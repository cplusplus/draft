<!DOCTYPE html><html><head><title>C++ Editor's Report, May 2013</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif"><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab"><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Archivo+Black"><style>.content {
  font-family: Droid Serif;
  max-width: 600px;
}
.papers {
  list-style: none;
}
.paper {
  margin-bottom: 4px;
}
.paperdetail {
  font-family: Roboto Slab;
  font-size: small;
  color: #444;
  background-color: #ccc;
  font-style: italic;
  border-radius: 5px;
  padding: 5px;
  margin-top: 2px;
}
.issues {
  list-style: none;
}
.issue {
  margin-bottom: 4px;
}
.issuedetail {
  font-family: Roboto Slab;
  font-size: small;
  color: #444;
  background-color: #ccc;
  font-style: italic;
  border-radius: 5px;
  padding: 5px;
  margin-top: 2px;
}
.stat {
  font-family: Archivo Black;
  font-size: 64px;
  color: #228;
}
.docheader {
  float: right;
  margin-right: 20px;
}</style></head><body><pre class="docheader">Document number  N3692
Date             2013-05-16
Project          Programming Language C++
Reference        ISO/IEC IS 14882:2011(E)
Reply to         Stefanus Du Toit
                 Intel
                 stefanus.du.toit@intel.com</pre><div class="content"><h1>C++ Editor's Report, May 2013</h1><h3>Overview</h3><h4>New Papers</h4><p>N3690 is the C++14 Committee Draft.
N3691 is the latest C++ Working Draft. Other than the front cover, its
contents are identical to N3690.
Both papers contain the <a href="#changes">changes listed below</a>.</p><h4>Acknowledgements</h4><p>Thank you to Jonathan Wakely for providing git patches to the draft source
for nearly all LWG papers.</p><p>Thank you to Richard Smith for providing git patches to the draft source
for his paper, N3652, Relaxing constraints on constexpr functions, and to
Jeffrey Yasskin for providing patches for his paper, N3668,
<code>std::exchange</code>.</p><p>Thank you to the editor's committee for reviewing the C++14 Committee Draft.
The editor's committee for the C++14 CD consists of:
Alisdair Meredith, Daniel Kr&uuml;gler, Richard Smith, and Mike Miller.</p><p>Thank you to everyone who provided editorial fixes to the draft. To submit a
fix, follow <a href="https://github.com/cplusplus/draft/wiki/How-to-submit-an-editorial-issue">these instructions</a>.</p><p>Thank you to my employer, <a href="http://www.intel.com/">Intel Corporation</a>,
for sponsoring my work as project editor.</p><h3><a name="changes">Working Draft Changes</a></h3><h4>Statistics</h4><p class="stats">The latest draft adds wording from<br/>
<span class="stat">64</span> <a href="#cwgissues">CWG issues</a>,
<span class="stat">11</span> <a href="#cwgpapers">CWG papers</a>,<br/>
<span class="stat">36</span> <a href="#lwgissues">LWG issues</a>,
<span class="stat">14</span> <a href="#lwgpapers">LWG papers</a>,<br/>
<span class="stat">5</span> <a href="#sg1issues">SG1 issues</a>, and
<span class="stat">1</span> <a href="#sg1papers">SG1 paper</a>.</p><h4><a name="cwgissues">CWG Issues Applied</a></h4><p>Resolutions from the following CWG issues were applied:</p><ul class="issues"><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#223"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#223">CWG223</a></a> The meaning of deprecation</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#496">CWG496</a> Is a volatile-qualified type really a POD?</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#616">CWG616</a> Definition of &quot;indeterminate value&quot;<div class="issuedetail">Also resolves <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#129">CWG129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#240">CWG240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#312">CWG312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1013">CWG1013</a>.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1310">CWG1310</a> What is an &quot;acceptable lookup result?&quot;</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1318">CWG1318</a> Syntactic ambiguities with final</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1320">CWG1320</a> Converting scoped enumerations to bool</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1374">CWG1374</a> Qualification conversion vs difference in reference binding<div class="issuedetail">Proposed wording tweaked slightly during application to add a missing
"or, if not that," to the now second-to-last bullet. Confirmed as the
right thing to do by Mike Miller.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1405">CWG1405</a> constexpr and mutable members of literal types</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1328">CWG1328</a> Conflict in reference binding vs overload resolution</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1330">CWG1330</a> Delayed instantiation of noexcept specifiers<div class="issuedetail">Context in proposed wording did not precisely match the wording as
in N3485. Confirmed with Mike Miller that the end state should be
"...shall not denote an incomplete type or an rvalue reference type."
in the relevant sentence.</div><div class="issuedetail">Added a comma after "e.g." - typo in proposed resolution.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1411">CWG1411</a> More on global scope :: in nested-name-specifier</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1412">CWG1412</a> Problems in specifying pointer conversions</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1413">CWG1413</a> Missing cases of value-dependency</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1425">CWG1425</a> Base-class subobjects of standard-layout structs</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1435">CWG1435</a> template-id as the declarator for a class template constructor</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1437">CWG1437</a> alignas in alias-declaration</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1442">CWG1442</a> Argument-dependent lookup in the range-based for</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1456">CWG1456</a> Address constant expression designating the one-past-the-end address</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1472">CWG1472</a> odr-use of reference variables</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1475">CWG1475</a> Errors in [[carries_dependency]] example</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1476">CWG1476</a> Definition of user-defined type</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1479">CWG1479</a> Literal operators and default arguments</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1481">CWG1481</a> Increment/decrement operators with reference parameters</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1489">CWG1489</a> Is value-initialization of an array constant initialization?</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1495">CWG1495</a> Partial specialization of variadic class template</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1502">CWG1502</a> Value initialization of unions with member initializers</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1503">CWG1503</a> Exceptions during copy to exception object</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1504">CWG1504</a> Pointer arithmetic after derived-base conversion</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1506">CWG1506</a> Value category of initializer_list object</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1510">CWG1510</a> cv-qualified references via decltype</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1511">CWG1511</a> const volatile variables and the one-definition rule</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1515">CWG1515</a> Modulo 2^n arithmetic for implicitly-unsigned types</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1516">CWG1516</a> Definition of "virtual function call"</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1522">CWG1522</a> Access checking for initializer_list array initialization</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1527">CWG1527</a> Assignment from braced-init-list</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1528">CWG1528</a> Repeated cv-qualifiers in declarators</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1532">CWG1532</a> Explicit instantiation and member templates</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1533">CWG1533</a> Function pack expansion for member initialization</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1535">CWG1535</a> typeid in core constant expressions</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1537">CWG1537</a> Optional compile-time evaluation of constant expressions</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1538">CWG1538</a> C-style cast in braced-init-list assignment</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1539">CWG1539</a> Definition of "character type"</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1541">CWG1541</a> cv void return types</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1543">CWG1543</a> Implicit conversion sequence for empty initializer list<div class="issuedetail">Fix transcription problem in proposed wording:
<code>initializer_list</code> -> <code>initializer_list&lt;int&gt;</code>
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1544">CWG1544</a> Linkage of member of unnamed namespace</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1550">CWG1550</a> Parenthesized throw-expression operand of conditional-expression<div class="issuedetail">Also resolves <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1560">CWG1560</a>.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1553">CWG1553</a> sizeof and xvalue bit-fields</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1556">CWG1556</a> Constructors and explicit conversion functions in direct initialization</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1557">CWG1557</a> Language linkage of converted lambda function pointer</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1464">CWG1464</a> Negative array bound in a new-expression<div class="issuedetail">Also resolves <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1559">CWG1559</a>.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1462">CWG1462</a> Deduction failure vs "ill-formed, no diagnostic required"</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1471">CWG1471</a> Nested type of non-dependent base</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1473">CWG1473</a> Syntax of literal-operator-id</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1477">CWG1477</a> Definition of a friend outside its namespace</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1482">CWG1482</a> Point of declaration of enumeration<div class="issuedetail">Also resolved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#977">CWG977</a>.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1487">CWG1487</a> When are inheriting constructors declared?</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1494">CWG1494</a> Temporary initialization for reference binding in list-initialization</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1507">CWG1507</a> Value initialization with trivial inaccessible default constructor</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1563">CWG1563</a> List-initialization and overloaded function disambiguation</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1605">CWG1605</a> Misleading parenthetical comment for explicit destructor call</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#903">CWG903</a> Value-dependent integral null pointer constants<div class="issuedetail">Minor tweak to the proposed resolution: in [dcl.init]/5, added "the"
to "...obtained by converting *the* integer literal 0 (zero)".</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1213">CWG1213</a> Array subscripting and xvalues</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1358">CWG1358</a> Unintentionally ill-formed constexpr function template instances<div class="issuedetail">October 2012 Proposed Resolution.</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#974">CWG974</a> Default arguments for lambdas</li></ul><h4><a name="cwgpapers">CWG Papers Applied</a></h4><p>Proposed wording from the following CWG papers was applied:</p><ul class="papers"><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3472">N3472</a> Binary Literals in the C++ Core Language<div class="paperdetail">Appendix A (grammar summary) also updated.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3624">N3624</a> Pointer comparison vs qualification conversions<div class="paperdetail">In the additions to [expr], terms like T1, C1, etc., were typeset in code font.</div><div class="paperdetail">"pointers to member" was replaced by "pointers to members" in accordance with
existing practice in the standard.</div><div class="paperdetail">In the new paragraph at the end of [expr], the reference to
"expr.qual" was fixed to refer to "conv.qual".</div><div class="paperdetail">operator== and operator!= in body text were changed to "the ==
operator" and "the != operator" respectively. This makes it clear
that we are not talking about overloaded operators here.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639">N3639</a> Runtime-sized arrays with automatic storage duration<div class="paperdetail">In [dcl.array]/1, removed bullet points from the last part of the major
bits of added text. The bulleted list was preceded by nothing and appeared
out of nowhere.</div><div class="paperdetail">Added an index entry for "array of runtime bound" and "runtime bound, array of".</div><div class="paperdetail">In [support.dynamic], bad_array_length also added to &lt;new&gt; synopsis.</div><div class="paperdetail">Typeset types in comments to [dcl.array]/1 as code, including two existing
instances not added by the paper.</div><div class="paperdetail">Improved grammar as follows:
"is invoked ... after the lifetime of the array ended" -> "... has ended"</div><div class="paperdetail">Rearranged commas in [dcl.fct]/8 for consistent and correct grammar.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3648">N3648</a> Wording Changes for Generalized Lambda-capture<div class="paperdetail">Grammar reference updated.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653">N3653</a> Member initializers and aggregates</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664">N3664</a> Clarifying Memory Allocation<div class="paperdetail">"size parameter" changed to  "size argument" in reference to an allocation
function.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3667">N3667</a> Drafting for Core 1402</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3651">N3651</a> Variable Templates (Revision 1)<div class="paperdetail">The example requested by change set 6 was merged into the existing
example for that paragraph.</div><div class="paperdetail">The order of "class/function/variable" was kept consistent in applying
change 8 in [temp.inst].</div><div class="paperdetail">I struck "member function" from the added sentence
"If the explicit instantiation is for a variable or member function,
the unqualified-id in the declaration shall be a template-id." because
that case was already covered in the existing text.</div><div class="paperdetail">I reordered the appearance of "variable template" to make it
consistent with the rest of the section in a few paragraphs.</div><div class="paperdetail">I formatted "const" in "const variables" as fixed-width.</div><div class="paperdetail">I added a missing "a" to "has constexpr specifier" in the existing
text.</div><div class="paperdetail">I changed "template&lt;typename T&gt;" to "template&lt;class T&gt;" for
consistency with existing examples in the clause.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638">N3638</a> Return type deduction for normal functions<div class="paperdetail">The grammar reference was updated.</div><div class="paperdetail">N3638 was based off an earlier draft than N3485. This caused some
conflicts in the middle of the [dcl.spec.auto] changes. These were
resolved based on feedback from the paper author.</div><div class="paperdetail">Replaced dangling non-normative sentence referring to
[dcl.spec.auto] from [dcl.type.simple] with a non-normative note to
make the paragraph easier to read.</div><div class="paperdetail">Avoided sentence starting with a conjunction ("But once a return ...")
and instead use "..., however, ...".</div><div class="paperdetail">Removed single quotation marks from "instantiates both 'f's".</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3649">N3649</a> Generic (Polymorphic) Lambda Expressions (Revision 3)<div class="paperdetail">Because of conflicts with N3638, I had to change the [dcl.spec.auto]
changes quite a bit, and I recommend CWG create an issue to review the
merged state.</div><div class="paperdetail">In the example provided (f1, f2, g, h, glambda), it is not clear to me
what "ID" refers to in comments like "error: ID is not convertible".</div><div class="paperdetail">Removed code font from "const" and "inline" in sentence usage, e.g. in
"For a generic lambda, the closure type has a public inline function".
An editorial issue was opened to make this consistent throughout the
draft.</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652">N3652</a> Relaxing constraints on constexpr functions<div class="paperdetail">Conflicts resolved as indicated by N3652.</div><div class="paperdetail">In [class.copy]/26 replaced "copy/move each direct base class" with
"copy/move each direct base class subobject" to make wording
consistent with other section above, as suggested by CWG chair.
</div></li></ul><h4><a name="lwgissues">LWG Issues Applied</a></h4><p>Resolutions from the following LWG issues were applied:</p><ul class="issues"><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2091">LWG2091</a> Misplaced effect in m.try_lock_for()</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2092">LWG2092</a> Vague Wording for condition_variable_any<div class="issuedetail">This change was made in [thread.condition.condvar] as the context and
issue description would suggest, rather than
[thread.timedmutex.requirements] as the proposed wording indicates
(presumably a copy-o from issue 2091).
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2145">LWG2145</a> error_category default constructor</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2147">LWG2147</a> Unclear hint type in Allocator's allocate function<div class="issuedetail">"possibly const" formatted with "const" in code font, since that is
the prevalent (though not uniform) style in the draft.
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2163">LWG2163</a> nth_element requires inconsistent post-conditions</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2169">LWG2169</a> Missing reset() requirements in unique_ptr specialization</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2172">LWG2172</a> Does atomic_compare_exchange_* accept v == nullptr arguments?</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2080">LWG2080</a> Specify when once_flag becomes invalid</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2144">LWG2144</a> Missing noexcept specification in type_index</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2174">LWG2174</a> wstring_convert::converted() should be noexcept</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2175">LWG2175</a> wstring_convert and wbuffer_convert validity<div class="issuedetail">Improved the grammar of the first added sentence with a comma.
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2177">LWG2177</a> Requirements on Copy/MoveInsertable<div class="issuedetail">I rephrased the new wording for grammar and clarity. Specifically, I
replaced "when evaluated the following postconditions hold" with
"its evaluation causes the following postcondition to hold" and I
changed "satisfying the MoveInsertable requirements" to "T being
MoveInsertable into X".
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2187">LWG2187</a> vector<bool> is missing emplace and emplace_back member functions</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2197">LWG2197</a> Specification of is_[un]signed unclear for non-arithmetic types</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2200">LWG2200</a> Data race avoidance for all containers, not only for sequences</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2211">LWG2211</a> Replace ambiguous use of "Allocator" in container requirements</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2222">LWG2222</a> Inconsistency in description of forward_list::splice_after single-element overload</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2225">LWG2225</a> Unrealistic header inclusion checks required</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2231">LWG2231</a> DR 704 removes complexity guarantee for clear()<div class="issuedetail">General issues with this table logged at
https://github.com/cplusplus/draft/issues/120
</div></li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2209">LWG2209</a> assign() overspecified for sequence containers</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2109">LWG2109</a> Incorrect requirements for hash specializations</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2093">LWG2093</a> Throws clause of condition_variable::wait with predicate<div class="issuedetail">I edited the first sentence of the new paragraph in
[thread.req.timing] for improved grammar and clarity.
</div><div class="issuedetail">I introduced the term "timeout-related exceptions" to make it clear
what is referred to by that phrase later on.
</div><div class="issuedetail">I dropped "any" from "any timeout-related exceptions" in some of the
Throws clauses modified to by the proposed wording to be consistent
with the other Throws clauses.
</div></li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2094</a> duration conversion overflow shouldn't participate in overload resolution</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2148</a> Hashing enums should be supported directly by std::hash</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2149</a> Concerns about 20.8/5</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2162</a> allocator_traits::max_size missing noexcept</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2176</a> Special members for wstring_convert and wbuffer_convert</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2207</a> basic_string::at should not have a Requires clause</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2229</a> Standard code conversion facets underspecified</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2235</a> Undefined behavior without proper requirements on basic_string constructors</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2128</a> Absence of global functions cbegin/cend</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2203</a> scoped_allocator_adaptor uses wrong argument types for piecewise construction</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2122</a> merge() stability for lists versus forward lists</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2196</a> Specification of is_*[copy/move]_[constructible/assignable] unclear for non-referencable types</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2210</a> Missing allocator-extended constructor for allocator-aware containers</li><li class="issue"><a href="http://wiki.edg.com/twiki/pub/Wg21bristol/FormalMotions/N3673.html">LWG2098</a> Minor Inconsistency between promise::set_value and promise::set_value_at_thread_exit</li></ul><h4><a name="lwgpapers">LWG Papers Applied</a></h4><p>Proposed wording from the following LWG papers was applied:</p><ul class="papers"><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668">N3668</a> exchange() utility function, revision 3</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3545">N3545</a> An Incremental Improvement to integral_constant</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644">N3644</a> Null Forward Iterators</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658">N3658</a> Compile-time integer sequences<div class="paperdetail">Includes editorial change to simplify example with return type
deduction (as discussed by LWG) as allowed by N3638.</div><div class="paperdetail">Updated the overview table in [utilities.general].
</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3670">N3670</a> Wording for Addressing Tuples by Type: Revision 2</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671">N3671</a> Making non-modifying sequence operations more robust: Revision 2</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656">N3656</a> make_unique (Revision 1)<div class="paperdetail">The new overloads were also added to the <memory> synopsis.</div><div class="paperdetail">Whitespace was tweaked to match the surrounding text.
</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3654">N3654</a> Quoted Strings Library Proposal (Revision 2)</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642">N3642</a> User-defined Literals for Standard Library Types (part 1 - version 4)<div class="paperdetail">Re-ordered the basic_string literals so they are listed in the order char, char16_t, char32_t and wchar_t. This matches the other functions in Clause 21.</div><div class="paperdetail">Changed const char *str to const char* str for consistency with asterisk placement in basic_string itself.</div><div class="paperdetail">Changed operator"" to operator "" for consistency with core wording.</div><div class="paperdetail">Added whitespace to duration literal declarations so they are aligned</div><div class="paperdetail">Changed section title to "Suffixes for duration literals" instead of "Suffix for duration literals"</div><div class="paperdetail">Use string, u16string etc. typedefs for basic_string</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657">N3657</a> Adding heterogeneous comparison lookup to associative containers (rev 4)</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672">N3672</a> A proposal to add a utility class to represent optional objects (Revision 4)<div class="paperdetail">Updated the overview table in [utilities.general].</div><div class="paperdetail">Placed after compile-time integer sequences.</div><div class="paperdetail">Reorganized [optional.defs]/1 as an itemized list.</div><div class="paperdetail">Reworded [optional.object]/2.</div><div class="paperdetail">Reworded [optional.object.ctor]/2.</div><div class="paperdetail">Added constexpr specifier to constructor declarations to match synopsis and Remarks.</div><div class="paperdetail">Corrected [optional.object.observe]/18 to depend on both constructors.</div><div class="paperdetail">Capitalized first letter of Remarks for operator bool().</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669">N3669</a> Fixing constexpr member functions without const</li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662">N3662</a> C++ Dynamic Arrays<div class="paperdetail">Placed between deque and forward_list, as opposed to at the very
end of [sequences].</div><div class="paperdetail">Removed Allocator template parameter from comparison operators.</div><div class="paperdetail">Used 'template &lt;class T&gt;' instead of 'template&lt; typename T &gt;'.</div><div class="paperdetail">Declared member types public.</div><div class="paperdetail">Referred to 23.2 for implementation-defined iterator types.</div><div class="paperdetail">Added 'explicit' keyword to first declaration in [dynarray.cons].</div></li><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655">N3655</a> TransformationTraits Redux, v2<div class="paperdetail">Section 4 of the proposal was not applied, as per the LWG motion.</div><div class="paperdetail">The added text was interspersed with the corresponding groups of
type declarations.
</div></li></ul><h4><a name="sg1issues">SG1 Issues Applied</a></h4><p>Resolutions from the following SG1 (Concurrency) issues were applied:</p><ul class="issues"><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2130">LWG2130</a> Missing ordering constraints</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2138">LWG2138</a> atomic_flag::clear should not accept memory_order_consume</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2140">LWG2140</a> Meaning of notify_all_at_thread_exit synchronization requirement?</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2190">LWG2190</a> Condition variable specification</li><li class="issue"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3522.html#2185">LWG2185</a> Missing throws clause for future/shared_future::wait_for/wait_until</li></ul><h4><a name="sg1papers">SG1 Papers Applied</a></h4><p>Proposed wording from the following SG1 (Concurrency) papers was applied:</p><ul class="papers"><li class="paper"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3659">N3659</a> Shared locking in C++, Revision 2</li></ul><h4>Minor editorial changes</h4><p>For a full list of editorial changes, please see the <a href="http://github.com/cplusplus/draft/commits">C++ draft repository on GitHub</a>.</p></div></body></html>