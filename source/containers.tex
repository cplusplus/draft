%!TEX root = std.tex
\rSec0[containers]{Containers library}

\rSec1[containers.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to
organize collections of information.

\pnum
The following subclauses describe
container requirements,
and components for
sequence containers and
associative containers,
as summarized in
\tref{containers.lib.summary}.

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
\ref{container.requirements} & Requirements                     &                           \\ \rowsep
\ref{sequences}              & Sequence containers              & \tcode{<array>}         \\
                             &                                  & \tcode{<deque>}         \\
                             &                                  & \tcode{<forward_list>}  \\
                             &                                  & \tcode{<list>}          \\
                             &                                  & \tcode{<vector>}        \\ \rowsep
\ref{associative}            & Associative containers           & \tcode{<map>}           \\
                             &                                  & \tcode{<set>}           \\ \rowsep
\ref{unord}                  & Unordered associative containers & \tcode{<unordered_map>} \\
                             &                                  & \tcode{<unordered_set>} \\ \rowsep
\ref{container.adaptors}     & Container adaptors               & \tcode{<queue>}         \\
                             &                                  & \tcode{<stack>}         \\ \rowsep
\ref{views}                  & Views                            & \tcode{<span>}          \\ \rowsep
\end{libsumtab}


\rSec1[container.requirements]{Container requirements}%
\indextext{requirements!container}

\rSec2[container.requirements.general]{General container requirements}

\pnum
Containers are objects that store other objects.
They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.

\pnum
All of the complexity requirements in this Clause are stated solely
in terms of the number of operations on the contained objects.
\begin{example}
The copy constructor of type
\tcode{vector<vector<int>>}
has linear complexity,
even though the complexity of copying each contained
\tcode{vector<int>}
is itself linear.
\end{example}

\pnum
For the components affected by this subclause that declare an \tcode{allocator_type},
objects stored in these components shall be constructed using the function
\tcode{allocator_traits<allocator_type>::rebind_traits<U>::\brk{}construct}
and destroyed using the function
\tcode{allocator_traits<allocator_type>::rebind_traits<U>::\brk{}destroy}\iref{allocator.traits.members},
where \tcode{U} is either \tcode{allocator_type::value_type} or
an internal type used by the container.
These functions are called only for the
container's element type, not for internal types used by the container. \begin{note} This
means, for example, that a node-based container might need to construct nodes containing
aligned buffers and call \tcode{construct} to place the element into the buffer.
\end{note}

\pnum
In Tables~\ref{tab:containers.container.requirements},
\ref{tab:containers.reversible.requirements}, and
\ref{tab:containers.optional.operations}
\tcode{X} denotes a container class containing objects of type
\tcode{T}, \tcode{a} and \tcode{b}
denote values of type \tcode{X}, \tcode{u}
denotes an identifier, \tcode{r} denotes
a non-const value of type \tcode{X}, and \tcode{rv}
denotes a non-const rvalue of type \tcode{X}.

\begin{libreqtab5}
{Container requirements}
{tab:containers.container.requirements}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre-/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre-/post-condition}   &      \\ \capsep
\endhead

\tcode{X::value_type}       &
 \tcode{T}                  &
                            &
 \requires\ \tcode{T} is \tcode{Erasable} from \tcode{X} (see~\ref{container.requirements.general}, below) &
 compile time               \\ \rowsep

\tcode{X::reference}        &
 \tcode{T\&}                &
                            &
                            &
 compile time               \\ \rowsep

\tcode{X::const_reference} &
 \tcode{const T\&}          &
                            &
                            &
 compile time               \\ \rowsep

\tcode{X::iterator}         &
 iterator type whose value type is \tcode{T} &
                            &
 any iterator category
 that meets the forward iterator requirements.
 convertible to \tcode{X::const_iterator}. &
 compile time               \\ \rowsep

\tcode{X::const_iterator}  &
 constant iterator type whose value type is \tcode{T} &
                            &
 any iterator category
 that meets the forward iterator requirements. &
 compile time               \\ \rowsep

\tcode{X::dif\-ference_type}    &
 signed integer type           &
                                &
 is identical to the difference type of \tcode{X::iterator} and \tcode{X::const_iterator} &
 compile time               \\ \rowsep

\tcode{X::size_type}        &
 unsigned integer type     &
                            &
 \tcode{size_type} can represent any non-negative value of \tcode{difference_type} &
 compile time                \\ \rowsep

\tcode{X u;}                &
                            &
                            &
 \postconditions \tcode{u.empty()}    &
 constant                   \\ \rowsep

\tcode{X()}                 &
                            &
                            &
 \postconditions \tcode{X().empty()}  &
 constant                   \\ \rowsep

\tcode{X(a)}                &
                            &
                            &
 \requires \tcode{T} is \tcode{CopyInsertable}
 into \tcode{X} (see below).\br \postconditions \tcode{a == X(a)}.         &
 linear                     \\ \rowsep

\tcode{X u(a);}\br
\tcode{X u = a;}            &
                            &
                            &
 \requires \tcode{T} is \tcode{CopyInsertable}
 into \tcode{X} (see below).\br
 \postconditions \tcode{u == a}       &
 linear                     \\ \rowsep

\tcode{X u(rv);}\br
\tcode{X u = rv;}            &
                            &
                            &
  \postconditions \tcode{u} shall be equal to the value that \tcode{rv} had before this construction
                            &
  (Note B)                  \\ \rowsep

\tcode{a = rv}              &
  \tcode{X\&}               &
  All existing elements of \tcode{a} are either move assigned to or destroyed   &
  \tcode{a} shall be equal to the value that \tcode{rv}
  had before this assignment   &
   linear                     \\ \rowsep

\tcode{(\&a)->\~X()}    &
 \tcode{void}               &
                            &
 the destructor is applied to every element of \tcode{a}; any memory obtained is deallocated. &
 linear                     \\ \rowsep

\tcode{a.begin()}           &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a} &
                            &
                            &
 constant                   \\ \rowsep

\tcode{a.end()}             &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a} &
                            &
                            &
 constant                   \\ \rowsep

\tcode{a.cbegin()}          &
 \tcode{const_iterator}     &
 \tcode{const_cast<\brk{}X const\&\brk{}>(a)\brk{}.begin();} &
                            &
 constant                   \\ \rowsep

\tcode{a.cend()}            &
 \tcode{const_iterator}     &
 \tcode{const_cast<\brk{}X const\&\brk{}>(a)\brk{}.end();} &
                            &
 constant                   \\ \rowsep

\tcode{a == b}                  &
 convertible to \tcode{bool}    &
 \tcode{==} is an equivalence relation.
 \tcode{equal(\brk{}a.begin(), a.end(), b.begin(), b.end())} &
 \requires\ \tcode{T} is \tcode{EqualityCompar\-a\-ble} &
 Constant if \tcode{a.size() != b.size()},
 linear otherwise                                   \\ \rowsep

\tcode{a != b}                      &
 convertible to \tcode{bool}        &
 Equivalent to \tcode{!(a == b)}   &
                                    &
 linear                             \\ \rowsep

\tcode{a.swap(b)}          &
 \tcode{void}               &
                            &
 exchanges the contents of \tcode{a} and \tcode{b}          &
 (Note A)                   \\ \rowsep

\tcode{swap(a, b)}          &
  \tcode{void}              &
  Equivalent to \tcode{a.swap(b)}         &
                            &
  (Note A)                  \\ \rowsep

\tcode{r = a}               &
 \tcode{X\&}                &
                            &
 \postconditions \tcode{r == a}.      &
 linear                     \\ \rowsep

\tcode{a.size()}                &
 \tcode{size_type}             &
 \tcode{distance(\brk{}a.begin(), a.end())}  &
                                &
 constant                       \\ \rowsep

\tcode{a.max_size()}        &
 \tcode{size_type}         &
 \tcode{distance(\brk{}begin(), end())}
 for the largest possible container &
                            &
 constant                   \\ \rowsep

\tcode{a.empty()}               &
 convertible to \tcode{bool}    &
 \tcode{a.begin() == a.end()}          &
                                &
constant                        \\

\end{libreqtab5}

Those entries marked ``(Note A)'' or ``(Note B)''
have linear complexity for \tcode{array} and have constant complexity
for all other standard containers.
\begin{note}
The algorithm \tcode{equal()} is defined in \ref{algorithms}.
\end{note}

\pnum
The member function \tcode{size()} returns the number of elements in the container.
The number of elements is defined by the rules of
constructors, inserts, and erases.

\pnum
\tcode{begin()}
returns an iterator referring to the first element in the container.
\tcode{end()}
returns an iterator which is the past-the-end value for the container.
If the container is empty, then
\tcode{begin() == end()}.

\pnum
In the expressions
\begin{codeblock}
i == j
i != j
i < j
i <= j
i >= j
i > j
i - j
\end{codeblock}
where \tcode{i} and \tcode{j} denote objects of a container's \tcode{iterator}
type, either or both may be replaced by an object of the container's
\tcode{const_iterator} type referring to the same element with no change in semantics.

\pnum
Unless otherwise specified, all containers defined in this clause obtain memory
using an allocator (see~\ref{allocator.requirements}).
\begin{note} In particular, containers and iterators do not store references
to allocated elements other than through the allocator's pointer type,
i.e., as objects of type \tcode{P} or
\tcode{pointer_traits<P>::template re\-bind<\unspec>},
where \tcode{P} is \tcode{allocator_traits<allocator_type>::pointer}. \end{note}
Copy constructors for these container types obtain an allocator by calling
\tcode{allocator_traits<allocator_type>::select_on_container_copy_construction}
on the allocator belonging to the container being copied.
Move constructors obtain an allocator by move construction from the allocator belonging to
the container being moved. Such move construction of the allocator shall not exit via an
exception.
All other constructors for these container types take a
\tcode{const allocator_type\&} argument.
\begin{note} If an invocation of a constructor uses the default value of an optional
allocator argument, then the \tcode{Allocator} type must support value-initialization.
\end{note}
A copy of this allocator is used for any memory allocation and element construction
performed, by these constructors and by all member functions,
during the lifetime of each container object
or until the allocator is replaced. The allocator may be replaced only via assignment or
\tcode{swap()}. Allocator replacement is performed by
copy assignment, move assignment, or swapping of the allocator only if
\tcode{allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value},
\tcode{allocator_traits<allocator_type>::propagate_on_container_move_assignment::value},
or \tcode{alloca\-tor_traits<allocator_type>::propagate_on_container_swap::value} is \tcode{true}
within the implementation of the corresponding container operation.
In all container types defined in this Clause, the member \tcode{get_allocator()}
returns a copy of the allocator used to construct the container or, if that allocator
has been replaced, a copy of the most recent replacement.

\pnum
The expression \tcode{a.swap(b)}, for containers \tcode{a} and \tcode{b} of a standard
container type other than \tcode{array}, shall exchange the values of \tcode{a} and
\tcode{b} without invoking any move, copy, or swap operations on the individual
container elements.
Lvalues of any \tcode{Compare}, \tcode{Pred}, or \tcode{Hash} types
belonging to \tcode{a} and \tcode{b} shall be swappable
and shall be exchanged by calling \tcode{swap}
as described in~\ref{swappable.requirements}. If
\tcode{allocator_traits<allocator_type>::propagate_on_container_swap::value} is
\tcode{true}, then
lvalues of type \tcode{allocator_type} shall be swappable and
the allocators of \tcode{a} and \tcode{b} shall also be exchanged
by calling \tcode{swap} as described in~\ref{swappable.requirements}.
Otherwise, the allocators shall not be swapped, and the behavior is
undefined unless \tcode{a.get_allocator() == b.get_allocator()}. Every iterator
referring to an element in one container before the swap shall refer to the same
element in the other container after the swap. It is unspecified whether an iterator
with value \tcode{a.end()} before the swap will have value \tcode{b.end()} after the
swap.

\pnum
If the iterator type of a container belongs to the bidirectional or
random access iterator categories\iref{iterator.requirements},
the container is called
\term{reversible}
and satisfies the additional requirements
in \tref{containers.reversible.requirements}.

\begin{libreqtab4a}
{Reversible container requirements}
{tab:containers.reversible.requirements}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{pre-/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{pre-/post-condition}   &      \\ \capsep
\endhead
\tcode{X::reverse_iterator}            &
iterator type whose value type is \tcode{T}    &
 \tcode{reverse_iterator<iterator>}   &
 compile time                           \\ \rowsep
\tcode{X::const_reverse_iterator}         &
 constant iterator type whose value type is \tcode{T}  &
 \tcode{reverse_iterator<const_iterator>}    &
 compile time                               \\ \rowsep
\tcode{a.rbegin()}                  &
 \tcode{reverse_iterator; const_reverse_iterator} for constant \tcode{a} &
 \tcode{reverse_iterator(end())}   &
 constant                           \\ \rowsep
\tcode{a.rend()}                     &
 \tcode{reverse_iterator; const_reverse_iterator} for constant \tcode{a} &
 \tcode{reverse_iterator(begin())}    &
 constant                           \\ \rowsep
\tcode{a.crbegin()}         &
 \tcode{const_reverse_iterator}     &
 \tcode{const_cast<X const\&>(a).rbegin()} &
 constant                   \\ \rowsep
\tcode{a.crend()}         &
 \tcode{const_reverse_iterator}     &
 \tcode{const_cast<X const\&>(a).rend()} &
 constant                   \\ \rowsep
\end{libreqtab4a}

\pnum
Unless otherwise specified (see~\ref{associative.reqmts.except}, \ref{unord.req.except}, \ref{deque.modifiers}, and
\ref{vector.modifiers})
all container types defined in this Clause meet
the following additional requirements:

\begin{itemize}
\item
if an exception is thrown by an
\tcode{insert()} or \tcode{emplace()}
function while inserting a single element, that
function has no effects.
\item
if an exception is thrown by a
\tcode{push_back()},
\tcode{push_front()},
\tcode{emplace_back()}, or \tcode{emplace_front()}
function, that function has no effects.
\item
no
\tcode{erase()},
\tcode{clear()},
\tcode{pop_back()}
or
\tcode{pop_front()}
function throws an exception.
\item
no copy constructor or assignment operator of a returned iterator
throws an exception.
\item
no
\tcode{swap()}
function throws an exception.
\item
no
\tcode{swap()}
function invalidates any references,
pointers, or iterators referring to the elements
of the containers being swapped. \begin{note} The \tcode{end()} iterator does not refer to any element, so it may be invalidated. \end{note}
\end{itemize}

\pnum
Unless otherwise specified (either explicitly or by defining a
function in terms of other functions), invoking a container member
function or passing a container as an argument to a library function
shall not invalidate iterators to, or change the values of, objects
within that container.

\pnum
\indextext{container!contiguous}%
A \defn{contiguous container}
is a container that supports random access iterators\iref{random.access.iterators}
and whose member types \tcode{iterator} and \tcode{const_iterator}
are contiguous iterators\iref{iterator.requirements.general}.

\pnum
\tref{containers.optional.operations} lists operations that are provided
for some types of containers but not others. Those containers for which the
listed operations are provided shall implement the semantics described in
\tref{containers.optional.operations} unless otherwise stated.

\begin{libreqtab5}
{Optional container operations}
{tab:containers.optional.operations}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre-/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre-/post-condition}   &      \\ \capsep
\endhead

\tcode{a < b}                   &
 convertible to \tcode{bool}    &
 \tcode{lexicographical_compare( a.begin(), a.end(), b.begin(), b.end())} &
 \requires \tcode{<} is defined for values of \tcode{T}. \tcode{<} is a total ordering relationship.    &
 linear                     \\ \rowsep

\tcode{a > b}                   &
 convertible to \tcode{bool}    &
 \tcode{b < a}                  &
                                &
 linear                         \\ \rowsep

\tcode{a <= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a > b)}               &
                                &
 linear                         \\ \rowsep

\tcode{a >= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a < b)}               &
                                &
 linear                         \\
\end{libreqtab5}

\begin{note}
The algorithm \tcode{lexicographical_compare()} is defined in \ref{algorithms}.
\end{note}

\pnum
All of the containers defined in this Clause and in~\ref{basic.string} except \tcode{array}
meet the additional requirements of an allocator-aware container, as described in
\tref{containers.allocatoraware}.

Given an allocator type \tcode{A}
and given a container type \tcode{X} having a \tcode{value_type} identical to \tcode{T}
and an \tcode{allocator_type} identical to \tcode{allocator_traits<A>::rebind_alloc<T>}
and given an lvalue \tcode{m} of type \tcode{A},
a pointer \tcode{p} of type \tcode{T*},
an expression \tcode{v} of type (possibly \tcode{const}) \tcode{T},
and an rvalue \tcode{rv} of type \tcode{T},
the following terms are defined. If \tcode{X}
is not allocator-aware, the terms below are defined as if \tcode{A} were
\tcode{allocator<T>} --- no allocator object needs to be created
and user specializations of \tcode{allocator<T>} are not instantiated:

\begin{itemize}
\item
\tcode{T} is \defnx{\tcode{DefaultInsertable} into \tcode{X}}
{DefaultInsertable into X@\tcode{DefaultInsertable} into \tcode{X}}
means that the following expression is well-formed:
\begin{codeblock}
allocator_traits<A>::construct(m, p)
\end{codeblock}

\item
An element of \tcode{X} is \defn{default-inserted} if it is initialized
by evaluation of the expression
\begin{codeblock}
allocator_traits<A>::construct(m, p)
\end{codeblock}
where \tcode{p} is the address of the uninitialized storage for the element
allocated within \tcode{X}.

\item
\tcode{T} is \defnx{\tcode{MoveInsertable} into \tcode{X}}
{MoveInsertable into X@\tcode{MoveInsertable} into \tcode{X}}
means that the following expression
is well-formed:
\begin{codeblock}
allocator_traits<A>::construct(m, p, rv)
\end{codeblock}
and its evaluation causes the following postcondition to hold: The value
of \tcode{*p} is equivalent to the value of \tcode{rv} before the evaluation.
\begin{note} \tcode{rv} remains a valid object. Its state is unspecified \end{note}

\item
\tcode{T} is \defnx{\tcode{CopyInsertable} into \tcode{X}}
{CopyInsertable into X@\tcode{CopyInsertable} into \tcode{X}}
means that, in addition to \tcode{T} being \tcode{MoveInsertable} into
\tcode{X}, the following expression is well-formed:
\begin{codeblock}
allocator_traits<A>::construct(m, p, v)
\end{codeblock}
and its evaluation causes the following postcondition to hold:
The value of \tcode{v} is unchanged and is equivalent to \tcode{*p}.

\item
\tcode{T} is
\defnx{\tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}}
{EmplaceConstructible into X from args@\tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}},
for zero
or more arguments \tcode{args}, means that the following expression is well-formed:
\begin{codeblock}
allocator_traits<A>::construct(m, p, args)
\end{codeblock}

\item
\tcode{T} is
\defnx{\tcode{Erasable} from \tcode{X}}
{Erasable from X@\tcode{Erasable} from \tcode{X}}
means that the following expression is well-formed:
\begin{codeblock}
allocator_traits<A>::destroy(m, p)
\end{codeblock}
\end{itemize}

\begin{note}
A container calls \tcode{allocator_traits<A>::construct(m, p, args)}
to construct an element at \tcode{p} using \tcode{args},
with \tcode{m == get_allocator()}.
The default \tcode{construct} in \tcode{allocator} will
call \tcode{::new((void*)p) T(args)},
but specialized allocators may choose a different definition.
\end{note}

\pnum
In \tref{containers.allocatoraware}, \tcode{X} denotes an allocator-aware container class
with a \tcode{value_type} of \tcode{T} using allocator of type \tcode{A}, \tcode{u} denotes a
variable,
\tcode{a} and \tcode{b} denote non-const lvalues of type \tcode{X},
\tcode{t} denotes an lvalue or a const rvalue of type \tcode{X}, \tcode{rv} denotes a
non-const rvalue of type \tcode{X}, and \tcode{m} is a value of type \tcode{A}.

\begin{libreqtab4a}
{Allocator-aware container requirements}
{tab:containers.allocatoraware}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{pre-/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\hline

\lhdr{Expression}       &   \chdr{Return type}  &
\chdr{Assertion/note}   &   \rhdr{Complexity}   \\
    &   &   \chdr{pre-/post-condition}   &      \\ \capsep
\endhead

\tcode{allocator_type}		&
  \tcode{A}								&
  \requires \tcode{allocator_type::value_type} is the same as \tcode{X::value_type}.					&
  compile time										\\ \rowsep

\tcode{get_-} \tcode{allocator()}	&
  \tcode{A}								&
																				&
  constant												\\ \rowsep

\tcode{X()}\br
\tcode{X u;}							&
													&
  \requires\ \tcode{A} is \tcode{DefaultConstructible}.\br
  \postconditions \tcode{u.empty()} returns \tcode{true},
  \tcode{u.get_allocator() == A()} &
  constant												\\ \rowsep

\tcode{X(m)}							&
																				&
\postconditions \tcode{u.empty()} returns \tcode{true}, &
constant												\\
\tcode{X u(m);}					&
																				&
\tcode{u.get_allocator() == m} &
																				\\ \rowsep

\tcode{X(t, m)}\br
\tcode{X u(t, m);}				&
                          &
\requires\ \tcode{T} is \tcode{CopyInsertable} into \tcode{X}.\br
\postconditions \tcode{u == t}, \tcode{u.get_allocator() == m} &
linear													\\ \rowsep

\tcode{X(rv)}\br
\tcode{X u(rv);}
           &
           &
  \postconditions \tcode{u} shall have the same elements as \tcode{rv} had before this
  construction; the value of \tcode{u.get_allocator()} shall be the same as the
  value of \tcode{rv.get_allocator()} before this construction. &
  constant                            \\ \rowsep

\tcode{X(rv, m)}\br
\tcode{X u(rv, m);}			&
												&
  \requires\ \tcode{T} is
  \tcode{MoveInsertable} into \tcode{X}.\br
  \postconditions \tcode{u} shall have the same elements,
  or copies of the elements, that \tcode{rv} had before
  this construction, \tcode{u.get_allocator() == m}												&
  constant if \tcode{m ==} \tcode{rv.get_allocator()}, otherwise linear	\\ \rowsep

\tcode{a = t}             &
  \tcode{X\&}             &
  \requires\ \tcode{T} is
  \tcode{CopyInsertable} into \tcode{X}
  and \tcode{CopyAssignable}.\br
  \postconditions \tcode{a == t}    &
  linear                  \\ \rowsep

\tcode{a = rv}          &
  \tcode{X\&}           &
  \requires\ If \tcode{allocator_-}\br
  \tcode{traits<allocator_type>}\br
  \tcode{::propagate_on_container_-}\br
  \tcode{move_assignment::value} is\br
  \tcode{false}, \tcode{T} is
  \tcode{MoveInsertable} into \tcode{X} and
  \tcode{MoveAssignable}. All existing elements of \tcode{a}
  are either move assigned to or destroyed.\br
  \postconditions \tcode{a} shall be equal to the value that \tcode{rv} had before
  this assignment.      &
  linear                \\ \rowsep

\tcode{a.swap(b)}       &
  \tcode{void}          &
  exchanges the contents of \tcode{a} and \tcode{b} &
  constant      \\ \rowsep

\end{libreqtab4a}

\pnum
The behavior of certain container member functions and deduction guides
depends on whether types qualify as input iterators or allocators.
The extent to which an implementation determines that a type cannot be an input
iterator is unspecified, except that as a minimum integral types shall not qualify
as input iterators.
Likewise, the extent to which an implementation determines that a type cannot be
an allocator is unspecified, except that as a minimum a type \tcode{A} shall not qualify
as an allocator unless it satisfies both of the following conditions:

\begin{itemize}
\item The \grammarterm{qualified-id} \tcode{A::value_type}
is valid and denotes a type\iref{temp.deduct}.

\item The expression \tcode{declval<A\&>().allocate(size_t\{\})}
is well-formed when treated as an unevaluated operand.
\end{itemize}

\rSec2[container.requirements.dataraces]{Container data races}

\pnum
For purposes of avoiding data races\iref{res.on.data.races}, implementations shall
consider the following functions to be \tcode{const}: \tcode{begin}, \tcode{end},
\tcode{rbegin}, \tcode{rend}, \tcode{front}, \tcode{back}, \tcode{data}, \tcode{find},
\tcode{lower_bound}, \tcode{upper_bound}, \tcode{equal_range}, \tcode{at} and, except in
associative or unordered associative containers, \tcode{operator[]}.

\pnum
Notwithstanding~\ref{res.on.data.races}, implementations are required to avoid data
races when the contents of the contained object in different elements in the same
container, excepting \tcode{vector<bool>}, are modified concurrently.

\pnum
\begin{note} For a \tcode{vector<int> x} with a size greater than one, \tcode{x[1] = 5}
and \tcode{*x.begin() = 10} can be executed concurrently without a data race, but
\tcode{x[0] = 5} and \tcode{*x.begin() = 10} executed concurrently may result in a data
race.
As an exception to the general rule, for a \tcode{vector<bool> y}, \tcode{y[0] = true}
may race with \tcode{y[1] = true}.
\end{note}

\rSec2[sequence.reqmts]{Sequence containers}

\pnum
A sequence container organizes a finite set of objects, all of the same type, into a strictly
linear arrangement. The library provides four basic kinds of sequence containers:
\tcode{vector}, \tcode{forward_list}, \tcode{list}, and \tcode{deque}. In addition,
\tcode{array} is provided as a sequence container which provides limited sequence operations
because it has a fixed number of elements. The library also provides container adaptors that
make it easy to construct abstract data types, such as \tcode{stack}s or \tcode{queue}s, out of
the basic sequence container kinds (or out of other kinds of sequence containers that the user
might define).

\pnum
\begin{note}
The sequence containers
offer the programmer different complexity trade-offs and should be used
accordingly.
\tcode{vector}
is the type of sequence container that should be used by default.
\tcode{array}
should be used when the container has a fixed size known during translation.
\tcode{list} or \tcode{forward_list}
should be used when there are frequent insertions and deletions from the
middle of the sequence.
\tcode{deque}
is the data structure of choice
when most insertions and deletions take place at the beginning or at the
end of the sequence.
When choosing a container, remember \tcode{vector} is best;
leave a comment to explain if you choose from the rest!
\end{note}

\pnum
In Tables~\ref{tab:containers.sequence.requirements}
and \ref{tab:containers.sequence.optional},
\tcode{X} denotes a sequence container class,
\tcode{a} denotes a value of type \tcode{X} containing elements of type \tcode{T},
\tcode{u} denotes the name of a variable being declared,
\tcode{A} denotes \tcode{X::allocator_type} if
the \grammarterm{qualified-id} \tcode{X::allocator_type} is valid and denotes a
type\iref{temp.deduct} and
\tcode{allocator<T>} if it doesn't,
\tcode{i} and \tcode{j}
denote iterators satisfying input iterator requirements
and refer to elements implicitly convertible to \tcode{value_type},
\tcode{[i, j)}
denotes a valid range,
\tcode{il} designates an object of type \tcode{initializer_list<value_type>},
\tcode{n}
denotes a value of type \tcode{X::size_type},
\tcode{p} denotes a valid constant iterator to
\tcode{a}, \tcode{q}
denotes a valid dereferenceable constant iterator to
\tcode{a}, \tcode{[q1, q2)}
denotes a valid range of constant iterators in
\tcode{a}, \tcode{t}
denotes an lvalue or a const rvalue of
\tcode{X::value_type}, and \tcode{rv} denotes
a non-const rvalue of \tcode{X::value_type}.
\tcode{Args} denotes a template parameter pack;
\tcode{args} denotes a function parameter pack with the pattern \tcode{Args\&\&}.

\pnum
The complexities of the expressions are sequence dependent.

\begin{libreqtab3}
{Sequence container requirements (in addition to container)}
{tab:containers.sequence.requirements}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Assertion/note}       \\
                        &                       &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Assertion/note}       \\
                        &                       &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{X(n, t)}\br
\tcode{X u(n, t);}   &
                &
 \requires\ \tcode{T} shall be
 \tcode{CopyInsertable} into \tcode{X}.\br
 \postconditions \tcode{distance(begin(), end()) == n}\br
 Constructs a sequence container with \tcode{n} copies of \tcode{t}  \\ \rowsep

\tcode{X(i, j)}\br
\tcode{X u(i, j);}   &
                    &
 \requires\ \tcode{T} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.
 For \tcode{vector}, if the iterator does
 not meet the forward iterator requirements\iref{forward.iterators}, \tcode{T}
 shall also be
 \tcode{MoveInsertable} into \tcode{X}.
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 \postconditions \tcode{distance(begin(), end()) ==}
 \tcode{distance(i, j)}\br
 Constructs a sequence container equal to the range \tcode{[i, j)}    \\ \rowsep

\tcode{X(il)}      &
                    &
  Equivalent to \tcode{X(il.begin(), il.end())} \\ \rowsep

\tcode{a = il}     &
  \tcode{X\&}               &
  \requires\ \tcode{T} is
  \tcode{CopyInsertable} into \tcode{X}
  and \tcode{CopyAssignable}.
  Assigns the range \range{il.begin()}{il.end()} into \tcode{a}. All existing
  elements of \tcode{a} are either assigned to or destroyed.\br
  \returns\ \tcode{*this}.
  \\ \rowsep

\tcode{a.emplace(p, args)}  &
 \tcode{iterator}            &
 \requires\ \tcode{T} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}. For \tcode{vector} and \tcode{deque},
 \tcode{T} is also
 \tcode{MoveInsertable} into \tcode{X} and \tcode{MoveAssignable}.
 \effects\ Inserts an object of type \tcode{T} constructed with
 \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...} before \tcode{p}.
 \begin{note} \tcode{args} may directly or indirectly refer to
 a value in \tcode{a}. \end{note}
 \\ \rowsep

\tcode{a.insert(p,t)}   &
 \tcode{iterator}       &
 \requires\ \tcode{T} shall be
 \tcode{CopyInsertable} into \tcode{X}. For \tcode{vector} and \tcode{deque},
 \tcode{T} shall also be \tcode{CopyAssignable}.\br
 \effects\ Inserts a copy of \tcode{t} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,rv)}   &
 \tcode{iterator}       &
 \requires\ \tcode{T} shall be
 \tcode{MoveInsertable} into \tcode{X}. For \tcode{vector} and \tcode{deque},
  \tcode{T} shall also be \tcode{MoveAssignable}.\br
 \effects\ Inserts a copy of \tcode{rv} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,n,t)}     &
 \tcode{iterator}               &
 \requires\ \tcode{T} shall be
 \tcode{CopyInsertable} into \tcode{X}
 and \tcode{CopyAssignable}.\br
 Inserts \tcode{n} copies of \tcode{t} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,i,j)}    &
 \tcode{iterator}           &
 \requires\ \tcode{T} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.
 For \tcode{vector} and \tcode{deque}, \tcode{T} shall also be
 \tcode{MoveInsertable} into \tcode{X}, \tcode{MoveConstructible}, \tcode{MoveAssignable},
 and swappable\iref{swappable.requirements}.
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 \requires \tcode{i} and \tcode{j} are not iterators into \tcode{a}.\br
 Inserts copies of elements in \tcode{[i, j)} before \tcode{p}  \\ \rowsep

\tcode{a.insert(p, il)}  &
  \tcode{iterator}            &
  \tcode{a.insert(p, il.begin(), il.end())}.  \\ \rowsep

\tcode{a.erase(q)}  &
 \tcode{iterator}   &
 \requires\ For \tcode{vector} and \tcode{deque},
 \tcode{T} shall be \tcode{MoveAssignable}.\br
 \effects\ Erases the element pointed to by \tcode{q}. \\ \rowsep

\tcode{a.erase(q1,q2)}  &
 \tcode{iterator}   &
 \requires\ For \tcode{vector} and \tcode{deque},
 \tcode{T} shall be \tcode{MoveAssignable}.\br
 \effects\ Erases the elements in the range \tcode{[q1, q2)}.  \\ \rowsep

\tcode{a.clear()}   &
 \tcode{void}       &
 Destroys all elements in \tcode{a}. Invalidates all references, pointers, and
 iterators referring to the elements of \tcode{a} and may invalidate the past-the-end iterator.\br
 \postconditions \tcode{a.empty()} returns \tcode{true}.\br
 \complexity Linear.      \\ \rowsep

\tcode{a.assign(i,j)}   &
 \tcode{void}           &
 \requires\ \tcode{T} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}
 and assignable from \tcode{*i}. For \tcode{vector}, if the iterator does not
 meet the forward iterator requirements\iref{forward.iterators}, \tcode{T}
 shall also be
 \tcode{MoveInsertable} into \tcode{X}.\br
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 \requires \tcode{i}, \tcode{j} are not iterators into \tcode{a}.\br
 Replaces elements in \tcode{a} with a copy of \tcode{[i, j)}.\br
 Invalidates all references, pointers and iterators
 referring to the elements of \tcode{a}.
 For \tcode{vector} and \tcode{deque},
 also invalidates the past-the-end iterator.  \\ \rowsep

\tcode{a.assign(il)}    &
  \tcode{void}          &
  \tcode{a.assign(il.begin(), il.end())}. \\ \rowsep

\tcode{a.assign(n,t)}   &
 \tcode{void}           &
 \requires\ \tcode{T} shall be
 \tcode{CopyInsertable} into \tcode{X}
 and \tcode{CopyAssignable}.\br
 \requires \tcode{t} is not a reference into \tcode{a}.\br
 Replaces elements in \tcode{a} with \tcode{n} copies of \tcode{t}.\br
 Invalidates all references, pointers and iterators
 referring to the elements of \tcode{a}.
 For \tcode{vector} and \tcode{deque},
 also invalidates the past-the-end iterator.  \\
\end{libreqtab3}

\pnum
The iterator returned from
\tcode{a.insert(p, t)}
points to the copy of
\tcode{t}
inserted into
\tcode{a}.

\pnum
The iterator returned from \tcode{a.insert(p, rv)} points to the copy of \tcode{rv}
inserted into \tcode{a}.

\pnum
The iterator returned from \tcode{a.insert(p, n, t)} points to the copy of the first
element inserted into \tcode{a}, or \tcode{p} if \tcode{n == 0}.

\pnum
The iterator returned from \tcode{a.insert(p, i, j)} points to the copy of the first
element inserted into \tcode{a}, or \tcode{p} if \tcode{i == j}.

\pnum
The iterator returned from \tcode{a.insert(p, il)} points to the copy of the first
element inserted into \tcode{a}, or \tcode{p} if \tcode{il} is empty.

\pnum
The iterator returned from \tcode{a.emplace(p, args)} points to the new element
constructed from \tcode{args} into \tcode{a}.

\pnum
The iterator returned from
\tcode{a.erase(q)}
points to the element immediately following
\tcode{q}
prior to the element being erased.
If no such element exists,
\tcode{a.end()}
is returned.

\pnum
The iterator returned by
\tcode{a.erase(q1, q2)}
points to the element pointed to by
\tcode{q2}
prior to any elements being erased.
If no such element exists,
\tcode{a.end()}
is returned.

\pnum
For every sequence container defined in this Clause and in \ref{strings}:
\begin{itemize}
\item If the constructor
\begin{codeblock}
template<class InputIterator>
  X(InputIterator first, InputIterator last,
    const allocator_type& alloc = allocator_type());
\end{codeblock}
is called with a type \tcode{InputIterator} that does not qualify as an input
iterator, then the constructor
shall not participate in overload resolution.

\item If the member functions of the forms:
\begin{codeblock}
template<class InputIterator>
  @\placeholdernc{return-type}@ @\placeholdernc{F}@(const_iterator p,
                InputIterator first, InputIterator last);       // such as \tcode{insert}

template<class InputIterator>
  @\placeholdernc{return-type}@ @\placeholdernc{F}@(InputIterator first, InputIterator last);       // such as \tcode{append}, \tcode{assign}

template<class InputIterator>
  @\placeholdernc{return-type}@ @\placeholdernc{F}@(const_iterator i1, const_iterator i2,
                InputIterator first, InputIterator last);       // such as \tcode{replace}
\end{codeblock}
are called with a type \tcode{InputIterator} that does not qualify as an input
iterator, then these functions
shall not participate in overload resolution.

\item A deduction guide for a sequence container shall not participate in overload resolution
if it has an \tcode{InputIterator} template parameter and a type that does not
qualify as an input iterator is deduced for that parameter,
or if it has an \tcode{Allocator} template parameter and a type that does not
qualify as an allocator is deduced for that parameter.
\end{itemize}

\pnum
\tref{containers.sequence.optional} lists operations
that are provided for some types of
sequence containers but not others.
An implementation shall provide
these operations for all container types shown in the ``container''
column, and shall implement them so as to take amortized constant
time.

\begin{libreqtab4a}
{Optional sequence container operations}
{tab:containers.sequence.optional}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational semantics}       &   \rhdr{Container}    \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational semantics}       &   \rhdr{Container}    \\ \capsep
\endhead

\tcode{a.front()}       &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*a.begin()}     &
 \tcode{basic_string},
 \tcode{array},
 \tcode{deque},
 \tcode{forward_list},
 \tcode{list},
 \tcode{vector}
 \\ \rowsep

\tcode{a.back()}        &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{\{ auto tmp = a.end();}\br
 \tcode{    \dcr tmp;}\br
 \tcode{    return *tmp; \}}    &
 \tcode{basic_string},
 \tcode{array},
 \tcode{deque},
 \tcode{list},
 \tcode{vector}
 \\ \rowsep

\tcode{a.emplace_\-front(args)}      &
 \tcode{reference}                &
 Prepends an object of type \tcode{T} constructed with \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...}.\br
 \requires\ \tcode{T} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
 \returns{} \tcode{a.front()}.  &
 \tcode{deque},
 \tcode{forward_list},
 \tcode{list}
 \\ \rowsep

\tcode{a.emplace_\-back(args)}      &
 \tcode{reference}                &
 Appends an object of type \tcode{T} constructed with \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...}.\br
 \requires\ \tcode{T} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}. For \tcode{vector}, \tcode{T}
 shall also be
 \tcode{MoveInsertable} into \tcode{X}.\br
 \returns{} \tcode{a.back()}.  &
 \tcode{deque},
 \tcode{list},
 \tcode{vector}
 \\ \rowsep

\tcode{a.push_front(t)} &
  \tcode{void}          &
  Prepends a copy of \tcode{t}.\br
  \requires\ \tcode{T} shall be
  \tcode{CopyInsertable} into \tcode{X}.
    &
  \tcode{deque},
  \tcode{forward_list},
  \tcode{list}
  \\ \rowsep

\tcode{a.push_front(rv)} &
  \tcode{void}          &
  Prepends a copy of \tcode{rv}.\br
  \requires\ \tcode{T} shall be
  \tcode{MoveInsertable} into \tcode{X}.
    &
  \tcode{deque},
  \tcode{forward_list},
  \tcode{list}
  \\ \rowsep

\tcode{a.push_back(t)} &
  \tcode{void}          &
  Appends a copy of \tcode{t}.\br
  \requires\ \tcode{T} shall be
  \tcode{CopyInsertable} into \tcode{X}.
    &
  \tcode{basic_string},
  \tcode{deque},
  \tcode{list},
  \tcode{vector}
  \\ \rowsep

\tcode{a.push_back(rv)} &
  \tcode{void}          &
  Appends a copy of \tcode{rv}.\br
  \requires\ \tcode{T} shall be
  \tcode{MoveInsertable} into \tcode{X}.
    &
  \tcode{basic_string},
  \tcode{deque},
  \tcode{list},
  \tcode{vector}
  \\ \rowsep

\tcode{a.pop_front()}      &
 \tcode{void}               &
 Destroys the first element.\br
 \requires\ \tcode{a.empty()} shall be \tcode{false}. &
 \tcode{deque},
 \tcode{forward_list},
 \tcode{list}
 \\ \rowsep

\tcode{a.pop_back()}       &
 \tcode{void}               &
 Destroys the last element.\br
 \requires\ \tcode{a.empty()} shall be \tcode{false}. &
 \tcode{basic_string},
 \tcode{deque},
 \tcode{list},
 \tcode{vector}
 \\ \rowsep

\tcode{a[n]}                &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{basic_string},
 \tcode{array},
 \tcode{deque},
 \tcode{vector}
 \\ \rowsep

\tcode{a.at(n)}             &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{basic_string},
 \tcode{array},
 \tcode{deque},
 \tcode{vector}
 \\

\end{libreqtab4a}

\pnum
The member function
\tcode{at()}
provides bounds-checked access to container elements.
\tcode{at()}
throws
\tcode{out_of_range}
if
\tcode{n >= a.size()}.


\rSec2[container.node]{Node handles}

\rSec3[container.node.overview]{Overview}

\pnum
A \defn{node handle} is an object that accepts ownership of a single element
from an associative container\iref{associative.reqmts} or an unordered
associative container\iref{unord.req}. It may be used to transfer that
ownership to another container with compatible nodes.  Containers with
compatible nodes have the same node handle type. Elements may be transferred in
either direction between container types in the same row of
\tref{containers.node.compat}.

\begin{floattable}{Container types with compatible nodes}{tab:containers.node.compat}
{ll}
\topline
\tcode{map<K, T, C1, A>}               & \tcode{map<K, T, C2, A>}                    \\
\rowsep
\tcode{map<K, T, C1, A>}               & \tcode{multimap<K, T, C2, A>}               \\
\rowsep
\tcode{set<K, C1, A>}                  & \tcode{set<K, C2, A>}                       \\
\rowsep
\tcode{set<K, C1, A>}                  & \tcode{multiset<K, C2, A>}                  \\
\rowsep
\tcode{unordered_map<K, T, H1, E1, A>} & \tcode{unordered_map<K, T, H2, E2, A>}      \\
\rowsep
\tcode{unordered_map<K, T, H1, E1, A>} & \tcode{unordered_multimap<K, T, H2, E2, A>} \\
\rowsep
\tcode{unordered_set<K, H1, E1, A>}    & \tcode{unordered_set<K, H2, E2, A>}         \\
\rowsep
\tcode{unordered_set<K, H1, E1, A>}    & \tcode{unordered_multiset<K, H2, E2, A>}    \\
\end{floattable}

\pnum
If a node handle is not empty, then it contains an allocator that is equal to
the allocator of the container when the element was extracted. If a node handle
is empty, it contains no allocator.

\pnum
Class \tcode{\placeholder{node_handle}} is for exposition only. An implementation is
permitted to provide equivalent functionality without providing a class with
this name.

\pnum
If a user-defined specialization of \tcode{pair} exists for
\tcode{pair<const Key, T>} or \tcode{pair<Key, T>}, where \tcode{Key} is the
container's \tcode{key_type} and \tcode{T} is the container's
\tcode{mapped_type}, the behavior of operations involving node handles is
undefined.

\begin{codeblock}
template<@\unspecnc@>
class @\placeholder{node_handle}@ {
public:
  // These type declarations are described in Tables \ref{tab:containers.associative.requirements} and \ref{tab:HashRequirements}.
  using value_type     = @\seebelownc{}@;     // not present for map containers
  using key_type       = @\seebelownc{}@;     // not present for set containers
  using mapped_type    = @\seebelownc{}@;     // not present for set containers
  using allocator_type = @\seebelownc{}@;

private:
  using container_node_type = @\unspecnc@;
  using ator_traits = allocator_traits<allocator_type>;

  typename ator_traits::rebind_traits<container_node_type>::pointer ptr_;
  optional<allocator_type> alloc_;

public:
  // \ref{container.node.cons}, constructors, copy, and assignment
  constexpr @\placeholdernc{node_handle}@() noexcept : ptr_(), alloc_() {}
  @\placeholdernc{node_handle}@(@\placeholdernc{node_handle}@&&) noexcept;
  @\placeholdernc{node_handle}@& operator=(@\placeholdernc{node_handle}@&&);

  // \ref{container.node.dtor}, destructor
  ~@\placeholdernc{node_handle}@();

  // \ref{container.node.observers}, observers
  value_type& value() const;            // not present for map containers
  key_type& key() const;                // not present for set containers
  mapped_type& mapped() const;          // not present for set containers

  allocator_type get_allocator() const;
  explicit operator bool() const noexcept;
  [[nodiscard]] bool empty() const noexcept;

  // \ref{container.node.modifiers}, modifiers
  void swap(@\placeholdernc{node_handle}@&)
    noexcept(ator_traits::propagate_on_container_swap::value ||
             ator_traits::is_always_equal::value);

  friend void swap(@\placeholdernc{node_handle}@& x, @\placeholdernc{node_handle}@& y) noexcept(noexcept(x.swap(y))) {
    x.swap(y);
  }
};
\end{codeblock}

\rSec3[container.node.cons]{Constructors, copy, and assignment}

\begin{itemdecl}
@\placeholdernc{node_handle}@(@\placeholdernc{node_handle}@&& nh) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{\placeholder{node_handle}} object initializing
\tcode{ptr_} with \tcode{nh.ptr_}.  Move constructs \tcode{alloc_} with
\tcode{nh.alloc_}.  Assigns \tcode{nullptr} to \tcode{nh.ptr_} and assigns
\tcode{nullopt} to \tcode{nh.alloc_}.
\end{itemdescr}

\begin{itemdecl}
@\placeholdernc{node_handle}@& operator=(@\placeholdernc{node_handle}@&& nh);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires Either \tcode{!alloc_}, or
\tcode{ator_traits::propagate_on_container_move_assignment}
is \tcode{true}, or \tcode{alloc_ ==  nh.alloc_}.

\pnum
\effects
\begin{itemize}
\item
If \tcode{ptr_ != nullptr}, destroys the \tcode{value_type}
subobject in the \tcode{container_node_type} object pointed to by \tcode{ptr_}
by calling \tcode{ator_traits::destroy}, then deallocates \tcode{ptr_} by
calling \tcode{ator_traits::rebind_traits<container_node_type>::deallocate}.
\item
Assigns \tcode{nh.ptr_} to \tcode{ptr_}.
\item
If \tcode{!alloc\textunderscore} or \tcode{ator_traits::propagate_on_container_move_assignment}
is \tcode{true}, move assigns \tcode{nh.alloc_} to \tcode{alloc_}.
\item
Assigns
\tcode{nullptr} to \tcode{nh.ptr_} and assigns \tcode{nullopt} to
\tcode{nh.alloc_}.
\end{itemize}

\pnum \returns \tcode{*this}.

\pnum \throws Nothing.
\end{itemdescr}

\rSec3[container.node.dtor]{Destructor}

\begin{itemdecl}
~@\placeholdernc{node_handle}@();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{ptr_ != nullptr}, destroys the \tcode{value_type} subobject
in the \tcode{container_node_type} object pointed to by \tcode{ptr_} by calling
\tcode{ator_traits::destroy}, then deallocates \tcode{ptr_} by calling
\tcode{ator_traits::rebind_traits<container_node_type>::deallocate}.
\end{itemdescr}

\rSec3[container.node.observers]{Observers}

\begin{itemdecl}
value_type& value() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{empty() == false}.

\pnum
\returns A reference to the \tcode{value_type} subobject in the
\tcode{container_node_type} object pointed to by \tcode{ptr_}.

\pnum
\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
key_type& key() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{empty() == false}.

\pnum
\returns A non-const reference to the \tcode{key_type} member of the
\tcode{value_type} subobject in the \tcode{contain\-er_node_type} object
pointed to by \tcode{ptr_}.

\pnum
\throws  Nothing.

\pnum
\remarks Modifying the key through the returned reference is permitted.
\end{itemdescr}

\begin{itemdecl}
mapped_type& mapped() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{empty() == false}.

\pnum
\returns A reference to the \tcode{mapped_type} member of the
\tcode{value_type} subobject in the \tcode{container_node_type} object
pointed to by \tcode{ptr_}.

\pnum
\throws  Nothing.
\end{itemdescr}


\begin{itemdecl}
allocator_type get_allocator() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{empty() == false}.

\pnum
\returns \tcode{*alloc_}.

\pnum
\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ptr_ != nullptr}.
\end{itemdescr}

\begin{itemdecl}
[[nodiscard]] bool empty() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ptr_ == nullptr}.
\end{itemdescr}

\rSec3[container.node.modifiers]{Modifiers}

\begin{itemdecl}
void swap(@\placeholdernc{node_handle}@& nh)
  noexcept(ator_traits::propagate_on_container_swap::value ||
           ator_traits::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!alloc_}, or \tcode{!nh.alloc_}, or
\tcode{ator_traits::propagate_on_container_swap} is \tcode{true},
or \tcode{alloc_ == nh.alloc_}.

\pnum
\effects Calls \tcode{swap(ptr_, nh.ptr_)}. If \tcode{!alloc_}, or
\tcode{!nh.alloc_}, or \tcode{ator_traits::propagate_on_container_swap}
is \tcode{true} calls \tcode{swap(alloc_, nh.alloc_)}.
\end{itemdescr}

\rSec2[container.insert.return]{Insert return type}

\pnum
The associative containers with unique keys and the unordered containers with unique keys
have a member function \tcode{insert} that returns a nested type \tcode{insert_return_type}.
That return type is a specialization of the type specified in this subclause.

\begin{codeblock}
template<class Iterator, class NodeType>
struct @\placeholder{INSERT_RETURN_TYPE}@
{
  Iterator position;
  bool     inserted;
  NodeType node;
};
\end{codeblock}

\pnum
The name \tcode{\placeholder{INSERT_RETURN_TYPE}} is exposition only.
\tcode{\placeholder{INSERT_RETURN_TYPE}} has the template parameters,
data members, and special members specified above.
It has no base classes or members other than those specified.

\rSec2[associative.reqmts]{Associative containers}

\pnum
Associative containers provide fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
\tcode{set},
\tcode{multiset},
\tcode{map}
and
\tcode{multimap}.

\pnum
Each associative container is parameterized on
\tcode{Key}
and an ordering relation
\tcode{Compare}
that induces a strict weak ordering\iref{alg.sorting} on
elements of
\tcode{Key}.
In addition,
\tcode{map}
and
\tcode{multimap}
associate an arbitrary \term{mapped type}
\tcode{T}
with the
\tcode{Key}.
The object of type
\tcode{Compare}
is called the
\term{comparison object}
of a container.

\pnum
The phrase ``equivalence of keys'' means the equivalence relation imposed by the
comparison object.
That is, two keys
\tcode{k1}
and
\tcode{k2}
are considered to be equivalent if for the
comparison object
\tcode{comp},
\tcode{comp(k1, k2) == false \&\& comp(k2, k1) == false}.
\begin{note}
This is not necessarily the same as the result of \tcode{k1 == k2}.
\end{note}
For any two keys
\tcode{k1}
and
\tcode{k2}
in the same container, calling
\tcode{comp(k1, k2)}
shall always return the same value.

\pnum
An associative container supports \term{unique keys} if it may contain at
most one element for each key. Otherwise, it supports \term{equivalent keys}.
The \tcode{set} and \tcode{map} classes support unique keys; the \tcode{multiset}
and \tcode{multimap} classes support equivalent keys.
For \tcode{multiset} and \tcode{multimap},
\tcode{insert}, \tcode{emplace}, and \tcode{erase} preserve the relative ordering
of equivalent elements.

\pnum
For \tcode{set} and \tcode{multiset} the value type is the same as the key type.
For \tcode{map} and \tcode{multimap} it is equal to \tcode{pair<const Key, T>}.

\pnum
\tcode{iterator}
of an associative container is of the bidirectional iterator category.
For associative containers where the value type is the same as the key type, both
\tcode{iterator}
and
\tcode{const_iterator}
are constant iterators. It is unspecified whether or not
\tcode{iterator}
and
\tcode{const_iterator}
are the same type.
\begin{note} \tcode{iterator} and \tcode{const_iterator} have identical semantics in this case, and \tcode{iterator} is convertible to \tcode{const_iterator}. Users can avoid violating the one-definition rule by always using \tcode{const_iterator} in their function parameter lists. \end{note}

\pnum
The associative containers meet all the requirements of Allocator-aware
containers\iref{container.requirements.general}, except that for
\tcode{map} and \tcode{multimap}, the requirements placed on \tcode{value_type}
in \tref{containers.allocatoraware} apply instead to \tcode{key_type}
and \tcode{mapped_type}. \begin{note} For example, in some cases \tcode{key_type} and \tcode{mapped_type}
are required to be \tcode{CopyAssignable} even though the associated
\tcode{value_type}, \tcode{pair<const key_type, mapped_type>}, is not
\tcode{CopyAssignable}. \end{note}

\pnum
In \tref{containers.associative.requirements},
\tcode{X} denotes an associative container class,
\tcode{a} denotes a value of type \tcode{X},
\tcode{a2} denotes a value of a type with nodes compatible with type
\tcode{X} (\tref{containers.node.compat}),
\tcode{b} denotes a possibly \tcode{const} value of type \tcode{X},
\tcode{u} denotes the name of a variable being declared,
\tcode{a_uniq} denotes a value of type \tcode{X}
when \tcode{X} supports unique keys,
\tcode{a_eq} denotes a value of type \tcode{X}
when \tcode{X} supports multiple keys,
\tcode{a_tran} denotes a possibly \tcode{const} value of type \tcode{X}
when the \grammarterm{qualified-id}
\tcode{X::key_compare::is_transparent} is valid
and denotes a type\iref{temp.deduct},
\tcode{i} and \tcode{j}
satisfy input iterator requirements and refer to elements
implicitly convertible to
\tcode{value_type}, \range{i}{j}
denotes a valid range,
\tcode{p} denotes a valid constant iterator to \tcode{a},
\tcode{q} denotes a valid dereferenceable constant iterator to \tcode{a},
\tcode{r} denotes a valid dereferenceable iterator to \tcode{a},
\tcode{[q1, q2)} denotes a valid range of constant iterators in \tcode{a},
\tcode{il} designates an object of type \tcode{initializer_list<value_type>},
\tcode{t} denotes a value of type \tcode{X::value_type},
\tcode{k} denotes a value of type \tcode{X::key_type}
and \tcode{c} denotes a possibly \tcode{const} value of type \tcode{X::key_compare};
\tcode{kl} is a value such that \tcode{a} is partitioned\iref{alg.sorting}
with respect to \tcode{c(r, kl)}, with \tcode{r} the key value of \tcode{e}
and \tcode{e} in \tcode{a};
\tcode{ku} is a value such that \tcode{a} is partitioned with respect to
\tcode{!c(ku, r)};
\tcode{ke} is a value such that \tcode{a} is partitioned with respect to
\tcode{c(r, ke)} and \tcode{!c(ke, r)}, with \tcode{c(r, ke)} implying
\tcode{!c(ke, r)}.
\tcode{A} denotes the storage allocator used by \tcode{X}, if any, or \tcode{allocator<X::value_type>} otherwise,
\tcode{m} denotes an allocator of a type convertible to \tcode{A},
and \tcode{nh} denotes a non-const rvalue of type \tcode{X::node_type}.

\begin{libreqtab4b}
{Associative container requirements (in addition to container)}
{tab:containers.associative.requirements}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Assertion/note}       &   \rhdr{Complexity}   \\
                        &                       &   \chdr{pre-/post-condition}   &                       \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Assertion/note}       &   \rhdr{Complexity}   \\
                        &                       &   \chdr{pre-/post-condition}   &                       \\ \capsep
\endhead

\tcode{X::key_type}     &
 \tcode{Key}            &
                        &
  compile time \\ \rowsep

\tcode{X::mapped_type} (\tcode{map} and \tcode{multimap} only) &
  \tcode{T}             &
                        &
  compile time          \\ \rowsep

\tcode{X::value_type} (\tcode{set} and \tcode{multiset} only) &
 \tcode{Key}            &
  \requires\ \tcode{value_type} is \tcode{Erasable} from \tcode{X} &
  compile time \\ \rowsep

\tcode{X::value_type} (\tcode{map} and \tcode{multimap} only) &
 \tcode{pair<const Key, T>}            &
  \requires\ \tcode{value_type} is \tcode{Erasable} from \tcode{X} &
  compile time \\ \rowsep

\tcode{X::key_compare}  &
  \tcode{Compare}       &
  \requires\ \tcode{key_compare} is \tcode{CopyConstructible}. &
  compile time   \\ \rowsep

\tcode{X::value_compare}           &
 a binary predicate type           &
 is the same as \tcode{key_compare} for \tcode{set} and
 \tcode{multiset}; is an ordering relation on pairs induced by the
 first component (i.e., \tcode{Key}) for \tcode{map} and \tcode{multimap}. &
 compile time                       \\ \rowsep

\tcode{X::node_type} &
 a specialization of a \tcode{\placeholder{node_handle}}
 class template, such that the public nested types are
 the same types as the corresponding types in \tcode{X}. &
 see~\ref{container.node} &
 compile time \\ \rowsep

\tcode{X(c)}\br
\tcode{X u(c);}                         &
                                        &
  \effects\ Constructs an empty container.
  Uses a copy of \tcode{c} as a comparison object.  &
 constant                               \\ \rowsep

\tcode{X()}\br\tcode{X u;}                      &
                                                &
  \requires\ \tcode{key_compare} is \tcode{DefaultConstructible}.\br
  \effects\ Constructs an empty container.
  Uses \tcode{Compare()} as a comparison object  &
  constant                                       \\ \rowsep

\tcode{X(i,j,c)}\br
\tcode{X~u(i,j,c);}     &
                        &
  \requires\ \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
  \effects\ Constructs an empty container and inserts elements from the
  range \tcode{[i, j)} into it; uses \tcode{c} as a comparison object. &
  $N \log N$ in general, where $N$ has the value \tcode{distance(i, j)};
  linear if \tcode{[i, j)} is sorted with \tcode{value_comp()} \\ \rowsep

\tcode{X(i,j)}\br\tcode{X~u(i,j);}    &
                                    &
  \requires\ \tcode{key_compare} is \tcode{DefaultConstructible}.
  \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
  \effects\ Same as above, but uses \tcode{Compare()} as a comparison object.  &
  same as above                      \\ \rowsep

\tcode{X(il)}            &
                          &
  same as \tcode{X(il.begin(), il.end())}  &
  same as \tcode{X(il.begin(), il.end())}  \\ \rowsep

\tcode{X(il,c)}          &
                          &
  same as \tcode{X(il.begin(), il.end(), c)}  &
  same as \tcode{X(il.begin(), il.end(), c)}  \\ \rowsep

\tcode{a = il}     &
  \tcode{X\&}               &
  \requires\ \tcode{value_type} is
  \tcode{CopyInsertable} into \tcode{X}
  and \tcode{CopyAssignable}.\br
  \effects Assigns the range \range{il.begin()}{il.end()} into \tcode{a}. All
  existing elements of \tcode{a} are either assigned to or destroyed. &
  $N \log N$ in general, where $N$ has the value \tcode{il.size() + a.size()};
  linear if \range{il.begin()}{il.end()} is sorted with \tcode{value_comp()}
  \\ \rowsep

\tcode{b.key_comp()}       &
 \tcode{X::key_compare}    &
 returns the comparison object out of which \tcode{b} was constructed. &
 constant                   \\ \rowsep

\tcode{b.value_comp()}     &
 \tcode{X::value_compare}  &
 returns an object of \tcode{value_compare} constructed out of the comparison object &
 constant                   \\ \rowsep

\tcode{a_uniq.\brk{}emplace(\brk{}args)} &
 \tcode{pair<\brk{}iterator, bool>} &
  \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
  \effects\ Inserts a \tcode{value_type} object \tcode{t} constructed with
  \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...} if and only if there is no
  element in the container with key equivalent to the key of \tcode{t}.
  The \tcode{bool} component of the returned
  pair is \tcode{true} if and only if the insertion takes place, and the iterator
  component of the pair points to the element with key equivalent to the
  key of \tcode{t}.  &
  logarithmic \\ \rowsep

\tcode{a_eq.\brk{}emplace(\brk{}args)}  &
 \tcode{iterator}    &
 \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
 \effects\ Inserts a \tcode{value_type} object \tcode{t} constructed with
 \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...} and returns the iterator pointing
 to the newly inserted element.
 If a range containing elements equivalent to \tcode{t} exists in \tcode{a_eq},
 \tcode{t} is inserted at the end of that range. &
 logarithmic    \\ \rowsep

\tcode{a.emplace_\-hint(\brk{}p, args)}  &
 \tcode{iterator}    &
 equivalent to \tcode{a.emplace(} \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...)}.
 Return value is an iterator pointing to the element with the key equivalent
 to the newly inserted element.
 The element is inserted as close as possible to the position just prior
 to \tcode{p}.  &
 logarithmic in general, but amortized constant if the element
 is inserted right before \tcode{p}    \\ \rowsep

\tcode{a_uniq.\brk{}insert(\brk{}t)}      &
  \tcode{pair<\brk{}iterator, bool>}   &
  \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
  \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
  \tcode{CopyInsertable} into \tcode{X}.\br
  \effects\ Inserts \tcode{t} if and only if there is no element in the container
  with key equivalent to the key of \tcode{t}. The \tcode{bool} component of
  the returned pair is \tcode{true} if and only if the insertion
  takes place, and the \tcode{iterator}
  component of the pair points to the element with key
  equivalent to the key of \tcode{t}.    &
  logarithmic                    \\ \rowsep

\tcode{a_eq.\brk{}insert(\brk{}t)}        &
  \tcode{iterator}               &
  \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
  \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
  \tcode{CopyInsertable} into \tcode{X}.\br
  \effects\ Inserts \tcode{t} and returns the iterator pointing
  to the newly inserted element.
  If a range containing elements equivalent to
  \tcode{t} exists in \tcode{a_eq}, \tcode{t}
  is inserted at the end of that range. &
  logarithmic                    \\ \rowsep

\tcode{a.\brk{}insert(\brk{}p, t)}                         &
  \tcode{iterator}               &
  \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
  \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
  \tcode{CopyInsertable} into \tcode{X}.\br
  \effects\ Inserts \tcode{t} if and only if there is no element with key
  equivalent to the key of \tcode{t} in containers with unique keys;
  always inserts \tcode{t} in containers with equivalent keys. Always
  returns the iterator pointing to the element with key equivalent to
  the key of \tcode{t}. \tcode{t} is inserted as close as possible to the position
  just prior to \tcode{p}.&
  logarithmic in general, but amortized constant if \tcode{t}
  is inserted right before \tcode{p}. \\ \rowsep

\tcode{a.\brk{}insert(\brk{}i, j)}          &
  \tcode{void}                   &
  \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
  \requires \tcode{i}, \tcode{j} are not iterators into \tcode{a}.
  inserts each element from the range \range{i}{j} if and only if there
  is no element with key equivalent to the key of that element in containers
  with unique keys; always inserts that element in containers with equivalent keys.  &
  $N \log (\tcode{a.size()} + N)$, where $N$ has the value \tcode{distance(i, j)} \\ \rowsep

\tcode{a.\brk{}insert(\brk{}il)}           &
  \tcode{void}                  &
  equivalent to \tcode{a.insert(il.begin(), il.end())} &
                                          \\ \rowsep

\tcode{a_uniq.\brk{}insert(\brk{}nh)}           &
 \tcode{insert_return_type}   &
 \requires \tcode{nh} is empty or
 \tcode{a_uniq.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect. Otherwise, inserts the
 element owned by \tcode{nh} if and only if there is no element in the
 container with a key equivalent to \tcode{nh.key()}.\br
 \postconditions If \tcode{nh} is empty, \tcode{inserted} is \tcode{false},
 \tcode{position} is \tcode{end()}, and \tcode{node} is empty.
 Otherwise if the insertion took place, \tcode{inserted} is \tcode{true},
 \tcode{position} points to the inserted element, and \tcode{node} is empty;
 if the insertion failed, \tcode{inserted} is \tcode{false},
 \tcode{node} has the previous value of \tcode{nh}, and \tcode{position}
 points to an element with a key equivalent to \tcode{nh.key()}. &
 logarithmic                             \\ \rowsep

\tcode{a_eq.\brk{}insert(\brk{}nh)}           &
 \tcode{iterator}   &
 \requires \tcode{nh} is empty or
 \tcode{a_eq.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect and returns \tcode{a_eq.end()}.
 Otherwise, inserts the element owned by \tcode{nh} and returns an iterator
 pointing to the newly inserted element. If a range containing elements with
 keys equivalent to \tcode{nh.key()} exists in \tcode{a_eq}, the element is
 inserted at the end of that range.\br
 \postconditions \tcode{nh} is empty. &
 logarithmic                             \\ \rowsep

\tcode{a.\brk{}insert(\brk{}p, nh)}           &
 \tcode{iterator}   &
 \requires \tcode{nh} is empty or
 \tcode{a.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect and returns \tcode{a.end()}.
 Otherwise, inserts the element owned by \tcode{nh} if and only if there
 is no element with key equivalent to \tcode{nh.key()} in containers with
 unique keys; always inserts the element owned by \tcode{nh} in containers
 with equivalent keys. Always returns the iterator pointing to the element
 with key equivalent to \tcode{nh.key()}. The element is inserted as close
 as possible to the position just prior to \tcode{p}.\br
 \postconditions \tcode{nh} is empty if insertion succeeds, unchanged if insertion fails.  &
 logarithmic in general, but amortized constant if the element is inserted right
 before \tcode{p}.                             \\ \rowsep

\tcode{a.\brk{}extract(\brk{}k)}              &
 \tcode{node_type}             &
 removes the first element in the container with key equivalent to \tcode{k}.
 Returns a \tcode{node_type} owning the element if found, otherwise an empty
 \tcode{node_type}. &
 $\log (\tcode{a.size()})$       \\ \rowsep

\tcode{a.\brk{}extract(\brk{}q)}              &
 \tcode{node_type}             &
 removes the element pointed to by \tcode{q}.
 Returns a \tcode{node_type} owning that element. &
 amortized constant       \\ \rowsep

\tcode{a.merge(a2)}              &
 \tcode{void}             &
 \requires \tcode{a.get_allocator() == a2.get_allocator()}.\br
 Attempts to extract each element in \tcode{a2} and insert it into \tcode{a}
 using the comparison object of \tcode{a}. In containers with unique keys,
 if there is an element in \tcode{a} with key equivalent to the key of an
 element from \tcode{a2}, then that element is not extracted from \tcode{a2}.\br
 \postconditions Pointers and references to the transferred elements of \tcode{a2}
 refer to those same elements but as members of \tcode{a}. Iterators referring
 to the transferred elements will continue to refer to their elements, but
 they now behave as iterators into \tcode{a}, not into \tcode{a2}.\br
 \throws{} Nothing unless the comparison object throws.  &
 $N \log(\tcode{a.size()+} N)$, where $N$ has the value \tcode{a2.size()}.    \\ \rowsep

\tcode{a.erase(k)}              &
 \tcode{size_type}             &
 erases all elements in the container with key equivalent to
 \tcode{k}. returns the number of erased elements.  &
 $\log (\tcode{a.size()}) + \tcode{a.count(k)}$       \\ \rowsep

\tcode{a.erase(q)}              &
 \tcode{iterator}               &
 erases the element pointed to by \tcode{q}. Returns an iterator pointing to
 the element immediately following \tcode{q} prior to the element being erased.
 If no such element exists, returns \tcode{a.end()}.     &
 amortized constant             \\ \rowsep

\tcode{a.erase(r)}              &
 \tcode{iterator}               &
 erases the element pointed to by \tcode{r}. Returns an iterator pointing to
 the element immediately following \tcode{r} prior to the element being erased.
 If no such element exists, returns \tcode{a.end()}.     &
 amortized constant             \\ \rowsep

\tcode{a.erase(}\br
 \tcode{q1, q2)}  &
 \tcode{iterator}        &
 erases all the elements in the range \range{q1}{q2}. Returns an iterator pointing to
 the element pointed to by \tcode{q2} prior to any elements being erased. If no such element
 exists, \tcode{a.end()} is returned.  &
 $\log(\tcode{a.size()}) + N$, where $N$ has the value \tcode{distance(q1, q2)}.    \\ \rowsep

\tcode{a.clear()}       &
 \tcode{void}           &
 \tcode{a.erase(a.begin(),a.end())}\br
 \postconditions \tcode{a.empty()} returns \tcode{true}.  &
 linear in \tcode{a.size()}.  \\ \rowsep

\tcode{b.find(k)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{b}.  &
 returns an iterator pointing to an element with the key equivalent
 to \tcode{k}, or \tcode{b.end()} if such an element is not found    &
 logarithmic            \\ \rowsep

\tcode{a_tran.}\br
 \tcode{find(ke)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a_tran}.  &
 returns an iterator pointing to an element with key \tcode{r} such that
 \tcode{!c(r, ke) \&\& !c(ke, r)}, or \tcode{a_tran.end()} if such an element
 is not found    &
 logarithmic            \\ \rowsep

\tcode{b.count(k)}        &
 \tcode{size_type}        &
 returns the number of elements with key equivalent to \tcode{k}    &
 $\log (\tcode{b.size()}) + \tcode{b.count(k)}$   \\ \rowsep

\tcode{a_tran.}\br
 \tcode{count(ke)}        &
 \tcode{size_type}        &
 returns the number of elements with key \tcode{r} such that
 \tcode{!c(r, ke) \&\& !c(ke, r)}    &
 $\log (\tcode{a_tran.size()}) + \tcode{a_tran.count(ke)}$   \\ \rowsep

\tcode{b.lower_bound(k)}   &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{b}.  &
 returns an iterator pointing to the first element with
 key not less than \tcode{k},
 or \tcode{b.end()} if such an element is not found.   &
 logarithmic            \\ \rowsep

\tcode{a_tran.}\br
 \tcode{lower_bound(kl)}   &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a_tran}.  &
 returns an iterator pointing to the first element with
 key \tcode{r} such that \tcode{!c(r, kl)},
 or \tcode{a_tran.end()} if such an element is not found.   &
 logarithmic            \\ \rowsep

\tcode{b.upper_bound(k)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{b}.  &
 returns an iterator pointing to the first element with
 key greater than \tcode{k},
 or \tcode{b.end()} if such an element is not found.   &
 logarithmic                    \\ \rowsep

\tcode{a_tran.}\br
 \tcode{upper_bound(ku)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a_tran}.  &
 returns an iterator pointing to the first element with
 key \tcode{r} such that \tcode{c(ku, r)},
 or \tcode{a_tran.end()} if such an element is not found.   &
 logarithmic                    \\ \rowsep

\tcode{b.equal_range(k)}       &
 \tcode{pair<\brk{}iterator, iterator>};
 \tcode{pair<\brk{}const_iterator, const_iterator>} for constant \tcode{b}.     &
 equivalent to \tcode{make_pair(b.lower_bound(k), b.upper_bound(k))}.    &
 logarithmic                    \\ \rowsep

\tcode{a_tran.}\br
 \tcode{equal_range(ke)}       &
 \tcode{pair<\brk{}iterator, iterator>};
 \tcode{pair<\brk{}const_iterator, const_iterator>} for constant \tcode{a_tran}.     &
 equivalent to \tcode{make_pair(}\br
 \tcode{a_tran.lower_bound(ke), a_tran.upper_bound(ke))}.    &
 logarithmic                    \\
\end{libreqtab4b}

\pnum
The \tcode{insert} and \tcode{emplace} members shall not affect the validity of
iterators and references to the container,
and the \tcode{erase} members shall invalidate only iterators and
references to the erased elements.

\pnum
The \tcode{extract} members invalidate only iterators to the removed element;
pointers and references to the removed element remain valid. However, accessing
the element through such pointers and references while the element is owned by
a \tcode{node_type} is undefined behavior. References and pointers to an element
obtained while it is owned by a \tcode{node_type} are invalidated if the element
is successfully inserted.

\pnum
The fundamental property of iterators of associative containers is that they iterate through the containers
in the non-descending order of keys where non-descending is defined by the comparison that was used to
construct them.
For any two dereferenceable iterators
\tcode{i}
and
\tcode{j}
such that distance from
\tcode{i}
to
\tcode{j}
is positive, the following condition holds:

\begin{codeblock}
value_comp(*j, *i) == false
\end{codeblock}

\pnum
For associative containers with unique keys the stronger condition holds:

\begin{codeblock}
value_comp(*i, *j) != false
\end{codeblock}

\pnum
When an associative container is constructed by passing a comparison object the
container shall not store a pointer or reference to the passed object,
even if that object is passed by reference.
When an associative container is copied, either through a copy constructor
or an assignment operator,
the target container shall then use the comparison object from the container
being copied,
as if that comparison object had been passed to the target container in
its constructor.

\pnum
The member function templates \tcode{find}, \tcode{count}, \tcode{lower_bound},
\tcode{upper_bound}, and \tcode{equal_range} shall not participate in overload
resolution unless the \grammarterm{qualified-id} \tcode{Compare::is_transparent} is valid
and denotes a type\iref{temp.deduct}.

\pnum
A deduction guide for an associative container shall not participate in overload resolution
if any of the following are true:
\begin{itemize}
\item It has an \tcode{InputIterator} template parameter
and a type that does not qualify as an input iterator is deduced for that parameter.

\item It has an \tcode{Allocator} template parameter
and a type that does not qualify as an allocator is deduced for that parameter.

\item It has a \tcode{Compare} template parameter
and a type that qualifies as an allocator is deduced for that parameter.
\end{itemize}

\indextext{associative containers!exception safety}%
\indextext{associative containers!requirements}%
\rSec3[associative.reqmts.except]{Exception safety guarantees}

\pnum
For associative containers, no \tcode{clear()} function throws an exception.
\tcode{erase(k)} does not throw an exception unless that exception is thrown
by the container's \tcode{Compare} object (if any).

\pnum
For associative containers, if an exception is thrown by any operation from
within an \tcode{insert} or \tcode{emplace} function inserting a single element, the
insertion has no effect.

\pnum
For associative containers, no \tcode{swap} function throws an exception unless
that exception is thrown by the
swap of the container's \tcode{Compare} object (if any).

\indextext{associative containers!unordered|see{unordered associative containers}}
\indextext{hash tables|see{unordered associative containers}}
\rSec2[unord.req]{Unordered associative containers}

\pnum
\indextext{unordered associative containers!complexity}%
Unordered associative containers provide an ability for fast retrieval
of data based on keys.  The worst-case complexity for most operations
is linear, but the average case is much faster.  The library provides
four unordered associative containers: \tcode{unordered_set},
\tcode{unordered_map}, \tcode{unordered_multiset}, and
\tcode{unordered_multimap}.

\pnum
\indextext{unordered associative containers!lack of comparison functions}%
\indextext{unordered associative containers!requirements}%
\indextext{requirements!container!not required for unordered associated containers}%
Unordered associative containers conform to the requirements for
Containers\iref{container.requirements}, except that
the expressions
\tcode{a == b} and \tcode{a != b} have different semantics than for the other
container types.

\pnum
Each unordered associative container is parameterized by \tcode{Key},
by a function object type \tcode{Hash} that meets the \tcode{Hash}
requirements\iref{hash.requirements} and acts as a hash function for
argument values of type \tcode{Key}, and by a binary predicate \tcode{Pred}
that induces an equivalence relation on values of type \tcode{Key}.
Additionally, \tcode{unordered_map} and \tcode{unordered_multimap} associate
an arbitrary \textit{mapped type} \tcode{T} with the \tcode{Key}.

\pnum
\indextext{unordered associative containers!hash function}%
\indextext{hash function}%
The container's object of type \tcode{Hash} --- denoted by
\tcode{hash} --- is called the \term{hash function} of the
container. The container's object of type \tcode{Pred} ---
denoted by \tcode{pred} --- is called the
\term{key equality predicate} of the container.

\pnum
\indextext{unordered associative containers!equality function}%
Two values \tcode{k1} and \tcode{k2} of type \tcode{Key} are
considered equivalent if the container's
key equality predicate returns
\tcode{true} when passed those values.  If \tcode{k1} and
\tcode{k2} are equivalent, the container's hash function shall
return the same value for both.
\begin{note} Thus, when an unordered associative container is instantiated with
a non-default \tcode{Pred} parameter it usually needs a non-default \tcode{Hash}
parameter as well. \end{note}
For any two keys \tcode{k1} and \tcode{k2} in the same container,
calling \tcode{pred(k1, k2)} shall always return the same value.
For any key \tcode{k} in a container, calling \tcode{hash(k)}
shall always return the same value.

\pnum
\indextext{unordered associative containers!unique keys}%
\indextext{unordered associative containers!equivalent keys}%
An unordered associative container supports \textit{unique keys} if it
may contain at most one element for each key.  Otherwise, it supports
\textit{equivalent keys}.  \tcode{unordered_set} and \tcode{unordered_map}
support unique keys. \tcode{unordered_multiset} and \tcode{unordered_multimap}
support equivalent keys.  In containers that support equivalent keys,
elements with equivalent keys are adjacent to each other
in the iteration order of the container. Thus, although the absolute order
of elements in an unordered container is not specified, its elements are
grouped into \defnx{equivalent-key groups}{equivalent-key group} such that all elements of each
group have equivalent keys. Mutating operations on unordered containers shall
preserve the relative order of elements within each equivalent-key group
unless otherwise specified.

\pnum
For \tcode{unordered_set} and \tcode{unordered_multiset} the value type is
the same as the key type.  For \tcode{unordered_map} and
\tcode{unordered_multimap} it is \tcode{pair<const Key,
T>}.

\pnum
For unordered containers where the value type is the same as the key
type, both \tcode{iterator} and \tcode{const_iterator} are constant
iterators. It is unspecified whether or not \tcode{iterator} and
\tcode{const_iterator} are the same type.
\begin{note} \tcode{iterator} and \tcode{const_iterator} have identical
semantics in this case, and \tcode{iterator} is convertible to
\tcode{const_iterator}. Users can avoid violating the one-definition rule
by always using \tcode{const_iterator} in their function parameter lists.
\end{note}

\pnum
\indextext{buckets}%
\indextext{hash code}%
The elements of an unordered associative container are organized into
\textit{buckets}.  Keys with the same hash code appear in the same
bucket.  The number of buckets is automatically increased as elements
are added to an unordered associative container, so that the average
number of elements per bucket is kept below a bound.  Rehashing
invalidates iterators, changes ordering between elements, and changes
which buckets elements appear in, but does not invalidate pointers or
references to elements. For \tcode{unordered_multiset} and
\tcode{unordered_multimap}, rehashing preserves the relative ordering of
equivalent elements.

\pnum
The unordered associative containers meet all the requirements of Allocator-aware
containers\iref{container.requirements.general}, except that for
\tcode{unordered_map} and \tcode{unordered_multimap}, the requirements placed on \tcode{value_type}
in \tref{containers.allocatoraware} apply instead to \tcode{key_type}
and \tcode{mapped_type}. \begin{note} For example, \tcode{key_type} and \tcode{mapped_type}
are sometimes required to be \tcode{CopyAssignable} even though the associated
\tcode{value_type}, \tcode{pair<const key_type, mapped_type>}, is not
\tcode{CopyAssignable}. \end{note}

\pnum
\indextext{unordered associative containers}%
\indextext{unordered associative containers!requirements}%
\indextext{requirements!unordered associative container}%
\indextext{unordered associative containers!unique keys}%
\indextext{unordered associative containers!equivalent keys}%
\indextext{requirements!container}%
In \tref{HashRequirements}:
\tcode{X} denotes an unordered associative container class,
\tcode{a} denotes a value of type \tcode{X},
\tcode{a2} denotes a value of a type with nodes compatible with type
\tcode{X} (\tref{containers.node.compat}),
\tcode{b} denotes a possibly const value of type \tcode{X},
\tcode{a_uniq} denotes a value of type \tcode{X} when \tcode{X} supports unique keys,
\tcode{a_eq} denotes a value of type \tcode{X} when \tcode{X} supports equivalent keys,
\tcode{i} and \tcode{j} denote input iterators that refer to \tcode{value_type},
\tcode{[i, j)} denotes a valid range,
\tcode{p} and \tcode{q2} denote valid constant iterators to \tcode{a},
\tcode{q} and \tcode{q1} denote valid dereferenceable constant iterators to \tcode{a},
\tcode{r} denotes a valid dereferenceable iterator to \tcode{a},
\tcode{[q1, q2)} denotes a valid range in \tcode{a},
\tcode{il} denotes a value of type \tcode{initializer_list<value_type>},
\tcode{t} denotes a value of type \tcode{X::value_type},
\tcode{k} denotes a value of type \tcode{key_type},
\tcode{hf} denotes a possibly const value of type \tcode{hasher},
\tcode{eq} denotes a possibly const value of type \tcode{key_equal},
\tcode{n} denotes a value of type \tcode{size_type},
\tcode{z} denotes a value of type \tcode{float},
and \tcode{nh} denotes a non-const rvalue of type \tcode{X::node_type}.

% Local command to index names as members of all unordered containers.
\newcommand{\indexunordmem}[1]{%
\indexlibrary{\idxcode{#1}!unordered associative containers}%
\indexlibrary{\idxcode{unordered_set}!\idxcode{#1}}%
\indexlibrary{\idxcode{unordered_map}!\idxcode{#1}}%
\indexlibrary{\idxcode{unordered_multiset}!\idxcode{#1}}%
\indexlibrary{\idxcode{unordered_multimap}!\idxcode{#1}}%
}

\begin{libreqtab4d}
  {Unordered associative container requirements (in addition to container)}
  {tab:HashRequirements}
\\ \topline
\lhdr{Expression} & \chdr{Return type}   & \chdr{Assertion/note}      & \rhdr{Complexity} \\
                  &                      & \chdr{pre-/post-condition} & \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression} & \chdr{Return type}   & \chdr{Assertion/note}      & \rhdr{Complexity} \\
                  &                      & \chdr{pre-/post-condition} & \\ \capsep
\endhead
%%
\indexunordmem{key_type}%
\tcode{X::key_type}   &
  \tcode{Key}         &
                      &
  compile time        \\ \rowsep

\tcode{X::mapped_type} (\tcode{unordered_map} and \tcode{unordered_multimap} only)  &
  \tcode{T}             &
                        &
  compile time          \\ \rowsep

\tcode{X::value_type} (\tcode{unordered_set} and \tcode{unordered_multiset} only) &
 \tcode{Key}            &
  \requires\ \tcode{value_type} is \tcode{Erasable} from \tcode{X} &
  compile time \\ \rowsep

\tcode{X::value_type} (\tcode{unordered_map} and \tcode{unordered_multimap} only) &
 \tcode{pair<const Key, T>}            &
  \requires\ \tcode{value_type} is \tcode{Erasable} from \tcode{X} &
  compile time \\ \rowsep

\indexunordmem{hasher}%
\tcode{X::hasher}
&   \tcode{Hash}
&   \tcode{Hash} shall be a unary function object type such that the expression
    \tcode{hf(k)} has type \tcode{size_t}.%
&   compile time
\\ \rowsep
%
\indexunordmem{key_equal}%
\tcode{X::key_equal}
&   \tcode{Pred}
&   \requires\ \tcode{Pred} is \tcode{CopyConstructible}.\br
    \tcode{Pred} shall be a binary predicate that takes two arguments
    of type \tcode{Key}.  \tcode{Pred} is an equivalence relation.%
&   compile time
\\ \rowsep
%
\indexunordmem{local_iterator}%
\tcode{X::local_iterator}
&   An iterator type whose category, value type,
    difference type, and pointer and reference types are the same as
    \tcode{X::iterator}'s. \indextext{\idxcode{local_iterator}}
&   A \tcode{local_iterator} object may be used to iterate through a
    single bucket, but may not be used to iterate across
    buckets.%
&   compile time
\\ \rowsep
%
\indexunordmem{const_local_iterator}%
\tcode{X::const_local_iterator}
&   An iterator type whose category, value type,
    difference type, and pointer and reference types are the same as
    \tcode{X::const_iterator}'s. \indextext{\idxcode{const_local_iterator}}
&   A \tcode{const_local_iterator} object may be used to iterate through a
    single bucket, but may not be used to iterate across
    buckets.%
&   compile time
\\ \rowsep
%
\indexunordmem{node_type}%
\tcode{X::node_type} &
 a specialization of a \tcode{\placeholder{node_handle}}
 class template, such that the public nested types are
 the same types as the corresponding types in \tcode{X}. &
 see~\ref{container.node} &
 compile time \\ \rowsep
%
\tcode{X(n, hf, eq)}\br \tcode{X a(n, hf, eq);}
&   \tcode{X}
&   \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hf} as the hash function and \tcode{eq} as the key
equality predicate.
&   \bigoh{\tcode{n}}
\\ \rowsep
%
\tcode{X(n, hf)}\br \tcode{X a(n, hf);}
&   \tcode{X}
&   \requires\ \tcode{key_equal} is \tcode{DefaultConstructible}.\br
    \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hf} as the hash function and \tcode{key_equal()} as the key
equality predicate.
&   \bigoh{\tcode{n}}
\\ \rowsep
%
\tcode{X(n)}\br \tcode{X a(n);}
&   \tcode{X}
&   \requires\ \tcode{hasher} and \tcode{key_equal} are \tcode{DefaultConstructible}.\br
    \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hasher()} as the hash function and \tcode{key_equal()}
as the key equality predicate.
&   \bigoh{\tcode{n}}
\\ \rowsep
%
\tcode{X()}\br \tcode{X a;}
&   \tcode{X}
&   \requires\ \tcode{hasher} and \tcode{key_equal} are \tcode{DefaultConstructible}.\br
    \effects\ Constructs an empty container with an unspecified number of
  buckets, using \tcode{hasher()} as the hash function and
  \tcode{key_equal()} as the key equality predicate.
&   constant
\\ \rowsep
%
\tcode{X(i, j, n, hf, eq)}\br \tcode{X a(i, j, n, hf, eq);}
&   \tcode{X}
&   \requires\ \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
    \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hf} as the hash function and \tcode{eq} as the key
equality predicate, and inserts elements from \tcode{[i, j)} into it.
&   Average case \bigoh{N} ($N$ is \tcode{distance(i, j)}), worst case
\bigoh{N^2}
\\ \rowsep
%
\tcode{X(i, j, n, hf)}\br \tcode{X a(i, j, n, hf);}
&   \tcode{X}
&   \requires\ \tcode{key_equal} is \tcode{DefaultConstructible}.
    \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
    \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hf} as the hash function and \tcode{key_equal()} as the key
equality predicate, and inserts elements from \tcode{[i, j)} into it.
&   Average case \bigoh{N} ($N$ is \tcode{distance(i, j)}), worst case
\bigoh{N^2}
\\ \rowsep
%
\tcode{X(i, j, n)}\br \tcode{X a(i, j, n);}
&   \tcode{X}
&   \requires\ \tcode{hasher} and \tcode{key_equal} are \tcode{DefaultConstructible}.
    \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
    \effects\ Constructs an empty container with at least \tcode{n} buckets,
using \tcode{hasher()} as the hash function and \tcode{key_equal()}
as the key equality predicate, and inserts elements from \tcode{[i, j)}
into it.
&   Average case \bigoh{N} ($N$ is \tcode{distance(i, j)}), worst case
\bigoh{N^2}
\\ \rowsep
%
\tcode{X(i, j)}\br \tcode{X a(i, j);}
&   \tcode{X}
&   \requires\ \tcode{hasher} and \tcode{key_equal} are \tcode{DefaultConstructible}.
    \tcode{value_type} is \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
    \effects\ Constructs an empty container with an unspecified number of
buckets, using \tcode{hasher()} as the hash function and
\tcode{key_equal()} as the key equality predicate, and inserts elements
from \tcode{[i, j)} into it.
&   Average case \bigoh{N} ($N$ is \tcode{distance(i, j)}), worst case
\bigoh{N^2}
\\ \rowsep
%
\tcode{X(il)}
&   \tcode{X}
&   Same as \tcode{X(il.begin(), il.end())}.
&   Same as \tcode{X(il.begin(),} \tcode{il.end())}.
\\ \rowsep
%
\tcode{X(il, n)}
&   \tcode{X}
&   Same as \tcode{X(il.begin(), il.end(), n)}.
&   Same as \tcode{X(il.begin(),} \tcode{il.end(), n)}.
\\ \rowsep
%
\tcode{X(il, n, hf)}
&   \tcode{X}
&   Same as \tcode{X(il.begin(), il.end(), n, hf)}.
&   Same as \tcode{X(il.begin(),} \tcode{il.end(), n, hf)}.
\\ \rowsep
%
\tcode{X(il, n, hf, eq)}
&   \tcode{X}
&   Same as \tcode{X(il.begin(), il.end(), n, hf, eq)}.
&   Same as \tcode{X(il.begin(),} \tcode{il.end(), n, hf, eq)}.
\\ \rowsep
%
\tcode{X(b)}\br \tcode{X a(b);}
&   \tcode{X}
&   Copy constructor.  In addition to the requirements
    of \tref{containers.container.requirements}, copies the
  hash function, predicate, and maximum load factor.
&   Average case linear in \tcode{b.size()}, worst case quadratic.
\\ \rowsep
%
\tcode{a = b}
&   \tcode{X\&}
&   Copy assignment operator.  In addition to the
    requirements of \tref{containers.container.requirements}, copies
  the hash function, predicate, and maximum load factor.
&   Average case linear in \tcode{b.size()}, worst case quadratic.
\\ \rowsep
%
\tcode{a = il}
&   \tcode{X\&}
&   \requires\ \tcode{value_type} is
\tcode{CopyInsertable} into \tcode{X}
and \tcode{CopyAssignable}.\br
    \effects\ Assigns the range \range{il.begin()}{il.end()} into \tcode{a}. All
    existing elements of \tcode{a} are either assigned to or destroyed.
&   Same as \tcode{a = X(il)}.
\\ \rowsep
%
\indexunordmem{hash_function}%
\tcode{b.hash_function()}
&   \tcode{hasher}
&   Returns \tcode{b}'s hash function.%
&   constant
\\ \rowsep
%
\indexunordmem{key_eq}%
\tcode{b.key_eq()}
&   \tcode{key_equal}
&   Returns \tcode{b}'s key equality predicate.%
&   constant
\\ \rowsep
%

\tcode{a_uniq.} \tcode{emplace(args)} &
  \tcode{pair<iterator,} \tcode{bool>} &
  \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
  \effects\ Inserts a \tcode{value_type} object \tcode{t} constructed with
  \tcode{std::forward<\brk{}Args\brk{}>(\brk{}args)...} if and only if there is no
  element in the container with key equivalent to the key of \tcode{t}.
  The \tcode{bool} component of the returned
  pair is \tcode{true} if and only if the insertion takes place, and the iterator
  component of the pair points to the element with key equivalent to the
  key of \tcode{t}.  &
  Average case \bigoh{1}, worst case \bigoh{\tcode{a_uniq.}\br\tcode{size()}}.
\\ \rowsep

\tcode{a_eq.}\tcode{emplace(args)}  &
  \tcode{iterator}    &
  \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
  \effects\ Inserts a \tcode{value_type} object \tcode{t} constructed with
  \tcode{std::forward<\brk{}Args>(\brk{}args)...} and returns the iterator pointing
  to the newly inserted element.    &
  Average case \bigoh{1}, worst case \bigoh{\tcode{a_eq.}\br\tcode{size()}}.
\\ \rowsep

\tcode{a.emplace_hint(p, args)}  &
  \tcode{iterator}    &
  \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{args}.\br
  \effects\ Equivalent to \tcode{a.emplace(} \tcode{std::forward<\brk{}Args>(\brk{}args)...)}.
  Return value is an iterator pointing to the element with the key equivalent
  to the newly inserted element. The \tcode{const_iterator} \tcode{p}
  is a hint pointing to where the search should start. Implementations are
  permitted to ignore the hint. &
  Average case \bigoh{1}, worst case \bigoh{\tcode{a.} \tcode{size()}}.
\\ \rowsep

\indexunordmem{insert}%
\tcode{a_uniq.insert(t)}
&   \tcode{pair<iterator, bool>}
&   \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
    \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
    \tcode{CopyInsertable} into \tcode{X}.\br
    \effects\ Inserts \tcode{t} if and only if there is no element in the container
    with key equivalent to the key of \tcode{t}.  The \tcode{bool}
    component of the returned pair indicates whether the insertion
    takes place, and the \tcode{iterator} component points to the element
    with key equivalent to the key of \tcode{t}.%
&   Average case \bigoh{1}, worst case \bigoh{\tcode{a_uniq.}\br\tcode{size()}}.
\\ \rowsep
%
\tcode{a_eq.insert(t)}
&   \tcode{iterator}
&   \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
    \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
    \tcode{CopyInsertable} into \tcode{X}.\br
    \effects\ Inserts \tcode{t}, and returns an iterator pointing to the newly
    inserted element.
&   Average case \bigoh{1}, worst case \bigoh{\tcode{a_eq.}\br\tcode{size()}}.
\\ \rowsep
%
\tcode{a.insert(p, t)}
&   \tcode{iterator}
&   \requires\ If \tcode{t} is a non-const rvalue expression, \tcode{value_type} shall be
    \tcode{MoveInsertable} into \tcode{X}; otherwise, \tcode{value_type} shall be
    \tcode{CopyInsertable} into \tcode{X}.\br
    \effects Equivalent to \tcode{a.insert(t)}.  Return value is an iterator pointing
to the element with the key equivalent to that of \tcode{t}.  The
iterator \tcode{p} is a hint pointing to where the search should
start.  Implementations are permitted to ignore the hint.%
&   Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.
\\ \rowsep
%
\tcode{a.insert(i, j)}
&   \tcode{void}
&   \requires\ \tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{X} from \tcode{*i}.\br
    \requires \tcode{i} and \tcode{j} are not iterators in \tcode{a}.\br
    \effects Equivalent to \tcode{a.insert(t)} for each element in \tcode{[i,j)}.%
&   Average case \bigoh{N}, where $N$ is \tcode{distance(i, j)}.
    Worst case \bigoh{N(\tcode{a.size()}\brk{}+\brk{}1)}.
\\ \rowsep
%
\tcode{a.insert(il)}
&   \tcode{void}
&   Same as \tcode{a.insert(il.begin(), il.end())}.
&   Same as \tcode{a.insert(} \tcode{il.begin(),} \tcode{il.end())}.
\\ \rowsep
%
\tcode{a_uniq.}\br
 \tcode{insert(nh)}           &
 \tcode{insert_return_type}   &
 \requires \tcode{nh} is empty or
 \tcode{a_uniq.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect. Otherwise, inserts the
 element owned by \tcode{nh} if and only if there is no element in the
 container with a key equivalent to \tcode{nh.key()}.\br
 \postconditions If \tcode{nh} is empty, \tcode{inserted} is \tcode{false},
 \tcode{position} is \tcode{end()}, and \tcode{node} is empty.
 Otherwise if the insertion took place, \tcode{inserted} is \tcode{true},
 \tcode{position} points to the inserted element, and \tcode{node} is empty;
 if the insertion failed, \tcode{inserted} is \tcode{false},
 \tcode{node} has the previous value of \tcode{nh}, and \tcode{position}
 points to an element with a key equivalent to \tcode{nh.key()}. &
 Average case \bigoh{1}, worst case \bigoh{\brk{}\tcode{a_uniq.}\brk{}\tcode{size()}}.  \\ \rowsep
%
\tcode{a_eq.}\br
 \tcode{insert(nh)}           &
 \tcode{iterator}   &
 \requires \tcode{nh} is empty or
 \tcode{a_eq.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect and returns \tcode{a_eq.end()}.
 Otherwise, inserts the element owned by \tcode{nh} and returns an iterator
 pointing to the newly inserted element.\br
 \postconditions \tcode{nh} is empty. &
 Average case \bigoh{1}, worst case \bigoh{\brk{}\tcode{a_eq.}\brk{}\tcode{size()}}.  \\ \rowsep
%
\tcode{a.insert(q, nh)}           &
 \tcode{iterator}   &
 \requires \tcode{nh} is empty or
 \tcode{a.get_allocator() == nh.get_allocator()}.\br
 \effects{} If \tcode{nh} is empty, has no effect and returns \tcode{a.end()}.
 Otherwise, inserts the element owned by \tcode{nh} if and only if there
 is no element with key equivalent to \tcode{nh.key()} in containers with
 unique keys; always inserts the element owned by \tcode{nh} in containers
 with equivalent keys. Always returns the iterator pointing to the element
 with key equivalent to \tcode{nh.key()}. The iterator \tcode{q} is a hint
 pointing to where the search should start. Implementations are permitted
 to ignore the hint.\br
 \postconditions \tcode{nh} is empty if insertion succeeds, unchanged if insertion fails.  &
 Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.  \\ \rowsep
%
\tcode{a.extract(k)}              &
 \tcode{node_type}             &
 Removes an element in the container with key equivalent to \tcode{k}.
 Returns a \tcode{node_type} owning the element if found, otherwise an empty
 \tcode{node_type}. &
 Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.  \\ \rowsep
%
\tcode{a.extract(q)}              &
 \tcode{node_type}             &
 Removes the element pointed to by \tcode{q}.
 Returns a \tcode{node_type} owning that element. &
 Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.  \\ \rowsep
%
\tcode{a.merge(a2)}              &
 \tcode{void}             &
 \requires \tcode{a.get_allocator() == a2.get_allocator()}.\br
 Attempts to extract each element in \tcode{a2} and insert it into \tcode{a}
 using the hash function and key equality predicate of \tcode{a}.
 In containers with unique keys, if there is an element in \tcode{a} with
 key equivalent to the key of an element from \tcode{a2}, then that
 element is not extracted from \tcode{a2}.\par
 \postconditions Pointers and references to the transferred elements of \tcode{a2}
 refer to those same elements but as members of \tcode{a}. Iterators referring
 to the transferred elements and all iterators referring to \tcode{a} will
 be invalidated, but iterators to elements remaining in \tcode{a2} will
 remain valid. &
 Average case \bigoh{N}, where $N$ is \tcode{a2.size()}.
 Worst case \bigoh{N\tcode{*a.size()}\br\tcode{+} N}.  \\ \rowsep
%
\tcode{a.erase(k)}
&   \tcode{size_type}
&   Erases all elements with key equivalent to \tcode{k}.  Returns
the number of elements erased.
&   Average case \bigoh{\tcode{a.count(k)}}.  Worst case
    \bigoh{\tcode{a.size()}}.
\\ \rowsep
%
\indexunordmem{erase}%
\tcode{a.erase(q)}
&   \tcode{iterator}
&   Erases the element pointed to by \tcode{q}. Returns the
    iterator immediately following \tcode{q} prior to the erasure.
&   Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.
\\ \rowsep
%
\tcode{a.erase(r)}
&   \tcode{iterator}
&   Erases the element pointed to by \tcode{r}. Returns the
    iterator immediately following \tcode{r} prior to the erasure.
&   Average case \bigoh{1}, worst case \bigoh{\tcode{a.size()}}.
\\ \rowsep
%
\tcode{a.erase(q1, q2)}
&   \tcode{iterator}
&   Erases all elements in the range \tcode{[q1, q2)}. Returns
    the iterator immediately following the erased elements prior to the
    erasure.%
&   Average case linear in \tcode{distance(q1, q2)},
    worst case \bigoh{\tcode{a.size()}}.
\\ \rowsep
%
\indexunordmem{clear}%
\tcode{a.clear()}
& \tcode{void}
& Erases all elements in the container.
   \postconditions \tcode{a.empty()} returns \tcode{true}%
& Linear in \tcode{a.size()}.
\\ \rowsep
%
\indexunordmem{find}%
\tcode{b.find(k)}
&   \tcode{iterator}; \br \tcode{const_iterator} for const \tcode{b}.
&   Returns an iterator pointing to an element with key equivalent to
    \tcode{k}, or \tcode{b.end()} if no such element exists.%
&   Average case \bigoh{1}, worst case \bigoh{\tcode{b.size()}}.
\\ \rowsep
%
\indexunordmem{count}%
\tcode{b.count(k)}
&   \tcode{size_type}
&   Returns the number of elements with key equivalent to \tcode{k}.%
&   Average case \bigoh{\tcode{b.count(k)}}, worst case \bigoh{\tcode{b.size()}}.
\\ \rowsep
%
\indexunordmem{equal_range}%
\tcode{b.equal_range(k)}
&   \tcode{pair<iterator, iterator>}; \br
    \tcode{pair<const_iterator, const_iterator>} for const \tcode{b}.
&   Returns a range containing all elements with keys equivalent to
    \tcode{k}.  Returns \tcode{make_pair(b.end(), b.end())} if
    no such elements exist.%
&   Average case \bigoh{\tcode{b.count(k)}}.  Worst case
    \bigoh{\tcode{b.size()}}.
\\ \rowsep
%
\indexunordmem{bucket_count}%
\tcode{b.bucket_count()}
&   \tcode{size_type}
&   Returns the number of buckets that \tcode{b} contains.%
&   Constant
\\ \rowsep
%
\indexunordmem{max_bucket_count}%
\tcode{b.max_bucket_count()}
&   \tcode{size_type}
&   Returns an upper bound on the number of buckets that \tcode{b} might
    ever contain.%
&   Constant
\\ \rowsep
%
\indexunordmem{bucket}%
\tcode{b.bucket(k)}
& \tcode{size_type}
&
  \requires \tcode{b.bucket_count() > 0}.\br
    Returns the index of the bucket in which elements with keys equivalent
    to \tcode{k} would be found, if any such element existed.
    \postconditions the return value shall be in the range \tcode{[0, b.bucket_count())}.%
& Constant
\\ \rowsep
%
\indexunordmem{bucket_size}%
\tcode{b.bucket_size(n)}
&   \tcode{size_type}
&   \requires \tcode{n} shall be in the range \tcode{[0, b.bucket_count())}.
    Returns the number of elements in the $\texttt{n}^{\textrm{ th}}$ bucket.%
&   \bigoh{\tcode{b.bucket_}\-\tcode{size(n)}}
\\ \rowsep
%
\indexunordmem{begin}%
\tcode{b.begin(n)}
&   \tcode{local_iterator}; \br
    \tcode{const_local_iterator} for const \tcode{b}.
&   \requires \tcode{n} shall be in the range \tcode{[0, b.bucket_count())}.
    \tcode{b.begin(n)} returns an iterator referring to the
    first element in the bucket. If the bucket is empty, then
    \tcode{b.begin(n) == b.end(n)}.%
&   Constant
\\ \rowsep
%
\indexunordmem{end}%
\tcode{b.end(n)}
&   \tcode{local_iterator}; \br
    \tcode{const_local_iterator} for const \tcode{b}.
&   \requires \tcode{n} shall be in the range \tcode{[0, b.bucket_count())}.
    \tcode{b.end(n)} returns an iterator which is the past-the-end
    value for the bucket.%
&   Constant
\\ \rowsep
%
\indexunordmem{cbegin}%
\tcode{b.cbegin(n)}
&   \tcode{const_local_iterator}
&   \requires \tcode{n} shall be in the range \tcode{[0, b.bucket_count())}.
    \tcode{b.cbegin(n)} returns an iterator referring to the
    first element in the bucket. If the bucket is empty, then
    \tcode{b.cbegin(n) == b.cend(n)}.%
&   Constant
\\ \rowsep
%
\indexunordmem{cend}%
\tcode{b.cend(n)}
&   \tcode{const_local_iterator}
&   \requires \tcode{n} shall be in the range \tcode{[0, b.bucket_count())}.%
    \tcode{b.cend(n)} returns an iterator which is the past-the-end
    value for the bucket.%
&   Constant
\\ \rowsep
%
\indexunordmem{load_factor}%
\tcode{b.load_factor()}
&   \tcode{float}
&   Returns the average number of elements per bucket.%
&   Constant
\\ \rowsep
%
\indexunordmem{max_load_factor}%
\tcode{b.max_load_factor()}
&   \tcode{float}
&   Returns a positive number that the container attempts to keep the load factor
    less than or equal to. The container automatically increases the
    number of buckets as necessary to keep the load factor below this
    number.%
&   Constant
\\ \rowsep
%
\tcode{a.max_load_factor(z)}
&   \tcode{void}
&   \requires \tcode{z} shall be positive.
    May change the container's maximum load factor, using \tcode{z} as a hint.%
& Constant
\\ \rowsep
%
\indexunordmem{rehash}%
\tcode{a.rehash(n)}
& \tcode{void}
& \postconditions \tcode{a.bucket_count() >= a.size() / a.max_load_factor()} and
        \tcode{a.bucket_count() >= n}.%
& Average case linear in \tcode{a.size()}, worst case quadratic.
\\ \rowsep

\indexunordmem{reserve}%
\tcode{a.reserve(n)}  &
  \tcode{void}        &
  Same as \tcode{a.rehash(ceil(n /} \tcode{a.max_load_factor()))}.  &
  Average case linear in \tcode{a.size()}, worst case quadratic. \\

\end{libreqtab4d}
\pnum
Two unordered containers \tcode{a} and \tcode{b} compare equal if
\tcode{a.size() == b.size()} and, for every equivalent-key group
\range{Ea1}{Ea2} obtained from \tcode{a.equal_range(Ea1)}, there exists an
equivalent-key group \range{Eb1}{Eb2} obtained from \tcode{b.equal_range(Ea1)},
such that
\tcode{is_permutation(Ea1, Ea2, Eb1, Eb2)} returns \tcode{true}. For
\tcode{unordered_set} and \tcode{unordered_map}, the complexity of
\tcode{operator==} (i.e., the number of calls to the \tcode{==} operator
of the \tcode{value_type}, to the predicate returned by \tcode{key_eq()},
and to the hasher returned by \tcode{hash_function()}) is proportional to
$N$ in the average case and to $N^2$ in the worst case, where $N$ is
a.size(). For \tcode{unordered_multiset} and \tcode{unordered_multimap},
the complexity of \tcode{operator==} is proportional to $\sum E_i^2$
in the average case and to $N^2$ in the worst case, where $N$ is \tcode{a.size()},
and $E_i$ is the size of the $i^\text{th}$ equivalent-key group in \tcode{a}.
However, if the respective elements of each corresponding pair of
equivalent-key groups $Ea_i$ and $Eb_i$ are arranged in the same order
(as is commonly the case, e.g., if \tcode{a} and \tcode{b} are unmodified copies
of the same container), then the average-case complexity for
\tcode{unordered_multiset} and \tcode{unordered_multimap} becomes
proportional to $N$ (but worst-case complexity remains \bigoh{N^2}, e.g., for
a pathologically bad hash function). The behavior of a program that uses
\tcode{operator==} or \tcode{operator!=} on unordered containers is undefined
unless the \tcode{Pred} function object has
the same behavior for both containers and the equality comparison function
for \tcode{Key} is a refinement\footnote{Equality comparison is a refinement
of partitioning if no two objects that
compare equal fall into different partitions.}
of the partition into equivalent-key groups produced by \tcode{Pred}.

\pnum
\indextext{unordered associative containers!iterators}%
The iterator types \tcode{iterator} and \tcode{const_iterator} of
an unordered associative container are of at least the forward iterator
category.  For unordered associative containers where the key type and
value type are the same, both \tcode{iterator} and
\tcode{const_iterator} are constant iterators.

\pnum
\indextext{unordered associative containers!iterator invalidation}%
The \tcode{insert} and \tcode{emplace} members shall not affect the validity of references to
container elements, but may invalidate all iterators to the
container.  The \tcode{erase} members shall invalidate only iterators and
references to the erased elements, and preserve the relative order of the
elements that are not erased.

\pnum
\indextext{unordered associative containers!iterator invalidation}%
\indextext{unordered associative containers!requirements}%
The \tcode{insert} and \tcode{emplace} members shall not affect the validity of iterators if
\tcode{(N+n) <= z * B}, where \tcode{N} is the number of elements in
the container prior to the insert operation, \tcode{n} is the
number of elements inserted, \tcode{B} is the container's bucket count, and
\tcode{z} is the container's maximum load factor.

\pnum
The \tcode{extract} members invalidate only iterators to the removed element,
and preserve the relative order of the elements that are not erased; pointers
and references to the removed element remain valid. However, accessing the
element through such pointers and references while the element is owned by a
\tcode{node_type} is undefined behavior. References and pointers to an element
obtained while it is owned by a \tcode{node_type} are invalidated if the
element is successfully inserted.

\pnum
A deduction guide for an unordered associative container shall not participate in overload resolution
if any of the following are true:
\begin{itemize}
\item It has an \tcode{InputIterator} template parameter
and a type that does not qualify as an input iterator is deduced for that parameter.

\item It has an \tcode{Allocator} template parameter
and a type that does not qualify as an allocator is deduced for that parameter.

\item It has a \tcode{Hash} template parameter
and an integral type or a type that qualifies as an allocator is deduced for that parameter.

\item It has a \tcode{Pred} template parameter
and a type that qualifies as an allocator is deduced for that parameter.
\end{itemize}

\rSec3[unord.req.except]{Exception safety guarantees}

\pnum
\indextext{unordered associative containers!exception safety}%
\indextext{unordered associative containers!requirements}%
For unordered associative containers, no \tcode{clear()} function
throws an exception. \tcode{erase(k)} does not throw an
exception unless that exception is thrown by the container's \tcode{Hash} or
\tcode{Pred} object (if any).

\pnum
For unordered associative containers, if an exception is thrown by any
operation other than the container's hash function from within an
\tcode{insert} or \tcode{emplace} function inserting a single element,
the insertion has no effect.

\pnum
For unordered associative containers, no \tcode{swap} function throws
an exception unless that exception is thrown by the swap of the container's
\tcode{Hash} or \tcode{Pred} object (if any).

\pnum
\indextext{unordered associative containers!exception safety}%
\indextext{unordered associative containers!requirements}%
For unordered associative containers, if an exception is thrown
from within a \tcode{rehash()} function other than by the container's hash
function or comparison function, the \tcode{rehash()} function has no effect.

\rSec1[sequences]{Sequence containers}

\rSec2[sequences.general]{In general}

\pnum
The headers \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>},
\tcode{<list>}, and \tcode{<vector>} define class templates that meet the
requirements for sequence containers.

\pnum
The following exposition-only alias template may appear in deduction guides for sequence containers:

\begin{codeblock}
template<class InputIterator>
  using @\placeholdernc{iter-value-type}@ = typename iterator_traits<InputIterator>::value_type;  // \expos
\end{codeblock}

\rSec2[array.syn]{Header \tcode{<array>} synopsis}

\indexhdr{array}%
\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{array}, class template \tcode{array}
  template<class T, size_t N> struct array;

  template<class T, size_t N>
    bool operator==(const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    bool operator!=(const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    bool operator< (const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    bool operator> (const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    bool operator<=(const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    bool operator>=(const array<T, N>& x, const array<T, N>& y);
  template<class T, size_t N>
    void swap(array<T, N>& x, array<T, N>& y) noexcept(noexcept(x.swap(y)));

  template<class T> class tuple_size;
  template<size_t I, class T> class tuple_element;
  template<class T, size_t N>
    struct tuple_size<array<T, N>>;
  template<size_t I, class T, size_t N>
    struct tuple_element<I, array<T, N>>;
  template<size_t I, class T, size_t N>
    constexpr T& get(array<T, N>&) noexcept;
  template<size_t I, class T, size_t N>
    constexpr T&& get(array<T, N>&&) noexcept;
  template<size_t I, class T, size_t N>
    constexpr const T& get(const array<T, N>&) noexcept;
  template<size_t I, class T, size_t N>
    constexpr const T&& get(const array<T, N>&&) noexcept;
}
\end{codeblock}

\rSec2[deque.syn]{Header \tcode{<deque>} synopsis}

\indexhdr{deque}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{deque}, class template \tcode{deque}
  template<class T, class Allocator = allocator<T>> class deque;

  template<class T, class Allocator>
    bool operator==(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator< (const deque<T, Allocator>& x, const deque<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator!=(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator> (const deque<T, Allocator>& x, const deque<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator>=(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator<=(const deque<T, Allocator>& x, const deque<T, Allocator>& y);

  template<class T, class Allocator>
    void swap(deque<T, Allocator>& x, deque<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class T>
      using deque = std::deque<T, polymorphic_allocator<T>>;
  }
}
\end{codeblock}

\rSec2[forward_list.syn]{Header \tcode{<forward_list>} synopsis}

\indexhdr{forward_list}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{forwardlist}, class template \tcode{forward_list}
  template<class T, class Allocator = allocator<T>> class forward_list;

  template<class T, class Allocator>
    bool operator==(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator< (const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator!=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator> (const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator>=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator<=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);

  template<class T, class Allocator>
    void swap(forward_list<T, Allocator>& x, forward_list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class T>
      using forward_list = std::forward_list<T, polymorphic_allocator<T>>;
  }
}
\end{codeblock}

\rSec2[list.syn]{Header \tcode{<list>} synopsis}

\indexhdr{list}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{list}, class template \tcode{list}
  template<class T, class Allocator = allocator<T>> class list;

  template<class T, class Allocator>
    bool operator==(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator< (const list<T, Allocator>& x, const list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator!=(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator> (const list<T, Allocator>& x, const list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator>=(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator<=(const list<T, Allocator>& x, const list<T, Allocator>& y);

  template<class T, class Allocator>
    void swap(list<T, Allocator>& x, list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class T>
      using list = std::list<T, polymorphic_allocator<T>>;
  }
}
\end{codeblock}

\rSec2[vector.syn]{Header \tcode{<vector>} synopsis}

\indexhdr{vector}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{vector}, class template \tcode{vector}
  template<class T, class Allocator = allocator<T>> class vector;

  template<class T, class Allocator>
    bool operator==(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator< (const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator!=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator> (const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator>=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template<class T, class Allocator>
    bool operator<=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);

  template<class T, class Allocator>
    void swap(vector<T, Allocator>& x, vector<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  // \ref{vector.bool}, class \tcode{vector<bool>}
  template<class Allocator> class vector<bool, Allocator>;

  // hash support
  template<class T> struct hash;
  template<class Allocator> struct hash<vector<bool, Allocator>>;

  namespace pmr {
    template<class T>
      using vector = std::vector<T, polymorphic_allocator<T>>;
  }
}
\end{codeblock}

\rSec2[array]{Class template \tcode{array}}
\indexlibrary{\idxcode{array}}%

\rSec3[array.overview]{Overview}

\pnum
\indextext{\idxcode{array}!contiguous storage}%
The header \tcode{<array>} defines a class template for storing fixed-size
sequences of objects.
An \tcode{array} is a contiguous container\iref{container.requirements.general}.
An instance of \tcode{array<T, N>} stores \tcode{N} elements of type \tcode{T},
so that \tcode{size() == N} is an invariant.

\pnum
\indextext{\idxcode{array}!initialization}%
\indextext{\idxcode{array}!as aggregate}%
An \tcode{array} is an aggregate\iref{dcl.init.aggr} that can be
list-initialized with up
to \tcode{N} elements whose types are convertible to \tcode{T}.

\pnum
\indextext{requirements!container}%
An \tcode{array} satisfies all of the requirements of a container and
of a reversible container\iref{container.requirements}, except that a default
constructed \tcode{array} object is not empty and that \tcode{swap} does not have constant
complexity. An \tcode{array} satisfies some of the requirements of a sequence
container\iref{sequence.reqmts}.
Descriptions are provided here
only for operations on \tcode{array} that are not described in
one of these tables and
for operations where there is additional semantic information.

\pnum
The types \tcode{iterator} and \tcode{const_iterator} satisfy
the constexpr iterator requirements\iref{iterator.requirements.general}.

\indexlibrary{\idxcode{array}}%
\indexlibrarymember{array}{begin}%
\indexlibrarymember{array}{end}%
\indexlibrarymember{array}{size}%
\indexlibrarymember{array}{max_size}%
\begin{codeblock}
namespace std {
  template<class T, size_t N>
  struct array {
    // types
    using value_type             = T;
    using pointer                = T*;
    using const_pointer          = const T*;
    using reference              = T&;
    using const_reference        = const T&;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using iterator               = @\impdefx{type of \tcode{array::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{array::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // no explicit construct/copy/destroy for aggregate type

    void fill(const T& u);
    void swap(array&) noexcept(is_nothrow_swappable_v<T>);

    // iterators
    constexpr iterator               begin() noexcept;
    constexpr const_iterator         begin() const noexcept;
    constexpr iterator               end() noexcept;
    constexpr const_iterator         end() const noexcept;

    constexpr reverse_iterator       rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator       rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;

    constexpr const_iterator         cbegin() const noexcept;
    constexpr const_iterator         cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] constexpr bool empty() const noexcept;
    constexpr size_type size() const noexcept;
    constexpr size_type max_size() const noexcept;

    // element access
    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);
    constexpr const_reference at(size_type n) const;
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;

    constexpr T *       data() noexcept;
    constexpr const T * data() const noexcept;
  };

  template<class T, class... U>
    array(T, U...) -> array<T, 1 + sizeof...(U)>;
}
\end{codeblock}

\rSec3[array.cons]{Constructors, copy, and assignment}

\pnum
\indextext{\idxcode{array}!initialization}%
\indextext{requirements!container}%
The conditions for an aggregate\iref{dcl.init.aggr} shall be
met. Class \tcode{array} relies on the implicitly-declared special
member functions~(\ref{class.ctor}, \ref{class.dtor}, and \ref{class.copy}) to
conform to the container requirements table in~\ref{container.requirements}.
In addition to the requirements specified in the container requirements table,
the implicit move constructor and move assignment operator for \tcode{array}
require that \tcode{T} be \tcode{MoveConstructible} or \tcode{MoveAssignable},
respectively.

\begin{itemdecl}
template<class T, class... U>
  array(T, U...) -> array<T, 1 + sizeof...(U)>;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires \tcode{(is_same_v<T, U> \&\& ...)} is \tcode{true}. Otherwise the program is ill-formed.
\end{itemdescr}

\rSec3[array.members]{Member functions}

\indexlibrarymember{array}{size}%
\begin{itemdecl}
constexpr size_type size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{N}.
\end{itemdescr}

\indexlibrarymember{array}{data}%
\begin{itemdecl}
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns
A pointer such that \range{data()}{data() + size()} is a valid range. For a
non-empty array, \tcode{data()} \tcode{==} \tcode{addressof(front())}.
\end{itemdescr}

\indexlibrarymember{array}{fill}%
\begin{itemdecl}
void fill(const T& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{fill_n(begin(), N, u)}.
\end{itemdescr}

\indexlibrarymember{array}{swap}%
\begin{itemdecl}
void swap(array& y) noexcept(is_nothrow_swappable_v<T>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{swap_ranges(begin(), end(), y.begin())}.

\pnum
\begin{note}
Unlike the \tcode{swap} function for other containers, \tcode{array::swap}
takes linear time, may exit via an exception, and does not cause iterators to
become associated with the other container.
\end{note}
\end{itemdescr}

\rSec3[array.special]{Specialized algorithms}

\indexlibrarymember{array}{swap}%
\begin{itemdecl}
template<class T, size_t N>
  void swap(array<T, N>& x, array<T, N>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum\remarks
This function shall not participate in overload resolution
unless \tcode{N == 0} or \tcode{is_swappable_v<T>} is \tcode{true}.

\pnum\effects
As if by \tcode{x.swap(y)}.

\pnum
\complexity Linear in \tcode{N}.
\end{itemdescr}

\rSec3[array.zero]{Zero-sized arrays}

\indextext{\idxcode{array}!zero sized}%
\pnum\tcode{array} shall provide support for the special case \tcode{N == 0}.

\pnum In the case that \tcode{N == 0}, \tcode{begin() == end() ==} unique value.
The return value of \tcode{data()} is unspecified.

\pnum
The effect of calling \tcode{front()} or \tcode{back()} for a zero-sized array is
undefined.

\pnum
Member function \tcode{swap()} shall have a
non-throwing exception specification.

\rSec3[array.tuple]{Tuple interface}
\indexlibrary{\idxcode{array}}%
\indexlibrary{\idxcode{tuple}}%
\indextext{\idxcode{array}!tuple interface to}%
\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template<class T, size_t N>
  struct tuple_size<array<T, N>> : integral_constant<size_t, N> { };
\end{itemdecl}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
tuple_element<I, array<T, N>>::type
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < N}. The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\cvalue  The type T.
\end{itemdescr}

\indexlibrarymember{array}{get}%
\begin{itemdecl}
template<size_t I, class T, size_t N>
  constexpr T& get(array<T, N>& a) noexcept;
template<size_t I, class T, size_t N>
  constexpr T&& get(array<T, N>&& a) noexcept;
template<size_t I, class T, size_t N>
  constexpr const T& get(const array<T, N>& a) noexcept;
template<size_t I, class T, size_t N>
  constexpr const T&& get(const array<T, N>&& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < N}. The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\returns A reference to the $\tcode{I}^\text{th}$ element of \tcode{a},
where indexing is zero-based.
\end{itemdescr}

\rSec2[deque]{Class template \tcode{deque}}

\rSec3[deque.overview]{Overview}

\pnum
A
\indexlibrary{\idxcode{deque}}%
\tcode{deque}
is a sequence container that supports random access iterators\iref{random.access.iterators}.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
Storage management is handled automatically.

\pnum
A
\tcode{deque}
satisfies all of the requirements of a container, of a reversible container
(given in tables in~\ref{container.requirements}), of a sequence container,
including the optional sequence container requirements\iref{sequence.reqmts}, and of an allocator-aware container (\tref{containers.allocatoraware}).
Descriptions are provided here only for operations on
\tcode{deque}
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class T, class Allocator = allocator<T>>
  class deque {
  public:
    // types
    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{deque::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{deque::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // \ref{deque.cons}, construct/copy/destroy
    deque() : deque(Allocator()) { }
    explicit deque(const Allocator&);
    explicit deque(size_type n, const Allocator& = Allocator());
    deque(size_type n, const T& value, const Allocator& = Allocator());
    template<class InputIterator>
      deque(InputIterator first, InputIterator last, const Allocator& = Allocator());
    deque(const deque& x);
    deque(deque&&);
    deque(const deque&, const Allocator&);
    deque(deque&&, const Allocator&);
    deque(initializer_list<T>, const Allocator& = Allocator());

    ~deque();
    deque& operator=(const deque& x);
    deque& operator=(deque&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    deque& operator=(initializer_list<T>);
    template<class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // \ref{deque.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T& c);
    void      shrink_to_fit();

    // element access
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{deque.modifiers}, modifiers
    template<class... Args> reference emplace_front(Args&&... args);
    template<class... Args> reference emplace_back(Args&&... args);
    template<class... Args> iterator emplace(const_iterator position, Args&&... args);

    void push_front(const T& x);
    void push_front(T&& x);
    void push_back(const T& x);
    void push_back(T&& x);

    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template<class InputIterator>
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<T>);

    void pop_front();
    void pop_back();

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(deque&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    void     clear() noexcept;
  };

  template<class InputIterator, class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    deque(InputIterator, InputIterator, Allocator = Allocator())
      -> deque<@\placeholder{iter-value-type}@<InputIterator>, Allocator>;

  // swap
  template<class T, class Allocator>
    void swap(deque<T, Allocator>& x, deque<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\rSec3[deque.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{deque}!constructor}%
\begin{itemdecl}
explicit deque(const Allocator&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{deque},
using the specified allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{deque}!constructor}%
\begin{itemdecl}
explicit deque(size_type n, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{deque} with
\tcode{n} default-inserted elements using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{DefaultInsertable} into \tcode{*this}.

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{deque}!constructor}%
\begin{itemdecl}
deque(size_type n, const T& value, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{deque}
with \tcode{n} copies of \tcode{value},
using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{CopyInsertable} into \tcode{*this}.

\pnum
\complexity
Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{deque}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  deque(InputIterator first, InputIterator last, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{deque}
equal to the range
\range{first}{last},
using the specified allocator.

\pnum
\complexity Linear in \tcode{distance(first, last)}.
\end{itemdescr}

\rSec3[deque.capacity]{Capacity}

\indexlibrary{\idxcode{resize}!\idxcode{deque}}%
\begin{itemdecl}
void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, erases the last \tcode{size() - sz} elements
from the sequence. Otherwise,
appends \tcode{sz - size()} default-inserted elements to the sequence.

\pnum
\requires \tcode{T} shall be \tcode{MoveInsertable} and \tcode{DefaultInsertable} into \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{deque}}%
\begin{itemdecl}
void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, erases the last \tcode{size() - sz} elements
from the sequence. Otherwise,
appends \tcode{sz - size()} copies of \tcode{c} to the sequence.

\pnum
\requires \tcode{T} shall be
\tcode{CopyInsertable} into \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{shrink_to_fit}{deque}%
\begin{itemdecl}
void shrink_to_fit();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{MoveInsertable} into \tcode{*this}.

\pnum
\effects \tcode{shrink_to_fit} is a non-binding request to reduce memory use
but does not change the size of the sequence.
\begin{note} The request is non-binding to allow latitude for
implementation-specific optimizations. \end{note}
If an exception is thrown other than by the move constructor
of a non-\tcode{CopyInsertable} \tcode{T} there are no effects.

\pnum
\complexity Linear in the size of the sequence.

\pnum
\remarks \tcode{shrink_to_fit} invalidates all the references, pointers, and iterators
referring to the elements in the sequence as well as the past-the-end iterator.
\end{itemdescr}

\rSec3[deque.modifiers]{Modifiers}

\indexlibrary{\idxcode{insert}!\idxcode{deque}}%
\indexlibrary{\idxcode{push_front}!\idxcode{deque}}%
\indexlibrary{\idxcode{push_back}!\idxcode{deque}}%
\indexlibrary{\idxcode{emplace}!\idxcode{deque}}%
\begin{itemdecl}
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
  iterator insert(const_iterator position,
                  InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template<class... Args> reference emplace_front(Args&&... args);
template<class... Args> reference emplace_back(Args&&... args);
template<class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.

\pnum
\remarks
If an exception is thrown other than by the
copy constructor, move constructor,
assignment operator, or move assignment operator of
\tcode{T}
there are no effects.
If an exception is thrown while inserting a single element at either end,
there are no effects.
Otherwise, if an exception is thrown by the move constructor of a
non-\tcode{CopyInsertable}
\tcode{T}, the effects are unspecified.

\pnum
\complexity
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
\tcode{T}.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{deque}}%
\begin{itemdecl}
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_front();
void pop_back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
An erase operation that erases the last element of a deque invalidates only the past-the-end iterator
and all iterators and references to the erased elements. An erase operation that erases the first
element of a deque but not the last element invalidates only iterators
and references to the erased elements. An erase operation
that erases neither the first element nor the last element of a deque invalidates the past-the-end
iterator and all iterators and references to all the elements of the deque.
\begin{note} \tcode{pop_front} and \tcode{pop_back} are erase operations. \end{note}

\pnum
\complexity
The number of calls to the destructor of \tcode{T} is the same as the
number of elements erased, but the number of calls to the assignment operator of \tcode{T} is
no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by the assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec2[forwardlist]{Class template \tcode{forward_list}}

\rSec3[forwardlist.overview]{Overview}

\pnum
A \tcode{forward_list} is a container that supports forward iterators and allows
constant time insert and erase operations anywhere within the sequence, with storage
management handled automatically. Fast random access to list elements is not supported.
\begin{note} It is intended that \tcode{forward_list} have zero space or time overhead
relative to a hand-written C-style singly linked list. Features that would conflict with
that goal have been omitted.\end{note}

\pnum
A \tcode{forward_list} satisfies all of the requirements of a container
(\tref{containers.container.requirements}), except that the \tcode{size()}
member function is not provided and \tcode{operator==} has linear complexity.
A \tcode{forward_list} also satisfies all of the requirements for an allocator-aware
container (\tref{containers.allocatoraware}). In addition, a \tcode{forward_list}
provides the \tcode{assign} member functions
(\tref{containers.sequence.requirements}) and several of the optional
container requirements (\tref{containers.sequence.optional}).
Descriptions are provided here only for operations on
\tcode{forward_list} that are not described in that table or for operations where there
is additional semantic information.

\pnum
\begin{note} Modifying any list requires access to the element preceding the first element
of interest, but in a \tcode{forward_list} there is no constant-time way to access a
preceding element. For this reason, ranges that are modified, such as those supplied to
\tcode{erase} and \tcode{splice}, must be open at the beginning. \end{note}

\begin{codeblock}
namespace std {
  template<class T, class Allocator = allocator<T>>
  class forward_list {
  public:
    // types
    using value_type      = T;
    using allocator_type  = Allocator;
    using pointer         = typename allocator_traits<Allocator>::pointer;
    using const_pointer   = typename allocator_traits<Allocator>::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    using size_type       = @\impdef@; // see \ref{container.requirements}
    using difference_type = @\impdef@; // see \ref{container.requirements}
    using iterator        = @\impdefx{type of \tcode{forward_list::iterator}}@; // see \ref{container.requirements}
    using const_iterator  = @\impdefx{type of \tcode{forward_list::const_iterator}}@; // see \ref{container.requirements}

    // \ref{forwardlist.cons}, construct/copy/destroy
    forward_list() : forward_list(Allocator()) { }
    explicit forward_list(const Allocator&);
    explicit forward_list(size_type n, const Allocator& = Allocator());
    forward_list(size_type n, const T& value, const Allocator& = Allocator());
    template<class InputIterator>
      forward_list(InputIterator first, InputIterator last, const Allocator& = Allocator());
    forward_list(const forward_list& x);
    forward_list(forward_list&& x);
    forward_list(const forward_list& x, const Allocator&);
    forward_list(forward_list&& x, const Allocator&);
    forward_list(initializer_list<T>, const Allocator& = Allocator());
    ~forward_list();
    forward_list& operator=(const forward_list& x);
    forward_list& operator=(forward_list&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    forward_list& operator=(initializer_list<T>);
    template<class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // \ref{forwardlist.iter}, iterators
    iterator before_begin() noexcept;
    const_iterator before_begin() const noexcept;
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cbefore_begin() const noexcept;
    const_iterator cend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type max_size() const noexcept;

    // \ref{forwardlist.access}, element access
    reference front();
    const_reference front() const;

    // \ref{forwardlist.modifiers}, modifiers
    template<class... Args> reference emplace_front(Args&&... args);
    void push_front(const T& x);
    void push_front(T&& x);
    void pop_front();

    template<class... Args> iterator emplace_after(const_iterator position, Args&&... args);
    iterator insert_after(const_iterator position, const T& x);
    iterator insert_after(const_iterator position, T&& x);

    iterator insert_after(const_iterator position, size_type n, const T& x);
    template<class InputIterator>
      iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
    iterator insert_after(const_iterator position, initializer_list<T> il);

    iterator erase_after(const_iterator position);
    iterator erase_after(const_iterator position, const_iterator last);
    void swap(forward_list&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);

    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);
    void clear() noexcept;

    // \ref{forwardlist.ops}, \tcode{forward_list} operations
    void splice_after(const_iterator position, forward_list& x);
    void splice_after(const_iterator position, forward_list&& x);
    void splice_after(const_iterator position, forward_list& x, const_iterator i);
    void splice_after(const_iterator position, forward_list&& x, const_iterator i);
    void splice_after(const_iterator position, forward_list& x,
                      const_iterator first, const_iterator last);
    void splice_after(const_iterator position, forward_list&& x,
                      const_iterator first, const_iterator last);

    void remove(const T& value);
    template<class Predicate> void remove_if(Predicate pred);

    void unique();
    template<class BinaryPredicate> void unique(BinaryPredicate binary_pred);

    void merge(forward_list& x);
    void merge(forward_list&& x);
    template<class Compare> void merge(forward_list& x, Compare comp);
    template<class Compare> void merge(forward_list&& x, Compare comp);

    void sort();
    template<class Compare> void sort(Compare comp);

    void reverse() noexcept;
  };

  template<class InputIterator, class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    forward_list(InputIterator, InputIterator, Allocator = Allocator())
      -> forward_list<@\placeholder{iter-value-type}@<InputIterator>, Allocator>;

  // swap
  template<class T, class Allocator>
    void swap(forward_list<T, Allocator>& x, forward_list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
An incomplete type \tcode{T} may be used when instantiating \tcode{forward_list}
if the allocator satisfies the
allocator completeness requirements\iref{allocator.requirements.completeness}.
\tcode{T} shall be complete before any member of the resulting specialization
of \tcode{forward_list} is referenced.

\rSec3[forwardlist.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{forward_list}!constructor}%
\begin{itemdecl}
explicit forward_list(const Allocator&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{forward_list} object using the specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{forward_list}!constructor}%
\begin{itemdecl}
explicit forward_list(size_type n, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n}
default-inserted elements using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{DefaultInsertable} into \tcode{*this}.

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{forward_list}!constructor}%
\begin{itemdecl}
forward_list(size_type n, const T& value, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n} copies of \tcode{value} using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{CopyInsertable} into \tcode{*this}.

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{forward_list}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  forward_list(InputIterator first, InputIterator last, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object equal to the range \range{first}{last}.

\pnum
\complexity Linear in \tcode{distance(first, last)}.
\end{itemdescr}

\rSec3[forwardlist.iter]{Iterators}

\indexlibrarymember{before_begin}{forward_list}%
\indexlibrarymember{cbefore_begin}{forward_list}%
\begin{itemdecl}
iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
const_iterator cbefore_begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A non-dereferenceable iterator that, when incremented, is equal to the iterator
returned by \tcode{begin()}.

\pnum
\effects \tcode{cbefore_begin()} is equivalent to
\tcode{const_cast<forward_list const\&>(*this).before_begin()}.

\pnum
\remarks \tcode{before_begin() == end()} shall equal \tcode{false}.
\end{itemdescr}

\rSec3[forwardlist.access]{Element access}

\indexlibrarymember{front}{forward_list}%
\begin{itemdecl}
reference front();
const_reference front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*begin()}
\end{itemdescr}

\rSec3[forwardlist.modifiers]{Modifiers}

\pnum
None of the overloads of \tcode{insert_after} shall affect the validity of iterators and
references, and \tcode{erase_after} shall invalidate only iterators and references to
the erased elements. If an exception is thrown during \tcode{insert_after} there shall
be no effect. Inserting \tcode{n} elements into a \tcode{forward_list} is linear in
\tcode{n}, and the number of calls to the copy or move constructor of \tcode{T} is
exactly equal to \tcode{n}. Erasing \tcode{n} elements from a \tcode{forward_list} is
linear in \tcode{n} and the number of calls to the destructor of type \tcode{T} is
exactly equal to \tcode{n}.

\indexlibrarymember{emplace_front}{forward_list}%
\begin{itemdecl}
template<class... Args> reference emplace_front(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Inserts an object of type \tcode{value_type} constructed with
\tcode{value_type(std::forward<Args>(\brk{}args)...)} at the beginning of the list.
\end{itemdescr}

\indexlibrarymember{push_front}{forward_list}%
\begin{itemdecl}
void push_front(const T& x);
void push_front(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Inserts a copy of \tcode{x} at the beginning of the list.
\end{itemdescr}


\indexlibrarymember{pop}{forward_list}%
\begin{itemdecl}
void pop_front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{erase_after(before_begin())}.
\end{itemdescr}

\indexlibrarymember{insert_after}{forward_list}%
\begin{itemdecl}
iterator insert_after(const_iterator position, const T& x);
iterator insert_after(const_iterator position, T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.

\pnum
\effects Inserts a copy of \tcode{x} after \tcode{position}.

\pnum
\returns An iterator pointing to the copy of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{insert_after}{forward_list}%
\begin{itemdecl}
iterator insert_after(const_iterator position, size_type n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.

\pnum
\effects Inserts \tcode{n} copies of \tcode{x} after \tcode{position}.

\pnum
\returns
An iterator pointing to the last inserted copy of \tcode{x} or \tcode{position} if \tcode{n == 0}.
\end{itemdescr}

\indexlibrarymember{insert_after}{forward_list}%
\begin{itemdecl}
template<class InputIterator>
  iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.
\tcode{first} and \tcode{last} are not iterators in \tcode{*this}.

\pnum
\effects Inserts copies of elements in \range{first}{last} after \tcode{position}.

\pnum
\returns
An iterator pointing to the last inserted element or \tcode{position} if \tcode{first == last}.
\end{itemdescr}

\indexlibrarymember{insert_after}{forward_list}%
\begin{itemdecl}
iterator insert_after(const_iterator position, initializer_list<T> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{insert_after(p, il.begin(), il.end())}.

\pnum
\returns
An iterator pointing to the last inserted element or \tcode{position} if \tcode{il} is empty.
\end{itemdescr}


\indexlibrarymember{emplace_after}{forward_list}%
\begin{itemdecl}
template<class... Args>
  iterator emplace_after(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.

\pnum
\effects Inserts an object of type \tcode{value_type} constructed with
\tcode{value_type(std::forward<Args>(\brk{}args)...)} after \tcode{position}.

\pnum
\returns An iterator pointing to the new object.
\end{itemdescr}

\indexlibrarymember{erase_after}{forward_list}%
\begin{itemdecl}
iterator erase_after(const_iterator position);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The iterator following \tcode{position} is dereferenceable.

\pnum
\effects Erases the element pointed to by the iterator following \tcode{position}.

\pnum
\returns An iterator pointing to the element following the one that was
erased, or \tcode{end()} if no such element exists.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{erased}{forward_list}%
\begin{itemdecl}
iterator erase_after(const_iterator position, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires All iterators in the range \orange{position}{last} are dereferenceable.

\pnum
\effects Erases the elements in the range \orange{position}{last}.

\pnum
\returns \tcode{last}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{resize}{forward_list}%
\begin{itemdecl}
void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < distance(begin(), end())}, erases the last \tcode{distance(begin(),
end()) - sz} elements from the list. Otherwise, inserts \tcode{sz - distance(begin(), end())} default-inserted
elements at the end of the list.

\pnum
\requires \tcode{T} shall be \tcode{DefaultInsertable} into \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
void resize(size_type sz, const value_type& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < distance(begin(), end())}, erases the last \tcode{distance(begin(),
end()) - sz} elements from the list. Otherwise, inserts \tcode{sz - distance(begin(), end())}
copies of \tcode{c} at the end of the list.

\pnum
\requires \tcode{T} shall be \tcode{CopyInsertable} into \tcode{*this}.
\end{itemdescr}


\indexlibrarymember{clear}{forward_list}%
\begin{itemdecl}
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Erases all elements in the range \range{begin()}{end()}.

\pnum
\remarks Does not invalidate past-the-end iterators.
\end{itemdescr}

\rSec3[forwardlist.ops]{Operations}

\pnum
In this subclause,
arguments for a template parameter
named \tcode{Predicate} or \tcode{BinaryPredicate}
shall satisfy the corresponding requirements in \ref{algorithms.requirements}.
For \tcode{merge} and \tcode{sort},
the definitions and requirements in \ref{alg.sorting} apply.

\indexlibrarymember{splice_after}{forward_list}%
\begin{itemdecl}
void splice_after(const_iterator position, forward_list& x);
void splice_after(const_iterator position, forward_list&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.
\tcode{get_allocator() == x.get_allocator()}.
\tcode{addressof(x) != this}.

\pnum
\effects Inserts the contents of \tcode{x} after
\tcode{position}, and \tcode{x} becomes empty. Pointers and references to the moved
elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}.
Iterators referring to the moved elements will continue to refer to their elements, but
they now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{\tcode{distance(x.begin(), x.end())}}
\end{itemdescr}

\indexlibrarymember{splice_after}{forward_list}%
\begin{itemdecl}
void splice_after(const_iterator position, forward_list& x, const_iterator i);
void splice_after(const_iterator position, forward_list&& x, const_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a dereferenceable
iterator in the range \range{begin()}{end()}.
The iterator following \tcode{i} is a dereferenceable iterator in \tcode{x}.
\tcode{get_allocator() == x.get_allocator()}.

\pnum
\effects Inserts the element following \tcode{i} into \tcode{*this}, following
\tcode{position}, and removes it from \tcode{x}.
The result is unchanged if \tcode{position == i} or \tcode{position == ++i}. Pointers
and references to \tcode{*++i} continue to refer to the same element but as a member of
\tcode{*this}. Iterators to \tcode{*++i} continue to refer to
the same element, but now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{1}
\end{itemdescr}

\indexlibrarymember{splice_after}{forward_list}%
\begin{itemdecl}
void splice_after(const_iterator position, forward_list& x,
                  const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&& x,
                  const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is \tcode{before_begin()} or is a
dereferenceable iterator in the range \range{begin()}{end()}. \orange{first}{last} is a
valid range in \tcode{x}, and all iterators in the range \orange{first}{last} are
dereferenceable. \tcode{position} is not an iterator in the range \orange{first}{last}.
\tcode{get_allocator() == x.get_allocator()}.

\pnum
\effects Inserts elements in the range \orange{first}{last} after \tcode{position} and
removes the elements from \tcode{x}. Pointers and references to the moved elements of
\tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators
referring to the moved elements will continue to refer to their elements, but they now
behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\complexity \bigoh{\tcode{distance(first, last)}}
\end{itemdescr}

\indexlibrarymember{remove}{forward_list}%
\indexlibrarymember{remove_if}{forward_list}%
\begin{itemdecl}
void remove(const T& value);
template<class Predicate> void remove_if(Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Erases all the elements in the list referred by a list iterator \tcode{i} for
which the following conditions hold: \tcode{*i == value} (for \tcode{remove()}),
\tcode{pred(*i)} is \tcode{true} (for \tcode{remove_if()}).
Invalidates only the iterators and references to the erased elements.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the
predicate.

\pnum
\remarks Stable\iref{algorithm.stable}.

\pnum
\complexity Exactly \tcode{distance(begin(), end())} applications of the corresponding
predicate.
\end{itemdescr}

\indexlibrarymember{unique}{forward_list}%
\begin{itemdecl}
void unique();
template<class BinaryPredicate> void unique(BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Erases all but the first element from every consecutive
group of equal elements referred to by the iterator \tcode{i} in the range \range{first +
1}{last} for which \tcode{*i == *(i-1)} (for the version with no arguments) or \tcode{pred(*i,
*(i - 1))} (for the version with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the predicate.

\pnum
\complexity If the range \range{first}{last} is not empty, exactly \tcode{(last - first) - 1} applications of the corresponding predicate, otherwise no applications of the predicate.
\end{itemdescr}

\indexlibrarymember{merge}{forward_list}%
\begin{itemdecl}
void merge(forward_list& x);
void merge(forward_list&& x);
template<class Compare> void merge(forward_list& x, Compare comp);
template<class Compare> void merge(forward_list&& x, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{*this} and \tcode{x} are both sorted with respect to
the comparator \tcode{operator<} (for the first two overloads) or
\tcode{comp} (for the last two overloads), and
\tcode{get_allocator() == x.get_allocator()} is \tcode{true}.

\pnum
\effects Merges the two sorted ranges \tcode{[begin(), end())} and
\tcode{[x.begin(), x.end())}. \tcode{x} is empty after the merge. If an
exception is thrown other than by a comparison there are no effects.
Pointers and references to the moved elements of \tcode{x} now refer to those same elements
but as members of \tcode{*this}. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into \tcode{*this}, not into
\tcode{x}.

\pnum
\remarks Stable\iref{algorithm.stable}. The behavior is undefined if
\tcode{get_allocator() != x.get_allocator()}.

\pnum
\complexity At most \tcode{distance(begin(),
end()) + distance(x.begin(), x.end()) - 1} comparisons.
\end{itemdescr}

\indexlibrarymember{sort}{forward_list}%
\begin{itemdecl}
void sort();
template<class Compare> void sort(Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Sorts the list according to the \tcode{operator<} or the \tcode{comp} function object.
If an exception is thrown, the order of the elements in \tcode{*this} is unspecified.
Does not affect the validity of iterators and references.

\pnum
\remarks Stable\iref{algorithm.stable}.

\pnum
\complexity Approximately $N \log N$ comparisons, where $N$ is \tcode{distance(begin(), end())}.
\end{itemdescr}

\indexlibrarymember{reverse}{forward_list}%
\begin{itemdecl}
void reverse() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.

\pnum
\complexity Linear time.
\end{itemdescr}

\rSec2[list]{Class template \tcode{list}}

\rSec3[list.overview]{Overview}

\pnum
\indexlibrary{\idxcode{list}}%
A
\tcode{list}
is a sequence container that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike vectors\iref{vector} and deques\iref{deque},
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.

\pnum
A \tcode{list} satisfies all of the requirements of a container, of
a reversible container (given in two tables in
\ref{container.requirements}), of a sequence container,
including most of the optional sequence container
requirements\iref{sequence.reqmts}, and of an allocator-aware container
(\tref{containers.allocatoraware}).
The exceptions are the
\tcode{operator[]}
and
\tcode{at}
member functions, which are not provided.\footnote{These member functions
are only provided by containers whose iterators
are random access iterators.
}
Descriptions are provided here only for operations on
\tcode{list}
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class T, class Allocator = allocator<T>>
  class list {
  public:
    // types
    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{list::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{list::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // \ref{list.cons}, construct/copy/destroy
    list() : list(Allocator()) { }
    explicit list(const Allocator&);
    explicit list(size_type n, const Allocator& = Allocator());
    list(size_type n, const T& value, const Allocator& = Allocator());
    template<class InputIterator>
      list(InputIterator first, InputIterator last, const Allocator& = Allocator());
    list(const list& x);
    list(list&& x);
    list(const list&, const Allocator&);
    list(list&&, const Allocator&);
    list(initializer_list<T>, const Allocator& = Allocator());
    ~list();
    list& operator=(const list& x);
    list& operator=(list&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    list& operator=(initializer_list<T>);
    template<class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // \ref{list.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T& c);

    // element access
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{list.modifiers}, modifiers
    template<class... Args> reference emplace_front(Args&&... args);
    template<class... Args> reference emplace_back(Args&&... args);
    void push_front(const T& x);
    void push_front(T&& x);
    void pop_front();
    void push_back(const T& x);
    void push_back(T&& x);
    void pop_back();

    template<class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template<class InputIterator>
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<T> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator position, const_iterator last);
    void     swap(list&) noexcept(allocator_traits<Allocator>::is_always_equal::value);
    void     clear() noexcept;

    // \ref{list.ops}, list operations
    void splice(const_iterator position, list& x);
    void splice(const_iterator position, list&& x);
    void splice(const_iterator position, list& x, const_iterator i);
    void splice(const_iterator position, list&& x, const_iterator i);
    void splice(const_iterator position, list& x, const_iterator first, const_iterator last);
    void splice(const_iterator position, list&& x, const_iterator first, const_iterator last);

    void remove(const T& value);
    template<class Predicate> void remove_if(Predicate pred);

    void unique();
    template<class BinaryPredicate>
      void unique(BinaryPredicate binary_pred);

    void merge(list& x);
    void merge(list&& x);
    template<class Compare> void merge(list& x, Compare comp);
    template<class Compare> void merge(list&& x, Compare comp);

    void sort();
    template<class Compare> void sort(Compare comp);

    void reverse() noexcept;
  };

  template<class InputIterator, class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    list(InputIterator, InputIterator, Allocator = Allocator())
      -> list<@\placeholder{iter-value-type}@<InputIterator>, Allocator>;

  // swap
  template<class T, class Allocator>
    void swap(list<T, Allocator>& x, list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
An incomplete type \tcode{T} may be used when instantiating \tcode{list}
if the allocator satisfies the
allocator completeness requirements\iref{allocator.requirements.completeness}.
\tcode{T} shall be complete before any member of the resulting specialization
of \tcode{list} is referenced.

\rSec3[list.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{list}!constructor}%
\begin{itemdecl}
explicit list(const Allocator&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty list, using the specified allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{list}!constructor}%
\begin{itemdecl}
explicit list(size_type n, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{list} with
\tcode{n} default-inserted elements using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{DefaultInsertable} into \tcode{*this}.

\pnum
\complexity
Linear in
\tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{list}!constructor}%
\begin{itemdecl}
list(size_type n, const T& value, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{list}
with
\tcode{n}
copies of
\tcode{value},
using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{CopyInsertable} into \tcode{*this}.

\pnum
\complexity
Linear in
\tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{list}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  list(InputIterator first, InputIterator last, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{list}
equal to the range
\range{first}{last}.

\pnum
\complexity
Linear in
\tcode{distance(first, last)}.
\end{itemdescr}

\rSec3[list.capacity]{Capacity}

\indexlibrary{\idxcode{resize}!\idxcode{list}}%
\begin{itemdecl}
void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{size() < sz},
appends \tcode{sz - size()} default-inserted elements to the
sequence.
If \tcode{sz <= size()}, equivalent to:

\begin{codeblock}
list<T>::iterator it = begin();
advance(it, sz);
erase(it, end());
\end{codeblock}


\pnum
\requires \tcode{T} shall be
\tcode{DefaultInsertable} into \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{list}}%
\begin{itemdecl}
void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 // do nothing
\end{codeblock}

\pnum
\requires \tcode{T} shall be \tcode{CopyInsertable} into \tcode{*this}.
\end{itemdescr}

\rSec3[list.modifiers]{Modifiers}

\indexlibrary{\idxcode{insert}!\idxcode{list}}%
\begin{itemdecl}
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
  iterator insert(const_iterator position, InputIterator first,
                  InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template<class... Args> reference emplace_front(Args&&... args);
template<class... Args> reference emplace_back(Args&&... args);
template<class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.

\pnum
\complexity
Insertion of a single element into a list takes constant time and
exactly one call to a constructor of
\tcode{T}. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor or move constructor of \tcode{T} is exactly equal
to the number of elements inserted.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{list}}%
\begin{itemdecl}
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Invalidates only the iterators and references to the erased elements.

\pnum
\throws Nothing.

\pnum
\complexity
Erasing a single element is a constant time operation with a single call to the destructor of
\tcode{T}.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
\tcode{T}
is exactly equal to the size of the range.
\end{itemdescr}

\rSec3[list.ops]{Operations}

\pnum
Since lists allow fast insertion and erasing from the middle of a list, certain
operations are provided specifically for them.\footnote{As specified
in~\ref{allocator.requirements}, the requirements in this Clause apply only to
lists whose allocators compare equal.}
In this subclause,
arguments for a template parameter
named \tcode{Predicate} or \tcode{BinaryPredicate}
shall satisfy the corresponding requirements in \ref{algorithms.requirements}.
For \tcode{merge} and \tcode{sort},
the definitions and requirements in \ref{alg.sorting} apply.

\pnum
\tcode{list} provides three splice operations that destructively move elements from one list to
another. The behavior of splice operations is undefined if \tcode{get_allocator() !=
x.get_allocator()}.

\indexlibrary{\idxcode{splice}!\idxcode{list}}%
\begin{itemdecl}
void splice(const_iterator position, list& x);
void splice(const_iterator position, list&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{addressof(x) != this}.

\pnum
\effects
Inserts the contents of
\tcode{x}
before
\tcode{position}
and
\tcode{x}
becomes empty.
Pointers and references to the moved elements of
\tcode{x}
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{splice}{list}%
\begin{itemdecl}
void splice(const_iterator position, list& x, const_iterator i);
void splice(const_iterator position, list&& x, const_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{i}
is a valid dereferenceable iterator of
\tcode{x}.

\pnum
\effects
Inserts an element pointed to by
\tcode{i}
from list
\tcode{x}
before \tcode{position} and removes the element from
\tcode{x}.
The result is unchanged if
\tcode{position == i}
or
\tcode{position == ++i}.
Pointers and references to
\tcode{*i}
continue to refer to this same element but as a member of
\tcode{*this}.
Iterators
to
\tcode{*i}
(including
\tcode{i}
itself) continue to refer to the same element, but now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{splice}{list}%
\begin{itemdecl}
void splice(const_iterator position, list& x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&& x, const_iterator first,
            const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{[first, last)}
is a valid range in
\tcode{x}.
The program has undefined behavior if
\tcode{position}
is an iterator in the range
\range{first}{last}.

\pnum
\effects
Inserts elements in the range
\range{first}{last}
before
\tcode{position}
and removes the elements from
\tcode{x}.
Pointers and references to the moved elements of
\tcode{x}
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity
Constant time if
\tcode{\&x == this};
otherwise, linear time.
\end{itemdescr}

\indexlibrary{\idxcode{remove}!\idxcode{list}}%
\begin{itemdecl}
void remove(const T& value);
template<class Predicate> void remove_if(Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Erases all the elements in the list referred by a list iterator \tcode{i} for which the
following conditions hold: \tcode{*i == value}, \tcode{pred(*i) != false}.
Invalidates only the iterators and references to the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by
\tcode{*i == value}
or
\tcode{pred(*i) != false}.

\pnum
\remarks Stable\iref{algorithm.stable}.

\pnum
\complexity
Exactly
\tcode{size()}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{unique}!\idxcode{list}}%
\begin{itemdecl}
void unique();
template<class BinaryPredicate> void unique(BinaryPredicate binary_pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Erases all but the first element from every
consecutive group of equal elements referred to by the iterator \tcode{i} in the range
\range{first + 1}{last} for which \tcode{*i == *(i-1)} (for the version of
\tcode{unique} with no arguments) or \tcode{pred(*i, *(i - 1))} (for the version of
\tcode{unique} with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by
\tcode{*i == *(i-1)}
or
\tcode{pred(*i, *(i - 1))}

\pnum
\complexity
If the range
\tcode{[first, last)}
is not empty, exactly
\tcode{(last - first) - 1}
applications of the corresponding predicate,
otherwise no applications of the predicate.
\end{itemdescr}

\indexlibrary{\idxcode{merge}!\idxcode{list}}%
\begin{itemdecl}
void merge(list& x);
void merge(list&& x);
template<class Compare> void merge(list& x, Compare comp);
template<class Compare> void merge(list&& x, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Both the list and the argument list
shall be sorted with respect to
the comparator \tcode{operator<} (for the first two overloads) or
\tcode{comp} (for the last two overloads).

\pnum
\effects
If \tcode{addressof(x) == this}, does nothing; otherwise, merges the two sorted ranges \tcode{[begin(),
end())} and \tcode{[x.\brk{}begin(), x.end())}. The result is a range in which the elements
will be sorted in non-decreasing order according to the ordering defined by \tcode{comp}; that
is, for every iterator \tcode{i}, in the range other than the first, the condition
\tcode{comp(*i, *(i - 1))} will be \tcode{false}.
Pointers and references to the moved elements of \tcode{x} now refer to those same elements
but as members of \tcode{*this}. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into \tcode{*this}, not into
\tcode{x}.

\pnum
\remarks Stable\iref{algorithm.stable}. If \tcode{addressof(x) != this}, the range \tcode{[x.begin(), x.end())}
is empty after the merge.
No elements are copied by this operation. The behavior is undefined if
\tcode{get_allocator() != x.get_allocator()}.

\pnum
\complexity
At most
\tcode{size() + x.size() - 1}
applications of \tcode{comp} if
\tcode{addressof(x) != this};
otherwise, no applications of \tcode{comp} are performed.
If an exception is thrown other than by a comparison there are no effects.
\end{itemdescr}

\indexlibrary{\idxcode{reverse}!\idxcode{list}}%
\begin{itemdecl}
void reverse() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.

\pnum
\complexity
Linear time.
\end{itemdescr}

\indexlibrary{\idxcode{sort}!\idxcode{list}}%
\begin{itemdecl}
void sort();
template<class Compare> void sort(Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sorts the list according to the \tcode{operator<} or a \tcode{Compare} function object.
If an exception is thrown,
the order of the elements in \tcode{*this} is unspecified.
Does not affect the validity of iterators and references.

\pnum
\remarks Stable\iref{algorithm.stable}.

\pnum
\complexity
Approximately
$N \log N$
comparisons, where
\tcode{N == size()}.
\end{itemdescr}

\rSec2[vector]{Class template \tcode{vector}}

\rSec3[vector.overview]{Overview}

\pnum
\indexlibrary{\idxcode{vector}}%
A
\tcode{vector}
is a sequence container that supports
(amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.

\pnum
A \tcode{vector} satisfies all of the requirements of a container and of a
reversible container (given in two tables in~\ref{container.requirements}), of a
sequence container, including most of the optional sequence container
requirements\iref{sequence.reqmts}, of an allocator-aware container
(\tref{containers.allocatoraware}),
and, for an element type other than \tcode{bool},
of a contiguous container\iref{container.requirements.general}.
The exceptions are the
\tcode{push_front}, \tcode{pop_front}, and \tcode{emplace_front} member functions, which are not
provided. Descriptions are provided here only for operations on \tcode{vector}
that are not described in one of these tables or for operations where there is
additional semantic information.

\begin{codeblock}
namespace std {
  template<class T, class Allocator = allocator<T>>
  class vector {
  public:
    // types
    using value_type             = T;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{vector::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{vector::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // \ref{vector.cons}, construct/copy/destroy
    vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
    explicit vector(const Allocator&) noexcept;
    explicit vector(size_type n, const Allocator& = Allocator());
    vector(size_type n, const T& value, const Allocator& = Allocator());
    template<class InputIterator>
      vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
    vector(const vector& x);
    vector(vector&&) noexcept;
    vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
    vector(initializer_list<T>, const Allocator& = Allocator());
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x)
      noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    vector& operator=(initializer_list<T>);
    template<class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& u);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // \ref{vector.capacity}, capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T& c);
    void      reserve(size_type n);
    void      shrink_to_fit();

    // element access
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{vector.data}, data access
    T*       data() noexcept;
    const T* data() const noexcept;

    // \ref{vector.modifiers}, modifiers
    template<class... Args> reference emplace_back(Args&&... args);
    void push_back(const T& x);
    void push_back(T&& x);
    void pop_back();

    template<class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template<class InputIterator>
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<T> il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(vector&)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    void     clear() noexcept;
  };

  template<class InputIterator, class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    vector(InputIterator, InputIterator, Allocator = Allocator())
      -> vector<@\placeholder{iter-value-type}@<InputIterator>, Allocator>;

  // swap
  template<class T, class Allocator>
    void swap(vector<T, Allocator>& x, vector<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}%
\indexlibrary{\idxcode{vector}!\idxcode{operator==}}%
\indexlibrary{\idxcode{vector}!\idxcode{operator<}}

\pnum
An incomplete type \tcode{T} may be used when instantiating \tcode{vector}
if the allocator satisfies the
allocator completeness requirements\iref{allocator.requirements.completeness}.
\tcode{T} shall be complete before any member of the resulting specialization
of \tcode{vector} is referenced.

\rSec3[vector.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{vector}!constructor}
\begin{itemdecl}
explicit vector(const Allocator&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{vector}, using the
specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{vector}!constructor}
\begin{itemdecl}
explicit vector(size_type n, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
default-inserted elements using the specified allocator.

\pnum
\requires \tcode{T} shall be \tcode{DefaultInsertable} into \tcode{*this}.

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{vector}!constructor}
\begin{itemdecl}
vector(size_type n, const T& value,
       const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
copies of \tcode{value}, using the specified allocator.

\pnum
\requires \tcode{T} shall be
\tcode{CopyInsertable} into \tcode{*this}.

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{vector}!constructor}
\begin{itemdecl}
template<class InputIterator>
  vector(InputIterator first, InputIterator last,
         const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects Constructs a \tcode{vector} equal to the
range \range{first}{last}, using the specified allocator.

\pnum
\complexity
Makes only $N$
calls to the copy constructor of
\tcode{T}
(where $N$
is the distance between
\tcode{first}
and
\tcode{last})
and no reallocations if iterators \tcode{first} and \tcode{last} are of forward, bidirectional, or random access categories.
It makes order
\tcode{N}
calls to the copy constructor of
\tcode{T}
and order
$\log N$
reallocations if they are just input iterators.
\end{itemdescr}

\rSec3[vector.capacity]{Capacity}

\indexlibrary{\idxcode{capacity}!\idxcode{vector}}%
\begin{itemdecl}
size_type capacity() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The total number of elements that the vector can hold
without requiring reallocation.

\pnum
\complexity Constant time.
\end{itemdescr}

\indexlibrary{\idxcode{reserve}!\idxcode{vector}}%
\begin{itemdecl}
void reserve(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{MoveInsertable} into \tcode{*this}.

\pnum
\effects
A directive that informs a
\tcode{vector}
of a planned change in size, so that it can manage the storage allocation accordingly.
After
\tcode{reserve()},
\tcode{capacity()}
is greater or equal to the argument of
\tcode{reserve}
if reallocation happens; and equal to the previous value of
\tcode{capacity()}
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
\tcode{reserve()}. If an exception is thrown
other than by the move constructor of a non-\tcode{CopyInsertable} type,
there are no effects.

\pnum
\complexity
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.

\pnum
\throws
\tcode{length_error} if \tcode{n >
max_size()}.\footnote{\tcode{reserve()} uses \tcode{Allocator::allocate()} which
may throw an appropriate exception.}

\pnum
\remarks
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
No reallocation shall take place during insertions that happen
after a call to
\tcode{reserve()}
until the time when an insertion would make the size of the vector
greater than the value of
\tcode{capacity()}.
\end{itemdescr}

\indexlibrary{\idxcode{shrink_to_fit}!\idxcode{vector}}%
\begin{itemdecl}
void shrink_to_fit();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{MoveInsertable} into \tcode{*this}.

\pnum
\effects \tcode{shrink_to_fit} is a non-binding request to reduce
\tcode{capacity()} to \tcode{size()}.
\begin{note} The request is non-binding to allow latitude for
implementation-specific optimizations. \end{note}
It does not increase \tcode{capacity()}, but may reduce \tcode{capacity()}
by causing reallocation.
If an exception is thrown other than by the move constructor
of a non-\tcode{CopyInsertable} \tcode{T} there are no effects.

\pnum
\complexity Linear in the size of the sequence.

\pnum
\remarks Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence as well as the past-the-end iterator.
If no reallocation happens, they remain valid.
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\idxcode{vector}}%
\begin{itemdecl}
void swap(vector& x)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Exchanges the contents and
\tcode{capacity()}
of
\tcode{*this}
with that of \tcode{x}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{vector}}%
\begin{itemdecl}
void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, erases the last \tcode{size() - sz} elements
from the sequence. Otherwise,
appends \tcode{sz - size()} default-inserted elements to the sequence.

\pnum
\requires \tcode{T} shall be
\tcode{MoveInsertable} and \tcode{DefaultInsertable} into \tcode{*this}.

\pnum
\remarks If an exception is thrown other than by the move constructor of a non-\tcode{CopyInsertable}
\tcode{T} there are no effects.
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{vector}}%
\begin{itemdecl}
void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, erases the last \tcode{size() - sz} elements
from the sequence. Otherwise,
appends \tcode{sz - size()} copies of \tcode{c} to the sequence.

\pnum
\requires \tcode{T} shall be
\tcode{CopyInsertable} into \tcode{*this}.

\pnum
\remarks If an exception is thrown there are no effects.
\end{itemdescr}

\rSec3[vector.data]{Data}

\indexlibrary{\idxcode{data}!\idxcode{vector}}%
\begin{itemdecl}
T*         data() noexcept;
const T*   data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer such that \range{data()}{data() + size()} is a valid range. For a
non-empty vector, \tcode{data()} \tcode{==} \tcode{addressof(front())}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\rSec3[vector.modifiers]{Modifiers}

\indexlibrary{\idxcode{insert}!\idxcode{vector}}%
\begin{itemdecl}
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
  iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template<class... Args> reference emplace_back(Args&&... args);
template<class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_back(const T& x);
void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Causes reallocation if the new size is greater than the old capacity.
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor, move constructor,
assignment operator, or move assignment operator of
\tcode{T} or by any \tcode{InputIterator} operation
there are no effects.
If an exception is thrown while inserting a single element at the end and
\tcode{T} is \tcode{CopyInsertable} or \tcode{is_nothrow_move_constructible_v<T>}
is \tcode{true}, there are no effects.
Otherwise, if an exception is thrown by the move constructor of a non-\tcode{CopyInsertable}
\tcode{T}, the effects are unspecified.

\pnum
\complexity
The complexity is linear in the number of elements inserted plus the distance
to the end of the vector.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{vector}}%
\begin{itemdecl}
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Invalidates iterators and references at or after the point of the erase.

\pnum
\complexity
The destructor of \tcode{T} is called the number of times equal to the
number of the elements erased, but the assignment operator
of \tcode{T} is called the number of times equal to the number of
elements in the vector after the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by the
assignment operator or move assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec2[vector.bool]{Class \tcode{vector<bool>}}

\pnum
\indexlibrary{\idxcode{vector<bool>}}%
To optimize space allocation, a specialization of vector for
\tcode{bool}
elements is provided:

\begin{codeblock}
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
  public:
    // types
    using value_type             = bool;
    using allocator_type         = Allocator;
    using pointer                = @\impdef@;
    using const_pointer          = @\impdef@;
    using const_reference        = bool;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{vector<bool>::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{vector<bool>::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // bit reference
    class reference {
      friend class vector;
      reference() noexcept;
    public:
      ~reference();
      operator bool() const noexcept;
      reference& operator=(const bool x) noexcept;
      reference& operator=(const reference& x) noexcept;
      void flip() noexcept;     // flips the bit
    };

    // construct/copy/destroy
    vector() : vector(Allocator()) { }
    explicit vector(const Allocator&);
    explicit vector(size_type n, const Allocator& = Allocator());
    vector(size_type n, const bool& value, const Allocator& = Allocator());
    template<class InputIterator>
      vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
    vector(const vector& x);
    vector(vector&& x);
    vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
    vector(initializer_list<bool>, const Allocator& = Allocator()));
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x);
    vector& operator=(initializer_list<bool>);
    template<class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const bool& t);
    void assign(initializer_list<bool>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz, bool c = false);
    void      reserve(size_type n);
    void      shrink_to_fit();

    // element access
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // modifiers
    template<class... Args> reference emplace_back(Args&&... args);
    void push_back(const bool& x);
    void pop_back();
    template<class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const bool& x);
    iterator insert(const_iterator position, size_type n, const bool& x);
    template<class InputIterator>
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<bool> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector&);
    static void swap(reference x, reference y) noexcept;
    void flip() noexcept;       // flips all bits
    void clear() noexcept;
  };
}
\end{codeblock}%

\pnum
Unless described below, all operations have the same requirements and
semantics as the primary \tcode{vector} template, except that operations
dealing with the \tcode{bool} value type map to bit values in the
container storage and
\tcode{allocator_traits::construct}\iref{allocator.traits.members}
is not used to construct these values.

\pnum
There is no requirement that the data be stored as a contiguous allocation
of \tcode{bool} values. A space-optimized representation of bits is
recommended instead.

\pnum
\tcode{reference}
is a class that simulates the behavior of references of a single bit in
\tcode{vector<bool>}. The conversion function returns \tcode{true}
when the bit is set, and \tcode{false} otherwise. The assignment operator
sets the bit when the argument is (convertible to) \tcode{true} and
clears it otherwise. \tcode{flip} reverses the state of the bit.

\indexlibrarymember{flip}{vector<bool>}%
\begin{itemdecl}
void flip() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Replaces each element in the container with its complement.
\end{itemdescr}

\indexlibrarymember{swap}{vector<bool>}%
\begin{itemdecl}
static void swap(reference x, reference y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Exchanges the contents of \tcode{x} and \tcode{y} as if by:

\begin{codeblock}
bool b = x;
x = y;
y = b;
\end{codeblock}

\end{itemdescr}

\begin{itemdecl}
template<class Allocator> struct hash<vector<bool, Allocator>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization is enabled\iref{unord.hash}.
\end{itemdescr}

\rSec1[associative]{Associative containers}

\rSec2[associative.general]{In general}

\pnum
The header \tcode{<map>} defines the class templates \tcode{map} and
\tcode{multimap}; the header \tcode{<set>} defines the class templates
\tcode{set} and \tcode{multiset}.

\pnum
The following exposition-only alias templates may appear in deduction guides for associative containers:
\begin{codeblock}
template<class InputIterator>
  using @\placeholder{iter-value-type}@ =
    typename iterator_traits<InputIterator>::value_type;                // \expos
template<class InputIterator>
  using @\placeholder{iter-key-type}@ = remove_const_t<
    typename iterator_traits<InputIterator>::value_type::first_type>;   // \expos
template<class InputIterator>
  using @\placeholder{iter-mapped-type}@ =
    typename iterator_traits<InputIterator>::value_type::second_type;   // \expos
template<class InputIterator>
  using @\placeholder{iter-to-alloc-type}@ = pair<
    add_const_t<typename iterator_traits<InputIterator>::value_type::first_type>,
    typename iterator_traits<InputIterator>::value_type::second_type>;  // \expos
\end{codeblock}

\rSec2[associative.map.syn]{Header \tcode{<map>} synopsis}

\indexhdr{map}%
\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{map}, class template \tcode{map}
  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
    class map;

  template<class Key, class T, class Compare, class Allocator>
    bool operator==(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator< (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator!=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator> (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator>=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator<=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);

  template<class Key, class T, class Compare, class Allocator>
    void swap(map<Key, T, Compare, Allocator>& x,
              map<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  // \ref{multimap}, class template \tcode{multimap}
  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
    class multimap;

  template<class Key, class T, class Compare, class Allocator>
    bool operator==(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator< (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator!=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator> (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator>=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template<class Key, class T, class Compare, class Allocator>
    bool operator<=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);

  template<class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key, T, Compare, Allocator>& x,
              multimap<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class Key, class T, class Compare = less<Key>>
      using map = std::map<Key, T, Compare,
                           polymorphic_allocator<pair<const Key, T>>>;

    template<class Key, class T, class Compare = less<Key>>
      using multimap = std::multimap<Key, T, Compare,
                                     polymorphic_allocator<pair<const Key, T>>>;
  }
}
\end{codeblock}

\rSec2[associative.set.syn]{Header \tcode{<set>} synopsis}%

\indexhdr{set}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{set}, class template \tcode{set}
  template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
    class set;

  template<class Key, class Compare, class Allocator>
    bool operator==(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator< (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator!=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator> (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator>=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator<=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);

  template<class Key, class Compare, class Allocator>
    void swap(set<Key, Compare, Allocator>& x,
              set<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  // \ref{multiset}, class template \tcode{multiset}
  template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
    class multiset;

  template<class Key, class Compare, class Allocator>
    bool operator==(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator< (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator> (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template<class Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);

  template<class Key, class Compare, class Allocator>
    void swap(multiset<Key, Compare, Allocator>& x,
              multiset<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class Key, class Compare = less<Key>>
      using set = std::set<Key, Compare, polymorphic_allocator<Key>>;

    template<class Key, class Compare = less<Key>>
      using multiset = std::multiset<Key, Compare, polymorphic_allocator<Key>>;
  }
}
\end{codeblock}

\rSec2[map]{Class template \tcode{map}}

\rSec3[map.overview]{Overview}

\indexlibrary{\idxcode{map}}%
\pnum
A \tcode{map} is an associative container that
supports unique keys (contains at most one of each key value) and
provides for fast retrieval of values of another type \tcode{T} based
on the keys. The \tcode{map} class supports bidirectional iterators.

\pnum
A
\tcode{map}
satisfies all of the requirements of a container, of a reversible container\iref{container.requirements}, of
an associative container\iref{associative.reqmts}, and of an allocator-aware container (\tref{containers.allocatoraware}).
A
\tcode{map}
also provides most operations described in~\ref{associative.reqmts}
for unique keys.
This means that a
\tcode{map}
supports the
\tcode{a_uniq}
operations in~\ref{associative.reqmts}
but not the
\tcode{a_eq}
operations.
For a
\tcode{map<Key,T>}
the
\tcode{key_type}
is
\tcode{Key}
and the
\tcode{value_type}
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{map}
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
  class map {
  public:
    // types
    using key_type               = Key;
    using mapped_type            = T;
    using value_type             = pair<const Key, T>;
    using key_compare            = Compare;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{map::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{map::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using node_type              = @\unspec@;
    using insert_return_type     = @\placeholdernc{INSERT_RETURN_TYPE}@<iterator, node_type>;

    class value_compare {
      friend class map;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // \ref{map.cons}, construct/copy/destroy
    map() : map(Compare()) { }
    explicit map(const Compare& comp, const Allocator& = Allocator());
    template<class InputIterator>
      map(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    map(const map& x);
    map(map&& x);
    explicit map(const Allocator&);
    map(const map&, const Allocator&);
    map(map&&, const Allocator&);
    map(initializer_list<value_type>,
      const Compare& = Compare(),
      const Allocator& = Allocator());
    template<class InputIterator>
      map(InputIterator first, InputIterator last, const Allocator& a)
        : map(first, last, Compare(), a) { }
    map(initializer_list<value_type> il, const Allocator& a)
      : map(il, Compare(), a) { }
    ~map();
    map& operator=(const map& x);
    map& operator=(map&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Compare>);
    map& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{map.access}, element access
    T& operator[](const key_type& x);
    T& operator[](key_type&& x);
    T&       at(const key_type& x);
    const T& at(const key_type& x) const;

    // \ref{map.modifiers}, modifiers
    template<class... Args> pair<iterator, bool> emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& x);
    pair<iterator, bool> insert(value_type&& x);
    template<class P> pair<iterator, bool> insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template<class P>
      iterator insert(const_iterator position, P&&);
    template<class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    insert_return_type insert(node_type&& nh);
    iterator           insert(const_iterator hint, node_type&& nh);

    template<class... Args>
      pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template<class... Args>
      pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template<class... Args>
      iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
    template<class... Args>
      iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template<class M>
      pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template<class M>
      pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template<class M>
      iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
    template<class M>
      iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(map&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Compare>);
    void      clear() noexcept;

    template<class C2>
      void merge(map<Key, T, C2, Allocator>& source);
    template<class C2>
      void merge(map<Key, T, C2, Allocator>&& source);
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>& source);
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>&& source);

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // map operations
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template<class K> iterator       find(const K& x);
    template<class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template<class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template<class K> iterator       lower_bound(const K& x);
    template<class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template<class K> iterator       upper_bound(const K& x);
    template<class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template<class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template<class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    map(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
      -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare, Allocator>;

  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
    map(initializer_list<pair<const Key, T>>, Compare = Compare(), Allocator = Allocator())
      -> map<Key, T, Compare, Allocator>;

  template<class InputIterator, class Allocator>
    map(InputIterator, InputIterator, Allocator)
      -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
             less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class Key, class T, class Allocator>
    map(initializer_list<pair<const Key, T>>, Allocator) -> map<Key, T, less<Key>, Allocator>;

  // swap
  template<class Key, class T, class Compare, class Allocator>
    void swap(map<Key, T, Compare, Allocator>& x,
              map<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}


\rSec3[map.cons]{Constructors, copy, and assignment}%
\indexlibrary{\idxcode{map}!\idxcode{operator==}}%
\indexlibrary{\idxcode{map}!\idxcode{operator<}}

\indexlibrary{\idxcode{map}!constructor}%
\begin{itemdecl}
explicit map(const Compare& comp, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{map}
using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{map}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  map(InputIterator first, InputIterator last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{map}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in $N$ if the range
\range{first}{last}
is already sorted using \tcode{comp}
and otherwise $N \log N$, where $N$
is \tcode{last - first}.
\end{itemdescr}

\rSec3[map.access]{Element access}

\indexlibrary{\idxcode{operator[]}!\idxcode{map}}%
\begin{itemdecl}
T& operator[](const key_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return try_emplace(x).first->second;}
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{map}}%
\begin{itemdecl}
T& operator[](key_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return try_emplace(move(x)).first->second;}
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{map}}%
\begin{itemdecl}
T&       at(const key_type& x);
const T& at(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to the \tcode{mapped_type} corresponding to \tcode{x} in \tcode{*this}.

\pnum
\throws
An exception object of type \tcode{out_of_range} if
no such element is present.

\pnum
\complexity Logarithmic.
\end{itemdescr}

\rSec3[map.modifiers]{Modifiers}

\indexlibrarymember{insert}{map}%
\begin{itemdecl}
template<class P>
  pair<iterator, bool> insert(P&& x);
template<class P>
  iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first form is equivalent to
\tcode{return emplace(std::forward<P>(x))}. The second form is
equivalent to \tcode{return emplace_hint(position, std::forward<P>(x))}.

\pnum
\remarks
These signatures shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is
\tcode{true}.
\end{itemdescr}

\indexlibrarymember{try_emplace}{map}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{map}
from \tcode{piecewise_construct}, \tcode{for\-ward_as_tuple(k)},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\effects
If the map already contains an element
whose key is equivalent to \tcode{k},
there is no effect.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{piecewise_construct}, \tcode{forward_as_tuple(k)},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{try_emplace}{map}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{map}
from \tcode{piecewise_construct}, \tcode{for\-ward_as_tuple(std::move(k))},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\effects
If the map already contains an element
whose key is equivalent to \tcode{k},
there is no effect.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{piecewise_construct}, \tcode{forward_as_tuple(std::move(k))},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{map}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_assignable_v<mapped_type\&, M\&\&>} shall be \tcode{true}.
\tcode{value_type} shall be \tcode{Emplace\-Constructible} into \tcode{map}
from \tcode{k}, \tcode{forward<M>(obj)}.

\pnum
\effects
If the map already contains an element \tcode{e}
whose key is equivalent to \tcode{k},
assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{k}, \tcode{std::forward<M>(obj)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{map}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_assignable_v<mapped_type\&, M\&\&>} shall be \tcode{true}.
\tcode{value_type} shall be \tcode{Emplace\-Constructible} into \tcode{map}
from \tcode{move(k)}, \tcode{forward<M>(obj)}.

\pnum
\effects
If the map already contains an element \tcode{e}
whose key is equivalent to \tcode{k},
assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{std::\brk{}move(k)}, \tcode{std::forward<M>(obj)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\rSec2[multimap]{Class template \tcode{multimap}}

\rSec3[multimap.overview]{Overview}

\pnum
\indexlibrary{\idxcode{multimap}}%
A
\tcode{multimap}
is an associative container that supports equivalent keys (possibly containing multiple copies of
the same key value) and provides for fast retrieval of values of another type
\tcode{T}
based on the keys.
The
\tcode{multimap}
class
supports bidirectional iterators.

\pnum
A
\tcode{multimap} satisfies all of the requirements of a container and of a
reversible container\iref{container.requirements}, of an associative
container\iref{associative.reqmts}, and of an allocator-aware container
(\tref{containers.allocatoraware}).
A
\tcode{multimap}
also provides most operations described in~\ref{associative.reqmts}
for equal keys.
This means that a
\tcode{multimap}
supports the
\tcode{a_eq}
operations in~\ref{associative.reqmts}
but not the
\tcode{a_uniq}
operations.
For a
\tcode{multimap<Key,T>}
the
\tcode{key_type}
is
\tcode{Key}
and the
\tcode{value_type}
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{multimap}
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
  class multimap {
  public:
    // types
    using key_type               = Key;
    using mapped_type            = T;
    using value_type             = pair<const Key, T>;
    using key_compare            = Compare;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{multimap::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{multimap::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using node_type              = @\unspec@;

    class value_compare {
      friend class multimap;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) { }
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // \ref{multimap.cons}, construct/copy/destroy
    multimap() : multimap(Compare()) { }
    explicit multimap(const Compare& comp, const Allocator& = Allocator());
    template<class InputIterator>
      multimap(InputIterator first, InputIterator last,
               const Compare& comp = Compare(),
               const Allocator& = Allocator());
    multimap(const multimap& x);
    multimap(multimap&& x);
    explicit multimap(const Allocator&);
    multimap(const multimap&, const Allocator&);
    multimap(multimap&&, const Allocator&);
    multimap(initializer_list<value_type>,
      const Compare& = Compare(),
      const Allocator& = Allocator());
    template<class InputIterator>
      multimap(InputIterator first, InputIterator last, const Allocator& a)
        : multimap(first, last, Compare(), a) { }
    multimap(initializer_list<value_type> il, const Allocator& a)
      : multimap(il, Compare(), a) { }
    ~multimap();
    multimap& operator=(const multimap& x);
    multimap& operator=(multimap&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Compare>);
    multimap& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{multimap.modifiers}, modifiers
    template<class... Args> iterator emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    template<class P> iterator insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template<class P> iterator insert(const_iterator position, P&& x);
    template<class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    iterator insert(node_type&& nh);
    iterator insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(multimap&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Compare>);
    void      clear() noexcept;

    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>& source);
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>&& source);
    template<class C2>
      void merge(map<Key, T, C2, Allocator>& source);
    template<class C2>
      void merge(map<Key, T, C2, Allocator>&& source);

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // map operations
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template<class K> iterator       find(const K& x);
    template<class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template<class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template<class K> iterator       lower_bound(const K& x);
    template<class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template<class K> iterator       upper_bound(const K& x);
    template<class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template<class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template<class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    multimap(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
      -> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                  Compare, Allocator>;

  template<class Key, class T, class Compare = less<Key>,
           class Allocator = allocator<pair<const Key, T>>>
    multimap(initializer_list<pair<const Key, T>>, Compare = Compare(), Allocator = Allocator())
      -> multimap<Key, T, Compare, Allocator>;

  template<class InputIterator, class Allocator>
    multimap(InputIterator, InputIterator, Allocator)
      -> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                  less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class Key, class T, class Allocator>
    multimap(initializer_list<pair<const Key, T>>, Allocator)
      -> multimap<Key, T, less<Key>, Allocator>;

  // swap
  template<class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key, T, Compare, Allocator>& x,
              multimap<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}%
\indexlibrary{\idxcode{multimap}!\idxcode{operator==}}%
\indexlibrary{\idxcode{multimap}!\idxcode{operator<}}

\rSec3[multimap.cons]{Constructors}

\indexlibrary{\idxcode{multimap}!constructor}%
\begin{itemdecl}
explicit multimap(const Compare& comp, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multimap}
using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{multimap}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  multimap(InputIterator first, InputIterator last,
           const Compare& comp = Compare(),
           const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multimap}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in $N$ if the range
\range{first}{last}
is already sorted using \tcode{comp}
and otherwise $N \log N$,
where $N$ is
\tcode{last - first}.
\end{itemdescr}

\rSec3[multimap.modifiers]{Modifiers}

\indexlibrarymember{insert}{multimap}%
\begin{itemdecl}
template<class P> iterator insert(P&& x);
template<class P> iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first form is equivalent to
\tcode{return emplace(std::forward<P>(x))}. The second form is
equivalent to \tcode{return emplace_hint(position, std::forward<P>(x))}.

\pnum
\remarks
These signatures shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is
\tcode{true}.
\end{itemdescr}

\rSec2[set]{Class template \tcode{set}}

\rSec3[set.overview]{Overview}

\pnum
\indexlibrary{\idxcode{set}}%
A
\tcode{set}
is an associative container that supports unique keys (contains at most one of each key value) and
provides for fast retrieval of the keys themselves.
The
\tcode{set} class
supports bidirectional iterators.

\pnum
A \tcode{set} satisfies all of the requirements of a container, of a reversible
container\iref{container.requirements}, of an associative
container\iref{associative.reqmts}, and of an allocator-aware container
(\tref{containers.allocatoraware}).
A
\tcode{set}
also provides most operations described in~\ref{associative.reqmts}
for unique keys.
This means that a
\tcode{set}
supports the
\tcode{a_uniq}
operations in~\ref{associative.reqmts}
but not the
\tcode{a_eq}
operations.
For a
\tcode{set<Key>}
both the
\tcode{key_type}
and
\tcode{value_type}
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{set}
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class Key, class Compare = less<Key>,
           class Allocator = allocator<Key>>
  class set {
  public:
    // types
    using key_type               = Key;
    using key_compare            = Compare;
    using value_type             = Key;
    using value_compare          = Compare;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{set::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{set::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using node_type              = @\unspec@;
    using insert_return_type     = @\placeholdernc{INSERT_RETURN_TYPE}@<iterator, node_type>;

    // \ref{set.cons}, construct/copy/destroy
    set() : set(Compare()) { }
    explicit set(const Compare& comp, const Allocator& = Allocator());
    template<class InputIterator>
      set(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    set(const set& x);
    set(set&& x);
    explicit set(const Allocator&);
    set(const set&, const Allocator&);
    set(set&&, const Allocator&);
    set(initializer_list<value_type>, const Compare& = Compare(),
        const Allocator& = Allocator());
    template<class InputIterator>
      set(InputIterator first, InputIterator last, const Allocator& a)
        : set(first, last, Compare(), a) { }
    set(initializer_list<value_type> il, const Allocator& a)
      : set(il, Compare(), a) { }
    ~set();
    set& operator=(const set& x);
    set& operator=(set&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Compare>);
    set& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // modifiers
    template<class... Args> pair<iterator, bool> emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator,bool> insert(const value_type& x);
    pair<iterator,bool> insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template<class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    insert_return_type insert(node_type&& nh);
    iterator           insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(set&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Compare>);
    void      clear() noexcept;

    template<class C2>
      void merge(set<Key, C2, Allocator>& source);
    template<class C2>
      void merge(set<Key, C2, Allocator>&& source);
    template<class C2>
      void merge(multiset<Key, C2, Allocator>& source);
    template<class C2>
      void merge(multiset<Key, C2, Allocator>&& source);

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template<class K> iterator       find(const K& x);
    template<class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template<class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template<class K> iterator       lower_bound(const K& x);
    template<class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template<class K> iterator       upper_bound(const K& x);
    template<class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template<class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template<class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template<class InputIterator,
           class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    set(InputIterator, InputIterator,
        Compare = Compare(), Allocator = Allocator())
      -> set<@\placeholder{iter-value-type}@<InputIterator>, Compare, Allocator>;

  template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
    set(initializer_list<Key>, Compare = Compare(), Allocator = Allocator())
      -> set<Key, Compare, Allocator>;

  template<class InputIterator, class Allocator>
    set(InputIterator, InputIterator, Allocator)
      -> set<@\placeholder{iter-value-type}@<InputIterator>,
             less<@\placeholder{iter-value-type}@<InputIterator>>, Allocator>;

  template<class Key, class Allocator>
    set(initializer_list<Key>, Allocator) -> set<Key, less<Key>, Allocator>;

  // swap
  template<class Key, class Compare, class Allocator>
    void swap(set<Key, Compare, Allocator>& x,
              set<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}%
\indexlibrary{\idxcode{set}!\idxcode{operator==}}%
\indexlibrary{\idxcode{set}!\idxcode{operator<}}

\rSec3[set.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{set}!constructor}%
\begin{itemdecl}
explicit set(const Compare& comp, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty \tcode{set} using the specified comparison objects and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{set}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  set(InputIterator first, InputIterator last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{set}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in $N$ if the range
\range{first}{last}
is already sorted using \tcode{comp}
and otherwise $N \log N$,
where $N$ is
\tcode{last - first}.
\end{itemdescr}

\rSec2[multiset]{Class template \tcode{multiset}}

\rSec3[multiset.overview]{Overview}

\pnum
\indexlibrary{\idxcode{multiset}}%
A
\tcode{multiset}
is an associative container that supports equivalent keys (possibly contains multiple copies of
the same key value) and provides for fast retrieval of the keys themselves.
The
\tcode{multiset} class
supports bidirectional iterators.

\pnum
A \tcode{multiset} satisfies all of the requirements of a container, of a
reversible container\iref{container.requirements}, of an associative
container\iref{associative.reqmts}, and of an allocator-aware container
(\tref{containers.allocatoraware}).
\tcode{multiset}
also provides most operations described in~\ref{associative.reqmts}
for duplicate keys.
This means that a
\tcode{multiset}
supports the
\tcode{a_eq}
operations in~\ref{associative.reqmts}
but not the
\tcode{a_uniq}
operations.
For a
\tcode{multiset<Key>}
both the
\tcode{key_type}
and
\tcode{value_type}
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{multiset}
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template<class Key, class Compare = less<Key>,
           class Allocator = allocator<Key>>
  class multiset {
  public:
    // types
    using key_type               = Key;
    using key_compare            = Compare;
    using value_type             = Key;
    using value_compare          = Compare;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdef@; // see \ref{container.requirements}
    using difference_type        = @\impdef@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{multiset::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{multiset::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using node_type              = @\unspec@;

    // \ref{multiset.cons}, construct/copy/destroy
    multiset() : multiset(Compare()) { }
    explicit multiset(const Compare& comp, const Allocator& = Allocator());
    template<class InputIterator>
      multiset(InputIterator first, InputIterator last,
               const Compare& comp = Compare(), const Allocator& = Allocator());
    multiset(const multiset& x);
    multiset(multiset&& x);
    explicit multiset(const Allocator&);
    multiset(const multiset&, const Allocator&);
    multiset(multiset&&, const Allocator&);
    multiset(initializer_list<value_type>, const Compare& = Compare(),
             const Allocator& = Allocator());
    template<class InputIterator>
      multiset(InputIterator first, InputIterator last, const Allocator& a)
        : multiset(first, last, Compare(), a) { }
    multiset(initializer_list<value_type> il, const Allocator& a)
      : multiset(il, Compare(), a) { }
    ~multiset();
    multiset& operator=(const multiset& x);
    multiset& operator=(multiset&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Compare>);
    multiset& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // modifiers
    template<class... Args> iterator emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template<class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    iterator insert(node_type&& nh);
    iterator insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(multiset&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Compare>);
    void      clear() noexcept;

    template<class C2>
      void merge(multiset<Key, C2, Allocator>& source);
    template<class C2>
      void merge(multiset<Key, C2, Allocator>&& source);
    template<class C2>
      void merge(set<Key, C2, Allocator>& source);
    template<class C2>
      void merge(set<Key, C2, Allocator>&& source);

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template<class K> iterator       find(const K& x);
    template<class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template<class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template<class K> iterator       lower_bound(const K& x);
    template<class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template<class K> iterator       upper_bound(const K& x);
    template<class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template<class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template<class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template<class InputIterator,
           class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    multiset(InputIterator, InputIterator,
             Compare = Compare(), Allocator = Allocator())
      -> multiset<@\placeholder{iter-value-type}@<InputIterator>, Compare, Allocator>;

  template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
    multiset(initializer_list<Key>, Compare = Compare(), Allocator = Allocator())
      -> multiset<Key, Compare, Allocator>;

  template<class InputIterator, class Allocator>
    multiset(InputIterator, InputIterator, Allocator)
      -> multiset<@\placeholder{iter-value-type}@<InputIterator>,
                  less<@\placeholder{iter-value-type}@<InputIterator>>, Allocator>;

  template<class Key, class Allocator>
    multiset(initializer_list<Key>, Allocator) -> multiset<Key, less<Key>, Allocator>;

  // swap
  template<class Key, class Compare, class Allocator>
    void swap(multiset<Key, Compare, Allocator>& x,
              multiset<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}%
\indexlibrary{\idxcode{multiset}!\idxcode{operator==}}%
\indexlibrary{\idxcode{multiset}!\idxcode{operator<}}

\rSec3[multiset.cons]{Constructors}

\indexlibrary{\idxcode{multiset}!constructor}%
\begin{itemdecl}
explicit multiset(const Compare& comp, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty \tcode{multiset} using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{multiset}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  multiset(InputIterator first, InputIterator last,
           const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multiset}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in $N$
if the range
\range{first}{last}
is already sorted using \tcode{comp} and otherwise $N \log N$,
where $N$ is
\tcode{last - first}.
\end{itemdescr}

\rSec1[unord]{Unordered associative containers}

\rSec2[unord.general]{In general}

\pnum
The header \tcode{<unordered_map>} defines the class templates
\tcode{unordered_map} and
\tcode{unordered_multimap}; the header \tcode{<unordered_set>} defines the class templates
\tcode{unordered_set} and \tcode{unordered_multiset}.

\pnum
The exposition-only alias templates \placeholder{iter-value-type},
\placeholder{iter-key-type}, \placeholder{iter-mapped-type}, and \placeholder{iter-to-alloc-type}
defined in \ref{associative.general} may appear in deduction guides for unordered containers.

\rSec2[unord.map.syn]{Header \tcode{<unordered_map>} synopsis}%
\indexhdr{unordered_map}%
\indexlibrary{\idxcode{unordered_map}}%
\indexlibrary{\idxcode{unordered_multimap}}%
\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{unord.map}, class template \tcode{unordered_map}
  template<class Key,
           class T,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Alloc = allocator<pair<const Key, T>>>
    class unordered_map;

  // \ref{unord.multimap}, class template \tcode{unordered_multimap}
  template<class Key,
           class T,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Alloc = allocator<pair<const Key, T>>>
    class unordered_multimap;

  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);
  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);

  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);

  template<class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template<class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class Key,
             class T,
             class Hash = hash<Key>,
             class Pred = equal_to<Key>>
      using unordered_map =
        std::unordered_map<Key, T, Hash, Pred,
                           polymorphic_allocator<pair<const Key, T>>>;
    template<class Key,
             class T,
             class Hash = hash<Key>,
             class Pred = equal_to<Key>>
      using unordered_multimap =
        std::unordered_multimap<Key, T, Hash, Pred,
                                polymorphic_allocator<pair<const Key, T>>>;

  }
}
\end{codeblock}

\rSec2[unord.set.syn]{Header \tcode{<unordered_set>} synopsis}%
\indexhdr{unordered_set}%
\indexlibrary{\idxcode{unordered_set}}%
\indexlibrary{\idxcode{unordered_multiset}}%
\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{unord.set}, class template \tcode{unordered_set}
  template<class Key,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Alloc = allocator<Key>>
    class unordered_set;

  // \ref{unord.multiset}, class template \tcode{unordered_multiset}
  template<class Key,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Alloc = allocator<Key>>
    class unordered_multiset;

  template<class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);
  template<class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);

  template<class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);
  template<class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);

  template<class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
              unordered_set<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template<class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
              unordered_multiset<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template<class Key,
             class Hash = hash<Key>,
             class Pred = equal_to<Key>>
      using unordered_set = std::unordered_set<Key, Hash, Pred,
                                               polymorphic_allocator<Key>>;

    template<class Key,
             class Hash = hash<Key>,
             class Pred = equal_to<Key>>
      using unordered_multiset = std::unordered_multiset<Key, Hash, Pred,
                                                         polymorphic_allocator<Key>>;
  }
}
\end{codeblock}

\rSec2[unord.map]{Class template \tcode{unordered_map}}%
\indexlibrary{\idxcode{unordered_map}}

\rSec3[unord.map.overview]{Overview}

\pnum
\indextext{\idxcode{unordered_map}!unique keys}%
\indextext{unordered associative containers!unique keys}%
An \tcode{unordered_map} is an unordered associative container that
supports unique keys (an \tcode{unordered_map} contains at most one of each
key value) and that associates values of another type
\tcode{mapped_type} with the keys.
The \tcode{unordered_map} class
supports forward iterators.

\pnum
An \tcode{unordered_map} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (\tref{containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_map} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_map<Key, T>} the \tcode{key type} is \tcode{Key}, the mapped type is \tcode{T}, and the value type is \tcode{pair<const Key, T>}.

\pnum
This subclause only describes operations on \tcode{unordered_map} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\indexlibrary{\idxcode{unordered_map}}%
\begin{codeblock}
namespace std {
  template<class Key,
           class T,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Allocator = allocator<pair<const Key, T>>>
  class unordered_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = pair<const Key, T>;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename allocator_traits<Allocator>::pointer;
    using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
    using reference            = value_type&;
    using const_reference      = const value_type&;
    using size_type            = @\impdef@; // see \ref{container.requirements}
    using difference_type      = @\impdef@; // see \ref{container.requirements}

    using iterator             = @\impdefx{type of \tcode{unordered_map::iterator}}@; // see \ref{container.requirements}
    using const_iterator       = @\impdefx{type of \tcode{unordered_map::const_iterator}}@; // see \ref{container.requirements}
    using local_iterator       = @\impdefx{type of \tcode{unordered_map::local_iterator}}@; // see \ref{container.requirements}
    using const_local_iterator = @\impdefx{type of \tcode{unordered_map::const_local_iterator}}@; // see \ref{container.requirements}
    using node_type            = @\unspec@;
    using insert_return_type   = @\placeholdernc{INSERT_RETURN_TYPE}@<iterator, node_type>;

    // \ref{unord.map.cnstr}, construct/copy/destroy
    unordered_map();
    explicit unordered_map(size_type n,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template<class InputIterator>
      unordered_map(InputIterator f, InputIterator l,
                    size_type n = @\seebelow@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    unordered_map(const unordered_map&);
    unordered_map(unordered_map&&);
    explicit unordered_map(const Allocator&);
    unordered_map(const unordered_map&, const Allocator&);
    unordered_map(unordered_map&&, const Allocator&);
    unordered_map(initializer_list<value_type> il,
                  size_type n = @\seebelow@,
                  const hasher& hf = hasher(),
                  const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_map(size_type n, const allocator_type& a)
      : unordered_map(n, hasher(), key_equal(), a) { }
    unordered_map(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_map(n, hf, key_equal(), a) { }
    template<class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template<class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                    const allocator_type& a)
        : unordered_map(f, l, n, hf, key_equal(), a) { }
    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
                  const allocator_type& a)
      : unordered_map(il, n, hf, key_equal(), a) { }
    ~unordered_map();
    unordered_map& operator=(const unordered_map&);
    unordered_map& operator=(unordered_map&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Hash> &&
               is_nothrow_move_assignable_v<Pred>);
    unordered_map& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{unord.map.modifiers}, modifiers
    template<class... Args> pair<iterator, bool> emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    pair<iterator, bool> insert(value_type&& obj);
    template<class P> pair<iterator, bool> insert(P&& obj);
    iterator       insert(const_iterator hint, const value_type& obj);
    iterator       insert(const_iterator hint, value_type&& obj);
    template<class P> iterator insert(const_iterator hint, P&& obj);
    template<class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    insert_return_type insert(node_type&& nh);
    iterator           insert(const_iterator hint, node_type&& nh);

    template<class... Args>
      pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template<class... Args>
      pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template<class... Args>
      iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
    template<class... Args>
      iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template<class M>
      pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template<class M>
      pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template<class M>
      iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
    template<class M>
      iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_map&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Hash> &&
               is_nothrow_swappable_v<Pred>);
    void      clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // map operations
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // \ref{unord.map.elem}, element access
    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);
    mapped_type& at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template<class InputIterator,
           class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
           class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type = @\seebelow@,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash, Pred,
                       Allocator>;

  template<class Key, class T, class Hash = hash<Key>,
           class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
    unordered_map(initializer_list<pair<const Key, T>>,
                  typename @\seebelow@::size_type = @\seebelow@, Hash = Hash(),
                  Pred = Pred(), Allocator = Allocator())
      -> unordered_map<Key, T, Hash, Pred, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
      -> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                       hash<@\placeholder{iter-key-type}@<InputIterator>>,
                       equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_map(InputIterator, InputIterator, Allocator)
      -> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                       hash<@\placeholder{iter-key-type}@<InputIterator>>,
                       equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class InputIterator, class Hash, class Allocator>
    unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash, Allocator)
      -> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
                       equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_map(initializer_list<pair<const Key, T>>, typename @\seebelow@::size_type,
                  Allocator)
      -> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_map(initializer_list<pair<const Key, T>>, Allocator)
      -> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>;

  template<class Key, class T, class Hash, class Allocator>
    unordered_map(initializer_list<pair<const Key, T>>, typename @\seebelow@::size_type, Hash,
                  Allocator)
      -> unordered_map<Key, T, Hash, equal_to<Key>, Allocator>;

  // swap
  template<class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
A \tcode{size_type} parameter type in an \tcode{unordered_map} deduction guide
refers to the \tcode{size_type} member type of the type deduced by the deduction guide.

\rSec3[unord.map.cnstr]{Constructors}

\indexlibrary{\idxcode{unordered_map}!constructor}%
\begin{itemdecl}
unordered_map() : unordered_map(size_type(@\seebelow@)) { }
explicit unordered_map(size_type n,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets.  For the default constructor,
the number of buckets is \impldef{default number of buckets in
\tcode{unordered_map}}.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{unordered_map}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  unordered_map(InputIterator f, InputIterator l,
                size_type n = @\seebelow@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
unordered_map(initializer_list<value_type> il,
              size_type n = @\seebelow@,
              const hasher& hf = hasher(),
              const key_equal& eql = key_equal(),
              const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets. If \tcode{n} is not
provided, the number of buckets is \impldef{default number of buckets in
\tcode{unordered_map}}. Then
inserts elements from the range \range{f}{l}
for the first form, or from the range
\range{il.begin()}{il.end()} for the second form.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.map.elem]{Element access}

\indexlibrarymember{unordered_map}{operator[]}%
\indextext{\idxcode{unordered_map}!element access}%
\begin{itemdecl}
mapped_type& operator[](const key_type& k);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return try_emplace(k).first->second;}
\end{itemdescr}

\indexlibrarymember{unordered_map}{operator[]}%
\indextext{\idxcode{unordered_map}!element access}%
\begin{itemdecl}
mapped_type& operator[](key_type&& k);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return try_emplace(move(k)).first->second;}
\end{itemdescr}

\indexlibrarymember{unordered_map}{at}%
\indextext{\idxcode{unordered_map}!element access}%
\begin{itemdecl}
mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A reference to \tcode{x.second}, where \tcode{x} is the (unique) element whose key is equivalent to \tcode{k}.

\pnum
\throws An exception object of type \tcode{out_of_range} if no such element is present.
\end{itemdescr}

\rSec3[unord.map.modifiers]{Modifiers}

\indexlibrarymember{unordered_map}{insert}%
\begin{itemdecl}
template<class P>
  pair<iterator, bool> insert(P&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return emplace(std::forward<P>(obj));}

\pnum
\remarks This signature shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{unordered_map}{insert}%
\begin{itemdecl}
template<class P>
  iterator insert(const_iterator hint, P&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return emplace_hint(hint, std::forward<P>(obj));}

\pnum
\remarks This signature shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{try_emplace}{unordered_map}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{unordered_map}
from \tcode{piecewise_con\-struct}, \tcode{forward_as_tuple(k)},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\effects
If the map already contains an element
whose key is equivalent to \tcode{k},
there is no effect.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{piecewise_construct}, \tcode{forward_as_tuple(k)},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{try_emplace}{unordered_map}%
\begin{itemdecl}
template<class... Args>
  pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{value_type} shall be \tcode{EmplaceConstructible} into \tcode{unordered_map}
from \tcode{piecewise_con\-struct}, \tcode{forward_as_tuple(std::move(k))},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\effects
If the map already contains an element
whose key is equivalent to \tcode{k},
there is no effect.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{piecewise_construct}, \tcode{forward_as_tuple(std::move(k))},
\tcode{forward_as_tuple(std::forward<Args>(args)...)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{unordered_map}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_assignable_v<mapped_type\&, M\&\&>} shall be \tcode{true}.
\tcode{value_type} shall be \tcode{Emplace\-Constructible} into \tcode{unordered_map}
from \tcode{k}, \tcode{std::forward<M>(obj)}.

\pnum
\effects
If the map already contains an element \tcode{e}
whose key is equivalent to \tcode{k},
assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{k}, \tcode{std::forward<M>(obj)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\indexlibrarymember{insert_or_assign}{unordered_map}%
\begin{itemdecl}
template<class M>
  pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_assignable_v<mapped_type\&, M\&\&>} shall be \tcode{true}.
\tcode{value_type} shall be \tcode{Emplace\-Constructible} into \tcode{unordered_map}
from \tcode{std::move(k)}, \tcode{std::forward<M>(obj)}.

\pnum
\effects
If the map already contains an element \tcode{e}
whose key is equivalent to \tcode{k},
assigns \tcode{std::for\-ward<M>(obj)} to \tcode{e.second}.
Otherwise inserts an object of type \tcode{value_type}
constructed with \tcode{std::\brk{}move(k)}, \tcode{std::forward<M>(obj)}.

\pnum
\returns
In the first overload,
the \tcode{bool} component of the returned pair is \tcode{true}
if and only if the insertion took place.
The returned iterator points to the map element
whose key is equivalent to \tcode{k}.

\pnum
\complexity
The same as \tcode{emplace} and \tcode{emplace_hint},
respectively.
\end{itemdescr}

\rSec2[unord.multimap]{Class template \tcode{unordered_multimap}}%
\indexlibrary{\idxcode{unordered_multimap}}

\rSec3[unord.multimap.overview]{Overview}

\pnum
\indextext{\idxcode{unordered_multimap}!equivalent keys}%
\indextext{unordered associative containers!equivalent keys}%
An \tcode{unordered_multimap} is an unordered associative container
that supports equivalent keys (an instance of \tcode{unordered_multimap} may contain
multiple copies of each key value) and that associates values of
another type \tcode{mapped_type} with the keys.
The \tcode{unordered_multimap} class
supports forward iterators.

\pnum
An \tcode{unordered_multimap} satisfies all of the requirements of a container, of an
unordered associative container, and of an allocator-aware container
(\tref{containers.allocatoraware}). It provides the operations described in the
preceding requirements table for equivalent keys; that is, an \tcode{unordered_multimap}
supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations.
For an \tcode{unordered_multimap<Key, T>} the \tcode{key type} is \tcode{Key}, the
mapped type is \tcode{T}, and the value type is \tcode{pair<const Key, T>}.

\pnum
This subclause only describes operations on \tcode{unordered_multimap}
that are not described in one of the requirement tables, or for which
there is additional semantic information.

\indexlibrary{\idxcode{unordered_multimap}}%
\begin{codeblock}
namespace std {
  template<class Key,
           class T,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Allocator = allocator<pair<const Key, T>>>
  class unordered_multimap {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = pair<const Key, T>;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename allocator_traits<Allocator>::pointer;
    using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
    using reference            = value_type&;
    using const_reference      = const value_type&;
    using size_type            = @\impdef@; // see \ref{container.requirements}
    using difference_type      = @\impdef@; // see \ref{container.requirements}

    using iterator             = @\impdefx{type of \tcode{unordered_multimap::iterator}}@; // see \ref{container.requirements}
    using const_iterator       = @\impdefx{type of \tcode{unordered_multimap::const_iterator}}@; // see \ref{container.requirements}
    using local_iterator       = @\impdefx{type of \tcode{unordered_multimap::local_iterator}}@; // see \ref{container.requirements}
    using const_local_iterator = @\impdefx{type of \tcode{unordered_multimap::const_local_it\-erator}}@; // see \ref{container.requirements}
    using node_type            = @\unspec@;

    // \ref{unord.multimap.cnstr}, construct/copy/destroy
    unordered_multimap();
    explicit unordered_multimap(size_type n,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template<class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l,
                         size_type n = @\seebelow@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    unordered_multimap(const unordered_multimap&);
    unordered_multimap(unordered_multimap&&);
    explicit unordered_multimap(const Allocator&);
    unordered_multimap(const unordered_multimap&, const Allocator&);
    unordered_multimap(unordered_multimap&&, const Allocator&);
    unordered_multimap(initializer_list<value_type> il,
                       size_type n = @\seebelow@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
    unordered_multimap(size_type n, const allocator_type& a)
      : unordered_multimap(n, hasher(), key_equal(), a) { }
    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    template<class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template<class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                         const allocator_type& a)
        : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf,
                       const allocator_type& a)
      : unordered_multimap(il, n, hf, key_equal(), a) { }
    ~unordered_multimap();
    unordered_multimap& operator=(const unordered_multimap&);
    unordered_multimap& operator=(unordered_multimap&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Hash> &&
               is_nothrow_move_assignable_v<Pred>);
    unordered_multimap& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{unord.multimap.modifiers}, modifiers
    template<class... Args> iterator emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    iterator insert(value_type&& obj);
    template<class P> iterator insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template<class P> iterator insert(const_iterator hint, P&& obj);
    template<class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    iterator insert(node_type&& nh);
    iterator insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_multimap&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Hash> &&
               is_nothrow_swappable_v<Pred>);
    void      clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // map operations
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template<class InputIterator,
           class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
           class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    unordered_multimap(InputIterator, InputIterator,
                       typename @\seebelow@::size_type = @\seebelow@,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                            Hash, Pred, Allocator>;

  template<class Key, class T, class Hash = hash<Key>,
           class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
    unordered_multimap(initializer_list<pair<const Key, T>>,
                       typename @\seebelow@::size_type = @\seebelow@,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_multimap<Key, T, Hash, Pred, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
      -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                            hash<@\placeholder{iter-key-type}@<InputIterator>>,
                            equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_multimap(InputIterator, InputIterator, Allocator)
      -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
                            hash<@\placeholder{iter-key-type}@<InputIterator>>,
                            equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class InputIterator, class Hash, class Allocator>
    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash,
                       Allocator)
      -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
                            equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_multimap(initializer_list<pair<const Key, T>>, typename @\seebelow@::size_type,
                       Allocator)
      -> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_multimap(initializer_list<pair<const Key, T>>, Allocator)
      -> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>;

  template<class Key, class T, class Hash, class Allocator>
    unordered_multimap(initializer_list<pair<const Key, T>>, typename @\seebelow@::size_type,
                       Hash, Allocator)
      -> unordered_multimap<Key, T, Hash, equal_to<Key>, Allocator>;

  // swap
  template<class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
A \tcode{size_type} parameter type in an \tcode{unordered_multimap} deduction guide
refers to the \tcode{size_type} member type of the type deduced by the deduction guide.

\rSec3[unord.multimap.cnstr]{Constructors}

\indexlibrary{\idxcode{unordered_multimap}!constructor}%
\begin{itemdecl}
unordered_multimap() : unordered_multimap(size_type(@\seebelow@)) { }
explicit unordered_multimap(size_type n,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets.  For the default constructor,
the number of buckets is \impldef{default number of buckets in
\tcode{unordered_multimap}}.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{unordered_multimap}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  unordered_multimap(InputIterator f, InputIterator l,
                     size_type n = @\seebelow@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
unordered_multimap(initializer_list<value_type> il,
                   size_type n = @\seebelow@,
                   const hasher& hf = hasher(),
                   const key_equal& eql = key_equal(),
                   const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets. If \tcode{n} is not
provided, the number of buckets is \impldef{default number of buckets in
\tcode{unordered_multimap}}. Then
inserts elements from the range \range{f}{l}
for the first form, or from the range
\range{il.begin()}{il.end()} for the second form.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.multimap.modifiers]{Modifiers}

\indexlibrarymember{unordered_multimap}{insert}%
\begin{itemdecl}
template<class P>
  iterator insert(P&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return emplace(std::forward<P>(obj));}

\pnum
\remarks This signature shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{unordered_multimap}{insert}%
\begin{itemdecl}
template<class P>
  iterator insert(const_iterator hint, P&& obj);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return emplace_hint(hint, std::forward<P>(obj));}

\pnum
\remarks This signature shall not participate in overload resolution
unless \tcode{is_constructible_v<value_type, P\&\&>} is \tcode{true}.
\end{itemdescr}

\rSec2[unord.set]{Class template \tcode{unordered_set}}%
\indexlibrary{\idxcode{unordered_set}}

\rSec3[unord.set.overview]{Overview}

\pnum
\indextext{\idxcode{unordered_set}!unique keys}%
\indextext{unordered associative containers!unique keys}%
An \tcode{unordered_set} is an unordered associative container that
supports unique keys (an \tcode{unordered_set} contains at most one of each
key value) and in which the elements' keys are the elements
themselves.
The \tcode{unordered_set} class
supports forward iterators.

\pnum
An \tcode{unordered_set} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (\tref{containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_set} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_set<Key>} the \tcode{key type} and the value type are both \tcode{Key}. The \tcode{iterator} and \tcode{const_iterator} types are both constant iterator types. It is unspecified whether they are the same type.

\pnum
This subclause only describes operations on \tcode{unordered_set} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\indexlibrary{\idxcode{unordered_set}}%
\begin{codeblock}
namespace std {
  template<class Key,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Allocator = allocator<Key>>
  class unordered_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename allocator_traits<Allocator>::pointer;
    using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
    using reference            = value_type&;
    using const_reference      = const value_type&;
    using size_type            = @\impdef@; // see \ref{container.requirements}
    using difference_type      = @\impdef@; // see \ref{container.requirements}

    using iterator             = @\impdefx{type of \tcode{unordered_set::iterator}}@; // see \ref{container.requirements}
    using const_iterator       = @\impdefx{type of \tcode{unordered_set::const_iterator}}@; // see \ref{container.requirements}
    using local_iterator       = @\impdefx{type of \tcode{unordered_set::local_iterator}}@; // see \ref{container.requirements}
    using const_local_iterator = @\impdefx{type of \tcode{unordered_set::const_local_iterator}}@; // see \ref{container.requirements}
    using node_type            = @\unspec@;
    using insert_return_type   = @\placeholdernc{INSERT_RETURN_TYPE}@<iterator, node_type>;

    // \ref{unord.set.cnstr}, construct/copy/destroy
    unordered_set();
    explicit unordered_set(size_type n,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template<class InputIterator>
      unordered_set(InputIterator f, InputIterator l,
                    size_type n = @\seebelow@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    unordered_set(const unordered_set&);
    unordered_set(unordered_set&&);
    explicit unordered_set(const Allocator&);
    unordered_set(const unordered_set&, const Allocator&);
    unordered_set(unordered_set&&, const Allocator&);
    unordered_set(initializer_list<value_type> il,
                  size_type n = @\seebelow@,
                  const hasher& hf = hasher(),
                  const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_set(size_type n, const allocator_type& a)
      : unordered_set(n, hasher(), key_equal(), a) { }
    unordered_set(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_set(n, hf, key_equal(), a) { }
    template<class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template<class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                    const allocator_type& a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    unordered_set(initializer_list<value_type> il, size_type n, const hasher& hf,
                  const allocator_type& a)
      : unordered_set(il, n, hf, key_equal(), a) { }
    ~unordered_set();
    unordered_set& operator=(const unordered_set&);
    unordered_set& operator=(unordered_set&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Hash> &&
               is_nothrow_move_assignable_v<Pred>);
    unordered_set& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // modifiers
    template<class... Args> pair<iterator, bool> emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    pair<iterator, bool> insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template<class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    insert_return_type insert(node_type&& nh);
    iterator           insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_set&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Hash> &&
               is_nothrow_swappable_v<Pred>);
    void      clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>&& source);
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // set operations
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template<class InputIterator,
           class Hash = hash<@\placeholder{iter-value-type}@<InputIterator>>,
           class Pred = equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    unordered_set(InputIterator, InputIterator, typename @\seebelow@::size_type = @\seebelow@,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_set<@\placeholder{iter-value-type}@<InputIterator>,
                       Hash, Pred, Allocator>;

  template<class T, class Hash = hash<T>,
           class Pred = equal_to<T>, class Allocator = allocator<T>>
    unordered_set(initializer_list<T>, typename @\seebelow@::size_type = @\seebelow@,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_set<T, Hash, Pred, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_set(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
      -> unordered_set<@\placeholder{iter-value-type}@<InputIterator>,
                       hash<@\placeholder{iter-value-type}@<InputIterator>>,
                       equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
                       Allocator>;

  template<class InputIterator, class Hash, class Allocator>
    unordered_set(InputIterator, InputIterator, typename @\seebelow@::size_type,
                  Hash, Allocator)
      -> unordered_set<@\placeholder{iter-value-type}@<InputIterator>, Hash,
                       equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
                       Allocator>;

  template<class T, class Allocator>
    unordered_set(initializer_list<T>, typename @\seebelow@::size_type, Allocator)
      -> unordered_set<T, hash<T>, equal_to<T>, Allocator>;

  template<class T, class Hash, class Allocator>
    unordered_set(initializer_list<T>, typename @\seebelow@::size_type, Hash, Allocator)
      -> unordered_set<T, Hash, equal_to<T>, Allocator>;

  // swap
  template<class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
              unordered_set<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
A \tcode{size_type} parameter type in an \tcode{unordered_set} deduction guide
refers to the \tcode{size_type} member type of
the type deduced by the deduction guide.

\rSec3[unord.set.cnstr]{Constructors}

\indexlibrary{\idxcode{unordered_set}!constructor}%
\begin{itemdecl}
unordered_set() : unordered_set(size_type(@\seebelow@)) { }
explicit unordered_set(size_type n,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets.  For the default constructor,
the number of buckets is \impldef{default number of buckets in
\tcode{unordered_set}}.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{unordered_set}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  unordered_set(InputIterator f, InputIterator l,
                size_type n = @\seebelow@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
unordered_set(initializer_list<value_type> il,
              size_type n = @\seebelow@,
              const hasher& hf = hasher(),
              const key_equal& eql = key_equal(),
              const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets. If \tcode{n} is not
provided, the number of buckets is \impldef{default number of buckets in
\tcode{unordered_set}}. Then
inserts elements from the range \range{f}{l}
for the first form, or from the range
\range{il.begin()}{il.end()} for the second form.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Average case linear, worst case quadratic.
\end{itemdescr}

\rSec2[unord.multiset]{Class template \tcode{unordered_multiset}}%
\indexlibrary{\idxcode{unordered_multiset}}

\rSec3[unord.multiset.overview]{Overview}

\pnum
\indextext{\idxcode{unordered_multiset}!equivalent keys}%
\indextext{unordered associative containers!equivalent keys}%
An \tcode{unordered_multiset} is an unordered associative container
that supports equivalent keys (an instance of \tcode{unordered_multiset} may contain
multiple copies of the same key value) and in which each element's key
is the element itself.
The \tcode{unordered_multiset} class
supports forward iterators.

\pnum
An \tcode{unordered_multiset} satisfies all of the requirements of a container, of an
unordered associative container, and of an allocator-aware container
(\tref{containers.allocatoraware}). It provides the operations described in the
preceding requirements table for equivalent keys; that is, an \tcode{unordered_multiset}
supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations.
For an \tcode{unordered_multiset<Key>} the \tcode{key type} and the value type are
both \tcode{Key}. The \tcode{iterator} and \tcode{const_iterator} types are both
constant iterator types. It is unspecified whether they are the same type.

\pnum
This subclause only describes operations on \tcode{unordered_multiset} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\indexlibrary{\idxcode{unordered_multiset}}%
\begin{codeblock}
namespace std {
  template<class Key,
           class Hash = hash<Key>,
           class Pred = equal_to<Key>,
           class Allocator = allocator<Key>>
  class unordered_multiset {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename allocator_traits<Allocator>::pointer;
    using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
    using reference            = value_type&;
    using const_reference      = const value_type&;
    using size_type            = @\impdef@; // see \ref{container.requirements}
    using difference_type      = @\impdef@; // see \ref{container.requirements}

    using iterator             = @\impdefx{type of \tcode{unordered_multiset::iterator}}@; // see \ref{container.requirements}
    using const_iterator       = @\impdefx{type of \tcode{unordered_multiset::const_iterator}}@; // see \ref{container.requirements}
    using local_iterator       = @\impdefx{type of \tcode{unordered_multiset::local_iterator}}@; // see \ref{container.requirements}
    using const_local_iterator = @\impdefx{type of \tcode{unordered_multiset::const_local_it\-erator}}@; // see \ref{container.requirements}
    using node_type            = @\unspec@;

    // \ref{unord.multiset.cnstr}, construct/copy/destroy
    unordered_multiset();
    explicit unordered_multiset(size_type n,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template<class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l,
                         size_type n = @\seebelow@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    unordered_multiset(const unordered_multiset&);
    unordered_multiset(unordered_multiset&&);
    explicit unordered_multiset(const Allocator&);
    unordered_multiset(const unordered_multiset&, const Allocator&);
    unordered_multiset(unordered_multiset&&, const Allocator&);
    unordered_multiset(initializer_list<value_type> il,
                       size_type n = @\seebelow@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
    unordered_multiset(size_type n, const allocator_type& a)
      : unordered_multiset(n, hasher(), key_equal(), a) { }
    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    template<class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template<class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                         const allocator_type& a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    unordered_multiset(initializer_list<value_type> il, size_type n, const hasher& hf,
                       const allocator_type& a)
      : unordered_multiset(il, n, hf, key_equal(), a) { }
    ~unordered_multiset();
    unordered_multiset& operator=(const unordered_multiset&);
    unordered_multiset& operator=(unordered_multiset&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Hash> &&
               is_nothrow_move_assignable_v<Pred>);
    unordered_multiset& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // modifiers
    template<class... Args> iterator emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    iterator insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template<class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    iterator insert(node_type&& nh);
    iterator insert(const_iterator hint, node_type&& nh);

    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_multiset&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v<Hash> &&
               is_nothrow_swappable_v<Pred>);
    void      clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>&& source);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // set operations
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template<class InputIterator,
           class Hash = hash<@\placeholder{iter-value-type}@<InputIterator>>,
           class Pred = equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
           class Allocator = allocator<@\placeholder{iter-value-type}@<InputIterator>>>
    unordered_multiset(InputIterator, InputIterator, @\seebelow@::size_type = @\seebelow@,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_multiset<@\placeholder{iter-value-type}@<InputIterator>,
                            Hash, Pred, Allocator>;

  template<class T, class Hash = hash<T>,
           class Pred = equal_to<T>, class Allocator = allocator<T>>
    unordered_multiset(initializer_list<T>, typename @\seebelow@::size_type = @\seebelow@,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_multiset<T, Hash, Pred, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_multiset(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
      -> unordered_multiset<@\placeholder{iter-value-type}@<InputIterator>,
                            hash<@\placeholder{iter-value-type}@<InputIterator>>,
                            equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
                            Allocator>;

  template<class InputIterator, class Hash, class Allocator>
    unordered_multiset(InputIterator, InputIterator, typename @\seebelow@::size_type,
                       Hash, Allocator)
      -> unordered_multiset<@\placeholder{iter-value-type}@<InputIterator>, Hash,
                            equal_to<@\placeholder{iter-value-type}@<InputIterator>>,
                            Allocator>;

  template<class T, class Allocator>
    unordered_multiset(initializer_list<T>, typename @\seebelow@::size_type, Allocator)
      -> unordered_multiset<T, hash<T>, equal_to<T>, Allocator>;

  template<class T, class Hash, class Allocator>
    unordered_multiset(initializer_list<T>, typename @\seebelow@::size_type, Hash, Allocator)
      -> unordered_multiset<T, Hash, equal_to<T>, Allocator>;

  // swap
  template<class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
              unordered_multiset<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\pnum
A \tcode{size_type} parameter type in an \tcode{unordered_multiset} deduction guide
refers to the \tcode{size_type} member type of
the type deduced by the deduction guide.

\rSec3[unord.multiset.cnstr]{Constructors}

\indexlibrary{\idxcode{unordered_multiset}!constructor}%
\begin{itemdecl}
unordered_multiset() : unordered_multiset(size_type(@\seebelow@)) { }
explicit unordered_multiset(size_type n,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets.  For the default constructor,
the number of buckets is \impldef{default number of buckets in
\tcode{unordered_multiset}}.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum
\complexity Constant.
\end{itemdescr}

\indexlibrary{\idxcode{unordered_multiset}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  unordered_multiset(InputIterator f, InputIterator l,
                     size_type n = @\seebelow@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
unordered_multiset(initializer_list<value_type> il,
                   size_type n = @\seebelow@,
                   const hasher& hf = hasher(),
                   const key_equal& eql = key_equal(),
                   const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum\effects
Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality predicate, and allocator, and
using at least \tcode{n} buckets. If \tcode{n} is not
provided, the number of buckets is \impldef{default number of buckets in
\tcode{unordered_multiset}}. Then
inserts elements from the range \range{f}{l}
for the first form, or from the range
\range{il.begin()}{il.end()} for the second form.
\tcode{max_load_factor()} returns \tcode{1.0}.

\pnum\complexity Average case linear, worst case quadratic.
\end{itemdescr}

\rSec1[container.adaptors]{Container adaptors}

\rSec2[container.adaptors.general]{In general}

\pnum
The headers \tcode{<queue>} and \tcode{<stack>} define the container adaptors
\tcode{queue}, \tcode{priority_queue}, and \tcode{stack}.

\pnum
The container adaptors each take a \tcode{Container} template parameter, and each constructor takes
a \tcode{Container} reference argument. This container is copied into the \tcode{Container} member
of each adaptor. If the container takes an allocator, then a compatible allocator may be passed in
to the adaptor's constructor. Otherwise, normal copy or move construction is used for the container
argument.
The first template parameter \tcode{T} of the container adaptors
shall denote the same type as \tcode{Container::value_type}.

\pnum
For container adaptors, no \tcode{swap} function throws an exception unless that
exception is thrown by the swap of the adaptor's \tcode{Container} or
\tcode{Compare} object (if any).

\pnum
A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:
\begin{itemize}
\item It has an \tcode{InputIterator} template parameter and a type that does not qualify as an input iterator is deduced for that parameter.
\item It has a \tcode{Compare} template parameter and a type that qualifies as an allocator is deduced for that parameter.
\item It has a \tcode{Container} template parameter and a type that qualifies as an allocator is deduced for that parameter.
\item It has an \tcode{Allocator} template parameter and a type that does not qualify as an allocator is deduced for that parameter.
\item It has both \tcode{Container} and \tcode{Allocator} template parameters, and \tcode{uses_allocator_v<Container, Allocator>} is \tcode{false}.
\end{itemize}

\rSec2[queue.syn]{Header \tcode{<queue>} synopsis}%
\indexhdr{queue}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  template<class T, class Container = deque<T>> class queue;
  template<class T, class Container = vector<T>,
           class Compare = less<typename Container::value_type>>
    class priority_queue;

  template<class T, class Container>
    bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);

  template<class T, class Container>
    void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));
  template<class T, class Container, class Compare>
    void swap(priority_queue<T, Container, Compare>& x,
              priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\rSec2[stack.syn]{Header \tcode{<stack>} synopsis}%
\indexhdr{stack}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  template<class T, class Container = deque<T>> class stack;

  template<class T, class Container>
    bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
  template<class T, class Container>
    bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
  template<class T, class Container>
    bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
  template<class T, class Container>
    bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
  template<class T, class Container>
    bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
  template<class T, class Container>
    bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);

  template<class T, class Container>
    void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));
}
\end{codeblock}

\rSec2[queue]{Class template \tcode{queue}}

\rSec3[queue.defn]{Definition}

\pnum
\indexlibrary{\idxcode{queue}}%
Any sequence container supporting operations
\tcode{front()},
\tcode{back()},
\tcode{push_back()}
and
\tcode{pop_front()}
can be used to instantiate
\tcode{queue}.
In particular,
\tcode{list}\iref{list}
and
\tcode{deque}\iref{deque}
can be used.

\begin{codeblock}
namespace std {
  template<class T, class Container = deque<T>>
  class queue {
  public:
    using value_type      = typename Container::value_type;
    using reference       = typename Container::reference;
    using const_reference = typename Container::const_reference;
    using size_type       = typename Container::size_type;
    using container_type  =          Container;

  protected:
    Container c;

  public:
    explicit queue(const Container&);
    explicit queue(Container&& = Container());
    template<class Alloc> explicit queue(const Alloc&);
    template<class Alloc> queue(const Container&, const Alloc&);
    template<class Alloc> queue(Container&&, const Alloc&);
    template<class Alloc> queue(const queue&, const Alloc&);
    template<class Alloc> queue(queue&&, const Alloc&);

    [[nodiscard]] bool empty() const    { return c.empty(); }
    size_type         size()  const     { return c.size(); }
    reference         front()           { return c.front(); }
    const_reference   front() const     { return c.front(); }
    reference         back()            { return c.back(); }
    const_reference   back() const      { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void push(value_type&& x)           { c.push_back(std::move(x)); }
    template<class... Args>
      decltype(auto) emplace(Args&&... args)
        { return c.emplace_back(std::forward<Args>(args)...); }
    void pop()                          { c.pop_front(); }
    void swap(queue& q) noexcept(is_nothrow_swappable_v<Container>)
      { using std::swap; swap(c, q.c); }
  };

  template<class Container>
    queue(Container) -> queue<typename Container::value_type, Container>;

  template<class Container, class Allocator>
    queue(Container, Allocator) -> queue<typename Container::value_type, Container>;

  template<class T, class Container>
    void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));

  template<class T, class Container, class Alloc>
    struct uses_allocator<queue<T, Container>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
\end{codeblock}

\rSec3[queue.cons]{Constructors}

\begin{itemdecl}
explicit queue(const Container& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{cont}.
\end{itemdescr}

\begin{itemdecl}
explicit queue(Container&& cont = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(cont)}.
\end{itemdescr}

\rSec3[queue.cons.alloc]{Constructors with allocators}

\pnum
If \tcode{uses_allocator_v<container_type, Alloc>} is \tcode{false}
the constructors in this subclause shall not participate in overload resolution.

\begin{itemdecl}
template<class Alloc> explicit queue(const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{a}.
\end{itemdescr}

\begin{itemdecl}
template<class Alloc> queue(const container_type& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{cont} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\begin{itemdecl}
template<class Alloc> queue(container_type&& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(cont)} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\begin{itemdecl}
template<class Alloc> queue(const queue& q, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{q.c} as the first argument and \tcode{a} as the
second argument.
\end{itemdescr}

\begin{itemdecl}
template<class Alloc> queue(queue&& q, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(q.c)} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\rSec3[queue.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c == y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator!=(const queue<T, Container>& x,  const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c != y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c < y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c <= y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c > y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{queue}}%
\begin{itemdecl}
template<class T, class Container>
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec3[queue.special]{Specialized algorithms}

\indexlibrarymember{swap}{queue}%
\begin{itemdecl}
template<class T, class Container>
  void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution
unless \tcode{is_swappable_v<Container>} is \tcode{true}.

\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[priority.queue]{Class template \tcode{priority_queue}}

\rSec3[priqueue.overview]{Overview}

\pnum
\indexlibrary{\idxcode{priority_queue}}%
Any sequence container with random access iterator and supporting operations
\tcode{front()},
\tcode{push_back()}
and
\tcode{pop_back()}
can be used to instantiate
\tcode{priority_queue}.
In particular,
\tcode{vector}\iref{vector}
and
\tcode{deque}\iref{deque}
can be used.
Instantiating
\tcode{priority_queue}
also involves supplying a function or function object for making
priority comparisons; the library assumes that the function or function
object defines a strict weak ordering\iref{alg.sorting}.

\begin{codeblock}
namespace std {
  template<class T, class Container = vector<T>,
           class Compare = less<typename Container::value_type>>
  class priority_queue {
  public:
    using value_type      = typename Container::value_type;
    using reference       = typename Container::reference;
    using const_reference = typename Container::const_reference;
    using size_type       = typename Container::size_type;
    using container_type  = Container;
    using value_compare   = Compare;

  protected:
    Container c;
    Compare comp;

  public:
    priority_queue(const Compare& x, const Container&);
    explicit priority_queue(const Compare& x = Compare(), Container&& = Container());
    template<class InputIterator>
      priority_queue(InputIterator first, InputIterator last, const Compare& x,
                     const Container&);
    template<class InputIterator>
      priority_queue(InputIterator first, InputIterator last,
                     const Compare& x = Compare(), Container&& = Container());
    template<class Alloc> explicit priority_queue(const Alloc&);
    template<class Alloc> priority_queue(const Compare&, const Alloc&);
    template<class Alloc> priority_queue(const Compare&, const Container&, const Alloc&);
    template<class Alloc> priority_queue(const Compare&, Container&&, const Alloc&);
    template<class Alloc> priority_queue(const priority_queue&, const Alloc&);
    template<class Alloc> priority_queue(priority_queue&&, const Alloc&);

    [[nodiscard]] bool empty() const { return c.empty(); }
    size_type size()  const          { return c.size(); }
    const_reference   top() const    { return c.front(); }
    void push(const value_type& x);
    void push(value_type&& x);
    template<class... Args> void emplace(Args&&... args);
    void pop();
    void swap(priority_queue& q) noexcept(is_nothrow_swappable_v<Container> &&
                                          is_nothrow_swappable_v<Compare>)
      { using std::swap; swap(c, q.c); swap(comp, q.comp); }
  };

  template<class Compare, class Container>
    priority_queue(Compare, Container)
      -> priority_queue<typename Container::value_type, Container, Compare>;

  template<class InputIterator,
           class Compare = less<typename iterator_traits<InputIterator>::value_type>,
           class Container = vector<typename iterator_traits<InputIterator>::value_type>>
    priority_queue(InputIterator, InputIterator, Compare = Compare(), Container = Container())
      -> priority_queue<typename iterator_traits<InputIterator>::value_type, Container, Compare>;

  template<class Compare, class Container, class Allocator>
    priority_queue(Compare, Container, Allocator)
      -> priority_queue<typename Container::value_type, Container, Compare>;

  // no equality is provided

  template<class T, class Container, class Compare>
    void swap(priority_queue<T, Container, Compare>& x,
              priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));

  template<class T, class Container, class Compare, class Alloc>
    struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
\end{codeblock}

\rSec3[priqueue.cons]{Constructors}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
priority_queue(const Compare& x, const Container& y);
explicit priority_queue(const Compare& x = Compare(), Container&& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{x} shall define a strict weak ordering\iref{alg.sorting}.

\pnum
\effects
Initializes
\tcode{comp} with
\tcode{x} and
\tcode{c} with
\tcode{y} (copy constructing or move constructing as appropriate);
calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  priority_queue(InputIterator first, InputIterator last, const Compare& x, const Container& y);
template<class InputIterator>
  priority_queue(InputIterator first, InputIterator last, const Compare& x = Compare(),
                 Container&& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{x} shall define a strict weak ordering\iref{alg.sorting}.

\pnum
\effects
Initializes
\tcode{comp} with
\tcode{x} and
\tcode{c} with
\tcode{y} (copy constructing or move constructing as appropriate);
calls
\tcode{c.insert(c.end(), first, last)};
and finally calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\rSec3[priqueue.cons.alloc]{Constructors with allocators}

\pnum
If \tcode{uses_allocator_v<container_type, Alloc>} is \tcode{false}
the constructors in this subclause shall not participate in overload resolution.

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc> explicit priority_queue(const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{a} and value-initializes \tcode{comp}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc> priority_queue(const Compare& compare, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{a} and initializes \tcode{comp} with \tcode{compare}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc>
  priority_queue(const Compare& compare, const Container& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{cont} as the first argument and \tcode{a} as the second
argument, and initializes \tcode{comp} with \tcode{compare};
calls \tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc>
  priority_queue(const Compare& compare, Container&& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(cont)} as the first argument and \tcode{a}
as the second argument, and initializes \tcode{comp} with \tcode{compare};
calls \tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc> priority_queue(const priority_queue& q, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{q.c} as the first argument and \tcode{a} as
the second argument, and initializes \tcode{comp} with \tcode{q.comp}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!constructor}%
\begin{itemdecl}
template<class Alloc> priority_queue(priority_queue&& q, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(q.c)} as the first argument and \tcode{a}
as the second argument, and initializes \tcode{comp} with \tcode{std::move(q.comp)}.
\end{itemdescr}

\rSec3[priqueue.members]{Members}

\indexlibrary{\idxcode{push}!\idxcode{priority_queue}}%
\begin{itemdecl}
void push(const value_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
c.push_back(x);
push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{push}!\idxcode{priority_queue}}%
\begin{itemdecl}
void push(value_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
c.push_back(std::move(x));
push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{emplace}{priority_queue}%
\begin{itemdecl}
template<class... Args> void emplace(Args&&... args)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
c.emplace_back(std::forward<Args>(args)...);
push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{pop}!\idxcode{priority_queue}}%
\begin{itemdecl}
void pop();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
\end{codeblock}
\end{itemdescr}

\rSec3[priqueue.special]{Specialized algorithms}

\indexlibrarymember{swap}{priority_queue}%
\begin{itemdecl}
template<class T, class Container, class Compare>
  void swap(priority_queue<T, Container, Compare>& x,
            priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution
unless \tcode{is_swappable_v<Container>} is \tcode{true} and
\tcode{is_swappable_v<Compare>} is \tcode{true}.

\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[stack]{Class template \tcode{stack}}

\pnum
\indexlibrary{\idxcode{stack}}%
Any sequence container supporting operations
\tcode{back()},
\tcode{push_back()}
and
\tcode{pop_back()}
can be used to instantiate
\tcode{stack}.
In particular,
\tcode{vector}\iref{vector},
\tcode{list}\iref{list}
and
\tcode{deque}\iref{deque}
can be used.

\rSec3[stack.defn]{Definition}

\begin{codeblock}
namespace std {
  template<class T, class Container = deque<T>>
  class stack {
  public:
    using value_type      = typename Container::value_type;
    using reference       = typename Container::reference;
    using const_reference = typename Container::const_reference;
    using size_type       = typename Container::size_type;
    using container_type  = Container;

  protected:
    Container c;

  public:
    explicit stack(const Container&);
    explicit stack(Container&& = Container());
    template<class Alloc> explicit stack(const Alloc&);
    template<class Alloc> stack(const Container&, const Alloc&);
    template<class Alloc> stack(Container&&, const Alloc&);
    template<class Alloc> stack(const stack&, const Alloc&);
    template<class Alloc> stack(stack&&, const Alloc&);

    [[nodiscard]] bool empty() const    { return c.empty(); }
    size_type size()  const             { return c.size(); }
    reference         top()             { return c.back(); }
    const_reference   top() const       { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void push(value_type&& x)           { c.push_back(std::move(x)); }
    template<class... Args>
      decltype(auto) emplace(Args&&... args)
        { return c.emplace_back(std::forward<Args>(args)...); }
    void pop()                          { c.pop_back(); }
    void swap(stack& s) noexcept(is_nothrow_swappable_v<Container>)
      { using std::swap; swap(c, s.c); }
  };

  template<class Container>
    stack(Container) -> stack<typename Container::value_type, Container>;

  template<class Container, class Allocator>
    stack(Container, Allocator) -> stack<typename Container::value_type, Container>;

  template<class T, class Container, class Alloc>
    struct uses_allocator<stack<T, Container>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
\end{codeblock}

\rSec3[stack.cons]{Constructors}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
explicit stack(const Container& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{cont}.
\end{itemdescr}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
explicit stack(Container&& cont = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{std::move(cont)}.
\end{itemdescr}

\rSec3[stack.cons.alloc]{Constructors with allocators}

\pnum
If \tcode{uses_allocator_v<container_type, Alloc>} is \tcode{false}
the constructors in this subclause shall not participate in overload resolution.

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
template<class Alloc> explicit stack(const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
template<class Alloc> stack(const container_type& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{cont} as the first argument and \tcode{a} as the
second argument.
\end{itemdescr}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
template<class Alloc> stack(container_type&& cont, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(cont)} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
template<class Alloc> stack(const stack& s, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{s.c} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\indexlibrary{\idxcode{stack}!constructor}%
\begin{itemdecl}
template<class Alloc> stack(stack&& s, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Initializes \tcode{c} with \tcode{std::move(s.c)} as the first argument and \tcode{a}
as the second argument.
\end{itemdescr}

\rSec3[stack.ops]{Operators}

\indexlibrary{\idxcode{operator==}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c == y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c != y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c < y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c <= y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
  bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c > y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{stack}}%
\begin{itemdecl}
template<class T, class Container>
    bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec3[stack.special]{Specialized algorithms}

\indexlibrarymember{swap}{stack}%
\begin{itemdecl}
template<class T, class Container>
  void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution
unless \tcode{is_swappable_v<Container>} is \tcode{true}.

\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

\rSec1[views]{Views}

\rSec2[views.general]{General}

\pnum
The header \tcode{<span>} defines the view \tcode{span}.
A \tcode{span} is a view over a contiguous sequence of objects,
the storage of which is owned by some other object.

\rSec2[span.syn]{Header \tcode{<span>} synopsis}%
\indexhdr{span}%

\begin{codeblock}
namespace std {
  // constants
  inline constexpr ptrdiff_t dynamic_extent = -1;

  // \ref{views.span}, class template span
  template<class ElementType, ptrdiff_t Extent = dynamic_extent>
    class span;

  // \ref{span.comparison}, comparison operators
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator==(span<T, X> l, span<U, Y> r);
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator!=(span<T, X> l, span<U, Y> r);
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator<(span<T, X> l, span<U, Y> r);
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator<=(span<T, X> l, span<U, Y> r);
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator>(span<T, X> l, span<U, Y> r);
  template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
    constexpr bool operator>=(span<T, X> l, span<U, Y> r);

  // \ref{span.objectrep}, views of object representation
  template<class ElementType, ptrdiff_t Extent>
    span<const byte,
         Extent == dynamic_extent ? dynamic_extent
                                  : static_cast<ptrdiff_t>(sizeof(ElementType)) * Extent>
      as_bytes(span<ElementType, Extent> s) noexcept;

  template<class ElementType, ptrdiff_t Extent>
    span<byte,
         Extent == dynamic_extent ? dynamic_extent
                                  : static_cast<ptrdiff_t>(sizeof(ElementType)) * Extent>
      as_writable_bytes(span<ElementType, Extent> s) noexcept;
}
\end{codeblock}

\rSec2[views.span]{Class template \tcode{span}}

\rSec3[span.overview]{Overview}

\pnum
\indexlibrary{\idxcode{span}}%
A \tcode{span} is a view over a contiguous sequence of objects,
the storage of which is owned by some other object.

\pnum
\tcode{ElementType} is required to be a complete object type that is not an abstract class type.

\pnum
If \tcode{Extent} is negative and not equal to \tcode{dynamic_extent},
the program is ill-formed.

\pnum
The iterator type for span is a random access iterator and a contiguous iterator.

\pnum
All member functions of \tcode{span} have constant time complexity.

\indexlibrary{\idxcode{span}}%
\begin{codeblock}
namespace std {
  template<class ElementType, ptrdiff_t Extent = dynamic_extent>
  class span {
  public:
    // constants and types
    using element_type = ElementType;
    using value_type = remove_cv_t<ElementType>;
    using index_type = ptrdiff_t;
    using difference_type = ptrdiff_t;
    using pointer = element_type*;
    using reference = element_type&;
    using iterator = @\impdefx{type of \tcode{span::iterator}}@;
    using const_iterator = @\impdefx{type of \tcode{span::const_iterator}}@;
    using reverse_iterator = reverse_iterator<iterator>;
    using const_reverse_iterator = reverse_iterator<const_iterator>;
    static constexpr index_type extent = Extent;

    // \ref{span.cons}, constructors, copy, and assignment
    constexpr span() noexcept;
    constexpr span(pointer ptr, index_type count);
    constexpr span(pointer first, pointer last);
    template<size_t N>
      constexpr span(element_type (&arr)[N]) noexcept;
    template<size_t N>
      constexpr span(array<value_type, N>& arr) noexcept;
    template<size_t N>
      constexpr span(const array<value_type, N>& arr) noexcept;
    template<class Container>
      constexpr span(Container& cont);
    template<class Container>
      constexpr span(const Container& cont);
    constexpr span(const span& other) noexcept = default;
    template<class OtherElementType, ptrdiff_t OtherExtent>
      constexpr span(const span<OtherElementType, OtherExtent>& s) noexcept;

    ~span() noexcept = default;

    constexpr span& operator=(const span& other) noexcept = default;

    // \ref{span.sub}, subviews
    template<ptrdiff_t Count>
      constexpr span<element_type, Count> first() const;
    template<ptrdiff_t Count>
      constexpr span<element_type, Count> last() const;
    template<ptrdiff_t Offset, ptrdiff_t Count = dynamic_extent>
      constexpr span<element_type, @\seebelow@> subspan() const;

    constexpr span<element_type, dynamic_extent> first(index_type count) const;
    constexpr span<element_type, dynamic_extent> last(index_type count) const;
    constexpr span<element_type, dynamic_extent> subspan(
      index_type offset, index_type count = dynamic_extent) const;

    // \ref{span.obs}, observers
    constexpr index_type size() const noexcept;
    constexpr index_type size_bytes() const noexcept;
    constexpr bool empty() const noexcept;

    // \ref{span.elem}, element access
    constexpr reference operator[](index_type idx) const;
    constexpr reference operator()(index_type idx) const;
    constexpr pointer data() const noexcept;

    // \ref{span.iterators}, iterator support
    constexpr iterator begin() const noexcept;
    constexpr iterator end() const noexcept;
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    constexpr reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator rend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

  private:
    pointer data_;    // \expos
    index_type size_; // \expos
  };

  template<class T, size_t N>
    span(T (&)[N]) -> span<T, N>;
  template<class T, size_t N>
    span(array<T, N>&) -> span<T, N>;
  template<class T, size_t N>
    span(const array<T, N>&) -> span<const T, N>;
  template<class Container>
    span(Container&) -> span<typename Container::value_type>;
  template<class Container>
    span(const Container&) -> span<const typename Container::value_type>;
}
\end{codeblock}

\rSec3[span.cons]{Constructors, copy, and assignment}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
constexpr span() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an empty \tcode{span}.

\pnum
\postconditions
\tcode{size() == 0 \&\& data() == nullptr}.

\pnum
\remarks
This constructor shall not participate in overload resolution
unless \tcode{Extent <= 0} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
constexpr span(pointer ptr, index_type count);
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires \range{ptr}{ptr + count} shall be a valid range.
If \tcode{extent} is not equal to \tcode{dynamic_extent},
then \tcode{count} shall be equal to \tcode{extent}.

\pnum
\effects
Constructs a \tcode{span} that is a view over the range \range{ptr}{ptr + count}.
If \tcode{count} is 0 then an empty span is constructed.

\pnum
\postconditions
\tcode{size() == count \&\& data() == ptr}.

\throws
Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
constexpr span(pointer first, pointer last);
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\range{first}{last} shall be a valid range.
If \tcode{extent} is not equal to \tcode{dynamic_extent},
then \tcode{last - first} shall be equal to \tcode{extent}.

\pnum
\effects
Constructs a span that is a view over the range \range{first}{last}.
If \tcode{last - first == 0} then an empty \tcode{span} is constructed.

\pnum
\postconditions
\tcode{size() == last - first \&\& data() == first}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
template<size_t N> constexpr span(element_type (&arr)[N]) noexcept;
template<size_t N> constexpr span(array<value_type, N>& arr) noexcept;
template<size_t N> constexpr span(const array<value_type, N>& arr) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{span} that is a view over the supplied array.

\pnum
\postconditions
\tcode{size() == N \&\& data() == data(arr)}.

\pnum
\remarks
These constructors shall not participate in overload resolution unless:
\begin{itemize}
\item \tcode{extent == dynamic_extent || N == extent} is \tcode{true}, and
\item \tcode{remove_pointer_t<decltype(data(arr))>(*)[]} is convertible to \tcode{ElementType(*)[]}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
template<class Container> constexpr span(Container& cont);
template<class Container> constexpr span(const Container& cont);
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\range{data(cont)}{data(cont) + size(cont)} shall be a valid range.
If \tcode{extent} is not equal to \tcode{dynamic_extent},
then \tcode{size(cont)} shall be equal to \tcode{extent}.

\pnum
\effects
Constructs a \tcode{span} that is a view over the range \range{data(cont)}{data(cont) + size(cont)}.

\pnum
\postconditions
\tcode{size() == size(cont) \&\& data() == data(cont)}.

\pnum
\throws
What and when \tcode{data(cont)} and \tcode{size(cont)} throw.

\pnum
\remarks
These constructors shall not participate in overload resolution unless:
\begin{itemize}
\item \tcode{Container} is not a specialization of \tcode{span},
\item \tcode{Container} is not a specialization of \tcode{array},
\item \tcode{is_array_v<Container>} is \tcode{false},
\item \tcode{data(cont)} and \tcode{size(cont)} are both well-formed, and
\item \tcode{remove_pointer_t<decltype(data(cont))>(*)[]} is convertible to \tcode{ElementType(*)[]}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
constexpr span(const span& other) noexcept = default;
\end{itemdecl}
\begin{itemdescr}
\pnum
\postconditions
\tcode{other.size() == size() \&\& other.data() == data()}.
\end{itemdescr}

\indexlibrary{\idxcode{span}!constructor}%
\begin{itemdecl}
template<class OtherElementType, ptrdiff_t OtherExtent>
  constexpr span(const span<OtherElementType, OtherExtent>& s) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{span} that is a view over the range
\range{s.data()}{s.data() + s.size()}.

\pnum
\postconditions
\tcode{size() == s.size() \&\& data() == s.data()}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless:
\begin{itemize}
\item \tcode{Extent == dynamic_extent || Extent == OtherExtent} is \tcode{true}, and
\item \tcode{OtherElementType(*)[]} is convertible to \tcode{ElementType(*)[]}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{span}}%
\begin{itemdecl}
constexpr span& operator=(const span& other) noexcept = default;
\end{itemdecl}
\begin{itemdescr}
\pnum
\postconditions
\tcode{size() == other.size() \&\& data() == other.data()}.
\end{itemdescr}

\rSec3[span.sub]{Subviews}

\indexlibrarymember{span}{first}%
\begin{itemdecl}
template<ptrdiff_t Count> constexpr span<element_type, Count> first() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{0 <= Count \&\& Count <= size()}.

\pnum
\effects
Equivalent to: \tcode{return \{data(), Count\};}
\end{itemdescr}

\indexlibrarymember{span}{last}%
\begin{itemdecl}
template<ptrdiff_t Count> constexpr span<element_type, Count> last() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{0 <= Count \&\& Count <= size()}.

\pnum
\effects
Equivalent to: \tcode{return \{data() + (size() - Count), Count\};}
\end{itemdescr}

\indexlibrarymember{span}{subspan}%
\begin{itemdecl}
template<ptrdiff_t Offset, ptrdiff_t Count = dynamic_extent>
  constexpr span<element_type, @\seebelow@> subspan() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\begin{codeblock}
(0 <= Offset && Offset <= size())
&& (Count == dynamic_extent || Count >= 0 && Offset + Count <= size())
\end{codeblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
return span<ElementType, @\seebelow@>(
  data() + Offset, Count != dynamic_extent ? Count : size() - Offset);
\end{codeblock}

\pnum
\remarks
The second template argument of the returned \tcode{span} type is:
\begin{codeblock}
Count != dynamic_extent ? Count
                        : (Extent != dynamic_extent ? Extent - Offset
                                                    : dynamic_extent)
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{span}{first}%
\begin{itemdecl}
constexpr span<element_type, dynamic_extent> first(index_type count) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{0 <= count \&\& count <= size()}.

\pnum
\effects
Equivalent to: \tcode{return \{data(), count\};}
\end{itemdescr}

\indexlibrarymember{span}{last}%
\begin{itemdecl}
constexpr span<element_type, dynamic_extent> last(index_type count) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{0 <= count 0 \&\& count <= size()}.

\pnum
\effects
Equivalent to: \tcode{return \{data() + (size() - count), count\};}
\end{itemdescr}

\indexlibrarymember{span}{subspan}%
\begin{itemdecl}
constexpr span<element_type, dynamic_extent> subspan(
  index_type offset, index_type count = dynamic_extent) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\begin{codeblock}
(0 <= offset && offset <= size())
&& (count == dynamic_extent || count >= 0 && offset + count <= size())
\end{codeblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
return {data() + offset, count == dynamic_extent ? size() - offset : count};
\end{codeblock}
\end{itemdescr}

\rSec3[span.obs]{Observers}

\indexlibrarymember{span}{size}%
\begin{itemdecl}
constexpr index_type size() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return size_;}
\end{itemdescr}

\indexlibrarymember{span}{size_bytes}%
\begin{itemdecl}
constexpr index_type size_bytes() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return size() * sizeof(element_type);}
\end{itemdescr}

\indexlibrarymember{span}{empty}%
\begin{itemdecl}
constexpr bool empty() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return size() == 0;}
\end{itemdescr}

\rSec3[span.elem]{Element access}

\indexlibrary{\idxcode{operator[]}!\idxcode{span}}%
\indexlibrary{\idxcode{operator()}!\idxcode{span}}%
\begin{itemdecl}
constexpr reference operator[](index_type idx) const;
constexpr reference operator()(index_type idx) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{0 <= idx \&\& idx < size()}.

\pnum
\effects
Equivalent to: \tcode{return *(data() + idx);}
\end{itemdescr}

\indexlibrarymember{span}{data}%
\begin{itemdecl}
constexpr pointer data() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return data_;}
\end{itemdescr}

\rSec3[span.iterators]{Iterator support}

\indexlibrarymember{span}{begin}%
\begin{itemdecl}
constexpr iterator begin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
An iterator referring to the first element in the span.
If \tcode{empty()} is \tcode{true}, then it returns the
same value as \tcode{end()}.
\end{itemdescr}

\indexlibrarymember{span}{end}%
\begin{itemdecl}
constexpr iterator end() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
An iterator which is the past-the-end value.
\end{itemdescr}

\indexlibrarymember{span}{rbegin}%
\begin{itemdecl}
constexpr reverse_iterator rbegin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return reverse_iterator(end());}
\end{itemdescr}

\indexlibrarymember{span}{rend}%
\begin{itemdecl}
constexpr reverse_iterator rend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{return reverse_iterator(begin());}
\end{itemdescr}

\indexlibrarymember{span}{cbegin}%
\begin{itemdecl}
constexpr const_iterator cbegin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A constant iterator referring to the first element in the span.
If \tcode{empty()} is \tcode{true}, then it returns the same value
as \tcode{cend()}.
\end{itemdescr}

\indexlibrarymember{span}{cend}%
\begin{itemdecl}
constexpr const_iterator cend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A constant iterator which is the past-the-end value.
\end{itemdescr}

\indexlibrarymember{span}{crbegin}%
\begin{itemdecl}
constexpr const_reverse_iterator crbegin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return const_reverse_iterator(cend());}
\end{itemdescr}

\indexlibrarymember{span}{crend}%
\begin{itemdecl}
constexpr const_reverse_iterator crend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return const_reverse_iterator(cbegin());}
\end{itemdescr}

\rSec3[span.comparison]{Comparison operators}

\indexlibrary{\idxcode{operator==}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator==(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return equal(l.begin(), l.end(), r.begin(), r.end());}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator!=(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(l == r);}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator<(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return lexicographical_compare(l.begin(), l.end(), r.begin(), r.end());
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator<=(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(r < l);}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator>(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return (r < l);}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{span}}%
\begin{itemdecl}
template<class T, ptrdiff_t X, class U, ptrdiff_t Y>
  constexpr bool operator>=(span<T, X> l, span<U, Y> r);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(l < r);}
\end{itemdescr}

\rSec3[span.objectrep]{Views of object representation}

\indexlibrary{\idxcode{as_bytes}}%
\begin{itemdecl}
template <class ElementType, ptrdiff_t Extent>
  span<const byte,
       Extent == dynamic_extent ? dynamic_extent
                                : static_cast<ptrdiff_t>(sizeof(ElementType)) * Extent>
    as_bytes(span<ElementType, Extent> s) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \{reinterpret_cast<const byte*>(s.data()), s.size_bytes()\};}
\end{itemdescr}

\indexlibrary{\idxcode{as_writable_bytes}}%
\begin{itemdecl}
template<class ElementType, ptrdiff_t Extent>
  span<byte,
       Extent == dynamic_extent ? dynamic_extent
                                : static_cast<ptrdiff_t>(sizeof(ElementType)) * Extent>
    as_writable_bytes(span<ElementType, Extent> s) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \{reinterpret_cast<byte*>(s.data()), s.size_bytes()\};}

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_const_v<ElementType>} is \tcode{false}.
\end{itemdescr}
