%!TEX root = std.tex
\rSec0[diagnostics]{Diagnostics library}

\rSec1[diagnostics.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to detect and
report error conditions.

\pnum
The following subclauses describe components for
reporting several kinds of exceptional conditions,
documenting program assertions, and
a global variable for error number codes,
as summarized in \tref{diagnostics.summary}.

\begin{libsumtab}{Diagnostics library summary}{diagnostics.summary}
\ref{std.exceptions}  & Exception classes     &   \tcode{<stdexcept>}     \\ \rowsep
\ref{assertions}      & Assertions            &   \tcode{<cassert>}       \\ \rowsep
\ref{errno}           & Error numbers         &   \tcode{<cerrno>}        \\ \rowsep
\ref{syserr}          & System error support  &   \tcode{<system_error>}  \\
\end{libsumtab}

\rSec1[std.exceptions]{Exception classes}

\rSec2[std.exceptions.general]{General}

\pnum
The \Cpp{} standard library provides classes to be used to report certain errors\iref{res.on.exception.handling} in
\Cpp{} programs.
In the error model reflected in these classes, errors are divided into two
broad categories:
\term{logic}
errors and
\term{runtime}
errors.

\pnum
The distinguishing characteristic of logic errors is that they are due to errors
in the internal logic of the program.
In theory, they are preventable.

\pnum
By contrast, runtime errors are due to events beyond the scope of the program.
They cannot be easily predicted in advance.
The header \libheaderdef{stdexcept}
defines several types of predefined exceptions for reporting errors in a \Cpp{} program.
These exceptions are related by inheritance.

\rSec2[stdexcept.syn]{Header \tcode{<stdexcept>} synopsis}

\indexlibraryglobal{logic_error}%
\indexlibraryglobal{domain_error}%
\indexlibraryglobal{invalid_argument}%
\indexlibraryglobal{length_error}%
\indexlibraryglobal{out_of_range}%
\indexlibraryglobal{runtime_error}%
\indexlibraryglobal{range_error}%
\indexlibraryglobal{overflow_error}%
\indexlibraryglobal{underflow_error}%
\begin{codeblock}
namespace std {
  class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
  class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;
}
\end{codeblock}

\rSec2[logic.error]{Class \tcode{logic_error}}

\indexlibraryglobal{logic_error}%
\begin{codeblock}
namespace std {
  class logic_error : public exception {
  public:
    explicit logic_error(const string& what_arg);
    explicit logic_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{logic_error}
defines the type of objects thrown as
exceptions to report errors presumably detectable before
the program executes, such as violations of logical preconditions or class
invariants.

\indexlibraryctor{logic_error}%
\begin{itemdecl}
logic_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{logic_error}%
\begin{itemdecl}
logic_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[domain.error]{Class \tcode{domain_error}}

\indexlibraryglobal{domain_error}%
\begin{codeblock}
namespace std {
  class domain_error : public logic_error {
  public:
    explicit domain_error(const string& what_arg);
    explicit domain_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{domain_error}
defines the type of objects thrown as
exceptions by the implementation to report domain errors.

\indexlibraryctor{domain_error}%
\begin{itemdecl}
domain_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{domain_error}%
\begin{itemdecl}
domain_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[invalid.argument]{Class \tcode{invalid_argument}}

\indexlibraryglobal{invalid_argument}%
\begin{codeblock}
namespace std {
  class invalid_argument : public logic_error {
  public:
    explicit invalid_argument(const string& what_arg);
    explicit invalid_argument(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{invalid_argument}
defines the type of objects thrown as exceptions to report an invalid argument.

\indexlibraryctor{invalid_argument}%
\begin{itemdecl}
invalid_argument(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{invalid_argument}%
\begin{itemdecl}
invalid_argument(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[length.error]{Class \tcode{length_error}}

\indexlibraryglobal{length_error}%
\begin{codeblock}
namespace std {
  class length_error : public logic_error {
  public:
    explicit length_error(const string& what_arg);
    explicit length_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{length_error}
defines the type of objects thrown as exceptions
to report an attempt to produce
an object whose length exceeds its maximum allowable size.

\indexlibraryctor{length_error}%
\begin{itemdecl}
length_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{length_error}%
\begin{itemdecl}
length_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[out.of.range]{Class \tcode{out_of_range}}

\indexlibraryglobal{out_of_range}%
\begin{codeblock}
namespace std {
  class out_of_range : public logic_error {
  public:
    explicit out_of_range(const string& what_arg);
    explicit out_of_range(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{out_of_range}
defines the type of objects thrown as exceptions to report an
argument value not in its expected range.
\indextext{argument}

\indexlibraryctor{out_of_range}%
\begin{itemdecl}
out_of_range(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{out_of_range}%
\begin{itemdecl}
out_of_range(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[runtime.error]{Class \tcode{runtime_error}}

\indexlibraryglobal{runtime_error}%
\begin{codeblock}
namespace std {
  class runtime_error : public exception {
  public:
    explicit runtime_error(const string& what_arg);
    explicit runtime_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{runtime_error}
defines the type of objects thrown as exceptions to report errors presumably detectable only
when the program executes.

\indexlibraryctor{runtime_error}%
\begin{itemdecl}
runtime_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{runtime_error}%
\begin{itemdecl}
runtime_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[range.error]{Class \tcode{range_error}}

\indexlibraryglobal{range_error}%
\begin{codeblock}
namespace std {
  class range_error : public runtime_error {
  public:
    explicit range_error(const string& what_arg);
    explicit range_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{range_error}
defines the type of objects thrown as exceptions to report range errors
in internal computations.

\indexlibraryctor{range_error}%
\begin{itemdecl}
range_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{range_error}%
\begin{itemdecl}
range_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[overflow.error]{Class \tcode{overflow_error}}

\indexlibraryglobal{overflow_error}%
\begin{codeblock}
namespace std {
  class overflow_error : public runtime_error {
  public:
    explicit overflow_error(const string& what_arg);
    explicit overflow_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{overflow_error}
defines the type of objects thrown as exceptions to report an arithmetic overflow error.

\indexlibraryctor{overflow_error}%
\begin{itemdecl}
overflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{overflow_error}%
\begin{itemdecl}
overflow_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[underflow.error]{Class \tcode{underflow_error}}

\indexlibraryglobal{underflow_error}%
\begin{codeblock}
namespace std {
  class underflow_error : public runtime_error {
  public:
    explicit underflow_error(const string& what_arg);
    explicit underflow_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{underflow_error}
defines the type of objects thrown as exceptions to report an arithmetic underflow error.

\indexlibraryctor{underflow_error}%
\begin{itemdecl}
underflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{underflow_error}%
\begin{itemdecl}
underflow_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec1[assertions]{Assertions}

\rSec2[assertions.general]{General}

\pnum
The header \libheaderdef{cassert}
provides a macro for documenting \Cpp{} program assertions and a mechanism
for disabling the assertion checks.

\rSec2[cassert.syn]{Header \tcode{<cassert>} synopsis}

\indexlibraryglobal{assert}%
\begin{codeblock}
#define assert(E) @\seebelow@
\end{codeblock}

\pnum
\indextext{static_assert@\tcode{static_assert}!not macro}%
The contents are the same as the C standard library header
\libheader{assert.h},
except that a macro named \tcode{static_assert}
is not defined.

\xrefc{7.2}

\rSec2[assertions.assert]{The \tcode{assert} macro}

\pnum
An expression \tcode{assert(E)}
is a constant subexpression\iref{defns.const.subexpr}, if
\begin{itemize}
\item
\tcode{NDEBUG} is defined at the point where \tcode{assert}
is last defined or redefined, or
\item
\tcode{E} contextually converted to \tcode{bool}\iref{conv}
is a constant subexpression that evaluates to the value \tcode{true}.
\end{itemize}

\rSec1[errno]{Error numbers}

\rSec2[errno.general]{General}

\pnum
The contents of the header \libheaderdef{cerrno} are the same as the POSIX header
\libheader{errno.h}, except that \tcode{errno} shall be defined as a macro.
\begin{note}
The intent is to remain in close alignment with the POSIX standard.
\end{note}
A separate \tcode{errno} value shall be provided for each thread.

\rSec2[cerrno.syn]{Header \tcode{<cerrno>} synopsis}

\indexlibraryglobal{errno}%
\indexlibraryglobal{E2BIG}%
\indexlibraryglobal{EACCES}%
\indexlibraryglobal{EADDRINUSE}%
\indexlibraryglobal{EADDRNOTAVAIL}%
\indexlibraryglobal{EAFNOSUPPORT}%
\indexlibraryglobal{EAGAIN}%
\indexlibraryglobal{EALREADY}%
\indexlibraryglobal{EBADF}%
\indexlibraryglobal{EBADMSG}%
\indexlibraryglobal{EBUSY}%
\indexlibraryglobal{ECANCELED}%
\indexlibraryglobal{ECHILD}%
\indexlibraryglobal{ECONNABORTED}%
\indexlibraryglobal{ECONNREFUSED}%
\indexlibraryglobal{ECONNRESET}%
\indexlibraryglobal{EDEADLK}%
\indexlibraryglobal{EDESTADDRREQ}%
\indexlibraryglobal{EDOM}%
\indexlibraryglobal{EEXIST}%
\indexlibraryglobal{EFAULT}%
\indexlibraryglobal{EFBIG}%
\indexlibraryglobal{EHOSTUNREACH}%
\indexlibraryglobal{EIDRM}%
\indexlibraryglobal{EILSEQ}%
\indexlibraryglobal{EINPROGRESS}%
\indexlibraryglobal{EINTR}%
\indexlibraryglobal{EINVAL}%
\indexlibraryglobal{EIO}%
\indexlibraryglobal{EISCONN}%
\indexlibraryglobal{EISDIR}%
\indexlibraryglobal{ELOOP}%
\indexlibraryglobal{EMFILE}%
\indexlibraryglobal{EMLINK}%
\indexlibraryglobal{EMSGSIZE}%
\indexlibraryglobal{ENAMETOOLONG}%
\indexlibraryglobal{ENETDOWN}%
\indexlibraryglobal{ENETRESET}%
\indexlibraryglobal{ENETUNREACH}%
\indexlibraryglobal{ENFILE}%
\indexlibraryglobal{ENOBUFS}%
\indexlibraryglobal{ENODATA}%
\indexlibraryglobal{ENODEV}%
\indexlibraryglobal{ENOENT}%
\indexlibraryglobal{ENOEXEC}%
\indexlibraryglobal{ENOLCK}%
\indexlibraryglobal{ENOLINK}%
\indexlibraryglobal{ENOMEM}%
\indexlibraryglobal{ENOMSG}%
\indexlibraryglobal{ENOPROTOOPT}%
\indexlibraryglobal{ENOSPC}%
\indexlibraryglobal{ENOSR}%
\indexlibraryglobal{ENOSTR}%
\indexlibraryglobal{ENOSYS}%
\indexlibraryglobal{ENOTCONN}%
\indexlibraryglobal{ENOTDIR}%
\indexlibraryglobal{ENOTEMPTY}%
\indexlibraryglobal{ENOTRECOVERABLE}%
\indexlibraryglobal{ENOTSOCK}%
\indexlibraryglobal{ENOTSUP}%
\indexlibraryglobal{ENOTTY}%
\indexlibraryglobal{ENXIO}%
\indexlibraryglobal{EOPNOTSUPP}%
\indexlibraryglobal{EOVERFLOW}%
\indexlibraryglobal{EOWNERDEAD}%
\indexlibraryglobal{EPERM}%
\indexlibraryglobal{EPIPE}%
\indexlibraryglobal{EPROTO}%
\indexlibraryglobal{EPROTONOSUPPORT}%
\indexlibraryglobal{EPROTOTYPE}%
\indexlibraryglobal{ERANGE}%
\indexlibraryglobal{EROFS}%
\indexlibraryglobal{ESPIPE}%
\indexlibraryglobal{ESRCH}%
\indexlibraryglobal{ETIME}%
\indexlibraryglobal{ETIMEDOUT}%
\indexlibraryglobal{ETXTBSY}%
\indexlibraryglobal{EWOULDBLOCK}%
\indexlibraryglobal{EXDEV}%
\begin{codeblock}
#define errno @\seebelow@

#define E2BIG @\seebelow@
#define EACCES @\seebelow@
#define EADDRINUSE @\seebelow@
#define EADDRNOTAVAIL @\seebelow@
#define EAFNOSUPPORT @\seebelow@
#define EAGAIN @\seebelow@
#define EALREADY @\seebelow@
#define EBADF @\seebelow@
#define EBADMSG @\seebelow@
#define EBUSY @\seebelow@
#define ECANCELED @\seebelow@
#define ECHILD @\seebelow@
#define ECONNABORTED @\seebelow@
#define ECONNREFUSED @\seebelow@
#define ECONNRESET @\seebelow@
#define EDEADLK @\seebelow@
#define EDESTADDRREQ @\seebelow@
#define EDOM @\seebelow@
#define EEXIST @\seebelow@
#define EFAULT @\seebelow@
#define EFBIG @\seebelow@
#define EHOSTUNREACH @\seebelow@
#define EIDRM @\seebelow@
#define EILSEQ @\seebelow@
#define EINPROGRESS @\seebelow@
#define EINTR @\seebelow@
#define EINVAL @\seebelow@
#define EIO @\seebelow@
#define EISCONN @\seebelow@
#define EISDIR @\seebelow@
#define ELOOP @\seebelow@
#define EMFILE @\seebelow@
#define EMLINK @\seebelow@
#define EMSGSIZE @\seebelow@
#define ENAMETOOLONG @\seebelow@
#define ENETDOWN @\seebelow@
#define ENETRESET @\seebelow@
#define ENETUNREACH @\seebelow@
#define ENFILE @\seebelow@
#define ENOBUFS @\seebelow@
#define ENODATA @\seebelow@
#define ENODEV @\seebelow@
#define ENOENT @\seebelow@
#define ENOEXEC @\seebelow@
#define ENOLCK @\seebelow@
#define ENOLINK @\seebelow@
#define ENOMEM @\seebelow@
#define ENOMSG @\seebelow@
#define ENOPROTOOPT @\seebelow@
#define ENOSPC @\seebelow@
#define ENOSR @\seebelow@
#define ENOSTR @\seebelow@
#define ENOSYS @\seebelow@
#define ENOTCONN @\seebelow@
#define ENOTDIR @\seebelow@
#define ENOTEMPTY @\seebelow@
#define ENOTRECOVERABLE @\seebelow@
#define ENOTSOCK @\seebelow@
#define ENOTSUP @\seebelow@
#define ENOTTY @\seebelow@
#define ENXIO @\seebelow@
#define EOPNOTSUPP @\seebelow@
#define EOVERFLOW @\seebelow@
#define EOWNERDEAD @\seebelow@
#define EPERM @\seebelow@
#define EPIPE @\seebelow@
#define EPROTO @\seebelow@
#define EPROTONOSUPPORT @\seebelow@
#define EPROTOTYPE @\seebelow@
#define ERANGE @\seebelow@
#define EROFS @\seebelow@
#define ESPIPE @\seebelow@
#define ESRCH @\seebelow@
#define ETIME @\seebelow@
#define ETIMEDOUT @\seebelow@
#define ETXTBSY @\seebelow@
#define EWOULDBLOCK @\seebelow@
#define EXDEV @\seebelow@
\end{codeblock}

\pnum
The meaning of the macros in this header is defined by the POSIX standard.

\xrefc{7.5}

\rSec1[syserr]{System error support}

\rSec2[syserr.general]{General}

\pnum
Subclause \ref{syserr} describes components that the standard library and
\Cpp{} programs may use to report error conditions originating from
the operating system or other low-level application program interfaces.

\pnum
Components described in \ref{syserr} shall not change the value of
\tcode{errno}\iref{errno}.
Implementations should leave the error states provided by other
libraries unchanged.

\rSec2[system.error.syn]{Header \tcode{<system_error>} synopsis}

\indexheader{system_error}%
\indexlibraryglobal{error_category}%
\indexlibraryglobal{error_code}%
\indexlibraryglobal{error_condition}%
\indexlibraryglobal{system_error}%
\indexlibraryglobal{is_error_code_enum}%
\indexlibraryglobal{is_error_condition_enum}%
\indexlibraryglobal{errc}%
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}

namespace std {
  class error_category;
  const error_category& generic_category() noexcept;
  const error_category& system_category() noexcept;

  class error_code;
  class error_condition;
  class system_error;

  template<class T>
    struct is_error_code_enum : public false_type {};

  template<class T>
    struct is_error_condition_enum : public false_type {};

  enum class errc {
    address_family_not_supported,       // \tcode{EAFNOSUPPORT}
    address_in_use,                     // \tcode{EADDRINUSE}
    address_not_available,              // \tcode{EADDRNOTAVAIL}
    already_connected,                  // \tcode{EISCONN}
    argument_list_too_long,             // \tcode{E2BIG}
    argument_out_of_domain,             // \tcode{EDOM}
    bad_address,                        // \tcode{EFAULT}
    bad_file_descriptor,                // \tcode{EBADF}
    bad_message,                        // \tcode{EBADMSG}
    broken_pipe,                        // \tcode{EPIPE}
    connection_aborted,                 // \tcode{ECONNABORTED}
    connection_already_in_progress,     // \tcode{EALREADY}
    connection_refused,                 // \tcode{ECONNREFUSED}
    connection_reset,                   // \tcode{ECONNRESET}
    cross_device_link,                  // \tcode{EXDEV}
    destination_address_required,       // \tcode{EDESTADDRREQ}
    device_or_resource_busy,            // \tcode{EBUSY}
    directory_not_empty,                // \tcode{ENOTEMPTY}
    executable_format_error,            // \tcode{ENOEXEC}
    file_exists,                        // \tcode{EEXIST}
    file_too_large,                     // \tcode{EFBIG}
    filename_too_long,                  // \tcode{ENAMETOOLONG}
    function_not_supported,             // \tcode{ENOSYS}
    host_unreachable,                   // \tcode{EHOSTUNREACH}
    identifier_removed,                 // \tcode{EIDRM}
    illegal_byte_sequence,              // \tcode{EILSEQ}
    inappropriate_io_control_operation, // \tcode{ENOTTY}
    interrupted,                        // \tcode{EINTR}
    invalid_argument,                   // \tcode{EINVAL}
    invalid_seek,                       // \tcode{ESPIPE}
    io_error,                           // \tcode{EIO}
    is_a_directory,                     // \tcode{EISDIR}
    message_size,                       // \tcode{EMSGSIZE}
    network_down,                       // \tcode{ENETDOWN}
    network_reset,                      // \tcode{ENETRESET}
    network_unreachable,                // \tcode{ENETUNREACH}
    no_buffer_space,                    // \tcode{ENOBUFS}
    no_child_process,                   // \tcode{ECHILD}
    no_link,                            // \tcode{ENOLINK}
    no_lock_available,                  // \tcode{ENOLCK}
    no_message_available,               // \tcode{ENODATA}
    no_message,                         // \tcode{ENOMSG}
    no_protocol_option,                 // \tcode{ENOPROTOOPT}
    no_space_on_device,                 // \tcode{ENOSPC}
    no_stream_resources,                // \tcode{ENOSR}
    no_such_device_or_address,          // \tcode{ENXIO}
    no_such_device,                     // \tcode{ENODEV}
    no_such_file_or_directory,          // \tcode{ENOENT}
    no_such_process,                    // \tcode{ESRCH}
    not_a_directory,                    // \tcode{ENOTDIR}
    not_a_socket,                       // \tcode{ENOTSOCK}
    not_a_stream,                       // \tcode{ENOSTR}
    not_connected,                      // \tcode{ENOTCONN}
    not_enough_memory,                  // \tcode{ENOMEM}
    not_supported,                      // \tcode{ENOTSUP}
    operation_canceled,                 // \tcode{ECANCELED}
    operation_in_progress,              // \tcode{EINPROGRESS}
    operation_not_permitted,            // \tcode{EPERM}
    operation_not_supported,            // \tcode{EOPNOTSUPP}
    operation_would_block,              // \tcode{EWOULDBLOCK}
    owner_dead,                         // \tcode{EOWNERDEAD}
    permission_denied,                  // \tcode{EACCES}
    protocol_error,                     // \tcode{EPROTO}
    protocol_not_supported,             // \tcode{EPROTONOSUPPORT}
    read_only_file_system,              // \tcode{EROFS}
    resource_deadlock_would_occur,      // \tcode{EDEADLK}
    resource_unavailable_try_again,     // \tcode{EAGAIN}
    result_out_of_range,                // \tcode{ERANGE}
    state_not_recoverable,              // \tcode{ENOTRECOVERABLE}
    stream_timeout,                     // \tcode{ETIME}
    text_file_busy,                     // \tcode{ETXTBSY}
    timed_out,                          // \tcode{ETIMEDOUT}
    too_many_files_open_in_system,      // \tcode{ENFILE}
    too_many_files_open,                // \tcode{EMFILE}
    too_many_links,                     // \tcode{EMLINK}
    too_many_symbolic_link_levels,      // \tcode{ELOOP}
    value_too_large,                    // \tcode{EOVERFLOW}
    wrong_protocol_type,                // \tcode{EPROTOTYPE}
  };

  template<> struct is_error_condition_enum<errc> : true_type {};

  // \ref{syserr.errcode.nonmembers}, non-member functions
  error_code make_error_code(errc e) noexcept;

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const error_code& ec);

  // \ref{syserr.errcondition.nonmembers}, non-member functions
  error_condition make_error_condition(errc e) noexcept;

  // \ref{syserr.compare}, comparison operator functions
  bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
  bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
  bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
  strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
  strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;

  // \ref{syserr.hash}, hash support
  template<class T> struct hash;
  template<> struct hash<error_code>;
  template<> struct hash<error_condition>;

  // \ref{syserr}, system error support
  template<class T>
    inline constexpr bool is_error_code_enum_v = is_error_code_enum<T>::value;
  template<class T>
    inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<T>::value;
}
\end{codeblock}

\pnum
The value of each \tcode{enum errc} constant shall be the same as
the value of the \libheader{cerrno} macro shown in the above synopsis.
Whether or not the \libheader{system_error} implementation
exposes the \libheader{cerrno} macros is unspecified.

\pnum
The \tcode{is_error_code_enum} and \tcode{is_error_condition_enum} may be
specialized for program-defined types to indicate that such types are eligible
for \tcode{class error_code} and \tcode{class error_condition} automatic
conversions, respectively.

\rSec2[syserr.errcat]{Class \tcode{error_category}}

\rSec3[syserr.errcat.overview]{Overview}

\pnum
The class \tcode{error_category} serves as a base class for types used
to identify the source and encoding of a particular category of error code.
Classes may be derived from \tcode{error_category} to support
categories of errors in addition to those defined in this document.
Such classes shall behave as specified in subclause~\ref{syserr.errcat}.
\begin{note}
\tcode{error_category} objects are
passed by reference, and two such objects
are equal if they have the same address.
If there is more than a single object of a custom \tcode{error_category} type,
such equality comparisons can evaluate to \tcode{false}
even for objects holding the same value.
\end{note}

\indexlibraryglobal{error_category}%
\indexlibraryctor{error_category}%
\indexlibrarydtor{error_category}%
\indexlibraryglobal{generic_category}%
\indexlibraryglobal{system_category}%
\begin{codeblock}
namespace std {
  class error_category {
  public:
    constexpr error_category() noexcept;
    virtual ~error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    strong_ordering operator<=>(const error_category& rhs) const noexcept;
  };

  const error_category& generic_category() noexcept;
  const error_category& system_category() noexcept;
}
\end{codeblock}

\rSec3[syserr.errcat.virtuals]{Virtual members}

\indexlibrarymember{name}{error_category}%
\begin{itemdecl}
virtual const char* name() const noexcept = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string naming the error category.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_category}%
\begin{itemdecl}
virtual error_condition default_error_condition(int ev) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_condition(ev, *this)}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{default_error_condition(code) == condition}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(const error_code& code, int condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this == code.category() \&\& code.value() == condition}.
\end{itemdescr}

\indexlibrarymember{message}{error_category}%
\begin{itemdecl}
virtual string message(int ev) const = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string that describes the error condition denoted by \tcode{ev}.
\end{itemdescr}

\rSec3[syserr.errcat.nonvirtuals]{Non-virtual members}

\indexlibrarymember{operator==}{error_category}%
\begin{itemdecl}
bool operator==(const error_category& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{this == \&rhs}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_category}%
\begin{itemdecl}
strong_ordering operator<=>(const error_category& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{compare_three_way()(this, \&rhs)}.

\begin{note}
\tcode{compare_three_way}\iref{comparisons.three.way} provides a total ordering for pointers.
\end{note}
\end{itemdescr}

\rSec3[syserr.errcat.derived]{Program-defined classes derived from \tcode{error_category}}

\indexlibrarymember{name}{error_category}%
\begin{itemdecl}
virtual const char* name() const noexcept = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string naming the error category.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_category}%
\begin{itemdecl}
virtual error_condition default_error_condition(int ev) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object of type \tcode{error_condition} that corresponds to \tcode{ev}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if, for the category of error represented by \tcode{*this}, \tcode{code} is considered equivalent to \tcode{condition}; otherwise, \tcode{false}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(const error_code& code, int condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if, for the category of error represented by \tcode{*this}, \tcode{code} is considered equivalent to \tcode{condition}; otherwise, \tcode{false}.
\end{itemdescr}

\rSec3[syserr.errcat.objects]{Error category objects}

\indexlibraryglobal{generic_category}%
\begin{itemdecl}
const error_category& generic_category() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to an object of a type derived from class \tcode{error_category}.
All calls to this function shall return references to the same object.

\pnum
\remarks
The object's \tcode{default_error_condition} and \tcode{equivalent} virtual functions shall behave as specified for the class \tcode{error_category}. The object's \tcode{name} virtual function shall return a pointer to the string \tcode{"generic"}.
\end{itemdescr}

\indexlibraryglobal{system_category}%
\begin{itemdecl}
const error_category& system_category() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to an object of a type derived from class \tcode{error_category}.
All calls to this function shall return references to the same object.

\pnum
\remarks
The object's \tcode{equivalent} virtual functions shall behave as specified for
class \tcode{error_category}. The object's \tcode{name} virtual function shall return a
pointer to the string \tcode{"system"}. The object's \tcode{default_error_condition}
virtual function shall behave as follows:

If the argument \tcode{ev} corresponds to a POSIX \tcode{errno} value \tcode{posv}, the
function shall return \tcode{error_condition(posv, generic_category())}.
Otherwise, the function shall return \tcode{error_condition(ev,
system_category())}. What constitutes correspondence for any given operating
system is unspecified.
\begin{note}
The number of potential system error codes is large
and unbounded, and it is possible that some do not correspond to any POSIX \tcode{errno} value. Thus
implementations are given latitude in determining correspondence.
\end{note}
\end{itemdescr}

\rSec2[syserr.errcode]{Class \tcode{error_code}}

\rSec3[syserr.errcode.overview]{Overview}

\pnum
The class \tcode{error_code} describes an object used to hold error code
values, such as those originating from the operating system or other low-level
application program interfaces.
\begin{note}
Class \tcode{error_code} is an
adjunct to error reporting by exception.
\end{note}

\indexlibraryglobal{error_code}%
\begin{codeblock}
namespace std {
  class error_code {
  public:
    // \ref{syserr.errcode.constructors}, constructors
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
      error_code(ErrorCodeEnum e) noexcept;

    // \ref{syserr.errcode.modifiers}, modifiers
    void assign(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
      error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // \ref{syserr.errcode.observers}, observers
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;

  private:
    int val_;                   // \expos
    const error_category* cat_; // \expos
  };

  // \ref{syserr.errcode.nonmembers}, non-member functions
  error_code make_error_code(errc e) noexcept;

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
}
\end{codeblock}

\rSec3[syserr.errcode.constructors]{Constructors}

\indexlibraryctor{error_code}%
\begin{itemdecl}
error_code() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == 0} and \tcode{cat_ == \&system_category()}.
\end{itemdescr}

\indexlibraryctor{error_code}%
\begin{itemdecl}
error_code(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibraryctor{error_code}%
\begin{itemdecl}
template<class ErrorCodeEnum>
  error_code(ErrorCodeEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_code_enum_v<ErrorCodeEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_code(e)}.
\end{itemdescr}

\rSec3[syserr.errcode.modifiers]{Modifiers}

\indexlibrarymember{assign}{error_code}%
\begin{itemdecl}
void assign(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibrarymember{operator=}{error_code}%
\begin{itemdecl}
template<class ErrorCodeEnum>
  error_code& operator=(ErrorCodeEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_code_enum_v<ErrorCodeEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_code(e)}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{clear}{error_code}%
\begin{itemdecl}
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{value() == 0} and \tcode{category() == system_category()}.
\end{itemdescr}


\rSec3[syserr.errcode.observers]{Observers}

\indexlibrarymember{value}{error_code}%
\begin{itemdecl}
int value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{val_}.
\end{itemdescr}

\indexlibrarymember{category}{error_code}%
\begin{itemdecl}
const error_category& category() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*cat_}.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_code}%
\begin{itemdecl}
error_condition default_error_condition() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().default_error_condition(value())}.
\end{itemdescr}

\indexlibrarymember{message}{error_code}%
\begin{itemdecl}
string message() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().message(value())}.
\end{itemdescr}

\indexlibrarymember{operator bool}{error_code}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{value() != 0}.
\end{itemdescr}

\rSec3[syserr.errcode.nonmembers]{Non-member functions}

\indexlibrarymember{make_error_code}{errc}%
\begin{itemdecl}
error_code make_error_code(errc e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_code(static_cast<int>(e), generic_category())}.
\end{itemdescr}

\indexlibrarymember{operator<<}{error_code}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return os << ec.category().name() << ':' << ec.value();}
\end{itemdescr}


\rSec2[syserr.errcondition]{Class \tcode{error_condition}}

\rSec3[syserr.errcondition.overview]{Overview}

\pnum
The class \tcode{error_condition} describes an object used to hold values identifying
error conditions.
\begin{note}
\tcode{error_condition} values are portable abstractions,
while \tcode{error_code} values\iref{syserr.errcode} are implementation specific.
\end{note}

\indexlibraryglobal{error_condition}%
\begin{codeblock}
namespace std {
  class error_condition {
  public:
    // \ref{syserr.errcondition.constructors}, constructors
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template<class ErrorConditionEnum>
      error_condition(ErrorConditionEnum e) noexcept;

    // \ref{syserr.errcondition.modifiers}, modifiers
    void assign(int val, const error_category& cat) noexcept;
    template<class ErrorConditionEnum>
      error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // \ref{syserr.errcondition.observers}, observers
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;

  private:
    int val_;                   // \expos
    const error_category* cat_; // \expos
  };
}
\end{codeblock}

\rSec3[syserr.errcondition.constructors]{Constructors}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
error_condition() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == 0} and \tcode{cat_ == \&generic_category()}.
\end{itemdescr}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
error_condition(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
template<class ErrorConditionEnum>
  error_condition(ErrorConditionEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_condition_enum_v<ErrorConditionEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_condition(e)}.
\end{itemdescr}


\rSec3[syserr.errcondition.modifiers]{Modifiers}

\indexlibrarymember{assign}{error_condition}%
\begin{itemdecl}
void assign(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibrarymember{operator=}{error_condition}%
\begin{itemdecl}
template<class ErrorConditionEnum>
  error_condition& operator=(ErrorConditionEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_condition_enum_v<ErrorConditionEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_condition(e)}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{clear}{error_condition}%
\begin{itemdecl}
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{value() == 0} and \tcode{category() == generic_category()}.
\end{itemdescr}

\rSec3[syserr.errcondition.observers]{Observers}

\indexlibrarymember{value}{error_condition}%
\begin{itemdecl}
int value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{val_}.
\end{itemdescr}

\indexlibrarymember{category}{error_condition}%
\begin{itemdecl}
const error_category& category() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*cat_}.
\end{itemdescr}

\indexlibrarymember{message}{error_condition}%
\begin{itemdecl}
string message() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().message(value())}.
\end{itemdescr}

\indexlibrarymember{operator bool}{error_condition}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{value() != 0}.
\end{itemdescr}

\rSec3[syserr.errcondition.nonmembers]{Non-member functions}

\indexlibrarymember{make_error_condition}{errc}%
\begin{itemdecl}
error_condition make_error_condition(errc e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_condition(static_cast<int>(e), generic_category())}.
\end{itemdescr}

\rSec2[syserr.compare]{Comparison operator functions}

\indexlibrarymember{operator==}{error_code}%
\begin{itemdecl}
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category() == rhs.category() && lhs.value() == rhs.value()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{error_condition}%
\indexlibrarymember{operator==}{error_code}%
\begin{itemdecl}
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs, rhs.value())
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{error_condition}%
\begin{itemdecl}
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category() == rhs.category() && lhs.value() == rhs.value()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_code}%
\begin{itemdecl}
strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_condition}%
\begin{itemdecl}
strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
\end{codeblock}
\end{itemdescr}

\rSec2[syserr.hash]{System error hash support}

\indexlibrarymember{hash}{error_code}%
\begin{itemdecl}
template<> struct hash<error_code>;
template<> struct hash<error_condition>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specializations are enabled\iref{unord.hash}.
\end{itemdescr}

\rSec2[syserr.syserr]{Class \tcode{system_error}}

\rSec3[syserr.syserr.overview]{Overview}

\pnum
The class \tcode{system_error} describes an exception object used to
report error conditions that have an associated error code. Such error
conditions typically originate from the operating system or other low-level
application program interfaces.

\pnum
\begin{note}
If an error represents an out-of-memory condition, implementations are
encouraged to throw an exception object of type \tcode{bad_alloc}\iref{bad.alloc} rather
than \tcode{system_error}.
\end{note}
\indexlibraryglobal{system_error}%
\begin{codeblock}
namespace std {
  class system_error : public runtime_error {
  public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);
    const error_code& code() const noexcept;
    const char* what() const noexcept override;
  };
}
\end{codeblock}

\rSec3[syserr.syserr.members]{Members}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec, const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec} and\newline
\tcode{string_view(what()).find(what_arg.c_str()) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec} and
\tcode{string_view(what()).find(what_arg) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat, const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string_view(what()).find(what_arg.c_str()) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string_view(what()).find(what_arg) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == error_code(ev, ecat)}.
\end{itemdescr}

\indexlibrarymember{code}{system_error}%
\begin{itemdecl}
const error_code& code() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ec} or \tcode{error_code(ev, ecat)}, from the constructor,
as appropriate.
\end{itemdescr}

\indexlibrarymember{what}{system_error}%
\begin{itemdecl}
const char* what() const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \ntbs{} incorporating the arguments supplied in the constructor.

\begin{note}
The returned \ntbs{} can be the contents of \tcode{what_arg + ": " +
code.message()}.
\end{note}
\end{itemdescr}
