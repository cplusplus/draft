%!TEX root = std.tex
\rSec0[diagnostics]{Diagnostics library}

\rSec1[diagnostics.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to detect and
report error conditions.

\pnum
The following subclauses describe components for
reporting several kinds of exceptional conditions,
documenting program assertions,
obtaining stacktraces, and
a global variable for error number codes,
as summarized in \tref{diagnostics.summary}.

\begin{libsumtab}{Diagnostics library summary}{diagnostics.summary}
\ref{std.exceptions}  & Exception classes     &   \tcode{<stdexcept>}     \\ \rowsep
\ref{assertions}      & Assertions            &   \tcode{<cassert>}       \\ \rowsep
\ref{errno}           & Error numbers         &   \tcode{<cerrno>}        \\ \rowsep
\ref{syserr}          & System error support  &   \tcode{<system_error>}  \\ \rowsep
\ref{stacktrace}      & Stacktrace            &   \tcode{<stacktrace>}    \\
\end{libsumtab}

\rSec1[std.exceptions]{Exception classes}

\rSec2[std.exceptions.general]{General}

\pnum
The \Cpp{} standard library provides classes to be used to report certain errors\iref{res.on.exception.handling} in
\Cpp{} programs.
In the error model reflected in these classes, errors are divided into two
broad categories:
\term{logic}
errors and
\term{runtime}
errors.

\pnum
The distinguishing characteristic of logic errors is that they are due to errors
in the internal logic of the program.
In theory, they are preventable.

\pnum
By contrast, runtime errors are due to events beyond the scope of the program.
They cannot be easily predicted in advance.
The header \libheaderdef{stdexcept}
defines several types of predefined exceptions for reporting errors in a \Cpp{} program.
These exceptions are related by inheritance.

\rSec2[stdexcept.syn]{Header \tcode{<stdexcept>} synopsis}

\indexlibraryglobal{logic_error}%
\indexlibraryglobal{domain_error}%
\indexlibraryglobal{invalid_argument}%
\indexlibraryglobal{length_error}%
\indexlibraryglobal{out_of_range}%
\indexlibraryglobal{runtime_error}%
\indexlibraryglobal{range_error}%
\indexlibraryglobal{overflow_error}%
\indexlibraryglobal{underflow_error}%
\begin{codeblock}
namespace std {
  class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
  class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;
}
\end{codeblock}

\rSec2[logic.error]{Class \tcode{logic_error}}

\indexlibraryglobal{logic_error}%
\begin{codeblock}
namespace std {
  class logic_error : public exception {
  public:
    explicit logic_error(const string& what_arg);
    explicit logic_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{logic_error}
defines the type of objects thrown as
exceptions to report errors presumably detectable before
the program executes, such as violations of logical preconditions or class
invariants.

\indexlibraryctor{logic_error}%
\begin{itemdecl}
logic_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{logic_error}%
\begin{itemdecl}
logic_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[domain.error]{Class \tcode{domain_error}}

\indexlibraryglobal{domain_error}%
\begin{codeblock}
namespace std {
  class domain_error : public logic_error {
  public:
    explicit domain_error(const string& what_arg);
    explicit domain_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{domain_error}
defines the type of objects thrown as
exceptions by the implementation to report domain errors.

\indexlibraryctor{domain_error}%
\begin{itemdecl}
domain_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{domain_error}%
\begin{itemdecl}
domain_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[invalid.argument]{Class \tcode{invalid_argument}}

\indexlibraryglobal{invalid_argument}%
\begin{codeblock}
namespace std {
  class invalid_argument : public logic_error {
  public:
    explicit invalid_argument(const string& what_arg);
    explicit invalid_argument(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{invalid_argument}
defines the type of objects thrown as exceptions to report an invalid argument.

\indexlibraryctor{invalid_argument}%
\begin{itemdecl}
invalid_argument(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{invalid_argument}%
\begin{itemdecl}
invalid_argument(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[length.error]{Class \tcode{length_error}}

\indexlibraryglobal{length_error}%
\begin{codeblock}
namespace std {
  class length_error : public logic_error {
  public:
    explicit length_error(const string& what_arg);
    explicit length_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{length_error}
defines the type of objects thrown as exceptions
to report an attempt to produce
an object whose length exceeds its maximum allowable size.

\indexlibraryctor{length_error}%
\begin{itemdecl}
length_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{length_error}%
\begin{itemdecl}
length_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[out.of.range]{Class \tcode{out_of_range}}

\indexlibraryglobal{out_of_range}%
\begin{codeblock}
namespace std {
  class out_of_range : public logic_error {
  public:
    explicit out_of_range(const string& what_arg);
    explicit out_of_range(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{out_of_range}
defines the type of objects thrown as exceptions to report an
argument value not in its expected range.
\indextext{argument}

\indexlibraryctor{out_of_range}%
\begin{itemdecl}
out_of_range(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{out_of_range}%
\begin{itemdecl}
out_of_range(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[runtime.error]{Class \tcode{runtime_error}}

\indexlibraryglobal{runtime_error}%
\begin{codeblock}
namespace std {
  class runtime_error : public exception {
  public:
    explicit runtime_error(const string& what_arg);
    explicit runtime_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{runtime_error}
defines the type of objects thrown as exceptions to report errors presumably detectable only
when the program executes.

\indexlibraryctor{runtime_error}%
\begin{itemdecl}
runtime_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{runtime_error}%
\begin{itemdecl}
runtime_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[range.error]{Class \tcode{range_error}}

\indexlibraryglobal{range_error}%
\begin{codeblock}
namespace std {
  class range_error : public runtime_error {
  public:
    explicit range_error(const string& what_arg);
    explicit range_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{range_error}
defines the type of objects thrown as exceptions to report range errors
in internal computations.

\indexlibraryctor{range_error}%
\begin{itemdecl}
range_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{range_error}%
\begin{itemdecl}
range_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[overflow.error]{Class \tcode{overflow_error}}

\indexlibraryglobal{overflow_error}%
\begin{codeblock}
namespace std {
  class overflow_error : public runtime_error {
  public:
    explicit overflow_error(const string& what_arg);
    explicit overflow_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{overflow_error}
defines the type of objects thrown as exceptions to report an arithmetic overflow error.

\indexlibraryctor{overflow_error}%
\begin{itemdecl}
overflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{overflow_error}%
\begin{itemdecl}
overflow_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec2[underflow.error]{Class \tcode{underflow_error}}

\indexlibraryglobal{underflow_error}%
\begin{codeblock}
namespace std {
  class underflow_error : public runtime_error {
  public:
    explicit underflow_error(const string& what_arg);
    explicit underflow_error(const char* what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{underflow_error}
defines the type of objects thrown as exceptions to report an arithmetic underflow error.

\indexlibraryctor{underflow_error}%
\begin{itemdecl}
underflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\indexlibraryctor{underflow_error}%
\begin{itemdecl}
underflow_error(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}

\rSec1[assertions]{Assertions}

\rSec2[assertions.general]{General}

\pnum
The header \libheaderdef{cassert}
provides a macro for documenting \Cpp{} program assertions and a mechanism
for disabling the assertion checks.

\rSec2[cassert.syn]{Header \tcode{<cassert>} synopsis}

\indexlibraryglobal{assert}%
\begin{codeblock}
#define assert(E) @\seebelow@
\end{codeblock}

\pnum
\indextext{static_assert@\tcode{static_assert}!not macro}%
The contents are the same as the C standard library header
\libheader{assert.h},
except that a macro named \keyword{static_assert}
is not defined.

\xrefc{7.2}

\rSec2[assertions.assert]{The \tcode{assert} macro}

\pnum
An expression \tcode{assert(E)}
is a constant subexpression\iref{defns.const.subexpr}, if
\begin{itemize}
\item
\tcode{NDEBUG} is defined at the point where \tcode{assert}
is last defined or redefined, or
\item
\tcode{E} contextually converted to \tcode{bool}\iref{conv}
is a constant subexpression that evaluates to the value \tcode{true}.
\end{itemize}

\rSec1[errno]{Error numbers}

\rSec2[errno.general]{General}

\pnum
The contents of the header \libheaderdef{cerrno} are the same as the POSIX header
\libheader{errno.h}, except that \tcode{errno} shall be defined as a macro.
\begin{note}
The intent is to remain in close alignment with the POSIX standard.
\end{note}
A separate \tcode{errno} value shall be provided for each thread.

\rSec2[cerrno.syn]{Header \tcode{<cerrno>} synopsis}

\indexlibraryglobal{errno}%
\indexlibraryglobal{E2BIG}%
\indexlibraryglobal{EACCES}%
\indexlibraryglobal{EADDRINUSE}%
\indexlibraryglobal{EADDRNOTAVAIL}%
\indexlibraryglobal{EAFNOSUPPORT}%
\indexlibraryglobal{EAGAIN}%
\indexlibraryglobal{EALREADY}%
\indexlibraryglobal{EBADF}%
\indexlibraryglobal{EBADMSG}%
\indexlibraryglobal{EBUSY}%
\indexlibraryglobal{ECANCELED}%
\indexlibraryglobal{ECHILD}%
\indexlibraryglobal{ECONNABORTED}%
\indexlibraryglobal{ECONNREFUSED}%
\indexlibraryglobal{ECONNRESET}%
\indexlibraryglobal{EDEADLK}%
\indexlibraryglobal{EDESTADDRREQ}%
\indexlibraryglobal{EDOM}%
\indexlibraryglobal{EEXIST}%
\indexlibraryglobal{EFAULT}%
\indexlibraryglobal{EFBIG}%
\indexlibraryglobal{EHOSTUNREACH}%
\indexlibraryglobal{EIDRM}%
\indexlibraryglobal{EILSEQ}%
\indexlibraryglobal{EINPROGRESS}%
\indexlibraryglobal{EINTR}%
\indexlibraryglobal{EINVAL}%
\indexlibraryglobal{EIO}%
\indexlibraryglobal{EISCONN}%
\indexlibraryglobal{EISDIR}%
\indexlibraryglobal{ELOOP}%
\indexlibraryglobal{EMFILE}%
\indexlibraryglobal{EMLINK}%
\indexlibraryglobal{EMSGSIZE}%
\indexlibraryglobal{ENAMETOOLONG}%
\indexlibraryglobal{ENETDOWN}%
\indexlibraryglobal{ENETRESET}%
\indexlibraryglobal{ENETUNREACH}%
\indexlibraryglobal{ENFILE}%
\indexlibraryglobal{ENOBUFS}%
\indexlibraryglobal{ENODATA}%
\indexlibraryglobal{ENODEV}%
\indexlibraryglobal{ENOENT}%
\indexlibraryglobal{ENOEXEC}%
\indexlibraryglobal{ENOLCK}%
\indexlibraryglobal{ENOLINK}%
\indexlibraryglobal{ENOMEM}%
\indexlibraryglobal{ENOMSG}%
\indexlibraryglobal{ENOPROTOOPT}%
\indexlibraryglobal{ENOSPC}%
\indexlibraryglobal{ENOSR}%
\indexlibraryglobal{ENOSTR}%
\indexlibraryglobal{ENOSYS}%
\indexlibraryglobal{ENOTCONN}%
\indexlibraryglobal{ENOTDIR}%
\indexlibraryglobal{ENOTEMPTY}%
\indexlibraryglobal{ENOTRECOVERABLE}%
\indexlibraryglobal{ENOTSOCK}%
\indexlibraryglobal{ENOTSUP}%
\indexlibraryglobal{ENOTTY}%
\indexlibraryglobal{ENXIO}%
\indexlibraryglobal{EOPNOTSUPP}%
\indexlibraryglobal{EOVERFLOW}%
\indexlibraryglobal{EOWNERDEAD}%
\indexlibraryglobal{EPERM}%
\indexlibraryglobal{EPIPE}%
\indexlibraryglobal{EPROTO}%
\indexlibraryglobal{EPROTONOSUPPORT}%
\indexlibraryglobal{EPROTOTYPE}%
\indexlibraryglobal{ERANGE}%
\indexlibraryglobal{EROFS}%
\indexlibraryglobal{ESPIPE}%
\indexlibraryglobal{ESRCH}%
\indexlibraryglobal{ETIME}%
\indexlibraryglobal{ETIMEDOUT}%
\indexlibraryglobal{ETXTBSY}%
\indexlibraryglobal{EWOULDBLOCK}%
\indexlibraryglobal{EXDEV}%
\begin{codeblock}
#define errno @\seebelow@

#define E2BIG @\seebelow@
#define EACCES @\seebelow@
#define EADDRINUSE @\seebelow@
#define EADDRNOTAVAIL @\seebelow@
#define EAFNOSUPPORT @\seebelow@
#define EAGAIN @\seebelow@
#define EALREADY @\seebelow@
#define EBADF @\seebelow@
#define EBADMSG @\seebelow@
#define EBUSY @\seebelow@
#define ECANCELED @\seebelow@
#define ECHILD @\seebelow@
#define ECONNABORTED @\seebelow@
#define ECONNREFUSED @\seebelow@
#define ECONNRESET @\seebelow@
#define EDEADLK @\seebelow@
#define EDESTADDRREQ @\seebelow@
#define EDOM @\seebelow@
#define EEXIST @\seebelow@
#define EFAULT @\seebelow@
#define EFBIG @\seebelow@
#define EHOSTUNREACH @\seebelow@
#define EIDRM @\seebelow@
#define EILSEQ @\seebelow@
#define EINPROGRESS @\seebelow@
#define EINTR @\seebelow@
#define EINVAL @\seebelow@
#define EIO @\seebelow@
#define EISCONN @\seebelow@
#define EISDIR @\seebelow@
#define ELOOP @\seebelow@
#define EMFILE @\seebelow@
#define EMLINK @\seebelow@
#define EMSGSIZE @\seebelow@
#define ENAMETOOLONG @\seebelow@
#define ENETDOWN @\seebelow@
#define ENETRESET @\seebelow@
#define ENETUNREACH @\seebelow@
#define ENFILE @\seebelow@
#define ENOBUFS @\seebelow@
#define ENODATA @\seebelow@
#define ENODEV @\seebelow@
#define ENOENT @\seebelow@
#define ENOEXEC @\seebelow@
#define ENOLCK @\seebelow@
#define ENOLINK @\seebelow@
#define ENOMEM @\seebelow@
#define ENOMSG @\seebelow@
#define ENOPROTOOPT @\seebelow@
#define ENOSPC @\seebelow@
#define ENOSR @\seebelow@
#define ENOSTR @\seebelow@
#define ENOSYS @\seebelow@
#define ENOTCONN @\seebelow@
#define ENOTDIR @\seebelow@
#define ENOTEMPTY @\seebelow@
#define ENOTRECOVERABLE @\seebelow@
#define ENOTSOCK @\seebelow@
#define ENOTSUP @\seebelow@
#define ENOTTY @\seebelow@
#define ENXIO @\seebelow@
#define EOPNOTSUPP @\seebelow@
#define EOVERFLOW @\seebelow@
#define EOWNERDEAD @\seebelow@
#define EPERM @\seebelow@
#define EPIPE @\seebelow@
#define EPROTO @\seebelow@
#define EPROTONOSUPPORT @\seebelow@
#define EPROTOTYPE @\seebelow@
#define ERANGE @\seebelow@
#define EROFS @\seebelow@
#define ESPIPE @\seebelow@
#define ESRCH @\seebelow@
#define ETIME @\seebelow@
#define ETIMEDOUT @\seebelow@
#define ETXTBSY @\seebelow@
#define EWOULDBLOCK @\seebelow@
#define EXDEV @\seebelow@
\end{codeblock}

\pnum
The meaning of the macros in this header is defined by the POSIX standard.

\xrefc{7.5}

\rSec1[syserr]{System error support}

\rSec2[syserr.general]{General}

\pnum
Subclause \ref{syserr} describes components that the standard library and
\Cpp{} programs may use to report error conditions originating from
the operating system or other low-level application program interfaces.

\pnum
Components described in \ref{syserr} shall not change the value of
\tcode{errno}\iref{errno}.
Implementations should leave the error states provided by other
libraries unchanged.

\rSec2[system.error.syn]{Header \tcode{<system_error>} synopsis}

\indexheader{system_error}%
\indexlibraryglobal{error_category}%
\indexlibraryglobal{error_code}%
\indexlibraryglobal{error_condition}%
\indexlibraryglobal{system_error}%
\indexlibraryglobal{is_error_code_enum}%
\indexlibraryglobal{is_error_condition_enum}%
\indexlibraryglobal{errc}%
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}

namespace std {
  class error_category;
  const error_category& generic_category() noexcept;
  const error_category& system_category() noexcept;

  class error_code;
  class error_condition;
  class system_error;

  template<class T>
    struct is_error_code_enum : public false_type {};

  template<class T>
    struct is_error_condition_enum : public false_type {};

  enum class errc {
    address_family_not_supported,       // \tcode{EAFNOSUPPORT}
    address_in_use,                     // \tcode{EADDRINUSE}
    address_not_available,              // \tcode{EADDRNOTAVAIL}
    already_connected,                  // \tcode{EISCONN}
    argument_list_too_long,             // \tcode{E2BIG}
    argument_out_of_domain,             // \tcode{EDOM}
    bad_address,                        // \tcode{EFAULT}
    bad_file_descriptor,                // \tcode{EBADF}
    bad_message,                        // \tcode{EBADMSG}
    broken_pipe,                        // \tcode{EPIPE}
    connection_aborted,                 // \tcode{ECONNABORTED}
    connection_already_in_progress,     // \tcode{EALREADY}
    connection_refused,                 // \tcode{ECONNREFUSED}
    connection_reset,                   // \tcode{ECONNRESET}
    cross_device_link,                  // \tcode{EXDEV}
    destination_address_required,       // \tcode{EDESTADDRREQ}
    device_or_resource_busy,            // \tcode{EBUSY}
    directory_not_empty,                // \tcode{ENOTEMPTY}
    executable_format_error,            // \tcode{ENOEXEC}
    file_exists,                        // \tcode{EEXIST}
    file_too_large,                     // \tcode{EFBIG}
    filename_too_long,                  // \tcode{ENAMETOOLONG}
    function_not_supported,             // \tcode{ENOSYS}
    host_unreachable,                   // \tcode{EHOSTUNREACH}
    identifier_removed,                 // \tcode{EIDRM}
    illegal_byte_sequence,              // \tcode{EILSEQ}
    inappropriate_io_control_operation, // \tcode{ENOTTY}
    interrupted,                        // \tcode{EINTR}
    invalid_argument,                   // \tcode{EINVAL}
    invalid_seek,                       // \tcode{ESPIPE}
    io_error,                           // \tcode{EIO}
    is_a_directory,                     // \tcode{EISDIR}
    message_size,                       // \tcode{EMSGSIZE}
    network_down,                       // \tcode{ENETDOWN}
    network_reset,                      // \tcode{ENETRESET}
    network_unreachable,                // \tcode{ENETUNREACH}
    no_buffer_space,                    // \tcode{ENOBUFS}
    no_child_process,                   // \tcode{ECHILD}
    no_link,                            // \tcode{ENOLINK}
    no_lock_available,                  // \tcode{ENOLCK}
    no_message_available,               // \tcode{ENODATA}
    no_message,                         // \tcode{ENOMSG}
    no_protocol_option,                 // \tcode{ENOPROTOOPT}
    no_space_on_device,                 // \tcode{ENOSPC}
    no_stream_resources,                // \tcode{ENOSR}
    no_such_device_or_address,          // \tcode{ENXIO}
    no_such_device,                     // \tcode{ENODEV}
    no_such_file_or_directory,          // \tcode{ENOENT}
    no_such_process,                    // \tcode{ESRCH}
    not_a_directory,                    // \tcode{ENOTDIR}
    not_a_socket,                       // \tcode{ENOTSOCK}
    not_a_stream,                       // \tcode{ENOSTR}
    not_connected,                      // \tcode{ENOTCONN}
    not_enough_memory,                  // \tcode{ENOMEM}
    not_supported,                      // \tcode{ENOTSUP}
    operation_canceled,                 // \tcode{ECANCELED}
    operation_in_progress,              // \tcode{EINPROGRESS}
    operation_not_permitted,            // \tcode{EPERM}
    operation_not_supported,            // \tcode{EOPNOTSUPP}
    operation_would_block,              // \tcode{EWOULDBLOCK}
    owner_dead,                         // \tcode{EOWNERDEAD}
    permission_denied,                  // \tcode{EACCES}
    protocol_error,                     // \tcode{EPROTO}
    protocol_not_supported,             // \tcode{EPROTONOSUPPORT}
    read_only_file_system,              // \tcode{EROFS}
    resource_deadlock_would_occur,      // \tcode{EDEADLK}
    resource_unavailable_try_again,     // \tcode{EAGAIN}
    result_out_of_range,                // \tcode{ERANGE}
    state_not_recoverable,              // \tcode{ENOTRECOVERABLE}
    stream_timeout,                     // \tcode{ETIME}
    text_file_busy,                     // \tcode{ETXTBSY}
    timed_out,                          // \tcode{ETIMEDOUT}
    too_many_files_open_in_system,      // \tcode{ENFILE}
    too_many_files_open,                // \tcode{EMFILE}
    too_many_links,                     // \tcode{EMLINK}
    too_many_symbolic_link_levels,      // \tcode{ELOOP}
    value_too_large,                    // \tcode{EOVERFLOW}
    wrong_protocol_type,                // \tcode{EPROTOTYPE}
  };

  template<> struct is_error_condition_enum<errc> : true_type {};

  // \ref{syserr.errcode.nonmembers}, non-member functions
  error_code make_error_code(errc e) noexcept;

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const error_code& ec);

  // \ref{syserr.errcondition.nonmembers}, non-member functions
  error_condition make_error_condition(errc e) noexcept;

  // \ref{syserr.compare}, comparison operator functions
  bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
  bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
  bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
  strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
  strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;

  // \ref{syserr.hash}, hash support
  template<class T> struct hash;
  template<> struct hash<error_code>;
  template<> struct hash<error_condition>;

  // \ref{syserr}, system error support
  template<class T>
    inline constexpr bool is_error_code_enum_v = is_error_code_enum<T>::value;
  template<class T>
    inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<T>::value;
}
\end{codeblock}

\pnum
The value of each \tcode{enum errc} constant shall be the same as
the value of the \libheader{cerrno} macro shown in the above synopsis.
Whether or not the \libheader{system_error} implementation
exposes the \libheader{cerrno} macros is unspecified.

\pnum
The \tcode{is_error_code_enum} and \tcode{is_error_condition_enum} templates may be
specialized for program-defined types to indicate that such types are eligible
for \tcode{class error_code} and \tcode{class error_condition} implicit
conversions, respectively.

\rSec2[syserr.errcat]{Class \tcode{error_category}}

\rSec3[syserr.errcat.overview]{Overview}

\pnum
The class \tcode{error_category} serves as a base class for types used
to identify the source and encoding of a particular category of error code.
Classes may be derived from \tcode{error_category} to support
categories of errors in addition to those defined in this document.
Such classes shall behave as specified in subclause~\ref{syserr.errcat}.
\begin{note}
\tcode{error_category} objects are
passed by reference, and two such objects
are equal if they have the same address.
If there is more than a single object of a custom \tcode{error_category} type,
such equality comparisons can evaluate to \tcode{false}
even for objects holding the same value.
\end{note}

\indexlibraryglobal{error_category}%
\indexlibraryctor{error_category}%
\indexlibrarydtor{error_category}%
\indexlibraryglobal{generic_category}%
\indexlibraryglobal{system_category}%
\begin{codeblock}
namespace std {
  class error_category {
  public:
    constexpr error_category() noexcept;
    virtual ~error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    strong_ordering operator<=>(const error_category& rhs) const noexcept;
  };

  const error_category& generic_category() noexcept;
  const error_category& system_category() noexcept;
}
\end{codeblock}

\rSec3[syserr.errcat.virtuals]{Virtual members}

\indexlibrarymember{name}{error_category}%
\begin{itemdecl}
virtual const char* name() const noexcept = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string naming the error category.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_category}%
\begin{itemdecl}
virtual error_condition default_error_condition(int ev) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_condition(ev, *this)}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{default_error_condition(code) == condition}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(const error_code& code, int condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this == code.category() \&\& code.value() == condition}.
\end{itemdescr}

\indexlibrarymember{message}{error_category}%
\begin{itemdecl}
virtual string message(int ev) const = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string that describes the error condition denoted by \tcode{ev}.
\end{itemdescr}

\rSec3[syserr.errcat.nonvirtuals]{Non-virtual members}

\indexlibrarymember{operator==}{error_category}%
\begin{itemdecl}
bool operator==(const error_category& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{this == \&rhs}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_category}%
\begin{itemdecl}
strong_ordering operator<=>(const error_category& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{compare_three_way()(this, \&rhs)}.

\begin{note}
\tcode{compare_three_way}\iref{comparisons.three.way} provides a total ordering for pointers.
\end{note}
\end{itemdescr}

\rSec3[syserr.errcat.derived]{Program-defined classes derived from \tcode{error_category}}

\indexlibrarymember{name}{error_category}%
\begin{itemdecl}
virtual const char* name() const noexcept = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string naming the error category.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_category}%
\begin{itemdecl}
virtual error_condition default_error_condition(int ev) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object of type \tcode{error_condition} that corresponds to \tcode{ev}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if, for the category of error represented by \tcode{*this}, \tcode{code} is considered equivalent to \tcode{condition}; otherwise, \tcode{false}.
\end{itemdescr}

\indexlibrarymember{equivalent}{error_category}%
\begin{itemdecl}
virtual bool equivalent(const error_code& code, int condition) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if, for the category of error represented by \tcode{*this}, \tcode{code} is considered equivalent to \tcode{condition}; otherwise, \tcode{false}.
\end{itemdescr}

\rSec3[syserr.errcat.objects]{Error category objects}

\indexlibraryglobal{generic_category}%
\begin{itemdecl}
const error_category& generic_category() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to an object of a type derived from class \tcode{error_category}.
All calls to this function shall return references to the same object.

\pnum
\remarks
The object's \tcode{default_error_condition} and \tcode{equivalent} virtual functions shall behave as specified for the class \tcode{error_category}. The object's \tcode{name} virtual function shall return a pointer to the string \tcode{"generic"}.
\end{itemdescr}

\indexlibraryglobal{system_category}%
\begin{itemdecl}
const error_category& system_category() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to an object of a type derived from class \tcode{error_category}.
All calls to this function shall return references to the same object.

\pnum
\remarks
The object's \tcode{equivalent} virtual functions shall behave as specified for
class \tcode{error_category}. The object's \tcode{name} virtual function shall return a
pointer to the string \tcode{"system"}. The object's \tcode{default_error_condition}
virtual function shall behave as follows:

If the argument \tcode{ev} is equal to 0,
the function returns \tcode{error_condition(0, generic_category())}.
Otherwise,
if \tcode{ev} corresponds to a POSIX \tcode{errno} value \tcode{pxv},
the function returns \tcode{error_condition(pxv, generic_category())}.
Otherwise, the function returns \tcode{error_condition(ev, system_category())}.
What constitutes correspondence for any given operating system is unspecified.
\begin{note}
The number of potential system error codes is large
and unbounded, and some might not correspond to any POSIX \tcode{errno} value. Thus
implementations are given latitude in determining correspondence.
\end{note}
\end{itemdescr}

\rSec2[syserr.errcode]{Class \tcode{error_code}}

\rSec3[syserr.errcode.overview]{Overview}

\pnum
The class \tcode{error_code} describes an object used to hold error code
values, such as those originating from the operating system or other low-level
application program interfaces.
\begin{note}
Class \tcode{error_code} is an
adjunct to error reporting by exception.
\end{note}

\indexlibraryglobal{error_code}%
\begin{codeblock}
namespace std {
  class error_code {
  public:
    // \ref{syserr.errcode.constructors}, constructors
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
      error_code(ErrorCodeEnum e) noexcept;

    // \ref{syserr.errcode.modifiers}, modifiers
    void assign(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
      error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // \ref{syserr.errcode.observers}, observers
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;

  private:
    int val_;                   // \expos
    const error_category* cat_; // \expos
  };

  // \ref{syserr.errcode.nonmembers}, non-member functions
  error_code make_error_code(errc e) noexcept;

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
}
\end{codeblock}

\rSec3[syserr.errcode.constructors]{Constructors}

\indexlibraryctor{error_code}%
\begin{itemdecl}
error_code() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == 0} and \tcode{cat_ == \&system_category()}.
\end{itemdescr}

\indexlibraryctor{error_code}%
\begin{itemdecl}
error_code(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibraryctor{error_code}%
\begin{itemdecl}
template<class ErrorCodeEnum>
  error_code(ErrorCodeEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_code_enum_v<ErrorCodeEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_code(e)}.
\end{itemdescr}

\rSec3[syserr.errcode.modifiers]{Modifiers}

\indexlibrarymember{assign}{error_code}%
\begin{itemdecl}
void assign(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibrarymember{operator=}{error_code}%
\begin{itemdecl}
template<class ErrorCodeEnum>
  error_code& operator=(ErrorCodeEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_code_enum_v<ErrorCodeEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_code(e)}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{clear}{error_code}%
\begin{itemdecl}
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{value() == 0} and \tcode{category() == system_category()}.
\end{itemdescr}


\rSec3[syserr.errcode.observers]{Observers}

\indexlibrarymember{value}{error_code}%
\begin{itemdecl}
int value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{val_}.
\end{itemdescr}

\indexlibrarymember{category}{error_code}%
\begin{itemdecl}
const error_category& category() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*cat_}.
\end{itemdescr}

\indexlibrarymember{default_error_condition}{error_code}%
\begin{itemdecl}
error_condition default_error_condition() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().default_error_condition(value())}.
\end{itemdescr}

\indexlibrarymember{message}{error_code}%
\begin{itemdecl}
string message() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().message(value())}.
\end{itemdescr}

\indexlibrarymember{operator bool}{error_code}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{value() != 0}.
\end{itemdescr}

\rSec3[syserr.errcode.nonmembers]{Non-member functions}

\indexlibrarymember{make_error_code}{errc}%
\begin{itemdecl}
error_code make_error_code(errc e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_code(static_cast<int>(e), generic_category())}.
\end{itemdescr}

\indexlibrarymember{operator<<}{error_code}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return os << ec.category().name() << ':' << ec.value();}
\end{itemdescr}


\rSec2[syserr.errcondition]{Class \tcode{error_condition}}

\rSec3[syserr.errcondition.overview]{Overview}

\pnum
The class \tcode{error_condition} describes an object used to hold values identifying
error conditions.
\begin{note}
\tcode{error_condition} values are portable abstractions,
while \tcode{error_code} values\iref{syserr.errcode} are implementation specific.
\end{note}

\indexlibraryglobal{error_condition}%
\begin{codeblock}
namespace std {
  class error_condition {
  public:
    // \ref{syserr.errcondition.constructors}, constructors
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template<class ErrorConditionEnum>
      error_condition(ErrorConditionEnum e) noexcept;

    // \ref{syserr.errcondition.modifiers}, modifiers
    void assign(int val, const error_category& cat) noexcept;
    template<class ErrorConditionEnum>
      error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // \ref{syserr.errcondition.observers}, observers
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;

  private:
    int val_;                   // \expos
    const error_category* cat_; // \expos
  };
}
\end{codeblock}

\rSec3[syserr.errcondition.constructors]{Constructors}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
error_condition() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == 0} and \tcode{cat_ == \&generic_category()}.
\end{itemdescr}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
error_condition(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibraryctor{error_condition}%
\begin{itemdecl}
template<class ErrorConditionEnum>
  error_condition(ErrorConditionEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_condition_enum_v<ErrorConditionEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_condition(e)}.
\end{itemdescr}


\rSec3[syserr.errcondition.modifiers]{Modifiers}

\indexlibrarymember{assign}{error_condition}%
\begin{itemdecl}
void assign(int val, const error_category& cat) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{val_ == val} and \tcode{cat_ == \&cat}.
\end{itemdescr}

\indexlibrarymember{operator=}{error_condition}%
\begin{itemdecl}
template<class ErrorConditionEnum>
  error_condition& operator=(ErrorConditionEnum e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_error_condition_enum_v<ErrorConditionEnum>} is \tcode{true}.

\pnum
\ensures
\tcode{*this == make_error_condition(e)}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{clear}{error_condition}%
\begin{itemdecl}
void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{value() == 0} and \tcode{category() == generic_category()}.
\end{itemdescr}

\rSec3[syserr.errcondition.observers]{Observers}

\indexlibrarymember{value}{error_condition}%
\begin{itemdecl}
int value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{val_}.
\end{itemdescr}

\indexlibrarymember{category}{error_condition}%
\begin{itemdecl}
const error_category& category() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*cat_}.
\end{itemdescr}

\indexlibrarymember{message}{error_condition}%
\begin{itemdecl}
string message() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{category().message(value())}.
\end{itemdescr}

\indexlibrarymember{operator bool}{error_condition}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{value() != 0}.
\end{itemdescr}

\rSec3[syserr.errcondition.nonmembers]{Non-member functions}

\indexlibrarymember{make_error_condition}{errc}%
\begin{itemdecl}
error_condition make_error_condition(errc e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{error_condition(static_cast<int>(e), generic_category())}.
\end{itemdescr}

\rSec2[syserr.compare]{Comparison operator functions}

\indexlibrarymember{operator==}{error_code}%
\begin{itemdecl}
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category() == rhs.category() && lhs.value() == rhs.value()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{error_condition}%
\indexlibrarymember{operator==}{error_code}%
\begin{itemdecl}
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs, rhs.value())
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{error_condition}%
\begin{itemdecl}
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.category() == rhs.category() && lhs.value() == rhs.value()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_code}%
\begin{itemdecl}
strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator<=>}{error_condition}%
\begin{itemdecl}
strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
\end{codeblock}
\end{itemdescr}

\rSec2[syserr.hash]{System error hash support}

\indexlibrarymember{hash}{error_code}%
\begin{itemdecl}
template<> struct hash<error_code>;
template<> struct hash<error_condition>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specializations are enabled\iref{unord.hash}.
\end{itemdescr}

\rSec2[syserr.syserr]{Class \tcode{system_error}}

\rSec3[syserr.syserr.overview]{Overview}

\pnum
The class \tcode{system_error} describes an exception object used to
report error conditions that have an associated error code. Such error
conditions typically originate from the operating system or other low-level
application program interfaces.

\pnum
\begin{note}
If an error represents an out-of-memory condition, implementations are
encouraged to throw an exception object of type \tcode{bad_alloc}\iref{bad.alloc} rather
than \tcode{system_error}.
\end{note}
\indexlibraryglobal{system_error}%
\begin{codeblock}
namespace std {
  class system_error : public runtime_error {
  public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);
    const error_code& code() const noexcept;
    const char* what() const noexcept override;
  };
}
\end{codeblock}

\rSec3[syserr.syserr.members]{Members}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec, const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec} and\newline
\tcode{string_view(what()).find(what_arg.c_str()) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec} and
\tcode{string_view(what()).find(what_arg) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == ec}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat, const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string_view(what()).find(what_arg.c_str()) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string_view(what()).find(what_arg) != string_view::npos}.
\end{itemdescr}

\indexlibraryctor{system_error}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{code() == error_code(ev, ecat)}.
\end{itemdescr}

\indexlibrarymember{code}{system_error}%
\begin{itemdecl}
const error_code& code() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ec} or \tcode{error_code(ev, ecat)}, from the constructor,
as appropriate.
\end{itemdescr}

\indexlibrarymember{what}{system_error}%
\begin{itemdecl}
const char* what() const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \ntbs{} incorporating the arguments supplied in the constructor.

\begin{note}
The returned \ntbs{} might be the contents of \tcode{what_arg + ": " +
code.message()}.
\end{note}
\end{itemdescr}

\rSec1[stacktrace]{Stacktrace}

\rSec2[stacktrace.general]{General}

\pnum
Subclause \ref{stacktrace} describes components
that \Cpp{} programs may use to store
the stacktrace of the current thread of execution and
query information about the stored stacktrace at runtime.

\pnum
The \defn{invocation sequence} of the current evaluation $x_0$
in the current thread of execution
is a sequence $(x_0, \ldots, x_n)$ of evaluations such that, for $i \geq 0$,
$x_i$ is within the function invocation $x_{i+1}$\iref{intro.execution}.

\pnum
A \defn{stacktrace} is an approximate representation of
an invocation sequence and consists of stacktrace entries.
A \defn{stacktrace entry} represents an evaluation in a stacktrace.

\rSec2[stacktrace.syn]{Header \tcode{<stacktrace>} synopsis}

\indexheader{stacktrace}%
\begin{codeblock}
namespace std {
  // \ref{stacktrace.entry}, class \tcode{stacktrace_entry}
  class stacktrace_entry;

  // \ref{stacktrace.basic}, class template \tcode{basic_stacktrace}
  template<class Allocator>
    class basic_stacktrace;

  // \tcode{basic_stacktrace} \grammarterm{typedef-name}s
  using stacktrace = basic_stacktrace<allocator<stacktrace_entry>>;

  // \ref{stacktrace.basic.nonmem}, non-member functions
  template<class Allocator>
    void swap(basic_stacktrace<Allocator>& a, basic_stacktrace<Allocator>& b)
      noexcept(noexcept(a.swap(b)));

  string to_string(const stacktrace_entry& f);

  template<class Allocator>
    string to_string(const basic_stacktrace<Allocator>& st);

  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const stacktrace_entry& f);

  template<class charT, class traits, class Allocator>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const basic_stacktrace<Allocator>& st);

  namespace pmr {
    using stacktrace = basic_stacktrace<polymorphic_allocator<stacktrace_entry>>;
  }

  // \ref{stacktrace.basic.hash}, hash support
  template<class T> struct hash;
  template<> struct hash<stacktrace_entry>;
  template<class Allocator> struct hash<basic_stacktrace<Allocator>>;
}
\end{codeblock}

\rSec2[stacktrace.entry]{Class \tcode{stacktrace_entry}}

\rSec3[stacktrace.entry.overview]{Overview}

\begin{codeblock}
namespace std {
  class @\libglobal{stacktrace_entry}@ {
  public:
    using native_handle_type = @\impdefx{\tcode{stacktrace_entry::native_handle_type}}@;

    // \ref{stacktrace.entry.ctor}, constructors
    constexpr stacktrace_entry() noexcept;
    constexpr stacktrace_entry(const stacktrace_entry& other) noexcept;
    constexpr stacktrace_entry& operator=(const stacktrace_entry& other) noexcept;

    ~stacktrace_entry();

    // \ref{stacktrace.entry.obs}, observers
    constexpr native_handle_type native_handle() const noexcept;
    constexpr explicit operator bool() const noexcept;

    // \ref{stacktrace.entry.query}, query
    string description() const;
    string source_file() const;
    uint_least32_t source_line() const;

    // \ref{stacktrace.entry.cmp}, comparison
    friend constexpr bool operator==(const stacktrace_entry& x,
                                     const stacktrace_entry& y) noexcept;
    friend constexpr strong_ordering operator<=>(const stacktrace_entry& x,
                                                 const stacktrace_entry& y) noexcept;
  };
}
\end{codeblock}

\pnum
An object of type \tcode{stacktrace_entry} is either empty,
or represents a stacktrace entry and
provides operations for querying information about it.
The class \tcode{stacktrace_entry} models
\libconcept{regular}\iref{concepts.object} and
\tcode{\libconcept{three_way_comparable}<strong_ordering>}\iref{cmp.concept}.

\rSec3[stacktrace.entry.ctor]{Constructors}

\indexlibraryctor{stacktrace_entry}%
\begin{itemdecl}
constexpr stacktrace_entry() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} is empty.
\end{itemdescr}

\rSec3[stacktrace.entry.obs]{Observers}

\indexlibrarymember{native_handle}{stacktrace_entry}%
\begin{itemdecl}
constexpr native_handle_type native_handle() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The semantics of this function are
\impldef{semantics of \tcode{stacktrace_entry::native_handle}}.

\pnum
\remarks
Successive invocations of the \tcode{native_handle} function
for an unchanged \tcode{stacktrace_entry} object return identical values.
\end{itemdescr}

\indexlibrarymember{operator bool}{stacktrace_entry}%
\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false} if and only if \tcode{*this} is empty.
\end{itemdescr}

\rSec3[stacktrace.entry.query]{Query}

\pnum
\begin{note}
All the \tcode{stacktrace_entry} query functions treat
errors other than memory allocation errors
as ``no information available'' and do not throw in that case.
\end{note}

\indexlibrarymember{description}{stacktrace_entry}%
\begin{itemdecl}
string description() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A description of the evaluation represented by \tcode{*this},
or an empty string.

\pnum
\throws
\tcode{bad_alloc} if memory for
the internal data structures or the resulting string cannot be allocated.
\end{itemdescr}

\indexlibrarymember{source_file}{stacktrace_entry}%
\begin{itemdecl}
string source_file() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The presumed or actual name of the source file\iref{cpp.predefined}
that lexically contains the expression or statement
whose evaluation is represented by \tcode{*this}, or an empty string.

\pnum
\throws
\tcode{bad_alloc} if memory for
the internal data structures or the resulting string cannot be allocated.
\end{itemdescr}

\indexlibrarymember{source_line}{stacktrace_entry}%
\begin{itemdecl}
uint_least32_t source_line() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{0}, or a 1-based line number that lexically relates to the evaluation
represented by \tcode{*this}.
If \tcode{source_file} returns the presumed name of the source file,
returns the presumed line number;
if \tcode{source_file} returns the actual name of the source file,
returns the actual line number.

\pnum
\throws
\tcode{bad_alloc} if memory for
the internal data structures cannot be allocated.
\end{itemdescr}

\rSec3[stacktrace.entry.cmp]{Comparison}

\indexlibrarymember{operator==}{stacktrace_entry}%
\begin{itemdecl}
friend constexpr bool operator==(const stacktrace_entry& x, const stacktrace_entry& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if and only if \tcode{x} and \tcode{y} represent
the same stacktrace entry or both \tcode{x} and \tcode{y} are empty.
\end{itemdescr}

\rSec2[stacktrace.basic]{Class template \tcode{basic_stacktrace}}

\rSec3[stacktrace.basic.overview]{Overview}

\begin{codeblock}
namespace std {
  template<class Allocator>
  class @\libglobal{basic_stacktrace}@ {
  public:
    using value_type = stacktrace_entry;
    using const_reference = const value_type&;
    using reference = value_type&;
    using const_iterator = @\impdefx{type of \tcode{basic_stacktrace::const_iterator}}@;  // see \ref{stacktrace.basic.obs}
    using iterator = const_iterator;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using difference_type = @\impdefx{type of \tcode{basic_stacktrace::difference_type}}@;
    using size_type = @\impdefx{type of \tcode{basic_stacktrace::size_type}}@;
    using allocator_type = Allocator;

    // \ref{stacktrace.basic.ctor}, creation and assignment
    static basic_stacktrace current(const allocator_type& alloc = allocator_type()) noexcept;
    static basic_stacktrace current(size_type skip,
                                    const allocator_type& alloc = allocator_type()) noexcept;
    static basic_stacktrace current(size_type skip, size_type max_depth,
                                    const allocator_type& alloc = allocator_type()) noexcept;

    basic_stacktrace() noexcept(is_nothrow_default_constructible_v<allocator_type>);
    explicit basic_stacktrace(const allocator_type& alloc) noexcept;

    basic_stacktrace(const basic_stacktrace& other);
    basic_stacktrace(basic_stacktrace&& other) noexcept;
    basic_stacktrace(const basic_stacktrace& other, const allocator_type& alloc);
    basic_stacktrace(basic_stacktrace&& other, const allocator_type& alloc);
    basic_stacktrace& operator=(const basic_stacktrace& other);
    basic_stacktrace& operator=(basic_stacktrace&& other)
      noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
        allocator_traits<Allocator>::is_always_equal::value);

    ~basic_stacktrace();

    // \ref{stacktrace.basic.obs}, observers
    allocator_type get_allocator() const noexcept;

    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    const_reference operator[](size_type) const;
    const_reference at(size_type) const;

    // \ref{stacktrace.basic.cmp}, comparisons
    template<class Allocator2>
    friend bool operator==(const basic_stacktrace& x,
                           const basic_stacktrace<Allocator2>& y) noexcept;
    template<class Allocator2>
    friend strong_ordering operator<=>(const basic_stacktrace& x,
                                       const basic_stacktrace<Allocator2>& y) noexcept;

    // \ref{stacktrace.basic.mod}, modifiers
    void swap(basic_stacktrace& other)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
        allocator_traits<Allocator>::is_always_equal::value);

  private:
    vector<value_type, allocator_type> frames_;         // \expos
  };
}
\end{codeblock}

\pnum
The class template \tcode{basic_stacktrace} satisfies
the requirements
of a reversible container\iref{container.rev.reqmts},
of an allocator-aware container\iref{container.alloc.reqmts}, and
of a sequence container\iref{sequence.reqmts},
except that
\begin{itemize}
\item
only move, assignment, swap, and
operations defined for const-qualified sequence containers are supported and,
\item
the semantics of comparison functions
are different from those required for a container.
\end{itemize}

\rSec3[stacktrace.basic.ctor]{Creation and assignment}

\indexlibrarymember{current}{basic_stacktrace}%
\begin{itemdecl}
static basic_stacktrace current(const allocator_type& alloc = allocator_type()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{basic_stacktrace} object
with \tcode{frames_} storing
the stacktrace of the current evaluation in the current thread of execution, or
an empty \tcode{basic_stacktrace} object
if the initialization of \tcode{frames_} failed.
\tcode{alloc} is passed to the constructor of the \tcode{frames_} object.

\begin{note}
If the stacktrace was successfully obtained,
then \tcode{frames_.front()} is the \tcode{stacktrace_entry}
representing approximately the current evaluation, and
\tcode{frames_.back()} is the \tcode{stacktrace_entry}
representing approximately the initial function of
the current thread of execution.
\end{note}
\end{itemdescr}

\indexlibrarymember{current}{basic_stacktrace}%
\begin{itemdecl}
static basic_stacktrace current(size_type skip,
                                const allocator_type& alloc = allocator_type()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{t} be a stacktrace
as-if obtained via \tcode{basic_stacktrace::current(alloc)}.
Let \tcode{n} be \tcode{t.size()}.

\pnum
\returns
A \tcode{basic_stacktrace} object
where \tcode{frames_} is direct-non-list-initialized from arguments
\tcode{t.begin() + min(n, skip)}, \tcode{t.end()}, and \tcode{alloc},
or an empty \tcode{basic_stacktrace} object
if the initialization of \tcode{frames_} failed.
\end{itemdescr}

\indexlibrarymember{current}{basic_stacktrace}%
\begin{itemdecl}
static basic_stacktrace current(size_type skip, size_type max_depth,
                                const allocator_type& alloc = allocator_type()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{t} be a stacktrace
as-if obtained via \tcode{basic_stacktrace::current(alloc)}.
Let \tcode{n} be \tcode{t.size()}.

\pnum
\expects
\tcode{skip <= skip + max_depth} is \tcode{true}.

\pnum
\returns
A \tcode{basic_stacktrace} object
where \tcode{frames_} is direct-non-list-initialized from arguments
\tcode{t.begin() + min(n, skip)}, \tcode{t.begin() + min(n, skip + max_depth)},
and \tcode{alloc},
or an empty \tcode{basic_stacktrace} object
if the initialization of \tcode{frames_} failed.
\end{itemdescr}

\indexlibraryctor{basic_stacktrace}%
\begin{itemdecl}
basic_stacktrace() noexcept(is_nothrow_default_constructible_v<allocator_type>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{empty()} is \tcode{true}.
\end{itemdescr}

\indexlibraryctor{basic_stacktrace}%
\begin{itemdecl}
explicit basic_stacktrace(const allocator_type& alloc) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{alloc} is passed to the \tcode{frames_} constructor.

\pnum
\ensures
\tcode{empty()} is \tcode{true}.
\end{itemdescr}

\indexlibraryctor{basic_stacktrace}%
\indexlibrarymember{operator=}{basic_stacktrace}%
\begin{itemdecl}
basic_stacktrace(const basic_stacktrace& other);
basic_stacktrace(const basic_stacktrace& other, const allocator_type& alloc);
basic_stacktrace(basic_stacktrace&& other, const allocator_type& alloc);
basic_stacktrace& operator=(const basic_stacktrace& other);
basic_stacktrace& operator=(basic_stacktrace&& other)
  noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
    allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Implementations may strengthen the exception specification
for these functions\iref{res.on.exception.handling}
by ensuring that \tcode{empty()} is \tcode{true} on failed allocation.
\end{itemdescr}

\rSec3[stacktrace.basic.obs]{Observers}

\indexlibrarymember{const_iterator}{basic_stacktrace}%
\begin{itemdecl}
using const_iterator = @\impdef@;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type models
\libconcept{random_access_iterator}\iref{iterator.concept.random.access} and
meets the
\oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}.
\end{itemdescr}

\indexlibrarymember{get_allocator}{basic_stacktrace}%
\begin{itemdecl}
allocator_type get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{frames_.get_allocator()}.
\end{itemdescr}

\indexlibrarymember{begin}{basic_stacktrace}%
\indexlibrarymember{cbegin}{basic_stacktrace}%
\begin{itemdecl}
const_iterator begin() const noexcept;
const_iterator cbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referring to the first element in \tcode{frames_}.
If \tcode{empty()} is \tcode{true},
then it returns the same value as \tcode{end()}.
\end{itemdescr}

\indexlibrarymember{end}{basic_stacktrace}%
\indexlibrarymember{cend}{basic_stacktrace}%
\begin{itemdecl}
const_iterator end() const noexcept;
const_iterator cend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The end iterator.
\end{itemdescr}

\indexlibrarymember{rbegin}{basic_stacktrace}%
\indexlibrarymember{crbegin}{basic_stacktrace}%
\begin{itemdecl}
const_reverse_iterator rbegin() const noexcept;
const_reverse_iterator crbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator(cend())}.
\end{itemdescr}

\indexlibrarymember{rend}{basic_stacktrace}%
\indexlibrarymember{crend}{basic_stacktrace}%
\begin{itemdecl}
const_reverse_iterator rend() const noexcept;
const_reverse_iterator crend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator(cbegin())}.
\end{itemdescr}

\indexlibrarymember{empty}{basic_stacktrace}%
\begin{itemdecl}
[[nodiscard]] bool empty() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{frames_.empty()}.
\end{itemdescr}

\indexlibrarymember{size}{basic_stacktrace}%
\begin{itemdecl}
size_type size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{frames_.size()}.
\end{itemdescr}

\indexlibrarymember{max_size}{basic_stacktrace}%
\begin{itemdecl}
size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{frames_.max_size()}.
\end{itemdescr}

\indexlibrarymember{operator[]}{basic_stacktrace}%
\begin{itemdecl}
const_reference operator[](size_type frame_no) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{frame_no < size()} is \tcode{true}.

\pnum
\returns
\tcode{frames_[frame_no]}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{at}{basic_stacktrace}%
\begin{itemdecl}
const_reference at(size_type frame_no) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{frames_[frame_no]}.

\pnum
\throws
\tcode{out_of_range} if \tcode{frame_no >= size()}.
\end{itemdescr}

\rSec3[stacktrace.basic.cmp]{Comparisons}

\indexlibrarymember{operator==}{basic_stacktrace}%
\begin{itemdecl}
template<class Allocator2>
friend bool operator==(const basic_stacktrace& x, const basic_stacktrace<Allocator2>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{equal(x.begin(), x.end(), y.begin(), y.end())}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{basic_stacktrace}%
\begin{itemdecl}
template<class Allocator2>
friend strong_ordering
  operator<=>(const basic_stacktrace& x, const basic_stacktrace<Allocator2>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.size() <=> y.size()} if \tcode{x.size() != y.size()};
\tcode{lexicographical_compare_three_way(x.begin(), x.end(), y.begin(), y.end())}
otherwise.
\end{itemdescr}

\rSec3[stacktrace.basic.mod]{Modifiers}

\indexlibrarymember{swap}{basic_stacktrace}%
\begin{itemdecl}
void swap(basic_stacktrace& other)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
    allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Exchanges the contents of \tcode{*this} and \tcode{other}.
\end{itemdescr}

\rSec3[stacktrace.basic.nonmem]{Non-member functions}

\indexlibrarymember{swap}{basic_stacktrace}%
\begin{itemdecl}
template<class Allocator>
void swap(basic_stacktrace<Allocator>& a, basic_stacktrace<Allocator>& b)
  noexcept(noexcept(a.swap(b)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{a.swap(b)}.
\end{itemdescr}

\indexlibrarymember{to_string}{basic_stacktrace}%
\begin{itemdecl}
string to_string(const stacktrace_entry& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string with a description of \tcode{f}.

\recommended
The description should provide information about the contained evaluation,
including information from
\tcode{f.source_file()} and \tcode{f.source_line()}.
\end{itemdescr}

\indexlibrarymember{to_string}{basic_stacktrace}%
\begin{itemdecl}
template<class Allocator>
string to_string(const basic_stacktrace<Allocator>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string with a description of \tcode{st}.
\begin{note}
The number of lines is not guaranteed to be equal to \tcode{st.size()}.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator<<}{stacktrace_entry}%
\begin{itemdecl}
template<class charT, class traits>
basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>& os, const stacktrace_entry& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return os << to_string(f);}
\end{itemdescr}

\indexlibrarymember{operator<<}{basic_stacktrace}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>& os, const basic_stacktrace<Allocator>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return os << to_string(st);}
\end{itemdescr}

\rSec3[stacktrace.basic.hash]{Hash support}

\begin{itemdecl}
template<> struct hash<stacktrace_entry>;
template<class Allocator> struct hash<basic_stacktrace<Allocator>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specializations are enabled\iref{unord.hash}.
\end{itemdescr}
