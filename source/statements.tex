%!TEX root = std.tex
\rSec0[stmt]{Statements}%
\indextext{statement|(}

\gramSec[gram.stmt]{Statements}

\indextext{block (statement)|see{statement, compound}}

\rSec1[stmt.pre]{Preamble}

\pnum
Except as indicated, statements are executed in sequence\iref{intro.execution}.

\begin{bnf}
\nontermdef{statement}\br
    labeled-statement\br
    \opt{attribute-specifier-seq} expression-statement\br
    \opt{attribute-specifier-seq} compound-statement\br
    \opt{attribute-specifier-seq} selection-statement\br
    \opt{attribute-specifier-seq} iteration-statement\br
    \opt{attribute-specifier-seq} jump-statement\br
    \opt{attribute-specifier-seq} try-block\br
    declaration-statement
\end{bnf}

\begin{bnf}
\nontermdef{init-statement}\br
    expression-statement\br
    simple-declaration\br
    alias-declaration
\end{bnf}

\begin{bnf}
\nontermdef{condition}\br
    expression\br
    \opt{attribute-specifier-seq} decl-specifier-seq declarator brace-or-equal-initializer\br
    structured-binding-declaration initializer
\end{bnf}

The optional \grammarterm{attribute-specifier-seq} appertains to the respective statement.

\pnum
A \defn{substatement} of a \grammarterm{statement} is one of the following:
\begin{itemize}
\item
  for a \grammarterm{labeled-statement}, its \grammarterm{statement},
\item
  for a \grammarterm{compound-statement}, any \grammarterm{statement} of its \grammarterm{statement-seq},
\item
  for a \grammarterm{selection-statement}, any of its \grammarterm{statement}{s} or \grammarterm{compound-statement}{s} (but not its \grammarterm{init-statement}), or
\item
  for an \grammarterm{iteration-statement}, its \grammarterm{statement} (but not an \grammarterm{init-statement}).
\end{itemize}
\begin{note}
The \grammarterm{compound-statement} of a \grammarterm{lambda-expression}
is not a substatement of the \grammarterm{statement} (if any)
in which the \grammarterm{lambda-expression} lexically appears.
\end{note}

\pnum
\indextext{statement!enclosing}%
A \grammarterm{statement} \tcode{S1} \defnx{encloses}{enclosing statement}
a \grammarterm{statement} \tcode{S2} if
\begin{itemize}
\item
  \tcode{S2} is a substatement of \tcode{S1},
\item
  \tcode{S1} is a \grammarterm{selection-statement} or
  \grammarterm{iteration-statement} and
  \tcode{S2} is the \grammarterm{init-statement} of \tcode{S1},
\item
  \tcode{S1} is a \grammarterm{try-block} and \tcode{S2}
  is its \grammarterm{compound-statement} or
  any of the \grammarterm{compound-statement}{s} of
  its \grammarterm{handler}{s}, or
\item
  \tcode{S1} encloses a statement \tcode{S3} and \tcode{S3} encloses \tcode{S2}.
\end{itemize}
\indextext{statement!enclosed by}%
A statement \tcode{S1} is
\defnx{enclosed by}{enclosed by statement}
a statement \tcode{S2} if
\tcode{S2} encloses \tcode{S1}.

\pnum
\indextext{\idxgram{condition}{s}!rules for}%
The rules for \grammarterm{condition}{s} apply both
to \grammarterm{selection-statement}{s}\iref{stmt.select} and
to the \keyword{for} and \keyword{while} statements\iref{stmt.iter}.
If a \grammarterm{structured-binding-declaration}
appears in a \grammarterm{condition},
the \grammarterm{condition} is a structured binding declaration\iref{dcl.pre}.
A \grammarterm{condition} that is
neither an \grammarterm{expression} nor a structured binding declaration
is a declaration\iref{dcl}.
The \grammarterm{declarator} shall not
specify a function or an array. The \grammarterm{decl-specifier-seq} shall not
define a class or enumeration. If the \keyword{auto} \grammarterm{type-specifier} appears in
the \grammarterm{decl-specifier-seq},
the type of the identifier being declared is deduced from the initializer as described in~\ref{dcl.spec.auto}.

\pnum
The \defnadj{decision}{variable} of a \grammarterm{condition}
that is neither an \grammarterm{expression} nor a structured binding declaration
is the declared variable.
The decision variable of a \grammarterm{condition}
that is a structured binding declaration is specified in \ref{dcl.struct.bind}.

\pnum
The value of a \grammarterm{condition} that is not an \grammarterm{expression}
in a statement other than a \keyword{switch} statement is the value of the
decision variable
contextually converted to \tcode{bool}\iref{conv}.
If that
conversion is ill-formed, the program is ill-formed.
The value of a
\grammarterm{condition} that is an expression is the value of the
expression, contextually converted to \tcode{bool}
for statements other
than \keyword{switch};
if that conversion is ill-formed, the program is
ill-formed. The value of the condition will be referred to as simply
``the condition'' where the usage is unambiguous.

\pnum
If a \grammarterm{condition} can be syntactically resolved
as either an expression or a declaration,
it is interpreted as the latter.

\pnum
In the \grammarterm{decl-specifier-seq} of a \grammarterm{condition},
including that of any \grammarterm{structured-binding-declaration} of
the \grammarterm{condition},
each
\grammarterm{decl-specifier} shall be either a \grammarterm{type-specifier}
or \keyword{constexpr}.

\rSec1[stmt.label]{Label}%
\indextext{statement!labeled}

\pnum
\indextext{statement!labeled}%
\indextext{\idxcode{:}!label specifier}%
A label can be added to a statement or
used anywhere in a \grammarterm{compound-statement}.

\begin{bnf}
\nontermdef{label}\br
    \opt{attribute-specifier-seq} identifier \terminal{:}\br
    \opt{attribute-specifier-seq} \keyword{case} constant-expression \terminal{:}\br
    \opt{attribute-specifier-seq} \keyword{default} \terminal{:}
\end{bnf}

\begin{bnf}
\nontermdef{labeled-statement}\br
    label statement
\end{bnf}

The optional \grammarterm{attribute-specifier-seq} appertains to the label.
\indextext{statement!\idxcode{goto}}%
The only use of a label with an \grammarterm{identifier} is
as the target of a \tcode{goto}.
\indextext{label!scope of}%
No two labels in a function shall have the same \grammarterm{identifier}.
A label can be used in a \tcode{goto} statement
before its introduction.

\pnum
\indextext{\idxgram{labeled-statement}}%
\indextext{label!\idxcode{case}}%
\indextext{label!\idxcode{default}}%
A \grammarterm{labeled-statement}
whose \grammarterm{label} is a \keyword{case} or \keyword{default} label
shall be enclosed by\iref{stmt.pre} a \keyword{switch} statement\iref{stmt.switch}.

\pnum
A \defnadj{control-flow-limited}{statement} is a statement \tcode{S} for which:
\begin{itemize}
\item
  a \keyword{case} or \keyword{default} label appearing within \tcode{S} shall
  be associated with a \keyword{switch} statement\iref{stmt.switch} within
  \tcode{S}, and
\item
  a label declared in \tcode{S} shall only be referred to by a
  statement\iref{stmt.goto} in \tcode{S}.
\end{itemize}


\rSec1[stmt.expr]{Expression statement}%
\indextext{statement!expression}

\pnum
Expression statements have the form
\begin{bnf}
\nontermdef{expression-statement}\br
    \opt{expression} \terminal{;}
\end{bnf}

The expression is
a discarded-value expression\iref{expr.context}.
All
\indextext{side effects}%
side effects from an expression statement
are completed before the next statement is executed.
\indextext{statement!empty}%
An expression statement with the \grammarterm{expression} missing is called
a \defnadj{null}{statement}.
\begin{note}
Most statements are expression statements --- usually assignments or
function calls. A null statement is useful to supply a null body to an
iteration statement such as a \keyword{while}
statement\iref{stmt.while}.
\end{note}

\rSec1[stmt.block]{Compound statement or block}%
\indextext{\idxcode{\{\}}!block statement}%

\pnum
A \defnadj{compound}{statement} (also known as a block) groups a
sequence of statements into a single statement.

\begin{bnf}
\nontermdef{compound-statement}\br
    \terminal{\{} \opt{statement-seq} \opt{label-seq} \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{statement-seq}\br
    statement\br
    statement-seq statement
\end{bnf}

\begin{bnf}
\nontermdef{label-seq}\br
    label\br
    label-seq label
\end{bnf}

A label at the end of a \grammarterm{compound-statement}
is treated as if it were followed by a null statement.

\pnum
\begin{note}
A compound statement defines a block scope\iref{basic.scope}.
A declaration is a \grammarterm{statement}\iref{stmt.dcl}.
\end{note}

\rSec1[stmt.select]{Selection statements}%

\rSec2[stmt.select.general]{General}%
\indextext{statement!selection|(}

\pnum
Selection statements choose one of several flows of control.

\indextext{statement!\idxcode{if}}%
\indextext{statement!\idxcode{switch}}%
%
\begin{bnf}
\nontermdef{selection-statement}\br
    \keyword{if} \opt{\keyword{constexpr}} \terminal{(} \opt{init-statement} condition \terminal{)} statement\br
    \keyword{if} \opt{\keyword{constexpr}} \terminal{(} \opt{init-statement} condition \terminal{)} statement \keyword{else} statement\br
    \keyword{if} \opt{\terminal{!}} \keyword{consteval} compound-statement\br
    \keyword{if} \opt{\terminal{!}} \keyword{consteval} compound-statement \keyword{else} statement\br
    \keyword{switch} \terminal{(} \opt{init-statement} condition \terminal{)} statement
\end{bnf}

See~\ref{dcl.meaning} for the optional \grammarterm{attribute-specifier-seq} in a condition.
\begin{note}
An \grammarterm{init-statement} ends with a semicolon.
\end{note}

\pnum
\indextext{scope!\idxgram{selection-statement}}%
\begin{note}
Each \grammarterm{selection-statement} and
each substatement of a \grammarterm{selection-statement}
has a block scope\iref{basic.scope.block}.
\end{note}

\rSec2[stmt.if]{The \keyword{if} statement}%
\indextext{statement!\idxcode{if}}

\pnum
If the condition\iref{stmt.pre} yields \tcode{true}, the first
substatement is executed. If the \keyword{else} part of the selection
statement is present and the condition yields \tcode{false}, the second
substatement is executed. If the first substatement is reached via a
label, the condition is not evaluated and the second substatement is
not executed. In the second form of \keyword{if} statement
(the one including \keyword{else}), if the first substatement is also an
\keyword{if} statement then that inner \tcode{if} statement shall contain
an \keyword{else} part.
\begin{footnote}
In other words, the \keyword{else} is associated with the nearest un-elsed
\keyword{if}.
\end{footnote}

\pnum
If the \keyword{if} statement is of the form \tcode{if constexpr},
the value of the condition
is contextually converted to \keyword{bool} and
the converted expression shall be a constant expression\iref{expr.const};
this
form is called a \defn{constexpr if} statement. If the value of the
converted condition is \tcode{false}, the first substatement is a
\defn{discarded statement}, otherwise the second substatement, if
present, is a discarded statement. During the instantiation of an
enclosing templated entity\iref{temp.pre}, if the condition is
not value-dependent after its instantiation, the discarded substatement
(if any) is not instantiated.
Each substatement of a constexpr if statement is a control-flow-limited
statement\iref{stmt.label}.
\begin{example}
\begin{codeblock}
if constexpr (sizeof(int[2])) {}        // OK, narrowing allowed
\end{codeblock}
\end{example}
\begin{note}
Odr-uses\iref{term.odr.use} in a discarded statement do not require
an entity to be defined.
\end{note}
\begin{example}
\begin{codeblock}
template<typename T, typename ... Rest> void g(T&& p, Rest&& ...rs) {
  // ... handle \tcode{p}

  if constexpr (sizeof...(rs) > 0)
    g(rs...);       // never instantiated with an empty argument list
}

extern int x;       // no definition of \tcode{x} required

int f() {
  if constexpr (true)
    return 0;
  else if (x)
    return x;
  else
    return -x;
}
\end{codeblock}
\end{example}

\pnum
An \keyword{if} statement of the form
\begin{ncsimplebnf}
\keyword{if} \opt{\keyword{constexpr}} \terminal{(} init-statement condition \terminal{)} statement
\end{ncsimplebnf}
is equivalent to
\begin{ncsimplebnf}
\terminal{\{}\br
\bnfindent init-statement\br
\bnfindent \keyword{if} \opt{\keyword{constexpr}} \terminal{(} condition \terminal{)} statement\br
\terminal{\}}
\end{ncsimplebnf}
and an \keyword{if} statement of the form
\begin{ncsimplebnf}
\keyword{if} \opt{\keyword{constexpr}} \terminal{(} init-statement condition \terminal{)} statement \keyword{else} statement
\end{ncsimplebnf}
is equivalent to
\begin{ncsimplebnf}
\terminal{\{}\br
\bnfindent init-statement\br
\bnfindent \keyword{if} \opt{\keyword{constexpr}} \terminal{(} condition \terminal{)} statement \keyword{else} statement\br
\terminal{\}}
\end{ncsimplebnf}
except that the \grammarterm{init-statement} is
in the same scope as the \grammarterm{condition}.

\pnum
An \keyword{if} statement of the form \tcode{\keyword{if} \keyword{consteval}}
is called a \defnadj{consteval if}{statement}.
The \grammarterm{statement}, if any, in a consteval if statement
shall be a \grammarterm{compound-statement}.
\begin{example}
\begin{codeblock}
constexpr void f(bool b) {
  if (true)
    if consteval { }
    else ;              // error: not a \grammarterm{compound-statement}; \keyword{else} not associated with outer \keyword{if}
}
\end{codeblock}
\end{example}

\pnum
If a consteval if statement is evaluated in a context
that is manifestly constant-evaluated\iref{expr.const},
the first substatement is executed.
\begin{note}
The first substatement is an immediate function context.
\end{note}
Otherwise, if the \keyword{else} part of the selection statement is present,
then the second substatement is executed.
Each substatement of a consteval if statement is a control-flow-limited
statement\iref{stmt.label}.

\pnum
An \keyword{if} statement of the form
\begin{ncsimplebnf}
\keyword{if} \terminal{!} \keyword{consteval} compound-statement
\end{ncsimplebnf}
is not itself a consteval if statement,
but is equivalent to the consteval if statement
\begin{ncsimplebnf}
\keyword{if} \keyword{consteval} \terminal{\{} \terminal{\}} \keyword{else} compound-statement
\end{ncsimplebnf}
An \keyword{if} statement of the form
\begin{ncsimplebnf}
\keyword{if} \terminal{!} \keyword{consteval} compound-statement$_1$ \keyword{else} statement$_2$
\end{ncsimplebnf}
is not itself a consteval if statement,
but is equivalent to the consteval if statement
\begin{ncsimplebnf}
\keyword{if} \keyword{consteval} statement$_2$ \keyword{else} compound-statement$_1$
\end{ncsimplebnf}

\rSec2[stmt.switch]{The \keyword{switch} statement}%
\indextext{statement!\idxcode{switch}}

\pnum
The \keyword{switch} statement causes control to be transferred to one of
several statements depending on the value of a condition.

\pnum
If the \grammarterm{condition} is an \grammarterm{expression},
the value of the condition is the value of the \grammarterm{expression};
otherwise, it is the value of the decision variable.
The value of the condition shall be of integral type, enumeration type, or class
type. If of class type, the
condition is contextually implicitly converted\iref{conv} to
an integral or enumeration type.
If the (possibly converted) type is subject to integral
promotions\iref{conv.prom}, the condition is converted
to the promoted type.
Any
statement within the \keyword{switch} statement can be labeled with one or
more case labels as follows:
\begin{ncbnf}
\indextext{label!\idxcode{case}}%
\keyword{case} constant-expression \terminal{:}
\end{ncbnf}
where the \grammarterm{constant-expression} shall be
a converted constant expression\iref{expr.const} of the
adjusted type of the switch condition. No two of the case constants in
the same switch shall have the same value after conversion.

\pnum
\indextext{label!\idxcode{default}}%
There shall be at most one label of the form
\begin{codeblock}
default :
\end{codeblock}
within a \keyword{switch} statement.

\pnum
Switch statements can be nested; a \keyword{case} or \keyword{default} label
is associated with the smallest switch enclosing it.

\pnum
When the \keyword{switch} statement is executed, its condition is
evaluated.
\indextext{label!\idxcode{case}}%
If one of the case constants has the same value as the condition,
control is passed to the statement following the matched case label. If
no case constant matches the condition, and if there is a
\indextext{label!\idxcode{default}}%
\keyword{default} label, control passes to the statement labeled by the
default label. If no case matches and if there is no \keyword{default}
then none of the statements in the switch is executed.

\pnum
\keyword{case} and \keyword{default} labels in themselves do not alter the
flow of control, which continues unimpeded across such labels. To exit
from a switch, see \keyword{break}, \ref{stmt.break}.
\begin{note}
Usually, the substatement that is the subject of a switch is compound
and \keyword{case} and \keyword{default} labels appear on the top-level
statements contained within the (compound) substatement, but this is not
required.
\indextext{statement!declaration in \tcode{switch}}%
Declarations can appear in the substatement of a
\keyword{switch} statement.
\end{note}

\pnum
A \keyword{switch} statement of the form
\begin{ncsimplebnf}
\keyword{switch} \terminal{(} init-statement condition \terminal{)} statement
\end{ncsimplebnf}
is equivalent to
\begin{ncsimplebnf}
\terminal{\{}\br
\bnfindent init-statement\br
\bnfindent \keyword{switch} \terminal{(} condition \terminal{)} statement\br
\terminal{\}}
\end{ncsimplebnf}
except that the \grammarterm{init-statement} is in
the same scope as the \grammarterm{condition}.

\indextext{statement!selection|)}

\rSec1[stmt.iter]{Iteration statements}%

\rSec2[stmt.iter.general]{General}%
\indextext{statement!iteration|(}

\pnum
Iteration statements specify looping.

\indextext{statement!\idxcode{while}}%
\indextext{statement!\idxcode{do}}%
\indextext{statement!\idxcode{for}}%
%
\begin{bnf}
\nontermdef{iteration-statement}\br
    \keyword{while} \terminal{(} condition \terminal{)} statement\br
    \keyword{do} statement \keyword{while} \terminal{(} expression \terminal{)} \terminal{;}\br
    \keyword{for} \terminal{(} init-statement \opt{condition} \terminal{;} \opt{expression} \terminal{)} statement\br
    \keyword{for} \terminal{(} \opt{init-statement} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement
\end{bnf}

\begin{bnf}
\nontermdef{for-range-declaration}\br
    \opt{attribute-specifier-seq} decl-specifier-seq declarator\br
    structured-binding-declaration
\end{bnf}

\begin{bnf}
\nontermdef{for-range-initializer}\br
    expr-or-braced-init-list
\end{bnf}

See~\ref{dcl.meaning} for the optional \grammarterm{attribute-specifier-seq} in a
\grammarterm{for-range-declaration}.
\begin{note}
An \grammarterm{init-statement} ends with a semicolon.
\end{note}

\pnum
\indextext{scope!\idxgram{iteration-statement}}%
The substatement in an \grammarterm{iteration-statement} implicitly defines
a block scope\iref{basic.scope} which is entered and exited each time
through the loop.
If the substatement in an \grammarterm{iteration-statement} is
a single statement and not a \grammarterm{compound-statement},
it is as if it was rewritten to be
a \grammarterm{compound-statement} containing the original statement.
\begin{example}
\begin{codeblock}
while (--x >= 0)
  int i;
\end{codeblock}
can be equivalently rewritten as
\begin{codeblock}
while (--x >= 0) {
  int i;
}
\end{codeblock}
Thus after the \keyword{while} statement, \tcode{i} is no longer in scope.
\end{example}

\pnum
A \defnadj{trivially empty}{iteration statement} is
an iteration statement matching one of the following forms:
\begin{itemize}
\item \tcode{while (} \grammarterm{expression} \tcode{) ;}
\item \tcode{while (} \grammarterm{expression} \tcode{) \{ \}}
\item \tcode{do ; while (} \grammarterm{expression} \tcode{) ;}
\item \tcode{do \{ \} while (} \grammarterm{expression} \tcode{) ;}
\item \tcode{for (} \grammarterm{init-statement} \opt{\grammarterm{expression}} \tcode{; ) ;}
\item \tcode{for (} \grammarterm{init-statement} \opt{\grammarterm{expression}} \tcode{; ) \{ \}}
\end{itemize}
The \defnadj{controlling}{expression} of a trivially empty iteration statement
is the \grammarterm{expression} of
a \tcode{while}, \tcode{do}, or \tcode{for} statement
(or \tcode{true}, if the \tcode{for} statement has no \grammarterm{expression}).
A \defnadj{trivial infinite}{loop} is a trivially empty iteration statement
for which the converted controlling expression is a constant expression,
when interpreted as a \grammarterm{constant-expression}\iref{expr.const}, and
evaluates to \tcode{true}.
The \grammarterm{statement} of a trivial infinite loop is replaced with
a call to the function \tcode{std::this_thread::yield}\iref{thread.thread.this};
it is implementation-defined whether this replacement occurs
on freestanding implementations.
\begin{note}
In a freestanding environment,
concurrent forward progress is not guaranteed;
such systems therefore require explicit cooperation.
A call to yield can add implicit cooperation where none is otherwise intended.
\end{note}

\rSec2[stmt.while]{The \keyword{while} statement}%
\indextext{statement!\idxcode{while}}

\pnum
In the \keyword{while} statement, the substatement is executed repeatedly
until the value of the condition\iref{stmt.pre} becomes
\tcode{false}. The test takes place before each execution of the
substatement.

\pnum
\indextext{statement!declaration in \tcode{while}}%
A \keyword{while} statement is equivalent to
\begin{ncsimplebnf}
\exposid{label} \terminal{:}\br
\terminal{\{}\br
\bnfindent \keyword{if} \terminal{(} condition \terminal{)} \terminal{\{}\br
\bnfindent \bnfindent statement\br
\bnfindent \bnfindent \keyword{goto} \exposid{label} \terminal{;}\br
\bnfindent \terminal{\}}\br
\terminal{\}}
\end{ncsimplebnf}
\begin{note}
The variable created in the condition is destroyed and created with each
iteration of the loop.
\begin{example}
\begin{codeblock}
struct A {
  int val;
  A(int i) : val(i) { }
  ~A() { }
  operator bool() { return val != 0; }
};
int i = 1;
while (A a = i) {
  // ...
  i = 0;
}
\end{codeblock}
In the while-loop, the constructor and destructor are each called twice,
once for the condition that succeeds and once for the condition that
fails.
\end{example}
\end{note}

\rSec2[stmt.do]{The \keyword{do} statement}%
\indextext{statement!\idxcode{do}}

\pnum
The expression is contextually converted to \tcode{bool}\iref{conv};
if that conversion is ill-formed, the program is ill-formed.

\pnum
In the \keyword{do} statement, the substatement is executed repeatedly
until the value of the expression becomes \tcode{false}. The test takes
place after each execution of the statement.

\rSec2[stmt.for]{The \tcode{for} statement}%
\indextext{statement!\idxcode{for}}

\pnum
The \keyword{for} statement
\begin{ncsimplebnf}
\keyword{for} \terminal{(} init-statement \opt{condition} \terminal{;} \opt{expression} \terminal{)} statement
\end{ncsimplebnf}
is equivalent to
\begin{ncsimplebnf}
\terminal{\{}\br
\bnfindent init-statement\br
\bnfindent \keyword{while} \terminal{(} condition \terminal{)} \terminal{\{}\br
\bnfindent\bnfindent statement\br
\bnfindent\bnfindent expression \terminal{;}\br
\bnfindent \terminal{\}}\br
\terminal{\}}
\end{ncsimplebnf}
except that the \grammarterm{init-statement} is
in the same scope as the \grammarterm{condition}, and
except that a
\indextext{statement!\tcode{continue} in \tcode{for}}%
\keyword{continue} in \grammarterm{statement} (not enclosed in another
iteration statement) will execute \grammarterm{expression} before
re-evaluating \grammarterm{condition}.
\begin{note}
Thus the first statement specifies initialization for the loop; the
condition\iref{stmt.pre} specifies a test, sequenced before each
iteration, such that the loop is exited when the condition becomes
\tcode{false}; the expression often specifies incrementing that is
sequenced after each iteration.
\end{note}

\pnum
Either or both of the \grammarterm{condition}
and the \grammarterm{expression} can be omitted.
A missing \grammarterm{condition}
makes the implied \keyword{while} clause
equivalent to \tcode{while(true)}.

\rSec2[stmt.ranged]{The range-based \keyword{for} statement}%
\indextext{statement!range based for@range based \tcode{for}}

\pnum
The range-based \keyword{for} statement
\begin{ncsimplebnf}
\keyword{for} \terminal{(} \opt{init-statement} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement
\end{ncsimplebnf}
is equivalent to
\begin{ncsimplebnf}
\terminal{\{}\br
\bnfindent \opt{init-statement}\br
\bnfindent \keyword{auto} \terminal{\&\&}\exposid{range} \terminal{=} for-range-initializer \terminal{;}\br
\bnfindent \keyword{auto} \exposid{begin} \terminal{=} \exposid{begin-expr} \terminal{;}\br
\bnfindent \keyword{auto} \exposid{end} \terminal{=} \exposid{end-expr} \terminal{;}\br
\bnfindent \keyword{for} \terminal{(} \terminal{;} \exposid{begin} \terminal{!=} \exposid{end}\terminal{;} \terminal{++}\exposid{begin} \terminal{)} \terminal{\{}\br
\bnfindent\bnfindent for-range-declaration \terminal{=} \terminal{*} \exposid{begin} \terminal{;}\br
\bnfindent\bnfindent statement\br
\bnfindent \terminal{\}}\br
\terminal{\}}
\end{ncsimplebnf}
where
\begin{itemize}
\item
if the \grammarterm{for-range-initializer} is an \grammarterm{expression},
it is regarded as if it were surrounded by parentheses (so that a comma operator
cannot be reinterpreted as delimiting two \grammarterm{init-declarator}{s});

\item \exposid{range}, \exposid{begin}, and \exposid{end} are variables defined for
exposition only; and

\item
\exposid{begin-expr} and \exposid{end-expr} are determined as follows:

\begin{itemize}
\item if the type of \exposid{range} is a reference to an
array type \tcode{R}, \exposid{begin-expr} and \exposid{end-expr} are
\exposid{range} and \exposid{range} \tcode{+} \tcode{N}, respectively,
where \tcode{N} is
the array bound. If \tcode{R} is an array of unknown bound or an array of
incomplete type, the program is ill-formed;

\item if the type of \exposid{range} is a reference to a
class type \tcode{C}, and
searches in the scope of \tcode{C}\iref{class.member.lookup}
for the names \tcode{begin} and \tcode{end}
each find at least one declaration,
\exposid{begin-expr} and \exposid{end-expr} are
\tcode{\exposid{range}.begin()} and \tcode{\exposid{range}.end()},
respectively;

\item otherwise, \exposid{begin-expr} and \exposid{end-expr} are
\tcode{begin(\exposid{range})} and \tcode{end(\exposid{range})}, respectively,
where \tcode{begin} and \tcode{end} undergo
argument-dependent lookup\iref{basic.lookup.argdep}.
\begin{note}
Ordinary unqualified lookup\iref{basic.lookup.unqual} is not
performed.
\end{note}
\end{itemize}
\end{itemize}
\begin{example}
\begin{codeblock}
int array[5] = { 1, 2, 3, 4, 5 };
for (int& x : array)
  x *= 2;
\end{codeblock}
\end{example}
\begin{note}
The lifetime of some temporaries in the \grammarterm{for-range-initializer}
is extended to cover the entire loop\iref{class.temporary}.
\end{note}
\begin{example}
\begin{codeblock}
using T = std::list<int>;
const T& f1(const T& t) { return t; }
const T& f2(T t)        { return t; }
T g();

void foo() {
  for (auto e : f1(g())) {}     // OK, lifetime of return value of \tcode{g()} extended
  for (auto e : f2(g())) {}     // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
In the \grammarterm{decl-specifier-seq} of a \grammarterm{for-range-declaration},
each \grammarterm{decl-specifier} shall be either a \grammarterm{type-specifier}
or \keyword{constexpr}. The \grammarterm{decl-specifier-seq} shall not define a
class or enumeration.%
\indextext{statement!iteration|)}

\rSec1[stmt.jump]{Jump statements}%

\rSec2[stmt.jump.general]{General}%
\indextext{statement!jump}

\pnum
Jump statements unconditionally transfer control.
\indextext{statement!jump}%

\indextext{statement!\idxcode{break}}%
\indextext{statement!\idxcode{continue}}%
\indextext{return statement@\tcode{return} statement|see{\tcode{return}}}%
\indextext{\idxcode{return}}%
\indextext{statement!\idxcode{goto}}%
%
\begin{bnf}
\nontermdef{jump-statement}\br
    \keyword{break} \terminal{;}\br
    \keyword{continue} \terminal{;}\br
    \keyword{return} \opt{expr-or-braced-init-list} \terminal{;}\br
    coroutine-return-statement\br
    \keyword{goto} identifier \terminal{;}
\end{bnf}

\pnum
\indextext{local variable!destruction of}%
\indextext{scope!destructor and exit from}%
\begin{note}
On exit from a scope (however accomplished), objects with automatic storage
duration\iref{basic.stc.auto} that have been constructed in that scope are destroyed
in the reverse order of their construction\iref{stmt.dcl}.
For temporaries, see~\ref{class.temporary}.
However, the program can be terminated (by calling
\indextext{\idxcode{exit}}%
\indexlibraryglobal{exit}%
\tcode{std::exit()} or
\indextext{\idxcode{abort}}%
\indexlibraryglobal{abort}%
\tcode{std::abort()}\iref{support.start.term}, for example) without
destroying objects with automatic storage duration.
\end{note}
\begin{note}
A suspension of a coroutine\iref{expr.await} is not considered to be an exit from a scope.
\end{note}

\rSec2[stmt.break]{The \keyword{break} statement}%
\indextext{statement!\idxcode{break}}

\pnum
A \keyword{break} statement shall be enclosed by\iref{stmt.pre}
\indextext{\idxgram{iteration-statement}}%
\indextext{statement!\idxcode{switch}}%
an \grammarterm{iteration-statement}\iref{stmt.iter} or
a \keyword{switch} statement\iref{stmt.switch}.
The \keyword{break} statement causes
termination of the smallest such enclosing statement;
control passes to the statement following the
terminated statement, if any.

\rSec2[stmt.cont]{The \keyword{continue} statement}%
\indextext{statement!\idxcode{continue}}

\pnum
A \keyword{continue}
statement shall be enclosed by\iref{stmt.pre} an
\indextext{\idxgram{iteration-statement}}%
\grammarterm{iteration-statement}\iref{stmt.iter}.
The \keyword{continue} statement
causes control to pass to the loop-continuation portion of the
smallest such enclosing statement, that is, to the end
of the loop. More precisely, in each of the statements

\begin{minipage}{.30\hsize}
\begin{codeblock}
while (foo) {
  {
    // ...
  }
@\exposid{contin}@: ;
}
\end{codeblock}
\end{minipage}
\begin{minipage}{.30\hsize}
\begin{codeblock}
do {
  {
    // ...
  }
@\exposid{contin}@: ;
} while (foo);
\end{codeblock}
\end{minipage}
\begin{minipage}{.30\hsize}
\begin{codeblock}
for (;;) {
  {
    // ...
  }
@\exposid{contin}@: ;
}
\end{codeblock}
\end{minipage}

a \keyword{continue} not contained in an enclosed iteration statement is
equivalent to \tcode{goto} \exposid{contin}.

\rSec2[stmt.return]{The \keyword{return} statement}%
\indextext{\idxcode{return}}%
\indextext{function return|see{\tcode{return}}}%

\pnum
A function returns control to its caller by the \tcode{return} statement.

\pnum
The \grammarterm{expr-or-braced-init-list}
of a \tcode{return} statement is called its operand. A \tcode{return} statement with
no operand shall be used only in a function whose return type is
\cv{}~\keyword{void}, a constructor\iref{class.ctor}, or a
destructor\iref{class.dtor}.
\indextext{\idxcode{return}!constructor and}%
\indextext{\idxcode{return}!constructor and}%
A \tcode{return} statement with an operand of type \keyword{void} shall be used only
in a function that has a \cv{}~\keyword{void} return type.
A \tcode{return} statement with any other operand shall be used only
in a function that has a return type other than \cv{}~\keyword{void};
\indextext{conversion!return type}%
the \tcode{return} statement initializes the
returned reference or prvalue result object
of the (explicit or implicit) function call
by copy-initialization\iref{dcl.init} from the operand.
\begin{note}
A constructor or destructor does not have a return type.
\end{note}
\begin{note}
A \tcode{return} statement can involve
an invocation of a constructor to perform a copy or move of the operand
if it is not a prvalue or if its type differs from the return type of the function.
A copy operation associated with a \tcode{return} statement can be elided or
converted to a move operation if an automatic storage duration variable is returned\iref{class.copy.elision}.
\end{note}

\pnum
The destructor for the result object
is potentially invoked\iref{class.dtor,except.ctor}.
\begin{example}
\begin{codeblock}
class A {
  ~A() {}
};
A f() { return A(); }   // error: destructor of \tcode{A} is private (even though it is never invoked)
\end{codeblock}
\end{example}

\pnum
Flowing off the end of
a constructor,
a destructor, or
a non-coroutine function with a \cv{}~\keyword{void} return type is
equivalent to a \tcode{return} with no operand.
Otherwise, flowing off the end of a function
that is neither \tcode{main}\iref{basic.start.main} nor a coroutine\iref{dcl.fct.def.coroutine}
results in undefined behavior.

\pnum
The copy-initialization of the result of the call is sequenced before the
destruction of temporaries at the end of the full-expression established
by the operand of the \tcode{return} statement, which, in turn, is sequenced
before the destruction of local variables\iref{stmt.jump} of the block
enclosing the \tcode{return} statement.

\pnum
In a function whose return type is a reference,
other than an invented function for \tcode{std::is_convertible}\iref{meta.rel},
a \tcode{return} statement that binds the returned reference to
a temporary expression\iref{class.temporary} is ill-formed.
\begin{example}
\begin{codeblock}
auto&& f1() {
  return 42;            // ill-formed
}
const double& f2() {
  static int x = 42;
  return x;             // ill-formed
}
auto&& id(auto&& r) {
  return static_cast<decltype(r)&&>(r);
}
auto&& f3() {
  return id(42);        // OK, but probably a bug
}
\end{codeblock}
\end{example}

\rSec2[stmt.return.coroutine]{The \keyword{co_return} statement}%
\indextext{\idxcode{co_return}}%
\indextext{coroutine return|see{\tcode{co_return}}}%

\begin{bnf}
\nontermdef{coroutine-return-statement}\br
    \terminal{co_return} \opt{expr-or-braced-init-list} \terminal{;}
\end{bnf}

\pnum
A \keyword{co_return} statement transfers control to
the caller or resumer of a coroutine\iref{dcl.fct.def.coroutine}.
A coroutine shall not enclose
a \tcode{return} statement\iref{stmt.return}.
\begin{note}
For this determination, it is irrelevant whether the \tcode{return} statement
is enclosed by a discarded statement\iref{stmt.if}.
\end{note}

\pnum
The \grammarterm{expr-or-braced-init-list} of a \keyword{co_return} statement is
called its operand.
Let \placeholder{p} be an lvalue naming the coroutine
promise object\iref{dcl.fct.def.coroutine}.
A \keyword{co_return} statement is equivalent to:
\begin{ncsimplebnf}
\terminal{\{} S\terminal{;} \terminal{goto} \exposid{final-suspend}\terminal{;} \terminal{\}}
\end{ncsimplebnf}
where \exposid{final-suspend} is the exposition-only label
defined in \ref{dcl.fct.def.coroutine}
and \placeholder{S} is defined as follows:
\begin{itemize}
\item
If the operand is a \grammarterm{braced-init-list} or an expression of non-\keyword{void} type,
\placeholder{S} is \placeholder{p}\tcode{.return_value(}\grammarterm{expr-or-braced-init-list}{}\tcode{)}.
The expression \placeholder{S} shall be a prvalue of type \keyword{void}.

\item
Otherwise,
\placeholder{S} is the \grammarterm{compound-statement} \tcode{\{}{ }\opt{\grammarterm{expression}} \tcode{;} \placeholder{p}\tcode{.return_void()}\tcode{;{ }\}}.
The expression \placeholder{p}\tcode{.return_void()}
shall be a prvalue of type \keyword{void}.
\end{itemize}

\pnum
If a search for the name \tcode{return_void} in the scope of the promise type
finds any declarations,
flowing off the end of a coroutine's \grammarterm{function-body}
is equivalent to a \keyword{co_return} with no operand;
otherwise flowing off the end of a coroutine's \grammarterm{function-body}
results in undefined behavior.

\rSec2[stmt.goto]{The \keyword{goto} statement}%
\indextext{statement!\idxcode{goto}}

\pnum
The \tcode{goto} statement unconditionally transfers control to the
statement labeled by the identifier. The identifier shall be a
\indextext{label}%
label\iref{stmt.label} located in the current function.

\rSec1[except]{Try block statements}%
\indextext{exception handling|(}

\indextext{exception object|see{exception handling, exception object}}%
\indextext{object!exception|see{exception handling, exception object}}

\rSec2[except.pre]{General}

\pnum
Exception handling provides a way of transferring control and information
from a point in the execution of a thread to an exception handler
associated with a point previously passed by the execution.
A handler will be invoked only by throwing an exception
in code executed in the handler's try block
or in functions called from the handler's try block.

\indextext{\idxcode{try}}%
%
\begin{bnf}
\nontermdef{try-block}\br
    \keyword{try} compound-statement handler-seq
\end{bnf}

\indextext{\idxcode{try}}%
%
\begin{bnf}
\nontermdef{function-try-block}\br
    \keyword{try} \opt{ctor-initializer} compound-statement handler-seq
\end{bnf}

\begin{bnf}
\nontermdef{handler-seq}\br
    handler \opt{handler-seq}
\end{bnf}

\indextext{\idxcode{catch}}%
%
\begin{bnf}
\nontermdef{handler}\br
    \keyword{catch} \terminal{(} exception-declaration \terminal{)} compound-statement
\end{bnf}

\begin{bnf}
\nontermdef{exception-declaration}\br
    \opt{attribute-specifier-seq} type-specifier-seq declarator\br
    \opt{attribute-specifier-seq} type-specifier-seq \opt{abstract-declarator}\br
    \terminal{...}
\end{bnf}

The optional \grammarterm{attribute-specifier-seq} in an \grammarterm{exception-declaration}
appertains to the parameter of the catch clause\iref{except.handle}.

\pnum
In this Clause, ``before'' and ``after'' refer to the
``sequenced before'' relation\iref{intro.execution}.

\pnum
\indextext{exception handling!try block}%
\indextext{try block|see{exception handling, try block}}%
Within this Clause
``try block'' is taken to mean both \grammarterm{try-block} and
\grammarterm{function-try-block}.

\pnum
\indextext{exception handling!\idxcode{switch}}%
\indextext{exception handling!handler}%
\indextext{handler|see{exception handling, handler}}%\indextext{exception handling!\idxcode{goto}}%
\indextext{\idxcode{goto}!and try block}%
\indextext{\idxcode{switch}!and try block}%
\indextext{\idxcode{goto}!and handler}%
\indextext{\idxcode{switch}!and handler}%
The \grammarterm{compound-statement} of a try block or of a handler is a
control-flow-limited statement\iref{stmt.label}.
\begin{example}
\begin{codeblock}
void f() {
  goto l1;          // error
  goto l2;          // error
  try {
    goto l1;        // OK
    goto l2;        // error
    l1: ;
  } catch (...) {
    l2: ;
    goto l1;        // error
    goto l2;        // OK
  }
}

\end{codeblock}
\end{example}

\pnum
\indextext{\idxcode{goto}!and try block}%
\indextext{\idxcode{switch}!and try block}%
\indextext{\idxcode{return}!and try block}%
\indextext{\idxcode{continue}!and try block}%
\indextext{\idxcode{goto}!and handler}%
\indextext{\idxcode{switch}!and handler}%
\indextext{\idxcode{return}!and handler}%
\indextext{\idxcode{continue}!and handler}%
A
\keyword{goto},
\keyword{break},
\keyword{return},
or
\keyword{continue}
statement can be used to transfer control out of
a try block or handler.
When this happens, each variable declared in the try block
will be destroyed in the context that
directly contains its declaration.
\begin{example}
\begin{codeblock}
lab:  try {
  T1 t1;
  try {
    T2 t2;
    if (@\grammarterm{condition}@)
      goto lab;
    } catch(...) { @\tcode{/* handler 2 */}@ }
  } catch(...) { @\tcode{/* handler 1 */}@ }
\end{codeblock}

Here, executing
\tcode{goto lab;}
will destroy first
\tcode{t2},
then
\tcode{t1},
assuming the
\grammarterm{condition}
does not declare a variable.
Any exception thrown while destroying
\tcode{t2}
will result in executing
\tcode{handler 2};
any exception thrown while destroying
\tcode{t1}
will result in executing
\tcode{handler 1}.
\end{example}

\pnum
\indextext{function try block|see{exception handling, function try block}}%
\indextext{exception handling!function try block}%
A
\grammarterm{function-try-block}
associates a
\grammarterm{handler-seq}
with the
\grammarterm{ctor-initializer},
if present, and the
\grammarterm{compound-statement}.
An exception
thrown during the execution of the
\grammarterm{compound-statement}
or, for constructors and destructors, during the initialization or
destruction, respectively, of the class's subobjects,
transfers control to a handler in a
\grammarterm{function-try-block}
in the same way as an exception thrown during the execution of a
\grammarterm{try-block}
transfers control to other handlers.
\begin{example}
\begin{codeblock}
int f(int);
class C {
  int i;
  double d;
public:
  C(int, double);
};

C::C(int ii, double id)
try : i(f(ii)), d(id) {
    // constructor statements
} catch (...) {
    // handles exceptions thrown from the ctor-initializer and from the constructor statements
}
\end{codeblock}
\end{example}

\rSec2[except.throw]{Throwing an exception}%
\indextext{exception handling!throwing}%
\indextext{throwing|see{exception handling, throwing}}

\pnum
Throwing an exception transfers control to a handler.
\begin{note}
An exception can be thrown from one of the following contexts:
\grammarterm{throw-expression}{s}\iref{expr.throw},
allocation functions\iref{basic.stc.dynamic.allocation},
\keyword{dynamic_cast}\iref{expr.dynamic.cast},
\keyword{typeid}\iref{expr.typeid},
\grammarterm{new-expression}{s}\iref{expr.new}, and standard library
functions\iref{structure.specifications}.
\end{note}
An object is passed and the type of that object determines which handlers
can catch it.
\begin{example}
\begin{codeblock}
throw "Help!";
\end{codeblock}
can be caught by a
\grammarterm{handler}
of
\keyword{const}
\tcode{\keyword{char}*}
type:
\begin{codeblock}
try {
    // ...
} catch(const char* p) {
    // handle character string exceptions here
}
\end{codeblock}
and
\begin{codeblock}
class Overflow {
public:
    Overflow(char,double,double);
};

void f(double x) {
    throw Overflow('+',x,3.45e107);
}
\end{codeblock}
can be caught by a handler for exceptions of type
\tcode{Overflow}:
\begin{codeblock}
try {
    f(1.2);
} catch(Overflow& oo) {
    // handle exceptions of type \tcode{Overflow} here
}
\end{codeblock}
\end{example}

\pnum
\indextext{exception handling!throwing}%
\indextext{exception handling!handler}%
\indextext{exception handling!nearest handler}%
When an exception is thrown, control is transferred to the nearest handler with
a matching type\iref{except.handle}; ``nearest'' means the handler
for which the
\grammarterm{compound-statement} or
\grammarterm{ctor-initializer}
following the
\keyword{try}
keyword was most recently entered by the thread of control and not yet exited.

\pnum
Throwing an exception
initializes an object with dynamic storage duration,
called the
\defnx{exception object}{exception handling!exception object}.
If the type of the exception object would be
an incomplete type\iref{basic.types.general},
an abstract class type\iref{class.abstract},
or a pointer to an incomplete type other than
\cv{}~\keyword{void}\iref{basic.compound},
the program is ill-formed.

\pnum
\indextext{exception handling!memory}%
\indextext{exception handling!rethrowing}%
\indextext{exception handling!exception object}%
The memory for the exception object is
allocated in an unspecified way, except as noted in~\ref{basic.stc.dynamic.allocation}.
If a handler exits by rethrowing, control is passed to another handler for
the same exception object.
The points of potential destruction for the exception object are:
\begin{itemize}
\item
when an active handler for the exception exits by
any means other than
rethrowing,
immediately after the destruction of the object (if any)
declared in the \grammarterm{exception-declaration} in the handler;

\item
when an object of type \tcode{std::exception_ptr}\iref{propagation}
that refers to the exception object is destroyed,
before the destructor of \tcode{std::exception_ptr} returns.
\end{itemize}

Among all points of potential destruction for the exception object,
there is an unspecified last one
where the exception object is destroyed.
All other points happen before that last one\iref{intro.races}.
\begin{note}
No other thread synchronization is implied in exception handling.
\end{note}
The implementation may then
deallocate the memory for the exception object; any such deallocation
is done in an unspecified way.
\begin{note}
A thrown exception does not
propagate to other threads unless caught, stored, and rethrown using
appropriate library functions; see~\ref{propagation} and~\ref{futures}.
\end{note}

\pnum
\indextext{exception handling!exception object!constructor}%
\indextext{exception handling!exception object!destructor}%
Let \tcode{T} denote the type of the exception object.
Copy-initialization of an object of type \tcode{T} from
an lvalue of type \tcode{const T} in a context unrelated to \tcode{T}
shall be well-formed.
If \tcode{T} is a class type,
the selected constructor is odr-used\iref{basic.def.odr} and
the destructor of \tcode{T} is potentially invoked\iref{class.dtor}.

\pnum
An exception is considered uncaught
after completing the initialization of the exception object
until completing the activation of a handler for the exception\iref{except.handle}.
\begin{note}
As a consequence, an exception is considered uncaught
during any stack unwinding resulting from it being thrown.
\end{note}

\pnum
\indextext{exception handling!rethrow}%
\indextext{rethrow|see{exception handling, rethrow}}%
An exception is considered caught when a handler for that exception
becomes active\iref{except.handle}.
\begin{note}
An exception can have active handlers and still be considered uncaught if
it is rethrown.
\end{note}

\pnum
If an exception is rethrown\iref{expr.throw,propagation},
it is considered uncaught from the point of rethrow
until the rethrown exception is caught.
\indexlibraryglobal{uncaught_exceptions}%
\begin{note}
The function \tcode{std::uncaught_exceptions}\iref{uncaught.exceptions}
returns the number of uncaught exceptions in the current thread.
\end{note}

\pnum
\indextext{exception handling!terminate called@\tcode{terminate} called}%
\indextext{\idxcode{terminate}!called}%
If the exception handling mechanism
handling an uncaught exception
directly invokes a function that exits via an
exception, the function \tcode{std::terminate} is invoked\iref{except.terminate}.
\begin{example}
\begin{codeblock}
struct C {
  C() { }
  C(const C&) {
    if (std::uncaught_exceptions()) {
      throw 0;      // throw during copy to handler's \grammarterm{exception-declaration} object\iref{except.handle}
    }
  }
};

int main() {
  try {
    throw C();      // calls \tcode{std::terminate} if construction of the handler's
                    // \grammarterm{exception-declaration} object is not elided\iref{class.copy.elision}
  } catch(C) { }
}
\end{codeblock}
\end{example}
\begin{note}
If a destructor directly invoked by stack unwinding exits via an exception,
\tcode{std::terminate} is invoked.
\end{note}


\rSec2[except.ctor]{Stack unwinding}%
\indextext{exception handling!constructors and destructors}%
\indextext{constructor!exception handling|see{exception handling, constructors and destructors}}%
\indextext{destructor!exception handling|see{exception handling, constructors and destructors}}

\pnum
\indextext{unwinding!stack}%
As control passes from the point where an exception is thrown
to a handler,
objects are destroyed by a process,
specified in this subclause, called \defn{stack unwinding}.

\pnum
Each object with automatic storage duration is destroyed if it has been
constructed, but not yet destroyed,
since the try block was entered.
If an exception is thrown during the destruction of temporaries or
local variables for a \keyword{return} statement\iref{stmt.return},
the destructor for the returned object (if any) is also invoked.
The objects are destroyed in the reverse order of the completion
of their construction.
\begin{example}
\begin{codeblock}
struct A { };

struct Y { ~Y() noexcept(false) { throw 0; } };

A f() {
  try {
    A a;
    Y y;
    A b;
    return {};      // \#1
  } catch (...) {
  }
  return {};        // \#2
}
\end{codeblock}
At \#1, the returned object of type \tcode{A} is constructed.
Then, the local variable \tcode{b} is destroyed\iref{stmt.jump}.
Next, the local variable \tcode{y} is destroyed,
causing stack unwinding,
resulting in the destruction of the returned object,
followed by the destruction of the local variable \tcode{a}.
Finally, the returned object is constructed again at \#2.
\end{example}

\pnum
If the initialization of an object
other than by delegating constructor
is terminated by an exception,
the destructor is invoked for
each of the object's subobjects
that were known to be initialized by the object's initialization and
whose initialization has completed\iref{dcl.init}.
\begin{note}
If such an object has a reference member
that extends the lifetime of a temporary object,
this ends the lifetime of the reference member,
so the lifetime of the temporary object is effectively not extended.
\end{note}
\indextext{subobject!initialized, known to be}%
A subobject is \defn{known to be initialized}
if it is not an anonymous union member and
its initialization is specified
\begin{itemize}
\item in \ref{expr.prim.lambda.capture} for the initialization of
the closure object when evaluating a \grammarterm{lambda-expression},
\item in \ref{dcl.init.general} for
default-initialization, value-initialization, or direct-initialization
of an array,
\item in \ref{dcl.init.aggr} for aggregate initialization,
\item in \ref{class.copy.ctor} for initialization by defaulted copy/move constructor,
\item in \ref{class.base.init} for initialization by constructor,
\item in \ref{class.inhctor.init} for initialization by inherited constructor.
\end{itemize}
\begin{note}
This includes virtual base class subobjects
if the initialization
is for a complete object, and
can include variant members
that were nominated explicitly by
a \grammarterm{mem-initializer} or \grammarterm{designated-initializer-clause} or
that have a default member initializer.
\end{note}
If the destructor of an object is terminated by an exception,
each destructor invocation
that would be performed after executing the body of the destructor\iref{class.dtor} and
that has not yet begun execution
is performed.
\begin{note}
This includes virtual base class subobjects if
the destructor was invoked for a complete object.
\end{note}
The subobjects are destroyed in the reverse order of the completion of
their construction. Such destruction is sequenced before entering a
handler of the \grammarterm{function-try-block} of the constructor or destructor,
if any.

\pnum
If the \grammarterm{compound-statement}
of the \grammarterm{function-body}
of a delegating constructor
for an object exits via
an exception, the object's destructor is invoked.
Such destruction is sequenced before entering a handler of the
\grammarterm{function-try-block} of a delegating constructor for that object, if any.

\pnum
\begin{note}
If the object was allocated by a \grammarterm{new-expression}\iref{expr.new},
the matching deallocation function\iref{basic.stc.dynamic.deallocation},
if any, is called to free the storage occupied by the object.
\end{note}


\rSec2[except.handle]{Handling an exception}
\indextext{exception handling!handler|(}%

\pnum
The
\grammarterm{exception-declaration}
in a
\grammarterm{handler}
describes the type(s) of exceptions that can cause
that
\grammarterm{handler}
to be entered.
\indextext{exception handling!handler!incomplete type in}%
\indextext{exception handling!handler!rvalue reference in}%
\indextext{exception handling!handler!array in}%
\indextext{exception handling!handler!pointer to function in}%
The
\grammarterm{exception-declaration}
shall not denote an incomplete type, an abstract class type, or an rvalue reference type.
The
\grammarterm{exception-declaration}
shall not denote a pointer or reference to an
incomplete type, other than ``pointer to \cv{}~\keyword{void}''.

\pnum
A handler of type
\indextext{array!handler of type}%
``array of \tcode{T}'' or
\indextext{function!handler of type}%
function type \tcode{T}
is adjusted to be of type
``pointer to \tcode{T}''.

\pnum
\indextext{exception handling!handler!match|(}%
A
\grammarterm{handler}
is a match for
an exception object
of type
\tcode{E}
if
\begin{itemize}
\item%
The \grammarterm{handler} is of type \cv{}~\tcode{T} or
\cv{}~\tcode{T\&} and
\tcode{E} and \tcode{T}
are the same type (ignoring the top-level \grammarterm{cv-qualifier}{s}), or
\item%
the \grammarterm{handler} is of type \cv{}~\tcode{T} or
\cv{}~\tcode{T\&} and
\tcode{T} is an unambiguous public base class of \tcode{E}, or
\item%
the \grammarterm{handler} is of type \cv{}~\tcode{T} or \tcode{const T\&}
where \tcode{T} is a pointer or pointer-to-member type and
\tcode{E} is a pointer or pointer-to-member type
that can be converted to \tcode{T} by one or more of
\begin{itemize}

\item%
a standard pointer conversion\iref{conv.ptr} not involving conversions
to pointers to private or protected or ambiguous classes
\item%
a function pointer conversion\iref{conv.fctptr}
\item%
a qualification conversion\iref{conv.qual}, or

\end{itemize}

\item
the \grammarterm{handler} is of type \cv{}~\tcode{T} or \tcode{const T\&} where \tcode{T} is a pointer or pointer-to-member type and \tcode{E} is \tcode{std::nullptr_t}.

\end{itemize}

\begin{note}
A
\grammarterm{throw-expression}
whose operand is an integer literal with value zero does not match a handler of
pointer or pointer-to-member type.
A handler of reference to array or function type
is never a match for any exception object\iref{expr.throw}.
\end{note}

\begin{example}
\begin{codeblock}
class Matherr { @\commentellip@ virtual void vf(); };
class Overflow: public Matherr { @\commentellip@ };
class Underflow: public Matherr { @\commentellip@ };
class Zerodivide: public Matherr { @\commentellip@ };

void f() {
  try {
    g();
  } catch (Overflow oo) {
    // ...
  } catch (Matherr mm) {
    // ...
  }
}
\end{codeblock}
Here, the
\tcode{Overflow}
handler will catch exceptions of type
\tcode{Overflow}
and the
\tcode{Matherr}
handler will catch exceptions of type
\tcode{Matherr}
and of all types publicly derived from
\tcode{Matherr}
including exceptions of type
\tcode{Underflow}
and
\tcode{Zerodivide}.
\end{example}

\pnum
The handlers for a try block are tried in order of appearance.
\begin{note}
This makes it possible to write handlers that can never be
executed, for example by placing a handler for a final derived class after
a handler for a corresponding unambiguous public base class.
\end{note}

\pnum
A
\tcode{...}
in a handler's
\grammarterm{exception-declaration}
specifies a match for any exception.
If present, a
\tcode{...}
handler shall be the last handler for its try block.

\pnum
If no match is found among the handlers for a try block,
the search for a matching
handler continues in a dynamically surrounding try block
of the same thread.

\pnum
\indextext{exception handling!terminate called@\tcode{terminate} called}%
\indextext{\idxcode{terminate}!called}%
If the search for a handler
encounters the outermost block of a function with a
non-throwing exception specification,
the function \tcode{std::terminate} is invoked\iref{except.terminate}.
\begin{note}
An implementation is not permitted to reject an expression merely because, when
executed, it throws or might
throw an exception from a function with a non-throwing exception specification.
\end{note}
\begin{example}
\begin{codeblock}
extern void f();                // potentially-throwing

void g() noexcept {
  f();                          // valid, even if \tcode{f} throws
  throw 42;                     // valid, effectively a call to \tcode{std::terminate}
}
\end{codeblock}
The call to
\tcode{f}
is well-formed despite the possibility for it to throw an exception.
\end{example}

\pnum
If no matching handler is found,
the function \tcode{std::terminate} is invoked;
whether or not the stack is unwound before this invocation of
\tcode{std::terminate}
is \impldef{stack unwinding before invocation of
\tcode{std::terminate}}\iref{except.terminate}.

\pnum
A handler is considered \defnx{active}{exception handling!handler!active} when
initialization is complete for the parameter (if any) of the catch clause.
\begin{note}
The stack will have been unwound at that point.
\end{note}
Also, an implicit handler is considered active when
the function \tcode{std::terminate}
is entered due to a throw. A handler is no longer considered active when the
catch clause exits.

\pnum
\indextext{currently handled exception|see{exception handling, currently handled exception}}%
The exception with the most recently activated handler that is
still active is called the
\defnx{currently handled exception}{exception handling!currently handled exception}.

\pnum
Referring to any non-static member or base class of an object
in the handler for a
\grammarterm{function-try-block}
of a constructor or destructor for that object results in undefined behavior.

\pnum
Exceptions thrown in destructors of objects with static storage duration or in
constructors of objects associated with non-block variables with static storage duration are not caught by a
\grammarterm{function-try-block}
on
the \tcode{main} function\iref{basic.start.main}.
Exceptions thrown in destructors of objects with thread storage duration or in constructors of objects associated with non-block variables with thread storage duration are not caught by a
\grammarterm{function-try-block}
on the initial function of the thread.

\pnum
If a \keyword{return} statement\iref{stmt.return} appears in a handler of the
\grammarterm{function-try-block}
of a
constructor, the program is ill-formed.

\pnum
The currently handled exception
is rethrown if control reaches the end of a handler of the
\grammarterm{function-try-block}
of a constructor or destructor.
Otherwise, flowing off the end of
the \grammarterm{compound-statement}
of a \grammarterm{handler}
of a \grammarterm{function-try-block}
is equivalent to flowing off the end of
the \grammarterm{compound-statement}
of that function (see \ref{stmt.return}).

\pnum
The variable declared by the \grammarterm{exception-declaration}, of type
\cv{}~\tcode{T} or \cv{}~\tcode{T\&}, is initialized from the exception object,
of type \tcode{E}, as follows:
\begin{itemize}
\item
if \tcode{T} is a base class of \tcode{E},
the variable is copy-initialized\iref{dcl.init}
from an lvalue of type \tcode{T} designating the corresponding base class subobject
of the exception object;
\item otherwise, the variable is copy-initialized\iref{dcl.init}
from an lvalue of type \tcode{E} designating the exception object.
\end{itemize}

The lifetime of the variable ends
when the handler exits, after the
destruction of any objects with automatic storage duration initialized
within the handler.

\pnum
When the handler declares an object,
any changes to that object will not affect the exception object.
When the handler declares a reference to an object,
any changes to the referenced object are changes to the
exception object and will have effect should that object be rethrown.%
\indextext{exception handling!handler!match|)}%
\indextext{exception handling!handler|)}

\rSec1[stmt.dcl]{Declaration statement}%
\indextext{statement!declaration}

\pnum
A declaration statement introduces one or more new names into a
block; it has the form
\begin{bnf}
\nontermdef{declaration-statement}\br
    block-declaration
\end{bnf}
\begin{note}
If an identifier introduced by a declaration was previously declared in
an outer block,
\indextext{declaration hiding|see{name hiding}}%
\indextext{name hiding}%
\indextext{block (statement)!structure}%
the outer declaration is hidden
for the remainder of the block\iref{basic.lookup.unqual},
after which it resumes its force.
\end{note}

\pnum
\indextext{block (statement)!initialization in}%
\indextext{initialization!automatic}%
\indextext{active|see{variable, active}}%
A block variable with automatic storage duration\iref{basic.stc.auto}
is \defnx{active}{variable!active} everywhere in the scope to which it belongs
after its \grammarterm{init-declarator}.
\indextext{initialization!jump past}%
\indextext{\idxcode{goto}!initialization and}%
Upon each transfer of control (including sequential execution of statements)
within a function from point $P$ to point $Q$,
all block variables with automatic storage duration
that are active at $P$ and not at $Q$ are destroyed in the reverse order of their construction.
Then, all block variables with automatic storage duration
that are active at $Q$ but not at $P$ are initialized in declaration order;
unless all such variables have vacuous initialization\iref{basic.life},
the transfer of control shall not be a jump.
\begin{footnote}
The transfer from the condition of a \keyword{switch} statement to a
\keyword{case} label is considered a jump in this respect.
\end{footnote}
When a \grammarterm{declaration-statement} is executed,
$P$ and $Q$ are the points immediately before and after it;
when a function returns, $Q$ is after its body.
\begin{example}
\begin{codeblock}
void f() {
  // ...
  goto lx;          // error: jump into scope of \tcode{a}
  // ...
ly:
  X a = 1;
  // ...
lx:
  goto ly;          // OK, jump implies destructor call for \tcode{a} followed by
                    // construction again immediately following label \tcode{ly}
}
\end{codeblock}
\end{example}

\pnum
\indextext{initialization!automatic}%
\indextext{initialization!dynamic block-scope}%
\indextext{initialization!local \tcode{static}}%
\indextext{initialization!local \tcode{thread_local}}%
Dynamic initialization of a block variable with
static storage duration\iref{basic.stc.static} or
thread storage duration\iref{basic.stc.thread} is performed
the first time control passes through its declaration; such a variable is
considered initialized upon the completion of its initialization. If the
initialization exits by throwing an exception, the initialization is not
complete, so it will be tried again the next time control enters the
declaration.
If control enters the declaration concurrently while the variable is
being initialized, the concurrent execution shall wait for completion
of the initialization.
\begin{note}
A conforming implementation cannot introduce
any deadlock around execution of the initializer.
Deadlocks might still be caused by the program logic;
the implementation need only avoid deadlocks
due to its own synchronization operations.
\end{note}
If control
re-enters the declaration recursively while
the variable is being initialized, the behavior is undefined.
\begin{example}
\begin{codeblock}
int foo(int i) {
  static int s = foo(2*i);      // undefined behavior: recursive call
  return i+1;
}
\end{codeblock}
\end{example}

\pnum
\indextext{\idxcode{static}!destruction of local}%
An object associated with
a block variable with static or thread storage duration
will be destroyed if and only if it was constructed.
\begin{note}
\ref{basic.start.term} describes the order in which such objects are destroyed.
\end{note}

\rSec1[stmt.ambig]{Ambiguity resolution}%
\indextext{ambiguity!declaration versus expression}

\pnum
There is an ambiguity in the grammar involving
\grammarterm{expression-statement}{s} and \grammarterm{declaration}{s}: An
\grammarterm{expression-statement} with a function-style explicit type
conversion\iref{expr.type.conv} as its leftmost subexpression can be
indistinguishable from a \grammarterm{declaration} where the first
\grammarterm{declarator} starts with a \tcode{(}. In those cases the
\grammarterm{statement} is considered a \grammarterm{declaration},
except as specified below.

\pnum
\begin{note}
If the \grammarterm{statement} cannot syntactically be a
\grammarterm{declaration}, there is no ambiguity,
so this rule does not apply.
In some cases, the whole \grammarterm{statement} needs to be examined
to determine whether this is the case. This resolves the meaning
of many examples.
\begin{example}
Assuming \tcode{T} is a
\grammarterm{simple-type-specifier}\iref{dcl.type.simple},

\begin{codeblock}
T(a)->m = 7;        // expression-statement
T(a)++;             // expression-statement
T(a,5)<<c;          // expression-statement

T(*d)(int);         //  declaration
T(e)[5];            //  declaration
T(f) = { 1, 2 };    //  declaration
T(*g)(double(3));   //  declaration
\end{codeblock}

In the last example above, \tcode{g}, which is a pointer to \tcode{T},
is initialized to \tcode{double(3)}. This is of course ill-formed for
semantic reasons, but that does not affect the syntactic analysis.
\end{example}

The remaining cases are \grammarterm{declaration}{s}.
\begin{example}
\begin{codeblock}
class T {
  // ...
public:
  T();
  T(int);
  T(int, int);
};
T(a);               //  declaration
T(*b)();            //  declaration
T(c)=7;             //  declaration
T(d),e,f=3;         //  declaration
extern int h;
T(g)(h,2);          //  declaration
\end{codeblock}
\end{example}
\end{note}

\pnum
The disambiguation is purely syntactic; that is, the meaning of the
names occurring in such a statement, beyond whether they are
\grammarterm{type-name}{s} or not, is not generally used in or changed by the
disambiguation. Class templates are instantiated as necessary to
determine if a qualified name is a \grammarterm{type-name}. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be
an ill-formed declaration.
If, during parsing, lookup finds
that a name in a template argument is bound to
(part of) the declaration being parsed,
the program is ill-formed.
No diagnostic is required.
\begin{example}
\begin{codeblock}
struct T1 {
  T1 operator()(int x) { return T1(x); }
  int operator=(int x) { return x; }
  T1(int) { }
};
struct T2 { T2(int) { } };
int a, (*(*b)(T2))(int), c, d;

void f() {
  // disambiguation requires this to be parsed as a declaration:
  T1(a) = 3,
  T2(4),                        // \tcode{T2} will be declared as a variable of type \tcode{T1}, but this will not
  (*(*b)(T2(c)))(int(d));       // allow the last part of the declaration to parse properly,
                                // since it depends on \tcode{T2} being a type-name
}
\end{codeblock}
\end{example}

\pnum
A syntactically ambiguous statement that can syntactically be
a \grammarterm{declaration} with an outermost \grammarterm{declarator}
with a \grammarterm{trailing-return-type}
is considered a \grammarterm{declaration} only if it starts with \keyword{auto}.
\begin{example}
\begin{codeblock}
struct M;
struct S {
  S* operator()();
  int N;
  int M;

  void mem(S s) {
    auto(s)()->M;               // expression, \tcode{S::M} hides \tcode{::M}
  }
};

void f(S s) {
  {
    auto(s)()->N;               // expression
    auto(s)()->M;               // function declaration
  }
  {
    S(s)()->N;                  // expression
    S(s)()->M;                  // expression
  }
}
\end{codeblock}
\end{example}
\indextext{statement|)}
