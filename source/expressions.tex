\rSec0[expr]{Expressions}

%gram: \rSec1[gram.expr]{Expressions}
%gram:

\indextext{\idxcode{operator new}|seealso{\tcode{new}}}%
\indextext{\idxcode{operator delete}|seealso{\tcode{delete}}}%
\indextext{usual arithmetic conversions|see{conversion, usual arithmetic}}%
\indextext{\idxcode{==}|see{equality~operator}}%
\indextext{\idxcode{"!=}|see{inequality~operator}}
\indextext{\idxcode{static_cast}|see{cast, static}}%
\indextext{\idxcode{dynamic_cast}|see{cast, dynamic}}%
\indextext{\idxcode{const_cast}|see{cast, const}}%
\indextext{\idxcode{reinterpret_cast}|see{cast, reinterpret}}

\pnum
\indextext{expression|(}%
\enternote 
Clause~\ref{expr} defines the syntax, order of evaluation, and meaning
of expressions.\footnote{The precedence of operators is not directly specified, but it can be
derived from the syntax.}
An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side
effects.
\exitnote 

\pnum
\indextext{operator!overloaded}%
\enternote 
Operators can be overloaded, that is, given meaning when applied to
expressions of class type~(Clause \ref{class}) or enumeration
type~(\ref{dcl.enum}). Uses of overloaded operators are transformed into
function calls as described in~\ref{over.oper}. Overloaded operators
obey the rules for syntax specified in Clause~\ref{expr}, but the
requirements of operand type, value category, and evaluation order are replaced
by the rules for function call. Relations between operators, such as
\tcode{++a} meaning \tcode{a+=1}, are not guaranteed for overloaded
operators~(\ref{over.oper}), and are not guaranteed for operands of type
\tcode{bool}.
\exitnote 

\pnum
Clause~\ref{expr} defines the effects of operators when applied to types
for which they have not been overloaded. Operator overloading shall not
modify the rules for the \term{built-in operators}, that
is, for operators applied to types for which they are defined by this
Standard. However, these built-in operators participate in overload
resolution, and as part of that process user-defined conversions will be
considered where necessary to convert the operands to types appropriate
for the built-in operator. If a built-in operator is selected, such
conversions will be applied to the operands before the operation is
considered further according to the rules in Clause~\ref{expr};
see~\ref{over.match.oper},~\ref{over.built}.

\pnum
\indextext{exception!arithmetic}%
\indextext{exception!undefined arithmetic}%
\indextext{overflow!undefined}%
\indextext{zero!division by undefined}%
\indextext{zero!remainder undefined}%
If during the evaluation of an expression, the result is not
mathematically defined or not in the range of representable values for
its type, the behavior is undefined.
\enternote 
\indextext{overflow}%
most existing implementations of \Cpp ignore integer overflows.
Treatment of division by zero, forming a remainder using a zero divisor,
and all floating point exceptions vary among machines, and is usually
adjustable by a library function.
\exitnote 

\pnum
\indextext{expression!reference}%
If an expression initially has the type ``reference to
\tcode{T}''~(\ref{dcl.ref},~\ref{dcl.init.ref}), the type is adjusted to
\tcode{T} prior to any further analysis. The expression designates the
object or function denoted by the reference, and the expression
is an lvalue or an xvalue, depending on the expression.

\pnum
If a prvalue initially has the type ``\cv{} \tcode{T},'' where
\tcode{T} is a cv-unqualified non-class, non-array type, the type of
the expression is adjusted to \tcode{T} prior to any further analysis.

\pnum
\indextext{expression!rvalue~reference}%
\enternote
An expression is an xvalue if it is:
\begin{itemize}
\item the result of calling a function, whether implicitly or explicitly,
whose return type is an rvalue reference to object type,

\item a cast to an rvalue reference to object type,

\item a class member access expression designating a non-static data member
of non-reference type
in which the object expression is an xvalue, or

\item a \tcode{.*} pointer-to-member expression in which the first operand is
an xvalue and the second operand is a pointer to data member.
\end{itemize}
In general, the effect of this rule is that named rvalue references are
treated as lvalues and unnamed rvalue references to objects are treated as
xvalues; rvalue references to functions are treated as lvalues whether named or not.
\exitnote

\enterexample
\begin{codeblock}
struct A {
  int m;
};
A&& operator+(A, A);
A&& f();

A a;
A&& ar = static_cast<A&&>(a);
\end{codeblock}

The expressions \tcode{f()}, \tcode{f().m}, \tcode{static_cast<A\&\&>(a)}, and \tcode{a + a}
are xvalues. The expression \tcode{ar} is an lvalue.
\exitexample

\pnum
In some contexts, \defnx{unevaluated operands}{unevaluated operand}
appear~(\ref{expr.typeid}, \ref{expr.sizeof}, \ref{expr.unary.noexcept}, \ref{dcl.type.simple}).
An unevaluated operand is not evaluated. An unevaluated operand is
considered a full-expression.
\enternote
In an unevaluated operand, a non-static class member may be
named~(\ref{expr.prim}) and naming of objects or functions does not, by
itself, require that a definition be provided~(\ref{basic.def.odr}).
\exitnote

\pnum
Whenever a glvalue expression appears as an operand of an operator that
expects a prvalue for that operand, the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
or function-to-pointer~(\ref{conv.func}) standard conversions are
applied to convert the expression to a prvalue.
\enternote 
because cv-qualifiers are removed from the type of an expression of
non-class type when the expression is converted to a prvalue, an lvalue
expression of type \tcode{const int} can, for example, be used where
a prvalue expression of type \tcode{int} is required.
\exitnote 

\pnum
\indextext{conversion!usual arithmetic}%
Many binary operators that expect operands of arithmetic or enumeration
type cause conversions and yield result types in a similar way. The
purpose is to yield a common type, which is also the type of the result.
This pattern is called the \term{usual arithmetic conversions},
which are defined as follows:

\begin{itemize}
\item If either operand is of scoped enumeration type~(\ref{dcl.enum}), no conversions
are performed; if the other operand does not have the same type, the expression is
ill-formed.

\item If either operand is of type \tcode{long} \tcode{double}, the
other shall be converted to \tcode{long} \tcode{double}.

\item Otherwise, if either operand is \tcode{double}, the other shall be
converted to \tcode{double}.

\item Otherwise, if either operand is \tcode{float}, the other shall be
converted to \tcode{float}.

\item Otherwise, the integral promotions~(\ref{conv.prom}) shall be
performed on both operands.\footnote{As a consequence, operands of type \tcode{bool}, \tcode{char16_t},
\tcode{char32_t}, \tcode{wchar_t}, or an enumerated type are converted
to some integral type.}
Then the following rules shall be applied to the promoted operands:

\begin{itemize}

\item If both operands have the same type, no further conversion is
needed.

\item Otherwise, if both operands have signed integer types or both have
unsigned integer types, the operand with the type of lesser integer
conversion rank shall be converted to the type of the operand with
greater rank.

\item Otherwise, if the operand that has unsigned integer type has rank
greater than or equal to the rank of the type of the other operand, the
operand with signed integer type shall be converted to the type of the
operand with unsigned integer type.

\item Otherwise, if the type of the operand with signed integer type can
represent all of the values of the type of the operand with unsigned
integer type, the operand with unsigned integer type shall be converted
to the type of the operand with signed integer type.

\item Otherwise, both operands shall be converted to the unsigned
integer type corresponding to the type of the operand with signed
integer type.
\end{itemize}
\end{itemize}

\pnum
In some contexts, an expression only appears for its side effects. Such an
expression is called a \defn{discarded-value expression}. The expression is
evaluated and its value is discarded. The array-to-pointer~(\ref{conv.array})
and function-to-pointer~(\ref{conv.func}) standard conversions are not
applied. The lvalue-to-rvalue conversion~(\ref{conv.lval}) is applied
if and only if
the expression is an lvalue of volatile-qualified type and it is one of the
following:

\begin{itemize}
\item \tcode{(} \grammarterm{expression} \tcode{)}, where
  \grammarterm{expression} is one of these expressions,
\item \grammarterm{id-expression}~(\ref{expr.prim.general}),
\item subscripting~(\ref{expr.sub}),
\item class member access~(\ref{expr.ref}),
\item indirection~(\ref{expr.unary.op}),
\item pointer-to-member operation~(\ref{expr.mptr.oper}),
\item conditional expression~(\ref{expr.cond}) where both the second and the
      third operands are one of these expressions, or
\item comma expression~(\ref{expr.comma}) where the right operand is one of
      these expressions.
\end{itemize}

\enternote Using an overloaded operator causes a function call; the
above covers only operators with built-in meaning. If the lvalue is of
class type, it must have a volatile copy constructor to initialize the
temporary that is the result of the lvalue-to-rvalue
conversion. \exitnote

\pnum
The values of the floating operands and the results of floating
expressions may be represented in greater precision and range than that
required by the type; the types are not changed\
thereby.\footnote{The cast and assignment operators must still perform their specific
conversions as described in~\ref{expr.cast},~\ref{expr.static.cast}
and~\ref{expr.ass}.}

\rSec1[expr.prim]{Primary expressions}%
\indextext{expression!primary|(}

\rSec2[expr.prim.general]{General}

\begin{bnf}
\nontermdef{primary-expression}\br
    literal\br
    \terminal{this}\br
    \terminal{(} expression \terminal{)}\br
    id-expression\br
    lambda-expression
\end{bnf}

\begin{bnf}
\nontermdef{id-expression}\br
    unqualified-id\br
    qualified-id
\end{bnf}

\begin{bnf}
\nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    literal-operator-id\br
    \terminal{\tilde} class-name\br
    \terminal{\tilde} decltype-specifier\br
    template-id
\end{bnf}

\pnum
A
\indextext{literal}%
\indextext{constant}%
\grammarterm{literal} 
is a primary expression.
Its type depends on its form~(\ref{lex.literal}).
A string literal is an lvalue; all other literals are prvalues.

\pnum
\indextext{\idxcode{this}}%
The keyword \tcode{this} names a pointer to the object for which a non-static member
function~(\ref{class.this}) is invoked or a non-static data member's
initializer~(\ref{class.mem}) is evaluated.

\pnum
If a declaration declares a member function or member function template of a
class \tcode{X}, the expression \tcode{this} is a prvalue of type ``pointer to
\grammarterm{cv-qualifier-seq} \tcode{X}'' between the optional
\grammarterm{cv-qualifer-seq} and the end of the \grammarterm{function-definition},
\grammarterm{member-declarator}, or \grammarterm{declarator}. It shall not appear
before the optional \grammarterm{cv-qualifier-seq} and it shall not appear within
the declaration of a static member function (although its type and value category
are defined within a static member function as they are within a non-static
member function). \enternote this is because declaration matching does not
occur until the complete declarator is known. \exitnote Unlike the object
expression in other contexts, \tcode{*this} is not required to be of complete
type for purposes of class member access~(\ref{expr.ref}) outside the member
function body. \enternote only class members declared prior to the declaration
are visible. \exitnote
\enterexample
\begin{codeblock}
struct A {
  char g();
  template<class T> auto f(T t) -> decltype(t + g())
    { return t + g(); }
};
template auto A::f(int t) -> decltype(t + g());
\end{codeblock}
\exitexample

\pnum
Otherwise, if a \grammarterm{member-declarator} declares a non-static data
member~(\ref{class.mem}) of a class \tcode{X}, the expression \tcode{this} is
a prvalue of type ``pointer to \tcode{X}'' within the
optional \grammarterm{brace-or-equal-initializer}. It shall not appear elsewhere
in the \grammarterm{member-declarator}.

\pnum
The expression \tcode{this} shall not appear in any other context.
\enterexample
\begin{codeblock}
class Outer {
  int a[sizeof(*this)];               // error: not inside a member function
  unsigned int sz = sizeof(*this);    // OK: in \grammarterm{brace-or-equal-initializer}

  void f() {
    int b[sizeof(*this)];             // OK

    struct Inner {
      int c[sizeof(*this)];           // error: not inside a member function of \tcode{Inner}
    };
  }
};
\end{codeblock}
\exitexample

\pnum
\indextext{expression!parenthesized}%
A parenthesized expression is a primary expression whose type and value
are identical to those of the enclosed expression. The presence of
parentheses does not affect whether the expression is an lvalue. The
parenthesized expression can be used in exactly the same contexts as
those where the enclosed expression can be used, and with the same
meaning, except as otherwise indicated.

\pnum
\indextext{name}%
\indextext{id-expression}%
An \grammarterm{id-expression} is a restricted form of a
\grammarterm{primary-expression}.
\enternote 
an \grammarterm{id-expression} can appear after \tcode{.} and \tcode{->}
operators~(\ref{expr.ref}).
\exitnote 

\pnum
\indextext{identifier}%
An \grammarterm{identifier} is an \grammarterm{id-expression} provided it has
been suitably declared (Clause~\ref{dcl.dcl}).
\enternote 
for \grammarterm{operator-function-id}{s}, see~\ref{over.oper}; for
\grammarterm{conversion-function-id}{s}, see~\ref{class.conv.fct}; for
\grammarterm{literal-operator-id}{s}, see~\ref{over.literal}; for
\grammarterm{template-id}{s}, see~\ref{temp.names}. A \grammarterm{class-name}
or \grammarterm{decltype-specifier}
prefixed by \tcode{\tilde} denotes a destructor; see~\ref{class.dtor}.
Within the definition of a non-static member function, an
\grammarterm{identifier} that names a non-static member is transformed to a
class member access expression~(\ref{class.mfct.non-static}).
\exitnote 
The type of the expression is the type of the \grammarterm{identifier}. The
result is the entity denoted by the identifier. The result is an lvalue
if the entity is a function, variable, or data member and a prvalue otherwise.
\clearpage

\indextext{operator!scope~resolution}%
\indextext{\idxcode{::}|see{scope~resolution~operator}}%
%
\begin{bnf}
\nontermdef{qualified-id}\br
    nested-name-specifier \terminal{template}\opt unqualified-id\br
    \terminal{::} identifier\br
    \terminal{::} operator-function-id\br
    \terminal{::} literal-operator-id\br
    \terminal{::} template-id
\end{bnf}

\indextext{operator!scope~resolution}%
\indextext{name~hiding}%
%
\begin{bnf}
\nontermdef{nested-name-specifier}\br
    \terminal{::}\opt type-name \terminal{::}\br
    \terminal{::}\opt namespace-name \terminal{::}\br
    decltype-specifier \terminal{::}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \terminal{template}\opt simple-template-id \terminal{::}
\end{bnf}

The type denoted by a \grammarterm{decltype-specifier} in a
\grammarterm{nested-name-specifier} shall be a class or enumeration
type.

\pnum
A \grammarterm{nested-name-specifier} that denotes a class, optionally
followed by the keyword \tcode{template}~(\ref{temp.names}), and then
followed by the name of a member of either that class~(\ref{class.mem})
or one of its base classes (Clause~\ref{class.derived}), is a
\indextext{id!qualified}%
\grammarterm{qualified-id};~\ref{class.qual} describes name lookup for
class members that appear in \grammarterm{qualified-ids}. The result is the
member. The type of the result is the type of the member. The result is
an lvalue if the member is a static member function or a data member and a
prvalue otherwise.
\enternote 
a class member can be referred to using a \grammarterm{qualified-id} at any
point in its potential scope~(\ref{basic.scope.class}).
\exitnote 
Where
\grammarterm{class-name} \tcode{::\tilde} \grammarterm{class-name} is used,
the two \grammarterm{class-name}{s} shall refer to the same class; this
notation names the destructor~(\ref{class.dtor}).
The form \grammarterm{\tilde} \grammarterm{decltype-specifier} also denotes the destructor,
but it shall not be used as the \grammarterm{unqualified-id} in a \grammarterm{qualified-id}.
\enternote 
a \grammarterm{typedef-name} that names a class is a
\grammarterm{class-name}~(\ref{class.name}).
\exitnote 

\pnum
A \tcode{::}, or a \grammarterm{nested-name-specifier} that names a
namespace~(\ref{basic.namespace}), in either case followed by the name of a member of
that namespace (or the name of a member of a namespace made visible by a
\grammarterm{using-directive}) is a
\indextext{id!qualified}%
\grammarterm{qualified-id};~\ref{namespace.qual} describes name lookup for
namespace members that appear in \grammarterm{qualified-ids}. The result is
the member. The type of the result is the type of the member. The result
is an lvalue if the member is a function or a variable and a prvalue otherwise.

\pnum
A \grammarterm{nested-name-specifier} that denotes an
enumeration~(\ref{dcl.enum}), followed by the name of an
enumerator of that enumeration, is a \grammarterm{qualified-id}
that refers to the enumerator. The result is the enumerator. The type
of the result is the type of the enumeration. The result is a prvalue.

\pnum
In a \grammarterm{qualified-id}, if the
\grammarterm{unqualified-id}
is a
\grammarterm{conversion-function-id}, its \grammarterm{conversion-type-id}
shall denote the same type in both the context in which the entire
\grammarterm{qualified-id} occurs and in the context of the class denoted
by the \grammarterm{nested-name-specifier}.

\pnum
An \grammarterm{id-expression} that denotes a non-static data member or
non-static member function of a class can only be used:

\begin{itemize}
\item as part of a class member access~(\ref{expr.ref}) in which the
object expression
refers to the member's class\footnote{This also applies when the object expression
is an implicit \tcode{(*this)}~(\ref{class.mfct.non-static}).} or a class derived from
that class, or

\item to form a pointer to member~(\ref{expr.unary.op}), or

\item in a \grammarterm{mem-initializer} for a constructor for that class
or for a class derived from that class~(\ref{class.base.init}), or

\item in a \grammarterm{brace-or-equal-initializer} for a non-static data member
of that class or of a class derived from that class~(\ref{class.base.init}), or

\item if that \grammarterm{id-expression} denotes a non-static data member
and it appears in an unevaluated operand.
\enterexample

\begin{codeblock}
struct S {
  int m;
};
int i = sizeof(S::m);           // OK
int j = sizeof(S::m + 42);      // OK
\end{codeblock}
\exitexample
\end{itemize}

\rSec2[expr.prim.lambda]{Lambda expressions}%
\indextext{expression!lambda|(}

\pnum
Lambda expressions provide a concise way to create simple function objects.
\enterexample

\begin{codeblock}
#include <algorithm>
#include <cmath>
void abssort(float *x, unsigned N) {
  std::sort(x, x + N,
    [](float a, float b) {
      return std::abs(a) < std::abs(b);
    });
}
\end{codeblock}
\exitexample

\begin{bnf}
\nontermdef{lambda-expression}\br
    lambda-introducer lambda-declarator\opt compound-statement
\end{bnf}

\begin{bnf}
\nontermdef{lambda-introducer}\br
    \terminal{[} lambda-capture\opt \terminal{]}
\end{bnf}

\begin{bnf}
\nontermdef{lambda-capture}\br
    capture-default\br
    capture-list\br
    capture-default \terminal{,} capture-list
\end{bnf}

\begin{bnf}
\nontermdef{capture-default}\br
    \terminal{\&}\br
    \terminal{=}
\end{bnf}

\begin{bnf}
\nontermdef{capture-list}\br
    capture \terminal{...\opt}\br
    capture-list \terminal{,} capture \terminal{...\opt}
\end{bnf}

\begin{bnf}
\nontermdef{capture}\br
    identifier\br
    \terminal{\&} identifier\br
    \terminal{this}
\end{bnf}

\begin{bnf}
\nontermdef{lambda-declarator}\br
    \terminal{(} parameter-declaration-clause \terminal{)} \terminal{mutable}\opt\br
    \hspace*{\bnfindentinc}exception-specification\opt attribute-specifier-seq\opt trailing-return-type\opt
\end{bnf}

\pnum
The evaluation of a \grammarterm{lambda-expression} results in a prvalue
temporary~(\ref{class.temporary}). This temporary is called the \defn{closure object}. A
\grammarterm{lambda-expression} shall not appear in an unevaluated operand
(Clause~\ref{expr}). \enternote A closure object behaves like a function
object~(\ref{function.objects}).\exitnote

\pnum
The type of the \grammarterm{lambda-expression} (which is also the type of the
closure object) is a unique, unnamed non-union class type --- called the \defn{closure
type} --- whose properties are described below. This class type is not an
aggregate~(\ref{dcl.init.aggr}). The closure type is declared in the smallest block
scope, class scope, or namespace scope that contains the corresponding
\grammarterm{lambda-expression}. \enternote This determines the set of namespaces and
classes associated with the closure type~(\ref{basic.lookup.argdep}). The parameter
types of a \grammarterm{lambda-declarator} do not affect these associated namespaces and
classes. \exitnote An implementation may define the closure type differently from what
is described below provided this does not alter the observable behavior of the program
other than by changing:

\begin{itemize}
\item the size and/or alignment of the closure type,

\item whether the closure type is trivially copyable (Clause~\ref{class}),

\item whether the closure type is a standard-layout class (Clause~\ref{class}),
or

\item whether the closure type is a POD class (Clause~\ref{class}).
\end{itemize}

An implementation shall not add members of rvalue reference type to the closure
type.

\pnum
If a \grammarterm{lambda-expression} does not include a
\grammarterm{lambda-declarator}, it is as if the \grammarterm{lambda-declarator} were
\tcode{()}. If a \grammarterm{lambda-expression} does not include a
\grammarterm{trailing-return-type}, it is as if the \grammarterm{trailing-return-type}
denotes the following type:

\begin{itemize}
\item if the \grammarterm{compound-statement} is of the form

\begin{ncbnf}
\terminal{\{} attribute-specifier-seq\opt \terminal{return} expression \terminal{;} \terminal{\}}
\end{ncbnf}

the type of the returned expression after lvalue-to-rvalue
conversion~(\ref{conv.lval}), array-to-pointer conversion~(\ref{conv.array}),
and function-to-pointer conversion~(\ref{conv.func});

\item otherwise, \tcode{void}.
\end{itemize}

\enterexample
\begin{codeblock}
auto x1 = [](int i){ return i; }; // OK: return type is \tcode{int}
auto x2 = []{ return { 1, 2 }; }; // error: the return type is \tcode{void} (a
                                  // \grammarterm{braced-init-list} is not an expression)
\end{codeblock}
\exitexample

\pnum
The closure type for a \grammarterm{lambda-expression} has a public
\tcode{inline} function call operator~(\ref{over.call}) whose parameters and return type
are described by the \grammarterm{lambda-expression}'s
\grammarterm{parameter-declaration-clause} and \grammarterm{trailing-return-type}
respectively. This function call operator is declared
\tcode{const}~(\ref{class.mfct.non-static}) if and only if the
\grammarterm{lambda-expression}'s \grammarterm{parameter-declaration-clause} is not
followed by \tcode{mutable}. It is neither virtual nor declared \tcode{volatile}. Default
arguments~(\ref{dcl.fct.default}) shall not be specified in the
\grammarterm{parameter-declaration-clause} of a \grammarterm{lambda-declarator}. Any
\grammarterm{exception-specification} specified on a \grammarterm{lambda-expression}
applies to the corresponding function call operator.
An \grammarterm{attribute-specifier-seq} in a \grammarterm{lambda-declarator} appertains
to the type of the corresponding function call operator. \enternote Names referenced in
the \grammarterm{lambda-declarator} are looked up in the context in which the
\grammarterm{lambda-expression} appears. \exitnote

\pnum
The closure type for a \grammarterm{lambda-expression} with no \grammarterm{lambda-capture}
has a public non-virtual non-explicit const conversion function to pointer to function having
the same parameter and return types as the closure type's function call operator. The
value returned by this conversion function shall be the address of a function that, when
invoked, has the same effect as invoking the closure type's function call operator.

\pnum
The \grammarterm{lambda-expression}'s \grammarterm{compound-statement} yields the
\grammarterm{function-body}~(\ref{dcl.fct.def}) of the function call operator, but for
purposes of name lookup~(\ref{basic.lookup}), determining the type and value of
\tcode{this}~(\ref{class.this}) and transforming \grammarterm{id-expression}{s}
referring to non-static class members into class member access expressions using
\tcode{(*this)}~(\ref{class.mfct.non-static}), the \grammarterm{compound-statement} is
considered in the context of the \grammarterm{lambda-expression}. \enterexample

\begin{codeblock}
struct S1 {
  int x, y;
  int operator()(int);
  void f() {
    [=]()->int {
      return operator()(this->x + y); // equivalent to \tcode{S1::operator()(this->x + (*this).y)}
                                      // \tcode{this} has type \tcode{S1*}
    };
  }
};
\end{codeblock}
\exitexample

\pnum
If a \grammarterm{lambda-capture} includes a \grammarterm{capture-default} that
is \tcode{\&}, the identifiers in the \grammarterm{lambda-capture} shall not be preceded
by \tcode{\&}. If a \grammarterm{lambda-capture} includes a
\grammarterm{capture-default} that is \tcode{=}, the \grammarterm{lambda-capture} shall
not contain \tcode{this} and each identifier it contains shall be preceded by
\tcode{\&}. An identifier or \tcode{this} shall not appear more than once in a
\grammarterm{lambda-capture}. \enterexample

\begin{codeblock}
struct S2 { void f(int i); };
void S2::f(int i) {
  [&, i]{ };    // OK
  [&, &i]{ };   // error: \tcode{i} preceded by \tcode{\&} when \tcode{\&} is the default
  [=, this]{ }; // error: \tcode{this} when \tcode{=} is the default
  [i, i]{ };    // error: \tcode{i} repeated
}
\end{codeblock}
\exitexample

\pnum
A \grammarterm{lambda-expression} whose smallest enclosing scope is a block
scope~(\ref{basic.scope.block}) is a \defn{local lambda expression}; any other
\grammarterm{lambda-expression} shall not have a \grammarterm{capture-list} in its
\grammarterm{lambda-introducer}. The \defn{reaching scope} of a local lambda expression
is the set of enclosing scopes up to and including the innermost enclosing function and
its parameters. \enternote This reaching scope includes any intervening
\grammarterm{lambda-expression}{s}. \exitnote

\pnum
The \grammarterm{identifiers} in a \grammarterm{capture-list} are looked up using the
usual rules for unqualified name lookup~(\ref{basic.lookup.unqual}); each such lookup
shall find a variable with automatic storage duration declared in
the reaching scope of the local lambda expression. An entity (i.e. a variable or
\tcode{this}) is said to be \defn{explicitly captured} if it appears in the
\grammarterm{lambda-expression}'s \grammarterm{capture-list}.

\pnum
If a \grammarterm{lambda-expression} has an associated \grammarterm{capture-default} and
its \grammarterm{compound-statement} odr-uses~(\ref{basic.def.odr}) \tcode{this} or a
variable with automatic storage duration and the odr-used entity is not explicitly
captured, then the odr-used entity is said to be \defn{implicitly captured}; such
entities shall be declared within the reaching scope of the lambda expression.
\enternote The implicit capture of an entity by a nested
\grammarterm{lambda-expression} can cause its implicit capture by the containing
\grammarterm{lambda-expression} (see below). Implicit odr-uses of \tcode{this} can result
in implicit capture. \exitnote

\pnum
An entity is \defn{captured} if it is captured explicitly or implicitly. An entity
captured by a \grammarterm{lambda-expression} is odr-used~(\ref{basic.def.odr}) in the scope
containing the \grammarterm{lambda-expression}. If \tcode{this} is captured by a local
lambda expression, its nearest enclosing function shall be a non-static member function.
If a \grammarterm{lambda-expression} odr-uses~(\ref{basic.def.odr}) \tcode{this} or a
variable with automatic storage duration from its reaching scope, that
entity shall be captured by the \grammarterm{lambda-expression}. If a
\grammarterm{lambda-expression} captures an entity and that entity is not defined or
captured in the immediately enclosing lambda expression or function, the program is
ill-formed. \enterexample
\begin{codeblock}
void f1(int i) {
  int const N = 20;
  auto m1 = [=]{
    int const M = 30;
    auto m2 = [i]{
      int x[N][M];              // OK: \tcode{N} and \tcode{M} are not odr-used
      x[0][0] = i;              // OK: \tcode{i} is explicitly captured by \tcode{m2}
                                // and implicitly captured by \tcode{m1}
    };
  };
  struct s1 {
    int f;
    void work(int n) {
      int m = n*n;
      int j = 40;
      auto m3 = [this,m] {
        auto m4 = [&,j] {       // error: \tcode{j} not captured by \tcode{m3}
          int x = n;            // error: \tcode{n} implicitly captured by \tcode{m4}
                                // but not captured by \tcode{m3}
          x += m;               // OK: \tcode{m} implicitly captured by \tcode{m4}
                                // and explicitly captured by \tcode{m3}
          x += i;               // error: \tcode{i} is outside of the reaching scope
          x += f;               // OK: \tcode{this} captured implicitly by \tcode{m4}
                                // and explicitly by \tcode{m3}
        };
      };
    }
  };
}
\end{codeblock}
\exitexample

\pnum
A \grammarterm{lambda-expression} appearing in a default argument shall not
implicitly or explicitly capture any entity. \enterexample

\begin{codeblock}
void f2() {
  int i = 1;
  void g1(int = ([i]{ return i; })());        // ill-formed
  void g2(int = ([i]{ return 0; })());        // ill-formed
  void g3(int = ([=]{ return i; })());        // ill-formed
  void g4(int = ([=]{ return 0; })());        // OK
  void g5(int = ([]{ return sizeof i; })());  // OK
}
\end{codeblock}
\exitexample

\pnum
An entity is \indexdefn{captured!by copy}\term{captured by copy} if it is implicitly captured and the
\grammarterm{capture-default} is \tcode{=} or if it is explicitly captured with a
capture that does not include an \tcode{\&}. For each entity captured by copy, an
unnamed non-static data member is declared in the closure type. The declaration order of
these members is unspecified. The type of such a data member is the type of the
corresponding captured entity if the entity is not a reference to an object, or the
referenced type otherwise. \enternote If the captured entity is a reference to a
function, the corresponding data member is also a reference to a function. \exitnote

\pnum
An entity is \indexdefn{captured!by reference}\term{captured by reference} if it is implicitly or explicitly
captured but not captured by copy. It is unspecified whether additional unnamed
non-static data members are declared in the closure type for entities captured by
reference.

\pnum
If a \grammarterm{lambda-expression} \tcode{m2} captures an entity and that entity is
captured by an immediately enclosing \grammarterm{lambda-expression}
\tcode{m1}, then
\tcode{m2}'s capture is transformed as follows:

\begin{itemize}
\item if \tcode{m1} captures the entity by copy,
\tcode{m2} captures the corresponding
non-static data member of \tcode{m1}'s closure type;

\item if \tcode{m1} captures the entity by reference,
\tcode{m2} captures the same
entity captured by \tcode{m1}.
\end{itemize}
\enterexample the nested lambda expressions and invocations below will output
\tcode{123234}.
\begin{codeblock}
int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
  auto m2 = [a, b, &c]() mutable {
    std::cout << a << b << c;
    a = 4; b = 4; c = 4;
  };
  a = 3; b = 3; c = 3;
  m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;
\end{codeblock}
\exitexample


\pnum
Every \grammarterm{id-expression} that is an odr-use~(\ref{basic.def.odr}) of an
entity captured by copy is transformed into an access to the corresponding unnamed data
member of the closure type.
\enternote An \grammarterm{id-expression} that is not an odr-use refers to
the original entity, never to a member of the closure type. Furthermore, such
an \grammarterm{id-expression} does not cause the implicit capture of the
entity. \exitnote
If \tcode{this} is captured, each odr-use of \tcode{this} is
transformed into an access to the corresponding unnamed data member of the closure type,
cast~(\ref{expr.cast}) to the type of \tcode{this}. \enternote The cast ensures that the
transformed expression is a prvalue. \exitnote \enterexample
\begin{codeblock}
void f(const int*);
void g() {
  const int N = 10;
  [=] {
    int arr[N];             // OK: not an odr-use, refers to automatic variable
    f(&N);                  // OK: causes \tcode{N} to be captured; \tcode{\&N} points to the
                            // corresponding member of the closure type
  };
}
\end{codeblock}
\exitexample

\pnum
Every occurrence of \tcode{decltype((x))} where \tcode{x} is a possibly
parenthesized \grammarterm{id-expression} that names an entity of automatic storage
duration is treated as if \tcode{x} were transformed into an access to a corresponding
data member of the closure type that would have been declared if \tcode{x} were an odr-use of
the denoted entity. \enterexample

\begin{codeblock}
void f3() {
  float x, &r = x;
  [=] {                     // \tcode{x} and \tcode{r} are not captured (appearance in a \tcode{decltype} operand is not an odr-use)
    decltype(x) y1;         // \tcode{y1} has type \tcode{float}
    decltype((x)) y2 = y1;  // \tcode{y2} has type \tcode{float const\&} because this lambda
                            // is not \tcode{mutable} and \tcode{x} is an lvalue
    decltype(r) r1 = y1;    // \tcode{r1} has type \tcode{float\&} (transformation not considered)
    decltype((r)) r2 = y2;  // \tcode{r2} has type \tcode{float const\&}
  };
}
\end{codeblock}
\exitexample

\pnum
The closure type associated with a \grammarterm{lambda-expression} has a
deleted~(\ref{dcl.fct.def.delete})
default constructor and a deleted copy assignment operator. It has an
implicitly-declared copy constructor~(\ref{class.copy})
and may have an implicitly-declared move constructor~(\ref{class.copy}).
\enternote The copy/move constructor
is implicitly defined in the same way as any other implicitly declared copy/move constructor
would be implicitly defined. \exitnote

\pnum
The closure type associated with a \grammarterm{lambda-expression} has an
implicitly-declared destructor~(\ref{class.dtor}).

\pnum
When the \grammarterm{lambda-expression} is evaluated, the entities that are
captured by copy are used to direct-initialize each corresponding non-static data member
of the resulting closure object. (For array members, the array elements are
direct-initialized in increasing subscript order.) These initializations are performed
in the (unspecified) order in which the non-static data members are declared. \enternote
This ensures that the destructions will occur in the reverse order of the constructions.
\exitnote

\pnum
\enternote If an entity is implicitly or explicitly captured by reference,
invoking the function call operator of the corresponding \grammarterm{lambda-expression}
after the lifetime of the entity has ended is likely to result in undefined behavior.
\exitnote

\pnum
A \grammarterm{capture} followed by an ellipsis is a pack expansion~(\ref{temp.variadic}).
\enterexample
\begin{codeblock}
template<class... Args>
void f(Args... args) {
  auto lm = [&, args...] { return g(args...); };
  lm();
}
\end{codeblock}
\exitexample%
\indextext{expression!lambda|)}%
\indextext{expression!primary|)}

\rSec1[expr.post]{Postfix expressions}%
\indextext{expression!postfix|(}

\pnum
Postfix expressions group left-to-right.

\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expression \terminal{]}\br
    postfix-expression \terminal{[} braced-init-list \terminal{]}\br
    postfix-expression \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
    typename-specifier \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier braced-init-list\br
    typename-specifier braced-init-list\br
    postfix-expression \terminal{. template}\opt id-expression\br
    postfix-expression \terminal{-> template}\opt id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{expression-list}\br
    initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{pseudo-destructor-name}\br
    nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name\br
    nested-name-specifier \terminal{template} simple-template-id \terminal{::\,\tilde} type-name\br
    nested-name-specifier\opt \terminal{\tilde} type-name\br
    \terminal{\tilde} decltype-specifier
\end{bnf}

\pnum
\enternote The \tcode{>} token following the
\nonterminal{type-id} in a \tcode{dynamic_cast},
\tcode{static_cast}, \tcode{reinterpret_cast}, or
\tcode{const_cast} may be the product of replacing a
\tcode{>{>}} token by two consecutive \tcode{>}
tokens~(\ref{temp.names}).\exitnote

\rSec2[expr.sub]{Subscripting}

\pnum
\indextext{operator!subscripting}%
\indextext{\idxcode{[]}|see{operator, subscripting}}%
A postfix expression followed by an expression in square brackets is a
postfix expression. One of the expressions shall have the type ``pointer
to \tcode{T}'' and the other shall have unscoped enumeration or integral type.
The result is an lvalue of type ``\tcode{T}.''
\indextext{type!incomplete}%
The type ``\tcode{T}'' shall be a completely-defined object type.\footnote{This
is true even if the subscript operator is used in the following common idiom:
\tcode{\&x[0]}.}
The expression \tcode{E1[E2]} is identical (by definition) to
\tcode{*((E1)+(E2))}
\enternote 
see~\ref{expr.unary} and~\ref{expr.add} for details of \tcode{*} and
\tcode{+} and~\ref{dcl.array} for details of arrays.
\exitnote 

\pnum
A \grammarterm{braced-init-list} shall not be used with the built-in subscript operator.

\rSec2[expr.call]{Function call}

\pnum
\indextext{expression!function~call}%
\indextext{operator!function~call}%
\indextext{\idxcode{()}|see{operator, function~call}}%
There are two kinds of function call: ordinary function call and member
function\footnote{A static member function~(\ref{class.static}) is an ordinary
function.}~(\ref{class.mfct}) call.
A function call is a postfix expression followed by parentheses
containing a possibly empty, comma-separated list of expressions which
constitute the arguments to the function. For an ordinary function call,
the postfix expression shall be either an lvalue that refers to a
function (in which case the function-to-pointer standard
conversion~(\ref{conv.func}) is suppressed on the postfix expression),
or it shall have pointer to function type. Calling a function through an
expression whose function type has a language linkage that is different
from the language linkage of the function type of the called function's
definition is undefined~(\ref{dcl.link}). For a member function call,
the postfix expression shall be an
implicit~(\ref{class.mfct.non-static},~\ref{class.static}) or explicit
class member access~(\ref{expr.ref}) whose \grammarterm{id-expression} is a
function member name, or a pointer-to-member
expression~(\ref{expr.mptr.oper}) selecting a function member; the call is as a member of
the class object referred to by the
object expression. In the case of an implicit class
member access, the implied object is the one pointed to by \tcode{this}.
\enternote 
a member function call of the form \tcode{f()} is interpreted as
\tcode{(*this).f()} (see~\ref{class.mfct.non-static}).
\exitnote 
If a function or member function name is used, the name can be
overloaded (Clause~\ref{over}), in which case the appropriate function
shall be selected according to the rules in~\ref{over.match}. If the selected
function is non-virtual, or if the \grammarterm{id-expression} in the class
member access expression is a \grammarterm{qualified-id}, that function is
called. Otherwise, its final overrider~(\ref{class.virtual}) in the dynamic type
of the object expression is called.
\enternote 
the dynamic type is the type of the object referred to by the
current value of the object expression. \ref{class.cdtor}~describes the
behavior of virtual function calls when the object expression
refers to
an object under construction or destruction.
\exitnote 

\pnum
\enternote
If a function or member function name is used, and name
lookup~(\ref{basic.lookup}) does not find a declaration of that name,
the program is ill-formed. No function is implicitly declared by such a
call.
\exitnote

\pnum
If the \grammarterm{postfix-expression} designates a destructor~(\ref{class.dtor}),
the type of the function call expression is \tcode{void}; otherwise, the
type of the function call expression is the return type of the
statically chosen function (i.e., ignoring the \tcode{virtual} keyword),
even if the type of the function actually called is different.
\indextext{type!incomplete}%
This return type shall be an object type, a reference type or \cv{}
\tcode{void}.

\pnum
\indextext{function~argument|see{argument}}%
\indextext{function~parameter|see{parameter}}%
\indextext{formal~argument|see{parameter}}%
\indextext{initialization!parameter}%
When a function is called, each parameter~(\ref{dcl.fct}) shall be
initialized~(\ref{dcl.init},~\ref{class.copy},~\ref{class.ctor}) with
its corresponding argument.
\enternote Such initializations are indeterminately sequenced
with respect to each other~(\ref{intro.execution}) \exitnote
If the function is a non-static member
function, the \tcode{this} parameter of the function~(\ref{class.this})
shall be initialized with a pointer to the object of the call, converted
as if by an explicit type conversion~(\ref{expr.cast}).
\enternote 
There is no access or ambiguity checking on this conversion; the access
checking and disambiguation are done as part of the (possibly implicit)
class member access operator.
See~\ref{class.member.lookup},~\ref{class.access.base},
and~\ref{expr.ref}.
\exitnote 
When a function is called, the parameters that have object type shall
have completely-defined object type.
\enternote 
this still allows a parameter to be a pointer or reference to an
incomplete class type. However, it prevents a passed-by-value parameter
to have an incomplete class type.
\exitnote 
During the initialization of a parameter, an implementation may avoid
the construction of extra temporaries by combining the conversions on
the associated argument and/or the construction of temporaries with the
initialization of the parameter (see~\ref{class.temporary}). The
lifetime of a parameter ends when the function in which it is defined
returns. The initialization and destruction of each parameter occurs
within the context of the calling function.
\enterexample 
the access of the constructor, conversion functions or destructor is
checked at the point of call in the calling function. If a constructor
or destructor for a function parameter throws an exception, the search
for a handler starts in the scope of the calling function; in
particular, if the function called has a \grammarterm{function-try-block}
(Clause~\ref{except}) with a handler that could handle the exception,
this handler is not considered.
\exitexample 
The value of a function call is the value returned by the called
function except in a virtual function call if the return type of the
final overrider is different from the return type of the statically
chosen function, the value returned from the final overrider is
converted to the return type of the statically chosen function.

\pnum
\enternote 
\indextext{type~checking!argument}%
\indextext{function~call}%
\indextext{argument~passing}%
\indextext{value!call~by}%
\indextext{reference!call~by}%
\indextext{argument!reference}%
a function can change the values of its non-const parameters, but these
changes cannot affect the values of the arguments except where a
parameter is of a reference type~(\ref{dcl.ref}); if the reference is to
a const-qualified type, \tcode{const_cast} is required to be used to
cast away the constness in order to modify the argument's value. Where a
parameter is of \tcode{const} reference type a temporary object is
introduced if
needed~(\ref{dcl.type},~\ref{lex.literal},~\ref{lex.string},~\ref{dcl.array},~\ref{class.temporary}).
In addition, it is possible to modify the values of nonconstant objects through
pointer parameters.
\exitnote 

\pnum
\indextext{declaration!ellipsis~in function}%
\indextext{parameter~list!variable}%
A function can be declared to accept fewer arguments (by declaring default
arguments~(\ref{dcl.fct.default})) or more arguments (by using the ellipsis,
\tcode{...}, or a function parameter pack~(\ref{dcl.fct})) than the number of
parameters in the function definition~(\ref{dcl.fct.def}).
\enternote 
this implies that, except where the ellipsis (\tcode{...}) or a function
parameter pack is used, a parameter is available for each argument.
\exitnote 

\pnum
\indextext{ellipsis!conversion~sequence}%
When there is no parameter for a given argument, the argument is passed
in such a way that the receiving function can obtain the value of the
argument by invoking \tcode{va_arg}~(\ref{support.runtime}).
\enternote This paragraph does not apply to arguments passed to a function parameter pack.
Function parameter packs are expanded during template instantiation~(\ref{temp.variadic}),
thus each such argument has a corresponding parameter when a function template
specialization is actually called. \exitnote
The
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the argument expression.
An argument that has (possibly cv-qualified) type \tcode{std::nullptr_t} is converted
to type \tcode{void*}~(\ref{conv.ptr}).
After these conversions, if the
argument does not have arithmetic, enumeration, pointer, pointer to
member, or class type, the program is ill-formed. Passing a potentially-evaluated
argument of class type (Clause~\ref{class}) having a non-trivial
copy constructor, a non-trivial move constructor,
or a
non-trivial destructor, with no corresponding parameter, is conditionally-supported with
\impldef{passing argument of class type through ellipsis} semantics. If the argument has
integral or enumeration type that is subject to the integral
promotions~(\ref{conv.prom}), or a floating point type that is subject to the floating
point promotion~(\ref{conv.fpprom}), the value of the argument is converted to the
promoted type before the call. These promotions are referred to as the \term{default
argument promotions}.

\pnum
\indextext{evaluation!order~of argument}%
\indextext{evaluation!unspecified order~of function~call}%
\enternote
The evaluations of the postfix expression and of the argument
expressions are all unsequenced relative to one another.
\indextext{evaluation!unspecified order~of argument}%
All side effects of
argument expression evaluations are sequenced before the function is
entered (see~\ref{intro.execution}).
\exitnote

\pnum
\indextext{function~call!recursive}%
Recursive calls are permitted, except to the function named
\tcode{main}~(\ref{basic.start.main}).

\pnum
A function call is an lvalue
if the result type is an lvalue reference type or an rvalue reference to function type,
an xvalue if the result type is an rvalue reference to object type, and a prvalue
otherwise.

\pnum
If a function call is a prvalue of object type:

\begin{itemize}
\item if the function call is either
\begin{itemize}
\item the operand of a \grammarterm{decltype-specifier} or
\item the right operand of a comma operator that is the operand of a
\grammarterm{decltype-specifier},
\end{itemize}
a temporary object is not introduced for the prvalue. The type of the prvalue
may be incomplete. \enternote as a result, storage is not allocated for the
prvalue and it is not destroyed; thus, a class type is not instantiated as a
result of being the type of a function call in this context. This is true
regardless of whether the expression uses function call notation or operator
notation~(\ref{over.match.oper}). \exitnote \enternote unlike the rule for
a \grammarterm{decltype-specifier} that considers whether an \grammarterm{id-expression}
is parenthesized~(\ref{dcl.type.simple}), parentheses have no special meaning
in this context. \exitnote

\item otherwise, the type of the prvalue shall be complete.
\end{itemize}

\rSec2[expr.type.conv]{Explicit type conversion (functional notation)}

\pnum
\indextext{expression!cast}
\indextext{explicit~type~conversion|see{casting}}%
\indextext{type~conversion,~explicit|see{casting}}%
\indextext{conversion~explicit~type|see{casting}}%
\indextext{casting}%
A \grammarterm{simple-type-specifier}~(\ref{dcl.type.simple}) or
\grammarterm{typename-specifier}~(\ref{temp.res}) followed by a
parenthesized \grammarterm{expression-list} constructs a value of the
specified type given the expression list. If the expression list is a
single expression, the type conversion expression is equivalent (in
definedness, and if defined in meaning) to the corresponding cast
expression~(\ref{expr.cast}).
\indextext{type!incomplete}%
If the type specified is a class type, the
class type shall be complete. If the expression list specifies more than
a single value, the type shall be a class with a suitably declared
constructor~(\ref{dcl.init},~\ref{class.ctor}), and the expression
\tcode{T(x1, x2, ...)} is equivalent in effect to the declaration
\tcode{T t(x1, x2, ...);} for some invented temporary variable
\tcode{t}, with the result being the value of \tcode{t} as a prvalue.

\pnum
The expression \tcode{T()}, where \tcode{T} is a
\grammarterm{simple-type-specifier} or \grammarterm{typename-specifier} for a non-array complete object
type or the (possibly cv-qualified) \tcode{void} type, creates a prvalue of the
specified type, whose value is that produced by
value-initializing~(\ref{dcl.init}) an object of type \tcode{T}; no
initialization is done for the \tcode{void()} case.
\enternote 
if \tcode{T} is a non-class type that is cv-qualified, the
\grammarterm{cv-qualifier}{s} are discarded when determining the type of the
resulting prvalue (Clause~\ref{expr}).
\exitnote 

\pnum
Similarly, a \grammarterm{simple-type-specifier} or
\grammarterm{typename-specifier} followed by a \grammarterm{braced-init-list}
creates a temporary object of the specified type
direct-list-initialized~(\ref{dcl.init.list}) with the specified
\grammarterm{braced-init-list}, and its value is that temporary object as a
prvalue.

\rSec2[expr.pseudo]{Pseudo destructor call}

\pnum
\indextext{expression!pseudo-destructor~call}
\indextext{call!pseudo~destructor}%
\indextext{pseudo-destructor-name}%
The use of a \grammarterm{pseudo-destructor-name} after a dot \tcode{.} or
arrow \tcode{->} operator represents the destructor for the non-class
type denoted by \grammarterm{type-name} or \grammarterm{decltype-specifier}.
The result shall only be used as the
operand for the function call operator \tcode{()}, and the result of
such a call has type \tcode{void}. The only effect is the evaluation of
the \grammarterm{postfix-expression} before the dot or arrow.

\pnum
The left-hand side of the dot operator shall be of scalar type. The
left-hand side of the arrow operator shall be of pointer to scalar type.
This scalar type is the object type. The \cvqual{cv}-unqualified
versions of the object type and of the type designated by the
\grammarterm{pseudo-destructor-name} shall be the same type. Furthermore,
the two \grammarterm{type-name}{s} in a \grammarterm{pseudo-destructor-name} of
the form

\begin{ncbnf}
nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name
\end{ncbnf}

shall designate the same scalar type.

\rSec2[expr.ref]{Class member access}

\pnum
\indextext{expression!class~member~access}%
\indextext{access control!class member}%
\indextext{syntax!class~member}%
\indextext{semantics!class~member}%
\indextext{operator!class~member~access}%
\indextext{\idxcode{.}|see{operator, class~member~access}}%
\indextext{dot~operator|see{operator, class~member~access}}%
\indextext{operator!class~member~access}%
\indextext{\idxcode{->}|see{operator, class~member~access}}%
\indextext{arrow~operator|see{operator, class~member~access}}%
A postfix expression followed by a dot \tcode{.} or an arrow \tcode{->},
optionally followed by the keyword
\tcode{template}~(\ref{temp.names}), and then followed by an
\grammarterm{id-expression}, is a postfix expression. The postfix
expression before the dot or arrow is evaluated;\footnote{If the class member
access expression is evaluated, the subexpression evaluation happens even if the
result is unnecessary to determine
the value of the entire postfix expression, for example if the
\grammarterm{id-expression} denotes a static member.}
the result of that evaluation, together with the
\grammarterm{id-expression}, determines the result of the entire postfix
expression.

\pnum
\indextext{type!incomplete}%
For the first option (dot) the first expression
shall have complete class type.
For the second option (arrow) the first expression
shall have pointer to complete class type. The expression \tcode{E1->E2} is
converted to the equivalent form \tcode{(*(E1)).E2}; the remainder of
\ref{expr.ref}~will address only the first option (dot).\footnote{Note that
\tcode{(*(E1))} is an lvalue.}
In either case, the
\grammarterm{id-expression} shall name a member of the class or of one of
its base classes.
\enternote 
because the name of a class is inserted in its class scope
(Clause~\ref{class}), the name of a class is also considered a nested
member of that class.
\exitnote 
\enternote
\ref{basic.lookup.classref} describes how names are looked up after the
\tcode{.} and \tcode{->} operators.
\exitnote 

\pnum
Abbreviating \term{postfix-expression.id-expression}
as \tcode{E1.E2},
\tcode{E1} is called the \defn{object expression}. The
type and value category of \tcode{E1.E2} are determined as follows.
In the remainder of~\ref{expr.ref}, \cvqual{cq} represents either
\tcode{const} or the absence of \tcode{const} and \cvqual{vq} represents
either \tcode{volatile} or the absence of \tcode{volatile}. \cvqual{cv}
represents an arbitrary set of cv-qualifiers, as defined
in~\ref{basic.type.qualifier}.

\pnum
If \tcode{E2} is declared to have type ``reference to \tcode{T},'' then
\tcode{E1.E2} is an lvalue; the type of \tcode{E1.E2} is \tcode{T}.
Otherwise, one of the following rules applies.

\begin{itemize}
\item If \tcode{E2} is a static data member and the type of \tcode{E2}
is \tcode{T}, then \tcode{E1.E2} is an lvalue; the expression designates
the named member of the class. The type of \tcode{E1.E2} is \tcode{T}.

\item If \tcode{E2} is a non-static data member and the type of
\tcode{E1} is ``\cvqual{cq1 vq1} \tcode{X}'', and the type of \tcode{E2}
is ``\cvqual{cq2 vq2} \tcode{T}'', the expression designates the named
member of the object designated by the first expression. If \tcode{E1}
is an lvalue, then \tcode{E1.E2} is an lvalue;
if \tcode{E1} is an xvalue, then \tcode{E1.E2} is an xvalue;
otherwise, it is a prvalue. Let the notation \cvqual{vq12} stand for the ``union'' of
\cvqual{vq1} and \cvqual{vq2}; that is, if \cvqual{vq1} or \cvqual{vq2}
is \tcode{volatile}, then \cvqual{vq12} is \tcode{volatile}. Similarly,
let the notation \cvqual{cq12} stand for the ``union'' of \cvqual{cq1}
and \cvqual{cq2}; that is, if \cvqual{cq1} or \cvqual{cq2} is
\tcode{const}, then \cvqual{cq12} is \tcode{const}. If \tcode{E2} is
declared to be a \tcode{mutable} member, then the type of \tcode{E1.E2}
is ``\cvqual{vq12} \tcode{T}''. If \tcode{E2} is not declared to be a
\tcode{mutable} member, then the type of \tcode{E1.E2} is
``\cvqual{cq12} \cvqual{vq12} \tcode{T}''.

\item If \tcode{E2} is a (possibly overloaded) member function, function
overload resolution~(\ref{over.match}) is used to determine whether
\tcode{E1.E2} refers to a static or a non-static member function.

\begin{itemize}
\item If it refers to a static member function and the type of
\tcode{E2} is ``function of parameter-type-list returning \tcode{T}'',
then \tcode{E1.E2} is an lvalue; the expression designates the static
member function. The type of \tcode{E1.E2} is the same type as that of
\tcode{E2}, namely ``function of parameter-type-list returning
\tcode{T}''.

\item Otherwise, if \tcode{E1.E2} refers to a non-static member
function and the type of \tcode{E2} is ``function of
parameter-type-list \cvqual{cv} \grammarterm{ref-qualifier\opt} returning \tcode{T}'', then
\tcode{E1.E2} is a prvalue. The expression designates a
non-static member function. The expression can be used only as the
left-hand operand of a member function call~(\ref{class.mfct}).
\enternote Any redundant set of parentheses surrounding the expression
is ignored~(\ref{expr.prim}). \exitnote The type of \tcode{E1.E2} is
``function of parameter-type-list \cvqual{cv} returning \tcode{T}''.
\end{itemize}

\item If \tcode{E2} is a nested type, the expression \tcode{E1.E2} is
ill-formed.

\item If \tcode{E2} is a member enumerator and the type of \tcode{E2}
is \tcode{T}, the expression \tcode{E1.E2} is a prvalue. The type of
\tcode{E1.E2} is \tcode{T}.
\end{itemize}

\pnum
If \tcode{E2} is a non-static data member or a non-static member
function, the program is ill-formed if the class of which \tcode{E2} is
directly a member is an ambiguous base~(\ref{class.member.lookup}) of
the naming class~(\ref{class.access.base}) of \tcode{E2}.
\enternote
The program is also ill-formed if the naming class is an ambiguous base of the class type
of the object expression; see~\ref{class.access.base}.
\exitnote

\rSec2[expr.post.incr]{Increment and decrement}

\pnum
\indextext{expression!increment}%
\indextext{operator!increment}%
\indextext{\idxcode{++}|see{operator, increment}}%
\indextext{postfix~\tcode{++}}%
The value of a postfix \tcode{++} expression is the value of its
operand.
\enternote 
the value obtained is a copy of the original value
\exitnote 
The operand shall be a modifiable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a complete object type. The value
of the operand object is modified by adding \tcode{1} to it,
\indextext{increment!\idxcode{bool}}%
\indextext{deprecated~features}%
unless the object is of type \tcode{bool}, in which case it is set to
\tcode{true}.
\enternote 
this use is deprecated, see Annex~\ref{depr}.
\exitnote 
The
\indextext{value computation}%
value computation of the \tcode{++} expression is sequenced before the
modification of the operand object. With respect to an
indeterminately-sequenced function call, the operation of postfix
\tcode{++} is
a single evaluation.
\enternote
Therefore, a function call shall not intervene between the
lvalue-to-rvalue conversion and the side effect associated with any
single postfix ++ operator.
\exitnote
The result is a prvalue. The type of the result is the cv-unqualified
version of the type of the operand. See also~\ref{expr.add}
and~\ref{expr.ass}.

\pnum
\indextext{expression!decrement}%
\indextext{operator!decrement}%
\indextext{\idxcode{\dcr}|see{operator, decrement}}%
\indextext{postfix~\tcode{\dcr}}%
The operand of postfix \tcode{\dcr} is decremented analogously to the
postfix \tcode{++} operator, except that the operand shall not be of
type \tcode{bool}.
\enternote 
For prefix increment and decrement, see~\ref{expr.pre.incr}.
\exitnote 

\rSec2[expr.dynamic.cast]{Dynamic cast}

\pnum
\indextext{expression!dynamic~cast}%
\indextext{cast!dynamic}%
The result of the expression \tcode{dynamic_cast<T>(v)} is the result of
converting the expression \tcode{v} to type \tcode{T}.
\indextext{type!incomplete}%
\tcode{T} shall be a pointer or reference to a complete class type, or
``pointer to \cvqual{cv} \tcode{void}.'' The \tcode{dynamic_cast} operator shall not cast
away constness~(\ref{expr.const.cast}).

\pnum
If \tcode{T} is a pointer type, \tcode{v} shall be a prvalue of a
pointer to complete class type, and the result is a prvalue of type
\tcode{T}. If \tcode{T} is an lvalue reference type, \tcode{v} shall be
an lvalue of a complete class type, and the result is an lvalue of the
type referred to by \tcode{T}. If \tcode{T} is an rvalue reference type,
\tcode{v} shall be an expression having a complete class type, and the
result is an xvalue of the type referred to by \tcode{T}.

\pnum
If the type of \tcode{v} is the same as \tcode{T}, or it is
the same as \tcode{T} except that the class object type in \tcode{T} is
more cv-qualified than the class object type in \tcode{v}, the result is
\tcode{v} (converted if necessary).

\pnum
If the value of \tcode{v} is a null pointer value in the pointer case,
the result is the null pointer value of type \tcode{T}.

\pnum
If \tcode{T} is ``pointer to \cvqual{cv1} \tcode{B}'' and \tcode{v} has
type ``pointer to \cvqual{cv2} \tcode{D}'' such that \tcode{B} is a base
class of \tcode{D}, the result is a pointer to the unique \tcode{B}
subobject of the \tcode{D} object pointed to by \tcode{v}. Similarly, if
\tcode{T} is ``reference to \cvqual{cv1} \tcode{B}'' and \tcode{v} has
type \cvqual{cv2} \tcode{D} such that \tcode{B} is a base class of
\tcode{D}, the result is the unique \tcode{B} subobject of the \tcode{D}
object referred to by \tcode{v}.
\footnote{The most derived object~(\ref{intro.object}) pointed or referred to by
\tcode{v} can contain other \tcode{B} objects as base classes, but these
are ignored.}
The result is an lvalue if \tcode{T} is an lvalue reference, or an
xvalue if \tcode{T} is an rvalue reference. In both the pointer and
reference cases, the program is ill-formed if \cvqual{cv2} has greater
cv-qualification than \cvqual{cv1} or if \tcode{B} is an inaccessible or
ambiguous base class of \tcode{D}.
\enterexample 

\begin{codeblock}
struct B { };
struct D : B { };
void foo(D* dp) {
  B*  bp = dynamic_cast<B*>(dp);    // equivalent to \tcode{B* bp = dp;}
}
\end{codeblock}
\exitexample 

\pnum
Otherwise, \tcode{v} shall be a pointer to or a glvalue of a polymorphic
type~(\ref{class.virtual}).

\pnum
If \tcode{T} is ``pointer to \cvqual{cv} \tcode{void},'' then the result
is a pointer to the most derived object pointed to by \tcode{v}.
Otherwise, a run-time check is applied to see if the object pointed or
referred to by \tcode{v} can be converted to the type pointed or
referred to by \tcode{T}.

\pnum
If \tcode{C} is the class type to which \tcode{T} points or refers, the run-time
check logically executes as follows:

\begin{itemize}
\item If, in the most derived object pointed (referred) to by \tcode{v},
\tcode{v} points (refers) to a \tcode{public} base class subobject of a
\tcode{C} object, and if only one object of type \tcode{C} is derived
from the subobject pointed (referred) to by \tcode{v} the result points (refers) to that \tcode{C} object.

\item Otherwise, if \tcode{v} points (refers) to a \tcode{public} base
class subobject of the most derived object, and the type of the most
derived object has a base class, of type \tcode{C}, that is unambiguous
and \tcode{public}, the result points (refers) to the
\tcode{C} subobject of the most derived object.

\item Otherwise, the
run-time check \term{fails}.
\end{itemize}

\pnum
The value of a failed cast to pointer type is the null pointer value of
the required result type. A failed cast to reference type throws
an exception~(\ref{except.throw}) of a type that would match a
handler~(\ref{except.handle}) of type \tcode{std::bad_cast}~(\ref{bad.cast}).

\indextext{\idxcode{bad_cast}}%
\indexlibrary{\idxcode{bad_cast}}%
\enterexample 

\begin{codeblock}
class A { virtual void f(); };
class B { virtual void g(); };
class D : public virtual A, private B { };
void g() {
  D   d;
  B*  bp = (B*)&d;                  // cast needed to break protection
  A*  ap = &d;                      // public derivation, no cast needed
  D&  dr = dynamic_cast<D&>(*bp);   // fails
  ap = dynamic_cast<A*>(bp);        // fails
  bp = dynamic_cast<B*>(ap);        // fails
  ap = dynamic_cast<A*>(&d);        // succeeds
  bp = dynamic_cast<B*>(&d);        // ill-formed (not a run-time check)
}

class E : public D, public B { };
class F : public E, public D { };
void h() {
  F   f;
  A*  ap  = &f;                     // succeeds: finds unique \tcode{A}
  D*  dp  = dynamic_cast<D*>(ap);   // fails: yields \tcode{0}
                                    // \tcode{f} has two \tcode{D} subobjects
  E*  ep  = (E*)ap;                 // ill-formed: cast from virtual base
  E*  ep1 = dynamic_cast<E*>(ap);   // succeeds
}
\end{codeblock}
\exitexample 
\enternote
\ref{class.cdtor} describes the behavior of a \tcode{dynamic_cast}
applied to an object under construction or destruction.
\exitnote 

\rSec2[expr.typeid]{Type identification}

\pnum
\indextext{expression!type~identification}%
\indextext{\idxcode{typeid}}%
The result of a \tcode{typeid} expression is an lvalue of static type
\indextext{\idxcode{type_info}}%
\indexlibrary{\idxcode{type_info}}%
\tcode{const} \tcode{std::type_info}~(\ref{type.info}) and dynamic type \tcode{const}
\tcode{std::type_info} or \tcode{const} \term{name} where \term{name} is an
\impldef{derived type for \tcode{typeid}} class publicly derived from
\tcode{std\,::\,type_info} which preserves the behavior described
in~\ref{type.info}.\footnote{The recommended name for such a class is
\tcode{extended_type_info}.}
The lifetime of the object referred to by the lvalue extends to the end
of the program. Whether or not the destructor is called for the
\tcode{std::type_info} object at the end of the program is unspecified.

\pnum
When \tcode{typeid} is applied to a glvalue expression whose type is a
polymorphic class type~(\ref{class.virtual}), the result refers to a
\tcode{std::type_info} object representing the type of the most derived
object~(\ref{intro.object}) (that is, the dynamic type) to which the
glvalue refers. If the glvalue expression is obtained by applying the
unary \tcode{*} operator to a pointer\footnote{If \tcode{p} is an expression of
pointer type, then \tcode{*p},
\tcode{(*p)}, \tcode{*(p)}, \tcode{((*p))}, \tcode{*((p))}, and so on
all meet this requirement.}
and the pointer is a null pointer value~(\ref{conv.ptr}), the
\tcode{typeid} expression throws an exception~(\ref{except.throw}) of
a type that would match a handler of type
\indextext{\idxcode{bad_typeid}}%
\indexlibrary{\idxcode{bad_typeid}}%
\tcode{std::bad_typeid}
exception~(\ref{bad.typeid}).

\pnum
When \tcode{typeid} is applied to an expression other than a glvalue of
a polymorphic class type, the result refers to a \tcode{std::type_info}
object representing the static type of the expression.
Lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) conversions are not applied to
the expression.
\indextext{type!incomplete}%
If the type of the expression is a class type, the class shall be
completely-defined. The expression is an unevaluated operand
(Clause~\ref{expr}).

\pnum
When \tcode{typeid} is applied to a \grammarterm{type-id}, the result
refers to a \tcode{std::type_info} object representing the type of the
\grammarterm{type-id}. If the type of the \grammarterm{type-id} is a reference
to a possibly \cvqual{cv}-qualified type, the result of the
\tcode{typeid} expression refers to a \tcode{std::type_info} object
representing the \cvqual{cv}-unqualified referenced type. If the type of
the \grammarterm{type-id} is a class type or a reference to a class type,
the class shall be completely-defined.

\pnum
If the type of the expression or \grammarterm{type-id} is a
cv-qualified type, the result of the \tcode{typeid} expression refers
to a \tcode{std::type_info} object representing the cv-unqualified
type.
\enterexample 

\begin{codeblock}
class D @\tcode{\{ /* ... */ \}}@;
D d1;
const D d2;

typeid(d1) == typeid(d2);       // yields \tcode{true}
typeid(D)  == typeid(const D);  // yields \tcode{true}
typeid(D)  == typeid(d2);       // yields \tcode{true}
typeid(D)  == typeid(const D&); // yields \tcode{true}
\end{codeblock}
\exitexample 

\pnum
If the header \tcode{<typeinfo>}~(\ref{type.info}) is not included prior
to a use of \tcode{typeid}, the program is ill-formed.

\pnum
\enternote
\ref{class.cdtor} describes the behavior of \tcode{typeid} applied to an
object under construction or destruction.
\exitnote 

\rSec2[expr.static.cast]{Static cast}

\pnum
\indextext{expression!static~cast}%
\indextext{cast!static}%
The result of the expression \tcode{static_cast<T>(v)} is the result of
converting the expression \tcode{v} to type \tcode{T}.
\indextext{cast!static!lvalue}%
\indextext{cast!lvalue}%
If \tcode{T} is an lvalue reference type
or an rvalue reference to function type, the result is an lvalue;
if \tcode{T} is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue. The \tcode{static_cast} operator shall not cast
away constness~(\ref{expr.const.cast}).

\pnum
\indextext{cast!static!reference}%
\indextext{cast!reference}%
An lvalue of type ``\cvqual{cv1} \tcode{B},'' where \tcode{B} is a class
type, can be cast to type ``reference to \cvqual{cv2} \tcode{D},'' where
\tcode{D} is a class derived (Clause~\ref{class.derived}) from
\tcode{B}, if a valid standard conversion from ``pointer to \tcode{D}''
to ``pointer to \tcode{B}'' exists~(\ref{conv.ptr}), \cvqual{cv2} is the
same cv-qualification as, or greater cv-qualification than,
\cvqual{cv1}, and \tcode{B} is neither a virtual base class of \tcode{D}
nor a base class of a virtual base class of \tcode{D}. The result has
type ``\cvqual{cv2} \tcode{D}.'' An xvalue of type
``\cvqual{cv1} \tcode{B}'' may be cast to type ``rvalue reference to
\cvqual{cv2} \tcode{D}'' with the same constraints as for an lvalue of
type ``\cvqual{cv1} \tcode{B}.'' If the object
of type ``\cvqual{cv1} \tcode{B}'' is actually a subobject of an object
of type \tcode{D}, the result refers to the enclosing object of type
\tcode{D}. Otherwise, the behavior is undefined.
\enterexample 

\begin{codeblock}
struct B { };
struct D : public B { };
D d;
B &br = d;

static_cast<D&>(br);            // produces lvalue to the original \tcode{d} object
\end{codeblock}
\exitexample 

\pnum
A glvalue of type ``\cvqual{cv1} \tcode{T1}'' can be cast to type ``rvalue
reference to \cvqual{cv2} \tcode{T2}'' if ``\cvqual{cv2} \tcode{T2}'' is
reference-compatible with ``\cvqual{cv1}
\tcode{T1}''~(\ref{dcl.init.ref}). If the glvalue is not a bit-field,
the result refers to the object or the specified base class subobject
thereof; otherwise, the lvalue-to-rvalue conversion~(\ref{conv.lval})
is applied to the bit-field and the resulting prvalue is used as the
\grammarterm{expression} of the \tcode{static_cast} for the remainder of this section.
If \tcode{T2} is an inaccessible (Clause~\ref{class.access}) or
ambiguous~(\ref{class.member.lookup}) base class of \tcode{T1},
a program that necessitates such a cast is ill-formed.

\pnum
An expression \tcode{e} can be explicitly converted to a type
\tcode{T} using a \tcode{static_cast} of the form
\tcode{static_cast<T>(e)} if the declaration \tcode{T t(e);} is
well-formed, for some invented temporary variable
\tcode{t}~(\ref{dcl.init}). The effect of such an explicit conversion is
the same as performing the declaration and initialization and then using
the temporary variable as the result of the conversion. The expression
\tcode{e} is used as a glvalue if and
only if the initialization uses it as a glvalue.

\pnum
Otherwise, the \tcode{static_cast} shall perform one of the conversions
listed below. No other conversion shall be performed explicitly using a
\tcode{static_cast}.

\pnum
Any expression can be explicitly converted to type \cv\
\tcode{void}, in which case it becomes a discarded-value
expression (Clause~\ref{expr}).
\enternote 
however, if the value is in a temporary
object~(\ref{class.temporary}), the destructor for that
object is
not executed until the usual time, and the value of the object is
preserved for the purpose of executing the destructor.
\exitnote 


\pnum
The inverse of any standard conversion sequence (Clause~\ref{conv}) not containing an
lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}),
function-to-pointer~(\ref{conv.func}),
null pointer~(\ref{conv.ptr}), null member pointer~(\ref{conv.mem}), or
boolean~(\ref{conv.bool})
conversion, can be performed explicitly using \tcode{static_cast}. A
program is ill-formed if it uses \tcode{static_cast} to perform the
inverse of an ill-formed standard conversion sequence.
\enterexample
\begin{codeblock}
struct B { };
struct D : private B { };
void f() {
  static_cast<D*>((B*)0);               // Error: B is a private base of D.
  static_cast<int B::*>((int D::*)0);   // Error: B is a private base of D.
}
\end{codeblock}
\exitexample

\pnum
The lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) conversions are applied to the
operand. Such a \tcode{static_cast} is subject to the restriction that
the explicit conversion does not cast away
constness~(\ref{expr.const.cast}), and the following additional rules
for specific cases:

\pnum
A value of a scoped enumeration type~(\ref{dcl.enum}) can be explicitly converted to an
integral type. The value is unchanged if the original value can be represented by the
specified type. Otherwise, the resulting value is unspecified.
A value of a scoped enumeration type can also be explicitly converted to a
floating-point type; the result is the same as that of converting from the original
value to the floating-point type.

\pnum
\indextext{enumeration~type!conversion~to}%
\indextext{enumeration~type!\idxcode{static_cast}!conversion~to}%
A value of integral or enumeration type can be explicitly converted to
an enumeration type. The value is unchanged if the original value is
within the range of the enumeration values~(\ref{dcl.enum}). Otherwise,
the resulting value is unspecified (and might not be
in that range).
A value of floating-point type can also be converted to an enumeration type.
The resulting value is the same as converting the original value to the
underlying type of the enumeration~(\ref{conv.fpint}), and subsequently to
the enumeration type.

\pnum
\indextext{cast!base~class}%
\indextext{cast!derived~class}%
A prvalue of type ``pointer to \cvqual{cv1} \tcode{B},'' where \tcode{B}
is a class type, can be converted to a prvalue of type ``pointer to
\cvqual{cv2} \tcode{D},'' where \tcode{D} is a class derived
(Clause~\ref{class.derived}) from \tcode{B}, if a valid standard
conversion from ``pointer to \tcode{D}'' to ``pointer to \tcode{B}''
exists~(\ref{conv.ptr}), \cvqual{cv2} is the same cv-qualification as,
or greater cv-qualification than, \cvqual{cv1}, and \tcode{B} is neither
a virtual base class of \tcode{D} nor a base class of a virtual base
class of \tcode{D}. The null pointer value~(\ref{conv.ptr}) is converted
to the null pointer value of the destination type. If the prvalue of type
``pointer to \cvqual{cv1} \tcode{B}'' points to a \tcode{B} that is
actually a subobject of an object of type \tcode{D}, the resulting
pointer points to the enclosing object of type \tcode{D}. Otherwise, the
result of the cast is undefined.

\pnum
\indextext{cast!pointer-to-member}%
A prvalue of type ``pointer to member of \tcode{D} of type \cvqual{cv1}
\tcode{T}'' can be converted to a prvalue of type ``pointer to member of
\tcode{B}'' of type \cvqual{cv2} \tcode{T}, where \tcode{B} is a base
class (Clause~\ref{class.derived}) of \tcode{D}, if a valid standard
conversion from ``pointer to member of \tcode{B} of type \tcode{T}'' to
``pointer to member of \tcode{D} of type \tcode{T}''
exists~(\ref{conv.mem}), and \cvqual{cv2} is the same cv-qualification
as, or greater cv-qualification than, \cvqual{cv1}.\footnote{Function types
(including those used in pointer to member function
types) are never cv-qualified; see~\ref{dcl.fct}.}
The null member pointer value~(\ref{conv.mem}) is converted to the null
member pointer value of the destination type. If class \tcode{B}
contains the original member, or is a base or derived class of the class
containing the original member, the resulting pointer to member points
to the original member. Otherwise, the result of the cast is undefined.
\enternote 
although class \tcode{B} need not contain the original member, the
dynamic type of the object with which indirection through the pointer
to member is performed must contain the original member;
see~\ref{expr.mptr.oper}.
\exitnote 

\pnum
A prvalue of type ``pointer to \cvqual{cv1} \tcode{void}'' can be
converted to a prvalue of type ``pointer to \cvqual{cv2} \tcode{T},''
where \tcode{T} is an object type and \cvqual{cv2} is the same
cv-qualification as, or greater cv-qualification than, \cvqual{cv1}. The
null pointer value is converted to the null pointer value of the
destination type. A value of type pointer to object converted to
``pointer to \cvqual{cv} \tcode{void}'' and back, possibly with
different cv-qualification, shall have its original value.
\enterexample

\begin{codeblock}
T* p1 = new T;
const T* p2 = static_cast<const T*>(static_cast<void*>(p1));
bool b = p1 == p2;  // \tcode{b} will have the value \tcode{true}.
\end{codeblock}
\exitexample

\rSec2[expr.reinterpret.cast]{Reinterpret cast}

\pnum
\indextext{expression!reinterpret~cast}
\indextext{cast!reinterpret}%
The result of the expression \tcode{reinterpret_cast<T>(v)} is the
result of converting the expression \tcode{v} to type \tcode{T}.
\indextext{cast!reinterpret!lvalue}%
\indextext{cast!lvalue}%
If \tcode{T} is an lvalue reference type or an rvalue reference to function type, the result is an lvalue;
if \tcode{T} is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue and the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the expression \tcode{v}. Conversions that can be performed explicitly
using \tcode{reinterpret_cast} are listed below. No other conversion can
be performed explicitly using \tcode{reinterpret_cast}.

\pnum
The \tcode{reinterpret_cast} operator shall not cast away constness~(\ref{expr.const.cast}).
An expression of integral, enumeration, pointer, or pointer-to-member type
can be explicitly converted to its own type; such a cast yields the value of
its operand.

\pnum
\enternote 
The mapping performed by \tcode{reinterpret_cast} might, or might not, produce a
representation different from the original value.
\exitnote 

\pnum
\indextext{cast!reinterpret!pointer to integer}%
\indextext{cast!pointer~to integer}%
A pointer can be explicitly converted to any integral type large enough
to hold it.
\indextext{conversion!implementation~defined pointer integer}%
The mapping function is implementa\-tion-defined.
\enternote
It is intended to be unsurprising to those who know the addressing
structure of the underlying machine.
\exitnote A value of type \tcode{std::nullptr_t} can be converted to an integral
type; the conversion has the same meaning and validity as a conversion of
\tcode{(void*)0} to the integral type. \enternote A \tcode{reinterpret_cast}
cannot be used to convert a value of any type to the type
\tcode{std::nullptr_t}. \exitnote

\pnum
\indextext{cast!reinterpret!integer~to pointer}%
\indextext{cast!integer~to pointer}%
A value of integral type or enumeration type can be explicitly converted
to a pointer. A pointer converted to an integer of sufficient size (if
any such exists on the implementation) and back to the same pointer type
will have its original value;
\indextext{conversion!implementation~defined pointer integer}%
mappings between pointers and integers are otherwise
\impldef{conversions between pointers and integers}.
\enternote Except as described in \ref{basic.stc.dynamic.safety}, the result of
such a conversion will not be a safely-derived pointer value. \exitnote

\pnum
\indextext{cast!reinterpret!pointer-to-function}%
\indextext{cast!pointer-to-function}%
\indextext{cast!undefined pointer-to-function}%
A function pointer can be explicitly converted
to a function pointer of a different type.
\indextext{function~call!undefined}%
The effect of calling a function through a pointer to a function
type~(\ref{dcl.fct}) that is not the same as the type used in the
definition of the function is undefined. Except that converting
a prvalue of type ``pointer to \tcode{T1}'' to the type ``pointer to
\tcode{T2}'' (where \tcode{T1} and \tcode{T2} are function types) and
back to its original type yields the original pointer value, the result
of such a pointer conversion is unspecified.
\enternote 
see also~\ref{conv.ptr} for more details of pointer conversions.
\exitnote 

\pnum
An object pointer
can be explicitly converted to an object pointer of a different type.\footnote{The
types may have different \cv-qualifiers, subject to
the overall
restriction that a \tcode{reinterpret_cast} cannot cast away constness.}
When a prvalue \tcode{v} of type ``pointer to \tcode{T1}'' is converted to
the type ``pointer to \cv\ \tcode{T2}'', the result is \tcode{static_cast<\cv\ T2*>(static_cast<\cv\
void*>(v))} if both \tcode{T1} and \tcode{T2} are standard-layout types~(\ref{basic.types}) and the
alignment requirements of \tcode{T2} are no stricter than those of
\tcode{T1}, or if either type is \tcode{void}.
Converting a prvalue of type ``pointer to \tcode{T1}'' to
the type ``pointer to \tcode{T2}'' (where \tcode{T1} and \tcode{T2} are
object types and where the alignment requirements of \tcode{T2} are no
stricter than those of \tcode{T1}) and back to its original type yields
the original pointer value. The result of any other such pointer conversion is
unspecified.

\pnum
Converting a function pointer to an object pointer
type or vice versa is
conditionally-supported. The meaning of such a conversion is
\impldef{converting function pointer to object pointer and vice versa},
except that if an implementation
supports conversions in both directions, converting a prvalue of one type to the other
type and back, possibly with different cv-qualification, shall yield the original
pointer value.

\pnum
The null pointer value~(\ref{conv.ptr}) is converted to the null pointer value
of the destination type.
\enternote
A null pointer constant of type \tcode{std::nullptr_t} cannot be converted to a
pointer type, and a null pointer constant of integral type is not necessarily
converted to a null pointer value.
\exitnote

\pnum
\indextext{cast!reinterpret!pointer-to-member}%
\indextext{cast!pointer-to-member}%
A prvalue of type ``pointer to member of \tcode{X} of type \tcode{T1}''
can be explicitly converted to a prvalue of a different type ``pointer to member of
\tcode{Y} of type \tcode{T2}'' if \tcode{T1} and \tcode{T2} are both
function types or both object types.\footnote{\tcode{T1} and \tcode{T2} may have
different \cv-qualifiers, subject to
the overall restriction that a \tcode{reinterpret_cast} cannot cast away
constness.} The null member pointer value~(\ref{conv.mem}) is converted to the
null member pointer value of the destination type. The result of this
conversion is unspecified, except in the following cases:

\begin{itemize}
\item converting a prvalue of type ``pointer to member function'' to a
different pointer to member function type and back to its original type
yields the original pointer to member value.

\item converting a prvalue of type ``pointer to data member of \tcode{X}
of type \tcode{T1}'' to the type ``pointer to data member of \tcode{Y}
of type \tcode{T2}'' (where the alignment requirements of \tcode{T2} are
no stricter than those of \tcode{T1}) and back to its original type
yields the original pointer to member value.
\end{itemize}

\pnum
\indextext{cast!reinterpret!reference}%
\indextext{cast!reference}%
A glvalue expression of type \tcode{T1} can be cast to the type
``reference to \tcode{T2}'' if an expression of type ``pointer to
\tcode{T1}'' can be explicitly converted to the type ``pointer to
\tcode{T2}'' using a \tcode{reinterpret_cast}. The result refers to
the same object as the source glvalue, but with the specified
type. \enternote That is, for lvalues, a reference cast
\tcode{reinterpret_cast<T\&>(x)} has the same effect as the conversion
\tcode{*reinterpret_cast<T*>(\&x)} with the built-in \tcode{\&} and
\tcode{*} operators (and similarly for
\tcode{reinterpret_cast<T\&\&>(x)}). \exitnote No
temporary is created, no copy is made, and
constructors~(\ref{class.ctor}) or conversion
functions~(\ref{class.conv}) are not called.\footnote{\indextext{type~pun}This
is sometimes referred to as a \term{type pun}.}

\rSec2[expr.const.cast]{Const cast}

\pnum
\indextext{expression!const~cast}%
\indextext{cast!const}%
The result of the expression \tcode{const_cast<T>(v)} is of type
\tcode{T}. If \tcode{T} is an lvalue reference to object type, the result is an
lvalue;
if \tcode{T} is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue and the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the expression \tcode{v}. Conversions that can be performed explicitly using
\tcode{const_cast} are listed below. No other conversion shall be
performed explicitly using \tcode{const_cast}.

\pnum
\enternote 
Subject to the restrictions in this section, an expression may be cast
to its own type using a \tcode{const_cast} operator.
\exitnote 

\pnum
For two pointer types \tcode{T1} and \tcode{T2} where

\begin{indented}
\term{T1} is $\mathit{cv}_{1,0}$ pointer to $\mathit{cv}_{1,1}$ pointer
to $\cdots \mathit{cv}_{1,n-1}$ pointer to $\mathit{cv}_{1,n}$ \term{T}
\end{indented}

and

\begin{indented}
\term{T2} is $\mathit{cv}_{2,0}$ pointer to $\mathit{cv}_{2,1}$ pointer
to $\cdots \mathit{cv}_{2,n-1}$ pointer to $\mathit{cv}_{2,n}$ \term{T}
\end{indented}

where
\tcode{T} is any object type or the \tcode{void} type and where
$\mathit{cv}_{1,k}$ and $\mathit{cv}_{2,k}$ may be different
cv-qualifications, a prvalue of type \tcode{T1} may be explicitly
converted to the type \tcode{T2} using a \tcode{const_cast}. The result
of a pointer \tcode{const_cast} refers to the original object.

\pnum
For two object types \tcode{T1} and \tcode{T2}, if a pointer to \tcode{T1} can
be explicitly converted to the type ``pointer to \tcode{T2}'' using a
\tcode{const_cast}, then the following conversions can also be made:

\begin{itemize}
\item an lvalue of type \tcode{T1} can be explicitly converted to an lvalue
of type \tcode{T2} using the cast \tcode{const_cast<T2\&>};

\item a glvalue of type \tcode{T1} can be explicitly converted to an xvalue
of type \tcode{T2} using the cast \tcode{const_cast<T2\&\&>}; and

\item if \tcode{T1} is a class type, a prvalue of type \tcode{T1} can be
explicitly converted to an xvalue of type \tcode{T2} using the cast
\tcode{const_cast<T2\&\&>}.
\end{itemize}

The result of a reference \tcode{const_cast} refers
to the original object.

\pnum
For a \tcode{const_cast} involving pointers to data members, multi-level
pointers to data members and multi-level mixed pointers and pointers to
data members~(\ref{conv.qual}), the rules for \tcode{const_cast} are the
same as those used for pointers; the ``member'' aspect of a pointer to
member is ignored when determining where the cv-qualifiers are added or
removed by the \tcode{const_cast}. The result of a pointer to data
member \tcode{const_cast} refers to the same member as the original
(uncast) pointer to data member.

\pnum
A null pointer value~(\ref{conv.ptr}) is converted to the null pointer
value of the destination type. The null member pointer
value~(\ref{conv.mem}) is converted to the null member pointer value of
the destination type.

\pnum
\enternote 
Depending on the type of the object, a write operation through the
pointer, lvalue or pointer to data member resulting from a
\tcode{const_cast} that casts away a const-qualifier\footnote{\tcode{const_cast}
is not limited to conversions that cast away a
const-qualifier.}
may produce undefined behavior~(\ref{dcl.type.cv}).
\exitnote 

\pnum
The following rules define the process known as \term{casting away
constness}. In these rules \tcode{T\term{n} } and \tcode{X\term{n} }
represent types. For two pointer types:

\begin{indented}
\tcode{X1} is \tcode{T1}$\mathit{cv}_{1,1}$ \tcode{*} $\cdots$
$\mathit{cv}_{1,N}$ \tcode{*} where \tcode{T1} is not a pointer type
\end{indented}

\begin{indented}
\tcode{X2} is \tcode{T2}$\mathit{cv}_{2,1}$ \tcode{*} $\cdots$
$\mathit{cv}_{2,M}$ \tcode{*} where \tcode{T2} is not a pointer type
\end{indented}

\begin{indented}
$K$ is $\min (N,M)$
\end{indented}

casting from \tcode{X1} to \tcode{X2} casts away constness if, for a
non-pointer type \tcode{T} there does not exist an implicit conversion
(Clause~\ref{conv}) from:

\begin{indented}
\tcode{T}$\mathit{cv}_{1,(N-K+1)}$ \tcode{*} $\mathit{cv}_{1,(N-K+2)}$
\tcode{*} $\cdots$ $\mathit{cv}_{1,N}$ \tcode{*}
\end{indented}

to

\begin{indented}
\tcode{T}$\mathit{cv}_{2,(M-K+1)}$ \tcode{*} $\mathit{cv}_{2,(M-K+2)}$
\tcode{*} $\cdots$ $\mathit{cv}_{2,M}$ \tcode{*}
\end{indented}

\pnum
Casting from an lvalue of type \tcode{T1} to an lvalue of type
\tcode{T2} using an lvalue reference cast
or casting from an expression of type \tcode{T1} to an xvalue of type \tcode{T2} using
an rvalue reference cast
casts away constness if a cast from a prvalue of type ``pointer to \tcode{T1}'' to the type ``pointer to
\tcode{T2}'' casts away constness.

\pnum
Casting from a prvalue of type ``pointer to data member of \tcode{X} of
type \tcode{T1}'' to the type ``pointer to data member of \tcode{Y} of
type \tcode{T2}'' casts away constness if a cast from a prvalue of type
``pointer to \tcode{T1}'' to the type ``pointer to \tcode{T2}'' casts
away constness.

\pnum
For multi-level pointer to members and multi-level mixed pointers and
pointer to members~(\ref{conv.qual}), the ``member'' aspect of a pointer
to member level is ignored when determining if a \tcode{const}
cv-qualifier has been cast away.

\pnum
\enternote 
some conversions which involve only changes in cv-qualification cannot
be done using \tcode{const_cast.} For instance, conversions between
pointers to functions are not covered because such conversions lead to
values whose use causes undefined behavior. For the same reasons,
conversions between pointers to member functions, and in particular, the
conversion from a pointer to a const member function to a pointer to a
non-const member function, are not covered.
\exitnote%
\indextext{expression!postfix|)}

\rSec1[expr.unary]{Unary expressions}

\pnum
\indextext{expression!unary|(}%
Expressions with unary operators group right-to-left.

\indextext{expression!unary}%
\indextext{operator!unary}%
\indextext{operator!\idxcode{sizeof}}%
\indextext{operator!cast}%
%
\begin{bnf}
\nontermdef{unary-expression}\br
    postfix-expression\br
    \terminal{++} cast-expression\br
    \terminal{-{-}} cast-expression\br
    unary-operator cast-expression\br
    \terminal{sizeof} unary-expression\br
    \terminal{sizeof (} type-id \terminal{)}\br
    \terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
    \terminal{alignof (} type-id \terminal{)}\br
    noexcept-expression\br
    new-expression\br
    delete-expression\br
\end{bnf}

\indextext{operator!indirection}%
\indextext{\idxcode{*}|see{operator, indirection}}%
\indextext{operator!address-of}%
\indextext{\idxcode{\&}|see{operator, address-of}}%
\indextext{operator!unary~minus}%
\indextext{\idxcode{-}|see{operator, unary~minus}}%
\indextext{operator!unary~plus}%
\indextext{\idxcode{+}|see{operator, unary~plus}}%
\indextext{operator!logical negation}%
\indextext{\idxcode{"!}|see{operator, logical~negation}}%
\indextext{operator!one's~complement}%
\indextext{~@\tcode{\tilde}|see{operator, one's~complement}}%
\indextext{operator!increment}%
\indextext{operator!decrement}%
%
\begin{bnf}
\nontermdef{unary-operator} \textnormal{one of}\br
    \terminal{*  \&  +  -  !  \tilde}
\end{bnf}

\rSec2[expr.unary.op]{Unary operators}

\pnum
\indextext{expression!unary~operator}%
\indextext{operator!unary}%
The unary \tcode{*} operator performs \term{indirection}:
\indextext{dereferencing|seealso{indirection}}%
\indextext{indirection}%
the expression to which it is applied shall be a pointer to an object
type, or a pointer to a function type and the result is an lvalue
referring to the object or function to which the expression points. If
the type of the expression is ``pointer to \tcode{T},'' the type of the
result is ``\tcode{T}.''
\enternote 
\indextext{type!incomplete}%
indirection through a pointer to an incomplete type (other than
\cvqual{cv} \tcode{void}) is valid. The lvalue thus obtained can be
used in limited ways (to initialize a reference, for example); this
lvalue must not be converted to a prvalue, see~\ref{conv.lval}.
\exitnote 

\pnum
The result of each of the following unary operators is a prvalue.

\pnum
\indextext{name!address~of cv-qualified}%
\indextext{expression!pointer~to~member constant}%
The result of the unary \tcode{\&} operator is a pointer to its operand.
The operand shall be an lvalue or a \grammarterm{qualified-id}.
If the operand is a \grammarterm{qualified-id} naming a non-static member \tcode{m}
of some class \tcode{C} with type \tcode{T}, the result has type ``pointer to member
of class \tcode{C} of type \tcode{T}'' and is a prvalue designating \tcode{C::m}.
Otherwise, if the type of the expression is \tcode{T}, the result has type ``pointer to
\tcode{T}'' and is a prvalue that is the address of the designated object~(\ref{intro.memory})
or a pointer to the designated function. \enternote In particular, the address of an
object of type ``\cv\ \tcode{T}'' is ``pointer to \cv\ \tcode{T}'', with the same
cv-qualification. \exitnote
\enterexample 

\begin{codeblock}
struct A { int i; };
struct B : A { };
... &B::i ...       // has type \tcode{int A::*}
\end{codeblock}
\exitexample 
\enternote 
a pointer to member formed from a \tcode{mutable} non-static data
member~(\ref{dcl.stc}) does not reflect the \tcode{mutable} specifier
associated with the non-static data member.
\exitnote 

\pnum
A pointer to member is only formed when an explicit \tcode{\&} is used
and its operand is a \grammarterm{qualified-id} not enclosed in
parentheses.
\enternote 
that is, the expression \tcode{\&(qualified-id)}, where the
\grammarterm{qualified-id} is enclosed in parentheses, does not form an
expression of type ``pointer to member.'' Neither does
\tcode{qualified-id}, because there is no implicit conversion from a
\grammarterm{qualified-id} for a non-static member function to the type
``pointer to member function'' as there is from an lvalue of function
type to the type ``pointer to function''~(\ref{conv.func}). Nor is
\tcode{\&unqualified-id} a pointer to member, even within the scope of
the \grammarterm{unqualified-id}'s class.
\exitnote 

\pnum
If \tcode{\&} is applied to an lvalue of incomplete class type and the
complete type declares \tcode{operator\&()}, it is unspecified whether
the operator has the built-in meaning or the operator function is
called. The operand of \tcode{\&} shall not be a bit-field.

\pnum
\indextext{overloaded~function!address~of}%
The address of an overloaded function (Clause~\ref{over}) can be taken
only in a context that uniquely determines which version of the
overloaded function is referred to (see~\ref{over.over}).
\enternote 
since the context might determine whether the operand is a static or
non-static member function, the context can also affect whether the
expression has type ``pointer to function'' or ``pointer to member
function.''
\exitnote 

\pnum
\indextext{operator!unary~plus}%
The operand of the unary \tcode{+} operator shall have arithmetic, unscoped
enumeration, or pointer type and the result is the value of the
argument. Integral promotion is performed on integral or enumeration
operands. The type of the result is the type of the promoted operand.

\pnum
\indextext{operator!unary~minus}%
The operand of the unary \tcode{-} operator shall have arithmetic or unscoped
enumeration type and the result is the negation of its operand. Integral
promotion is performed on integral or enumeration operands. The negative
of an unsigned quantity is computed by subtracting its value from $2^n$,
where $n$ is the number of bits in the promoted operand. The type of the
result is the type of the promoted operand.

\pnum
\indextext{operator!logical negation}%
The operand of the logical negation operator \tcode{!} is contextually
converted to \tcode{bool}
(Clause~\ref{conv}); its value is \tcode{true}
if the converted operand is \tcode{false} and \tcode{false} otherwise.
The type of the result is \tcode{bool}.

\pnum
\indextext{operator!one's~complement}%
The operand of \tcode{\~{}} shall have integral or unscoped enumeration type; the
result is the one's complement of its operand. Integral promotions are
performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the \grammarterm{unary-expression}
\tcode{\~{}X()}, where \tcode{X} is a \grammarterm{class-name} or \grammarterm{decltype-specifier}.
The
ambiguity is resolved in favor of treating \tcode{\~{}} as a unary
complement rather than treating \tcode{\~{}X} as referring to a
destructor.

\rSec2[expr.pre.incr]{Increment and decrement}

\pnum
\indextext{expression!increment}%
\indextext{expression!decrement}%
The operand of prefix \tcode{++}
\indextext{operator!increment}%
\indextext{prefix~\tcode{++}}%
is modified by adding \tcode{1},
\indextext{increment!\idxcode{bool}}%
\indextext{prefix~\tcode{\dcr}}%
\indextext{deprecated~features}%
or set to \tcode{true} if it is \tcode{bool} (this use is deprecated).
The operand shall be a modifiable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a completely-defined object type.
The result is the updated operand; it is an lvalue, and it is a
bit-field if the operand is a bit-field. If \tcode{x} is not of type
\tcode{bool}, the expression \tcode{++x} is equivalent to \tcode{x+=1}
\indextext{operator!\idxcode{+=}}%
\enternote
See the discussions of addition~(\ref{expr.add}) and assignment
operators~(\ref{expr.ass}) for information on conversions.
\exitnote 

\pnum
The operand of prefix
\indextext{operator!decrement}%
\tcode{\dcr} is modified by subtracting \tcode{1}. The operand shall not
be of type \tcode{bool}. The requirements on the operand of prefix
\tcode{\dcr} and the properties of its result are otherwise the same as
those of prefix \tcode{++}.
\enternote 
For postfix increment and decrement, see~\ref{expr.post.incr}.
\exitnote 

\rSec2[expr.sizeof]{Sizeof}

\pnum
\indextext{expression!\idxcode{sizeof}}%
\indextext{operator!\idxcode{sizeof}}%
\indextext{byte}%
The \tcode{sizeof} operator yields the number of bytes in the object
representation of its operand. The operand is either an expression,
which is an unevaluated operand (Clause~\ref{expr}), or a parenthesized
\grammarterm{type-id}.
\indextext{type!incomplete}%
The \tcode{sizeof} operator shall not be applied to an expression that
has function or incomplete type, to an enumeration type whose underlying type is not fixed before all
its enumerators have been declared, to the parenthesized name of such
types, or to an lvalue that designates a bit-field.
\tcode{sizeof(char)}, \tcode{sizeof(signed char)} and
\tcode{sizeof(unsigned char)} are \tcode{1}. The result of
\tcode{sizeof} applied to any other fundamental
type~(\ref{basic.fundamental}) is \impldef{sizeof applied@\tcode{sizeof} applied to
fundamental types
other than \tcode{char}, \tcode{signed char}, and \tcode{unsigned char}}.
\enternote 
in particular, \tcode{sizeof(bool)}, \tcode{sizeof(char16_t)},
\tcode{sizeof(char32_t)}, and \tcode{sizeof(wchar_t)} are
implementation-defined.\footnote{\tcode{sizeof(bool)} is not required to be \tcode{1}.}
\exitnote 
\enternote 
See~\ref{intro.memory} for the definition of \term{byte}
and~\ref{basic.types} for the definition of \term{object representation}.
\exitnote 

\pnum
\indextext{reference!\idxcode{sizeof}}%
When applied to a reference or a reference type, the result is the size
of the referenced type.
\indextext{class~object!\idxcode{sizeof}}%
When applied to a class, the result is the number of bytes in an object
of that class including any padding required for placing objects of that
type in an array. The size of a most derived class shall be greater than
zero~(\ref{intro.object}). The result of applying \tcode{sizeof} to a
base class subobject is the size of the base class type.\footnote{The actual
size of a base class subobject may be less than the result of
applying \tcode{sizeof} to the subobject, due to virtual base classes
and less strict padding requirements on base class subobjects.}
\indextext{array!\idxcode{sizeof}}%
When applied to an array, the result is the total number of bytes in the
array. This implies that the size of an array of \term{n} elements is
\term{n} times the size of an element.

\pnum
The \tcode{sizeof} operator can be applied to a pointer to a function,
but shall not be applied directly to a function.

\pnum
The lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) standard conversions are not
applied to the operand of \tcode{sizeof}.

\pnum
The identifier in a \tcode{sizeof...} expression shall name a parameter
pack. The \tcode{sizeof...} operator yields the number of arguments
provided for the parameter pack \grammarterm{identifier}.
A \tcode{sizeof...} expression is a pack expansion~(\ref{temp.variadic}).
\enterexample

\begin{codeblock}
template<class... Types>
struct count {
  static const std::size_t value = sizeof...(Types);
};
\end{codeblock}
\exitexample

\pnum
The result of \tcode{sizeof} and \tcode{sizeof...} is a constant of type
\tcode{std::size_t}.
\enternote 
\indextext{\idxcode{size_t}}%
\indexlibrary{\idxcode{size_t}}%
\tcode{std::size_t} is defined in the standard header
\indextext{\idxhdr{cstddef}}%
\tcode{<cstddef>}~(\ref{support.types}).
\exitnote 

\rSec2[expr.new]{New}

\pnum
\indextext{expression!\idxcode{new}}%
\indextext{free~store|seealso{\tcode{new},~\tcode{delete}}}%
\indextext{memory~management|seealso{\tcode{new},~\tcode{delete}}}%
\indextext{storage~management|see{\tcode{new},~\tcode{delete}}}%
\indextext{\idxcode{new}}%
The \grammarterm{new-expression} attempts to create an object of the
\grammarterm{type-id}~(\ref{dcl.name}) or \grammarterm{new-type-id} to which
it is applied. The type of that object is the \term{allocated type}.
\indextext{type!incomplete}%
This type shall be a complete object type, but not an abstract class
type or array
thereof~(\ref{intro.object},~\ref{basic.types},~\ref{class.abstract}).
It is \impldef{support for over-aligned types} whether over-aligned types are
supported~(\ref{basic.align}).
\enternote 
because references are not objects, references cannot be created by
\grammarterm{new-expression}{s}.
\exitnote 
\enternote 
the \grammarterm{type-id} may be a cv-qualified type, in which case the
object created by the \grammarterm{new-expression} has a cv-qualified type.
\exitnote 

\begin{bnf}
\nontermdef{new-expression}\br
    \terminal{::}\opt \terminal{new} new-placement\opt new-type-id new-initializer\opt \br
    \terminal{::}\opt \terminal{new} new-placement\opt \terminal{(} type-id \terminal{)} new-initializer\opt
\end{bnf}

\indextext{\idxcode{new}!storage allocation}%
%
\begin{bnf}
\nontermdef{new-placement}\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{new-type-id}\br
    type-specifier-seq new-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{new-declarator}\br
    ptr-operator new-declarator\opt \br
    noptr-new-declarator
\end{bnf}

\begin{bnf}
\nontermdef{noptr-new-declarator}\br
    \terminal{[} expression \terminal{]} attribute-specifier-seq\opt\br
    noptr-new-declarator \terminal{[} constant-expression \terminal{]} attribute-specifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{new-initializer}\br
    \terminal{(} expression-list\opt \terminal{)}\br
    braced-init-list
\end{bnf}

\indextext{storage~duration!dynamic}%
Entities created by a \grammarterm{new-expression} have dynamic storage
duration~(\ref{basic.stc.dynamic}).
\enternote 
\indextext{\idxcode{new}!scoping~and}%
the lifetime of such an entity is not necessarily restricted to the
scope in which it is created.
\exitnote 
If the entity is a non-array object, the \grammarterm{new-expression}
returns a pointer to the object created. If it is an array, the
\grammarterm{new-expression} returns a pointer to the initial element of
the array.

\pnum
If the \tcode{auto} \nonterminal{type-specifier} appears in the
\nonterminal{type-specifier-seq} of a \nonterminal{new-type-id} or
\nonterminal{type-id} of a \nonterminal{new-expression},
the \nonterminal{new-expression} shall contain a
\nonterminal{new-initializer} of the form

\begin{ncsimplebnf}
\terminal{(} assignment-expression \terminal{)}
\end{ncsimplebnf}

The allocated type is deduced from the \nonterminal{new-initializer} as
follows: Let \tcode{e} be the \grammarterm{assignment-expression} in the \nonterminal{new-initializer} and
\tcode{T} be the \nonterminal{new-type-id} or \nonterminal{type-id} of
the \nonterminal{new-expression}, then the allocated type is the type
deduced for the variable \tcode{x} in the invented
declaration~(\ref{dcl.spec.auto}):

\begin{codeblock}
T x(e);
\end{codeblock}

\enterexample
\begin{codeblock}
new auto(1);                    // allocated type is \tcode{int}
auto x = new auto('a');         // allocated type is \tcode{char}, \tcode{x} is of type \tcode{char*}
\end{codeblock}
\exitexample

\pnum
The \grammarterm{new-type-id} in a \grammarterm{new-expression} is the longest
possible sequence of \grammarterm{new-declarator}{s}.
\enternote 
this prevents ambiguities between the declarator operators \tcode{\&}, \tcode{\&\&},
\tcode{*}, and \tcode{[]} and their expression counterparts.
\exitnote 
\enterexample 

\begin{codeblock}
new int * i;                    // syntax error: parsed as \tcode{(new int*) i}, not as \tcode{(new int)*i}
\end{codeblock}
The \tcode{*} is the pointer declarator and not the multiplication
operator.
\exitexample 

\pnum
\enternote 
\indextext{ambiguity!parentheses~and}%
parentheses in a \grammarterm{new-type-id} of a \grammarterm{new-expression}
can have surprising effects.
\enterexample 

\begin{codeblock}
new int(*[10])();               // error
\end{codeblock}

is ill-formed because the binding is

\begin{codeblock}
(new int) (*[10])();            // error
\end{codeblock}

Instead, the explicitly parenthesized version of the \tcode{new}
operator can be used to create objects of compound
types~(\ref{basic.compound}):

\begin{codeblock}
new (int (*[10])());
\end{codeblock}

allocates an array of \tcode{10} pointers to functions (taking no
argument and returning \tcode{int}.
\exitexample 
\exitnote 

\pnum
\indextext{array!\idxcode{new}}%
When the allocated object is an array (that is, the
\grammarterm{noptr-new-declarator} syntax is used or the
\grammarterm{new-type-id} or \grammarterm{type-id} denotes an array type), the
\grammarterm{new-expression} yields a pointer to the initial element (if
any) of the array.
\enternote 
both \tcode{new int} and \tcode{new int[10]} have type \tcode{int*} and
the type of \tcode{new int[i][10]} is \tcode{int (*)[10]}
\exitnote 
The \grammarterm{attribute-specifier-seq} in a \grammarterm{noptr-new-declarator} appertains
to the associated array type.

\pnum
Every \grammarterm{constant-expression} in a
\grammarterm{noptr-new-declarator} shall be a converted constant
expression~(\ref{expr.const}) of type \tcode{std\colcol{}size_t} and
shall evaluate to a strictly positive value.
\indextext{\idxcode{new}}%
The \grammarterm{expression} in a \grammarterm{noptr-new-declarator}is
implicitly converted to \tcode{std\colcol{}size_t}.
\enterexample
given the definition \tcode{int n = 42},
\tcode{new float[n][5]} is well-formed (because \tcode{n} is the
\grammarterm{expression} of a \grammarterm{noptr-new-declarator}), but
\tcode{new float[5][n]} is ill-formed (because \tcode{n} is not a
constant expression).
\exitexample 

\pnum
\indextext{function!allocation}%
When the value of the \grammarterm{expression} in a \grammarterm{noptr-new-declarator}
is zero, the allocation function is called to allocate an array with no elements. If the
value of that \grammarterm{expression} is less than zero or such that the size of the allocated object
would exceed the implementation-defined limit,
or if the \grammarterm{new-initializer} is a \grammarterm{braced-init-list} for
which the number of \grammarterm{initializer-clause}{s} exceeds the number of
elements to initialize,
no storage is obtained and the
\grammarterm{new-expression} throws an exception~(\ref{except.throw}) of a type that would
match a handler~(\ref{except.handle}) of type
\tcode{std::bad_array_new_length}~(\ref{new.badlength}).

\pnum
A \grammarterm{new-expression} obtains storage for the object by calling an
\term{allocation function}~(\ref{basic.stc.dynamic.allocation}). If
the \grammarterm{new-expression} terminates by throwing an exception, it
may release storage by calling a deallocation
function~(\ref{basic.stc.dynamic.deallocation}). If the allocated type
is a non-array type, the allocation function's name is
\indextext{\idxcode{operator new}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator new} and the deallocation function's name is
\tcode{operator delete}. If the allocated type is an array type, the
allocation function's name is
\indextext{\idxcode{operator new}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator new[]}
and the deallocation function's name is
\tcode{operator delete[]}.
\enternote 
an implementation shall provide default definitions for the global
allocation
functions~(\ref{basic.stc.dynamic},~\ref{new.delete.single},~\ref{new.delete.array}).
A \Cpp program can provide alternative definitions of
these functions~(\ref{replacement.functions}) and/or class-specific
versions~(\ref{class.free}).
\exitnote 

\pnum
\indextext{operator!scope~resolution}%
If the \grammarterm{new-expression} begins with a unary \tcode{::}
operator, the allocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type \tcode{T} or
array thereof, the allocation function's name is looked up in the scope
of \tcode{T}. If this lookup fails to find the name, or if the allocated
type is not a class type, the allocation function's name is looked up in
the global scope.

\pnum
A \grammarterm{new-expression} passes the amount of space requested to the
allocation function as the first argument of type
\tcode{std\colcol{}size_t}. That argument shall be no less than the size
of the object being created; it may be greater than the size of the
object being created only if the object is an array. For arrays of
\tcode{char} and \tcode{unsigned char}, the difference between the
result of the \grammarterm{new-expression} and the address returned by the
allocation function shall be an integral multiple of the
strictest fundamental
alignment requirement~(\ref{basic.align}) of any object type whose size
is no greater than the size of the array being created.
\enternote 
\indextext{allocation!alignment~storage}%
Because allocation functions are assumed to return pointers to storage
that is appropriately aligned for objects of any type
with fundamental alignment, this constraint
on array allocation overhead permits the common idiom of allocating
character arrays into which objects of other types will later be placed.
\exitnote 

\pnum
\indextext{placement~syntax!\idxcode{new}}%
The \grammarterm{new-placement} syntax is used to supply additional
arguments to an allocation function. If used, overload resolution is
performed on a function call created by assembling an argument list
consisting of the amount of space requested (the first argument) and the
expressions in the \grammarterm{new-placement} part of the
\grammarterm{new-expression} (the second and succeeding arguments). The
first of these arguments has type \tcode{std::size_t} and the remaining
arguments have the corresponding types of the expressions in the
\grammarterm{new-placement}.

\pnum
\enterexample 

\begin{itemize}
\item \tcode{new T} results in a call of \tcode{operator
new(sizeof(T))},

\item \tcode{new(2,f) T} results in a call of \tcode{operator
new(sizeof(T),2,f)},

\item \tcode{new T[5]} results in a call of \tcode{operator
new[](sizeof(T)*5+x)}, and

\item \tcode{new(2,f) T[5]} results in a call of \tcode{operator
new[](sizeof(T)*5+y,2,f)}.
\end{itemize}

Here, \tcode{x} and \tcode{y} are non-negative unspecified values
representing array allocation overhead; the result of the
\grammarterm{new-expression} will be offset by this amount from the value
returned by \tcode{operator new[]}. This overhead may be applied in all
array \grammarterm{new-expression}{s}, including those referencing the
library function \tcode{operator new[](std::size_t, void*)} and other
placement allocation functions. The amount of overhead may vary from one
invocation of \tcode{new} to another.
\exitexample 

\pnum
\enternote 
unless an allocation function is declared with a non-throwing
\grammarterm{exception-specification}~(\ref{except.spec}),
it indicates failure to allocate storage by throwing a
\indextext{\idxcode{bad_alloc}}%
\indexlibrary{\idxcode{bad_alloc}}%
\tcode{std::bad_alloc} exception (Clause~\ref{except},~\ref{bad.alloc});
it returns a non-null pointer otherwise. If the allocation function is
declared with a non-throwing \grammarterm{exception-specification},
it returns null to indicate failure to allocate storage
and a non-null pointer otherwise.
\exitnote 
If the allocation function returns null, initialization shall not be
done, the deallocation function shall not be called, and the value of
the \grammarterm{new-expression} shall be null.

\pnum
\enternote 
when the allocation function returns a value other than null, it must be
a pointer to a block of storage in which space for the object has been
reserved. The block of storage is assumed to be appropriately aligned
and of the requested size. The address of the created object will not
necessarily be the same as that of the block if the object is an array.
\exitnote 

\pnum
\indextext{\idxcode{new}!array~of class~objects~and}%
\indextext{\idxcode{new}!initialization~and}%
\indextext{\idxcode{new}!constructor~and}%
\indextext{\idxcode{new}!default~constructor~and}%
\indextext{constructor, default|see{default~constructor}}%
\indextext{trivial~type}%
\indextext{trivial~class~type}%
A \grammarterm{new-expression} that creates an object of type \tcode{T}
initializes that object as follows:

\begin{itemize}
\item If the \grammarterm{new-initializer} is omitted, the object is
default-initialized~(\ref{dcl.init}); if no initialization is performed, the
object has indeterminate value.

\item Otherwise, the \grammarterm{new-initializer} is interpreted according to
the initialization rules of~\ref{dcl.init} for direct-initialization.
\end{itemize}

\pnum
\indextext{\idxcode{new}!unspecified order~of evaluation}%
\indextext{\idxcode{new}!unspecified constructor~and}%
The invocation of the allocation function is indeterminately sequenced with respect to
the evaluations of expressions in the \grammarterm{new-initializer}. Initialization of
the allocated object is sequenced before the
\indextext{value computation}%
value computation of the
\grammarterm{new-expression}.
\indextext{constructor!unspecified argument~to}%
It is unspecified whether expressions in the \grammarterm{new-initializer} are
evaluated if the allocation function returns the null pointer or exits
using an exception.

\pnum
If the \grammarterm{new-expression} creates an object or an array of
objects of class type, access and ambiguity control are done for the
allocation function, the deallocation function~(\ref{class.free}), and
the constructor~(\ref{class.ctor}). If the new expression creates an
array of objects of class type, access and ambiguity control are done
for the destructor~(\ref{class.dtor}).

\pnum
\indextext{\idxcode{new}!exception~and}%
If any part of the object initialization described above\footnote{This may
include evaluating a \grammarterm{new-initializer} and/or calling
a constructor.}
terminates by throwing an exception, storage has been obtained for the
object, and a suitable deallocation function
can be found, the deallocation function is called to free the memory in
which the object was being constructed, after which the exception
continues to propagate in the context of the \grammarterm{new-expression}.
If no unambiguous matching deallocation function can be found,
propagating the exception does not cause the object's memory to be
freed.
\enternote 
This is appropriate when the called allocation function does not
allocate memory; otherwise, it is likely to result in a memory leak.
\exitnote 

\pnum
If the \grammarterm{new-expression} begins with a unary \tcode{::}
operator, the deallocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type \tcode{T} or an
array thereof, the deallocation function's name is looked up in the
scope of \tcode{T}. If this lookup fails to find the name, or if the
allocated type is not a class type or array thereof, the deallocation
function's name is looked up in the global scope.

\pnum
A declaration of a placement deallocation function matches the
declaration of a placement allocation function if it has the same number
of parameters and, after parameter transformations~(\ref{dcl.fct}), all
parameter types except the first are identical. Any non-placement
deallocation function matches a non-placement allocation function. If
the lookup finds a single matching deallocation function, that function
will be called; otherwise, no deallocation function will be called. If
the lookup finds the two-parameter form of a usual deallocation
function~(\ref{basic.stc.dynamic.deallocation}) and that function,
considered as a placement deallocation function, would have been
selected as a match for the allocation function, the program is
ill-formed.
\enterexample

\begin{codeblock}
struct S { 
  // Placement allocation function:
  static void* operator new(std::size_t, std::size_t); 

  // Usual (non-placement) deallocation function:
  static void operator delete(void*, std::size_t); 
}; 

S* p = new (0) S;   // ill-formed: non-placement deallocation function matches 
                    // placement allocation function 
\end{codeblock}

\exitexample

\pnum
If a \grammarterm{new-expression} calls a deallocation function, it passes
the value returned from the allocation function call as the first
argument of type \tcode{void*}. If a placement deallocation function is
called, it is passed the same additional arguments as were passed to the
placement allocation function, that is, the same arguments as those
specified with the \grammarterm{new-placement} syntax. If the
implementation is allowed to make a copy of any argument as part of the
call to the allocation function, it is allowed to make a copy (of the
same original value) as part of the call to the deallocation function or
to reuse the copy made as part of the call to the allocation function.
If the copy is elided in one place, it need not be elided in the other.

\rSec2[expr.delete]{Delete}

\pnum
\indextext{expression!\idxcode{delete}}%
\indextext{\idxcode{delete}}%
The \grammarterm{delete-expression} operator destroys a most derived
object~(\ref{intro.object}) or array created by a
\grammarterm{new-expression}.

\begin{bnf}
\nontermdef{delete-expression}\br
    \terminal{::}\opt \terminal{delete} cast-expression\br
    \terminal{::}\opt \terminal{delete [ ]} cast-expression
\end{bnf}

The first alternative is for non-array objects, and the second is for arrays. Whenever
the \tcode{delete} keyword is immediately followed by empty square brackets, it shall be
interpreted as the second alternative.\footnote{A lambda expression with a
\grammarterm{lambda-introducer} that consists of
empty square brackets can follow the \tcode{delete} keyword if the lambda expression is
enclosed in parentheses.}
The operand shall be of pointer to object type or of class type. If of
class type, the operand is contextually implicitly converted
(Clause~\ref{conv}) to a pointer to object
type. The \grammarterm{delete-expression}'s result has type
\tcode{void}.\footnote{This implies that an object
cannot be deleted using a pointer of type
\tcode{void*} because \tcode{void} is not an object type.}

\pnum
\indextext{\idxcode{delete}!object}
If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section.
\indextext{object!delete}%
In the first alternative
(\term{delete object}), the value of the operand of \tcode{delete} may
be a null pointer value, a pointer to a non-array object
created by a previous \grammarterm{new-expression},
or a pointer to a
subobject~(\ref{intro.object}) representing a base class of such an
object (Clause~\ref{class.derived}). If not, the behavior is undefined.
\indextext{array!\idxcode{delete}}%
\indextext{\idxcode{delete}!array}%
In the second alternative (\term{delete array}), the value of the
operand of \tcode{delete}
may be a null pointer value or a pointer value
that resulted from
a previous array \grammarterm{new-expression}.\footnote{For non-zero-length
arrays, this is the same as a pointer to the first
element of the array created by that \grammarterm{new-expression}.
Zero-length arrays do not have a first element.}
If not, the behavior is undefined.
\enternote 
this means that the syntax of the \grammarterm{delete-expression} must
match the type of the object allocated by \tcode{new}, not the syntax of the
\grammarterm{new-expression}.
\exitnote 
\enternote 
a pointer to a \tcode{const} type can be the operand of a
\grammarterm{delete-expression}; it is not necessary to cast away the
constness~(\ref{expr.const.cast}) of the pointer expression before it is
used as the operand of the \grammarterm{delete-expression}.
\exitnote 

\pnum
\indextext{\idxcode{delete}!undefined}%
In the first alternative (\term{delete object}), if the static type of
the object to be deleted is different from its dynamic type, the static type shall be
a base class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (\term{delete array}) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.

\pnum
The \grammarterm{cast-expression} in a \grammarterm{delete-expression} shall
be evaluated exactly once.

\pnum
\indextext{type!incomplete}%
If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.

\pnum
\indextext{\idxcode{delete}!destructor~and}%
If the value of the operand of the \grammarterm{delete-expression} is not a
null pointer value, the \grammarterm{delete-expression} will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see~\ref{class.base.init}).

\pnum
If the value of the operand of the \grammarterm{delete-expression} is not a
null pointer value, the \grammarterm{delete-expression} will call a
\indextext{function!deallocation}%
\indextext{deallocation|see{\tcode{delete}}}%
\indextext{\idxcode{delete}}
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation}).
Otherwise, it is unspecified whether the deallocation function will be
called.
\enternote
The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception.
\exitnote

\pnum
\enternote 
An implementation provides default definitions of the global
deallocation functions \tcode{operator delete()} for
non-arrays~(\ref{new.delete.single}) and
\indextext{operator~|see{\tcode{delete}}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator delete[]()} for arrays~(\ref{new.delete.array}). A \Cpp
program can provide alternative definitions of these
functions~(\ref{replacement.functions}), and/or class-specific
versions~(\ref{class.free}).
\exitnote 

\pnum
When the keyword \tcode{delete} in a \grammarterm{delete-expression} is
preceded by the unary \tcode{::} operator, the global deallocation
function is used to deallocate the storage.

\pnum
Access and ambiguity control are done for both the deallocation function
and the destructor~(\ref{class.dtor},~\ref{class.free}).

\rSec2[expr.alignof]{Alignof}

\pnum
\indextext{expression!\idxcode{alignof}}%
An \tcode{alignof} expression yields the alignment requirement
of its operand type. The operand shall be a \grammarterm{type-id}
representing a complete object type, or an array thereof, or a reference
to one of those types.

\pnum
The result is an integral constant of type
\tcode{std::size_t}.

\pnum
When \tcode{alignof} is applied to a reference type, the result
shall be the alignment of the referenced type. When \tcode{alignof}
is applied to an array type, the result shall be the alignment of the
element type.

\rSec2[expr.unary.noexcept]{\tcode{noexcept} operator}

\pnum
\indextext{expression!\idxcode{noexcept}}%
The \tcode{noexcept} operator determines whether the evaluation of its operand,
which is an unevaluated operand (Clause~\ref{expr}), can throw an
exception~(\ref{except.throw}).

\begin{bnf}
\nontermdef{noexcept-expression}\br
  \terminal{noexcept} \terminal{(} expression \terminal{)}
\end{bnf}

\pnum
The result of the \tcode{noexcept} operator is a constant of type \tcode{bool}
and is an rvalue.

\pnum
The result of the \tcode{noexcept} operator is \tcode{false} if in a
potentially-evaluated context the \grammarterm{expression} would contain

\begin{itemize}
\item a potentially-evaluated call\footnote{This includes implicit calls such as
the call to an allocation function in a \grammarterm{new-expression}.}
to a function, member function, function pointer, or member function pointer
that does not have a non-throwing \grammarterm{exception-specification}~(\ref{except.spec}),
unless the call is a constant expression~(\ref{expr.const}),

\item a potentially-evaluated \grammarterm{throw-expression}~(\ref{except.throw}),

\item a potentially-evaluated \tcode{dynamic_cast} expression
\tcode{dynamic_cast<T>(v)}, where \tcode{T} is a reference type,
that requires a run-time check~(\ref{expr.dynamic.cast}), or

\item a potentially-evaluated \tcode{typeid} expression~(\ref{expr.typeid}) applied to
a glvalue expression whose type is a polymorphic class type~(\ref{class.virtual}).
\end{itemize}

Otherwise, the result is \tcode{true}.%
\indextext{expression!unary|)}

\rSec1[expr.cast]{Explicit type conversion (cast notation)}%
\indextext{expression!cast|(}

\pnum
The result of the expression \tcode{(T)} \grammarterm{cast-expression} is
of type \tcode{T}. The result is an lvalue if \tcode{T} is an lvalue
reference type or an rvalue reference to function type and an xvalue if \tcode{T}
is an rvalue reference to object type; otherwise the result is a prvalue.
\enternote 
if \tcode{T} is a non-class type that is cv-qualified, the
\grammarterm{cv-qualifiers} are discarded when determining the type of the
resulting prvalue; see Clause~\ref{expr}.
\exitnote 

\pnum
An explicit type conversion can be expressed using functional
notation~(\ref{expr.type.conv}), a type conversion operator
(\tcode{dynamic_cast}, \tcode{static_cast}, \tcode{reinterpret_cast},
\tcode{const_cast}), or the \term{cast} notation.

\begin{bnf}
\nontermdef{cast-expression}\br
    unary-expression\br
    \terminal{(} type-id \terminal{)} cast-expression
\end{bnf}

\pnum
Any type conversion not mentioned below and not explicitly defined by
the user~(\ref{class.conv}) is ill-formed.

\pnum
The conversions performed by

\begin{itemize}
\indextext{cast!const}%
\indextext{cast!static}%
\indextext{cast!reinterpret}%
\item a \tcode{const_cast}~(\ref{expr.const.cast}),
\item a \tcode{static_cast}~(\ref{expr.static.cast}),
\item a \tcode{static_cast} followed by a \tcode{const_cast},
\item a \tcode{reinterpret_cast}~(\ref{expr.reinterpret.cast}), or
\item a \tcode{reinterpret_cast} followed by a \tcode{const_cast},
\end{itemize}

can be performed using the cast notation of explicit type conversion.
The same semantic restrictions and behaviors apply, with the exception
that in performing a \tcode{static_cast} in the following situations the
conversion is valid even if the base class is inaccessible:

\begin{itemize}
\item a pointer to an object of derived class type or an lvalue or
rvalue of derived class type may be explicitly converted to a pointer or
reference to an unambiguous base class type, respectively;

\item a pointer to member of derived class type may be explicitly
converted to a pointer to member of an unambiguous non-virtual base
class type;

\item a pointer to an object of an unambiguous non-virtual base class
type, a glvalue of an unambiguous non-virtual base class type,
or a pointer to member of an unambiguous non-virtual base class type may
be explicitly converted to a pointer, a reference, or a pointer to
member of a derived class type, respectively.
\end{itemize}

If a conversion can be interpreted in more than one of the ways listed
above, the interpretation that appears first in the list is used, even
if a cast resulting from that interpretation is ill-formed. If a
conversion can be interpreted in more than one way as a
\tcode{static_cast} followed by a \tcode{const_cast}, the conversion is
ill-formed.
\enterexample 

\begin{codeblock}
struct A { };
struct I1 : A { };
struct I2 : A { };
struct D : I1, I2 { };
A *foo( D *p ) {
  return (A*)( p ); // ill-formed \tcode{static_cast} interpretation
}
\end{codeblock}
\exitexample 

\pnum
\indextext{class!cast~to incomplete}%
The operand of a cast using the cast notation can be a prvalue of type
``pointer to incomplete class type''. The destination type of a cast
using the cast notation can be ``pointer to incomplete class type''. If
both the operand and destination types are class types and one or both
are incomplete, it is unspecified whether the \tcode{static_cast} or the
\tcode{reinterpret_cast} interpretation is used, even if there is an
inheritance relationship between the two classes.
\enternote
For example, if the classes were defined later in the translation unit,
a multi-pass compiler would be permitted to interpret a cast between
pointers to the classes as if the class types were complete at the point
of the cast.
\exitnote%
\indextext{expression!cast|)}

\rSec1[expr.mptr.oper]{Pointer-to-member operators}

\pnum
\indextext{expression!pointer-to-member}%
\indextext{pointer~to~member}%
\indextext{operator!pointer~to~member}%
\indextext{\idxcode{.*}|see{pointer~to~member~operator}}%
\indextext{operator!pointer~to~member}%
\indextext{\idxcode{->*}|see{pointer~to~member~operator}}%
The pointer-to-member operators \tcode{->*} and \tcode{.*} group
left-to-right.

\begin{bnf}
\nontermdef{pm-expression}\br
    cast-expression\br
    pm-expression \terminal{.*} cast-expression\br
    pm-expression \terminal{->*} cast-expression
\end{bnf}

\pnum
The binary operator \tcode{.*} binds its second operand, which shall be
of type ``pointer to member of \tcode{T}'' to its first operand, which shall be of
class \tcode{T} or of a class of which \tcode{T} is an unambiguous and
accessible base class. The result is an object or a function of the type
specified by the second operand.

\pnum
The binary operator \tcode{->*} binds its second operand, which shall be
of type ``pointer to member of \tcode{T}'' to its first operand, which shall be of
type ``pointer to \tcode{T}'' or ``pointer to a class of which \tcode{T}
is an unambiguous and accessible base class.''
The expression \tcode{E1->*E2} is converted into the equivalent form
\tcode{(*(E1)).*E2}.

\pnum
Abbreviating \term{pm-expression}{}\tcode{.*}\term{cast-expression} as \tcode{E1.*E2}, \tcode{E1}
is called the \term{object expression}.
If the dynamic type of \tcode{E1} does not
contain the member to which
\tcode{E2} refers, the behavior is undefined.

\pnum
The restrictions on \cvqual{cv-}qualification, and the manner in which
the \cvqual{cv-}qualifiers of the operands are combined to produce the
\cvqual{cv-}qualifiers of the result, are the same as the rules for
\tcode{E1.E2} given in~\ref{expr.ref}.
\enternote 
it is not possible to use a pointer to member that refers to a
\tcode{mutable} member to modify a \tcode{const} class object. For
example,

\begin{codeblock}
struct S {
  S() : i(0) { }
  mutable int i;
};
void f()
{
const S cs;
int S::* pm = &S::i;            // \tcode{pm} refers to \tcode{mutable} member \tcode{S::i}
cs.*pm = 88;                    // ill-formed: \tcode{cs} is a \tcode{const} object
}
\end{codeblock}
\exitnote 

\pnum
\indextext{function!pointer~to~member}%
If the result of \tcode{.*} or \tcode{->*} is a function, then that
result can be used only as the operand for the function call operator
\tcode{()}.
\enterexample 

\begin{codeblock}
(ptr_to_obj->*ptr_to_mfct)(10);
\end{codeblock}

calls the member function denoted by \tcode{ptr_to_mfct} for the object
pointed to by \tcode{ptr_to_obj}.
\exitexample 
In a \tcode{.*} expression whose object expression is an rvalue, the program is
ill-formed if the second operand is a pointer to member function with
\grammarterm{ref-qualifier} \tcode{\&}.
In a \tcode{.*}
expression whose object expression is an lvalue, the program is ill-formed if the second
operand is a pointer to member function with \grammarterm{ref-qualifier} \tcode{\&\&}.
The result of a \tcode{.*} expression
whose second operand is a pointer to a data member is of the same value
category~(\ref{basic.lval}) as its first operand. The result of a \tcode{.*} expression whose
second operand is a pointer to a member function is a prvalue.
If the second operand is the null
pointer to member value~(\ref{conv.mem}), the behavior is undefined.

\rSec1[expr.mul]{Multiplicative operators}%
\indextext{expression!multiplicative~operators}%
\indextext{operator!multiplicative}

\pnum
The multiplicative operators \tcode{*}, \tcode{/}, and \tcode{\%} group
left-to-right.

\indextext{operator!multiplication}%
\indextext{\idxcode{*}|see{multiplication~operator}}%
\indextext{operator!division}%
\indextext{\idxcode{/}|see{division~operator}}%
\indextext{operator!remainder}%
\indextext{\idxcode{\%}|see{remainder~operator}}%
\indextext{remainder~operator|see{remainder~operator}}%
%
\begin{bnf}
\nontermdef{multiplicative-expression}\br
    pm-expression\br
    multiplicative-expression \terminal{*} pm-expression\br
    multiplicative-expression \terminal{/} pm-expression\br
    multiplicative-expression \terminal{\%} pm-expression
\end{bnf}

\pnum
The operands of \tcode{*} and \tcode{/} shall have arithmetic or unscoped
enumeration type; the operands of \tcode{\%} shall have integral or unscoped
enumeration type. The usual arithmetic conversions are performed on the
operands and determine the type of the result.

\pnum
The binary \tcode{*} operator indicates multiplication.

\pnum
The binary \tcode{/} operator yields the quotient, and the binary
\tcode{\%} operator yields the remainder from the division of the first
expression by the second.
\indextext{zero!undefined division~by}%
If the second operand of \tcode{/} or \tcode{\%} is zero the behavior is
undefined.
For integral operands the \tcode{/} operator yields the algebraic quotient with
any fractional part discarded;\footnote{This is often called truncation towards
zero.} if the quotient \tcode{a/b} is representable in the type of the result,
\tcode{(a/b)*b + a\%b} is equal to \tcode{a}; otherwise, the behavior
of both \tcode{a/b} and \tcode{a\%b} is undefined.

\rSec1[expr.add]{Additive operators}%
\indextext{expression!additive~operators}%
\indextext{operator!additive}

\pnum
The additive operators \tcode{+} and \tcode{-} group left-to-right. The
usual arithmetic conversions are performed for operands of arithmetic or
enumeration type.

\indextext{addition~operator}%
\indextext{\idxcode{+}|see{addition~operator}}%
\indextext{subtraction~operator}%
\indextext{\idxcode{-}|see{subtraction~operator}}%
%
\begin{bnf}
\nontermdef{additive-expression}\br
    multiplicative-expression\br
    additive-expression \terminal{+} multiplicative-expression\br
    additive-expression \terminal{-} multiplicative-expression
\end{bnf}

\indextext{incomplete}%
For addition, either both operands shall have arithmetic or unscoped enumeration
type, or one operand shall be a pointer to a completely-defined object
type and the other shall have integral or unscoped enumeration type.

\pnum
For subtraction, one of the following shall hold:

\begin{itemize}
\item both operands have arithmetic or unscoped enumeration type; or

\indextext{arithmetic!pointer}%
\item both operands are pointers to cv-qualified or cv-unqualified
versions of the same completely-defined object type; or

\item the left operand is a pointer to a completely-defined object type
and the right operand has integral or unscoped enumeration type.
\end{itemize}

\pnum
The result of the binary \tcode{+} operator is the sum of the operands.
The result of the binary \tcode{-} operator is the difference resulting
from the subtraction of the second operand from the first.

\pnum
\indextext{arithmetic!pointer}%
For the purposes of these operators, a pointer to a nonarray object
behaves the same as a pointer to the first element of an array of length
one with the type of the object as its element type.

\pnum
When an expression that has integral type is added to or subtracted from
a pointer, the result has the type of the pointer operand. If the
pointer operand points to an element of an array object, and the array
is large enough, the result points to an element offset from the
original element such that the difference of the subscripts of the
resulting and original array elements equals the integral expression. In
other words, if the expression \tcode{P} points to the $i$-th element of
an array object, the expressions \tcode{(P)+N} (equivalently,
\tcode{N+(P)}) and \tcode{(P)-N} (where \tcode{N} has the value $n$)
point to, respectively, the $i+n$-th and $i-n$-th elements of the array
object, provided they exist. Moreover, if the expression \tcode{P}
points to the last element of an array object, the expression
\tcode{(P)+1} points one past the last element of the array object, and
if the expression \tcode{Q} points one past the last element of an array
object, the expression \tcode{(Q)-1} points to the last element of the
array object. If both the pointer operand and the result point to
elements of the same array object, or one past the last element of the
array object, the evaluation shall not produce an overflow; otherwise,
the behavior is undefined.

\pnum
\indextext{\idxcode{ptrdiff_t}!implementation~defined type~of}%
\indextext{subtraction!implementation~defined pointer}%
\indextext{\idxcode{ptrdiff_t}}%
\indextext{\idxhdr{cstddef}}%
\indextext{comparison!undefined pointer}%
When two pointers to elements of the same array object are subtracted,
the result is the difference of the subscripts of the two array
elements. The type of the result is an \impldef{type of \tcode{ptrdiff_t}} signed
integral type; this type shall be the same type that is defined as
\tcode{std::ptrdiff_t} in the \tcode{<cstddef>}
header~(\ref{support.types}). As with any other arithmetic overflow, if
the result does not fit in the space provided, the behavior is
undefined. In other words, if the expressions \tcode{P} and \tcode{Q}
point to, respectively, the $i$-th and $j$-th elements of an array
object, the expression \tcode{(P)-(Q)} has the value $i-j$ provided the
value fits in an object of type \tcode{std::ptrdiff_t}. Moreover, if the
expression \tcode{P} points either to an element of an array object or
one past the last element of an array object, and the expression
\tcode{Q} points to the last element of the same array object, the
expression \tcode{((Q)+1)-(P)} has the same value as \tcode{((Q)-(P))+1}
and as \tcode{-((P)-((Q)+1))}, and has the value zero if the expression
\tcode{P} points one past the last element of the array object, even
though the expression \tcode{(Q)+1} does not point to an element of the
array object. Unless both pointers point to elements of the same array
object, or one past the last element of the array object, the behavior
is undefined.\footnote{Another way to approach pointer arithmetic is first to convert the
pointer(s) to character pointer(s): In this scheme the integral value of
the expression added to or subtracted from the converted pointer is
first multiplied by the size of the object originally pointed to, and
the resulting pointer is converted back to the original type. For
pointer subtraction, the result of the difference between the character
pointers is similarly divided by the size of the object originally
pointed to.

When viewed in this way, an implementation need only provide one extra
byte (which might overlap another object in the program) just after the
end of the object in order to satisfy the ``one past the last element''
requirements.}

\pnum
If the value 0 is added to or subtracted from a pointer value, the
result compares equal to the original pointer value. If two pointers
point to the same object or both point one past the end of the same
array or both are null, and the two pointers are subtracted, the result
compares equal to the value 0 converted to the type
\tcode{std::ptrdiff_t}.

\rSec1[expr.shift]{Shift operators}

\pnum
\indextext{expression!left-shift-operator}%
\indextext{expression!right-shift-operator}%
\indextext{shift~operator|see{left~shift~operator,~right~shift~operator}}%
\indextext{operator~right~shift|see{right~shift~operator}}%
\indextext{operator~left~shift|see{left~shift~operator}}%
The shift operators \tcode{\shl} and \tcode{\shr} group left-to-right.

\indextext{left~shift~operator}%
\indextext{\idxcode{\shl}|see{left~shift~operator}}%
\indextext{right~shift~operator}%
\indextext{\idxcode{\shr}|see{right~shift~operator}}%
%
\begin{bnf}
\nontermdef{shift-expression}\br
    additive-expression\br
    shift-expression \terminal{\shl} additive-expression\br
    shift-expression \terminal{\shr} additive-expression
\end{bnf}

The operands shall be of integral or unscoped enumeration type and integral
promotions are performed. The type of the result is that of the promoted
left operand.
\indextext{left~shift!undefined}%
The behavior is undefined if the right operand is negative, or greater
than or equal to the length in bits of the promoted left operand.

\pnum
The value of \tcode{E1 \shl\ E2} is \tcode{E1} left-shifted \tcode{E2} bit positions; vacated bits are
zero-filled. If \tcode{E1} has an unsigned type, the value of the result
is $\mathrm{E1}\times2^\mathrm{E2}$, reduced modulo
one more than the maximum value representable in the result type. Otherwise, if
\tcode{E1} has a signed type and non-negative value, and $\mathrm{E1}\times2^\mathrm{E2}$ is
representable in the corresponding unsigned type of the result type, then
that value, converted to the result type, is the resulting value; otherwise, the
behavior is undefined.

\pnum
The value of \tcode{E1 \shr\ E2} is \tcode{E1} right-shifted \tcode{E2}
bit positions. If \tcode{E1} has an unsigned type or if \tcode{E1} has a
signed type and a non-negative value, the value of the result is the
integral part of the quotient of $\mathrm{E1}/2^\mathrm{E2}$. If \tcode{E1}
\indextext{right~shift!implementation~defined}%
has a signed type and a negative value, the resulting value is
\impldef{result of right shift of negative value}.

\rSec1[expr.rel]{Relational operators}%
\indextext{expression!relational operators}%
\indextext{operator!relational}

\pnum
The relational operators group left-to-right.
\enterexample 
\tcode{a<b<c} means \tcode{(a<b)<c} and \emph{not}
\tcode{(a<b)\&\&(b<c)}.
\exitexample 

\indextext{operator!less~than}%
\indextext{\idxcode{<}|see{less~than~operator}}%
\indextext{operator!greater~than}%
\indextext{\idxcode{>}|see{greater~than~operator}}%
\indextext{operator!less~than~or~equal~to}%
\indextext{\idxcode{<=}|see{less~than~or~equal~to~operator}}%
\indextext{operator!greater~than~or~equal~to}%
\indextext{\idxcode{>=}|see{greater~than~or~equal~operator}}%
%
\begin{bnf}
\nontermdef{relational-expression}\br
    shift-expression\br
    relational-expression \terminal{<} shift-expression\br
    relational-expression \terminal{>} shift-expression\br
    relational-expression \terminal{<=} shift-expression\br
    relational-expression \terminal{>=} shift-expression
\end{bnf}

The operands shall have arithmetic, enumeration, or pointer type, or type \tcode{std::nullptr_t}. The
operators \tcode{<} (less than), \tcode{>} (greater than), \tcode{<=}
(less than or equal to), and \tcode{>=} (greater than or equal to) all
yield \tcode{false} or \tcode{true}. The type of the result is
\tcode{bool}.

\pnum
The usual arithmetic conversions are performed on operands of arithmetic
or enumeration type. Pointer conversions~(\ref{conv.ptr}) and
qualification conversions~(\ref{conv.qual}) are performed on pointer
operands (or on a pointer operand and a null pointer constant, or on two
null pointer constants, at least one of which is non-integral) to bring
them to their \term{composite pointer type}. If one operand is a
null pointer constant, the composite pointer type is
\tcode{std::nullptr_t} if the other operand is also a null pointer constant or,
if the other operand is a pointer,
the type of the
other operand. Otherwise, if one of the operands has type ``pointer to
\cvqual{cv1} \tcode{void},'' then the other has type ``pointer to
\cvqual{cv2} \term{T}'' and the composite pointer type is ``pointer to
\cvqual{cv12} \tcode{void},'' where \cvqual{cv12} is the union of
\cvqual{cv1} and \cvqual{cv2}. Otherwise, the composite pointer type is
a pointer type similar~(\ref{conv.qual}) to the type of one of the
operands, with a cv-qualification signature~(\ref{conv.qual}) that is
the union of the cv-qualification signatures of the operand types.
\enternote 
\indextext{comparison!void* pointer@\tcode{void*} pointer}%
this implies
that any pointer can be compared to a null pointer constant and that any
object pointer can be compared to a pointer to (possibly cv-qualified)
\tcode{void}.
\exitnote 
\enterexample 

\begin{codeblock}
void *p;
const int *q;
int **pi;
const int *const *pci;
void ct() {
  p <= q;           // Both converted to \tcode{const void*} before comparison
  pi <= pci;        // Both converted to \tcode{const int *const *} before comparison
}
\end{codeblock}
\exitexample 
\indextext{comparison!pointer}%
\indextext{comparison!pointer~to function}%
Pointers to objects or functions of the same type (after pointer
conversions) can be compared, with a result defined as follows:

\begin{itemize}
\item If two pointers \tcode{p} and \tcode{q} of the same type point to
the same object or function, or both point one past the end of the same
array, or are both null, then \tcode{p<=q} and \tcode{p>=q} both yield
\tcode{true} and \tcode{p<q} and \tcode{p>q} both yield \tcode{false}.

\item If two pointers \tcode{p} and \tcode{q} of the same type point to
different objects that are not members of the same object or elements of
the same array or to different functions, or if only one of them is
null, the results of \tcode{p<q}, \tcode{p>q}, \tcode{p<=q}, and
\tcode{p>=q} are unspecified.

\item If two pointers point to non-static data members of the same
object, or to subobjects or array elements of such members, recursively,
the pointer to the later declared member compares greater provided the
two members
have the same access control (Clause~\ref{class.access})
and provided their class is not a union.

\indextext{comparison!undefined pointer}%
\item If two pointers point to non-static data members of the same
object
with different access control (Clause~\ref{class.access})
the result is unspecified.

\item If two pointers point to non-static data members of the same union object,
they compare equal (after conversion to \tcode{void*}, if necessary). If
two pointers point to elements of the same array or one beyond the end
of the array, the pointer to the object with the higher subscript
compares higher.

\indextext{comparison!unspecified pointer}%
\indextext{comparison!pointer}%
\item Other pointer comparisons are unspecified.
\end{itemize}

\pnum
Pointers to \tcode{void} (after pointer conversions) can be compared, with a result
defined as follows: If both pointers represent the same address or are both the null
pointer value, the result is \tcode{true} if the operator is \tcode{<=} or \tcode{>=}
and \tcode{false} otherwise; otherwise the result is unspecified.

\pnum
If two operands of type \tcode{std::nullptr_t} are compared, the result is
\tcode{true} if the operator is \tcode{<=} or \tcode{>=}, and \tcode{false}
otherwise.

\pnum
If both operands (after conversions) are of arithmetic or enumeration type, each
of the operators shall yield \tcode{true} if the specified relationship is true
and \tcode{false} if it is false.

\rSec1[expr.eq]{Equality operators}%
\indextext{expression!equality~operators}%
\indextext{operator!equality}%
\indextext{operator!inequality}

\begin{bnf}
\nontermdef{equality-expression}\br
    relational-expression\br
    equality-expression \terminal{==} relational-expression\br
    equality-expression \terminal{!=} relational-expression
\end{bnf}

\pnum
The \tcode{==} (equal to) and the \tcode{!=} (not equal to) operators
have the same semantic restrictions, conversions, and result type as the
relational operators except for their lower precedence and truth-value
result.
\enternote 
\tcode{a<b == c<d} is \tcode{true} whenever \tcode{a<b} and \tcode{c<d}
have the same truth-value.
\exitnote 
\indextext{comparison!pointer}%
\indextext{comparison!pointer~to function}%
Pointers of the same type (after pointer
conversions) can be compared for equality. Two pointers of the same type
compare equal if and only if they are both null, both point to the same
\indextext{address}%
function, or both represent the same address~(\ref{basic.compound}).

\pnum
In addition, pointers to members can be compared, or a pointer to member
and a null pointer constant. Pointer to member
conversions~(\ref{conv.mem}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to a common
type. If one operand is a null pointer constant, the common type is the
type of the other operand. Otherwise, the common type is a pointer to
member type similar~(\ref{conv.qual}) to the type of one of the
operands, with a cv-qualification signature~(\ref{conv.qual}) that is
the union of the cv-qualification signatures of the operand types.
\enternote 
this implies that any pointer to member can be compared to a null
pointer constant.
\exitnote 
If both operands are null, they compare equal. Otherwise if only one is
null, they compare unequal. Otherwise if either is a pointer to a
virtual member function, the result is unspecified. Otherwise they
compare equal if and only if they would refer to the same member of the
same most derived object~(\ref{intro.object}) or the same subobject if
indirection with a hypothetical object of the associated
class type were performed.
\enterexample 

\begin{codeblock}
struct B {
  int f();
};
struct L : B { };
struct R : B { };
struct D : L, R { };

int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr);          // \tcode{false}
\end{codeblock}
\exitexample 

\pnum
If two operands of type \tcode{std::nullptr_t} are compared, the result is
\tcode{true} if the operator is \tcode{==}, and \tcode{false} otherwise.

\pnum
Each of the operators shall yield \tcode{true} if the specified relationship is
true and \tcode{false} if it is false.

\rSec1[expr.bit.and]{Bitwise AND operator}%
\indextext{expression!bitwise~AND}%
\indextext{operator!bitwise}%
\indextext{operator!bitwise AND}%
\indextext{\idxcode{\&}|see{bitwise~AND~operator}}%

\begin{bnf}
\nontermdef{and-expression}\br
    equality-expression\br
    and-expression \terminal{\&} equality-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise \logop{AND} function of the operands. The operator
applies only to integral or unscoped enumeration operands.

\rSec1[expr.xor]{Bitwise exclusive OR operator}%
\indextext{expression!bitwise~exclusive~OR}%
\indextext{operator!bitwise~exclusive OR}%
\indextext{\idxcode{\exor}|see{bitwise~exclusive~OR~operator}}

\begin{bnf}
\nontermdef{exclusive-or-expression}\br
    and-expression\br
    exclusive-or-expression \terminal{\^{}} and-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise exclusive \logop{OR} function of the operands. The
operator applies only to integral or unscoped enumeration operands.

\rSec1[expr.or]{Bitwise inclusive OR operator}%
\indextext{expression!bitwise~inclusive~OR}%
\indextext{operator!bitwise~inclusive OR}%
\indextext{\idxcode{"|}|see{bitwise~inclusive~OR~operator}}

\begin{bnf}
\nontermdef{inclusive-or-expression}\br
    exclusive-or-expression\br
    inclusive-or-expression \terminal{|} exclusive-or-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise inclusive \logop{OR} function of its operands. The
operator applies only to integral or unscoped enumeration operands.

\rSec1[expr.log.and]{Logical AND operator}%
\indextext{expression!logical~AND}%
\indextext{operator!logical AND}%
\indextext{\idxcode{\&\&}|see{logical~AND~operator}}%

\begin{bnf}
\nontermdef{logical-and-expression}\br
    inclusive-or-expression\br
    logical-and-expression \terminal{\&\&} inclusive-or-expression
\end{bnf}

\pnum
The \tcode{\&\&} operator groups left-to-right. The operands are both
contextually converted to \tcode{bool}
(Clause~\ref{conv}). The
result is \tcode{true} if both operands are \tcode{true} and
\tcode{false} otherwise. Unlike \tcode{\&}, \tcode{\&\&} guarantees
left-to-right evaluation: the second operand is not evaluated if the
first operand is \tcode{false}.

\pnum
The result is a \tcode{bool}.
\indextext{operator!side~effects~and logical AND}%
If the second expression is evaluated, every
\indextext{value computation}%
value computation and
\indextext{side effects}
side
effect associated with the first expression is sequenced before every
value computation and side effect associated with the second expression.

\rSec1[expr.log.or]{Logical OR operator}%
\indextext{expression!logical~OR}%
\indextext{operator!logical OR}%
\indextext{\idxcode{"|"|}|see{logical~OR~operator}}%

\begin{bnf}
\nontermdef{logical-or-expression}\br
    logical-and-expression\br
    logical-or-expression \terminal{$||$} logical-and-expression
\end{bnf}

\pnum
The \tcode{$||$} operator groups left-to-right. The operands are both
contextually converted to \tcode{bool}
(Clause~\ref{conv}). It returns
\tcode{true} if either of its operands is \tcode{true}, and
\tcode{false} otherwise. Unlike \tcode{$|$}, \tcode{$||$} guarantees
left-to-right evaluation; moreover, the second operand is not evaluated
if the first operand evaluates to \tcode{true}.

\pnum
The result is a \tcode{bool}.
\indextext{operator!side~effects~and logical OR}%
If the second expression is evaluated, every
\indextext{value computation}%
value computation and
\indextext{side effects}%
side effect
associated with the first expression is sequenced before every value computation
and side effect associated with the second expression.

\rSec1[expr.cond]{Conditional operator}%
\indextext{expression!conditional~operator}%
\indextext{operator!conditional~expression}%
\indextext{\idxcode{?:}|see{conditional~expression~operator}}%

\begin{bnf}
\nontermdef{conditional-expression}\br
    logical-or-expression\br
    logical-or-expression \terminal{?} expression \terminal{:} assignment-expression
\end{bnf}

\pnum
Conditional expressions group right-to-left. The first expression is
contextually converted to \tcode{bool}
(Clause~\ref{conv}). It is
evaluated and if it is \tcode{true}, the result of the conditional
expression is the value of the second expression, otherwise that of the
third expression. Only one of the second and third expressions is
evaluated. Every
\indextext{value computation}%
value computation and side effect associated with the
first expression is sequenced before every value computation and side
effect associated with the second or third expression.

\pnum
If either the second or the third operand has type \tcode{void},
then the lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) standard conversions are performed
on the second and third operands, and one of the following shall hold:

\begin{itemize}
\indextext{conditional-expression!throw-expression~in}%
\item The second or the third operand (but not both) is a
\grammarterm{throw-expression}~(\ref{except.throw}); the result is of the
type of the other and is a prvalue.

\item Both the second and the third operands have type \tcode{void}; the
result is of type \tcode{void} and is a prvalue. \enternote This
includes the case where both operands are \grammarterm{throw-expression}{s}.
\exitnote
\end{itemize}

\pnum
Otherwise, if the second and third operand have different types and
either has (possibly cv-qualified) class type, or if both
are glvalues of the same value category and the same type except for
cv-qualification, an attempt is made to
convert each of those operands to the type of the other. The process for
determining whether an operand expression \tcode{E1} of type \tcode{T1}
can be converted to match an operand expression \tcode{E2} of type
\tcode{T2} is defined as follows:

\begin{itemize}
\item If \tcode{E2} is an lvalue: \tcode{E1} can be converted to match
\tcode{E2} if \tcode{E1} can be implicitly converted (Clause~\ref{conv})
to the type ``lvalue reference to \tcode{T2}'', subject to the
constraint that in the conversion the reference must bind
directly~(\ref{dcl.init.ref}) to an lvalue.

\item If \tcode{E2} is an xvalue: \tcode{E1} can be converted to match \tcode{E2}
if \tcode{E1} can be implicitly converted to the type ``rvalue reference to \tcode{T2}'',
subject to the constraint that the reference must bind directly.

\item If \tcode{E2} is an rvalue or if neither of the conversions above can be
done and at least one of the operands has (possibly cv-qualified) class type:

\begin{itemize}
\item if \tcode{E1} and \tcode{E2} have class type, and the underlying
class types are the same or one is a base class of the other: \tcode{E1}
can be converted to match \tcode{E2} if the class of \tcode{T2} is the
same type as, or a base class of, the class of \tcode{T1}, and the
cv-qualification of \tcode{T2} is the same cv-qualification as, or a
greater cv-qualification than, the cv-qualification of \tcode{T1}. If
the conversion is applied, \tcode{E1} is changed to a prvalue of type
\tcode{T2} by copy-initializing a temporary of type \tcode{T2} from
\tcode{E1} and using that temporary as the converted operand.

\item Otherwise (i.e., if \tcode{E1} or \tcode{E2} has a nonclass type,
or if they both have class types but the underlying classes are not
either the same or one a base class of the other): \tcode{E1} can be
converted to match \tcode{E2} if \tcode{E1} can be implicitly converted
to the type that expression \tcode{E2} would have if \tcode{E2} were
converted to a prvalue (or the type it has,
if \tcode{E2} is a prvalue).
\end{itemize}
\end{itemize}

Using this process, it is determined whether the second operand can be
converted to match the third operand, and whether the third operand can
be converted to match the second operand. If both can be converted, or
one can be converted but the conversion is ambiguous, the program is
ill-formed. If neither can be converted, the operands are left unchanged
and further checking is performed as described below. If exactly one
conversion is possible, that conversion is applied to the chosen operand
and the converted operand is used in place of the original operand for
the remainder of this section.

\pnum
If the second and third operands are glvalues of the same value category
and have the same type, the
result is of that type and value category and it is a bit-field if the
second or the third operand is a bit-field, or if both are bit-fields.

\pnum
Otherwise, the result is a prvalue. If the second and third operands do
not have the same type, and either has (possibly cv-qualified) class
type, overload resolution is used to determine the conversions (if any)
to be applied to the operands~(\ref{over.match.oper},~\ref{over.built}).
If the overload resolution fails, the program is ill-formed. Otherwise,
the conversions thus determined are applied, and the converted operands
are used in place of the original operands for the remainder of this
section.

\pnum
Lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the second and third operands. After those conversions, one
of the following shall hold:

\begin{itemize}
\item The second and third operands have the same type; the result is of
that type. If the operands have class type, the result is a prvalue
temporary of the result type, which is copy-initialized from either the
second operand or the third operand depending on the value of the first
operand.

\item The second and third operands have arithmetic or enumeration type;
the usual arithmetic conversions are performed to bring them to a common
type, and the result is of that type.

\item The second and third operands have pointer type, or one has
pointer type and the other is a null pointer constant, or both are
null pointer constants, at least one of which is non-integral; pointer
conversions~(\ref{conv.ptr}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to their
composite pointer type~(\ref{expr.rel}). The result is of the composite
pointer type.

\item The second and third operands have pointer to member type, or one
has pointer to member type and the other is a null pointer constant;
pointer to member conversions~(\ref{conv.mem}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to a common
type, whose cv-qualification shall match the cv-qualification of either
the second or the third operand. The result is of the common type.
\end{itemize}

\rSec1[expr.ass]{Assignment and compound assignment operators}%
\indextext{expression!assignment and compound assignment}

\pnum
\indextext{operator!assignment}%
\indextext{\idxcode{=}|see{assignment~operator}}%
\indextext{operator!\idxcode{+=}}%
\indextext{operator!\idxcode{-=}}%
\indextext{operator!\idxcode{*=}}%
\indextext{operator!\idxcode{/=}}%
\indextext{operator!\idxcode{\%=}}%
\indextext{operator!\idxcode{\shr=}}%
\indextext{operator!\idxcode{\shl=}}%
\indextext{operator!\idxcode{\&=}}%
\indextext{operator!\idxcode{\^{}=}}%
\indextext{operator!\idxcode{"|=}}%
The assignment operator (\tcode{=}) and the compound assignment
operators all group right-to-left.
\indextext{assignment!and lvalue}%
All
require a modifiable lvalue as their left operand and return an lvalue
referring to the left operand. The result in all cases is a bit-field if
the left operand is a bit-field. In all cases, the assignment is
sequenced after the
\indextext{value computation}%
value computation of the right and left operands,
and before the
value computation of the assignment expression. With
respect to an indeterminately-sequenced function call, the operation of
a compound assignment is a single evaluation.
\enternote
Therefore, a function call shall not intervene between the
lvalue-to-rvalue conversion and the side effect associated with any
single compound assignment operator.
\exitnote

\begin{bnf}
\nontermdef{assignment-expression}\br
    conditional-expression\br
    logical-or-expression assignment-operator initializer-clause\br
    throw-expression
\end{bnf}

\begin{bnf}
\nontermdef{assignment-operator} \textnormal{one of}\br
    \terminal{=  *=  /=  \%=   +=  -=  \shr=  \shl=  \&=  \^{}=  |=}
\end{bnf}

\pnum
In simple assignment (\tcode{=}), the value of the expression replaces
that of the object referred to by the left operand.

\pnum
\indextext{assignment!conversion~by}%
If the left operand is not of class type, the expression is implicitly
converted (Clause~\ref{conv}) to the cv-unqualified type of the left
operand.

\pnum
\indextext{class~object!assignment~to}%
\indextext{type!incomplete}%
If the left operand is of class type, the class shall be complete.
Assignment to objects of a class is defined by the copy/move assignment
operator~(\ref{class.copy},~\ref{over.ass}).

\pnum
\enternote 
For class objects, assignment is not in general the same as
initialization~(\ref{dcl.init},~\ref{class.ctor},~\ref{class.init},~\ref{class.copy}).
\exitnote 

\pnum
\indextext{reference!assignment~to}%
When the left operand of an assignment operator denotes a reference to
\tcode{T}, the operation assigns to the object of type \tcode{T} denoted
by the reference.

\pnum
The behavior of an expression of the form \tcode{E1} \term{op}\tcode{=}
\tcode{E2} is equivalent to \tcode{E1 = E1} \term{op} \tcode{E2} except
that \tcode{E1} is evaluated only once. In \tcode{+=} and \tcode{-=},
\tcode{E1} shall either have arithmetic type or be a pointer to a
possibly cv-qualified completely-defined object type. In all other
cases, \tcode{E1} shall have arithmetic type.

\pnum
If the value being stored in an object is accessed from another object that
overlaps in any way the storage of the first object, then the overlap shall be
exact and the two objects shall have the same type, otherwise the behavior is
undefined. \enternote This restriction applies to the relationship
between the left and right sides of the assignment operation; it is not a
statement about how the target of the assignment may be aliased in general.
See~\ref{basic.lval}. \exitnote

\pnum
A \grammarterm{braced-init-list} may appear on the right-hand side of

\begin{itemize}
\item an assignment to a scalar, in which case the initializer list shall have
at most a single element. The meaning of \tcode{x=\{v\}}, where \tcode{T} is the
scalar type of the expression \tcode{x}, is that of \tcode{x=T(v)} except that
no narrowing conversion~(\ref{dcl.init.list}) is allowed. The meaning of
\tcode{x=\{\}} is \tcode{x=T()}.

\item an assignment defined by a user-defined assignment operator, in which case
the initializer list is passed as the argument to the operator function.
\end{itemize}

\enterexample
\begin{codeblock}
complex<double> z;
z = { 1,2 };              // meaning \tcode{z.operator=(\{1,2\})}
z += { 1, 2 };            // meaning \tcode{z.operator+=(\{1,2\})}
int a, b;
a = b = { 1 };            // meaning \tcode{a=b=1;}
a = { 1 } = b;            // syntax error
\end{codeblock}
\exitexample

\rSec1[expr.comma]{Comma operator}%
\indextext{expression!comma}%
\indextext{operator!comma}%
\indextext{\idxcode{,}|see{comma~operator}}%
\indextext{sequencing~operator|see{comma~operator}}%

\pnum
The comma operator groups left-to-right.

\begin{bnf}
\nontermdef{expression}\br
    assignment-expression\br
    expression \terminal{,} assignment-expression
\end{bnf}

A pair of expressions separated by a comma is evaluated left-to-right;
the left expression is
a discarded-value expression (Clause~\ref{expr}).\footnote{However, an
invocation of an overloaded comma operator is an ordinary function call; hence,
the evaluations of its argument expressions are unsequenced relative to one
another~(see \ref{intro.execution}).}
Every
\indextext{value computation}%
value computation and side effect
associated with the left expression is sequenced before every value
computation and side effect associated with the right expression.
\indextext{operator!side~effects~and comma}%
The type and value of the
result are the type and value of the right operand; the result is of the same
value category as its right operand, and is a bit-field if its
right operand is a glvalue and a bit-field.
If the value of the right operand is a temporary~(\ref{class.temporary}),
the result is that temporary.

\pnum
In contexts where comma is given a special meaning, \enterexample in
lists of arguments to functions~(\ref{expr.call}) and lists of
initializers~(\ref{dcl.init}) \exitexample the comma operator as
described in Clause~\ref{expr} can appear only in parentheses.
\enterexample 

\begin{codeblock}
f(a, (t=3, t+2), c);
\end{codeblock}

has three arguments, the second of which has the value
\tcode{5}.
\exitexample 

\rSec1[expr.const]{Constant expressions}%
\indextext{expression!constant}

\pnum
Certain contexts require expressions that satisfy additional
requirements as detailed in this sub-clause; other contexts have different
semantics depending on whether or not an expression satisfies these requirements.
Expressions that satisfy these requirements are called 
\term{constant expressions}. \enternote Constant expressions can be evaluated
during translation.\exitnote

\begin{bnf}
\nontermdef{constant-expression}\br
    conditional-expression
\end{bnf}

\pnum
A \grammarterm{conditional-expression} is a
\term{core constant expression}
unless it involves one of the following as a potentially evaluated
subexpression~(\ref{basic.def.odr}), but 
subexpressions of logical AND~(\ref{expr.log.and}),
logical OR~(\ref{expr.log.or}), and conditional~(\ref{expr.cond})
operations that are not evaluated are not considered 
\enternote An overloaded operator invokes a function.\exitnote:

\begin{itemize}
\item
\tcode{this}~(\ref{expr.prim.general})
\enternote when evaluating a constant expression, function invocation
substitution~(\ref{dcl.constexpr}) replaces each occurrence of
\tcode{this} in a \tcode{constexpr} member function with a pointer to
the class object. \exitnote;

\item
an invocation of a function other than
a \tcode{constexpr} constructor for a literal class or
a \tcode{constexpr} function
\enternote Overload resolution~(\ref{over.match})
is applied as usual \exitnote;

\item
an invocation of an undefined \tcode{constexpr} function or an
undefined \tcode{constexpr} constructor;

\item
an invocation of a \tcode{constexpr} function with arguments that, when
substituted by function invocation substitution~(\ref{dcl.constexpr}),
do not
produce a core constant expression; \enterexample
\begin{codeblock}
constexpr const int* addr(const int& ir) { return &ir; }  // OK
static const int x = 5;
constexpr const int* xp = addr(x);  // OK: \tcode{(const int*)\&(const int\&)x} is an
                                    // address constant expression
constexpr const int* tp = addr(5);  // error, initializer for \tcode{constexpr} variable not a constant
                                    // expression; \tcode{(const int*)\&(const int\&)5} is not a constant
                                    // expression because it takes the address of a temporary
\end{codeblock}
\exitexample

\item
an invocation of a \tcode{constexpr} constructor with arguments that, when substituted
by function invocation substitution~(\ref{dcl.constexpr}), do not
produce all core constant
expressions for the constructor calls and full-expressions in the
\grammarterm{mem-initializer}{s} (including conversions); \enterexample
\begin{codeblock}
int x;                              // not constant
struct A {
  constexpr A(bool b) : m(b?42:x) { }
  int m;
};
constexpr int v = A(true).m;        // OK: constructor call initializes
                                    // \tcode{m} with the value \tcode{42} after substitution
constexpr int w = A(false).m;       // error: initializer for \tcode{m} is
                                    // \tcode{x}, which is non-constant
\end{codeblock}
\exitexample

\item
an invocation of a \tcode{constexpr} function or a \tcode{constexpr}
constructor that would exceed the implementation-defined recursion limits
(see Annex~\ref{implimits});

\item
an operation that would have undefined behavior \enternote including,
for example, signed integer overflow~(Clause \ref{expr}), certain
pointer arithmetic~(\ref{expr.add}), division by
zero~(\ref{expr.mul}), or certain shift operations~(\ref{expr.shift})
\exitnote;

\item
a \grammarterm{lambda-expression}~(\ref{expr.prim.lambda});

\item
an lvalue-to-rvalue conversion~(\ref{conv.lval}) unless
it is applied to

\begin{itemize}
  \item
  a non-volatile glvalue of integral or enumeration type that refers
  to a non-volatile const object with a preceding initialization,
  initialized with a constant expression \enternote a string
  literal~(\ref{lex.string}) corresponds to an array of such 
  objects. \exitnote, or

  \item
  a non-volatile glvalue of literal type that refers to a non-volatile object
  defined with \tcode{constexpr}, or that refers to a sub-object
  of such an object, or

  \item
  a non-volatile glvalue of literal type that refers to a non-volatile
  temporary object whose lifetime has not ended, initialized with a core
  constant expression;
\end{itemize}

\item
an lvalue-to-rvalue conversion~(\ref{conv.lval}) that is applied to a glvalue
that refers to a non-active member of a union or a subobject thereof;

\item
an \grammarterm{id-expression} that refers to a variable or
data member of reference type
unless the reference has a preceding initialization and either

\begin{itemize}
  \item
  it is initialized with a constant expression or

  \item
  it is a non-static data member of a temporary object whose lifetime
  has not ended and is initialized with a core constant expression;
\end{itemize}

\item
a conversion from type \cv{} \tcode{void *} to a pointer-to-object type;

\item
a dynamic cast~(\ref{expr.dynamic.cast});

\item
a \tcode{reinterpret_cast}~(\ref{expr.reinterpret.cast});

\item
a pseudo-destructor call~(\ref{expr.pseudo});

\item
increment or decrement operations~(\ref{expr.post.incr}, \ref{expr.pre.incr});

\item
a typeid expression~(\ref{expr.typeid}) whose operand
is of a polymorphic class type;

\item
a \grammarterm{new-expression}~(\ref{expr.new});

\item
a \grammarterm{delete-expression}~(\ref{expr.delete});

\item
a relational~(\ref{expr.rel}) or equality~(\ref{expr.eq})
operator where the result is unspecified;

\item
an assignment or a compound assignment~(\ref{expr.ass}); or

\item
a \grammarterm{throw-expression}~(\ref{except.throw}).
\end{itemize}

\pnum
An \term{integral constant expression} is an expression of integral or
unscoped enumeration type, implicitly converted to a prvalue, where the converted expression is a core constant expression.
\enternote
Such expressions may be
used as array bounds~(\ref{dcl.array}, \ref{expr.new}),
as bit-field lengths~(\ref{class.bit}), as enumerator
initializers if the underlying type is not fixed~(\ref{dcl.enum}),
as null pointer constants~(\ref{conv.ptr}), and as alignments~(\ref{dcl.align}).
\exitnote
A \term{converted constant expression} of type \tcode{T} is an
expression, implicitly converted to a prvalue of type \tcode{T}, where
the converted expression is a core constant expression and the
implicit conversion sequence contains only user-defined conversions, lvalue-to-rvalue
conversions~(\ref{conv.lval}), integral promotions~(\ref{conv.prom}), and
integral conversions~(\ref{conv.integral}) other than narrowing conversions~(\ref{dcl.init.list}).
\enternote
such expressions may be used in \tcode{new}
expressions~(\ref{expr.new}), as case expressions~(\ref{stmt.switch}),
as enumerator initializers if the underlying type is
fixed~(\ref{dcl.enum}), as array bounds~(\ref{dcl.array}), and
as integral or enumeration non-type template
arguments~(\ref{temp.arg}). 
\exitnote

\pnum
A \term{literal constant expression} is a prvalue core constant
expression of literal type, but not pointer type (after conversions as
required by the context). For a literal constant expression of array
or class type, each subobject of its value shall have been initialized
by a constant expression. 
A \term{reference constant expression} is an lvalue core constant
expression that designates an object with static storage duration or a
function. An \term{address constant expression} is a prvalue core
constant expression (after conversions as required by the context) of
type \tcode{std::nullptr_t} or of
pointer type that evaluates to the address of an object with static
storage duration, to the address of a function, or to a null pointer 
value. Collectively, literal constant expressions, reference constant 
expressions, and address constant expressions are called 
\term{constant expressions}.

\pnum
\enternote Although in some contexts constant expressions must be evaluated during program
translation, others may be evaluated during program execution. Since this International Standard
imposes no restrictions on the accuracy of floating-point operations, it is unspecified whether the
evaluation of a floating-point expression during translation yields the same result as the
evaluation of the same expression (or the same operations on the same values) during program
execution.\footnote{Nonetheless, implementations are encouraged to provide consistent results,
irrespective of whether the evaluation was actually performed during translation or during program
execution.} \enterexample

\begin{codeblock}
bool f() {
    char array[1 + int(1 + 0.2 - 0.1 - 0.1)];  // Must be evaluated during translation
    int size = 1 + int(1 + 0.2 - 0.1 - 0.1);   // May be evaluated at runtime
    return sizeof(array) == size;
}
\end{codeblock}
It is unspecified whether the value of \tcode{f()} will be \tcode{true} or \tcode{false}.
\exitexample \exitnote

\pnum
If an expression of literal class type is used in a context where an 
integral constant expression is required, then that expression is
contextually implicitly converted (Clause~\ref{conv}) to an integral or unscoped
enumeration type 
and the selected conversion function shall be \tcode{constexpr}. \enterexample
\begin{codeblock}
struct A { 
  constexpr A(int i) : val(i) { } 
  constexpr operator int() { return val; } 
  constexpr operator long() { return 43; } 
private: 
  int val; 
}; 
template<int> struct X { }; 
constexpr A a = 42; 
X<a> x;             // OK: unique conversion to \tcode{int}
int ary[a];         // error: ambiguous conversion 
\end{codeblock}
\exitexample%
\indextext{expression|)}
