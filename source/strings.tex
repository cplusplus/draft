%!TEX root = std.tex
\rSec0[strings]{Strings library}

\rSec1[strings.general]{General}

\pnum
This Clause describes components for manipulating sequences of
any non-array trivial standard-layout\iref{basic.types} type.
Such types are called \defnx{char-like types}{char-like type},
and objects of
char-like types are called \defnx{char-like objects}{char-like object} or
simply \term{characters}.

\pnum
The following subclauses describe a
character traits class, string classes, and
null-terminated sequence utilities,
as summarized in \tref{strings.summary}.

\begin{libsumtab}[x{2.1in}]{Strings library summary}{strings.summary}
\ref{char.traits}     & Character traits                    & \tcode{<string>}  \\
\ref{string.classes}  & String classes                      &   \\ \rowsep
\ref{string.view}     & String view classes                 & \tcode{<string_view>} \\ \rowsep
\ref{c.strings}       & Null-terminated sequence utilities  &
  \tcode{<cctype>}, \tcode{<cstdlib>}, \tcode{<cstring>},
  \tcode{<cuchar>}, \tcode{<cwchar>}, \tcode{<cwctype>}  \\
\end{libsumtab}

\rSec1[char.traits]{Character traits}

\rSec2[char.traits.general]{General}

\pnum
Subclause \ref{char.traits} defines requirements on classes representing
\term{character traits},
and defines a class template
\tcode{char_traits<charT>},
along with five specializations,
\tcode{char_traits<char>},
\tcode{char_traits<char8_t>},
\tcode{char_traits<char16_t>},
\tcode{char_traits<char32_t>},
and
\tcode{char_traits<wchar_t>},
that meet those requirements.

\pnum
Most classes specified in \ref{string.classes}, \ref{string.view},
and \ref{input.output} need a set of related types and functions to complete
the definition of their semantics.  These types and functions are provided as a
set of member \grammarterm{typedef-name}{s} and functions in the template
parameter \tcode{traits} used by each such template.
Subclause \ref{char.traits} defines the semantics of these members.

\pnum
To specialize those templates to generate a string, string view, or
iostream class to handle a particular character container type\iref{defns.character.container}
\tcode{C},
that and its related character traits class
\tcode{X}
are passed as a pair of parameters to the string, string view, or iostream template as
parameters
\tcode{charT}
and
\tcode{traits}.
If
\tcode{X::char_type}
is not the same type as
\tcode{C}, the program is ill-formed.

\rSec2[char.traits.require]{Character traits requirements}

\pnum
In \tref{char.traits.req},
\tcode{X}
denotes a traits class defining types and functions for the
character container type
\tcode{C};
\tcode{c}
and
\tcode{d}
denote values of type
\tcode{C};
\tcode{p}
and
\tcode{q}
denote values of type
\tcode{const C*};
\tcode{s}
denotes a value of type
\tcode{C*};
\tcode{n},
\tcode{i}
and
\tcode{j}
denote values of type
\tcode{size_t};
\tcode{e}
and
\tcode{f}
denote values of type
\tcode{X::int_type};
\tcode{pos}
denotes a value of type
\tcode{X::pos_type};
and
\tcode{r}
denotes an lvalue of type
\tcode{C}.
No expression which is part of the character traits requirements
specified in this subclause \ref{char.traits.require}
shall exit via an exception.

\begin{libreqtab4d}
{Character traits requirements}
{char.traits.req}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Assertion/note}   &   \rhdr{Complexity}\\
                        &                       &   \chdr{pre-/post-condition}   &               \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Assertion/note}   &   \rhdr{Complexity}\\
                        &                       &   \chdr{pre-/post-condition}   &               \\ \capsep
\endhead
\tcode{X::char_type}    &   \tcode{C}       &
   &   compile-time    \\ \rowsep
\tcode{X::int_type} &                       &
(described in~\ref{char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::off_type} &                       &
(described in~\ref{iostreams.limits.pos} and \ref{iostream.forward})   &   compile-time    \\ \rowsep
\tcode{X::pos_type} &                       &
(described in~\ref{iostreams.limits.pos} and \ref{iostream.forward})   &   compile-time    \\ \rowsep
\tcode{X::state_type}   &                       &
(described in~\ref{char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::eq(c,d)}      &   \tcode{bool}        &
\returns
whether \tcode{c} is to be treated as equal to \tcode{d}.   &   constant    \\ \rowsep
\tcode{X::lt(c,d)}      &   \tcode{bool}        &
\returns
whether \tcode{c} is to be treated as less than \tcode{d}.  &   constant    \\ \rowsep
\tcode{X::compare(p,q,n)}   &   \tcode{int}     &
\returns
\tcode{0} if for each \tcode{i} in \tcode{[0,n)}, \tcode{X::eq(p[i],q[i])}
is \tcode{true}; else, a negative value if, for some \tcode{j} in \tcode{[0,n)},
\tcode{X::lt(p[j],q[j])} is \tcode{true} and for each \tcode{i} in \tcode{[0,j)}
\tcode{X::eq(p[i],q[i])} is \tcode{true}; else a positive value.            &   linear      \\ \rowsep
\tcode{X::length(p)}    &   \tcode{size_t}     &
\returns
the smallest \tcode{i} such that \tcode{X::eq(p[i],charT())} is \tcode{true}.  &   linear  \\ \rowsep
\tcode{X::find(p,n,c)}  &   \tcode{const X::char_type*} &
\returns
the smallest \tcode{q} in \tcode{[p,p+n)} such that
\tcode{X::eq(*q,c)} is \tcode{true}, zero otherwise.                        &   linear      \\ \rowsep
\tcode{X::move(s,p,n)}  &   \tcode{X::char_type*}   &
for each \tcode{i} in \tcode{[0,n)}, performs \tcode{X::assign(s[i],p[i])}.
Copies correctly even where the ranges \tcode{[p,p+n)} and \tcode{[s,s+n)} overlap.\br \returns \tcode{s}.    &   linear  \\ \rowsep
\tcode{X::copy(s,p,n)}  &   \tcode{X::char_type*}   &
\expects
\tcode{p} not in \tcode{[s,s+n)}.\par
\returns
\tcode{s}.\br
for each \tcode{i} in
\tcode{[0,n)}, performs \tcode{X::assign(s[i],p[i])}.               &   linear      \\ \rowsep
\tcode{X::assign(r,d)}  &   (not used)          &
assigns \tcode{r=d}.                            &   constant        \\ \rowsep
\tcode{X::assign\-(s,n,c)}  &   \tcode{X::char_type*}   &
for each \tcode{i} in \tcode{[0,n)}, performs
\tcode{X::assign(s[i],c)}.\br
\returns
\tcode{s}.                       &   linear      \\ \rowsep
\tcode{X::not_eof(e)}   &   \tcode{int_type}        &
\returns
\tcode{e} if \tcode{X::eq_int_type(e,X::eof())} is \tcode{false},
otherwise a value \tcode{f} such that
\tcode{X::eq_int_type(f,X::eof())} is \tcode{false}.                       &   constant    \\ \rowsep
\tcode{X::to_char_type\-(e)}    &   \tcode{X::char_type}    &
\returns
if for some \tcode{c}, \tcode{X::eq_int_type(e,X::to_int_type(c))}
is \tcode{true}, \tcode{c}; else some unspecified value.                    &   constant    \\ \rowsep
\tcode{X::to_int_type\-(c)} &   \tcode{X::int_type} &
\returns
some value \tcode{e}, constrained by the definitions of
\tcode{to_char_type} and \tcode{eq_int_type}.                  &   constant    \\ \rowsep
\tcode{X::eq_int_type\-(e,f)}   &   \tcode{bool}            &
\returns
for all \tcode{c} and \tcode{d}, \tcode{X::eq(c,d)} is equal to
\tcode{X::eq_int_type(X::to_int_type(c), X::to_int_type(d))}; otherwise, yields \tcode{true}
if \tcode{e} and \tcode{f} are both copies of \tcode{X::eof()}; otherwise, yields \tcode{false} if
one of \tcode{e} and \tcode{f} is a copy of \tcode{X::eof()} and the other is not; otherwise
the value is unspecified.                                           &   constant    \\ \rowsep
\tcode{X::eof()}                &   \tcode{X::int_type} &
\returns
a value \tcode{e} such that \tcode{X::eq_int_type(e,X::to_int_type(c))}
is \tcode{false} for all values \tcode{c}.                                  &   constant    \\
\end{libreqtab4d}

\pnum
The class template
\indexlibraryglobal{char_traits}%
\begin{codeblock}
template<class charT> struct char_traits;
\end{codeblock}
is provided in the header \libheader{string}
as a basis for explicit specializations.

\rSec2[char.traits.typedefs]{Traits typedefs}

\indexlibrarymember{char_type}{char_traits}%
\indexlibrarymember{int_type}{char_traits}%
\begin{itemdecl}
using int_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{int_type}
shall be able to represent all of the
valid characters converted from the corresponding
\tcode{char_type}
values, as well as an end-of-file value,
\tcode{eof()}.
\begin{footnote}
If
\tcode{eof()}
can be held in
\tcode{char_type}
then some iostreams operations can give surprising results.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{state_type}{char_traits}%
\begin{itemdecl}
using state_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{state_type} meets the
\oldconcept{Destructible} (\tref{cpp17.destructible}),
\oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}),
\oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible}), and
\oldconcept{DefaultConstructible} (\tref{cpp17.defaultconstructible}) requirements.
\end{itemdescr}

\rSec2[char.traits.specializations]{\tcode{char_traits} specializations}

\rSec3[char.traits.specializations.general]{General}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char>;
  template<> struct char_traits<char8_t>;
  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;
  template<> struct char_traits<wchar_t>;
}
\end{codeblock}

\pnum
The header \libheader{string}
defines five specializations of the class template
\tcode{char_traits}:
\tcode{char_traits<\brk{}char>},
\tcode{char_traits<char8_t>},
\tcode{char_traits<char16_t>},
\tcode{char_traits<char32_t>},
and
\tcode{char_traits<wchar_t>}.


\rSec3[char.traits.specializations.char]{\tcode{struct char_traits<char>}}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char> {
    using char_type  = char;
    using int_type   = int;
    using off_type   = streamoff;
    using pos_type   = streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type& a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
\end{codeblock}

\pnum
The type \tcode{mbstate_t} is defined in \libheader{cwchar}
and can represent any of the conversion states that can occur in an
\impldef{supported multibyte character encoding rules} set of supported multibyte
character encoding rules.

\pnum
The two-argument member \tcode{assign} is defined identically to the
built-in operator \tcode{=}. The two-argument members \tcode{eq}
and \tcode{lt} are defined identically to the built-in operators
\tcode{==} and \tcode{<} for type \tcode{unsigned char}.

\pnum
The member
\tcode{eof()}
returns
\tcode{EOF}.

\rSec3[char.traits.specializations.char8.t]{\tcode{struct char_traits<char8_t>}}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char8_t> {
    using char_type  = char8_t;
    using int_type   = unsigned int;
    using off_type   = streamoff;
    using pos_type   = u8streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type& a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
\end{codeblock}

\pnum
The two-argument members \tcode{assign}, \tcode{eq}, and \tcode{lt}
are defined identically to
the built-in operators \tcode{=}, \tcode{==}, and \tcode{<} respectively.

\pnum
The member \tcode{eof()} returns an implementation-defined constant
that cannot appear as a valid UTF-8 code unit.

\rSec3[char.traits.specializations.char16.t]{\tcode{struct char_traits<char16_t>}}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char16_t> {
    using char_type  = char16_t;
    using int_type   = uint_least16_t;
    using off_type   = streamoff;
    using pos_type   = u16streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type& a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
\end{codeblock}


\pnum
The two-argument members \tcode{assign},
\tcode{eq}, and \tcode{lt} are defined identically to
the built-in operators \tcode{=}, \tcode{==}, and
\tcode{<}, respectively.

\pnum
The member \tcode{eof()} returns an
\impldef{return value of \tcode{char_traits<char16_t>::eof}} constant that cannot appear
as a valid UTF-16 code unit.

\rSec3[char.traits.specializations.char32.t]{\tcode{struct char_traits<char32_t>}}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char32_t> {
    using char_type  = char32_t;
    using int_type   = uint_least32_t;
    using off_type   = streamoff;
    using pos_type   = u32streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type& a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
\end{codeblock}


\pnum
The two-argument members \tcode{assign},
\tcode{eq}, and \tcode{lt} are defined identically to
the built-in operators \tcode{=}, \tcode{==}, and
\tcode{<}, respectively.

\pnum
The member \tcode{eof()} returns an
\impldef{return value of \tcode{char_traits<char32_t>::eof}} constant that cannot appear as a Unicode
code point.

\rSec3[char.traits.specializations.wchar.t]{\tcode{struct char_traits<wchar_t>}}

\indexlibraryglobal{char_traits}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<wchar_t> {
    using char_type  = wchar_t;
    using int_type   = wint_t;
    using off_type   = streamoff;
    using pos_type   = wstreampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type& a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);

    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}
\end{codeblock}


\pnum
The two-argument members
\tcode{assign},
\tcode{eq},
and
\tcode{lt}
are defined identically
to the built-in operators
\tcode{=},
\tcode{==},
and
\tcode{<},
respectively.

\pnum
The member
\tcode{eof()}
returns
\tcode{WEOF}.

\rSec1[string.classes]{String classes}

\rSec2[string.classes.general]{General}

\pnum
The header \tcode{<string>} defines the
\tcode{basic_string} class template for manipulating
varying-length sequences of char-like objects and five
\grammarterm{typedef-name}{s}, \tcode{string},
\tcode{u8string},
\tcode{u16string},
\tcode{u32string},
and \tcode{wstring}, that name
the specializations
\tcode{basic_string<char>},
\tcode{basic_string<char8_t>},
\tcode{basic_string<char16_t>},
\tcode{basic_string<char32_t>},
and
\tcode{basic_string<\brk{}wchar_t>}, respectively.

\rSec2[string.syn]{Header \tcode{<string>} synopsis}
\indexheader{string}%

\begin{codeblock}
#include <compare>              // see \ref{compare.syn}
#include <initializer_list>     // see \ref{initializer.list.syn}

namespace std {
  // \ref{char.traits}, character traits
  template<class charT> struct char_traits;
  template<> struct char_traits<char>;
  template<> struct char_traits<char8_t>;
  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;
  template<> struct char_traits<wchar_t>;

  // \ref{basic.string}, \tcode{basic_string}
  template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
    class basic_string;

  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(basic_string<charT, traits, Allocator>&& lhs,
                const basic_string<charT, traits, Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const basic_string<charT, traits, Allocator>& lhs,
                basic_string<charT, traits, Allocator>&& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(basic_string<charT, traits, Allocator>&& lhs,
                basic_string<charT, traits, Allocator>&& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const charT* lhs,
                const basic_string<charT, traits, Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const charT* lhs,
                basic_string<charT, traits, Allocator>&& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(charT lhs,
                const basic_string<charT, traits, Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(charT lhs,
                basic_string<charT, traits, Allocator>&& rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const basic_string<charT, traits, Allocator>& lhs,
                const charT* rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(basic_string<charT, traits, Allocator>&& lhs,
                const charT* rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(const basic_string<charT, traits, Allocator>& lhs,
                charT rhs);
  template<class charT, class traits, class Allocator>
    constexpr basic_string<charT, traits, Allocator>
      operator+(basic_string<charT, traits, Allocator>&& lhs,
                charT rhs);

  template<class charT, class traits, class Allocator>
    constexpr bool
      operator==(const basic_string<charT, traits, Allocator>& lhs,
                 const basic_string<charT, traits, Allocator>& rhs) noexcept;
  template<class charT, class traits, class Allocator>
    constexpr bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                              const charT* rhs);

  template<class charT, class traits, class Allocator>
    constexpr @\seebelow@ operator<=>(const basic_string<charT, traits, Allocator>& lhs,
              @\itcorr@                      const basic_string<charT, traits, Allocator>& rhs) noexcept;
  template<class charT, class traits, class Allocator>
    constexpr @\seebelow@ operator<=>(const basic_string<charT, traits, Allocator>& lhs,
              @\itcorr@                      const charT* rhs);

  // \ref{string.special}, swap
  template<class charT, class traits, class Allocator>
    constexpr void
      swap(basic_string<charT, traits, Allocator>& lhs,
           basic_string<charT, traits, Allocator>& rhs)
        noexcept(noexcept(lhs.swap(rhs)));

  // \ref{string.io}, inserters and extractors
  template<class charT, class traits, class Allocator>
    basic_istream<charT, traits>&
      operator>>(basic_istream<charT, traits>& is,
                 basic_string<charT, traits, Allocator>& str);
  template<class charT, class traits, class Allocator>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 const basic_string<charT, traits, Allocator>& str);
  template<class charT, class traits, class Allocator>
    basic_istream<charT, traits>&
      getline(basic_istream<charT, traits>& is,
              basic_string<charT, traits, Allocator>& str,
              charT delim);
  template<class charT, class traits, class Allocator>
    basic_istream<charT, traits>&
      getline(basic_istream<charT, traits>&& is,
              basic_string<charT, traits, Allocator>& str,
              charT delim);
  template<class charT, class traits, class Allocator>
    basic_istream<charT, traits>&
      getline(basic_istream<charT, traits>& is,
              basic_string<charT, traits, Allocator>& str);
  template<class charT, class traits, class Allocator>
    basic_istream<charT, traits>&
      getline(basic_istream<charT, traits>&& is,
              basic_string<charT, traits, Allocator>& str);

  // \ref{string.erasure}, erasure
  template<class charT, class traits, class Allocator, class U>
    constexpr typename basic_string<charT, traits, Allocator>::size_type
      erase(basic_string<charT, traits, Allocator>& c, const U& value);
  template<class charT, class traits, class Allocator, class Predicate>
    constexpr typename basic_string<charT, traits, Allocator>::size_type
      erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred);

  // \tcode{basic_string} typedef names
  using @\libglobal{string}@    = basic_string<char>;
  using @\libglobal{u8string}@  = basic_string<char8_t>;
  using @\libglobal{u16string}@ = basic_string<char16_t>;
  using @\libglobal{u32string}@ = basic_string<char32_t>;
  using @\libglobal{wstring}@   = basic_string<wchar_t>;

  // \ref{string.conversions}, numeric conversions
  int stoi(const string& str, size_t* idx = nullptr, int base = 10);
  long stol(const string& str, size_t* idx = nullptr, int base = 10);
  unsigned long stoul(const string& str, size_t* idx = nullptr, int base = 10);
  long long stoll(const string& str, size_t* idx = nullptr, int base = 10);
  unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);
  float stof(const string& str, size_t* idx = nullptr);
  double stod(const string& str, size_t* idx = nullptr);
  long double stold(const string& str, size_t* idx = nullptr);
  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);
  string to_string(float val);
  string to_string(double val);
  string to_string(long double val);

  int stoi(const wstring& str, size_t* idx = nullptr, int base = 10);
  long stol(const wstring& str, size_t* idx = nullptr, int base = 10);
  unsigned long stoul(const wstring& str, size_t* idx = nullptr, int base = 10);
  long long stoll(const wstring& str, size_t* idx = nullptr, int base = 10);
  unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);
  float stof(const wstring& str, size_t* idx = nullptr);
  double stod(const wstring& str, size_t* idx = nullptr);
  long double stold(const wstring& str, size_t* idx = nullptr);
  wstring to_wstring(int val);
  wstring to_wstring(unsigned val);
  wstring to_wstring(long val);
  wstring to_wstring(unsigned long val);
  wstring to_wstring(long long val);
  wstring to_wstring(unsigned long long val);
  wstring to_wstring(float val);
  wstring to_wstring(double val);
  wstring to_wstring(long double val);

  namespace pmr {
    template<class charT, class traits = char_traits<charT>>
      using basic_string = std::basic_string<charT, traits, polymorphic_allocator<charT>>;

    using string    = basic_string<char>;
    using u8string  = basic_string<char8_t>;
    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;
    using wstring   = basic_string<wchar_t>;
  }

  // \ref{basic.string.hash}, hash support
  template<class T> struct hash;
  template<> struct hash<string>;
  template<> struct hash<u8string>;
  template<> struct hash<u16string>;
  template<> struct hash<u32string>;
  template<> struct hash<wstring>;
  template<> struct hash<pmr::string>;
  template<> struct hash<pmr::u8string>;
  template<> struct hash<pmr::u16string>;
  template<> struct hash<pmr::u32string>;
  template<> struct hash<pmr::wstring>;

  inline namespace literals {
  inline namespace string_literals {
    // \ref{basic.string.literals}, suffix for \tcode{basic_string} literals
    constexpr string    operator""s(const char* str, size_t len);
    constexpr u8string  operator""s(const char8_t* str, size_t len);
    constexpr u16string operator""s(const char16_t* str, size_t len);
    constexpr u32string operator""s(const char32_t* str, size_t len);
    constexpr wstring   operator""s(const wchar_t* str, size_t len);
  }
  }
}
\end{codeblock}

\rSec2[basic.string]{Class template \tcode{basic_string}}

\rSec3[basic.string.general]{General}

\pnum
\indexlibraryglobal{basic_string}%
The
class template
\tcode{basic_string}
describes objects that can store a sequence consisting of a varying number of
arbitrary char-like objects with the first element of the sequence at position zero.
Such a sequence is also called a ``string'' if the type of the
char-like objects that it holds
is clear from context.
In the rest of \ref{basic.string},
the type of the char-like objects held in a \tcode{basic_string} object
is designated by \tcode{charT}.

\pnum
A specialization of \tcode{basic_string} is a contiguous container\iref{container.requirements.general}.

\pnum
In all cases,
\crange{data()}{data() + size()} is a valid range,
\tcode{data() + size()} points at an object with value \tcode{charT()}
(a ``null terminator''\indextext{string!null terminator}),
and \tcode{size() <= capacity()} is \tcode{true}.


\indexlibraryglobal{basic_string}%
\indexlibrarymember{traits_type}{basic_string}%
\indexlibrarymember{value_type}{basic_string}%
\indexlibrarymember{allocator_type}{basic_string}%
\indexlibrarymember{size_type}{basic_string}%
\indexlibrarymember{difference_type}{basic_string}%
\indexlibrarymember{pointer}{basic_string}%
\indexlibrarymember{const_pointer}{basic_string}%
\indexlibrarymember{reference}{basic_string}%
\indexlibrarymember{const_reference}{basic_string}%
\indexlibrarymember{iterator}{basic_string}%
\indexlibrarymember{const_iterator}{basic_string}%
\indexlibrarymember{reverse_iterator}{basic_string}%
\indexlibrarymember{const_reverse_iterator}{basic_string}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>,
           class Allocator = allocator<charT>>
  class basic_string {
  public:
    // types
    using traits_type            = traits;
    using value_type             = charT;
    using allocator_type         = Allocator;
    using size_type              = typename allocator_traits<Allocator>::size_type;
    using difference_type        = typename allocator_traits<Allocator>::difference_type;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;

    using iterator               = @\impdefx{type of \tcode{basic_string::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{basic_string::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    static const size_type npos  = -1;

    // \ref{string.cons}, construct/copy/destroy
    constexpr basic_string() noexcept(noexcept(Allocator())) : basic_string(Allocator()) { }
    constexpr explicit basic_string(const Allocator& a) noexcept;
    constexpr basic_string(const basic_string& str);
    constexpr basic_string(basic_string&& str) noexcept;
    constexpr basic_string(const basic_string& str, size_type pos,
                           const Allocator& a = Allocator());
    constexpr basic_string(const basic_string& str, size_type pos, size_type n,
                           const Allocator& a = Allocator());
    template<class T>
      constexpr basic_string(const T& t, size_type pos, size_type n,
                             const Allocator& a = Allocator());
    template<class T>
      constexpr explicit basic_string(const T& t, const Allocator& a = Allocator());
    constexpr basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
    constexpr basic_string(const charT* s, const Allocator& a = Allocator());
    basic_string(nullptr_t) = delete;
    constexpr basic_string(size_type n, charT c, const Allocator& a = Allocator());
    template<class InputIterator>
      constexpr basic_string(InputIterator begin, InputIterator end,
                             const Allocator& a = Allocator());
    constexpr basic_string(initializer_list<charT>, const Allocator& = Allocator());
    constexpr basic_string(const basic_string&, const Allocator&);
    constexpr basic_string(basic_string&&, const Allocator&);
    constexpr ~basic_string();

    constexpr basic_string& operator=(const basic_string& str);
    constexpr basic_string& operator=(basic_string&& str)
      noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    template<class T>
      constexpr basic_string& operator=(const T& t);
    constexpr basic_string& operator=(const charT* s);
    basic_string& operator=(nullptr_t) = delete;
    constexpr basic_string& operator=(charT c);
    constexpr basic_string& operator=(initializer_list<charT>);

    // \ref{string.iterators}, iterators
    constexpr iterator       begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator       end() noexcept;
    constexpr const_iterator end() const noexcept;

    constexpr reverse_iterator       rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator       rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;

    constexpr const_iterator         cbegin() const noexcept;
    constexpr const_iterator         cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

    // \ref{string.capacity}, capacity
    constexpr size_type size() const noexcept;
    constexpr size_type length() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr void resize(size_type n, charT c);
    constexpr void resize(size_type n);
    constexpr size_type capacity() const noexcept;
    constexpr void reserve(size_type res_arg);
    constexpr void shrink_to_fit();
    constexpr void clear() noexcept;
    [[nodiscard]] constexpr bool empty() const noexcept;

    // \ref{string.access}, element access
    constexpr const_reference operator[](size_type pos) const;
    constexpr reference       operator[](size_type pos);
    constexpr const_reference at(size_type n) const;
    constexpr reference       at(size_type n);

    constexpr const charT& front() const;
    constexpr charT&       front();
    constexpr const charT& back() const;
    constexpr charT&       back();

    // \ref{string.modifiers}, modifiers
    constexpr basic_string& operator+=(const basic_string& str);
    template<class T>
      constexpr basic_string& operator+=(const T& t);
    constexpr basic_string& operator+=(const charT* s);
    constexpr basic_string& operator+=(charT c);
    constexpr basic_string& operator+=(initializer_list<charT>);
    constexpr basic_string& append(const basic_string& str);
    constexpr basic_string& append(const basic_string& str, size_type pos, size_type n = npos);
    template<class T>
      constexpr basic_string& append(const T& t);
    template<class T>
      constexpr basic_string& append(const T& t, size_type pos, size_type n = npos);
    constexpr basic_string& append(const charT* s, size_type n);
    constexpr basic_string& append(const charT* s);
    constexpr basic_string& append(size_type n, charT c);
    template<class InputIterator>
      constexpr basic_string& append(InputIterator first, InputIterator last);
    constexpr basic_string& append(initializer_list<charT>);

    constexpr void push_back(charT c);

    constexpr basic_string& assign(const basic_string& str);
    constexpr basic_string& assign(basic_string&& str)
      noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    constexpr basic_string& assign(const basic_string& str, size_type pos, size_type n = npos);
    template<class T>
      constexpr basic_string& assign(const T& t);
    template<class T>
      constexpr basic_string& assign(const T& t, size_type pos, size_type n = npos);
    constexpr basic_string& assign(const charT* s, size_type n);
    constexpr basic_string& assign(const charT* s);
    constexpr basic_string& assign(size_type n, charT c);
    template<class InputIterator>
      constexpr basic_string& assign(InputIterator first, InputIterator last);
    constexpr basic_string& assign(initializer_list<charT>);

    constexpr basic_string& insert(size_type pos, const basic_string& str);
    constexpr basic_string& insert(size_type pos1, const basic_string& str,
                                   size_type pos2, size_type n = npos);
    template<class T>
      constexpr basic_string& insert(size_type pos, const T& t);
    template<class T>
      constexpr basic_string& insert(size_type pos1, const T& t,
                                     size_type pos2, size_type n = npos);
    constexpr basic_string& insert(size_type pos, const charT* s, size_type n);
    constexpr basic_string& insert(size_type pos, const charT* s);
    constexpr basic_string& insert(size_type pos, size_type n, charT c);
    constexpr iterator insert(const_iterator p, charT c);
    constexpr iterator insert(const_iterator p, size_type n, charT c);
    template<class InputIterator>
      constexpr iterator insert(const_iterator p, InputIterator first, InputIterator last);
    constexpr iterator insert(const_iterator p, initializer_list<charT>);

    constexpr basic_string& erase(size_type pos = 0, size_type n = npos);
    constexpr iterator erase(const_iterator p);
    constexpr iterator erase(const_iterator first, const_iterator last);

    constexpr void pop_back();

    constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
    constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                                    size_type pos2, size_type n2 = npos);
    template<class T>
      constexpr basic_string& replace(size_type pos1, size_type n1, const T& t);
    template<class T>
      constexpr basic_string& replace(size_type pos1, size_type n1, const T& t,
                                      size_type pos2, size_type n2 = npos);
    constexpr basic_string& replace(size_type pos, size_type n1, const charT* s, size_type n2);
    constexpr basic_string& replace(size_type pos, size_type n1, const charT* s);
    constexpr basic_string& replace(size_type pos, size_type n1, size_type n2, charT c);
    constexpr basic_string& replace(const_iterator i1, const_iterator i2,
                                    const basic_string& str);
    template<class T>
      constexpr basic_string& replace(const_iterator i1, const_iterator i2, const T& t);
    constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s,
                                    size_type n);
    constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
    constexpr basic_string& replace(const_iterator i1, const_iterator i2, size_type n, charT c);
    template<class InputIterator>
      constexpr basic_string& replace(const_iterator i1, const_iterator i2,
                                      InputIterator j1, InputIterator j2);
    constexpr basic_string& replace(const_iterator, const_iterator, initializer_list<charT>);

    constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;

    constexpr void swap(basic_string& str)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
               allocator_traits<Allocator>::is_always_equal::value);

    // \ref{string.ops}, string operations
    constexpr const charT* c_str() const noexcept;
    constexpr const charT* data() const noexcept;
    constexpr charT* data() noexcept;
    constexpr operator basic_string_view<charT, traits>() const noexcept;
    constexpr allocator_type get_allocator() const noexcept;

    template<class T>
      constexpr size_type find(const T& t, size_type pos = 0) const noexcept(@\seebelow@);
    constexpr size_type find(const basic_string& str, size_type pos = 0) const noexcept;
    constexpr size_type find(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find(const charT* s, size_type pos = 0) const;
    constexpr size_type find(charT c, size_type pos = 0) const noexcept;
    template<class T>
      constexpr size_type rfind(const T& t, size_type pos = npos) const noexcept(@\seebelow@);
    constexpr size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
    constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
    constexpr size_type rfind(const charT* s, size_type pos = npos) const;
    constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;

    template<class T>
      constexpr size_type find_first_of(const T& t, size_type pos = 0) const noexcept(@\seebelow@);
    constexpr size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
    template<class T>
      constexpr size_type find_last_of(const T& t,
                                       size_type pos = npos) const noexcept(@\seebelow@);
    constexpr size_type find_last_of(const basic_string& str,
                                     size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
    constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;

    template<class T>
      constexpr size_type find_first_not_of(const T& t,
                                            size_type pos = 0) const noexcept(@\seebelow@);
    constexpr size_type find_first_not_of(const basic_string& str,
                                          size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
    template<class T>
      constexpr size_type find_last_not_of(const T& t,
                                           size_type pos = npos) const noexcept(@\seebelow@);
    constexpr size_type find_last_not_of(const basic_string& str,
                                         size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;
    constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;

    constexpr basic_string substr(size_type pos = 0, size_type n = npos) const;

    template<class T>
      constexpr int compare(const T& t) const noexcept(@\seebelow@);
    template<class T>
      constexpr int compare(size_type pos1, size_type n1, const T& t) const;
    template<class T>
      constexpr int compare(size_type pos1, size_type n1, const T& t,
                            size_type pos2, size_type n2 = npos) const;
    constexpr int compare(const basic_string& str) const noexcept;
    constexpr int compare(size_type pos1, size_type n1, const basic_string& str) const;
    constexpr int compare(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2 = npos) const;
    constexpr int compare(const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;

    constexpr bool starts_with(basic_string_view<charT, traits> x) const noexcept;
    constexpr bool starts_with(charT x) const noexcept;
    constexpr bool starts_with(const charT* x) const;
    constexpr bool ends_with(basic_string_view<charT, traits> x) const noexcept;
    constexpr bool ends_with(charT x) const noexcept;
    constexpr bool ends_with(const charT* x) const;

    constexpr bool contains(basic_string_view<charT, traits> x) const noexcept;
    constexpr bool contains(charT x) const noexcept;
    constexpr bool contains(const charT* x) const;
  };

  template<class InputIterator,
           class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
    basic_string(InputIterator, InputIterator, Allocator = Allocator())
      -> basic_string<typename iterator_traits<InputIterator>::value_type,
                      char_traits<typename iterator_traits<InputIterator>::value_type>,
                      Allocator>;

  template<class charT,
           class traits,
           class Allocator = allocator<charT>>
    explicit basic_string(basic_string_view<charT, traits>, const Allocator& = Allocator())
      -> basic_string<charT, traits, Allocator>;

  template<class charT,
           class traits,
           class Allocator = allocator<charT>>
    basic_string(basic_string_view<charT, traits>,
                 typename @\seebelow@::size_type, typename @\seebelow@::size_type,
                 const Allocator& = Allocator())
      -> basic_string<charT, traits, Allocator>;
}
\end{codeblock}

\pnum
A \tcode{size_type} parameter type in
a \tcode{basic_string} deduction guide
refers to the \tcode{size_type} member type of
the type deduced by the deduction guide.

\rSec3[string.require]{General requirements}

\pnum
If any operation would cause \tcode{size()} to
exceed \tcode{max_size()}, that operation throws an
exception object of type \tcode{length_error}.

\pnum
If any member function or operator of \tcode{basic_string} throws an exception, that
function or operator has no other effect on the \tcode{basic_string} object.

\pnum
In every specialization \tcode{basic_string<charT, traits, Allocator>},
the type \tcode{allocator_traits<All\-ocator>::value_type} shall name the same type
as \tcode{charT}. Every object of type
\tcode{basic_string<charT, traits, Allocator>} uses an object of type
\tcode{Allocator} to allocate and free storage for the contained \tcode{charT}
objects as needed. The \tcode{Allocator} object used is
obtained as described in \ref{container.requirements.general}.
In every specialization \tcode{basic_string<charT, traits, Allocator>},
the type \tcode{traits} shall meet
the character traits requirements\iref{char.traits}.
\begin{note}
The program is ill-formed if \tcode{traits::char_type}
is not the same type as \tcode{charT}.
\end{note}

\pnum
References, pointers, and iterators referring to the elements of a
\tcode{basic_string} sequence may be
invalidated by the following uses of that \tcode{basic_string} object:

\begin{itemize}
\item Passing as an argument to any standard library function taking a reference to non-const
\tcode{basic_string} as an argument.
\begin{footnote}
For example, as an argument to non-member
functions \tcode{swap()}\iref{string.special},
\tcode{operator>{}>()}\iref{string.io}, and \tcode{getline()}\iref{string.io}, or as
an argument to \tcode{basic_string::swap()}.
\end{footnote}

\item Calling non-const member functions, except
\tcode{operator[]},
\tcode{at},
\tcode{data},
\tcode{front},
\tcode{back},
\tcode{begin},
\tcode{rbegin},
\tcode{end},
and
\tcode{rend}.
\end{itemize}

\rSec3[string.cons]{Constructors and assignment operators}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr explicit basic_string(const Allocator& a) noexcept;
\end{itemdecl}

\begin{itemdescr}

\pnum
\ensures
\tcode{size()} is equal to \tcode{0}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(const basic_string& str);
constexpr basic_string(basic_string&& str) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object whose
value is that of \tcode{str} prior to this call.

\pnum
\remarks
In the second form, \tcode{str} is left in a valid but unspecified state.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(const basic_string& str, size_type pos,
                       const Allocator& a = Allocator());
constexpr basic_string(const basic_string& str, size_type pos, size_type n,
                       const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Let \tcode{n} be \tcode{npos} for the first overload. Equivalent to:
\begin{codeblock}
basic_string(basic_string_view<charT, traits>(str).substr(pos, n), a)
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>}
is \tcode{true}.

\pnum
\effects
Creates a variable, \tcode{sv},
as if by \tcode{basic_string_view<charT, traits> sv = t;}
and then behaves the same as:
\begin{codeblock}
basic_string(sv.substr(pos, n), a);
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr explicit basic_string(const T& t, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Creates a variable, \tcode{sv}, as if by
\tcode{basic_string_view<charT, traits> sv = t;} and
then behaves the same as \tcode{basic_string(sv.data(), sv.size(), a)}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{s}{s + n} is a valid range.

\pnum
\effects
Constructs an object whose initial value is the range \range{s}{s + n}.

\pnum
\ensures
\tcode{size()} is equal to \tcode{n}, and
\tcode{traits::compare(data(), s, n)} is equal to \tcode{0}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(const charT* s, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{Allocator} is a type
that qualifies as an allocator\iref{container.requirements.general}.
\begin{note}
This affects class template argument deduction.
\end{note}

\pnum
\effects
Equivalent to: \tcode{basic_string(s, traits::length(s), a)}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(size_type n, charT c, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{Allocator} is a type
that qualifies as an allocator\iref{container.requirements.general}.
\begin{note}
This affects class template argument deduction.
\end{note}

\pnum
\effects
Constructs an object whose value consists of \tcode{n} copies of \tcode{c}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
template<class InputIterator>
  constexpr basic_string(InputIterator begin, InputIterator end, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input
iterator\iref{container.requirements.general}.

\pnum
\effects
Constructs a string from the values in the range \range{begin}{end},
as indicated in \tref{container.seq.req}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(initializer_list<charT> il, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{basic_string(il.begin(), il.end(), a)}.
\end{itemdescr}

\indexlibraryctor{basic_string}%
\begin{itemdecl}
constexpr basic_string(const basic_string& str, const Allocator& alloc);
constexpr basic_string(basic_string&& str, const Allocator& alloc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object whose value is
that of \tcode{str} prior to this call.
The stored allocator is constructed from \tcode{alloc}.
In the second form, \tcode{str} is left in a valid but unspecified state.

\pnum
\throws
The second form throws nothing if \tcode{alloc == str.get_allocator()}.
\end{itemdescr}

\begin{itemdecl}
template<class InputIterator,
         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
  basic_string(InputIterator, InputIterator, Allocator = Allocator())
    -> basic_string<typename iterator_traits<InputIterator>::value_type,
                    char_traits<typename iterator_traits<InputIterator>::value_type>,
                    Allocator>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input iterator,
and \tcode{Allocator} is a type that qualifies as an allocator\iref{container.requirements.general}.
\end{itemdescr}

\begin{itemdecl}
template<class charT,
         class traits,
         class Allocator = allocator<charT>>
  explicit basic_string(basic_string_view<charT, traits>, const Allocator& = Allocator())
    -> basic_string<charT, traits, Allocator>;

template<class charT,
         class traits,
         class Allocator = allocator<charT>>
  basic_string(basic_string_view<charT, traits>,
               typename @\seebelow@::size_type, typename @\seebelow@::size_type,
               const Allocator& = Allocator())
    -> basic_string<charT, traits, Allocator>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{Allocator} is a type that qualifies as
an allocator\iref{container.requirements.general}.
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator=(const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} and \tcode{str} are the same object, has no effect.
Otherwise, replaces the value of \tcode{*this} with a copy of \tcode{str}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator=(basic_string&& str)
  noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Move assigns as a sequence container\iref{container.requirements},
except that iterators, pointers and references may be invalidated.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& operator=(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>}
is \tcode{true} and
\item \tcode{is_convertible_v<const T\&, const charT*>}
is \tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return assign(sv);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator=(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return *this = basic_string_view<charT, traits>(s);}
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator=(charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return *this = basic_string_view<charT, traits>(addressof(c), 1);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator=(initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return *this = basic_string_view<charT, traits>(il.begin(), il.size());
\end{codeblock}
\end{itemdescr}

\rSec3[string.iterators]{Iterator support}

\indexlibrarymember{begin}{basic_string}%
\indexlibrarymember{cbegin}{basic_string}%
\begin{itemdecl}
constexpr iterator       begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referring to the first character in the string.
\end{itemdescr}

\indexlibrarymember{end}{basic_string}%
\indexlibrarymember{cend}{basic_string}%
\begin{itemdecl}
constexpr iterator       end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator which is the past-the-end value.
\end{itemdescr}

\indexlibrarymember{rbegin}{basic_string}%
\indexlibrarymember{crbegin}{basic_string}%
\begin{itemdecl}
constexpr reverse_iterator       rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator which is semantically equivalent to
\tcode{reverse_iterator(end())}.
\end{itemdescr}

\indexlibrarymember{rend}{basic_string}%
\indexlibrarymember{crend}{basic_string}%
\begin{itemdecl}
constexpr reverse_iterator       rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator which is semantically equivalent to
\tcode{reverse_iterator(begin())}.
\end{itemdescr}

\rSec3[string.capacity]{Capacity}

\indexlibrarymember{size}{basic_string}%
\indexlibrarymember{length}{basic_string}%
\begin{itemdecl}
constexpr size_type size() const noexcept;
constexpr size_type length() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A count of the number of char-like objects currently in the string.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{max_size}{basic_string}%
\begin{itemdecl}
constexpr size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The largest possible number of char-like objects that can be stored in a
\tcode{basic_string}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{resize}{basic_string}%
\begin{itemdecl}
constexpr void resize(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the value of
\tcode{*this}
as follows:
\begin{itemize}
\item
If
\tcode{n <= size()},
erases the last \tcode{size() - n} elements.
\item
If
\tcode{n > size()},
appends \tcode{n - size()} copies of \tcode{c}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{resize}{basic_string}%
\begin{itemdecl}
constexpr void resize(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{resize(n, charT())}.
\end{itemdescr}

\indexlibrarymember{capacity}{basic_string}%
\begin{itemdecl}
constexpr size_type capacity() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The size of the allocated storage in the string.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{reserve}{basic_string}%
\begin{itemdecl}
constexpr void reserve(size_type res_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
A directive that informs a \tcode{basic_string} of a planned change in size,
so that the storage allocation can be managed accordingly.
After
\tcode{reserve()},
\tcode{capacity()}
is greater or equal to the argument of
\tcode{reserve}
if reallocation happens; and
equal to the previous value of
\tcode{capacity()}
otherwise.
Reallocation happens at this point if and only if
the current capacity is less than the argument of \tcode{reserve()}.

\pnum
\throws
\tcode{length_error}
if
\tcode{res_arg > max_size()} or any exceptions thrown by
\tcode{allocator_traits} \tcode{<Allocator>::allocate}.
\end{itemdescr}

\indexlibrarymember{shrink_to_fit}{basic_string}%
\begin{itemdecl}
constexpr void shrink_to_fit();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{shrink_to_fit} is a non-binding request to reduce
\tcode{capacity()} to \tcode{size()}.
\begin{note}
The request is non-binding to
allow latitude for implementation-specific optimizations.
\end{note}
It does not increase \tcode{capacity()}, but may reduce \tcode{capacity()}
by causing reallocation.

\pnum
\complexity
If the size is not equal to the old capacity,
linear in the size of the sequence;
otherwise constant.

\pnum
\remarks
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence, as well as the past-the-end iterator.
\begin{note}
If no reallocation happens, they remain valid.
\end{note}
\end{itemdescr}

\indexlibrarymember{clear}{basic_string}%
\begin{itemdecl}
constexpr void clear() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{erase(begin(), end());}
\end{itemdescr}

\indexlibrarymember{empty}{basic_string}%
\begin{itemdecl}
[[nodiscard]] constexpr bool empty() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return size() == 0;}
\end{itemdescr}

\rSec3[string.access]{Element access}

\indexlibrarymember{operator[]}{basic_string}%
\begin{itemdecl}
constexpr const_reference operator[](size_type pos) const;
constexpr reference       operator[](size_type pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{pos <= size()}.

\pnum
\returns
\tcode{*(begin() + pos)} if \tcode{pos < size()}. Otherwise,
returns a reference to an object of type \tcode{charT} with value
\tcode{charT()}, where modifying the object to any value other than
\tcode{charT()} leads to undefined behavior.

\pnum
\throws
Nothing.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{at}{basic_string}%
\begin{itemdecl}
constexpr const_reference at(size_type pos) const;
constexpr reference       at(size_type pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{operator[](pos)}.

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos >= size()}.
\end{itemdescr}

\indexlibrarymember{front}{basic_string}%
\begin{itemdecl}
constexpr const charT& front() const;
constexpr charT& front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\effects
Equivalent to: \tcode{return operator[](0);}
\end{itemdescr}

\indexlibrarymember{back}{basic_string}%
\begin{itemdecl}
constexpr const charT& back() const;
constexpr charT& back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\effects
Equivalent to: \tcode{return operator[](size() - 1);}
\end{itemdescr}

\rSec3[string.modifiers]{Modifiers}

\rSec4[string.op.append]{\tcode{basic_string::operator+=}}

\indexlibrarymember{operator+=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator+=(const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(str);}


\end{itemdescr}

\indexlibrarymember{operator+=}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& operator+=(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return append(sv);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator+=(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(s);}
\end{itemdescr}

\indexlibrarymember{operator+=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator+=(charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(size_type\{1\}, c);}
\end{itemdescr}

\indexlibrarymember{operator+=}{basic_string}%
\begin{itemdecl}
constexpr basic_string& operator+=(initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(il);}
\end{itemdescr}


\rSec4[string.append]{\tcode{basic_string::append}}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(str.data(), str.size());}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(const basic_string& str, size_type pos, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return append(basic_string_view<charT, traits>(str).substr(pos, n));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& append(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return append(sv.data(), sv.size());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& append(const T& t, size_type pos, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return append(sv.substr(pos, n));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{s}{s + n} is a valid range.

\pnum
\effects
Appends a copy of the range \range{s}{s + n} to the string.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(s, traits::length(s));}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Appends \tcode{n} copies of \tcode{c} to the string.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
template<class InputIterator>
  constexpr basic_string& append(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input
iterator\iref{container.requirements.general}.

\pnum
\effects
Equivalent to: \tcode{return append(basic_string(first, last, get_allocator()));}
\end{itemdescr}

\indexlibrarymember{append}{basic_string}%
\begin{itemdecl}
constexpr basic_string& append(initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return append(il.begin(), il.size());}
\end{itemdescr}

\indexlibrarymember{push_back}{basic_string}%
\begin{itemdecl}
constexpr void push_back(charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\tcode{append(size_type\{1\}, c)}.
\end{itemdescr}

\rSec4[string.assign]{\tcode{basic_string::assign}}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *this = str;}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(basic_string&& str)
  noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *this = std::move(str);}
\end{itemdescr}


\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(const basic_string& str, size_type pos, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return assign(basic_string_view<charT, traits>(str).substr(pos, n));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& assign(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return assign(sv.data(), sv.size());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& assign(const T& t, size_type pos, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return assign(sv.substr(pos, n));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{s}{s + n} is a valid range.

\pnum
\effects
Replaces the string controlled by \tcode{*this} with
a copy of the range \range{s}{s + n}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(s, traits::length(s));}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(il.begin(), il.size());}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
constexpr basic_string& assign(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
clear();
resize(n, c);
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{assign}{basic_string}%
\begin{itemdecl}
template<class InputIterator>
  constexpr basic_string& assign(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input
iterator\iref{container.requirements.general}.

\pnum
\effects
Equivalent to: \tcode{return assign(basic_string(first, last, get_allocator()));}
\end{itemdescr}

\rSec4[string.insert]{\tcode{basic_string::insert}}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr basic_string& insert(size_type pos, const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return insert(pos, str.data(), str.size());}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr basic_string& insert(size_type pos1, const basic_string& str,
                               size_type pos2, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return insert(pos1, basic_string_view<charT, traits>(str), pos2, n);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& insert(size_type pos, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return insert(pos, sv.data(), sv.size());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& insert(size_type pos1, const T& t,
                                 size_type pos2, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return insert(pos1, sv.substr(pos2, n));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr basic_string& insert(size_type pos, const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{s}{s + n} is a valid range.

\pnum
\effects
Inserts a copy of the range \range{s}{s + n}
immediately before the character at position \tcode{pos} if \tcode{pos < size()},
or otherwise at the end of the string.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
\begin{itemize}
\item \tcode{out_of_range} if \tcode{pos > size()},
\item \tcode{length_error} if \tcode{n > max_size() - size()}, or
\item any exceptions thrown by \tcode{allocator_traits<Allocator>::allocate}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr basic_string& insert(size_type pos, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return insert(pos, s, traits::length(s));}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr basic_string& insert(size_type pos, size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts \tcode{n} copies of \tcode{c} before the character at position \tcode{pos}
if \tcode{pos < size()},
or otherwise at the end of the string.

\pnum
\returns
\tcode{*this}

\pnum
\throws
\begin{itemize}
\item \tcode{out_of_range} if \tcode{pos > size()},
\item \tcode{length_error} if \tcode{n > max_size() - size()}, or
\item any exceptions thrown by \tcode{allocator_traits<Allocator>::allocate}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr iterator insert(const_iterator p, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{p} is a valid iterator on
\tcode{*this}.

\pnum
\effects
Inserts a copy of \tcode{c} at the position \tcode{p}.

\pnum
\returns
An iterator which refers to the inserted character.
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr iterator insert(const_iterator p, size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{p} is a valid iterator on
\tcode{*this}.

\pnum
\effects
Inserts \tcode{n} copies of \tcode{c} at the position \tcode{p}.

\pnum
\returns
An iterator which refers to  the first inserted character, or
\tcode{p} if \tcode{n == 0}.
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
template<class InputIterator>
  constexpr iterator insert(const_iterator p, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input
iterator\iref{container.requirements.general}.

\pnum
\expects
\tcode{p} is a valid iterator on
\tcode{*this}.

\pnum
\effects
Equivalent to
\tcode{insert(p - begin(), basic_string(first, last, get_allocator()))}.

\pnum
\returns
An iterator which refers to the first inserted character, or
\tcode{p} if \tcode{first == last}.
\end{itemdescr}

\indexlibrarymember{insert}{basic_string}%
\begin{itemdecl}
constexpr iterator insert(const_iterator p, initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return insert(p, il.begin(), il.end());}
\end{itemdescr}

\rSec4[string.erase]{\tcode{basic_string::erase}}

\indexlibrarymember{erase}{basic_string}%
\begin{itemdecl}
constexpr basic_string& erase(size_type pos = 0, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the effective length \tcode{xlen}
of the string to be removed as the smaller of \tcode{n} and
\tcode{size() - pos}.
Removes the characters in the range \range{begin() + pos}{begin() + pos + xlen}.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos}
\tcode{> size()}.
\end{itemdescr}

\indexlibrarymember{erase}{basic_string}%
\begin{itemdecl}
constexpr iterator erase(const_iterator p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{p} is a valid dereferenceable iterator on \tcode{*this}.

\pnum
\effects
Removes the character referred to by \tcode{p}.

\pnum
\returns
An iterator which points to the element immediately following \tcode{p} prior to
the element being erased.
If no such element exists,
\tcode{end()}
is returned.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{erase}{basic_string}%
\begin{itemdecl}
constexpr iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{first} and \tcode{last} are valid iterators on
\tcode{*this}. \range{first}{last} is a valid range.

\pnum
\effects
Removes the characters in the range
\tcode{[first, last)}.

\pnum
\returns
An iterator which points to the element pointed to by \tcode{last} prior to
the other elements being erased.
If no such element exists,
\tcode{end()}
is returned.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{pop_back}{basic_string}%
\begin{itemdecl}
constexpr void pop_back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\effects
Equivalent to \tcode{erase(end() - 1)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec4[string.replace]{\tcode{basic_string::replace}}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(pos1, n1, str.data(), str.size());}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                                size_type pos2, size_type n2 = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return replace(pos1, n1, basic_string_view<charT, traits>(str).substr(pos2, n2));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& replace(size_type pos1, size_type n1, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return replace(pos1, n1, sv.data(), sv.size());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& replace(size_type pos1, size_type n1, const T& t,
                                  size_type pos2, size_type n2 = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return replace(pos1, n1, sv.substr(pos2, n2));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(size_type pos1, size_type n1, const charT* s, size_type n2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{s}{s + n2} is a valid range.

\pnum
\effects
Determines the effective length \tcode{xlen} of the string to be
removed as the smaller of \tcode{n1} and \tcode{size() - pos1}. If
\tcode{size() - xlen >= max_size() - n2} throws \tcode{length_error}. Otherwise,
the function replaces the characters in the range
\range{begin() + pos1}{begin() + pos1 + xlen}
with a copy of the range \range{s}{s + n2}.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
\begin{itemize}
\item \tcode{out_of_range} if \tcode{pos1 > size()},
\item \tcode{length_error} if the length of the resulting string
would exceed \tcode{max_size()}, or
\item any exceptions thrown by \tcode{allocator_traits<Allocator>::allocate}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(size_type pos, size_type n, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(pos, n, s, traits::length(s));}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(size_type pos1, size_type n1, size_type n2, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the effective length \tcode{xlen} of the string to be
removed as the smaller of \tcode{n1} and \tcode{size() - pos1}. If
\tcode{size() - xlen >=} \tcode{max_size() - n2} throws \tcode{length_error}. Otherwise,
the function replaces the characters in the range
\range{begin() + pos1}{begin() + pos1 + xlen}
with \tcode{n2} copies of \tcode{c}.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
\begin{itemize}
\item \tcode{out_of_range} if \tcode{pos1 > size()},
\item \tcode{length_error} if the length of the resulting string
would exceed\tcode{max_size()}, or
\item any exceptions thrown by \tcode{allocator_traits<Allocator>::allocate.}
\end{itemize}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(i1, i2, basic_string_view<charT, traits>(str));}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr basic_string& replace(const_iterator i1, const_iterator i2, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\expects
\range{begin()}{i1} and \range{i1}{i2} are valid ranges.

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> sv = t;
return replace(i1 - begin(), i2 - i1, sv.data(), sv.size());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(i1, i2, basic_string_view<charT, traits>(s, n));}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(i1, i2, basic_string_view<charT, traits>(s));}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(const_iterator i1, const_iterator i2, size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{begin()}{i1} and \range{i1}{i2} are valid ranges.

\pnum
\effects
Equivalent to: \tcode{return replace(i1 - begin(), i2 - i1, n, c);}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
template<class InputIterator>
  constexpr basic_string& replace(const_iterator i1, const_iterator i2,
                                  InputIterator j1, InputIterator j2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{InputIterator} is a type that qualifies as an input
iterator\iref{container.requirements.general}.

\pnum
\effects
Equivalent to: \tcode{return replace(i1, i2, basic_string(j1, j2, get_allocator()));}
\end{itemdescr}

\indexlibrarymember{replace}{basic_string}%
\begin{itemdecl}
constexpr basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return replace(i1, i2, il.begin(), il.size());}
\end{itemdescr}

\rSec4[string.copy]{\tcode{basic_string::copy}}

\indexlibrarymember{copy}{basic_string}%
\begin{itemdecl}
constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return basic_string_view<charT, traits>(*this).copy(s, n, pos);}
\begin{note}
This does not terminate \tcode{s} with a null object.
\end{note}
\end{itemdescr}

\rSec4[string.swap]{\tcode{basic_string::swap}}

\indexlibrarymember{swap}{basic_string}%
\begin{itemdecl}
constexpr void swap(basic_string& s)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{allocator_traits<Allocator>::propagate_on_container_swap::value} is \tcode{true}
or
\tcode{get_allocator() == s.get_allocator()}.

\pnum
\ensures
\tcode{*this}
contains the same sequence of characters that was in \tcode{s},
\tcode{s} contains the same sequence of characters that was in
\tcode{*this}.

\pnum
\throws
Nothing.

\pnum
\complexity
Constant time.
\end{itemdescr}

\rSec3[string.ops]{String operations}

\rSec4[string.accessors]{Accessors}

\indexlibrarymember{c_str}{basic_string}%
\indexlibrarymember{data}{basic_string}%
\begin{itemdecl}
constexpr const charT* c_str() const noexcept;
constexpr const charT* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer \tcode{p} such that \tcode{p + i == addressof(operator[](i))} for each
\tcode{i} in \crange{0}{size()}.

\pnum
\complexity
Constant time.

\pnum
\remarks
The program shall not modify any of the values stored in the character array; otherwise, the behavior is undefined.
\end{itemdescr}

\indexlibrarymember{data}{basic_string}%
\begin{itemdecl}
constexpr charT* data() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer \tcode{p} such that \tcode{p + i == addressof(operator[](i))} for each
\tcode{i} in \crange{0}{size()}.

\pnum
\complexity
Constant time.

\pnum
\remarks
The program shall not modify the value stored at \tcode{p + size()}
to any value other than \tcode{charT()}; otherwise, the behavior is undefined.
\end{itemdescr}

\indexlibrarymember{operator basic_string_view}{basic_string}%
\begin{itemdecl}
constexpr operator basic_string_view<charT, traits>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return basic_string_view<charT, traits>(data(), size());}
\end{itemdescr}

\indexlibrarymember{get_allocator}{basic_string}%
\begin{itemdecl}
constexpr allocator_type get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A copy of the
\tcode{Allocator}
object used to construct the string or, if that allocator has been replaced, a
copy of the most recent replacement.
\end{itemdescr}

\rSec4[string.find]{Searching}

\pnum
\indexlibrarymember{find}{basic_string}%
\indexlibrarymember{rfind}{basic_string}%
\indexlibrarymember{find_first_of}{basic_string}%
\indexlibrarymember{find_last_of}{basic_string}%
\indexlibrarymember{find_first_not_of}{basic_string}%
\indexlibrarymember{find_last_not_of}{basic_string}%
Let \placeholder{F} be one of
\tcode{find}, \tcode{rfind}, \tcode{find_first_of}, \tcode{find_last_of},
\tcode{find_first_not_of}, and \tcode{find_last_not_of}.

\begin{itemize}
\item
Each member function of the form
\begin{codeblock}
constexpr size_type @\placeholder{F}@(const basic_string& str, size_type pos) const noexcept;
\end{codeblock}
has effects equivalent to:
\tcode{return \placeholder{F}(basic_string_view<charT, traits>(str), pos);}

\item
Each member function of the form
\begin{codeblock}
constexpr size_type @\placeholder{F}@(const charT* s, size_type pos) const;
\end{codeblock}
has effects equivalent to:
\tcode{return \placeholder{F}(basic_string_view<charT, traits>(s), pos);}

\item
Each member function of the form
\begin{codeblock}
constexpr size_type @\placeholder{F}@(const charT* s, size_type pos, size_type n) const;
\end{codeblock}
has effects equivalent to:
\tcode{return \placeholder{F}(basic_string_view<charT, traits>(s, n), pos);}

\item
Each member function of the form
\begin{codeblock}
constexpr size_type @\placeholder{F}@(charT c, size_type pos) const noexcept;
\end{codeblock}
has effects equivalent to:
\begin{codeblock}
return @\placeholder{F}@(basic_string_view<charT, traits>(addressof(c), 1), pos);
\end{codeblock}
\end{itemize}

\indexlibrarymember{find}{basic_string}%
\indexlibrarymember{rfind}{basic_string}%
\indexlibrarymember{find_first_of}{basic_string}%
\indexlibrarymember{find_last_of}{basic_string}%
\indexlibrarymember{find_first_not_of}{basic_string}%
\indexlibrarymember{find_last_not_of}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr size_type find(const T& t, size_type pos = 0) const noexcept(@\seebelow@);
template<class T>
  constexpr size_type rfind(const T& t, size_type pos = npos) const noexcept(@\seebelow@);
template<class T>
  constexpr size_type find_first_of(const T& t, size_type pos = 0) const noexcept(@\seebelow@);
template<class T>
  constexpr size_type find_last_of(const T& t, size_type pos = npos) const noexcept(@\seebelow@);
template<class T>
  constexpr size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept(@\seebelow@);
template<class T>
  constexpr size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Let \placeholder{G} be the name of the function.
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> s = *this, sv = t;
return s.@\placeholder{G}@(sv, pos);
\end{codeblock}

\pnum
\remarks
The exception specification is equivalent to
\tcode{is_nothrow_convertible_v<const T\&, basic_string_view<charT, traits>>}.
\end{itemdescr}

\rSec4[string.substr]{\tcode{basic_string::substr}}

\indexlibrarymember{substr}{basic_string}%
\begin{itemdecl}
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the effective length \tcode{rlen} of the string to copy as the smaller of \tcode{n} and
\tcode{size() - pos}.

\pnum
\returns
\tcode{basic_string(data()+pos, rlen)}.

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > size()}.
\end{itemdescr}

\rSec4[string.compare]{\tcode{basic_string::compare}}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr int compare(const T& t) const noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to: \tcode{return basic_string_view<charT, traits>(*this).compare(t);}

\pnum
\remarks
The exception specification is equivalent to
\tcode{is_nothrow_convertible_v<const T\&, basic_string_view<charT, traits>>}.
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr int compare(size_type pos1, size_type n1, const T& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
return basic_string_view<charT, traits>(*this).substr(pos1, n1).compare(t);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
template<class T>
  constexpr int compare(size_type pos1, size_type n1, const T& t,
                        size_type pos2, size_type n2 = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item
\tcode{is_convertible_v<const T\&, basic_string_view<charT, traits>>} is
\tcode{true} and
\item
\tcode{is_convertible_v<const T\&, const charT*>} is
\tcode{false}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string_view<charT, traits> s = *this, sv = t;
return s.substr(pos1, n1).compare(sv.substr(pos2, n2));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(const basic_string& str) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return compare(basic_string_view<charT, traits>(str));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, const basic_string& str) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return compare(pos1, n1, basic_string_view<charT, traits>(str));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, const basic_string& str,
                      size_type pos2, size_type n2 = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return compare(pos1, n1, basic_string_view<charT, traits>(str), pos2, n2);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(const charT* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return compare(basic_string_view<charT, traits>(s));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(size_type pos, size_type n1, const charT* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return compare(pos, n1, basic_string_view<charT, traits>(s));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string}%
\begin{itemdecl}
constexpr int compare(size_type pos, size_type n1, const charT* s, size_type n2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return compare(pos, n1, basic_string_view<charT, traits>(s, n2));}
\end{itemdescr}

\rSec4[string.starts.with]{\tcode{basic_string::starts_with}}

\indexlibrarymember{starts_with}{basic_string}%
\begin{itemdecl}
constexpr bool starts_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool starts_with(charT x) const noexcept;
constexpr bool starts_with(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return basic_string_view<charT, traits>(data(), size()).starts_with(x);
\end{codeblock}
\end{itemdescr}

\rSec4[string.ends.with]{\tcode{basic_string::ends_with}}

\indexlibrarymember{ends_with}{basic_string}%
\begin{itemdecl}
constexpr bool ends_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool ends_with(charT x) const noexcept;
constexpr bool ends_with(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return basic_string_view<charT, traits>(data(), size()).ends_with(x);
\end{codeblock}
\end{itemdescr}

\rSec4[string.contains]{\tcode{basic_string::contains}}

\indexlibrarymember{contains}{basic_string}%
\begin{itemdecl}
constexpr bool contains(basic_string_view<charT, traits> x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return basic_string_view<charT, traits>(data(), size()).contains(x);
\end{codeblock}
\end{itemdescr}

\rSec2[string.nonmembers]{Non-member functions}

\indexlibraryglobal{basic_string}

\rSec3[string.op.plus]{\tcode{operator+}}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const basic_string<charT, traits, Allocator>& lhs,
              const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string<charT, traits, Allocator> r = lhs;
r.append(rhs);
return r;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(basic_string<charT, traits, Allocator>&& lhs,
              const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(basic_string<charT, traits, Allocator>&& lhs, const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
lhs.append(rhs);
return std::move(lhs);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(basic_string<charT, traits, Allocator>&& lhs,
              basic_string<charT, traits, Allocator>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
lhs.append(rhs);
return std::move(lhs);
\end{codeblock}
except that both \tcode{lhs} and \tcode{rhs}
are left in valid but unspecified states.
\begin{note}
If \tcode{lhs} and \tcode{rhs} have equal allocators,
the implementation can move from either.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const basic_string<charT, traits, Allocator>& lhs,
              basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const charT* lhs, basic_string<charT, traits, Allocator>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
rhs.insert(0, lhs);
return std::move(rhs);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string<charT, traits, Allocator> r = rhs;
r.insert(0, lhs);
return r;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(charT lhs, const basic_string<charT, traits, Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string<charT, traits, Allocator> r = rhs;
r.insert(r.begin(), lhs);
return r;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(charT lhs, basic_string<charT, traits, Allocator>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
rhs.insert(rhs.begin(), lhs);
return std::move(rhs);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
basic_string<charT, traits, Allocator> r = lhs;
r.push_back(rhs);
return r;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr basic_string<charT, traits, Allocator>
    operator+(basic_string<charT, traits, Allocator>&& lhs, charT rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
lhs.push_back(rhs);
return std::move(lhs);
\end{codeblock}
\end{itemdescr}

\rSec3[string.cmp]{Non-member comparison operator functions}
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr bool
    operator==(const basic_string<charT, traits, Allocator>& lhs,
               const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
  constexpr bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                            const charT* rhs);

template<class charT, class traits, class Allocator>
  constexpr @\seebelow@ operator<=>(const basic_string<charT, traits, Allocator>& lhs,
            @\itcorr@                      const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
  constexpr @\seebelow@ operator<=>(const basic_string<charT, traits, Allocator>& lhs,
            @\itcorr@                      const charT* rhs);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Let \tcode{\placeholder{op}} be the operator.
Equivalent to:
\begin{codeblock}
return basic_string_view<charT, traits>(lhs) @\placeholder{op}@ basic_string_view<charT, traits>(rhs);
\end{codeblock}
\end{itemdescr}

\rSec3[string.special]{\tcode{swap}}

\indexlibrarymember{swap}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  constexpr void
    swap(basic_string<charT, traits, Allocator>& lhs,
         basic_string<charT, traits, Allocator>& rhs)
      noexcept(noexcept(lhs.swap(rhs)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{lhs.swap(rhs)}.
\end{itemdescr}

\rSec3[string.io]{Inserters and extractors}

\indexlibrarymember{operator>>}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves as a formatted input function\iref{istream.formatted.reqmts}.
After constructing a
\tcode{sentry}
object, if the sentry converts to \tcode{true}, calls
\tcode{str.erase()}
and then extracts characters from \tcode{is} and appends them
to \tcode{str} as if by calling
\tcode{str.append(1, c)}.
If
\tcode{is.width()}
is greater than zero, the maximum
number \tcode{n} of characters appended is
\tcode{is.width()};
otherwise \tcode{n} is
\tcode{str.max_size()}.
Characters are extracted and appended until any of the following
occurs:
\begin{itemize}
\item
\textit{n}
characters are stored;
\item
end-of-file occurs on the input sequence;
\item
\tcode{isspace(c, is.getloc())}
is \tcode{true} for the next available input character
\textit{c}.
\end{itemize}

\pnum
After the last character (if any) is extracted,
\tcode{is.width(0)}
is called and the
\tcode{sentry}
object is destroyed.

\pnum
If the function extracts no characters, it calls
\tcode{is.setstate(ios_base::failbit)},
which may throw
\tcode{ios_base::fail\-ure}\iref{iostate.flags}.

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrarymember{operator<<}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os,
               const basic_string<charT, traits, Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return os << basic_string_view<charT, traits>(str);}
\end{itemdescr}

\indexlibrarymember{getline}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT, traits>&
    getline(basic_istream<charT, traits>& is,
            basic_string<charT, traits, Allocator>& str,
            charT delim);
template<class charT, class traits, class Allocator>
  basic_istream<charT, traits>&
    getline(basic_istream<charT, traits>&& is,
            basic_string<charT, traits, Allocator>& str,
            charT delim);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves as an unformatted input function\iref{istream.unformatted},
except that it does not affect the value returned by subsequent calls to
\tcode{basic_istream<>::gcount()}.
After constructing a
\tcode{sentry}
object, if the sentry converts to \tcode{true}, calls
\tcode{str.erase()}
and then extracts characters from \tcode{is} and appends them
to \tcode{str} as if by calling
\tcode{str.append(1, c)}
until any of the following occurs:
\begin{itemize}
\item
end-of-file occurs on the input sequence
(in which case, the
\tcode{getline}
function calls
\tcode{is.setstate(\brk{}ios_base::eofbit)}).
\item
\tcode{traits::eq(c, delim)}
for the next available input character
\textit{c}
(in which case,
\textit{c}
is extracted but not appended)\iref{iostate.flags}
\item
\tcode{str.max_size()}
characters are stored
(in which case,
the function calls
\tcode{is.setstate(ios_base::fail\-bit))}\iref{iostate.flags}
\end{itemize}

\pnum
The conditions are tested in the order shown.
In any case,
after the last character is extracted, the
\tcode{sentry}
object is destroyed.

\pnum
If the function extracts no characters, it calls
\tcode{is.setstate(ios_base::fail\-bit)}
which may throw
\tcode{ios_base::fail\-ure}\iref{iostate.flags}.

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrarymember{getline}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT, traits>&
    getline(basic_istream<charT, traits>& is,
            basic_string<charT, traits, Allocator>& str);
template<class charT, class traits, class Allocator>
  basic_istream<charT, traits>&
    getline(basic_istream<charT, traits>&& is,
            basic_string<charT, traits, Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{getline(is, str, is.widen('\textbackslash n'))}.
\end{itemdescr}

\rSec3[string.erasure]{Erasure}

\indexlibrarymember{erase}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator, class U>
  constexpr typename basic_string<charT, traits, Allocator>::size_type
    erase(basic_string<charT, traits, Allocator>& c, const U& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto it = remove(c.begin(), c.end(), value);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{erase_if}{basic_string}%
\begin{itemdecl}
template<class charT, class traits, class Allocator, class Predicate>
  constexpr typename basic_string<charT, traits, Allocator>::size_type
    erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto it = remove_if(c.begin(), c.end(), pred);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
\end{codeblock}
\end{itemdescr}

\rSec2[string.conversions]{Numeric conversions}

\indexlibraryglobal{stoi}%
\indexlibraryglobal{stol}%
\indexlibraryglobal{stoul}%
\indexlibraryglobal{stoll}%
\indexlibraryglobal{stoull}%
\begin{itemdecl}
int stoi(const string& str, size_t* idx = nullptr, int base = 10);
long stol(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const string& str, size_t* idx = nullptr, int base = 10);
long long stoll(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first two functions call \tcode{strtol(str.c_str(), ptr, base)},
and the last three functions call \tcode{strtoul(str.c_str(), ptr, base)},
\tcode{strtoll(str.c_str(), ptr, base)}, and \tcode{strtoull(\brk{}str.c_str(), ptr,
base)}, respectively. Each function returns the converted result, if any. The
argument \tcode{ptr} designates a pointer to an object internal to the function
that is used to determine what to store at \tcode{*idx}. If the function does
not throw an exception and \tcode{idx != nullptr}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns
The converted result.

\pnum
\throws
\tcode{invalid_argument} if \tcode{strtol}, \tcode{strtoul},
\tcode{strtoll}, or \tcode{strtoull} reports that no conversion can be
performed. Throws \tcode{out_of_range} if \tcode{strtol}, \tcode{strtoul},
\tcode{strtoll} or \tcode{strtoull} sets \tcode{errno} to \tcode{ERANGE},
or if the converted value is outside the range of representable values
for the return type.
\end{itemdescr}

\indexlibraryglobal{stof}%
\indexlibraryglobal{stod}%
\indexlibraryglobal{stold}%
\begin{itemdecl}
float stof(const string& str, size_t* idx = nullptr);
double stod(const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions call
\tcode{strtof(str.c_str(), ptr)}, \tcode{strtod(str.c_str(), ptr)}, and
\tcode{strtold(\brk{}str.c_str(), ptr)}, respectively. Each function returns
the converted result, if any. The argument \tcode{ptr} designates a pointer to
an object internal to the function that is used to determine what to store at
\tcode{*idx}. If the function does not throw an exception and \tcode{idx != nullptr},
the function stores in \tcode{*idx} the index of the first unconverted element
of \tcode{str}.

\pnum
\returns
The converted result.

\pnum
\throws
\tcode{invalid_argument} if \tcode{strtof}, \tcode{strtod}, or
\tcode{strtold} reports that no conversion can be performed. Throws
\tcode{out_of_range} if \tcode{strtof}, \tcode{strtod}, or
\tcode{strtold} sets \tcode{errno} to \tcode{ERANGE}
or if the converted value is outside the range of representable
values for the return type.
\end{itemdescr}

\indexlibraryglobal{to_string}%
\begin{itemdecl}
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
Each function returns a \tcode{string} object holding the character
representation of the value of its argument that would be generated by calling
\tcode{sprintf(buf, fmt, val)} with a format specifier of
\tcode{"\%d"},
\tcode{"\%u"},
\tcode{"\%ld"},
\tcode{"\%lu"},
\tcode{"\%lld"},  \tcode{"\%llu"},
\tcode{"\%f"},
\tcode{"\%f"},
or \tcode{"\%Lf"}, respectively, where \tcode{buf} designates an internal
character buffer of sufficient size.
\end{itemdescr}

\indexlibraryglobal{stoi}%
\indexlibraryglobal{stol}%
\indexlibraryglobal{stoul}%
\indexlibraryglobal{stoll}%
\indexlibraryglobal{stoull}%
\begin{itemdecl}
int stoi(const wstring& str, size_t* idx = nullptr, int base = 10);
long stol(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const wstring& str, size_t* idx = nullptr, int base = 10);
long long stoll(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first two functions call \tcode{wcstol(str.c_str(), ptr, base)},
and the last three functions call \tcode{wcstoul(str.c_str(), ptr, base)},
\tcode{wcstoll(str.c_str(), ptr, base)}, and \tcode{wcstoull(\brk{}str.c_str(), ptr,
base)}, respectively. Each function returns the converted result, if any. The
argument \tcode{ptr} designates a pointer to an object internal to the function
that is used to determine what to store at \tcode{*idx}. If the function does
not throw an exception and \tcode{idx != nullptr}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns
The converted result.

\pnum
\throws
\tcode{invalid_argument} if \tcode{wcstol}, \tcode{wcstoul}, \tcode{wcstoll}, or
\tcode{wcstoull} reports that no conversion can be performed. Throws
\tcode{out_of_range} if the converted value is outside the range of representable values
for the return type.
\end{itemdescr}

\indexlibraryglobal{stof}%
\indexlibraryglobal{stod}%
\indexlibraryglobal{stold}%
\begin{itemdecl}
float stof(const wstring& str, size_t* idx = nullptr);
double stod(const wstring& str, size_t* idx = nullptr);
long double stold(const wstring& str, size_t* idx = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions call \tcode{wcstof(str.c_str(), ptr)},
\tcode{wcstod(str.c_str(), ptr)}, and \tcode{wcstold(\brk{}str.c_str(), ptr)},
respectively. Each function returns the converted
result, if any. The argument \tcode{ptr} designates a pointer to an object internal to
the function that is used to determine what to store at \tcode{*idx}. If the function
does not throw an exception and \tcode{idx != nullptr}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns
The converted result.

\pnum
\throws
\tcode{invalid_argument} if \tcode{wcstof}, \tcode{wcstod}, or \tcode{wcstold} reports that no
conversion can be performed. Throws \tcode{out_of_range} if \tcode{wcstof}, \tcode{wcstod}, or
\tcode{wcstold} sets \tcode{errno} to \tcode{ERANGE}.
\end{itemdescr}

\indexlibraryglobal{to_wstring}%
\begin{itemdecl}
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
Each function returns a \tcode{wstring} object holding the character
representation of the value of its argument that would be generated by calling
\tcode{swprintf(buf, buffsz, fmt, val)} with a format specifier of
\tcode{L"\%d"},
\tcode{L"\%u"},
\tcode{L"\%ld"},
\tcode{L"\%lu"},
\tcode{L"\%lld"},
\tcode{L"\%llu"},
\tcode{L"\%f"},
\tcode{L"\%f"},
or \tcode{L"\%Lf"}, respectively, where \tcode{buf} designates an
internal character buffer of sufficient size \tcode{buffsz}.
\end{itemdescr}

\rSec2[basic.string.hash]{Hash support}

\indexlibrarymember{hash}{string}%
\indexlibrarymember{hash}{u16string}%
\indexlibrarymember{hash}{u32string}%
\indexlibrarymember{hash}{wstring}%
\indexlibrarymember{hash}{pmr::string}%
\indexlibrarymember{hash}{pmr::u16string}%
\indexlibrarymember{hash}{pmr::u32string}%
\indexlibrarymember{hash}{pmr::wstring}%
\begin{itemdecl}
template<> struct hash<string>;
template<> struct hash<u8string>;
template<> struct hash<u16string>;
template<> struct hash<u32string>;
template<> struct hash<wstring>;
template<> struct hash<pmr::string>;
template<> struct hash<pmr::u8string>;
template<> struct hash<pmr::u16string>;
template<> struct hash<pmr::u32string>;
template<> struct hash<pmr::wstring>;
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{S} is one of these string types,
\tcode{SV} is the corresponding string view type, and
\tcode{s} is an object of type \tcode{S},
then \tcode{hash<S>()(s) == hash<SV>()(SV(s))}.
\end{itemdescr}

\rSec2[basic.string.literals]{Suffix for \tcode{basic_string} literals}

\indexlibrarymember{operator""""s}{string}%
\begin{itemdecl}
constexpr string operator""s(const char* str, size_t len);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{string\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""s}{u8string}%
\begin{itemdecl}
constexpr u8string operator""s(const char8_t* str, size_t len);
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u8string\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""s}{u16string}%
\begin{itemdecl}
constexpr u16string operator""s(const char16_t* str, size_t len);
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u16string\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""s}{u32string}%
\begin{itemdecl}
constexpr u32string operator""s(const char32_t* str, size_t len);
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u32string\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""s}{wstring}%
\begin{itemdecl}
constexpr wstring operator""s(const wchar_t* str, size_t len);
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{wstring\{str, len\}}.
\end{itemdescr}

\pnum
\begin{note}
The same suffix \tcode{s} is used for \tcode{chrono::duration} literals denoting seconds but there is no conflict, since duration suffixes apply to numbers and string literal suffixes apply to character array literals.
\end{note}

\rSec1[string.view]{String view classes}

\rSec2[string.view.general]{General}

\pnum
The class template \tcode{basic_string_view} describes an object that can refer to a constant contiguous sequence of char-like\iref{strings.general} objects with the first element of the sequence at position zero.
In the rest of \ref{string.view}, the type of the char-like objects held in a \tcode{basic_string_view} object is designated by \tcode{charT}.

\pnum
\begin{note}
The library provides implicit conversions from \tcode{const charT*} and \tcode{std::basic_string<charT, ...>} to \tcode{std::basic_string_view<charT, ...>} so that user code can accept just \tcode{std::basic_string_view<charT>} as a non-templated parameter wherever a sequence of characters is expected.
User-defined types can define their own implicit conversions to \tcode{std::basic_string_view} in order to interoperate with these functions.
\end{note}

\rSec2[string.view.synop]{Header \tcode{<string_view>} synopsis}

\indexheader{string_view}%
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}

namespace std {
  // \ref{string.view.template}, class template \tcode{basic_string_view}
  template<class charT, class traits = char_traits<charT>>
  class basic_string_view;

  template<class charT, class traits>
    inline constexpr bool ranges::enable_view<basic_string_view<charT, traits>> = true;
  template<class charT, class traits>
    inline constexpr bool ranges::enable_borrowed_range<basic_string_view<charT, traits>> = true;

  // \ref{string.view.comparison}, non-member comparison functions
  template<class charT, class traits>
    constexpr bool operator==(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
  template<class charT, class traits>
    constexpr @\seebelow@ operator<=>(basic_string_view<charT, traits> x,
              @\itcorr@                      basic_string_view<charT, traits> y) noexcept;

  // see \ref{string.view.comparison}, sufficient additional overloads of comparison functions

  // \ref{string.view.io}, inserters and extractors
  template<class charT, class traits>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 basic_string_view<charT, traits> str);

  // \tcode{basic_string_view} typedef names
  using string_view    = basic_string_view<char>;
  using u8string_view  = basic_string_view<char8_t>;
  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;
  using wstring_view   = basic_string_view<wchar_t>;

  // \ref{string.view.hash}, hash support
  template<class T> struct hash;
  template<> struct hash<string_view>;
  template<> struct hash<u8string_view>;
  template<> struct hash<u16string_view>;
  template<> struct hash<u32string_view>;
  template<> struct hash<wstring_view>;

  inline namespace literals {
  inline namespace string_view_literals {
    // \ref{string.view.literals}, suffix for \tcode{basic_string_view} literals
    constexpr string_view    operator""sv(const char* str, size_t len) noexcept;
    constexpr u8string_view  operator""sv(const char8_t* str, size_t len) noexcept;
    constexpr u16string_view operator""sv(const char16_t* str, size_t len) noexcept;
    constexpr u32string_view operator""sv(const char32_t* str, size_t len) noexcept;
    constexpr wstring_view   operator""sv(const wchar_t* str, size_t len) noexcept;
  }
  }
}
\end{codeblock}

\pnum
The function templates defined in \ref{utility.swap} and \ref{iterator.range}
are available when \tcode{<string_view>} is included.

\rSec2[string.view.template]{Class template \tcode{basic_string_view}}

\rSec3[string.view.template.general]{General}

\indexlibraryglobal{basic_string_view}%
\indexlibrarymember{traits_type}{basic_string_view}%
\indexlibrarymember{value_type}{basic_string_view}%
\indexlibrarymember{pointer}{basic_string_view}%
\indexlibrarymember{const_pointer}{basic_string_view}%
\indexlibrarymember{reference}{basic_string_view}%
\indexlibrarymember{const_reference}{basic_string_view}%
\indexlibrarymember{const_iterator}{basic_string_view}%
\indexlibrarymember{iterator}{basic_string_view}%
\indexlibrarymember{const_reverse_iterator}{basic_string_view}%
\indexlibrarymember{reverse_iterator}{basic_string_view}%
\indexlibrarymember{size_type}{basic_string_view}%
\indexlibrarymember{difference_type}{basic_string_view}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>>
  class basic_string_view {
  public:
    // types
    using traits_type            = traits;
    using value_type             = charT;
    using pointer                = value_type*;
    using const_pointer          = const value_type*;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using const_iterator         = @\impdefx{type of \tcode{basic_string_view::const_iterator}}@; // see \ref{string.view.iterators}
    using iterator               = const_iterator;@
\begin{footnote}
Because \tcode{basic_string_view} refers to a constant sequence, \tcode{iterator} and \tcode{const_iterator} are the same type.
\end{footnote}@
    using const_reverse_iterator = reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    static constexpr size_type npos = size_type(-1);

    // \ref{string.view.cons}, construction and assignment
    constexpr basic_string_view() noexcept;
    constexpr basic_string_view(const basic_string_view&) noexcept = default;
    constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
    constexpr basic_string_view(const charT* str);
    basic_string_view(nullptr_t) = delete;
    constexpr basic_string_view(const charT* str, size_type len);
    template<class It, class End>
      constexpr basic_string_view(It begin, End end);
    template<class R>
      constexpr basic_string_view(R&& r);

    // \ref{string.view.iterators}, iterator support
    constexpr const_iterator begin() const noexcept;
    constexpr const_iterator end() const noexcept;
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr const_reverse_iterator rend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;

    // \ref{string.view.capacity}, capacity
    constexpr size_type size() const noexcept;
    constexpr size_type length() const noexcept;
    constexpr size_type max_size() const noexcept;
    [[nodiscard]] constexpr bool empty() const noexcept;

    // \ref{string.view.access}, element access
    constexpr const_reference operator[](size_type pos) const;
    constexpr const_reference at(size_type pos) const;
    constexpr const_reference front() const;
    constexpr const_reference back() const;
    constexpr const_pointer data() const noexcept;

    // \ref{string.view.modifiers}, modifiers
    constexpr void remove_prefix(size_type n);
    constexpr void remove_suffix(size_type n);
    constexpr void swap(basic_string_view& s) noexcept;

    // \ref{string.view.ops}, string operations
    constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;

    constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;

    constexpr int compare(basic_string_view s) const noexcept;
    constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
    constexpr int compare(size_type pos1, size_type n1, basic_string_view s,
                          size_type pos2, size_type n2) const;
    constexpr int compare(const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;

    constexpr bool starts_with(basic_string_view x) const noexcept;
    constexpr bool starts_with(charT x) const noexcept;
    constexpr bool starts_with(const charT* x) const;
    constexpr bool ends_with(basic_string_view x) const noexcept;
    constexpr bool ends_with(charT x) const noexcept;
    constexpr bool ends_with(const charT* x) const;

    constexpr bool contains(basic_string_view x) const noexcept;
    constexpr bool contains(charT x) const noexcept;
    constexpr bool contains(const charT* x) const;

    // \ref{string.view.find}, searching
    constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find(const charT* s, size_type pos = 0) const;
    constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
    constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
    constexpr size_type rfind(const charT* s, size_type pos = npos) const;

    constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
    constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(const charT* s, size_type pos,
                                          size_type n) const;
    constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_not_of(basic_string_view s,
                                         size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(const charT* s, size_type pos,
                                         size_type n) const;
    constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

  private:
    const_pointer data_;        // \expos
    size_type size_;            // \expos
  };

  // \ref{string.view.deduct}, deduction guides
  template<class It, class End>
    basic_string_view(It, End) -> basic_string_view<iter_value_t<It>>;
  template<class R>
    basic_string_view(R&&) -> basic_string_view<ranges::range_value_t<R>>;
}
\end{codeblock}

\pnum
In every specialization \tcode{basic_string_view<charT, traits>}, the type \tcode{traits} shall meet the character traits requirements\iref{char.traits}.
\begin{note}
The program is ill-formed if \tcode{traits::char_type} is not the same type as \tcode{charT}.
\end{note}

\pnum
For a \tcode{basic_string_view str},
any operation that invalidates a pointer
in the range \range{str.data()}{\brk{}str.data() + str.size()}
invalidates pointers, iterators, and references
returned from \tcode{str}'s member functions.

\pnum
The complexity of \tcode{basic_string_view} member functions is \bigoh{1}
unless otherwise specified.

\rSec3[string.view.cons]{Construction and assignment}

\indexlibraryctor{basic_string_view}%
\begin{itemdecl}
constexpr basic_string_view() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{size_ == 0} and \tcode{data_ == nullptr}.
\end{itemdescr}

\indexlibraryctor{basic_string_view}%
\begin{itemdecl}
constexpr basic_string_view(const charT* str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{str}{str + traits::length(str)} is a valid range.

\pnum
\effects
Constructs a \tcode{basic_string_view}, initializing \tcode{data_} with \tcode{str}
and initializing \tcode{size_} with \tcode{traits::length(str)}.

\pnum
\complexity
\bigoh{\tcode{traits::length(str)}}.
\end{itemdescr}

\indexlibraryctor{basic_string_view}%
\begin{itemdecl}
constexpr basic_string_view(const charT* str, size_type len);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{str}{str + len} is a valid range.

\pnum
\effects
Constructs a \tcode{basic_string_view}, initializing \tcode{data_} with \tcode{str}
and initializing \tcode{size_} with \tcode{len}.
\end{itemdescr}

\indexlibraryctor{basic_string_view}%
\begin{itemdecl}
template<class It, class End>
  constexpr basic_string_view(It begin, End end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{It} satisfies \libconcept{contiguous_iterator}.
\item \tcode{End} satisfies \tcode{\libconcept{sized_sentinel_for}<It>}.
\item \tcode{is_same_v<iter_value_t<It>, charT>} is \tcode{true}.
\item \tcode{is_convertible_v<End, size_type>} is \tcode{false}.
\end{itemize}

\pnum
\expects
\begin{itemize}
\item \range{begin}{end} is a valid range.
\item \tcode{It} models \libconcept{contiguous_iterator}.
\item \tcode{End} models \tcode{\libconcept{sized_sentinel_for}<It>}.
\end{itemize}

\pnum
\effects
Initializes \tcode{data_} with \tcode{to_address(begin)} and
initializes \tcode{size_} with \tcode{end - begin}.
\end{itemdescr}

\indexlibraryctor{basic_string_view}%
\begin{itemdecl}
template<class R>
  constexpr basic_string_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{d} be an lvalue of type \tcode{remove_cvref_t<R>}.

\pnum
\constraints
\begin{itemize}
\item
\tcode{R} models
\tcode{ranges::\libconcept{contiguous_range}} and \tcode{ranges::\libconcept{sized_range}},
\item
\tcode{is_same_v<ranges::range_value_t<R>, charT>} is \tcode{true},
\item
\tcode{is_convertible_v<R, const charT*>} is \tcode{false},
\item
\tcode{d.operator ::std::basic_string_view<charT, traits>()}
is not a valid expression, and
\item
if the \grammarterm{qualified-id} \tcode{remove_reference_t<R>::traits_type}
is valid and denotes a type,
\tcode{is_same_v<remove_reference_t<R>::traits_type, traits>} is \tcode{true}.
\end{itemize}

\pnum
\effects
Initializes \tcode{data_} with \tcode{ranges::data(r)} and
\tcode{size_} with \tcode{ranges::size(r)}.

\pnum
\throws
Any exception thrown by \tcode{ranges::data(r)} and \tcode{ranges::size(r)}.
\end{itemdescr}

\rSec3[string.view.iterators]{Iterator support}

\indexlibrarymember{const_iterator}{basic_string_view}%
\begin{itemdecl}
using const_iterator = @\impdefx{type of \tcode{basic_string_view::const_iterator}}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
A type that meets the requirements
of a constant
\oldconcept{RandomAccessIterator}\iref{random.access.iterators},
models \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous}, and
meets the constexpr iterator requirements\iref{iterator.requirements.general},
whose \tcode{value_type} is the template parameter \tcode{charT}.

\pnum
All requirements on container iterators\iref{container.requirements} apply to \tcode{basic_string_view::const_iterator} as well.
\end{itemdescr}

\indexlibrarymember{begin}{basic_string_view}%
\indexlibrarymember{cbegin}{basic_string_view}%
\begin{itemdecl}
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator such that
\begin{itemize}
\item if \tcode{!empty()}, \tcode{addressof(*begin()) == data_},
\item otherwise, an unspecified value such that \range{begin()}{end()} is a valid range.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{end}{basic_string_view}%
\indexlibrarymember{cend}{basic_string_view}%
\begin{itemdecl}
constexpr const_iterator end() const noexcept;
constexpr const_iterator cend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{begin() + size()}.
\end{itemdescr}

\indexlibrarymember{rbegin}{basic_string_view}%
\indexlibrarymember{crbegin}{basic_string_view}%
\begin{itemdecl}
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_reverse_iterator(end())}.
\end{itemdescr}

\indexlibrarymember{rend}{basic_string_view}%
\indexlibrarymember{crend}{basic_string_view}%
\begin{itemdecl}
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_reverse_iterator(begin())}.
\end{itemdescr}

\rSec3[string.view.capacity]{Capacity}

\indexlibrarymember{size}{basic_string_view}%
\indexlibrarymember{length}{basic_string_view}%
\begin{itemdecl}
constexpr size_type size() const noexcept;
constexpr size_type length() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{size_}.
\end{itemdescr}


\indexlibrarymember{max_size}{basic_string_view}%
\begin{itemdecl}
constexpr size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The largest possible number of char-like objects that can be referred to by a \tcode{basic_string_view}.
\end{itemdescr}

\indexlibrarymember{empty}{basic_string_view}%
\begin{itemdecl}
[[nodiscard]] constexpr bool empty() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{size_ == 0}.
\end{itemdescr}

\rSec3[string.view.access]{Element access}

\indexlibrarymember{operator[]}{basic_string_view}%
\begin{itemdecl}
constexpr const_reference operator[](size_type pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{pos < size()}.

\pnum
\returns
\tcode{data_[pos]}.

\pnum
\throws
Nothing.

\pnum
\begin{note}
Unlike \tcode{basic_string::operator[]},
\tcode{basic_string_view::operator[](size())} has undefined behavior instead of returning \tcode{charT()}.
\end{note}
\end{itemdescr}

\indexlibrarymember{at}{basic_string_view}%
\begin{itemdecl}
constexpr const_reference at(size_type pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{data_[pos]}.

\pnum
\throws
\tcode{out_of_range} if \tcode{pos >= size()}.
\end{itemdescr}

\indexlibrarymember{front}{basic_string_view}%
\begin{itemdecl}
constexpr const_reference front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\returns
\tcode{data_[0]}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{back}{basic_string_view}%
\begin{itemdecl}
constexpr const_reference back() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\returns
\tcode{data_[size() - 1]}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{data}{basic_string_view}%
\begin{itemdecl}
constexpr const_pointer data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{data_}.

\pnum
\begin{note}
Unlike \tcode{basic_string::data()} and \grammarterm{string-literal}s,
\tcode{data()} can return a pointer to a buffer that is not null-terminated.
Therefore it is typically a mistake to pass \tcode{data()} to a function that takes just a \tcode{const charT*} and expects a null-terminated string.
\end{note}
\end{itemdescr}

\rSec3[string.view.modifiers]{Modifiers}

\indexlibrarymember{remove_prefix}{basic_string_view}%
\begin{itemdecl}
constexpr void remove_prefix(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n <= size()}.

\pnum
\effects
Equivalent to: \tcode{data_ += n; size_ -= n;}
\end{itemdescr}

\indexlibrarymember{remove_suffix}{basic_string_view}%
\begin{itemdecl}
constexpr void remove_suffix(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n <= size()}.

\pnum
\effects
Equivalent to: \tcode{size_ -= n;}
\end{itemdescr}

\indexlibrarymember{swap}{basic_string_view}%
\begin{itemdecl}
constexpr void swap(basic_string_view& s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Exchanges the values of \tcode{*this} and \tcode{s}.
\end{itemdescr}

\rSec3[string.view.ops]{String operations}

\indexlibrarymember{copy}{basic_string_view}%
\begin{itemdecl}
constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{rlen} be the smaller of \tcode{n} and \tcode{size() - pos}.

\pnum
\expects
\range{s}{s + rlen} is a valid range.

\pnum
\effects
Equivalent to \tcode{traits::copy(s, data() + pos, rlen)}.

\pnum
\returns
\tcode{rlen}.

\pnum
\throws
\tcode{out_of_range} if \tcode{pos > size()}.

\pnum
\complexity
\bigoh{\tcode{rlen}}.
\end{itemdescr}

\indexlibrarymember{substr}{basic_string_view}%
\begin{itemdecl}
constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{rlen} be the smaller of \tcode{n} and \tcode{size() - pos}.

\pnum
\effects
Determines \tcode{rlen}, the effective length of the string to reference.

\pnum
\returns
\tcode{basic_string_view(data() + pos, rlen)}.

\pnum
\throws
\tcode{out_of_range} if \tcode{pos > size()}.
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(basic_string_view str) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{rlen} be the smaller of \tcode{size()} and \tcode{str.size()}.

\pnum
\effects
Determines \tcode{rlen}, the effective length of the strings to compare.
The function then compares the two strings by calling \tcode{traits::compare(data(), str.data(), rlen)}.

\pnum
\returns
The nonzero result if the result of the comparison is nonzero.
Otherwise, returns a value as indicated in \tref{string.view.compare}.
\begin{libtab2}{\tcode{compare()} results}{string.view.compare}{cc}{Condition}{Return Value}
\tcode{size() < str.size()}  & \tcode{< 0}\\
\tcode{size() == str.size()} & \tcode{ \ 0}\\
\tcode{size() >  str.size()} & \tcode{> 0}\\
\end{libtab2}

\pnum
\complexity
\bigoh{\tcode{rlen}}.
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, basic_string_view str) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return substr(pos1, n1).compare(str);}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, basic_string_view str,
                      size_type pos2, size_type n2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return substr(pos1, n1).compare(str.substr(pos2, n2));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(const charT* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return compare(basic_string_view(s));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return substr(pos1, n1).compare(basic_string_view(s));}
\end{itemdescr}

\indexlibrarymember{compare}{basic_string_view}%
\begin{itemdecl}
constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return substr(pos1, n1).compare(basic_string_view(s, n2));}
\end{itemdescr}

\indexlibrarymember{starts_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool starts_with(basic_string_view x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return substr(0, x.size()) == x;}
\end{itemdescr}

\indexlibrarymember{starts_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool starts_with(charT x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !empty() \&\& traits::eq(front(), x);}
\end{itemdescr}

\indexlibrarymember{starts_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool starts_with(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return starts_with(basic_string_view(x));}
\end{itemdescr}

\indexlibrarymember{ends_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool ends_with(basic_string_view x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return size() >= x.size() && compare(size() - x.size(), npos, x) == 0;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{ends_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool ends_with(charT x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !empty() \&\& traits::eq(back(), x);}
\end{itemdescr}

\indexlibrarymember{ends_with}{basic_string_view}%
\begin{itemdecl}
constexpr bool ends_with(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return ends_with(basic_string_view(x));}
\end{itemdescr}

\indexlibrarymember{contains}{basic_string_view}%
\begin{itemdecl}
constexpr bool contains(basic_string_view x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return find(x) != npos;}
\end{itemdescr}

\rSec3[string.view.find]{Searching}

\pnum
Member functions in this subclause have complexity \bigoh{\tcode{size() * str.size()}} at worst,
although implementations should do better.

\pnum
Let \placeholder{F} be one of
\tcode{find},
\tcode{rfind},
\tcode{find_first_of},
\tcode{find_last_of},
\tcode{find_first_not_of},
and
\tcode{find_last_not_of}.
\begin{itemize}
\item
Each member function of the form
\begin{codeblock}
constexpr @\placeholder{return-type}@ @\placeholder{F}@(const charT* s, size_type pos) const;
\end{codeblock}
has effects equivalent to: \tcode{return \placeholder{F}(basic_string_view(s), pos);}

\item
Each member function of the form
\begin{codeblock}
constexpr @\placeholder{return-type}@ @\placeholder{F}@(const charT* s, size_type pos, size_type n) const;
\end{codeblock}
has effects equivalent to: \tcode{return \placeholder{F}(basic_string_view(s, n), pos);}

\item
Each member function of the form
\begin{codeblock}
constexpr @\placeholder{return-type}@ @\placeholder{F}@(charT c, size_type pos) const noexcept;
\end{codeblock}
has effects equivalent to: \tcode{return \placeholder{F}(basic_string_view(addressof(c), 1), pos);}
\end{itemize}

\indexlibrarymember{find}{basic_string_view}%
\begin{itemdecl}
constexpr size_type find(basic_string_view str, size_type pos = 0) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the lowest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{pos <= xpos}
\item
\tcode{xpos + str.size() <= size()}
\item
\tcode{traits::eq(at(xpos + I), str.at(I))} for all elements \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns \tcode{npos}.
\end{itemdescr}

\indexlibrarymember{rfind}{basic_string_view}%
\begin{itemdecl}
constexpr size_type rfind(basic_string_view str, size_type pos = npos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the highest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{xpos <= pos}
\item
\tcode{xpos + str.size() <= size()}
\item
\tcode{traits::eq(at(xpos + I), str.at(I))} for all elements \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns \tcode{npos}.
\end{itemdescr}

\indexlibrarymember{find_first_of}{basic_string_view}%
\begin{itemdecl}
constexpr size_type find_first_of(basic_string_view str, size_type pos = 0) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the lowest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{pos <= xpos}
\item
\tcode{xpos < size()}
\item
\tcode{traits::eq(at(xpos), str.at(I))} for some element \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns \tcode{npos}.
\end{itemdescr}

\indexlibrarymember{find_last_of}{basic_string_view}%
\begin{itemdecl}
constexpr size_type find_last_of(basic_string_view str, size_type pos = npos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the highest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{xpos <= pos}
\item
\tcode{xpos < size()}
\item
\tcode{traits::eq(at(xpos), str.at(I))} for some element \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns \tcode{npos}.
\end{itemdescr}

\indexlibrarymember{find_first_not_of}{basic_string_view}%
\begin{itemdecl}
constexpr size_type find_first_not_of(basic_string_view str, size_type pos = 0) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the lowest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{pos <= xpos}
\item
\tcode{xpos < size()}
\item
\tcode{traits::eq(at(xpos), str.at(I))} for no element \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}. Otherwise, returns \tcode{npos}.
\end{itemdescr}

\indexlibrarymember{find_last_not_of}{basic_string_view}%
\begin{itemdecl}
constexpr size_type find_last_not_of(basic_string_view str, size_type pos = npos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{xpos} be the highest position, if possible, such that the following conditions hold:
\begin{itemize}
\item
\tcode{xpos <= pos}
\item
\tcode{xpos < size()}
\item
\tcode{traits::eq(at(xpos), str.at(I))} for no element \tcode{I} of the string referenced by \tcode{str}.
\end{itemize}

\pnum
\effects
Determines \tcode{xpos}.

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns \tcode{npos}.
\end{itemdescr}

\rSec2[string.view.deduct]{Deduction guides}

\begin{itemdecl}
template<class It, class End>
  basic_string_view(It, End) -> basic_string_view<iter_value_t<It>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{It} satisfies \libconcept{contiguous_iterator}.
\item \tcode{End} satisfies \tcode{\libconcept{sized_sentinel_for}<It>}.
\end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class R>
  basic_string_view(R&&) -> basic_string_view<ranges::range_value_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{R} satisfies \tcode{ranges::\libconcept{contiguous_range}}.
\end{itemdescr}

\rSec2[string.view.comparison]{Non-member comparison functions}

\pnum
Let \tcode{S} be \tcode{basic_string_view<charT, traits>}, and \tcode{sv} be an instance of \tcode{S}.
Implementations shall provide sufficient additional overloads marked \keyword{constexpr} and \keyword{noexcept}
so that an object \tcode{t} with an implicit conversion to \tcode{S} can be compared according to \tref{string.view.comparison.overloads}.
\begin{libtab2}{Additional \tcode{basic_string_view} comparison overloads}{string.view.comparison.overloads}{cc}{Expression}{Equivalent to}
\tcode{t == sv} & \tcode{S(t) == sv} \\
\tcode{sv == t} & \tcode{sv == S(t)} \\
\tcode{t != sv} & \tcode{S(t) != sv} \\
\tcode{sv != t} & \tcode{sv != S(t)} \\
\tcode{t < sv}  & \tcode{S(t) < sv}  \\
\tcode{sv < t}  & \tcode{sv < S(t)}  \\
\tcode{t > sv}  & \tcode{S(t) > sv}  \\
\tcode{sv > t}  & \tcode{sv > S(t)}  \\
\tcode{t <= sv} & \tcode{S(t) <= sv} \\
\tcode{sv <= t} & \tcode{sv <= S(t)} \\
\tcode{t >= sv} & \tcode{S(t) >= sv} \\
\tcode{sv >= t} & \tcode{sv >= S(t)} \\
\tcode{t <=> sv} & \tcode{S(t) <=> sv} \\
\tcode{sv <=> t} & \tcode{sv <=> S(t)} \\
\end{libtab2}
\begin{example}
A sample conforming implementation for \tcode{operator==} would be:
\begin{codeblock}
template<class charT, class traits>
  constexpr bool operator==(basic_string_view<charT, traits> lhs,
                            basic_string_view<charT, traits> rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }
template<class charT, class traits>
  constexpr bool operator==(basic_string_view<charT, traits> lhs,
                            type_identity_t<basic_string_view<charT, traits>> rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }
\end{codeblock}
\end{example}

\indexlibrarymember{operator==}{basic_string_view}%
\begin{itemdecl}
template<class charT, class traits>
  constexpr bool operator==(basic_string_view<charT, traits> lhs,
                            basic_string_view<charT, traits> rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{basic_string_view}%
\begin{itemdecl}
template<class charT, class traits>
  constexpr @\seebelow@ operator<=>(basic_string_view<charT, traits> lhs,
            @\itcorr@                      basic_string_view<charT, traits> rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{R} denote the type \tcode{traits::comparison_category} if
that \grammarterm{qualified-id} is valid and denotes a type\iref{temp.deduct},
otherwise \tcode{R} is \tcode{weak_ordering}.

\pnum
\mandates
\tcode{R} denotes a comparison category type\iref{cmp.categories}.

\pnum
\returns
\tcode{static_cast<R>(lhs.compare(rhs) <=> 0)}.
\end{itemdescr}

\rSec2[string.view.io]{Inserters and extractors}

\indexlibrarymember{operator<<}{basic_string_view}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, basic_string_view<charT, traits> str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves as a formatted output
function\iref{ostream.formatted.reqmts} of \tcode{os}. Forms a character sequence
\tcode{seq}, initially consisting of the elements defined by the range
\range{str.begin()}{str.end()}. Determines padding for \tcode{seq}
as described in~\ref{ostream.formatted.reqmts}.
Then inserts \tcode{seq} as if by calling
\tcode{os.rdbuf()->sputn(\brk{}seq, n)}, where \tcode{n} is the larger
of \tcode{os.width()} and \tcode{str.size()};
then calls \tcode{os.\brk{}width(0)}.

\pnum
\returns
\tcode{os}
\end{itemdescr}

\rSec2[string.view.hash]{Hash support}

\indexlibrarymember{hash}{string_view}%
\indexlibrarymember{hash}{u8string_view}%
\indexlibrarymember{hash}{u16string_view}%
\indexlibrarymember{hash}{u32string_view}%
\indexlibrarymember{hash}{wstring_view}%
\begin{itemdecl}
template<> struct hash<string_view>;
template<> struct hash<u8string_view>;
template<> struct hash<u16string_view>;
template<> struct hash<u32string_view>;
template<> struct hash<wstring_view>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization is enabled\iref{unord.hash}.
\begin{note}
The hash value of a string view object is equal to the hash value of
the corresponding string object\iref{basic.string.hash}.
\end{note}
\end{itemdescr}

\rSec2[string.view.literals]{Suffix for \tcode{basic_string_view} literals}

\indexlibrarymember{operator""""sv}{string_view}%
\begin{itemdecl}
constexpr string_view operator""sv(const char* str, size_t len) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{string_view\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""sv}{u8string_view}%
\begin{itemdecl}
constexpr u8string_view operator""sv(const char8_t* str, size_t len) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u8string_view\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""sv}{u16string_view}%
\begin{itemdecl}
constexpr u16string_view operator""sv(const char16_t* str, size_t len) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u16string_view\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""sv}{u32string_view}%
\begin{itemdecl}
constexpr u32string_view operator""sv(const char32_t* str, size_t len) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{u32string_view\{str, len\}}.
\end{itemdescr}

\indexlibrarymember{operator""""sv}{wstring_view}%
\begin{itemdecl}
constexpr wstring_view operator""sv(const wchar_t* str, size_t len) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{wstring_view\{str, len\}}.
\end{itemdescr}


\rSec1[c.strings]{Null-terminated sequence utilities}

\rSec2[cctype.syn]{Header \tcode{<cctype>} synopsis}

\indexlibraryglobal{isalnum}%
\indexlibraryglobal{isalpha}%
\indexlibraryglobal{isblank}%
\indexlibraryglobal{iscntrl}%
\indexlibraryglobal{isdigit}%
\indexlibraryglobal{isgraph}%
\indexlibraryglobal{islower}%
\indexlibraryglobal{isprint}%
\indexlibraryglobal{ispunct}%
\indexlibraryglobal{isspace}%
\indexlibraryglobal{isupper}%
\indexlibraryglobal{isxdigit}%
\indexlibraryglobal{tolower}%
\indexlibraryglobal{toupper}%
\begin{codeblock}
namespace std {
  int isalnum(int c);
  int isalpha(int c);
  int isblank(int c);
  int iscntrl(int c);
  int isdigit(int c);
  int isgraph(int c);
  int islower(int c);
  int isprint(int c);
  int ispunct(int c);
  int isspace(int c);
  int isupper(int c);
  int isxdigit(int c);
  int tolower(int c);
  int toupper(int c);
}
\end{codeblock}

\pnum
The contents and meaning of the header \libheaderdef{cctype}
are the same as the C standard library header \libheader{ctype.h}.

\xrefc{7.4}

\rSec2[cwctype.syn]{Header \tcode{<cwctype>} synopsis}

\indexlibraryglobal{wint_t}%
\indexlibraryglobal{wctrans_t}%
\indexlibraryglobal{wctype_t}%
\indexlibraryglobal{iswalnum}%
\indexlibraryglobal{iswalpha}%
\indexlibraryglobal{iswblank}%
\indexlibraryglobal{iswcntrl}%
\indexlibraryglobal{iswdigit}%
\indexlibraryglobal{iswgraph}%
\indexlibraryglobal{iswlower}%
\indexlibraryglobal{iswprint}%
\indexlibraryglobal{iswpunct}%
\indexlibraryglobal{iswspace}%
\indexlibraryglobal{iswupper}%
\indexlibraryglobal{iswxdigit}%
\indexlibraryglobal{iswctype}%
\indexlibraryglobal{wctype}%
\indexlibraryglobal{towlower}%
\indexlibraryglobal{towupper}%
\indexlibraryglobal{towctrans}%
\indexlibraryglobal{wctrans}%
\indexlibraryglobal{WEOF}%
\begin{codeblock}
namespace std {
  using wint_t = @\seebelow@;
  using wctrans_t = @\seebelow@;
  using wctype_t = @\seebelow@;

  int iswalnum(wint_t wc);
  int iswalpha(wint_t wc);
  int iswblank(wint_t wc);
  int iswcntrl(wint_t wc);
  int iswdigit(wint_t wc);
  int iswgraph(wint_t wc);
  int iswlower(wint_t wc);
  int iswprint(wint_t wc);
  int iswpunct(wint_t wc);
  int iswspace(wint_t wc);
  int iswupper(wint_t wc);
  int iswxdigit(wint_t wc);
  int iswctype(wint_t wc, wctype_t desc);
  wctype_t wctype(const char* property);
  wint_t towlower(wint_t wc);
  wint_t towupper(wint_t wc);
  wint_t towctrans(wint_t wc, wctrans_t desc);
  wctrans_t wctrans(const char* property);
}

#define WEOF @\seebelow@
\end{codeblock}

\pnum
The contents and meaning of the header \libheaderdef{cwctype}
are the same as the C standard library header \libheader{wctype.h}.

\xrefc{7.30}

\rSec2[cstring.syn]{Header \tcode{<cstring>} synopsis}

\indexlibraryglobal{memchr}%
\indexlibraryglobal{memcmp}%
\indexlibraryglobal{memcpy}%
\indexlibraryglobal{memmove}%
\indexlibraryglobal{memset}%
\indexlibraryglobal{size_t}%
\indexlibraryglobal{strcat}%
\indexlibraryglobal{strchr}%
\indexlibraryglobal{strcmp}%
\indexlibraryglobal{strcoll}%
\indexlibraryglobal{strcpy}%
\indexlibraryglobal{strcspn}%
\indexlibraryglobal{strerror}%
\indexlibraryglobal{strlen}%
\indexlibraryglobal{strncat}%
\indexlibraryglobal{strncmp}%
\indexlibraryglobal{strncpy}%
\indexlibraryglobal{strpbrk}%
\indexlibraryglobal{strrchr}%
\indexlibraryglobal{strspn}%
\indexlibraryglobal{strstr}%
\indexlibraryglobal{strtok}%
\indexlibraryglobal{strxfrm}%
\begin{codeblock}
namespace std {
  using size_t = @\textit{see \ref{support.types.layout}}@;

  void* memcpy(void* s1, const void* s2, size_t n);
  void* memmove(void* s1, const void* s2, size_t n);
  char* strcpy(char* s1, const char* s2);
  char* strncpy(char* s1, const char* s2, size_t n);
  char* strcat(char* s1, const char* s2);
  char* strncat(char* s1, const char* s2, size_t n);
  int memcmp(const void* s1, const void* s2, size_t n);
  int strcmp(const char* s1, const char* s2);
  int strcoll(const char* s1, const char* s2);
  int strncmp(const char* s1, const char* s2, size_t n);
  size_t strxfrm(char* s1, const char* s2, size_t n);
  const void* memchr(const void* s, int c, size_t n);           // see \ref{library.c}
  void* memchr(void* s, int c, size_t n);                       // see \ref{library.c}
  const char* strchr(const char* s, int c);                     // see \ref{library.c}
  char* strchr(char* s, int c);                                 // see \ref{library.c}
  size_t strcspn(const char* s1, const char* s2);
  const char* strpbrk(const char* s1, const char* s2);          // see \ref{library.c}
  char* strpbrk(char* s1, const char* s2);                      // see \ref{library.c}
  const char* strrchr(const char* s, int c);                    // see \ref{library.c}
  char* strrchr(char* s, int c);                                // see \ref{library.c}
  size_t strspn(const char* s1, const char* s2);
  const char* strstr(const char* s1, const char* s2);           // see \ref{library.c}
  char* strstr(char* s1, const char* s2);                       // see \ref{library.c}
  char* strtok(char* s1, const char* s2);
  void* memset(void* s, int c, size_t n);
  char* strerror(int errnum);
  size_t strlen(const char* s);
}

#define NULL @\textit{see \ref{support.types.nullptr}}@
\end{codeblock}

\pnum
The contents and meaning of the header \libheaderdef{cstring}
are the same as the C standard library header \libheader{string.h}.

\pnum
The functions \tcode{strerror} and \tcode{strtok} are not required to avoid data
races\iref{res.on.data.races}.

\pnum
\indextext{signal-safe!\idxcode{memcpy}}%
\indextext{signal-safe!\idxcode{memmove}}%
The functions \tcode{memcpy} and \tcode{memmove} are signal-safe\iref{support.signal}.
Both functions implicitly create objects\iref{intro.object}
in the destination region of storage
immediately prior to copying the sequence of characters to the destination.

\pnum
\begin{note}
The functions
\tcode{strchr}, \tcode{strpbrk}, \tcode{strrchr}, \tcode{strstr}, and \tcode{memchr},
have different signatures in this document,
but they have the same behavior as in the C standard library\iref{library.c}.
\end{note}

\xrefc{7.24}

\rSec2[cwchar.syn]{Header \tcode{<cwchar>} synopsis}

\indexheader{cwchar}%
\indexlibraryglobal{NULL}%
\indexlibraryglobal{WCHAR_MAX}%
\indexlibraryglobal{WCHAR_MIN}%
\indexlibraryglobal{WEOF}%
\indexlibraryglobal{btowc}%
\indexlibraryglobal{fgetwc}%
\indexlibraryglobal{fgetws}%
\indexlibraryglobal{fputwc}%
\indexlibraryglobal{fputws}%
\indexlibraryglobal{fwide}%
\indexlibraryglobal{fwprintf}%
\indexlibraryglobal{fwscanf}%
\indexlibraryglobal{getwchar}%
\indexlibraryglobal{getwc}%
\indexlibraryglobal{mbrlen}%
\indexlibraryglobal{mbrtowc}%
\indexlibraryglobal{mbsinit}%
\indexlibraryglobal{mbsrtowcs}%
\indexlibraryglobal{mbstate_t}%
\indexlibraryglobal{putwchar}%
\indexlibraryglobal{putwc}%
\indexlibraryglobal{size_t}%
\indexlibraryglobal{swprintf}%
\indexlibraryglobal{swscanf}%
\indexlibraryglobal{tm}%
\indexlibraryglobal{ungetwc}%
\indexlibraryglobal{vfwprintf}%
\indexlibraryglobal{vfwscanf}%
\indexlibraryglobal{vswprintf}%
\indexlibraryglobal{vswscanf}%
\indexlibraryglobal{vwprintf}%
\indexlibraryglobal{vwscanf}%
\indexlibraryglobal{wcrtomb}%
\indexlibraryglobal{wcscat}%
\indexlibraryglobal{wcschr}%
\indexlibraryglobal{wcscmp}%
\indexlibraryglobal{wcscoll}%
\indexlibraryglobal{wcscpy}%
\indexlibraryglobal{wcscspn}%
\indexlibraryglobal{wcsftime}%
\indexlibraryglobal{wcslen}%
\indexlibraryglobal{wcsncat}%
\indexlibraryglobal{wcsncmp}%
\indexlibraryglobal{wcsncpy}%
\indexlibraryglobal{wcspbrk}%
\indexlibraryglobal{wcsrchr}%
\indexlibraryglobal{wcsrtombs}%
\indexlibraryglobal{wcsspn}%
\indexlibraryglobal{wcsstr}%
\indexlibraryglobal{wcstod}%
\indexlibraryglobal{wcstof}%
\indexlibraryglobal{wcstok}%
\indexlibraryglobal{wcstold}%
\indexlibraryglobal{wcstoll}%
\indexlibraryglobal{wcstol}%
\indexlibraryglobal{wcstoull}%
\indexlibraryglobal{wcstoul}%
\indexlibraryglobal{wcsxfrm}%
\indexlibraryglobal{wctob}%
\indexlibraryglobal{wint_t}%
\indexlibraryglobal{wmemchr}%
\indexlibraryglobal{wmemcmp}%
\indexlibraryglobal{wmemcpy}%
\indexlibraryglobal{wmemmove}%
\indexlibraryglobal{wmemset}%
\indexlibraryglobal{wprintf}%
\indexlibraryglobal{wscanf}%
\begin{codeblock}
namespace std {
  using size_t = @\textit{see \ref{support.types.layout}}@;
  using mbstate_t = @\seebelow@;
  using wint_t = @\seebelow@;

  struct tm;

  int fwprintf(FILE* stream, const wchar_t* format, ...);
  int fwscanf(FILE* stream, const wchar_t* format, ...);
  int swprintf(wchar_t* s, size_t n, const wchar_t* format, ...);
  int swscanf(const wchar_t* s, const wchar_t* format, ...);
  int vfwprintf(FILE* stream, const wchar_t* format, va_list arg);
  int vfwscanf(FILE* stream, const wchar_t* format, va_list arg);
  int vswprintf(wchar_t* s, size_t n, const wchar_t* format, va_list arg);
  int vswscanf(const wchar_t* s, const wchar_t* format, va_list arg);
  int vwprintf(const wchar_t* format, va_list arg);
  int vwscanf(const wchar_t* format, va_list arg);
  int wprintf(const wchar_t* format, ...);
  int wscanf(const wchar_t* format, ...);
  wint_t fgetwc(FILE* stream);
  wchar_t* fgetws(wchar_t* s, int n, FILE* stream);
  wint_t fputwc(wchar_t c, FILE* stream);
  int fputws(const wchar_t* s, FILE* stream);
  int fwide(FILE* stream, int mode);
  wint_t getwc(FILE* stream);
  wint_t getwchar();
  wint_t putwc(wchar_t c, FILE* stream);
  wint_t putwchar(wchar_t c);
  wint_t ungetwc(wint_t c, FILE* stream);
  double wcstod(const wchar_t* nptr, wchar_t** endptr);
  float wcstof(const wchar_t* nptr, wchar_t** endptr);
  long double wcstold(const wchar_t* nptr, wchar_t** endptr);
  long int wcstol(const wchar_t* nptr, wchar_t** endptr, int base);
  long long int wcstoll(const wchar_t* nptr, wchar_t** endptr, int base);
  unsigned long int wcstoul(const wchar_t* nptr, wchar_t** endptr, int base);
  unsigned long long int wcstoull(const wchar_t* nptr, wchar_t** endptr, int base);
  wchar_t* wcscpy(wchar_t* s1, const wchar_t* s2);
  wchar_t* wcsncpy(wchar_t* s1, const wchar_t* s2, size_t n);
  wchar_t* wmemcpy(wchar_t* s1, const wchar_t* s2, size_t n);
  wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
  wchar_t* wcscat(wchar_t* s1, const wchar_t* s2);
  wchar_t* wcsncat(wchar_t* s1, const wchar_t* s2, size_t n);
  int wcscmp(const wchar_t* s1, const wchar_t* s2);
  int wcscoll(const wchar_t* s1, const wchar_t* s2);
  int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
  size_t wcsxfrm(wchar_t* s1, const wchar_t* s2, size_t n);
  int wmemcmp(const wchar_t* s1, const wchar_t* s2, size_t n);
  const wchar_t* wcschr(const wchar_t* s, wchar_t c);           // see \ref{library.c}
  wchar_t* wcschr(wchar_t* s, wchar_t c);                       // see \ref{library.c}
  size_t wcscspn(const wchar_t* s1, const wchar_t* s2);
  const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2); // see \ref{library.c}
  wchar_t* wcspbrk(wchar_t* s1, const wchar_t* s2);             // see \ref{library.c}
  const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);          // see \ref{library.c}
  wchar_t* wcsrchr(wchar_t* s, wchar_t c);                      // see \ref{library.c}
  size_t wcsspn(const wchar_t* s1, const wchar_t* s2);
  const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);  // see \ref{library.c}
  wchar_t* wcsstr(wchar_t* s1, const wchar_t* s2);              // see \ref{library.c}
  wchar_t* wcstok(wchar_t* s1, const wchar_t* s2, wchar_t** ptr);
  const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);    // see \ref{library.c}
  wchar_t* wmemchr(wchar_t* s, wchar_t c, size_t n);            // see \ref{library.c}
  size_t wcslen(const wchar_t* s);
  wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
  size_t wcsftime(wchar_t* s, size_t maxsize, const wchar_t* format, const tm* timeptr);
  wint_t btowc(int c);
  int wctob(wint_t c);

  // \ref{c.mb.wcs}, multibyte / wide string and character conversion functions
  int mbsinit(const mbstate_t* ps);
  size_t mbrlen(const char* s, size_t n, mbstate_t* ps);
  size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t* ps);
  size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
  size_t mbsrtowcs(wchar_t* dst, const char** src, size_t len, mbstate_t* ps);
  size_t wcsrtombs(char* dst, const wchar_t** src, size_t len, mbstate_t* ps);
}

#define NULL @\textit{see \ref{support.types.nullptr}}@
#define WCHAR_MAX @\seebelow@
#define WCHAR_MIN @\seebelow@
#define WEOF @\seebelow@
\end{codeblock}

\pnum
The contents and meaning of the header \libheader{cwchar}
are the same as the C standard library header
\libheader{wchar.h}, except that it does not declare a type \keyword{wchar_t}.

\pnum
\begin{note}
The functions
\tcode{wcschr}, \tcode{wcspbrk}, \tcode{wcsrchr}, \tcode{wcsstr}, and \tcode{wmemchr}
have different signatures in this document,
but they have the same behavior as in the C standard library\iref{library.c}.
\end{note}

\xrefc{7.29}

\rSec2[cuchar.syn]{Header \tcode{<cuchar>} synopsis}

\indexlibraryglobal{mbstate_t}%
\indexlibraryglobal{size_t}%
\indexlibraryglobal{mbrtoc8}%
\indexlibraryglobal{c8rtomb}%
\indexlibraryglobal{mbrtoc16}%
\indexlibraryglobal{c16rtomb}%
\indexlibraryglobal{mbrtoc32}%
\indexlibraryglobal{c32rtomb}%
\begin{codeblock}
namespace std {
  using mbstate_t = @\seebelow@;
  using size_t = @\textit{see \ref{support.types.layout}}@;

  size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);
  size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);
  size_t mbrtoc16(char16_t* pc16, const char* s, size_t n, mbstate_t* ps);
  size_t c16rtomb(char* s, char16_t c16, mbstate_t* ps);
  size_t mbrtoc32(char32_t* pc32, const char* s, size_t n, mbstate_t* ps);
  size_t c32rtomb(char* s, char32_t c32, mbstate_t* ps);
}
\end{codeblock}

\pnum
The contents and meaning of the header \libheaderdef{cuchar}
are the same as the C standard library header
\libheader{uchar.h}, except that it
declares the additional \tcode{mbrtoc8} and \tcode{c8rtomb} functions
and does not declare types \keyword{char16_t} nor \keyword{char32_t}.

\xrefc{7.28}

\rSec2[c.mb.wcs]{Multibyte / wide string and character conversion functions}

\pnum
\begin{note}
The headers \libheaderref{cstdlib},
\libheaderref{cuchar},
and \libheaderref{cwchar}
declare the functions described in this subclause.
\end{note}

\indexlibraryglobal{mbsinit}%
\indexlibraryglobal{mblen}%
\indexlibraryglobal{mbstowcs}%
\indexlibraryglobal{wcstombs}%
\begin{itemdecl}
int mbsinit(const mbstate_t* ps);
int mblen(const char* s, size_t n);
size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions have the semantics specified in the C standard library.
\end{itemdescr}

\xrefc{7.22.7.1, 7.22.8, 7.29.6.2.1}

\indexlibraryglobal{mbtowc}%
\indexlibraryglobal{wctomb}%
\begin{itemdecl}
int mbtowc(wchar_t* pwc, const char* s, size_t n);
int wctomb(char* s, wchar_t wchar);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions have the semantics specified in the C standard library.

\pnum
\remarks
Calls to these functions
may introduce a data race\iref{res.on.data.races}
with other calls to the same function.
\end{itemdescr}

\xrefc{7.22.7}

\indexlibraryglobal{mbrlen}%
\indexlibraryglobal{mbrstowcs}%
\indexlibraryglobal{wcrstombs}%
\indexlibraryglobal{mbrtowc}%
\indexlibraryglobal{wcrtomb}%
\begin{itemdecl}
size_t mbrlen(const char* s, size_t n, mbstate_t* ps);
size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t* ps);
size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
size_t mbsrtowcs(wchar_t* dst, const char** src, size_t len, mbstate_t* ps);
size_t wcsrtombs(char* dst, const wchar_t** src, size_t len, mbstate_t* ps);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions have the semantics specified in the C standard library.

\pnum
\remarks
Calling these functions
with an \tcode{mbstate_t*} argument that is a null pointer value
may introduce a data race\iref{res.on.data.races}
with other calls to the same function
with an \tcode{mbstate_t*} argument that is a null pointer value.
\end{itemdescr}

\xrefc{7.29.6.3}

\indexlibraryglobal{mbrtoc8}%
\begin{itemdecl}
size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{s} is a null pointer,
equivalent to \tcode{mbrtoc8(nullptr, "", 1, ps)}.
Otherwise, the function inspects at most \tcode{n} bytes
beginning with the byte pointed to by \tcode{s}
to determine the number of bytes needed to complete
the next multibyte character (including any shift sequences).
If the function determines
that the next multibyte character is complete and valid,
it determines the values of the corresponding UTF-8 code units and then,
if \tcode{pc8} is not a null pointer,
stores the value of the first (or only) such code unit
in the object pointed to by \tcode{pc8}.
Subsequent calls will store successive UTF-8 code units
without consuming any additional input
until all the code units have been stored.
If the corresponding Unicode character is U+0000,
the resulting state described is the initial conversion state.

\pnum
\returns
The first of the following that applies (given the current conversion state):
\begin{itemize}
\item \tcode{0}, if the next \tcode{n} or fewer bytes complete
the multibyte character
that corresponds to the U+0000 Unicode character
(which is the value stored).
\item between \tcode{1} and \tcode{n} (inclusive),
if the next n or fewer bytes complete a valid multibyte character
(which is the value stored);
the value returned is the number of bytes that complete the multibyte character.
\item \tcode{(size_t)(-3)}, if the next character
resulting from a previous call has been stored
(no bytes from the input have been consumed by this call).
\item \tcode{(size_t)(-2)}, if the next \tcode{n} bytes
contribute to an incomplete (but potentially valid) multibyte character, and
all \tcode{n} bytes have been processed (no value is stored).
\item \tcode{(size_t)(-1)}, if an encoding error occurs,
in which case the next \tcode{n} or fewer bytes do not contribute to
a complete and valid multibyte character (no value is stored);
the value of the macro \tcode{EILSEQ} is stored in \tcode{errno}, and
the conversion state is unspecified.
\end{itemize}
\end{itemdescr}

\indexlibraryglobal{c8rtomb}%
\begin{itemdecl}
size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{s} is a null pointer, equivalent to
\tcode{c8rtomb(buf, u8'$\backslash$0', ps)}
where \tcode{buf} is an internal buffer.
Otherwise, if \tcode{c8} completes a sequence of valid UTF-8 code units,
determines the number of bytes needed
to represent the multibyte character (including any shift sequences),
and stores the multibyte character representation in the array
whose first element is pointed to by \tcode{s}.
At most \tcode{MB_CUR_MAX} bytes are stored.
If the multibyte character is a null character, a null byte is stored,
preceded by any shift sequence needed to restore the initial shift state;
the resulting state described is the initial conversion state.

\pnum
\returns
The number of bytes stored in the array object (including any shift sequences).
If \tcode{c8} does not contribute to a sequence of \keyword{char8_t}
corresponding to a valid multibyte character,
the value of the macro \tcode{EILSEQ} is stored in \tcode{errno},
\tcode{(size_t) (-1)} is returned, and the conversion state is unspecified.

\pnum
\remarks
Calls to \tcode{c8rtomb} with a null pointer argument for \tcode{s}
may introduce a data race\iref{res.on.data.races}
with other calls to \tcode{c8rtomb}
with a null pointer argument for \tcode{s}.
\end{itemdescr}
