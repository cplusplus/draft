%!TEX root = std.tex
\rSec0[over]{Overloading}%
\indextext{overloading|(}

\gramSec[gram.over]{Overloading}

\rSec1[over.pre]{Preamble}

\pnum
\indextext{overloaded function|see{overloading}}%
\indextext{function!overloaded|see{overloading}}%
\begin{note}
Each of two or more entities with the same name in the same scope,
which must be functions or function templates,
is commonly called an ``overload''.
\end{note}

\pnum
When a function is named in a call, which function
declaration is being referenced and the validity of the call
are determined by comparing the types
of the arguments at the point of use with the types of the parameters
in the declarations in the overload set.
This function selection process is called
\defn{overload resolution} and is defined in~\ref{over.match}.
\begin{example}
\indextext{overloading!example of}%
\begin{codeblock}
double abs(double);
int abs(int);

abs(1);             // calls \tcode{abs(int);}
abs(1.0);           // calls \tcode{abs(double);}
\end{codeblock}
\end{example}

\rSec1[over.match]{Overload resolution}%

\rSec2[over.match.general]{General}%
\indextext{overloading!resolution|(}%
\indextext{resolution|see{overloading, resolution}}%
\indextext{ambiguity!overloaded function}

\pnum
Overload resolution is a mechanism for selecting the best
function to call given a list of expressions that are to be the
arguments of the call and a set of
\defnx{candidate functions}{candidate}
that can
be called based on the context of the call.
The selection
criteria for the best function are the number of arguments, how
well the arguments match the parameter-type-list of the
candidate function,
how well (for non-static member functions) the object
matches the implicit object parameter,
and certain other properties of the candidate function.
\begin{note}
The function selected by overload resolution is not
guaranteed to be appropriate for the context.
Other restrictions,
such as the accessibility of the function, can make its use in
the calling context ill-formed.
\end{note}

\pnum
\indextext{overloading!resolution!contexts}%
Overload resolution selects the function to call in seven distinct
contexts within the language:
\begin{itemize}
\item
invocation of a function named in the function call syntax\iref{over.call.func};
\item
invocation of a function call operator, a pointer-to-function
conversion function, a reference-to-pointer-to-function conversion
function, or a reference-to-function
conversion function on a class object named in the function
call syntax\iref{over.call.object};
\item
invocation of the operator referenced in an expression\iref{over.match.oper};
\item
invocation of a constructor for default- or direct-initialization\iref{dcl.init}
of a class object\iref{over.match.ctor};
\item
invocation of a user-defined conversion for
copy-initialization\iref{dcl.init} of a class object\iref{over.match.copy};
\item
invocation of a conversion function for initialization of an object of a
non-class type from an expression of class type\iref{over.match.conv}; and
\item
invocation of a conversion function for conversion
in which a reference\iref{dcl.init.ref}
will be directly bound\iref{over.match.ref}.
\end{itemize}

Each of these contexts defines the set of candidate functions and
the list of arguments in its own unique way.
But, once the
candidate functions and argument lists have been identified, the
selection of the best function is the same in all cases:

\begin{itemize}
\item
First, a subset of the candidate functions (those that have
the proper number of arguments and meet certain other
conditions) is selected to form a set of
\indextext{function!viable}%
viable functions\iref{over.match.viable}.
\item
Then the best viable function is selected based on the
implicit conversion sequences\iref{over.best.ics} needed to
match each argument to the corresponding parameter of each
viable function.
\end{itemize}

\pnum
If a best viable function exists and is unique, overload
resolution succeeds and produces it as the result.
Otherwise
overload resolution fails and the invocation is ill-formed.
When overload resolution succeeds,
and the best viable function is not accessible\iref{class.access} in the context
in which it is used,
the program is ill-formed.

\pnum
Overload resolution results in a \defnadj{usable}{candidate}
if overload resolution succeeds and
the selected candidate
is either not a function\iref{over.built}, or
is a function that is not deleted and
is accessible from the context
in which overload resolution was performed.

\rSec2[over.match.funcs]{Candidate functions and argument lists}%

\rSec3[over.match.funcs.general]{General}%
\indextext{overloading!candidate functions|(}%
\indextext{overloading!argument lists|(}

\pnum
The subclauses of~\ref{over.match.funcs} describe
the set of candidate functions and the argument list submitted to
overload resolution in each context in which
overload resolution is used.
The source transformations and constructions defined
in these subclauses are only for the purpose of describing the
overload resolution process.
An implementation is not required
to use such transformations and constructions.

\pnum
\indextext{member function!overload resolution and}%
\indextext{function!overload resolution and}%
The set of candidate functions can contain both member and non-member
functions to be resolved against the same argument list.
So that argument and parameter lists are comparable within this
heterogeneous set, a member function is considered to have an
extra first parameter, called the
\defn{implicit object parameter},
which represents the object for which the member function has been
called.
For the purposes of overload resolution, both static and
non-static member functions have an implicit object parameter,
but constructors do not.

\pnum
Similarly, when appropriate, the context can construct an
argument list that contains an
\defn{implied object argument}
as the first argument in the list to denote
the object to be operated on.

\pnum
For non-static member functions, the type of the implicit object
parameter is
\begin{itemize}
\item ``lvalue reference to \cv{}~\tcode{X}'' for functions declared
without a \grammarterm{ref-qualifier} or with the
\tcode{\&} \grammarterm{ref-qualifier}
\item ``rvalue reference to \cv{}~\tcode{X}'' for functions declared with the
\tcode{\&\&} \grammarterm{ref-qualifier}
\end{itemize}
where
\tcode{X}
is the class of which the function is a member and
\cv{}
is the cv-qualification on the
member function declaration.
\begin{example}
For a
\keyword{const}
member
function of class
\tcode{X},
the extra parameter is assumed to have type
``reference to
\tcode{const X}''.
\end{example}
For conversion functions, the function is considered to be a member of the
class of the implied object argument for the purpose of defining the
type of the implicit object parameter.
For non-conversion functions
nominated by a \grammarterm{using-declaration}
in a derived class, the function is
considered to be a member of the derived class for the purpose of defining
the type of the implicit object parameter.
For static member functions, the implicit object parameter is considered
to match any object (since if the function is selected, the object is
discarded).
\begin{note}
No actual type is established for the implicit object parameter
of a static member function, and no attempt will be made to determine a
conversion sequence for that parameter\iref{over.match.best}.
\end{note}

\pnum
\indextext{implied object argument!implicit conversion sequences}%
During overload resolution, the implied object argument is
indistinguishable from other arguments.
The implicit object
parameter, however, retains its identity since
no user-defined conversions can be applied to achieve a type
match with it.
\indextext{implied object argument!non-static member function and}%
For non-static member functions declared without a \grammarterm{ref-qualifier},
even if the implicit object parameter is not const-qualified,
an rvalue can be bound to the parameter
as long as in all other respects the argument can be
converted to the type of the implicit object parameter.
\begin{note}
The fact that such an argument is an rvalue does not
affect the ranking of implicit conversion sequences\iref{over.ics.rank}.
\end{note}

\pnum
Because other than in list-initialization only one user-defined conversion
is allowed
in an
implicit conversion sequence, special rules apply when selecting
the best user-defined conversion~(\ref{over.match.best},
\ref{over.best.ics}).
\begin{example}
\begin{codeblock}
class T {
public:
  T();
};

class C : T {
public:
  C(int);
};
T a = 1;            // error: no viable conversion (\tcode{T(C(1))} not considered)
\end{codeblock}
\end{example}

\pnum
In each case where conversion functions of a class \tcode{S} are considered
for initializing an object or reference of type \tcode{T},
the candidate functions include the result of a search
for the \grammarterm{conversion-function-id} \tcode{\keyword{operator} T}
in \tcode{S}.
\begin{note}
This search can find a specialization of
a conversion function template\iref{basic.lookup}.
\end{note}
Each such case also defines sets of \defnadj{permissible}{types}
for explicit and non-explicit conversion functions;
each (non-template) conversion function
that
\begin{itemize}
\item is a non-hidden member of \tcode{S},
\item yields a permissible type, and,
\item for the former set, is non-explicit
\end{itemize}
is also a candidate function.
If initializing an object, for any permissible type \cv{} \tcode{U}, any
\cvqual{cv2} \tcode{U}, \cvqual{cv2} \tcode{U\&}, or \cvqual{cv2} \tcode{U\&\&}
is also a permissible type.
If the set of permissible types for explicit conversion functions is empty,
any candidates that are explicit are discarded.

\pnum
In each case where a candidate is a function template, candidate
function template specializations
are generated using template argument deduction~(\ref{temp.over},
\ref{temp.deduct}).
If a constructor template or conversion function template
has an \grammarterm{explicit-specifier}
whose \grammarterm{constant-expression} is value-dependent\iref{temp.dep},
template argument deduction is performed first and then,
if the context admits only candidates that
are not explicit and the generated specialization is explicit\iref{dcl.fct.spec},
it will be removed from the candidate set.
Those candidates are then handled as candidate
functions in the usual way.
\begin{footnote}
The process of argument deduction fully
determines the parameter types of
the
function template specializations,
i.e., the parameters of
function template specializations
contain
no template parameter types.
Therefore, except where specified otherwise,
function template specializations
and non-template functions\iref{dcl.fct} are treated equivalently
for the remainder of overload resolution.
\end{footnote}
A given name can refer to, or a conversion can consider,
one or more function templates as well as a set of non-template functions.
In such a case, the
candidate functions generated from each function template are combined
with the set of non-template candidate functions.

\pnum
A
defaulted move special member function~(\ref{class.copy.ctor}, \ref{class.copy.assign})
that is defined as deleted
is excluded from the set of candidate functions in all contexts.
A constructor inherited from class type \tcode{C}\iref{class.inhctor.init}
that has a first parameter of type ``reference to \cvqual{cv1} \tcode{P}''
(including such a constructor instantiated from a template)
is excluded from the set of candidate functions
when constructing an object of type \cvqual{cv2} \tcode{D}
if the argument list has exactly one argument and
\tcode{C} is reference-related to \tcode{P} and
\tcode{P} is reference-related to \tcode{D}.
\begin{example}
\begin{codeblock}
struct A {
  A();                                  // \#1
  A(A &&);                              // \#2
  template<typename T> A(T &&);         // \#3
};
struct B : A {
  using A::A;
  B(const B &);                         // \#4
  B(B &&) = default;                    // \#5, implicitly deleted

  struct X { X(X &&) = delete; } x;
};
extern B b1;
B b2 = static_cast<B&&>(b1);            // calls \#4: \#1 is not viable, \#2, \#3, and \#5 are not candidates
struct C { operator B&&(); };
B b3 = C();                             // calls \#4
\end{codeblock}
\end{example}

\rSec3[over.match.call]{Function call syntax}%

\rSec4[over.match.call.general]{General}%
\indextext{overloading!resolution!function call syntax|(}

\pnum
In a function call\iref{expr.call}
\begin{ncsimplebnf}
postfix-expression \terminal{(} \opt{expression-list} \terminal{)}
\end{ncsimplebnf}
if the \grammarterm{postfix-expression} names at least one function or
function template,
overload resolution is applied as specified in \ref{over.call.func}.
If the \grammarterm{postfix-expression} denotes an object of class type, overload
resolution is applied as specified in \ref{over.call.object}.

\pnum
If the \grammarterm{postfix-expression} is the address of an overload set,
overload resolution is applied using that set as described above.
If the function selected by overload resolution is a non-static member function,
the program is ill-formed.
\begin{note}
The resolution of the address of an
overload set in other contexts is described in \ref{over.over}.
\end{note}

\rSec4[over.call.func]{Call to named function}

\pnum
Of interest in~\ref{over.call.func} are only those function calls in
which the \grammarterm{postfix-expression}
ultimately contains an \grammarterm{id-expression} that
denotes one or more functions.
Such a
\grammarterm{postfix-expression},
perhaps nested arbitrarily deep in
parentheses, has one of the following forms:

\begin{ncbnf}
postfix-expression:\br
    postfix-expression \terminal{.} id-expression\br
    postfix-expression \terminal{->} id-expression\br
    primary-expression
\end{ncbnf}

These represent two syntactic subcategories of function calls:
qualified function calls and unqualified function calls.

\pnum
In qualified function calls,
the function is named by an \grammarterm{id-expression}
preceded by an \tcode{->} or \tcode{.} operator.
Since the
construct
\tcode{A->B}
is generally equivalent to
\tcode{(*A).B},
the rest of
\ref{over} assumes, without loss of generality, that all member
function calls have been normalized to the form that uses an
object and the
\tcode{.}
operator.
Furthermore, \ref{over} assumes that
the
\grammarterm{postfix-expression}
that is the left operand of the
\tcode{.}
operator
has type ``\cv{}~\tcode{T}''
where
\tcode{T}
denotes a class.
\begin{footnote}
Note that cv-qualifiers on the type of objects are
significant in overload
resolution for
both glvalue and class prvalue objects.
\end{footnote}
The function declarations found by name lookup\iref{class.member.lookup}
constitute the set of candidate functions.
The argument list is the
\grammarterm{expression-list}
in the call augmented by the addition of the left operand of
the
\tcode{.}
operator in the normalized member function call as the
implied object argument\iref{over.match.funcs}.

\pnum
In unqualified function calls, the function is named by a
\grammarterm{primary-expression}.
The function declarations found by name lookup\iref{basic.lookup} constitute the
set of candidate functions.
Because of the rules for name lookup, the set of candidate functions
consists (1) entirely of non-member functions or (2) entirely of
member functions of some class
\tcode{T}.
In case (1),
the argument list is
the same as the
\grammarterm{expression-list}
in the call.
In case (2), the argument list is the
\grammarterm{expression-list}
in the call augmented by the addition of an implied object
argument as in a qualified function call.
If the current class is, or is derived from, \tcode{T}, and the keyword
\keyword{this}\iref{expr.prim.this} refers to it,
then the implied object argument is \tcode{(*this)}.
Otherwise,
a contrived object of type
\tcode{T}
becomes the implied object argument;
\begin{footnote}
An implied object argument is contrived to
correspond to the implicit object
parameter attributed to member functions during overload resolution.
It is not
used in
the call to the selected function.
Since the member functions all have the
same implicit
object parameter, the contrived object will not be the cause to select or
reject a
function.
\end{footnote}
if overload resolution selects a non-static member function,
the call is ill-formed.

\rSec4[over.call.object]{Call to object of class type}

\pnum
If the \grammarterm{postfix-expression} \tcode{E}
in the function call syntax evaluates
to a class object of type ``\cv{}~\tcode{T}'',
then the set of candidate functions
includes at least the function call operators of \tcode{T}.
The function call operators of \tcode{T}
are the results of a search for the name \tcode{\keyword{operator}()}
in the scope of \tcode{T}.

\pnum
In addition, for each non-explicit conversion function declared in \tcode{T} of the
form
\begin{ncsimplebnf}
\keyword{operator} conversion-type-id \terminal{(\,)} \opt{cv-qualifier-seq} \opt{ref-qualifier} \opt{noexcept-specifier} \opt{attribute-specifier-seq} \terminal{;}
\end{ncsimplebnf}
where the optional
\grammarterm{cv-qualifier-seq}
is the same cv-qualification as, or a greater cv-qualification than,
\cv{},
and where
\grammarterm{conversion-type-id}
denotes the type ``pointer to function
of ($\tcode{P}_1, \dotsc, \tcode{P}_n$) returning \tcode{R}'',
or the type ``reference to pointer to function
of ($\tcode{P}_1, \dotsc, \tcode{P}_n$) returning \tcode{R}'',
or the type
``reference to function of ($\tcode{P}_1, \dotsc, \tcode{P}_n$)
returning \tcode{R}'', a \defn{surrogate call function} with the unique name
\placeholder{call-function}
and having the form
\begin{ncbnf}
\terminal{R} \placeholder{call-function} \terminal{(} conversion-type-id \ %
\terminal{F, P$_1$ a$_1$, $\dotsc$, P$_n$ a$_n$)} \terminal{\{ return F (a$_1$, $\dotsc$, a$_n$); \}}
\end{ncbnf}
is also considered as a candidate function.
Similarly, surrogate
call functions are added to the set of candidate functions for
each non-explicit conversion function declared in a base class of
\tcode{T}
provided the function is not hidden within
\tcode{T}
by another
intervening declaration.
\begin{footnote}
Note that this construction can yield
candidate call functions that cannot be
differentiated one from the other by overload resolution because they have
identical
declarations or differ only in their return type.
The call will be ambiguous
if overload
resolution cannot select a match to the call that is uniquely better than such
undifferentiable functions.
\end{footnote}

\pnum
The argument list submitted to overload resolution consists of
the argument expressions present in the function call syntax
preceded by the implied object argument
\tcode{(E)}.
\begin{note}
When comparing the
call against the function call operators, the implied object
argument is compared against the implicit object parameter of the
function call operator.
When comparing the call against a
surrogate call function, the implied object argument is compared
against the first parameter of the surrogate call function.
The
conversion function from which the surrogate call function was
derived will be used in the conversion sequence for that
parameter since it converts the implied object argument to the
appropriate function pointer or reference required by that first
parameter.
\end{note}
\begin{example}
\begin{codeblock}
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
  operator fp1() { return f1; }
  operator fp2() { return f2; }
} a;
int i = a(1);                   // calls \tcode{f1} via pointer returned from conversion function
\end{codeblock}
\end{example}
\indextext{overloading!resolution!function call syntax|)}

\rSec3[over.match.oper]{Operators in expressions}%
\indextext{overloading!resolution!operators}

\pnum
If no operand of an operator in an expression has a type that is a class
or an enumeration, the operator is assumed to be a built-in operator
and interpreted according to \ref{expr.compound}.
\begin{note}
Because
\tcode{.},
\tcode{.*},
and
\tcode{::}
cannot be overloaded,
these operators are always built-in operators interpreted according to
\ref{expr.compound}.
\tcode{?:}
cannot be overloaded, but the rules in this subclause are used to determine
the conversions to be applied to the second and third operands when they
have class or enumeration type\iref{expr.cond}.
\end{note}
\begin{example}
\begin{codeblock}
struct String {
  String (const String&);
  String (const char*);
  operator const char* ();
};
String operator + (const String&, const String&);

void f() {
  const char* p= "one" + "two"; // error: cannot add two pointers; overloaded \tcode{operator+} not considered
                                // because neither operand has class or enumeration type
  int I = 1 + 1;                // always evaluates to \tcode{2} even if class or enumeration types exist
                                // that would perform the operation.
}
\end{codeblock}
\end{example}

\pnum
If either operand has a type that is a class or an enumeration, a
user-defined operator function can be declared that implements
this operator or a user-defined conversion can be necessary to
convert the operand to a type that is appropriate for a built-in
operator.
In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the
operator.
Therefore, the operator notation is first transformed
to the equivalent function-call notation as summarized in
\tref{over.match.oper}
(where \tcode{@} denotes one of the operators covered in the specified subclause).
However, the operands are sequenced in the order prescribed
for the built-in operator\iref{expr.compound}.

\begin{floattable}{Relationship between operator and function call notation}{over.match.oper}
{l|l|l|l}
\topline
\hdstyle{Subclause} &   \hdstyle{Expression} &   \hdstyle{As member function} &   \hdstyle{As non-member function} \\ \capsep
\ref{over.unary}    &   \tcode{@a}   &   \tcode{(a).\keyword{operator}@ (\,)}  &   \tcode{\keyword{operator}@(a)}    \\
\ref{over.binary}   &   \tcode{a@b}  &   \tcode{(a).\keyword{operator}@ (b)}   &   \tcode{\keyword{operator}@(a, b)} \\
\ref{over.ass}      &   \tcode{a=b}  &   \tcode{(a).\keyword{operator}= (b)}   &                           \\
\ref{over.sub}      &   \tcode{a[b]} &   \tcode{(a).\keyword{operator}[](b)}   &                           \\
\ref{over.ref}      &   \tcode{a->}  &   \tcode{(a).\keyword{operator}->(\,)}  &                           \\
\ref{over.inc}      &   \tcode{a@}   &   \tcode{(a).\keyword{operator}@ (0)}   &   \tcode{\keyword{operator}@(a, 0)} \\
\end{floattable}

\pnum
For a unary operator \tcode{@}
with an operand of type \cvqual{cv1} \tcode{T1},
and for a binary operator \tcode{@}
with a left operand of type \cvqual{cv1} \tcode{T1}
and a right operand of type \cvqual{cv2} \tcode{T2},
four sets of candidate functions, designated
\defnx{member candidates}{member candidate},
\defnx{non-member candidates}{non-member candidate},
\defnx{built-in candidates}{built-in candidate},
and
\defnx{rewritten candidates}{rewritten candidate},
are constructed as follows:
\begin{itemize}
\item
If \tcode{T1} is a complete class type or a class currently being defined,
the set of member candidates is the result of a search for
\tcode{\keyword{operator}@} in the scope of \tcode{T1};
otherwise, the set of member candidates is empty.
\item
For the operators \tcode{=}, \tcode{[]}, or \tcode{->},
the set of non-member candidates is empty;
otherwise, it includes the result of unqualified lookup for
\tcode{\keyword{operator}@}
in the rewritten function call
(\ref{basic.lookup.unqual}, \ref{basic.lookup.argdep}),
ignoring all member functions.
However, if no operand has a class type, only those non-member
functions in the lookup set that have a first parameter of type
\tcode{T1}
or ``reference to \cv{}~\tcode{T1}'',
when
\tcode{T1}
is an enumeration type,
or (if there is a right operand) a second parameter of type
\tcode{T2}
or ``reference to \cv{}~\tcode{T2}'',
when
\tcode{T2}
is an enumeration type,
are candidate functions.
\item
For the operator
\tcode{,},
the unary operator
\tcode{\&},
or the operator
\tcode{->},
the built-in candidates set is empty.
For all other operators, the built-in candidates include all
of the candidate operator functions defined in~\ref{over.built} that,
compared to the given operator,
\begin{itemize}
\item
have the same operator name, and
\item
accept the same number of operands, and
\item
accept operand types to which the given operand or
operands can be converted according to \ref{over.best.ics}, and
\item
do not have the same parameter-type-list as any non-member candidate
that is not a function template specialization.
\end{itemize}

\item
The rewritten candidate set is determined as follows:
\begin{itemize}
\item
For the relational\iref{expr.rel} operators,
the rewritten candidates include
all non-rewritten candidates
for the expression \tcode{x <=> y}.
\item
For the
relational\iref{expr.rel} and
three-way comparison\iref{expr.spaceship}
operators,
the rewritten candidates also include
a synthesized candidate,
with the order of the two parameters reversed,
for each non-rewritten candidate
for the expression
\tcode{y <=> x}.
\item
For the \tcode{!=} operator\iref{expr.eq},
the rewritten candidates
include all non-rewritten candidates
for the expression \tcode{x == y}.
\item
For the equality operators,
the rewritten candidates also include a synthesized candidate,
with the order of the two parameters reversed,
for each non-rewritten candidate
for the expression \tcode{y == x}.
\item
For all other operators, the rewritten candidate set is empty.
\end{itemize}
\begin{note}
A candidate synthesized from a member candidate has its implicit
object parameter as the second parameter, thus implicit conversions
are considered for the first, but not for the second, parameter.
\end{note}
\end{itemize}

\pnum
For the built-in assignment operators, conversions of the left
operand are restricted as follows:
\begin{itemize}
\item
no temporaries are introduced to hold the left operand, and
\item
no user-defined conversions are applied to the left operand to achieve
a type match with the left-most parameter of a built-in candidate.
\end{itemize}

\pnum
For all other operators, no such restrictions apply.

\pnum
The set of candidate functions for overload resolution
for some operator \tcode{@}
is the
union of
the member candidates,
the non-member candidates,
the built-in candidates,
and the rewritten candidates
for that operator \tcode{@}.

\pnum
The argument list contains all of the
operands of the operator.
The best function from the set of candidate functions is selected
according to~\ref{over.match.viable}
and~\ref{over.match.best}.
\begin{footnote}
If the set of candidate functions is empty,
overload resolution is unsuccessful.
\end{footnote}
\begin{example}
\begin{codeblock}
struct A {
  operator int();
};
A operator+(const A&, const A&);
void m() {
  A a, b;
  a + b;                        // \tcode{\keyword{operator}+(a, b)} chosen over \tcode{int(a) + int(b)}
}
\end{codeblock}
\end{example}

\pnum
If a rewritten \tcode{\keyword{operator}<=>} candidate
is selected by overload resolution
for an operator \tcode{@},
\tcode{x @ y}
is interpreted as
\tcode{0 @ (y <=> x)}
if the selected candidate is a synthesized candidate
with reversed order of parameters,
or \tcode{(x <=> y) @ 0} otherwise,
using the selected rewritten \tcode{\keyword{operator}<=>} candidate.
Rewritten candidates for the operator \tcode{@}
are not considered in the context of the resulting expression.

\pnum
If a rewritten \tcode{\keyword{operator}==} candidate
is selected by overload resolution
for an operator \tcode{@},
its return type shall be \cv{} \tcode{bool}, and
\tcode{x @ y} is interpreted as:
\begin{itemize}
\item
if \tcode{@} is \tcode{!=}
and the selected candidate is a synthesized candidate
with reversed order of parameters,
\tcode{!(y == x)},
\item
otherwise, if \tcode{@} is \tcode{!=},
\tcode{!(x == y)},
\item
otherwise (when \tcode{@} is \tcode{==}),
\tcode{y == x},
\end{itemize}
in each case using the selected rewritten \tcode{\keyword{operator}==} candidate.

\pnum
If a built-in candidate is selected by overload resolution, the
operands of class type are converted to the types of the corresponding parameters
of the selected operation function, except that the second standard conversion
sequence of a user-defined conversion sequence\iref{over.ics.user} is not applied.
Then the operator is treated as the corresponding
built-in operator and interpreted according to \ref{expr.compound}.
\begin{example}
\begin{codeblock}
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0;           // error: pointer arithmetic requires integral operand
int *b = Y() + X();             // error: pointer arithmetic requires integral operand
\end{codeblock}
\end{example}

\pnum
The second operand of operator
\tcode{->}
is ignored in selecting an
\tcode{\keyword{operator}->}
function, and is not an argument when the
\tcode{\keyword{operator}->}
function is called.
When
\tcode{\keyword{operator}->}
returns, the operator
\tcode{->}
is applied to the value returned, with the original second
operand.
\begin{footnote}
If the value returned by the
\tcode{\keyword{operator}->}
function has class type, this can result in selecting and calling another
\tcode{\keyword{operator}->}
function.
The process repeats until an
\tcode{\keyword{operator}->}
function returns a value of non-class type.
\end{footnote}

\pnum
If the operator is the operator
\tcode{,},
the unary operator
\tcode{\&},
or the operator
\tcode{->},
and there are no viable functions, then the operator is
assumed to be the built-in operator and interpreted according to
\ref{expr.compound}.

\pnum
\begin{note}
The lookup rules for operators in expressions are different than
the lookup
rules for operator function names in a function call, as shown in the following
example:

\begin{codeblock}
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);              // error: global operator hidden by member
  a + a;                        // OK: calls global \tcode{\keyword{operator}+}
}
\end{codeblock}
\end{note}

\rSec3[over.match.ctor]{Initialization by constructor}%
\indextext{overloading!resolution!initialization}

\pnum
When objects of class type are direct-initialized\iref{dcl.init},
copy-initialized from an expression of the same or a
derived class type\iref{dcl.init},
or default-initialized\iref{dcl.init},
overload resolution selects the constructor.
For direct-initialization or default-initialization
that is not in the context of copy-initialization, the
candidate functions are
all the constructors of the class of the object being
initialized.
For copy-initialization (including default initialization
in the context of copy-initialization), the candidate functions are all
the converting constructors\iref{class.conv.ctor} of that
class.
The argument list is the
\grammarterm{expression-list} or \grammarterm{assignment-expression}
of the \grammarterm{initializer}.

\rSec3[over.match.copy]{Copy-initialization of class by user-defined conversion}%
\indextext{overloading!resolution!initialization}

\pnum
Under the conditions specified in~\ref{dcl.init}, as
part of a copy-initialization of an object of class type, a user-defined
conversion can be invoked to convert an initializer expression to the
type of the object being initialized.
Overload resolution is used
to select the user-defined conversion to be invoked.
\begin{note}
The conversion performed for indirect binding to a reference to a possibly
cv-qualified class type is determined in terms of a corresponding non-reference
copy-initialization.
\end{note}
Assuming that
``\cvqual{cv1} \tcode{T}'' is the type of the object being initialized, with
\tcode{T}
a class type,
the candidate functions are selected as follows:

\begin{itemize}
\item
The converting constructors\iref{class.conv.ctor} of
\tcode{T}
are candidate functions.
\item
When the type of the initializer expression is a class type
``\cv{}~\tcode{S}'',
conversion functions are considered.
The permissible types for non-explicit conversion functions are
\tcode{T} and any class derived from \tcode{T}.
When initializing a temporary object\iref{class.mem}
to be bound to the first parameter of a constructor
where the parameter is of type
``reference to \cvqual{cv2} \tcode{T}''
and the constructor is
called with a single argument in the context of
direct-initialization of an object of type ``\cvqual{cv3} \tcode{T}'',
the permissible types for explicit conversion functions are the same;
otherwise there are none.
\end{itemize}

\pnum
In both cases, the argument list has one argument, which is the initializer
expression.
\begin{note}
This argument will be compared against
the first parameter of the constructors and against the implicit
object parameter of the conversion functions.
\end{note}

\rSec3[over.match.conv]{Initialization by conversion function}%
\indextext{overloading!resolution!initialization}

\pnum
Under the conditions specified in~\ref{dcl.init}, as
part of an initialization of an object of non-class type,
a conversion function can be invoked to convert an initializer
expression of class type to the type of the object
being initialized.
Overload resolution is used to select the
conversion function to be invoked.
Assuming that ``\cv{} \tcode{T}'' is the
type of the object being initialized,
the candidate functions are selected as follows:

\begin{itemize}
\item
The permissible types for non-explicit conversion functions are
those that can be converted to type \tcode{T}
via a standard conversion sequence\iref{over.ics.scs}.
For direct-initialization,
the permissible types for explicit conversion functions are
those that can be converted to type \tcode{T}
with a (possibly trivial) qualification conversion\iref{conv.qual};
otherwise there are none.
\end{itemize}

\pnum
The argument list has one argument, which is the initializer expression.
\begin{note}
This argument will be compared against
the implicit object parameter of the conversion functions.
\end{note}

\rSec3[over.match.ref]{Initialization by conversion function for direct reference binding}%
\indextext{overloading!resolution!initialization}

\pnum
Under the conditions specified in~\ref{dcl.init.ref}, a reference can be bound directly
to the result of applying a conversion
function to an initializer expression.
Overload resolution is used to select the
conversion function to be invoked.
Assuming that ``reference to \cvqual{cv1} \tcode{T}'' is the
type of the reference being initialized,
the candidate functions are selected as follows:
\begin{itemize}
\item
Let $R$ be a set of types including
\begin{itemize}
\item
``lvalue reference to \cvqual{cv2} \tcode{T2}''
(when initializing an lvalue reference or an rvalue reference to function) and
\item
``\cvqual{cv2} \tcode{T2}''
and ``rvalue reference to \cvqual{cv2} \tcode{T2}'' (when initializing an
rvalue reference or an lvalue reference to function)
\end{itemize}
for any \tcode{T2}.
The permissible types for non-explicit conversion functions are
the members of $R$
where ``\cvqual{cv1} \tcode{T}'' is reference-compatible\iref{dcl.init.ref}
with ``\cvqual{cv2} \tcode{T2}''.
For direct-initialization, the permissible types for explicit
conversion functions are the members of $R$
where \tcode{T2} can be converted to type \tcode{T}
with a (possibly trivial) qualification conversion\iref{conv.qual};
otherwise there are none.
\end{itemize}

\pnum
The argument list has one argument, which is the initializer expression.
\begin{note}
This argument will be compared against
the implicit object parameter of the conversion functions.
\end{note}

\rSec3[over.match.list]{Initialization by list-initialization}%
\indextext{overloading!resolution!initialization}

\pnum
When objects of non-aggregate class type \tcode{T} are
list-initialized such that \ref{dcl.init.list} specifies that overload resolution
is performed according to the rules in this subclause
or when forming a list-initialization sequence according to \ref{over.ics.list},
overload resolution selects the constructor in two phases:

\begin{itemize}
\item
If the initializer list is not empty or \tcode{T} has no default constructor,
overload resolution is first performed
where the candidate functions are the initializer-list constructors\iref{dcl.init.list}
of the class \tcode{T} and
the argument list consists of the initializer list as a single argument.

\item
Otherwise, or if no viable initializer-list constructor is found,
overload resolution is
performed again, where the candidate functions are all the constructors of
the class \tcode{T} and
the argument list consists of the elements of the initializer list.
\end{itemize}

In copy-list-initialization, if an explicit constructor is
chosen, the initialization is ill-formed.
\begin{note}
This differs from other situations~(\ref{over.match.ctor}, \ref{over.match.copy}),
where only converting constructors are considered for copy-initialization.
This restriction only
applies if this initialization is part of the final result of overload
resolution.
\end{note}

\rSec3[over.match.class.deduct]{Class template argument deduction}%
\indextext{deduction!class template arguments}%

\pnum
When resolving a placeholder for a deduced class type\iref{dcl.type.class.deduct}
where the \grammarterm{template-name} names a primary class template \tcode{C},
a set of functions and function templates, called the guides of \tcode{C},
is formed comprising:
\begin{itemize}
\item
If \tcode{C} is defined,
for each constructor of \tcode{C},
a function template with the following properties:
\begin{itemize}
\item
The template parameters are the template parameters of \tcode{C}
followed
by the template parameters (including default template arguments) of the constructor,
if any.
\item
The types of the function parameters are those of the constructor.
\item
The return type is the class template specialization
designated by \tcode{C}
and template arguments
corresponding to the template parameters of \tcode{C}.
\end{itemize}

\item
If \tcode{C}
is not defined or does not declare any constructors,
an additional function template derived as above
from a hypothetical constructor \tcode{C()}.

\item
An additional function template derived as above
from a hypothetical constructor \tcode{C(C)},
called the \defn{copy deduction candidate}.

\item
For each \grammarterm{deduction-guide},
a function or function template
with the following properties:

\begin{itemize}
\item
The template parameters, if any,
and function parameters
are those of the \grammarterm{deduction-guide}.
\item
The return type
is the \grammarterm{simple-template-id}
of the \grammarterm{deduction-guide}.
\end{itemize}
\end{itemize}
In addition, if \tcode{C} is defined
and its definition satisfies the conditions for
an aggregate class\iref{dcl.init.aggr}
with the assumption that any dependent base class has
no virtual functions and no virtual base classes, and
the initializer is a non-empty \grammarterm{braced-init-list} or
parenthesized \grammarterm{expression-list}, and
there are no \grammarterm{deduction-guide}{s} for \tcode{C},
the set contains an additional function template,
called the \defnadj{aggregate deduction}{candidate}, defined as follows.
Let $x_1, \dotsc, x_n$ be the elements
of the \grammarterm{initializer-list} or
\grammarterm{designated-initializer-list}
of the \grammarterm{braced-init-list}, or
of the \grammarterm{expression-list}.
For each $x_i$, let $e_i$ be the corresponding aggregate element
of \tcode{C} or of one of its (possibly recursive) subaggregates
that would be initialized by $x_i$\iref{dcl.init.aggr} if
\begin{itemize}
\item
brace elision is not considered for any aggregate element
that has a dependent non-array type or
an array type with a value-dependent bound, and
\item
each non-trailing aggregate element that is a pack expansion
is assumed to correspond to no elements of the initializer list, and
\item
a trailing aggregate element that is a pack expansion is assumed to correspond
to all remaining elements of the initializer list (if any).
\end{itemize}
If there is no such aggregate element $e_i$ for any $x_i$,
the aggregate deduction candidate is not added to the set.
The aggregate deduction candidate is derived as above
from a hypothetical constructor $\tcode{C}(\tcode{T}_1, \dotsc, \tcode{T}_n)$,
where
\begin{itemize}
\item
if $e_i$ is of array type and
$x_i$ is a \grammarterm{braced-init-list} or \grammarterm{string-literal},
$\tcode{T}_i$ is an rvalue reference to the declared type of $e_i$, and
\item
otherwise, $\tcode{T}_i$ is the declared type of $e_i$,
\end{itemize}
except that additional parameter packs of the form $\tcode{P}_j \tcode{...}$
are inserted into the parameter list in their original aggregate element position corresponding to each non-trailing aggregate element of type $\tcode{P}_j$
that was skipped because it was a parameter pack, and
the trailing sequence of parameters corresponding
to a trailing aggregate element that is a pack expansion (if any)
is replaced by a single parameter of the form $\tcode{T}_n \tcode{...}$.

\pnum
When resolving a placeholder for a deduced class type\iref{dcl.type.simple}
where the \grammarterm{template-name} names an alias template \tcode{A},
the \grammarterm{defining-type-id} of \tcode{A} must be of the form
\begin{ncsimplebnf}
\opt{\keyword{typename}} \opt{nested-name-specifier} \opt{\keyword{template}} simple-template-id
\end{ncsimplebnf}
as specified in \ref{dcl.type.simple}.
The guides of \tcode{A} are the set of functions or function templates
formed as follows.
For each function or function template \tcode{f} in the guides of
the template named by the \grammarterm{simple-template-id}
of the \grammarterm{defining-type-id},
the template arguments of the return type of \tcode{f}
are deduced
from the \grammarterm{defining-type-id} of \tcode{A}
according to the process in \ref{temp.deduct.type}
with the exception that deduction does not fail
if not all template arguments are deduced.
Let \tcode{g} denote the result of substituting
these deductions into \tcode{f}.
If substitution succeeds,
form a function or function template \tcode{f'}
with the following properties and add it to the set
of guides of \tcode{A}:
\begin{itemize}
\item
The function type of \tcode{f'} is the function type of \tcode{g}.

\item
If \tcode{f} is a function template,
\tcode{f'} is a function template whose
template parameter list consists of
all the template parameters of \tcode{A}
(including their default template arguments)
that appear in the above deductions or
(recursively) in their default template arguments,
followed by the template parameters of \tcode{f} that were not deduced
(including their default template arguments),
otherwise \tcode{f'} is not a function template.

\item
The associated constraints\iref{temp.constr.decl} are
the conjunction of the associated constraints of \tcode{g} and
a constraint that is satisfied if and only if
the arguments of \tcode{A} are deducible (see below) from the return type.

\item
If \tcode{f} is a copy deduction candidate,
then \tcode{f'} is considered to be so as well.

\item
If \tcode{f} was generated
from a \grammarterm{deduction-guide}\iref{temp.deduct.guide},
then \tcode{f'} is considered to be so as well.

\item
The \grammarterm{explicit-specifier} of \tcode{f'} is
the \grammarterm{explicit-specifier} of \tcode{g} (if any).
\end{itemize}

\indextext{template!deducible arguments of}%
\pnum
The arguments of a template \tcode{A} are said to be
deducible from a type \tcode{T} if, given a class template
\begin{codeblock}
template <typename> class AA;
\end{codeblock}
with a single partial specialization
whose template parameter list is that of \tcode{A} and
whose template argument list is a specialization of \tcode{A}
with the template argument list of \tcode{A}\iref{temp.dep.type},
\tcode{AA<T>} matches the partial specialization.

\pnum
Initialization and overload resolution are performed as described
in \ref{dcl.init} and \ref{over.match.ctor}, \ref{over.match.copy},
or \ref{over.match.list} (as appropriate for the type of initialization
performed) for an object of a hypothetical class type, where
the guides of the template named by the placeholder are considered to be the
constructors of that class type for the purpose of forming an overload
set, and the initializer is provided by the context in which class
template argument deduction was performed.
The following exceptions apply:
\begin{itemize}
\item
The first phase in \ref{over.match.list}
(considering initializer-list constructors)
is omitted if the initializer list consists of
a single expression of type \cv{}~\tcode{U},
where \tcode{U} is, or is derived from,
a specialization of the class template
directly or indirectly named by the placeholder.
\item
During template argument deduction for the aggregate deduction candidate,
the number of elements in a trailing parameter pack
is only deduced from the number of remaining function arguments
if it is not otherwise deduced.
\end{itemize}
If the function or function template was generated from
a constructor or \grammarterm{deduction-guide}
that had an \grammarterm{explicit-specifier},
each such notional constructor is considered to have
that same \grammarterm{explicit-specifier}.
All such notional constructors are considered to be
public members of the hypothetical class type.

\pnum
\begin{example}
\begin{codeblock}
template <class T> struct A {
  explicit A(const T&, ...) noexcept;               // \#1
  A(T&&, ...);                                      // \#2
};

int i;
A a1 = { i, i };    // error: explicit constructor \#1 selected in copy-list-initialization during deduction,
                    // cannot deduce from non-forwarding rvalue reference in \#2

A a2{i, i};         // OK, \#1 deduces to \tcode{A<int>} and also initializes
A a3{0, i};         // OK, \#2 deduces to \tcode{A<int>} and also initializes
A a4 = {0, i};      // OK, \#2 deduces to \tcode{A<int>} and also initializes

template <class T> A(const T&, const T&) -> A<T&>;  // \#3
template <class T> explicit A(T&&, T&&) -> A<T>;    // \#4

A a5 = {0, 1};      // error: explicit deduction guide \#4 selected in copy-list-initialization during deduction
A a6{0,1};          // OK, \#4 deduces to \tcode{A<int>} and \#2 initializes
A a7 = {0, i};      // error: \#3 deduces to \tcode{A<int\&>}, \#1 and \#2 declare same constructor
A a8{0,i};          // error: \#3 deduces to \tcode{A<int\&>}, \#1 and \#2 declare same constructor

template <class T> struct B {
  template <class U> using TA = T;
  template <class U> B(U, TA<U>);
};

B b{(int*)0, (char*)0};         // OK, deduces \tcode{B<char*>}

template <typename T>
struct S {
  T x;
  T y;
};

template <typename T>
struct C {
  S<T> s;
  T t;
};

template <typename T>
struct D {
  S<int> s;
  T t;
};

C c1 = {1, 2};                  // error: deduction failed
C c2 = {1, 2, 3};               // error: deduction failed
C c3 = {{1u, 2u}, 3};           // OK, deduces \tcode{C<int>}

D d1 = {1, 2};                  // error: deduction failed
D d2 = {1, 2, 3};               // OK, braces elided, deduces \tcode{D<int>}

template <typename T>
struct E {
  T t;
  decltype(t) t2;
};

E e1 = {1, 2};                  // OK, deduces \tcode{E<int>}

template <typename... T>
struct Types {};

template <typename... T>
struct F : Types<T...>, T... {};

struct X {};
struct Y {};
struct Z {};
struct W { operator Y(); };

F f1 = {Types<X, Y, Z>{}, {}, {}};      // OK, \tcode{F<X, Y, Z>} deduced
F f2 = {Types<X, Y, Z>{}, X{}, Y{}};    // OK, \tcode{F<X, Y, Z>} deduced
F f3 = {Types<X, Y, Z>{}, X{}, W{}};    // error: conflicting types deduced; \tcode{operator Y} not considered
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
template <class T, class U> struct C {
  C(T, U);                                      // \#1
};
template<class T, class U>
  C(T, U) -> C<T, std::type_identity_t<U>>;     // \#2

template<class V> using A = C<V *, V *>;
template<std::@\libconcept{integral}@ W> using B = A<W>;

int i{};
double d{};
A a1(&i, &i);   // deduces \tcode{A<int>}
A a2(i, i);     // error: cannot deduce \tcode{V *} from \tcode{i}
A a3(&i, &d);   // error: \#1: cannot deduce \tcode{(V*, V*)} from \tcode{(int *, double *)}
                // \#2: cannot deduce \tcode{A<V>} from \tcode{C<int *, double *>}
B b1(&i, &i);   // deduces \tcode{B<int>}
B b2(&d, &d);   // error: cannot deduce \tcode{B<W>} from \tcode{C<double *, double *>}
\end{codeblock}
Possible exposition-only implementation of the above procedure:
\begin{codeblock}
// The following concept ensures a specialization of \tcode{A} is deduced.
template <class> class AA;
template <class V> class AA<A<V>> { };
template <class T> concept deduces_A = requires { sizeof(AA<T>); };

// \tcode{f1} is formed from the constructor \#1 of \tcode{C}, generating the following function template
template<T, U>
  auto f1(T, U) -> C<T, U>;

// Deducing arguments for \tcode{C<T, U>} from \tcode{C<V *, V*>} deduces \tcode{T} as \tcode{V *} and \tcode{U} as \tcode{V *};
// \tcode{f1'} is obtained by transforming \tcode{f1} as described by the above procedure.
template<class V> requires deduces_A<C<V *, V *>>
  auto f1_prime(V *, V*) -> C<V *, V *>;

// \tcode{f2} is formed from the deduction-guide \#2 of \tcode{C}
template<class T, class U> auto f2(T, U) -> C<T, std::type_identity_t<U>>;

// Deducing arguments for \tcode{C<T, std::type_identity_t<U>>} from \tcode{C<V *, V*>} deduces \tcode{T} as \tcode{V *};
// \tcode{f2'} is obtained by transforming \tcode{f2} as described by the above procedure.
template<class V, class U>
  requires deduces_A<C<V *, std::type_identity_t<U>>>
  auto f2_prime(V *, U) -> C<V *, std::type_identity_t<U>>;

// The following concept ensures a specialization of \tcode{B} is deduced.
template <class> class BB;
template <class V> class BB<B<V>> { };
template <class T> concept deduces_B = requires { sizeof(BB<T>); };

// The guides for \tcode{B} derived from the above \tcode{f1'} and \tcode{f2'} for \tcode{A} are as follows:
template<std::@\libconcept{integral}@ W>
  requires deduces_A<C<W *, W *>> && deduces_B<C<W *, W *>>
  auto f1_prime_for_B(W *, W *) -> C<W *, W *>;

template<std::@\libconcept{integral}@ W, class U>
  requires deduces_A<C<W *, std::type_identity_t<U>>> &&
    deduces_B<C<W *, std::type_identity_t<U>>>
  auto f2_prime_for_B(W *, U) -> C<W *, std::type_identity_t<U>>;
\end{codeblock}
\end{example}
\indextext{overloading!argument lists|)}%
\indextext{overloading!candidate functions|)}

\rSec2[over.match.viable]{Viable functions}%
\indextext{overloading!resolution!viable functions|(}

\pnum
From the set of candidate functions constructed for a given
context\iref{over.match.funcs}, a set of viable functions is
chosen, from which the best function will be selected by
comparing argument conversion sequences
and associated constraints\iref{temp.constr.decl}
for the best fit\iref{over.match.best}.
The selection of viable functions considers
associated constraints, if any, and
relationships between arguments and function parameters other
than the ranking of conversion sequences.

\pnum
\indextext{ellipsis!overload resolution and}%
\indextext{default argument!overload resolution and}%
First, to be a viable function, a candidate function shall have
enough parameters to agree in number with the arguments in the
list.

\begin{itemize}
\item
If there are $m$ arguments in the list,
all candidate functions having exactly $m$ parameters are viable.
\item
A candidate function having fewer than $m$ parameters is viable
only if it has an ellipsis in its parameter list\iref{dcl.fct}.
For the purposes of overload resolution,
any argument for which there is no corresponding parameter is
considered to ``match the ellipsis''\iref{over.ics.ellipsis}.
\item
A candidate function having more than $m$ parameters is viable
only if all parameters following the $m^\text{th}$
have default arguments\iref{dcl.fct.default}.
For the purposes of overload resolution,
the parameter list is truncated on the right,
so that there are exactly $m$ parameters.
\end{itemize}

\pnum
Second, for a function to be viable, if it has associated constraints\iref{temp.constr.decl},
those constraints shall be satisfied\iref{temp.constr.constr}.

\pnum
Third, for
\tcode{F}
to be a viable function, there shall exist for each
argument an
implicit conversion sequence\iref{over.best.ics} that
converts that argument to the corresponding parameter of
\tcode{F}.
If the parameter has reference type, the implicit conversion sequence
includes the operation of binding the reference, and the fact that
an lvalue reference to non-\keyword{const} cannot be bound to an rvalue
and that an rvalue reference cannot be bound to an lvalue
can affect
the viability of the function (see~\ref{over.ics.ref}).

\rSec2[over.match.best]{Best viable function}%

\rSec3[over.match.best.general]{General}%
\indextext{overloading!resolution!best viable function|(}

\pnum
\indextext{conversion!overload resolution and}%
Define $\text{ICS}^i(\tcode{F})$ as follows:
\begin{itemize}
\item
If \tcode{F} is a static member function,
$\text{ICS}^1(\tcode{F})$ is defined such that
$\text{ICS}^1(\tcode{F})$ is neither better nor worse than
$\text{ICS}^1(\tcode{G})$ for any function \tcode{G},
and, symmetrically, $\text{ICS}^1(\tcode{G})$ is neither better nor worse than
$\text{ICS}^1(\tcode{F})$;
\begin{footnote}
If a function is a static member function, this
definition means that the first argument, the implied object argument,
has no effect in the determination of whether the function is better
or worse than any other function.
\end{footnote}
otherwise,
\item
let $\text{ICS}^i(\tcode{F})$ denote the implicit conversion sequence that converts
the $i^\text{th}$ argument in the list to the type of
the $i^\text{th}$ parameter of viable function \tcode{F}.
\ref{over.best.ics} defines the implicit conversion sequences and \ref{over.ics.rank}
defines what it means for one implicit conversion sequence to be
a better conversion sequence or worse conversion sequence than
another.
\end{itemize}

\pnum
Given these definitions,
a viable function $\tcode{F}_1$ is defined to be a
\defnx{better}{overloading!resolution!better viable function}
function than another viable function $\tcode{F}_2$
if for all arguments $i$,
$\text{ICS}^i(\tcode{F}_1)$ is not a worse conversion
sequence than $\text{ICS}^i(\tcode{F}_2)$, and then
\begin{itemize}
\item
for some argument $j$,
$\text{ICS}^j(\tcode{F}_1)$ is a better conversion sequence than
$\text{ICS}^j(\tcode{F}_2)$, or, if not that,

\item
the context is an initialization by user-defined conversion
(see~\ref{dcl.init},
\ref{over.match.conv}, and~\ref{over.match.ref})
and the standard conversion sequence
from the return type of $\tcode{F}_1$ to the destination type
(i.e., the type of the entity being initialized)
is a better conversion sequence than the standard conversion sequence
from the return type of $\tcode{F}_2$ to the destination type
\begin{example}
\begin{codeblock}
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;          // \tcode{a.\keyword{operator} int()} followed by no conversion is better than
                    // \tcode{a.\keyword{operator} double()} followed by a conversion to \tcode{int}
float x = a;        // ambiguous: both possibilities require conversions,
                    // and neither is better than the other
\end{codeblock}
\end{example}
or, if not that,

\item the context is an initialization by conversion function for direct
reference binding\iref{over.match.ref} of a reference to function type, the
return type of \tcode{F1} is the same kind of reference (lvalue or rvalue)
as the reference being initialized, and the return type of \tcode{F2} is not
\begin{example}
\begin{codeblock}
template <class T> struct A {
  operator T&();    // \#1
  operator T&&();   // \#2
};
typedef int Fn();
A<Fn> a;
Fn& lf = a;         // calls \#1
Fn&& rf = a;        // calls \#2
\end{codeblock}
\end{example}
or, if not that,

\item
\tcode{F1}
is not a function template specialization and
\tcode{F2}
is a
function template
specialization, or, if not that,

\item
\tcode{F1}
and
\tcode{F2}
are
function template specializations,
and the function template
for
\tcode{F1}
is more specialized than the template for
\tcode{F2}
according to the partial ordering rules described in~\ref{temp.func.order},
or, if not that,

\item
\tcode{F1} and \tcode{F2} are non-template functions with the same
parameter-type-lists, and  \tcode{F1} is more constrained than \tcode{F2}
according to the partial ordering of constraints described in
\ref{temp.constr.order}, or if not that,

\item
\tcode{F1} is a constructor for a class \tcode{D},
\tcode{F2} is a constructor for a base class \tcode{B} of \tcode{D}, and
for all arguments
the corresponding parameters of \tcode{F1} and \tcode{F2} have the same type
\begin{example}
\begin{codeblock}
struct A {
  A(int = 0);
};

struct B: A {
  using A::A;
  B();
};

int main() {
  B b;              // OK, \tcode{B::B()}
}
\end{codeblock}
\end{example}
or, if not that,

\item
\tcode{F2} is a rewritten candidate\iref{over.match.oper} and
\tcode{F1} is not
\begin{example}
\begin{codeblock}
struct S {
  friend auto operator<=>(const S&, const S&) = default;        // \#1
  friend bool operator<(const S&, const S&);                    // \#2
};
bool b = S() < S();                                             // calls \#2
\end{codeblock}
\end{example}
or, if not that,

\item
\tcode{F1} and \tcode{F2} are rewritten candidates, and
\tcode{F2} is a synthesized candidate
with reversed order of parameters
and \tcode{F1} is not
\begin{example}
\begin{codeblock}
struct S {
  friend std::weak_ordering operator<=>(const S&, int);         // \#1
  friend std::weak_ordering operator<=>(int, const S&);         // \#2
};
bool b = 1 < S();                                               // calls \#2
\end{codeblock}
\end{example}
or, if not that

\item
\tcode{F1} is generated from a
\grammarterm{deduction-guide}\iref{over.match.class.deduct}
and \tcode{F2} is not, or, if not that,

\item
\tcode{F1} is the copy deduction candidate\iref{over.match.class.deduct}
and \tcode{F2} is not, or, if not that,

\item
\tcode{F1} is generated from a non-template constructor
and \tcode{F2} is generated from a constructor template.
\begin{example}
\begin{codeblock}
template <class T> struct A {
  using value_type = T;
  A(value_type);    // \#1
  A(const A&);      // \#2
  A(T, T, int);     // \#3
  template<class U>
    A(int, T, U);   // \#4
  // \#5 is the copy deduction candidate, \tcode{A(A)}
};

A x(1, 2, 3);       // uses \#3, generated from a non-template constructor

template <class T>
A(T) -> A<T>;       // \#6, less specialized than \#5

A a(42);            // uses \#6 to deduce \tcode{A<int>} and \#1 to initialize
A b = a;            // uses \#5 to deduce \tcode{A<int>} and \#2 to initialize

template <class T>
A(A<T>) -> A<A<T>>; // \#7, as specialized as \#5

A b2 = a;           // uses \#7 to deduce \tcode{A<A<int>>} and \#1 to initialize
\end{codeblock}
\end{example}
\end{itemize}

\pnum
If there is exactly one viable function that is a better function
than all other viable functions, then it is the one selected by
overload resolution; otherwise the call is ill-formed.
\begin{footnote}
The algorithm
for selecting the best viable function is linear in the number
of viable
functions.
Run a simple tournament to find a function
\tcode{W}
that is not
worse than any
opponent it faced.
Although it is possible that another function
\tcode{F}
that
\tcode{W}
did not face
is at least as good as
\tcode{W},
\tcode{F}
cannot be the best function because at some point in the
tournament
\tcode{F}
encountered another function
\tcode{G}
such that
\tcode{F}
was not better than
\tcode{G}.
Hence,
either \tcode{W} is
the best function or there is no best function.
So, make a second pass over
the viable
functions to verify that
\tcode{W}
is better than all other functions.
\end{footnote}
\begin{example}
\begin{codeblock}
void Fcn(const int*,  short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&i, s);       // is ambiguous because \tcode{\&i} $\to$ \tcode{int*} is better than \tcode{\&i} $\to$ \tcode{const int*}
                    // but \tcode{s} $\to$ \tcode{short} is also better than \tcode{s} $\to$ \tcode{int}

  Fcn(&i, 1L);      // calls \tcode{Fcn(int*, int)}, because \tcode{\&i} $\to$ \tcode{int*} is better than \tcode{\&i} $\to$ \tcode{const int*}
                    // and \tcode{1L} $\to$ \tcode{short} and \tcode{1L} $\to$ \tcode{int} are indistinguishable

  Fcn(&i, 'c');     // calls \tcode{Fcn(int*, int)}, because \tcode{\&i} $\to$ \tcode{int*} is better than \tcode{\&i} $\to$ \tcode{const int*}
                    // and \tcode{c} $\to$ \tcode{int} is better than \tcode{c} $\to$ \tcode{short}
}
\end{codeblock}
\end{example}

\pnum
If the best viable function resolves to a function
for which multiple declarations were found, and
if any two of these declarations inhabit different scopes and
specify a default argument that made the function viable,
the program is ill-formed.
\begin{example}
\begin{codeblock}
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3);             // OK, default argument was not used for viability
  f();              // error: found default argument twice
}
\end{codeblock}
\end{example}

\rSec3[over.best.ics]{Implicit conversion sequences}%

\rSec4[over.best.ics.general]{General}%
\indextext{overloading!resolution!implicit conversions and|(}
\indextext{implicit conversion sequence|see{conversion sequence, implicit}}

\pnum
An \defnadj{implicit}{conversion sequence}
is a sequence of conversions used
to convert an argument in a function call to the type of the
corresponding parameter of the function being called.
The
sequence of conversions is an implicit conversion as defined in
\ref{conv}, which means it is governed by the rules for
initialization of an object or reference by a single
expression~(\ref{dcl.init}, \ref{dcl.init.ref}).

\pnum
Implicit conversion sequences are concerned only with the type,
cv-qualification, and value category of the argument and how these
are converted to match the corresponding properties of the
parameter.
\begin{note}
Other properties, such as the lifetime, storage class,
alignment, accessibility of the argument, whether the argument is a bit-field,
and whether a function is deleted\iref{dcl.fct.def.delete}, are ignored.
So, although an implicit
conversion sequence can be defined for a given argument-parameter
pair, the conversion from the argument to the parameter might still
be ill-formed in the final analysis.
\end{note}

\pnum
A
well-formed implicit conversion
sequence is one of the following forms:
\begin{itemize}
\item
a standard conversion sequence\iref{over.ics.scs},
\item
a user-defined conversion sequence\iref{over.ics.user}, or
\item
an ellipsis conversion sequence\iref{over.ics.ellipsis}.
\end{itemize}

\pnum
However, if the target is
\begin{itemize}
\item the first parameter of a constructor or
\item the implicit object parameter of a user-defined conversion function
\end{itemize}
and the constructor or user-defined conversion function is a candidate by
\begin{itemize}
\item \ref{over.match.ctor}, when the argument is the temporary in the second
step of a class copy-initialization,
\item \ref{over.match.copy}, \ref{over.match.conv}, or \ref{over.match.ref}
(in all cases), or
\item the second phase of \ref{over.match.list}
when the initializer list has exactly one element that
is itself an initializer list, and
the target is the first parameter of a constructor of class \tcode{X}, and
the conversion is to \tcode{X} or reference to \cv{}~\tcode{X},
\end{itemize}
user-defined conversion sequences are not considered.
\begin{note}
These rules prevent more than one user-defined conversion from being
applied during overload resolution, thereby avoiding infinite recursion.
\end{note}
\begin{example}
\begin{codeblock}
struct Y { Y(int); };
struct A { operator int(); };
Y y1 = A();         // error: \tcode{A::\keyword{operator} int()} is not a candidate

struct X { X(); };
struct B { operator X(); };
B b;
X x{{b}};           // error: \tcode{B::\keyword{operator} X()} is not a candidate
\end{codeblock}
\end{example}

\pnum
For the case where the parameter type is a reference, see~\ref{over.ics.ref}.

\pnum
When the parameter type is not a reference, the implicit conversion
sequence models a copy-initialization of the parameter from the argument
expression.
The implicit conversion sequence is the one required to convert the
argument expression to a prvalue of the type of
the parameter.
\begin{note}
When the parameter has a class type, this is a conceptual conversion
defined for the purposes of \ref{over}; the actual initialization is
defined in terms of constructors and is not a conversion.
\end{note}
Any difference in top-level cv-qualification is
subsumed by the initialization itself and does not constitute a conversion.
\begin{example}
A parameter of type
\tcode{A}
can be initialized from an argument of type
\tcode{const A}.
The implicit conversion sequence for that case is the identity sequence; it
contains no ``conversion'' from
\tcode{const A}
to
\tcode{A}.
\end{example}
When the parameter has a class type and the argument expression has the
same type, the implicit conversion sequence is an identity conversion.
When the parameter has a class type and the argument expression has a
derived class type, the implicit conversion sequence is a
derived-to-base
\indextext{conversion!derived-to-base}%
conversion from the derived class to the base class.
\begin{note}
There is no such standard conversion; this derived-to-base conversion exists
only in the description of implicit conversion sequences.
\end{note}
A derived-to-base conversion has Conversion rank\iref{over.ics.scs}.

\pnum
In all contexts, when converting to the implicit object parameter
or when converting to the left operand of an assignment operation
only standard conversion sequences are allowed.

\pnum
If no conversions are required to match an argument to a
parameter type, the implicit conversion sequence is the standard
conversion sequence consisting of the identity conversion\iref{over.ics.scs}.

\pnum
If no sequence of conversions can be found to convert an argument
to a parameter type, an implicit conversion sequence cannot be formed.

\pnum
If there are multiple well-formed implicit conversion sequences
converting the argument to the parameter type, the implicit
conversion sequence associated with the parameter is defined to be
the unique conversion sequence designated the
\defnadj{ambiguous}{conversion sequence}.
For the purpose of ranking implicit conversion sequences as described
in~\ref{over.ics.rank}, the ambiguous conversion sequence is treated
as a user-defined conversion sequence that is indistinguishable from any
other user-defined conversion sequence.
\begin{note}
This rule prevents a function from becoming non-viable because of an ambiguous
conversion sequence for one of its parameters.
\begin{example}
\begin{codeblock}
class B;
class A { A (B&);};
class B { operator A (); };
class C { C (B&); };
void f(A) { }
void f(C) { }
B b;
f(b);               // error: ambiguous because there is a conversion \tcode{b} $\to$ \tcode{C} (via constructor)
                    // and an (ambiguous) conversion \tcode{b} $\to$ \tcode{A} (via constructor or conversion function)
void f(B) { }
f(b);               // OK, unambiguous
\end{codeblock}
\end{example}
\end{note}
If a function that uses the ambiguous conversion sequence is selected
as the best viable function, the call will be ill-formed because the conversion
of one of the arguments in the call is ambiguous.

\pnum
The three forms of implicit conversion sequences mentioned above
are defined in the following subclauses.

\rSec4[over.ics.scs]{Standard conversion sequences}

\pnum
\tref{over.ics.scs}
summarizes the conversions defined in \ref{conv} and
partitions them into four disjoint categories: Lvalue Transformation,
Qualification Adjustment, Promotion, and Conversion.
\begin{note}
These categories are orthogonal with respect to value category,
cv-qualification, and data representation: the Lvalue Transformations
do not change the cv-qualification or data
representation of the type; the Qualification Adjustments do not
change the value category or data representation of the type; and
the Promotions and Conversions do not change the
value category or cv-qualification of the type.
\end{note}

\pnum
\begin{note}
As described in \ref{conv},
a standard conversion sequence either is the Identity conversion
by itself (that is, no conversion) or consists of one to three
conversions from the other
four categories.
If there are two or more conversions in the sequence, the
conversions are applied in the canonical order:
\textbf{Lvalue Transformation},
\textbf{Promotion}
or
\textbf{Conversion},
\textbf{Qualification Adjustment}.
\end{note}

\pnum
\indextext{conversion rank}%
Each conversion in \tref{over.ics.scs}
also has an associated rank (Exact
Match, Promotion, or Conversion).
These are used
to rank standard conversion sequences\iref{over.ics.rank}.
The rank of a conversion sequence is determined by considering the
rank of each conversion in the sequence and the rank of any reference
binding\iref{over.ics.ref}.
If any of those has Conversion rank, the
sequence has Conversion rank; otherwise, if any of those has Promotion rank,
the sequence has Promotion rank; otherwise, the sequence has Exact
Match rank.

\begin{floattable}{Conversions}{over.ics.scs}{l|c|c|c}
\topline
\hdstyle{Conversion}            &   \hdstyle{Category}          &   \hdstyle{Rank}  &   \hdstyle{Subclause} \\ \capsep
No conversions required         &   Identity                    &                   &                       \\ \cline{1-2}\cline{4-4}
Lvalue-to-rvalue conversion     &                               &                   &   \ref{conv.lval}     \\ \cline{1-1}\cline{4-4}
Array-to-pointer conversion     &   Lvalue Transformation       &                   &   \ref{conv.array}    \\ \cline{1-1}\cline{4-4}
Function-to-pointer conversion  &                               &   \rb{Exact Match}&   \ref{conv.func}     \\ \cline{1-2}\cline{4-4}
Qualification conversions       &                               &                   &   \ref{conv.qual}     \\ \cline{1-1}\cline{4-4}
Function pointer conversion     & \rb{Qualification Adjustment} &                   &   \ref{conv.fctptr}   \\ \hline
Integral promotions             &                               &                   &   \ref{conv.prom}     \\ \cline{1-1}\cline{4-4}
Floating-point promotion        &   \rb{Promotion}              &   \rb{Promotion}  &   \ref{conv.fpprom}   \\ \hline
Integral conversions            &                               &                   &   \ref{conv.integral} \\ \cline{1-1}\cline{4-4}
Floating-point conversions      &                               &                   &   \ref{conv.double}   \\ \cline{1-1}\cline{4-4}
Floating-integral conversions   &                               &                   &   \ref{conv.fpint}    \\ \cline{1-1}\cline{4-4}
Pointer conversions             &   \rb{Conversion}             &   \rb{Conversion} &   \ref{conv.ptr}      \\ \cline{1-1}\cline{4-4}
Pointer-to-member conversions   &                               &                   &   \ref{conv.mem}      \\ \cline{1-1}\cline{4-4}
Boolean conversions             &                               &                   &   \ref{conv.bool}     \\
\end{floattable}

\rSec4[over.ics.user]{User-defined conversion sequences}

\pnum
A \defnadj{user-defined}{conversion sequence} consists of an initial
standard conversion sequence followed by a user-defined
conversion\iref{class.conv} followed by a second standard
conversion sequence.
If the user-defined conversion is specified
by a constructor\iref{class.conv.ctor}, the initial standard
conversion sequence converts the source type to the type of the
first parameter of that constructor.
If the user-defined
conversion is specified by a conversion function\iref{class.conv.fct}, the
initial standard conversion sequence
converts the source type to the type of the
implicit object parameter of that conversion function.

\pnum
The second standard conversion sequence converts the result of
the user-defined conversion to the target type for the sequence;
any reference binding is included in the second standard
conversion sequence.
Since an implicit conversion sequence is an initialization, the
special rules for initialization by user-defined conversion apply
when selecting the best user-defined conversion for a
user-defined conversion sequence (see~\ref{over.match.best} and~\ref{over.best.ics}).

\pnum
If the user-defined conversion is specified by a
specialization of a conversion function template,
the second standard conversion sequence shall have exact match rank.

\pnum
A conversion of an expression of class type
to the same class type is given Exact Match rank, and
a conversion of an expression of class type
to a base class of that type is given Conversion rank,
in spite of the
fact that a constructor (i.e., a user-defined conversion
function) is called for those cases.

\rSec4[over.ics.ellipsis]{Ellipsis conversion sequences}

\pnum
\indextext{ellipsis!conversion sequence}%
An ellipsis conversion sequence occurs when an argument in a
function call is matched with the ellipsis parameter
specification of the function called (see~\ref{expr.call}).

\rSec4[over.ics.ref]{Reference binding}

\pnum
When a parameter of reference type binds directly\iref{dcl.init.ref} to an
argument expression, the implicit conversion sequence is the identity conversion,
unless the argument expression has a type that is a derived class of the parameter
type, in which case the implicit conversion sequence is a derived-to-base
conversion\iref{over.best.ics}.
\begin{example}
\begin{codeblock}
struct A {};
struct B : public A {} b;
int f(A&);
int f(B&);
int i = f(b);       // calls \tcode{f(B\&)}, an exact match, rather than \tcode{f(A\&)}, a conversion
\end{codeblock}
\end{example}
If the parameter binds directly to the result of
applying a conversion function to the argument expression, the implicit
conversion sequence is a user-defined conversion sequence\iref{over.ics.user},
with the second standard conversion sequence either an identity conversion or,
if the conversion function returns an entity of a type that is a derived class
of the parameter type, a derived-to-base conversion.

\pnum
When a parameter of reference type is not bound directly to an argument
expression, the conversion sequence is the one required to convert the argument
expression to the referenced type according to~\ref{over.best.ics}.
Conceptually, this conversion sequence corresponds to copy-initializing a
temporary of the referenced type with the argument expression.
Any difference
in top-level cv-qualification is subsumed by the initialization itself and
does not constitute a conversion.

\pnum
Except for an implicit object parameter, for which see~\ref{over.match.funcs},
an implicit conversion sequence cannot be formed if it requires
binding an lvalue reference
other than a reference to a non-volatile \keyword{const} type
to an rvalue
or binding an rvalue reference to an lvalue other than a function lvalue.
\begin{note}
This means, for example, that a candidate function cannot be a viable
function if it has a non-\keyword{const} lvalue reference parameter (other than
the implicit object parameter) and the corresponding argument
would require a temporary to be created to initialize the lvalue
reference (see~\ref{dcl.init.ref}).
\end{note}

\pnum
Other restrictions on binding a reference to a particular argument
that are not based on the types of the reference and the argument
do not affect the formation of an implicit conversion
sequence, however.
\begin{example}
A function with an ``lvalue reference to \tcode{int}'' parameter can
be a viable candidate even if the corresponding argument is an
\tcode{int}
bit-field.
The formation of implicit conversion sequences
treats the
\tcode{int}
bit-field as an
\tcode{int}
lvalue and finds an exact
match with the parameter.
If the function is selected by overload
resolution, the call will nonetheless be ill-formed because of
the prohibition on binding a non-\keyword{const} lvalue reference to a bit-field\iref{dcl.init.ref}.
\end{example}

\rSec4[over.ics.list]{List-initialization sequence}

\pnum
When an argument is an initializer list\iref{dcl.init.list}, it is not an
expression and special rules apply for converting it to a parameter type.

\pnum
If the initializer list is a \grammarterm{designated-initializer-list},
a conversion is only possible if
the parameter has an aggregate type
that can be initialized from the initializer list
according to the rules for aggregate initialization\iref{dcl.init.aggr},
in which case the implicit conversion sequence is
a user-defined conversion sequence
whose second standard conversion sequence
is an identity conversion.
\begin{note}
Aggregate initialization does not require that
the members are declared in designation order.
If, after overload resolution, the order does not match
for the selected overload,
the initialization of the parameter will be ill-formed\iref{dcl.init.list}.
\begin{example}
\begin{codeblock}
struct A { int x, y; };
struct B { int y, x; };
void f(A a, int);               // \#1
void f(B b, ...);               // \#2
void g(A a);                    // \#3
void g(B b);                    // \#4
void h() {
  f({.x = 1, .y = 2}, 0);       // OK; calls \#1
  f({.y = 2, .x = 1}, 0);       // error: selects \#1, initialization of \tcode{a} fails
                                // due to non-matching member order\iref{dcl.init.list}
  g({.x = 1, .y = 2});          // error: ambiguous between \#3 and \#4
}
\end{codeblock}
\end{example}
\end{note}

\pnum
Otherwise,
if the parameter type is an aggregate class \tcode{X} and the initializer list has a
single element of type \cv{}~\tcode{U}, where \tcode{U} is \tcode{X}
or a class derived from \tcode{X}, the implicit conversion sequence is the one
required to convert the element to the parameter type.

\pnum
Otherwise, if the parameter type is a character array
\begin{footnote}
Since there are no parameters of array type,
this will only occur as the referenced type of a reference parameter.
\end{footnote}
and the initializer list has a single element that is an appropriately-typed
\grammarterm{string-literal}\iref{dcl.init.string}, the implicit conversion
sequence is the identity conversion.

\pnum
Otherwise, if the parameter type is \tcode{std::initializer_list<X>}
and all the elements
of the initializer list can be implicitly converted to \tcode{X}, the implicit
conversion sequence is the worst conversion necessary to convert an element of
the list to \tcode{X}, or if the initializer list has no elements, the identity
conversion. This conversion can be a user-defined conversion even in
the context of a call to an initializer-list constructor.
\begin{example}
\begin{codeblock}
void f(std::initializer_list<int>);
f( {} );                        // OK: \tcode{f(initializer_list<int>)} identity conversion
f( {1,2,3} );                   // OK: \tcode{f(initializer_list<int>)} identity conversion
f( {'a','b'} );                 // OK: \tcode{f(initializer_list<int>)} integral promotion
f( {1.0} );                     // error: narrowing

struct A {
  A(std::initializer_list<double>);             // \#1
  A(std::initializer_list<complex<double>>);    // \#2
  A(std::initializer_list<std::string>);        // \#3
};
A a{ 1.0,2.0 };                 // OK, uses \#1

void g(A);
g({ "foo", "bar" });            // OK, uses \#3

typedef int IA[3];
void h(const IA&);
h({ 1, 2, 3 });                 // OK: identity conversion
\end{codeblock}
\end{example}

\pnum
Otherwise, if the parameter type is ``array of \tcode{N} \tcode{X}''
or ``array of unknown bound of \tcode{X}'',
if there exists an implicit conversion sequence
from each element of the initializer list
(and from \tcode{\{\}} in the former case
if \tcode{N} exceeds the number of elements in the initializer list)
to \tcode{X}, the implicit conversion sequence is
the worst such implicit conversion sequence.

\pnum
Otherwise, if the parameter is a non-aggregate class \tcode{X} and overload
resolution per~\ref{over.match.list} chooses a single best constructor \tcode{C} of
\tcode{X} to perform the initialization of an object of type \tcode{X} from the
argument initializer list:
\begin{itemize}
\item
If \tcode{C} is not an initializer-list constructor
and the initializer list has a single element of type \cv{}~\tcode{U},
where \tcode{U} is \tcode{X} or a class derived from \tcode{X},
the implicit conversion sequence has Exact Match rank if \tcode{U} is \tcode{X},
or Conversion rank if \tcode{U} is derived from \tcode{X}.
\item
Otherwise, the implicit conversion sequence is a user-defined
conversion sequence with the second standard conversion sequence an
identity conversion.
\end{itemize}
If multiple constructors are viable but none is better than
the others, the implicit conversion sequence is the ambiguous conversion
sequence. User-defined conversions are allowed for conversion of the initializer
list elements to the constructor parameter types except as noted
in~\ref{over.best.ics}.
\begin{example}
\begin{codeblock}
struct A {
  A(std::initializer_list<int>);
};
void f(A);
f( {'a', 'b'} );        // OK: \tcode{f(A(std::initializer_list<int>))} user-defined conversion

struct B {
  B(int, double);
};
void g(B);
g( {'a', 'b'} );        // OK: \tcode{g(B(int, double))} user-defined conversion
g( {1.0, 1.0} );        // error: narrowing

void f(B);
f( {'a', 'b'} );        // error: ambiguous \tcode{f(A)} or \tcode{f(B)}

struct C {
  C(std::string);
};
void h(C);
h({"foo"});             // OK: \tcode{h(C(std::string("foo")))}

struct D {
  D(A, C);
};
void i(D);
i({ {1,2}, {"bar"} });  // OK: \tcode{i(D(A(std::initializer_list<int>\{1,2\}), C(std::string("bar"))))}
\end{codeblock}
\end{example}

\pnum
Otherwise, if the parameter has an aggregate type which can be initialized from
the initializer list according to the rules for aggregate
initialization\iref{dcl.init.aggr}, the implicit conversion sequence is a
user-defined conversion sequence with the second standard conversion
sequence an identity conversion.
\begin{example}
\begin{codeblock}
struct A {
  int m1;
  double m2;
};

void f(A);
f( {'a', 'b'} );        // OK: \tcode{f(A(int,double))} user-defined conversion
f( {1.0} );             // error: narrowing
\end{codeblock}
\end{example}

\pnum
Otherwise, if the parameter is a reference, see~\ref{over.ics.ref}.
\begin{note}
The rules in this subclause will apply for initializing the underlying temporary
for the reference.
\end{note}
\begin{example}
\begin{codeblock}
struct A {
  int m1;
  double m2;
};

void f(const A&);
f( {'a', 'b'} );        // OK: \tcode{f(A(int,double))} user-defined conversion
f( {1.0} );             // error: narrowing

void g(const double &);
g({1});                 // same conversion as \tcode{int} to \tcode{double}
\end{codeblock}
\end{example}

\pnum
Otherwise, if the parameter type is not a class:
\begin{itemize}
\item if the initializer list has one element that is not itself an initializer list,
the implicit conversion sequence is the one required to convert the element to
the parameter type;
\begin{example}
\begin{codeblock}
void f(int);
f( {'a'} );             // OK: same conversion as \tcode{char} to \tcode{int}
f( {1.0} );             // error: narrowing
\end{codeblock}
\end{example}

\item if the initializer list has no elements, the implicit conversion sequence
is the identity conversion.
\begin{example}
\begin{codeblock}
void f(int);
f( { } );               // OK: identity conversion
\end{codeblock}
\end{example}
\end{itemize}

\pnum
In all cases other than those enumerated above, no conversion is possible.

\rSec3[over.ics.rank]{Ranking implicit conversion sequences}

\pnum
This subclause defines a partial ordering of implicit conversion
sequences based on the relationships
\defnadj{better}{conversion sequence}
and
\defnadj{better}{conversion}.
If an implicit conversion sequence S1 is
defined by these rules to be a better conversion sequence than
S2, then it is also the case that S2 is a
\defnadj{worse}{conversion sequence}
than S1.
If conversion sequence S1 is neither better
than nor worse than conversion sequence S2, S1 and S2 are said to
be
\defnx{indistinguishable conversion sequences}{conversion sequence!indistinguishable}.

\pnum
When comparing the basic forms of implicit conversion sequences
(as defined in~\ref{over.best.ics})
\begin{itemize}
\item
a standard conversion sequence\iref{over.ics.scs} is a better
conversion sequence than a user-defined conversion sequence
or an ellipsis conversion sequence, and
\item
a user-defined conversion sequence\iref{over.ics.user} is a
better conversion sequence than an ellipsis conversion
sequence\iref{over.ics.ellipsis}.
\end{itemize}

\pnum
Two implicit conversion sequences of the same form are
indistinguishable conversion sequences unless one of the
following rules applies:

\begin{itemize}
\item
List-initialization sequence \tcode{L1} is a better conversion sequence than
list-initialization sequence \tcode{L2} if
\begin{itemize}
\item
\tcode{L1} converts to \tcode{std::initializer_list<X>} for some \tcode{X} and
\tcode{L2} does not, or, if not that,

\item
\tcode{L1} and \tcode{L2} convert to arrays of the same element type, and
either the number of elements $n_1$ initialized by \tcode{L1}
is less than the number of elements $n_2$ initialized by \tcode{L2}, or
$n_1 = n_2$ and
\tcode{L2} converts to an array of unknown bound and \tcode{L1} does not,
\end{itemize}
even if one of the other rules in this paragraph would otherwise apply.
\begin{example}
\begin{codeblock}
void f1(int);                                   // \#1
void f1(std::initializer_list<long>);           // \#2
void g1() { f1({42}); }                         // chooses \#2

void f2(std::pair<const char*, const char*>);   // \#3
void f2(std::initializer_list<std::string>);    // \#4
void g2() { f2({"foo","bar"}); }                // chooses \#4
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
void f(int    (&&)[] );         // \#1
void f(double (&&)[] );         // \#2
void f(int    (&&)[2]);         // \#3

f( {1} );           // Calls \#1: Better than \#2 due to conversion, better than \#3 due to bounds
f( {1.0} );         // Calls \#2: Identity conversion is better than floating-integral conversion
f( {1.0, 2.0} );    // Calls \#2: Identity conversion is better than floating-integral conversion
f( {1, 2} );        // Calls \#3: Converting to array of known bound is better than to unknown bound,
                    // and an identity conversion is better than floating-integral conversion
\end{codeblock}
\end{example}

\item
Standard conversion sequence
\tcode{S1}
is a better conversion
sequence than standard conversion sequence
\tcode{S2}
if
\begin{itemize}
\item
\indextext{subsequence rule!overloading}%
\tcode{S1}
is a proper subsequence of
\tcode{S2}
(comparing the conversion sequences in the canonical form defined
by~\ref{over.ics.scs}, excluding any Lvalue Transformation;
the identity conversion sequence is considered to be a
subsequence of any non-identity conversion sequence)
or, if not that,
\item
the rank of
\tcode{S1}
is better than the rank of
\tcode{S2},
or
\tcode{S1}
and
\tcode{S2}
have the same rank and are distinguishable by the rules
in the paragraph below,
or, if not that,

\item \tcode{S1} and \tcode{S2} include reference bindings\iref{dcl.init.ref} and
neither refers to an implicit object parameter of a non-static member function
declared without a \grammarterm{ref-qualifier},
and \tcode{S1} binds an rvalue reference to an
rvalue and \tcode{S2} binds an lvalue reference
\begin{example}
\begin{codeblock}
int i;
int f1();
int&& f2();
int g(const int&);
int g(const int&&);
int j = g(i);                   // calls \tcode{g(const int\&)}
int k = g(f1());                // calls \tcode{g(const int\&\&)}
int l = g(f2());                // calls \tcode{g(const int\&\&)}

struct A {
  A& operator<<(int);
  void p() &;
  void p() &&;
};
A& operator<<(A&&, char);
A() << 1;                       // calls \tcode{A::\keyword{operator}<<(int)}
A() << 'c';                     // calls \tcode{\keyword{operator}<<(A\&\&, char)}
A a;
a << 1;                         // calls \tcode{A::\keyword{operator}<<(int)}
a << 'c';                       // calls \tcode{A::\keyword{operator}<<(int)}
A().p();                        // calls \tcode{A::p()\&\&}
a.p();                          // calls \tcode{A::p()\&}
\end{codeblock}
\end{example}
or, if not that,

\item
\tcode{S1} and \tcode{S2} include reference bindings\iref{dcl.init.ref} and
\tcode{S1} binds an lvalue reference to a function lvalue and \tcode{S2} binds
an rvalue reference to a function lvalue
\begin{example}
\begin{codeblock}
int f(void(&)());               // \#1
int f(void(&&)());              // \#2
void g();
int i1 = f(g);                  // calls \#1
\end{codeblock}
\end{example}
or, if not that,

\item
\tcode{S1} and \tcode{S2} differ only
in their qualification conversion\iref{conv.qual} and
yield similar types \tcode{T1} and \tcode{T2}, respectively,
where \tcode{T1} can be converted to \tcode{T2} by a qualification conversion.
\begin{example}
\begin{codeblock}
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&i);                  // calls \tcode{f(const int*)}
\end{codeblock}
\end{example}
or, if not that,
\item
\tcode{S1}
and
\tcode{S2}
include reference bindings\iref{dcl.init.ref}, and the types to which the references
refer are the same type except for top-level cv-qualifiers, and the type to
which the reference initialized by
\tcode{S2}
refers is more cv-qualified than the type to which the reference initialized by
\tcode{S1}
refers.
\begin{example}
\begin{codeblock}
int f(const int &);
int f(int &);
int g(const int &);
int g(int);

int i;
int j = f(i);                   // calls \tcode{f(int \&)}
int k = g(i);                   // ambiguous

struct X {
  void f() const;
  void f();
};
void g(const X& a, X b) {
  a.f();                        // calls \tcode{X::f() const}
  b.f();                        // calls \tcode{X::f()}
}
\end{codeblock}
\end{example}
\end{itemize}

\item
User-defined conversion sequence
\tcode{U1}
is a better conversion sequence than another user-defined conversion
sequence
\tcode{U2}
if they contain the same user-defined conversion function or
constructor or they initialize the same class in an aggregate
initialization and in either case the second standard conversion
sequence of
\tcode{U1}
is better than
the second standard conversion sequence of
\tcode{U2}.
\begin{example}
\begin{codeblock}
struct A {
  operator short();
} a;
int f(int);
int f(float);
int i = f(a);                   // calls \tcode{f(int)}, because \tcode{short} $\to$ \tcode{int} is
                                // better than \tcode{short} $\to$ \tcode{float}.
\end{codeblock}
\end{example}

\end{itemize}

\pnum
Standard conversion sequences are ordered by their ranks: an Exact Match is a
better conversion than a Promotion, which is a better conversion than
a Conversion.
Two conversion sequences with the same rank are indistinguishable unless
one of the following rules applies:

\begin{itemize}
\item
A conversion that does not convert a pointer or a pointer to member
to
\tcode{bool}
is better than one that does.

\item
A conversion that promotes an enumeration whose underlying type is fixed to its underlying
type is better than one that promotes to the promoted underlying type, if the two are
different.

\item
If class
\tcode{B}
is derived directly or indirectly from class
\tcode{A},
conversion of
\tcode{B*}
to
\tcode{A*}
is better than conversion of
\tcode{B*}
to
\tcode{\keyword{void}*},
and conversion of
\tcode{A*}
to
\tcode{\keyword{void}*}
is better than conversion
of
\tcode{B*}
to
\tcode{\keyword{void}*}.
\item
If class
\tcode{B}
is derived directly or indirectly from class
\tcode{A}
and class
\tcode{C}
is derived directly or indirectly from
\tcode{B},
\begin{itemize}
\item
conversion of
\tcode{C*}
to
\tcode{B*}
is better than conversion of
\tcode{C*}
to
\tcode{A*},
\begin{example}
\begin{codeblock}
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);                  // calls \tcode{f(B*)}
\end{codeblock}
\end{example}

\item
binding of an expression of type
\tcode{C}
to a reference to type
\tcode{B}
is better than binding an expression of type
\tcode{C}
to a reference to type
\tcode{A},
\item
conversion of
\tcode{A::*}
to
\tcode{B::*}
is better than conversion of
\tcode{A::*}
to
\tcode{C::*},
\item
conversion of
\tcode{C}
to
\tcode{B}
is better than conversion of
\tcode{C}
to
\tcode{A},
\item
conversion of
\tcode{B*}
to
\tcode{A*}
is better than conversion of
\tcode{C*}
to
\tcode{A*},
\item
binding of an expression of type
\tcode{B}
to a reference to type
\tcode{A}
is better than binding an expression of type
\tcode{C}
to a
reference to type
\tcode{A},
\item
conversion of
\tcode{B::*}
to
\tcode{C::*}
is better than conversion
of
\tcode{A::*}
to
\tcode{C::*},
and
\item
conversion of
\tcode{B}
to
\tcode{A}
is better than conversion of
\tcode{C}
to
\tcode{A}.
\end{itemize}

\begin{note}
Compared conversion sequences will have different source types only in the
context of comparing the second standard conversion sequence of an
initialization by user-defined conversion (see~\ref{over.match.best}); in
all other contexts, the source types will be the same and the target
types will be different.
\end{note}
\end{itemize}%
\indextext{overloading!resolution!implicit conversions and|)}%
\indextext{overloading!resolution|)}

\rSec1[over.over]{Address of an overload set}%
\indextext{overloading!address of overloaded function}%
\indextext{overloaded function!address of}

\pnum
An \grammarterm{id-expression}
whose terminal name refers to an overload set $S$ and
that appears without arguments
is resolved to
a function,
a pointer to function, or
a pointer to member function
for a specific function
that is chosen from a set of functions selected from $S$
determined based on the target type required in the context (if any),
as described below.
The target can be
\begin{itemize}
\item
an object or reference being initialized~(\ref{dcl.init}, \ref{dcl.init.ref},
\ref{dcl.init.list}),
\item
the left side of an assignment\iref{expr.ass},
\item
a parameter of a function\iref{expr.call},
\item
a parameter of a user-defined operator\iref{over.oper},
\item
the return value of a function, operator function, or conversion\iref{stmt.return},
\item
an explicit type conversion~(\ref{expr.type.conv}, \ref{expr.static.cast},
\ref{expr.cast}), or
\item
a non-type
\grammarterm{template-parameter}\iref{temp.arg.nontype}.
\end{itemize}
The \grammarterm{id-expression} can be preceded by the \tcode{\&} operator.
\begin{note}
Any redundant set of parentheses surrounding the function name is
ignored\iref{expr.prim.paren}.
\end{note}

\pnum
If there is no target, all non-template functions named are selected.
Otherwise, a non-template function with type \tcode{F}
is selected for the function type \tcode{FT} of the target type
if \tcode{F}
(after possibly applying the function pointer conversion\iref{conv.fctptr})
is identical to \tcode{FT}.
\begin{note}
That is, the class of which the function is a member is ignored when matching a
pointer-to-member-function type.
\end{note}

\pnum
The specialization, if any, generated by template argument deduction
(\ref{temp.over}, \ref{temp.deduct.funcaddr}, \ref{temp.arg.explicit})
for each function template named
is added to the set of selected functions considered.

\pnum
Non-member functions and static member functions
match targets of function pointer type or
reference to function type.
Non-static member functions match targets of
pointer-to-member-function type.
\begin{note}
%% FIXME: Should this only apply after the eliminations in the next paragraph?
If a non-static member function is chosen,
the result can be used only to form a pointer to member\iref{expr.unary.op}.
\end{note}

\pnum
All functions with
associated constraints
that are not satisfied\iref{temp.constr.decl}
are eliminated from the set of selected functions.
If more than one function in the set remains,
all function template specializations
in the set
are eliminated if the set also contains a function that is not a
function template specialization.
Any given non-template function
\tcode{F0}
is eliminated if the set contains a second
non-template function that
is more constrained than
\tcode{F0}
according to
the partial ordering rules of \ref{temp.constr.order}.
Any given
function template specialization
\tcode{F1}
is eliminated if the set contains a second
function template specialization whose function template
is more specialized than the
function template of
\tcode{F1}
according to
the partial ordering rules of~\ref{temp.func.order}.
After such eliminations,
if any, there shall remain exactly one selected function.

\pnum
\begin{example}
\begin{codeblock}
int f(double);
int f(int);
int (*pfd)(double) = &f;        // selects \tcode{f(double)}
int (*pfi)(int) = &f;           // selects \tcode{f(int)}
int (*pfe)(...) = &f;           // error: type mismatch
int (&rfi)(int) = f;            // selects \tcode{f(int)}
int (&rfd)(double) = f;         // selects \tcode{f(double)}
void g() {
  (int (*)(int))&f;             // cast expression as selector
}
\end{codeblock}

The initialization of
\tcode{pfe}
is ill-formed because no
\tcode{f()}
with type
\tcode{int(...)}
has been declared, and not because of any ambiguity.
For another example,

\begin{codeblock}
struct X {
  int f(int);
  static int f(long);
};

int (X::*p1)(int)  = &X::f;     // OK
int    (*p2)(int)  = &X::f;     // error: mismatch
int    (*p3)(long) = &X::f;     // OK
int (X::*p4)(long) = &X::f;     // error: mismatch
int (X::*p5)(int)  = &(X::f);   // error: wrong syntax for
                                // pointer to member
int    (*p6)(long) = &(X::f);   // OK
\end{codeblock}
\end{example}

\pnum
\begin{note}
If \tcode{f} and \tcode{g} are both overload sets,
the Cartesian product of possibilities is considered
to resolve \tcode{f(\&g)}, or the equivalent expression \tcode{f(g)}.
\end{note}

\pnum
\indextext{conversion!overload resolution and pointer}%
\begin{note}
Even if \tcode{B} is a public base of \tcode{D},
we have
\begin{codeblock}
D* f();
B* (*p1)() = &f;                // error

void g(D*);
void (*p2)(B*) = &g;            // error
\end{codeblock}
\end{note}

\rSec1[over.oper]{Overloaded operators}%

\rSec2[over.oper.general]{General}%
\indextext{overloading!operator|(}%
\indextext{overloaded operator|see{overloading, operator}}%
\indextext{operator overloading|see{overloading, operator}}

\pnum
\indextext{operator!overloaded}%
A declaration
whose \grammarterm{declarator-id} is an \grammarterm{operator-function-id}
shall declare a function or function template or
an explicit instantiation or specialization of a function template.
A function so declared is an \defnadj{operator}{function}.
A function template so declared is
an \defnx{operator function template}{function!operator!template}.
A specialization of an operator function template is also an operator function.
An operator function is said to
\defnx{implement}{operator!implementation}
the operator named in its
\grammarterm{operator-function-id}.

\begin{bnf}
\nontermdef{operator-function-id}\br
    \keyword{operator} operator
\end{bnf}

\begin{bnf}
%% Ed. note: character protrusion would misalign various operators.
\microtypesetup{protrusion=false}\obeyspaces
\nontermdef{operator} \textnormal{one of}\br
    \terminal{new      delete   new[]    delete[] co_await (\rlap{\,)}        [\rlap{\,]}        ->       ->*}\br
    \terminal{\~        !        +        -        *        /        \%        \caret{}        \&}\br
    \terminal{|        =        +=       -=       *=       /=       \%=       \caret{}=       \&=}\br
    \terminal{|=       ==       !=       <        >        <=       >=       <=>      \&\&}\br
    \terminal{||       <<       >>       <<=      >>=      ++       --       ,}\br
\end{bnf}
\begin{note}
The operators
\tcode{new[]},
\tcode{delete[]},
\tcode{()},
and
\tcode{[]}
are formed from more than one token.
The latter two operators are function call\iref{expr.call}
and subscripting\iref{expr.sub}.
\end{note}
\indextext{operator!subscripting}%
\indextext{operator!function call}%

\pnum
Both the unary and binary forms of
\begin{ncsimplebnf}\obeyspaces
\terminal{+      -      *      \&}
\end{ncsimplebnf}
can be overloaded.

\pnum
\begin{note}
\indextext{restriction!operator overloading}%
The following operators cannot be overloaded:
\begin{ncsimplebnf}\obeyspaces
\terminal{.      .*     ::     ?:}
\end{ncsimplebnf}
nor can the preprocessing symbols
\tcode{\#}\iref{cpp.stringize}
and
\tcode{\#\#}\iref{cpp.concat}.
\end{note}

\pnum
\indextext{call!operator function}%
Operator functions are usually not called directly; instead they are invoked
to evaluate the operators they implement~(\ref{over.unary} -- \ref{over.inc}).
They can be explicitly called, however, using the
\grammarterm{operator-function-id}
as the name of the function in the function call syntax\iref{expr.call}.
\begin{example}
\begin{codeblock}
complex z = a.operator+(b);     // \tcode{complex z = a+b;}
void* p = operator new(sizeof(int)*n);
\end{codeblock}
\end{example}

\pnum
The allocation and deallocation functions,
\keyword{operator} \keyword{new},
\keyword{operator} \tcode{\keyword{new}[]},
\keyword{operator} \keyword{delete}, and
\keyword{operator} \tcode{\keyword{delete}[]},
are described completely in~\ref{basic.stc.dynamic}.
The attributes and restrictions
found in the rest of \ref{over.oper} do not apply to them unless explicitly
stated in~\ref{basic.stc.dynamic}.

\pnum
The \tcode{co_await} operator is described completely in~\ref{expr.await}.
The attributes and restrictions
found in the rest of \ref{over.oper} do not apply to it unless explicitly
stated in~\ref{expr.await}.

\pnum
\indextext{restriction!overloading}%
An operator function
shall either be a non-static member function or be a non-member function that
has at least one parameter whose type is a class, a reference to a class, an
enumeration, or a reference to an enumeration.
It is not possible to change the precedence, grouping, or number of operands
of operators.
The meaning of
the operators \tcode{=}, (unary) \tcode{\&}, and \tcode{,} (comma),
predefined for each type, can be changed for specific class types by
defining operator functions that implement these operators.
Likewise, the meaning of the operators (unary) \tcode{\&} and \tcode{,} (comma)
can be changed for specific enumeration types.
\indextext{overloaded operator!inheritance of}%
Operator functions are inherited in the same manner as other base class
functions.

\pnum
An operator function shall be a
prefix unary, binary, function call, subscripting, class member access, increment, or decrement
operator function.

\pnum
\indextext{operator}%
\begin{note}
The identities among certain predefined operators applied to basic types
(for example,
\tcode{++a} $\equiv$
\tcode{a+=1})
need not hold for operator functions.
Some predefined operators, such as
\tcode{+=},
require an operand to be an lvalue when applied to basic types;
this is not required by operator functions.
\end{note}

\pnum
\indextext{argument!overloaded operator and default}%
An operator function cannot have default arguments\iref{dcl.fct.default},
except where explicitly stated below.
Operator
functions cannot have more or fewer parameters than the
number required for the corresponding operator, as
described in the rest of \ref{over.oper}.

\pnum
Operators not mentioned explicitly in subclauses~\ref{over.ass} through~\ref{over.inc}
act as ordinary unary and binary
operators obeying the rules of~\ref{over.unary} or~\ref{over.binary}.%
\indextext{overloading!resolution!best viable function|)}%
\indextext{overloading!resolution!viable functions|)}

\rSec2[over.unary]{Unary operators}%
\indextext{unary operator!overloaded}%
\indextext{overloading!unary operator}

\pnum
A \defnadj{prefix unary}{operator function}
is a function named \tcode{\keyword{operator}@}
for a prefix \grammarterm{unary-operator} \tcode{@}\iref{expr.unary.op}
that is either
a non-static member function\iref{class.mfct} with no parameters or
a non-member function with one parameter.
\indextext{unary operator!interpretation of}%
For a \grammarterm{unary-expression}
of the form \tcode{@ \grammarterm{cast-expression}},
the operator function is selected by overload resolution\iref{over.match.oper}.
If a member function is selected,
the expression is interpreted as
\begin{ncsimplebnf}
cast-expression \terminal{.} \keyword{operator} \terminal{@} \terminal{(}\terminal{)}
\end{ncsimplebnf}
Otherwise, if a non-member function is selected,
the expression is interpreted as
\begin{ncsimplebnf}
\keyword{operator} \terminal{@} \terminal{(} cast-expression \terminal{)}
\end{ncsimplebnf}
\begin{note}
The operators \tcode{++} and \tcode{--}\iref{expr.pre.incr}
are described in~\ref{over.inc}.
\end{note}

\pnum
\begin{note}
The unary and binary forms of the same operator have the same name.
Consequently, a unary operator can hide a binary
operator from an enclosing scope, and vice versa.
\end{note}

\rSec2[over.binary]{Binary operators}%

\rSec3[over.binary.general]{General}%
\indextext{binary operator!overloaded}%
\indextext{overloading!binary operator}

\pnum
A \defnadj{binary}{operator function}
is a function named \tcode{\keyword{operator}@}
for a binary operator \tcode{@} that is either
a non-static member function\iref{class.mfct} with one parameter or
a non-member function with two parameters.
\indextext{binary operator!interpretation of}%
For an expression \tcode{$x$ @ $y$} with subexpressions $x$ and $y$,
the operator function is selected by overload resolution\iref{over.match.oper}.
If a member function is selected,
the expression is interpreted as
\begin{ncsimplebnf}
$x$ \terminal{.} \keyword{operator} \terminal{@} \terminal{(} $y$ \terminal{)}
\end{ncsimplebnf}
Otherwise, if a non-member function is selected,
the expression is interpreted as
\begin{ncsimplebnf}
\keyword{operator} \terminal{@} \terminal{(} $x$ \terminal{,} $y$ \terminal{)}
\end{ncsimplebnf}

\pnum
An \defnadj{equality}{operator function} is an operator function
for an equality operator\iref{expr.eq}.
A \defnadj{relational}{operator function} is an operator function
for a relational operator\iref{expr.rel}.
A \defnadj{three-way comparison}{operator function} is an operator function
for the three-way comparison operator\iref{expr.spaceship}.
A \defnadj{comparison}{operator function} is
an equality operator function,
a relational operator function, or
a three-way comparison operator function.

\rSec3[over.ass]{Simple assignment}
\indextext{assignment operator!overloaded}%
\indextext{overloading!assignment operator}

\pnum
A \defnadj{simple assignment}{operator function}
is a binary operator function named \tcode{\keyword{operator}=}.
A simple assignment operator function shall be a non-static member function.
\begin{note}
Because only standard conversion sequences are considered when converting
to the left operand of an assignment operation\iref{over.best.ics},
an expression \tcode{$x$ = $y$} with a subexpression $x$ of class type
is always interpreted as \tcode{$x$.\keyword{operator}=($y$)}.
\end{note}

\pnum
\begin{note}
Since a copy assignment operator is implicitly declared for a class
if not declared by the user\iref{class.copy.assign},
a base class assignment operator function is always hidden by
the copy assignment operator function of the derived class.
\end{note}

\pnum
\begin{note}
Any assignment operator function, even the copy and move assignment operators,
can be virtual.
For a derived class \tcode{D} with a base class \tcode{B}
for which a virtual copy/move assignment has been declared,
the copy/move assignment operator in \tcode{D} does not override
\tcode{B}'s virtual copy/move assignment operator.
\begin{example}
\begin{codeblock}
struct B {
  virtual int operator= (int);
  virtual B& operator= (const B&);
};
struct D : B {
  virtual int operator= (int);
  virtual D& operator= (const B&);
};

D dobj1;
D dobj2;
B* bptr = &dobj1;
void f() {
  bptr->operator=(99);          // calls \tcode{D::\keyword{operator}=(int)}
  *bptr = 99;                   // ditto
  bptr->operator=(dobj2);       // calls \tcode{D::\keyword{operator}=(const B\&)}
  *bptr = dobj2;                // ditto
  dobj1 = dobj2;                // calls implicitly-declared \tcode{D::\keyword{operator}=(const D\&)}
}
\end{codeblock}
\end{example}
\end{note}

\rSec2[over.call]{Function call}%
\indextext{function call operator!overloaded}%
\indextext{overloading!function call operator}

\pnum
A \defnadj{function call}{operator function}
is a function named \tcode{\keyword{operator}()}
that is a non-static member function with an arbitrary number of parameters.
It may have default arguments.
For an expression of the form
\begin{ncsimplebnf}
postfix-expression \terminal{(} \opt{expression-list} \terminal{)}
\end{ncsimplebnf}
where the \grammarterm{postfix-expression} is of class type,
the operator function
is selected by overload resolution\iref{over.call.object}.
If a surrogate call function for a conversion function
named \keyword{operator} \grammarterm{conversion-type-id} is selected,
the expression is interpreted as
\begin{ncsimplebnf}
postfix-expression \terminal{.} \keyword{operator} conversion-type-id \terminal{(}\terminal{)} \terminal{(} \opt{expression-list} \terminal{)}
\end{ncsimplebnf}
Otherwise, the expression is interpreted as
\begin{ncsimplebnf}
postfix-expression \terminal{.} \keyword{operator} \terminal{(}\terminal{)} \terminal{(} \opt{expression-list} \terminal{)}
\end{ncsimplebnf}

\rSec2[over.sub]{Subscripting}%
\indextext{subscripting operator!overloaded}%
\indextext{overloading!subscripting operator}

\pnum
A \defnadj{subscripting}{operator function}
is a function named \tcode{\keyword{operator}[]}
that is a non-static member function with exactly one parameter.
For an expression of the form
\begin{ncsimplebnf}
postfix-expression \terminal{[} expr-or-braced-init-list \terminal{]}
\end{ncsimplebnf}
the operator function
is selected by overload resolution\iref{over.match.oper}.
If a member function is selected,
the expression is interpreted as
\begin{ncsimplebnf}
postfix-expression . \keyword{operator} \terminal{[}\terminal{]} \terminal{(} expr-or-braced-init-list \terminal{)}
\end{ncsimplebnf}

\pnum
\begin{example}
\begin{codeblock}
struct X {
  Z operator[](std::initializer_list<int>);
};
X x;
x[{1,2,3}] = 7;                 // OK: meaning \tcode{x.\keyword{operator}[](\{1,2,3\})}
int a[10];
a[{1,2,3}] = 7;                 // error: built-in subscript operator
\end{codeblock}
\end{example}

\rSec2[over.ref]{Class member access}
\indextext{member access operator!overloaded}%
\indextext{overloading!member access operator}

\pnum
A \defnadj{class member access}{operator function}
is a function named \tcode{\keyword{operator}->}
that is a non-static member function taking no parameters.
For an expression of the form
\begin{ncsimplebnf}
postfix-expression \terminal{->} \opt{\keyword{template}} id-expression
\end{ncsimplebnf}
the operator function
is selected by overload resolution\iref{over.match.oper},
and the expression is interpreted as
\begin{ncsimplebnf}
\terminal{(} postfix-expression . \keyword{operator} \terminal{->} \terminal{(}\terminal{)} \terminal{)} \terminal{->} \opt{\keyword{template}} id-expression
\end{ncsimplebnf}

\rSec2[over.inc]{Increment and decrement}
\indextext{increment operator!overloaded|see{overloading, increment operator}}%
\indextext{decrement operator!overloaded|see{overloading, decrement operator}}%
\indextext{prefix ++ and -{-} overloading@prefix \tcode{++} and \tcode{--}!overloading}%
\indextext{postfix ++ and -{-} overloading@postfix \tcode{++} and \tcode{--}!overloading}%

\pnum
An \defnadj{increment}{operator function}
is a function named \tcode{\keyword{operator}++}.
If this function is a non-static member function with no parameters, or a non-member
function with one parameter,
it defines the prefix increment operator
\tcode{++}
for objects of that type.
If the function is a non-static member function with one parameter (which shall be of type
\tcode{int})
or a non-member function with two parameters (the second of which shall be of type
\tcode{int}),
it defines the postfix increment operator
\tcode{++}
for objects of that type.
When the postfix increment is called as a result of using the
\tcode{++}
operator, the
\tcode{int}
argument will have value zero.
\begin{footnote}
Calling
\tcode{\keyword{operator}++}
explicitly, as in expressions like
\tcode{a.\keyword{operator}++(2)},
has no special properties:
The argument to
\tcode{\keyword{operator}++}
is
\tcode{2}.
\end{footnote}
\begin{example}
\begin{codeblock}
struct X {
  X&   operator++();            // prefix \tcode{++a}
  X    operator++(int);         // postfix \tcode{a++}
};

struct Y { };
Y&   operator++(Y&);            // prefix \tcode{++b}
Y    operator++(Y&, int);       // postfix \tcode{b++}

void f(X a, Y b) {
  ++a;                          // \tcode{a.\keyword{operator}++();}
  a++;                          // \tcode{a.\keyword{operator}++(0);}
  ++b;                          // \tcode{\keyword{operator}++(b);}
  b++;                          // \tcode{\keyword{operator}++(b, 0);}

  a.operator++();               // explicit call: like \tcode{++a;}
  a.operator++(0);              // explicit call: like \tcode{a++;}
  operator++(b);                // explicit call: like \tcode{++b;}
  operator++(b, 0);             // explicit call: like \tcode{b++;}
}
\end{codeblock}
\end{example}

\pnum
A \defnadj{decrement}{operator function}
is a function named \tcode{\keyword{operator}--}
and is handled analogously to an increment operator function.
\indextext{overloading!operator|)}

\rSec1[over.built]{Built-in operators}%
\indextext{overloading!built-in operators and}

\pnum
The candidate operator functions that represent the built-in operators
defined in \ref{expr.compound} are specified in this subclause.
These candidate
functions participate in the operator overload resolution process as
described in~\ref{over.match.oper} and are used for no other purpose.
\begin{note}
Because built-in operators take only operands with non-class type,
and operator overload resolution occurs only when an operand expression
originally has class or enumeration type,
operator overload resolution can resolve to a built-in operator only
when an operand has a class type that has a user-defined conversion to
a non-class type appropriate for the operator, or when an operand has
an enumeration type that can be converted to a type appropriate
for the operator.
Also note that some of the candidate operator functions given in this subclause are
more permissive than the built-in operators themselves.
As
described in~\ref{over.match.oper}, after a built-in operator is selected
by overload resolution the expression is subject to the requirements for
the built-in operator given in \ref{expr.compound}, and therefore to any
additional semantic constraints given there.
In some cases, user-written candidates
with the same name and parameter types as a built-in
candidate operator function cause the built-in operator function
to not be included in the set of candidate functions.
\end{note}

\pnum
\indextext{type!integral!promoted}%
\indextext{type!arithmetic!promoted}%
In this subclause, the term
\defn{promoted integral type}
is used to refer to those cv-unqualified integral types which are preserved by
integral promotion\iref{conv.prom} (including e.g.
\tcode{int}
and
\tcode{long}
but excluding e.g.
\tcode{char}).
\begin{note}
In all cases where a promoted integral type is
required, an operand of unscoped enumeration type will be acceptable by way of the
integral promotions.
\end{note}

\pnum
In the remainder of this subclause, \cvqual{vq} represents either
\tcode{volatile} or no cv-qualifier.

\pnum
For every pair
(\tcode{\placeholder{T}},
\cvqual{vq}),
where
\tcode{\placeholder{T}}
is a cv-unqualified arithmetic type other than \tcode{bool}
or a cv-unqualified pointer to (possibly cv-qualified) object type,
there exist candidate operator functions of the form
\begin{codeblock}
@\cvqual{vq} \placeholder{T}@& operator++(@\cvqual{vq} \placeholder{T}@&);
@\placeholder{T}@ operator++(@\cvqual{vq} \placeholder{T}@&, int);
@\cvqual{vq} \placeholder{T}@& operator--(@\cvqual{vq} \placeholder{T}@&);
@\placeholder{T}@ operator--(@\cvqual{vq} \placeholder{T}@&, int);
\end{codeblock}

\pnum
For every (possibly cv-qualified) object type \tcode{\placeholder{T}} and
for every function type \tcode{\placeholder{T}}
that has neither \grammarterm{cv-qualifier}s nor a \grammarterm{ref-qualifier},
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@&    operator*(@\placeholder{T}@*);
\end{codeblock}

\pnum
For every type \tcode{\placeholder{T}} there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@*    operator+(@\placeholder{T}@*);
\end{codeblock}

\pnum
For every cv-unqualified floating-point or promoted integral type \tcode{\placeholder{T}},
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@ operator+(@\placeholder{T}@);
@\placeholder{T}@ operator-(@\placeholder{T}@);
\end{codeblock}

\pnum
For every promoted integral type
\tcode{\placeholder{T}},
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@ operator~(@\placeholder{T}@);
\end{codeblock}

\pnum
For every quintuple
(\tcode{\placeholder{C1}},
\tcode{\placeholder{C2}},
\tcode{\placeholder{T}},
\cvqual{cv1},
\cvqual{cv2}),
where
\tcode{\placeholder{C2}}
is a class type,
\tcode{\placeholder{C1}}
is the same type as \tcode{\placeholder{C2}} or is a derived class of \tcode{\placeholder{C2}}, and
\tcode{\placeholder{T}}
is an object type or a function type,
there exist candidate operator functions of the form
\begin{codeblock}
@\cvqual{cv12} \placeholder{T}@& operator->*(@\cvqual{cv1} \placeholder{C1}@*, @\cvqual{cv2} \placeholder{T C2}@::*);
\end{codeblock}
where \cvqual{cv12} is the union of \cvqual{cv1} and \cvqual{cv2}.
The return type is shown for exposition only; see~\ref{expr.mptr.oper} for the
determination of the operator's result type.

\pnum
For every pair of types \tcode{\placeholder{L}} and \tcode{\placeholder{R}},
where each of \tcode{\placeholder{L}} and \tcode{\placeholder{R}} is a
floating-point or promoted integral type,
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{LR}@      operator*(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator/(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator+(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator-(@\placeholder{L}@, @\placeholder{R}@);
bool    operator==(@\placeholder{L}@, @\placeholder{R}@);
bool    operator!=(@\placeholder{L}@, @\placeholder{R}@);
bool    operator<(@\placeholder{L}@, @\placeholder{R}@);
bool    operator>(@\placeholder{L}@, @\placeholder{R}@);
bool    operator<=(@\placeholder{L}@, @\placeholder{R}@);
bool    operator>=(@\placeholder{L}@, @\placeholder{R}@);
\end{codeblock}
where
\tcode{\placeholder{LR}}
is the result of the usual arithmetic conversions\iref{expr.arith.conv} between types
\tcode{\placeholder{L}}
and
\tcode{\placeholder{R}}.

\pnum
For every integral type \tcode{\placeholder{T}}
there exists a candidate operator function of the form
\begin{codeblock}
std::strong_ordering operator<=>(@\placeholder{T}@, @\placeholder{T}@);
\end{codeblock}

\pnum
For every pair of floating-point types
\tcode{\placeholder{L}} and \tcode{\placeholder{R}},
there exists a candidate operator function of the form
\begin{codeblock}
std::partial_ordering operator<=>(@\placeholder{L}@, @\placeholder{R}@);
\end{codeblock}

\pnum
For every cv-qualified or cv-unqualified object type
\tcode{\placeholder{T}}
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@*      operator+(@\placeholder{T}@*, std::ptrdiff_t);
@\placeholder{T}@&      operator[](@\placeholder{T}@*, std::ptrdiff_t);
@\placeholder{T}@*      operator-(@\placeholder{T}@*, std::ptrdiff_t);
@\placeholder{T}@*      operator+(std::ptrdiff_t, @\placeholder{T}@*);
@\placeholder{T}@&      operator[](std::ptrdiff_t, @\placeholder{T}@*);
\end{codeblock}

\pnum
For every
\tcode{\placeholder{T}},
where
\tcode{\placeholder{T}}
is a pointer to object type,
there exist candidate operator functions of the form
\begin{codeblock}
std::ptrdiff_t   operator-(@\placeholder{T}@, @\placeholder{T}@);
\end{codeblock}

\pnum
For every \tcode{\placeholder{T}}, where \tcode{\placeholder{T}} is an enumeration type or a pointer type,
there exist candidate operator functions of the form
\begin{codeblock}
bool    operator==(@\placeholder{T}@, @\placeholder{T}@);
bool    operator!=(@\placeholder{T}@, @\placeholder{T}@);
bool    operator<(@\placeholder{T}@, @\placeholder{T}@);
bool    operator>(@\placeholder{T}@, @\placeholder{T}@);
bool    operator<=(@\placeholder{T}@, @\placeholder{T}@);
bool    operator>=(@\placeholder{T}@, @\placeholder{T}@);
@\placeholdernc{R}@       operator<=>(@\placeholder{T}@, @\placeholder{T}@);
\end{codeblock}
where \tcode{\placeholder{R}} is the result type specified in \ref{expr.spaceship}.

\pnum
For every \tcode{\placeholder{T}}, where \tcode{\placeholder{T}}
is a pointer-to-member type or \tcode{std::nullptr_t},
there exist candidate operator functions of the form
\begin{codeblock}
bool operator==(@\placeholder{T}@, @\placeholder{T}@);
bool operator!=(@\placeholder{T}@, @\placeholder{T}@);
\end{codeblock}

\pnum
For every pair of promoted integral types
\tcode{\placeholder{L}}
and
\tcode{\placeholder{R}},
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{LR}@      operator%(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator&(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator^(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{LR}@      operator|(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{L}@       operator<<(@\placeholder{L}@, @\placeholder{R}@);
@\placeholder{L}@       operator>>(@\placeholder{L}@, @\placeholder{R}@);
\end{codeblock}
where
\tcode{\placeholder{LR}}
is the result of the usual arithmetic conversions\iref{expr.arith.conv} between types
\tcode{\placeholder{L}}
and
\tcode{\placeholder{R}}.

\pnum
For every triple
(\tcode{\placeholder{L}}, \cvqual{vq}, \tcode{\placeholder{R}}),
where \tcode{\placeholder{L}} is an arithmetic type,
and \tcode{\placeholder{R}} is a floating-point or promoted integral type,
there exist candidate operator functions of the form
\begin{codeblock}
@\cvqual{vq} \placeholder{L}@&   operator=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator*=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator/=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator+=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator-=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
\end{codeblock}

\pnum
For every pair (\tcode{\placeholder{T}}, \cvqual{vq}),
where \tcode{\placeholder{T}} is any type,
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@*@\cvqual{vq}@&   operator=(@\placeholder{T}@*@\cvqual{vq}@&, @\placeholder{T}@*);
\end{codeblock}

\pnum
For every pair
(\tcode{\placeholder{T}},
\cvqual{vq}),
where
\tcode{\placeholder{T}}
is an enumeration or pointer-to-member type,
there exist candidate operator functions of the form
\begin{codeblock}
@\cvqual{vq} \placeholder{T}@&   operator=(@\cvqual{vq} \placeholder{T}@&, @\placeholder{T}@);
\end{codeblock}

\pnum
For every pair
(\tcode{\placeholder{T}},
\cvqual{vq}),
where
\tcode{\placeholder{T}}
is a cv-qualified or cv-unqualified object type,
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{T}@*@\cvqual{vq}@&   operator+=(@\placeholder{T}@*@\cvqual{vq}@&, std::ptrdiff_t);
@\placeholder{T}@*@\cvqual{vq}@&   operator-=(@\placeholder{T}@*@\cvqual{vq}@&, std::ptrdiff_t);
\end{codeblock}

\pnum
For every triple
(\tcode{\placeholder{L}},
\cvqual{vq},
\tcode{\placeholder{R}}),
where
\tcode{\placeholder{L}}
is an integral type, and
\tcode{\placeholder{R}}
is a promoted integral type,
there exist candidate operator functions of the form
\begin{codeblock}
@\cvqual{vq} \placeholder{L}@&   operator%=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator<<=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator>>=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator&=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator^=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
@\cvqual{vq} \placeholder{L}@&   operator|=(@\cvqual{vq} \placeholder{L}@&, @\placeholder{R}@);
\end{codeblock}

\pnum
There also exist candidate operator functions of the form
\begin{codeblock}
bool    operator!(bool);
bool    operator&&(bool, bool);
bool    operator||(bool, bool);
\end{codeblock}

\pnum
For every pair of types \tcode{\placeholder{L}} and \tcode{\placeholder{R}},
where each of \tcode{\placeholder{L}} and \tcode{\placeholder{R}} is a
floating-point or promoted integral type,
there exist candidate operator functions of the form
\begin{codeblock}
@\placeholder{LR}@      operator?:(bool, @\placeholder{L}@, @\placeholder{R}@);
\end{codeblock}
where
\tcode{\placeholder{LR}}
is the result of the usual arithmetic conversions\iref{expr.arith.conv} between types
\tcode{\placeholder{L}}
and
\tcode{\placeholder{R}}.
\begin{note}
As with all these descriptions of candidate functions, this declaration serves
only to describe the built-in operator for purposes of overload resolution.
The operator
``\tcode{?:}''
cannot be overloaded.
\end{note}

\pnum
For every type
\tcode{\placeholder{T}},
where
\tcode{\placeholder{T}}
is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator
functions of the form
\begin{codeblock}
@\placeholder{T}@       operator?:(bool, @\placeholder{T}@, @\placeholder{T}@);
\end{codeblock}%
\indextext{overloading|)}

\rSec1[over.literal]{User-defined literals}%
\indextext{user-defined literal!overloaded}%
\indextext{overloading!user-defined literal}

\begin{bnf}
\nontermdef{literal-operator-id}\br
    \keyword{operator} string-literal identifier\br
    \keyword{operator} user-defined-string-literal
\end{bnf}

\pnum
The \grammarterm{string-literal} or \grammarterm{user-defined-string-literal}
in a \grammarterm{literal-operator-id} shall have no
\grammarterm{encoding-prefix} and shall contain no characters other than the
implicit terminating \tcode{'\textbackslash 0'}.
The \grammarterm{ud-suffix} of the \grammarterm{user-defined-string-literal} or
the \grammarterm{identifier} in a \grammarterm{literal-operator-id} is called a
\defnx{literal suffix identifier}{literal!suffix identifier}.
Some literal suffix identifiers are reserved for future standardization;
see~\ref{usrlit.suffix}.  A declaration whose \grammarterm{literal-operator-id} uses
such a literal suffix identifier is ill-formed, no diagnostic required.

\pnum
A declaration whose \grammarterm{declarator-id} is a
\grammarterm{literal-operator-id} shall declare a function or function template
that belongs to a namespace (it could be a friend function\iref{class.friend}) or
an explicit instantiation or specialization of a function template.
A function declared with a \grammarterm{literal-operator-id} is a \defnx{literal
operator}{literal!operator}. A function template declared with a \grammarterm{literal-operator-id}
is a \defnx{literal operator template}{literal!operator!template}.

\pnum
The declaration of a literal operator shall have a
\grammarterm{parameter-declaration-clause} equivalent to one of the following:

\begin{codeblock}
const char*
unsigned long long int
long double
char
wchar_t
char8_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char8_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t
\end{codeblock}

If a parameter has a default argument\iref{dcl.fct.default}, the program is
ill-formed.

\pnum
A \defnx{raw literal operator}{literal!operator!raw} is a literal operator with a single parameter
whose type is \tcode{const char*}.

\pnum
A \defnx{numeric literal operator template}{literal!operator!template numeric}
is a literal operator template whose \grammarterm{template-parameter-list}
has a single \grammarterm{template-parameter}
that is a non-type template parameter pack\iref{temp.variadic}
with element type \tcode{char}.
A \defnx{string literal operator template}{literal!operator!template string}
is a literal operator template whose \grammarterm{template-parameter-list}
comprises
a single non-type \grammarterm{template-parameter} of class type.
The declaration of a literal operator template
shall have an empty \grammarterm{parameter-declaration-clause}
and shall declare either a numeric literal operator template
or a string literal operator template.

\pnum
Literal operators and literal operator templates shall not have C language linkage.

\pnum
\begin{note}
Literal operators and literal operator templates are usually invoked
implicitly through user-defined literals\iref{lex.ext}. However, except for
the constraints described above, they are ordinary namespace-scope functions and
function templates. In particular, they are looked up like ordinary functions
and function templates and they follow the same overload resolution rules. Also,
they can be declared \keyword{inline} or \keyword{constexpr},
they can have internal, module, or external linkage,
they can be called explicitly, their addresses can be
taken, etc.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
void operator "" _km(long double);                  // OK
string operator "" _i18n(const char*, std::size_t); // OK
template <char...> double operator "" _\u03C0();    // OK: UCN for lowercase pi
float operator ""_e(const char*);                   // OK
float operator ""E(const char*);                    // ill-formed, no diagnostic required:
                                                    // reserved literal suffix~(\ref{usrlit.suffix}, \ref{lex.ext})
double operator""_Bq(long double);                  // OK: does not use the reserved \grammarterm{identifier} \tcode{_Bq}\iref{lex.name}
double operator"" _Bq(long double);                 // ill-formed, no diagnostic required:
                                                    // uses the reserved \grammarterm{identifier} \tcode{_Bq}\iref{lex.name}
float operator " " B(const char*);                  // error: non-empty \grammarterm{string-literal}
string operator "" 5X(const char*, std::size_t);    // error: invalid literal suffix identifier
double operator "" _miles(double);                  // error: invalid \grammarterm{parameter-declaration-clause}
template <char...> int operator "" _j(const char*); // error: invalid \grammarterm{parameter-declaration-clause}
extern "C" void operator "" _m(long double);        // error: C language linkage
\end{codeblock}
\end{example}
