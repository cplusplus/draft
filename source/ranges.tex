%!TEX root = std.tex
\rSec0[ranges]{Ranges library}

\rSec1[ranges.general]{General}

\pnum
This clause describes components for dealing with ranges of elements.

\pnum
The following subclauses describe
range and view requirements, and
components for
range primitives
as summarized in \tref{range.summary}.

\begin{libsumtab}{Ranges library summary}{range.summary}
  \ref{range.access}       & Range access      & \tcode{<ranges>} \\
  \ref{range.req}          & Requirements      & \\
  \ref{range.utility}      & Range utilities   & \\
  \ref{range.factories}    & Range factories   & \\
  \ref{range.adaptors}     & Range adaptors    & \\
\end{libsumtab}

\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\indexheader{ranges}%
\begin{codeblock}
#include <initializer_list>
#include <iterator>

namespace std::ranges {
  inline namespace @\unspec@ {
    // \ref{range.access}, range access
    inline constexpr @\unspec@ begin = @\unspec@;
    inline constexpr @\unspec@ end = @\unspec@;
    inline constexpr @\unspec@ cbegin = @\unspec@;
    inline constexpr @\unspec@ cend = @\unspec@;
    inline constexpr @\unspec@ rbegin = @\unspec@;
    inline constexpr @\unspec@ rend = @\unspec@;
    inline constexpr @\unspec@ crbegin = @\unspec@;
    inline constexpr @\unspec@ crend = @\unspec@;

    inline constexpr @\unspec@ size = @\unspec@;
    inline constexpr @\unspec@ empty = @\unspec@;
    inline constexpr @\unspec@ data = @\unspec@;
    inline constexpr @\unspec@ cdata = @\unspec@;
  }

  // \ref{range.range}, ranges
  template<class T>
    concept range = @\seebelow@;

  template<range T>
    inline constexpr bool enable_safe_range = false;

  template<class T>
    concept safe_range = @\seebelow@;

  template<range R>
    using iterator_t = decltype(ranges::begin(declval<R&>()));
  template<range R>
    using sentinel_t = decltype(ranges::end(declval<R&>()));
  template<range R>
    using range_difference_t = iter_difference_t<iterator_t<R>>;
  template<range R>
    using range_value_t = iter_value_t<iterator_t<R>>;
  template<range R>
    using range_reference_t = iter_reference_t<iterator_t<R>>;
  template<range R>
    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<R>>;

  // \ref{range.sized}, sized ranges
  template<class>
    inline constexpr bool disable_sized_range = false;

  template<class T>
    concept sized_range = @\seebelow@;

  // \ref{range.view}, views
  template<class T>
    inline constexpr bool enable_view = @\seebelow@;

  struct view_base { };

  template<class T>
    concept view = @\seebelow@;

  // \ref{range.refinements}, other range refinements
  template<class R, class T>
    concept output_range = @\seebelow@;

  template<class T>
    concept input_range = @\seebelow@;

  template<class T>
    concept forward_range = @\seebelow@;

  template<class T>
    concept bidirectional_range = @\seebelow@;

  template<class T>
    concept random_access_range = @\seebelow@;

  template<class T>
    concept contiguous_range = @\seebelow@;

  template<class T>
    concept common_range = @\seebelow@;

  template<class T>
    concept viewable_range = @\seebelow@;

  // \ref{view.interface}, class template \tcode{view_interface}
  template<class D>
    requires is_class_v<D> && same_as<D, remove_cv_t<D>>
  class view_interface;

  // \ref{range.subrange}, sub-ranges
  enum class subrange_kind : bool { unsized, sized };

  template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K = @\seebelow@>
    requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
  class subrange;

  template<input_or_output_iterator I, sentinel_for<I> S, subrange_kind K>
    inline constexpr bool enable_safe_range<subrange<I, S, K>> = true;

  // \ref{range.dangling}, dangling iterator handling
  struct dangling;

  template<range R>
    using safe_iterator_t = conditional_t<safe_range<R>, iterator_t<R>, dangling>;

  template<range R>
    using safe_subrange_t =
      conditional_t<safe_range<R>, subrange<iterator_t<R>>, dangling>;

  // \ref{range.empty}, empty view
  template<class T>
    requires is_object_v<T>
  class empty_view;

  template<class T>
    inline constexpr bool enable_safe_range<empty_view<T>> = true;

  namespace views {
    template<class T>
      inline constexpr empty_view<T> empty{};
  }

  // \ref{range.single}, single view
  template<copy_constructible T>
    requires is_object_v<T>
  class single_view;

  namespace views { inline constexpr @\unspec@ single = @\unspec@; }

  // \ref{range.iota}, iota view
  template<weakly_incrementable W, semiregular Bound = unreachable_sentinel_t>
    requires @\placeholder{weakly-equality-comparable-with}@<W, Bound>
  class iota_view;

  template<weakly_incrementable W, semiregular Bound>
    inline constexpr bool enable_safe_range<iota_view<W, Bound>> = true;

  namespace views { inline constexpr @\unspec@ iota = @\unspec@; }

  // \ref{range.istream}, istream view
  template<movable Val, class CharT, class Traits = char_traits<CharT>>
    requires @\seebelow@
  class basic_istream_view;
  template<class Val, class CharT, class Traits>
    basic_istream_view<Val, CharT, Traits> istream_view(basic_istream<CharT, Traits>& s);

  // \ref{range.all}, all view
  namespace views { inline constexpr @\unspec@ all = @\unspec@; }

  template<viewable_range R>
    using all_view = decltype(views::all(declval<R>()));

  template<range R>
    requires is_object_v<R>
  class ref_view;

  template<class T>
    inline constexpr bool enable_safe_range<ref_view<T>> = true;

  // \ref{range.filter}, filter view
  template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
    requires view<V> && is_object_v<Pred>
  class filter_view;

  namespace views { inline constexpr @\unspec@ filter = @\unspec@; }

  // \ref{range.transform}, transform view
  template<input_range V, copy_constructible F>
    requires view<V> && is_object_v<F> &&
             regular_invocable<F&, range_reference_t<V>>
  class transform_view;

  namespace views { inline constexpr @\unspec@ transform = @\unspec@; }

  // \ref{range.take}, take view
  template<view> class take_view;

  namespace views { inline constexpr @\unspec@ take = @\unspec@; }

  // \ref{range.take.while}, take while view
  template<view V, class Pred>
    requires input_range<V> && is_object_v<Pred> &&
      indirect_unary_predicate<const Pred, iterator_t<V>>
    class take_while_view;

  namespace views { inline constexpr @\unspec@ take_while = @\unspec@; }

  // \ref{range.drop}, drop view
  template<view V>
    class drop_view;

  namespace views { inline constexpr @\unspec@ drop = @\unspec@; }

  // \ref{range.drop.while}, drop while view
  template<view V, class Pred>
    requires input_range<V> && is_object_v<Pred> &&
      indirect_unary_predicate<const Pred, iterator_t<V>>
    class drop_while_view;

  namespace views { inline constexpr @\unspec@ drop_while = @\unspec@; }

  // \ref{range.join}, join view
  template<input_range V>
    requires view<V> && input_range<range_reference_t<V>> &&
             (is_reference_v<range_reference_t<V>> ||
              view<range_value_t<V>>)
  class join_view;

  namespace views { inline constexpr @\unspec@ join = @\unspec@; }

  // \ref{range.split}, split view
  template<class R>
    concept @\exposconcept{tiny-range}@ = @\seebelow@;   // \expos

  template<input_range V, forward_range Pattern>
    requires view<V> && view<Pattern> &&
             indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
             (forward_range<V> || @\placeholder{tiny-range}@<Pattern>)
  class split_view;

  namespace views { inline constexpr @\unspec@ split = @\unspec@; }

  // \ref{range.counted}, counted view
  namespace views { inline constexpr @\unspec@ counted = @\unspec@; }

  // \ref{range.common}, common view
  template<view V>
    requires (!common_range<V> && copyable<iterator_t<V>>)
  class common_view;

  namespace views { inline constexpr @\unspec@ common = @\unspec@; }

  // \ref{range.reverse}, reverse view
  template<view V>
    requires bidirectional_range<V>
  class reverse_view;

  namespace views { inline constexpr @\unspec@ reverse = @\unspec@; }

  // \ref{range.elements}, elements view
  template<input_range V, size_t N>
    requires @\seebelow@;
  class elements_view;

  template<class R>
    using keys_view = elements_view<all_view<R>, 0>;
  template<class R>
    using values_view = elements_view<all_view<R>, 1>;

  namespace views {
    template<size_t N>
      inline constexpr @\unspec@ elements = @\unspec@ ;
    inline constexpr @\unspec@ keys = @\unspec@ ;
    inline constexpr @\unspec@ values = @\unspec@ ;
  }
}

namespace std {
  namespace views = ranges::views;

  template<class I, class S, ranges::subrange_kind K>
  struct tuple_size<ranges::subrange<I, S, K>>
    : integral_constant<size_t, 2> {};
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<0, ranges::subrange<I, S, K>> {
    using type = I;
  };
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<1, ranges::subrange<I, S, K>> {
    using type = S;
  };
}
\end{codeblock}

\pnum
\indextext{make-unigned-like@\exposid{make-unsigned-like}}%
\indextext{make-unigned-like-t@\exposid{make-unsigned-like-t}}%
Within this clause,
for an integer-like type \tcode{X}\iref{iterator.concept.winc},
\tcode{\placeholdernc{make-unsigned-like-t}(X)} denotes
\tcode{make_unsigned_t<X>} if \tcode{X} is an integer type;
otherwise, it denotes a corresponding unspecified unsigned-integer-like type
of the same width as \tcode{X}.
For an object \tcode{x} of type \tcode{X},
\tcode{\placeholdernc{make-unsigned-like}(x)} is
\tcode{x} explicitly converted to
\tcode{\placeholdernc{make-unsigned-like-t}(X)}.

\rSec1[range.access]{Range access}

\pnum
In addition to being available via inclusion of the \libheader{ranges}
header, the customization point objects in \ref{range.access} are
available when \libheaderrefx{iterator}{iterator.synopsis} is included.

\rSec2[range.access.begin]{\tcode{ranges::begin}}
\pnum
The name \tcode{ranges::begin} denotes a customization point
object\iref{customization.point.object}.
Given a subexpression \tcode{E} and
an lvalue \tcode{t} that denotes the same object as \tcode{E},
if \tcode{E} is an rvalue and
\tcode{enable_safe_range<remove_cvref_t<decltype((E))>>} is \tcode{false},
\tcode{ranges::begin(E)} is ill-formed.
Otherwise,
\tcode{ranges::begin(E)} is
expression-equivalent to:
\begin{itemize}
\item
  \tcode{t + 0} if \tcode{t} is of array type\iref{basic.compound}.

\item
  Otherwise,
  \tcode{\placeholdernc{decay-copy}(t.begin())}
  if it is a valid expression and its type \tcode{I} models
  \libconcept{input_or_output_iterator}.

\item
  Otherwise, \tcode{\placeholdernc{decay-copy}(begin(t))} if it is a
  valid expression and its type \tcode{I} models
  \libconcept{input_or_output_iterator} with overload
  resolution performed in a context that includes the declarations:
\begin{codeblock}
template<class T> void begin(T&&) = delete;
template<class T> void begin(initializer_list<T>&&) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::begin}.

\item
  Otherwise, \tcode{ranges::begin(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::begin(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::begin(E)} is a valid expression, its type models
\tcode{input_or_output_iterator}.
\end{note}

\rSec2[range.access.end]{\tcode{ranges::end}}
\pnum
The name \tcode{ranges::end} denotes a customization point
object\iref{customization.point.object}.
Given a subexpression \tcode{E} and
an lvalue \tcode{t} that denotes the same object as \tcode{E},
if \tcode{E} is an rvalue and
\tcode{enable_safe_range<remove_cvref_t<decltype((E))>>} is \tcode{false},
\tcode{ranges::end(E)} is ill-formed.
Otherwise,
\tcode{ranges::end(E)} is
expression-equivalent to:
\begin{itemize}
\item
  \tcode{t + extent_v<T>} if \tcode{E} is of array
  type\iref{basic.compound} \tcode{T}.

\item
  Otherwise,
  \tcode{\placeholdernc{decay-copy}(t.end())}
  if it is a valid expression and its type \tcode{S} models
\begin{codeblock}
sentinel_for<decltype(ranges::begin(E))>
\end{codeblock}

\item
  Otherwise, \tcode{\placeholdernc{decay-copy}(end(t))} if it is a valid
  expression and its type \tcode{S} models
\begin{codeblock}
sentinel_for<decltype(ranges::begin(E))>
\end{codeblock}
  with overload
  resolution performed in a context that includes the declarations:
\begin{codeblock}
template<class T> void end(T&&) = delete;
template<class T> void end(initializer_list<T>&&) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::end}.

\item
  Otherwise, \tcode{ranges::end(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::end(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::end(E)} is a valid expression,
the types \tcode{S} and \tcode{I} of
\tcode{ranges::end(E)} and \tcode{ranges::begin(E)}
model \tcode{\libconcept{sentinel_for}<S, I>}.
\end{note}

\rSec2[range.access.cbegin]{\tcode{ranges::cbegin}}
\pnum
The name \tcode{ranges::cbegin} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::\brk{}cbegin(E)} for a subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::begin(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.
\item Otherwise, \tcode{ranges::begin(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cbegin(E)} is a valid expression, its type models
\libconcept{input_or_output_iterator}.
\end{note}

\rSec2[range.access.cend]{\tcode{ranges::cend}}
\pnum
The name \tcode{ranges::cend} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::cend(E)} for a subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::end(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.
\item Otherwise, \tcode{ranges::end(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cend(E)} is a valid expression,
the types \tcode{S} and \tcode{I} of
\tcode{ranges::cend(E)} and \tcode{ranges::cbegin(E)}
model \tcode{\libconcept{sentinel_for}<S, I>}.
\end{note}

\rSec2[range.access.rbegin]{\tcode{ranges::rbegin}}
\pnum
The name \tcode{ranges::rbegin} denotes a customization point
object\iref{customization.point.object}.
Given a subexpression \tcode{E} and
an lvalue \tcode{t} that denotes the same object as \tcode{E},
if \tcode{E} is an rvalue and
\tcode{enable_safe_range<remove_cvref_t<decltype((E))>>} is \tcode{false},
\tcode{ranges::rbegin(E)} is ill-formed.
Otherwise,
\tcode{ranges::rbegin(E)} is
expression-equivalent to:
\begin{itemize}
\item
  \tcode{\placeholdernc{decay-copy}(t.rbegin())}
  if it is a valid expression and its type \tcode{I} models
  \libconcept{input_or_output_iterator}.

\item
  Otherwise, \tcode{\placeholdernc{decay-copy}(rbegin(t))} if it is a valid
  expression and its type \tcode{I} models
  \libconcept{input_or_output_iterator} with overload
  resolution performed in a context that includes the declaration:
\begin{codeblock}
template<class T> void rbegin(T&&) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::rbegin}.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::end(t))} if both
  \tcode{ranges::begin(t)} and \tcode{ranges::end(\brk{}t)} are valid
  expressions of the same type \tcode{I} which models
  \libconcept{bidirectional_iterator}\iref{iterator.concept.bidir}.

\item
  Otherwise, \tcode{ranges::rbegin(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::rbegin(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rbegin(E)} is a valid expression, its type models
\libconcept{input_or_output_iterator}.
\end{note}

\rSec2[range.access.rend]{\tcode{ranges::rend}}
\pnum
The name \tcode{ranges::rend} denotes a customization point
object\iref{customization.point.object}.
Given a subexpression \tcode{E} and
an lvalue \tcode{t} that denotes the same object as \tcode{E},
if \tcode{E} is an rvalue and
\tcode{enable_safe_range<remove_cvref_t<decltype((E))>>} is \tcode{false},
\tcode{ranges::rend(E)} is ill-formed.
Otherwise,
\tcode{ranges::rend(E)} is
expression-equivalent to:
\begin{itemize}
\item
  \tcode{\placeholdernc{decay-copy}(t.rend())}
  if it is a valid expression and its type \tcode{S} models
\begin{codeblock}
sentinel_for<decltype(ranges::rbegin(E))>
\end{codeblock}

\item
  Otherwise, \tcode{\placeholdernc{decay-copy}(rend(t))} if it is a valid
  expression and its type \tcode{S} models
\begin{codeblock}
sentinel_for<decltype(ranges::rbegin(E))>
\end{codeblock}
  with overload
  resolution performed in a context that includes the declaration:
\begin{codeblock}
template<class T> void rend(T&&) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::rend}.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::begin(t))} if both
  \tcode{ranges::begin(t)} and \tcode{ranges::\brk{}end(t)} are valid
  expressions of the same type \tcode{I} which models
  \libconcept{bidirectional_iterator}\iref{iterator.concept.bidir}.

\item
  Otherwise, \tcode{ranges::rend(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::rend(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rend(E)} is a valid expression,
the types \tcode{S} and \tcode{I} of
\tcode{ranges::rend(E)} and \tcode{ranges::rbegin(E)}
model \tcode{\libconcept{sentinel_for}<S, I>}.
\end{note}

\rSec2[range.access.crbegin]{\tcode{ranges::crbegin}}
\pnum
The name \tcode{ranges::crbegin} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::\brk{}crbegin(E)} for a subexpression \tcode{E} of type
\tcode{T} is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::\brk{}rbegin(static_cast<const T\&>(E))} if \tcode{E} is
  an lvalue.
\item Otherwise, \tcode{ranges::rbegin(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::crbegin(E)} is a valid expression, its
type models \libconcept{input_or_output_iterator}.
\end{note}

\rSec2[range.access.crend]{\tcode{ranges::crend}}
\pnum
The name \tcode{ranges::crend} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::\brk{}crend(E)} for a subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::rend(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.

\item Otherwise, \tcode{ranges::rend(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::crend(E)} is a valid expression,
the types \tcode{S} and \tcode{I} of
\tcode{ranges::crend(E)} and \tcode{ranges::crbegin(E)}
model \tcode{\libconcept{sentinel_for}<S, I>}.
\end{note}

\rSec2[range.prim.size]{\tcode{ranges::size}}
\pnum
The name \tcode{size} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::size(E)} for a subexpression \tcode{E} of type
\tcode{T} is expression-equivalent to:
\begin{itemize}
\item
  \tcode{\placeholdernc{decay-copy}(extent_v<T>)} if \tcode{T} is an array
  type\iref{basic.compound}.

\item
  Otherwise, if
  \tcode{disable_sized_range<remove_cv_t<T>>}\iref{range.sized}
  is \tcode{false}:
  \begin{itemize}
  \item
    \tcode{\placeholdernc{decay-copy}(E.size())}
    if it is a valid expression and its type \tcode{I}
    is integer-like\iref{iterator.concept.winc}.

  \item
    Otherwise, \tcode{\placeholdernc{decay-copy}(size(E))}
    if it is a valid expression and its type \tcode{I}
    is integer-like
    with overload resolution performed in a context that includes
    the declaration:
\begin{codeblock}
template<class T> void size(T&&) = delete;
\end{codeblock}
    and does not include a declaration of \tcode{ranges::size}.
  \end{itemize}

\item
  Otherwise, \tcode{\placeholdernc{make-unsigned-like}(ranges::end(E) - ranges::begin(E))}\iref{range.subrange}
  if it is a valid expression and
  the types \tcode{I} and \tcode{S} of \tcode{ranges::begin(E)} and
  \tcode{ranges::end(E)} (respectively) model both
  \tcode{\libconcept{sized_sentinel_for}<S, I>}\iref{iterator.concept.sizedsentinel} and
  \tcode{\libconcept{forward_iterator}<I>}.
  However, \tcode{E} is evaluated only once.

\item
  Otherwise, \tcode{ranges::size(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::size(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::size(E)} is a valid expression, its
type is integer-like.
\end{note}

\rSec2[range.prim.empty]{\tcode{ranges::empty}}
\pnum
The name \tcode{empty} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::empty(E)} for a subexpression \tcode{E} is
expression-equivalent to:
\begin{itemize}
\item
  \tcode{bool((E).empty())} if it is a valid expression.

\item
  Otherwise, \tcode{(ranges::size(E) == 0)} if it is a valid expression.

\item
  Otherwise, \tcode{EQ}, where \tcode{EQ} is
  \tcode{bool(ranges::begin(E) == ranges::end(E))}
  except that \tcode{E} is only evaluated once,
  if \tcode{EQ} is a valid expression and
  the type of \tcode{ranges::begin(E)} models \libconcept{forward_iterator}.

\item
  Otherwise, \tcode{ranges::empty(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::empty(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::empty(E)} is a valid expression,
it has type \tcode{bool}.
\end{note}

\rSec2[range.prim.data]{\tcode{ranges::data}}
\pnum
The name \tcode{data} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::data(E)} for a subexpression \tcode{E} is
expression-equivalent to:
\begin{itemize}
\item
  If \tcode{E} is an lvalue, \tcode{\placeholdernc{decay-copy}(E.data())}
  if it is a valid expression of pointer to object type.

\item
  Otherwise, if \tcode{ranges::begin(E)} is a valid expression whose type models
  \libconcept{contiguous_iterator},
  \tcode{to_address(ranges::begin(E))}.

\item
  Otherwise, \tcode{ranges::data(E)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::data(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::data(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec2[range.prim.cdata]{\tcode{ranges::cdata}}
\pnum
The name \tcode{cdata} denotes a customization point
object\iref{customization.point.object}. The expression
\tcode{ranges::cdata(E)} for a subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::data(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.

\item Otherwise, \tcode{ranges::data(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cdata(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec1[range.req]{Range requirements}

\rSec2[range.req.general]{General}

\pnum
Ranges are an abstraction that allow a \Cpp{} program
to operate on elements of data structures uniformly.
Calling \tcode{ranges::begin} on a range returns an object
whose type models \libconcept{input_or_output_iterator}\iref{iterator.concept.iterator}.
Calling \tcode{ranges::end} on a range returns an object whose type \tcode{S},
together with the type \tcode{I} of the object returned by \tcode{ranges::begin},
models \tcode{\libconcept{sentinel_for}<S, I>}.
The library formalizes the interfaces, semantics, and complexity of ranges
to enable algorithms and range adaptors that work efficiently
on different types of sequences.

\pnum
The \libconcept{range} concept requires that
\tcode{ranges::begin} and \tcode{ranges::end}
return an iterator and a sentinel, respectively.
The \libconcept{sized_range} concept refines \libconcept{range} with
the requirement that the number of elements in the range can be determined
in constant time using the \tcode{ranges::size} function.
The \libconcept{view} concept specifies requirements on a \libconcept{range} type
with constant-time destruction and move operations.

\pnum
Several refinements of \libconcept{range} group requirements
that arise frequently in concepts and algorithms.
Common ranges are ranges for which
\tcode{ranges::begin} and \tcode{ranges::end}
return objects of the same type.
Random access ranges are ranges for which \tcode{ranges::begin}
returns a type that models
\libconcept{random_access_iterator}\iref{iterator.concept.random.access}.
(Contiguous, bidirectional, forward, input, and output ranges
are defined similarly.)
Viewable ranges can be converted to views.

\rSec2[range.range]{Ranges}

\pnum
The \libconcept{range} concept defines the requirements of a type that allows
iteration over its elements by providing an iterator and sentinel
that denote the elements of the range.

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{range}@ =
    requires(T& t) {
      ranges::begin(t);                         // sometimes equality-preserving (see below)
      ranges::end(t);
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
The required expressions
\tcode{ranges::begin(t)}
and
\tcode{ranges::end(t)}
of the \libconcept{range} concept
do not require implicit expression variations\iref{concepts.equality}.

\pnum
Given an expression \tcode{t} such that \tcode{decltype((t))} is \tcode{T\&},
\tcode{T} models \libconcept{range} only if
\begin{itemize}
\item \range{ranges::begin(t)}{ranges::end(t)}
  denotes a range\iref{iterator.requirements.general},

\item both
\tcode{ranges::begin(t)}
and
\tcode{ranges::end(t)}
are amortized constant time and non-modifying, and

\item if the type of \tcode{ranges::begin(t)} models
\libconcept{forward_iterator}, \tcode{ranges::begin(t)} is equality-preserving.
\end{itemize}

\pnum
\begin{note}
Equality preservation of both \tcode{ranges::begin} and
\tcode{ranges::end} enables passing a \libconcept{range} whose iterator
type models \libconcept{forward_iterator} to multiple
algorithms and making multiple passes over the range by repeated calls to
\tcode{ranges::begin} and \tcode{ranges::end}.
Since \tcode{ranges::begin} is not required to be equality-preserving
when the return type does not model \libconcept{forward_iterator}, repeated calls
might not return equal values or might not be well-defined;
\tcode{ranges::begin} should be called at most once for such a range.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{safe_range}@ =
    range<T> &&
      (is_lvalue_reference_v<T> || enable_safe_range<remove_cvref_t<T>>);
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an expression \tcode{E} such that \tcode{decltype((E))} is \tcode{T},
\tcode{T} models \libconcept{safe_range} only if
the validity of iterators obtained from the object denoted by \tcode{E}
is not tied to the lifetime of that object.

\pnum
\begin{note}
Since the validity of iterators is not tied to the lifetime of
an object whose type models \libconcept{safe_range},
a function can accept arguments of such a type by value and
return iterators obtained from it without danger of dangling.
\end{note}
\end{itemdescr}

\indexlibraryglobal{enable_safe_range}%
\begin{itemdecl}
template<class>
  inline constexpr bool enable_safe_range = false;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Pursuant to \ref{namespace.std}, users may specialize \tcode{enable_safe_range}
for cv-unqualified program-defined types.
Such specializations shall be
usable in constant expressions\iref{expr.const} and
have type \tcode{const bool}.

\pnum
\begin{example}
Each specialization \tcode{S} of class template \tcode{subrange}\iref{range.subrange}
models \libconcept{safe_range} because
\begin{itemize}
\item
\tcode{enable_safe_range<S>} is specialized
to have the value \tcode{true}, and

\item
\tcode{S}'s iterators
do not have validity tied to the lifetime of an \tcode{S} object
because they are ``borrowed'' from some other range.
\end{itemize}
\end{example}
\end{itemdescr}

\rSec2[range.sized]{Sized ranges}

\pnum
The \libconcept{sized_range} concept specifies the requirements
of a \libconcept{range} type that knows its size in constant time with the
\tcode{size} function.

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{sized_range}@ =
    range<T> &&
    !disable_sized_range<remove_cvref_t<T>> &&
    requires(T& t) { ranges::size(t); };
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
models \libconcept{sized_range} only if
\begin{itemize}
\item \tcode{ranges::size(t)} is \bigoh{1}, does not modify \tcode{t},
and is equal to \tcode{ranges::distance(t)}, and

\item if \tcode{iterator_t<T>} models \libconcept{forward_iterator},
\tcode{ranges::size(t)} is well-defined regardless of the evaluation of
\tcode{ranges::begin(t)}.
\begin{note}
\tcode{ranges::size(t)} is otherwise not required to be
well-defined after evaluating \tcode{ranges::begin(t)}.
For example, \tcode{ranges::size(t)} might be well-defined
for a \libconcept{sized_range} whose iterator type
does not model \libconcept{forward_iterator}
only if evaluated before the first call to \tcode{ranges::begin(t)}.
\end{note}
\end{itemize}

\pnum
\begin{note}
The complexity requirement for the evaluation of \tcode{ranges::size}
is non-amortized, unlike the case for the complexity of the evaluations of
\tcode{ranges::begin} and \tcode{ranges::end} in the \libconcept{range} concept.
\end{note}
\end{itemdescr}

\indexlibraryglobal{disable_sized_range}%
\begin{itemdecl}
template<class>
  inline constexpr bool disable_sized_range = false;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Pursuant to \ref{namespace.std},
users may specialize \tcode{disable_sized_range}
for cv-unqualified program-defined types.
Such specializations shall
be usable in constant expressions\iref{expr.const} and
have type \tcode{const bool}.

\pnum
\begin{note}
\tcode{disable_sized_range} allows use of range types with the library
that satisfy but do not in fact model \libconcept{sized_range}.
\end{note}
\end{itemdescr}

\rSec2[range.view]{Views}

\pnum
The \libconcept{view} concept specifies the requirements of a \libconcept{range} type
that has constant time move construction, move assignment, and destruction;
that is, the cost of these operations is
independent of the number of elements in the \tcode{view}.

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{view}@ =
    range<T> && movable<T> && default_constructible<T> && enable_view<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{T} models \libconcept{view} only if:
\begin{itemize}
\item
\tcode{T} has \bigoh{1} move construction; and

\item
\tcode{T} has \bigoh{1} move assignment; and

\item
\tcode{T} has \bigoh{1} destruction; and

\item
\tcode{copy_constructible<T>} is \tcode{false}, or
\tcode{T} has \bigoh{1} copy construction; and

\item
\tcode{copyable<T>} is \tcode{false}, or
\tcode{T} has \bigoh{1} copy assignment.
\end{itemize}

\pnum
\begin{example}
Examples of \tcode{view}s are:
\begin{itemize}
\item A \libconcept{range} type that wraps a pair of iterators.

\item A \libconcept{range} type that holds its elements by \tcode{shared_ptr}
and shares ownership with all its copies.

\item A \libconcept{range} type that generates its elements on demand.
\end{itemize}

Most containers\iref{containers} are not views since
destruction of the container destroys the elements,
which cannot be done in constant time.
\end{example}
\end{itemdescr}

\pnum
Since the difference between \libconcept{range} and \libconcept{view} is largely
semantic, the two are differentiated with the help of \tcode{enable_view}.

\indexlibraryglobal{enable_view}%
\begin{itemdecl}
template<class T>
  inline constexpr bool enable_view = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
For a type \tcode{T}, the default value of \tcode{enable_view<T>} is:
\begin{itemize}

\item If \tcode{derived_from<T, view_base>} is \tcode{true}, \tcode{true}.
\item Otherwise, if \tcode{T} is a specialization of class template
  \tcode{initializer_list}\iref{support.initlist},
  \tcode{set}\iref{set},
  \tcode{multiset}\iref{multiset},
  \tcode{unordered_set}\iref{unord.set},
  \tcode{unordered_multiset}\iref{unord.multiset}, or
  \tcode{match_results}\iref{re.results}, \tcode{false}.
\item Otherwise, if both \tcode{T} and \tcode{const T} model \libconcept{range}
  and \tcode{range_reference_t<T>} is not the same type as
  \tcode{range_reference_t<const T>},
  \tcode{false}.
  \begin{note}
  Deep \tcode{const}-ness implies element ownership,
  whereas shallow \tcode{const}-ness implies reference semantics.
  \end{note}
\item Otherwise, \tcode{true}.
\end{itemize}

\pnum
Pursuant to \ref{namespace.std}, users may specialize \tcode{enable_view}
to \tcode{true}
for cv-unqualified program-defined types which model \libconcept{view},
and \tcode{false} for types which do not.
Such specializations shall
be usable in constant expressions\iref{expr.const} and
have type \tcode{const bool}.
\end{itemdescr}

\rSec2[range.refinements]{Other range refinements}

\pnum
The \libconcept{output_range} concept specifies requirements of a
\libconcept{range} type for which \tcode{ranges::begin} returns
a model of \libconcept{output_iterator}\iref{iterator.concept.output}.
\libconcept{input_range}, \libconcept{forward_range}, \libconcept{bidirectional_range},
and \libconcept{random_access_range} are defined similarly.

\begin{itemdecl}
template<class R, class T>
  concept @\deflibconcept{output_range}@ =
    range<R> && output_iterator<iterator_t<R>, T>;

template<class T>
  concept @\deflibconcept{input_range}@ =
    range<T> && input_iterator<iterator_t<T>>;

template<class T>
  concept @\deflibconcept{forward_range}@ =
    input_range<T> && forward_iterator<iterator_t<T>>;

template<class T>
  concept @\deflibconcept{bidirectional_range}@ =
    forward_range<T> && bidirectional_iterator<iterator_t<T>>;

template<class T>
  concept @\deflibconcept{random_access_range}@ =
    bidirectional_range<T> && random_access_iterator<iterator_t<T>>;
\end{itemdecl}

\pnum
\libconcept{contiguous_range} additionally requires that
the \tcode{ranges::data} customization point\iref{range.prim.data}
is usable with the range.

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{contiguous_range}@ =
    random_access_range<T> && contiguous_iterator<iterator_t<T>> &&
    requires(T& t) {
      { ranges::data(t) } -> same_as<add_pointer_t<range_reference_t<T>>>;
    };
\end{itemdecl}

\pnum
The \libconcept{common_range} concept specifies requirements of
a \libconcept{range} type for which \tcode{ranges::begin} and
\tcode{ranges::end} return objects of the same type.
\begin{example}
The standard containers\iref{containers} model \libconcept{common_range}.
\end{example}

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{common_range}@ =
    range<T> && same_as<iterator_t<T>, sentinel_t<T>>;
\end{itemdecl}

\pnum
The \libconcept{viewable_range} concept specifies the requirements of a
\libconcept{range} type that can be converted to a \libconcept{view} safely.

\begin{itemdecl}
template<class T>
  concept @\deflibconcept{viewable_range}@ =
    range<T> && (safe_range<T> || view<decay_t<T>>);
\end{itemdecl}

\rSec1[range.utility]{Range utilities}

\pnum
The components in this subclause are general utilities for representing and
manipulating ranges.

\rSec2[range.utility.helpers]{Helper concepts}

\pnum
Many of the types in subclause~\ref{range.utility} are specified in terms of
the following exposition-only concepts:

\begin{codeblock}
template<class R>
  concept @\defexposconcept{simple-view}@ =                         // \expos
    view<R> && range<const R> &&
    same_as<iterator_t<R>, iterator_t<const R>> &&
    same_as<sentinel_t<R>, sentinel_t<const R>>;

template<input_iterator I>
  concept @\defexposconcept{has-arrow}@ =                           // \expos
    is_pointer_v<I> || requires(I i) { i.operator->(); };

template<class T, class U>
  concept @\defexposconcept{not-same-as}@ =                         // \expos
    !same_as<remove_cvref_t<T>, remove_cvref_t<U>>;
\end{codeblock}

\rSec2[view.interface]{View interface}

\pnum
The class template \tcode{view_interface} is a helper for defining
\tcode{view}-like types that offer a container-like interface. It is
parameterized with the type that is derived from it.

\indexlibraryglobal{view_interface}%
\begin{codeblock}
namespace std::ranges {
  template<class D>
    requires is_class_v<D> && same_as<D, remove_cv_t<D>>
  class view_interface : public view_base {
  private:
    constexpr D& @\exposid{derived}@() noexcept {                   // \expos
      return static_cast<D&>(*this);
    }
    constexpr const D& @\exposid{derived}@() const noexcept {       // \expos
      return static_cast<const D&>(*this);
    }
  public:
    constexpr bool empty() requires forward_range<D> {
      return ranges::begin(@\exposid{derived}@()) == ranges::end(@\exposid{derived}@());
    }
    constexpr bool empty() const requires forward_range<const D> {
      return ranges::begin(@\exposid{derived}@()) == ranges::end(@\exposid{derived}@());
    }

    constexpr explicit operator bool()
      requires requires { ranges::empty(@\exposid{derived}@()); } {
        return !ranges::empty(@\exposid{derived}@());
      }
    constexpr explicit operator bool() const
      requires requires { ranges::empty(@\exposid{derived}@()); } {
        return !ranges::empty(@\exposid{derived}@());
      }

    constexpr auto data() requires contiguous_iterator<iterator_t<D>> {
      return to_address(ranges::begin(@\exposid{derived}@()));
    }
    constexpr auto data() const
      requires range<const D> && contiguous_iterator<iterator_t<const D>> {
        return to_address(ranges::begin(@\exposid{derived}@()));
      }

    constexpr auto size() requires forward_range<D> &&
      sized_sentinel_for<sentinel_t<D>, iterator_t<D>> {
        return ranges::end(@\exposid{derived}@()) - ranges::begin(@\exposid{derived}@());
      }
    constexpr auto size() const requires forward_range<const D> &&
      sized_sentinel_for<sentinel_t<const D>, iterator_t<const D>> {
        return ranges::end(@\exposid{derived}@()) - ranges::begin(@\exposid{derived}@());
      }

    constexpr decltype(auto) front() requires forward_range<D>;
    constexpr decltype(auto) front() const requires forward_range<const D>;

    constexpr decltype(auto) back() requires bidirectional_range<D> && common_range<D>;
    constexpr decltype(auto) back() const
      requires bidirectional_range<const D> && common_range<const D>;

    template<random_access_range R = D>
      constexpr decltype(auto) operator[](range_difference_t<R> n) {
        return ranges::begin(@\exposid{derived}@())[n];
      }
    template<random_access_range R = const D>
      constexpr decltype(auto) operator[](range_difference_t<R> n) const {
        return ranges::begin(@\exposid{derived}@())[n];
      }
  };
}
\end{codeblock}

\pnum
The template parameter \tcode{D} for \tcode{view_interface} may be an
incomplete type. Before any member of the resulting specialization of
\tcode{view_interface} other than special member functions
is referenced, \tcode{D} shall be complete, and
model both \tcode{\libconcept{derived_from}<view_interface<D>>} and \libconcept{view}.

\rSec3[view.interface.members]{Members}

\indexlibrarymember{front}{view_interface}%
\begin{itemdecl}
constexpr decltype(auto) front() requires forward_range<D>;
constexpr decltype(auto) front() const requires forward_range<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\effects
Equivalent to: \tcode{return *ranges::begin(\exposid{derived}());}
\end{itemdescr}

\indexlibrarymember{back}{view_interface}%
\begin{itemdecl}
constexpr decltype(auto) back() requires bidirectional_range<D> && common_range<D>;
constexpr decltype(auto) back() const
  requires bidirectional_range<const D> && common_range<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{!empty()}.

\pnum
\effects
Equivalent to: \tcode{return *ranges::prev(ranges::end(\exposid{derived}()));}
\end{itemdescr}

\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template combines together an
iterator and a sentinel into a single object that models the
\libconcept{view} concept. Additionally, it models the
\libconcept{sized_range} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\indexlibraryglobal{subrange}%
\begin{codeblock}
namespace std::ranges {
  template<class T>
    concept @\defexposconcept{pair-like}@ =                                     // \expos
      !is_reference_v<T> && requires(T t) {
        typename tuple_size<T>::type;                       // ensures \tcode{tuple_size<T>} is complete
        requires derived_from<tuple_size<T>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<T>>;
        typename tuple_element_t<1, remove_const_t<T>>;
        { get<0>(t) } -> convertible_to<const tuple_element_t<0, T>&>;
        { get<1>(t) } -> convertible_to<const tuple_element_t<1, T>&>;
      };

  template<class T, class U, class V>
    concept @\defexposconcept{pair-like-convertible-to}@ =                      // \expos
      !range<T> && @\exposconcept{pair-like}@<remove_reference_t<T>> &&
      requires(T&& t) {
        { get<0>(std::forward<T>(t)) } -> convertible_to<U>;
        { get<1>(std::forward<T>(t)) } -> convertible_to<V>;
      };

  template<class T, class U, class V>
    concept @\defexposconcept{pair-like-convertible-from}@ =                    // \expos
      !range<T> && @\exposconcept{pair-like}@<T> && constructible_from<T, U, V>;

  template<class T>
    concept @\defexposconcept{iterator-sentinel-pair}@ =                        // \expos
      !range<T> && @\exposconcept{pair-like}@<T> &&
      sentinel_for<tuple_element_t<1, T>, tuple_element_t<0, T>>;

  template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K =
      sized_sentinel_for<S, I> ? subrange_kind::sized : subrange_kind::unsized>
    requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
  class subrange : public view_interface<subrange<I, S, K>> {
  private:
    static constexpr bool @\exposid{StoreSize}@ =                           // \expos
      K == subrange_kind::sized && !sized_sentinel_for<S, I>;
    I @\exposid{begin_}@ = I();                                             // \expos
    S @\exposid{end_}@ = S();                                               // \expos
    @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) @\exposid{size_}@ = 0;       // \expos; present only
                                                                // when \exposid{StoreSize} is \tcode{true}
  public:
    subrange() = default;

    constexpr subrange(I i, S s) requires (!@\exposid{StoreSize}@);

    constexpr subrange(I i, S s, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized);

    template<@\exposconcept{not-same-as}@<subrange> R>
      requires safe_range<R> &&
               convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
    constexpr subrange(R&& r) requires (!@\exposid{StoreSize}@ || sized_range<R>);

    template<safe_range R>
      requires convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
    constexpr subrange(R&& r, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized)
        : subrange{ranges::begin(r), ranges::end(r), n}
    {}

    template<@\exposconcept{not-same-as}@<subrange> PairLike>
      requires @\exposconcept{pair-like-convertible-to}@<PairLike, I, S>
    constexpr subrange(PairLike&& r) requires (!@\exposid{StoreSize}@)
      : subrange{std::get<0>(std::forward<PairLike>(r)),
                 std::get<1>(std::forward<PairLike>(r))}
    {}

    template<@\exposconcept{pair-like-convertible-to}@<I, S> PairLike>
    constexpr subrange(PairLike&& r, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized)
      : subrange{std::get<0>(std::forward<PairLike>(r)),
                 std::get<1>(std::forward<PairLike>(r)), n}
    {}

    template<@\exposconcept{not-same-as}@<subrange> PairLike>
      requires @\exposconcept{pair-like-convertible-from}@<PairLike, const I&, const S&>
    constexpr operator PairLike() const;

    constexpr I begin() const requires copyable<I>;
    [[nodiscard]] constexpr I begin() requires (!copyable<I>);
    constexpr S end() const;

    constexpr bool empty() const;
    constexpr @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) size() const
      requires (K == subrange_kind::sized);

    [[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const &
      requires forward_iterator<I>;
    [[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) &&;
    [[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
      requires bidirectional_iterator<I>;
    constexpr subrange& advance(iter_difference_t<I> n);
  };

  template<input_or_output_iterator I, sentinel_for<I> S>
    subrange(I, S, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>)) ->
      subrange<I, S, subrange_kind::sized>;

  template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P) -> subrange<tuple_element_t<0, P>, tuple_element_t<1, P>>;

  template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<tuple_element_t<0, P>>)) ->
      subrange<tuple_element_t<0, P>, tuple_element_t<1, P>, subrange_kind::sized>;

  template<safe_range R>
    subrange(R&&) ->
      subrange<iterator_t<R>, sentinel_t<R>,
               (sized_range<R> || sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
                 ? subrange_kind::sized : subrange_kind::unsized>;

  template<safe_range R>
    subrange(R&&, @\placeholdernc{make-unsigned-like-t}@(range_difference_t<R>)) ->
      subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;

  template<size_t N, class I, class S, subrange_kind K>
    requires (N < 2)
    constexpr auto get(const subrange<I, S, K>& r);

  template<size_t N, class I, class S, subrange_kind K>
    requires (N < 2)
    constexpr auto get(subrange<I, S, K>&& r);
}

namespace std {
  using ranges::get;
}
\end{codeblock}

\rSec3[range.subrange.ctor]{Constructors and conversions}

\indexlibraryctor{subrange}%
\begin{itemdecl}
constexpr subrange(I i, S s) requires (!@\exposid{StoreSize}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{i}{s} is a valid range.

\pnum
\effects
Initializes \exposid{begin_} with \tcode{std::move(i)} and \exposid{end_} with
\tcode{s}.
\end{itemdescr}

\indexlibraryctor{subrange}%
\begin{itemdecl}
constexpr subrange(I i, S s, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
  requires (K == subrange_kind::sized);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{i}{s} is a valid range, and
\tcode{n == \placeholdernc{make-unsigned-like}(ranges::distance(i, s))}.

\pnum
\effects
Initializes \exposid{begin_} with \tcode{std::move(i)} and \exposid{end_} with
\tcode{s}. If \exposid{StoreSize} is \tcode{true}, initializes \exposid{size_} with
\tcode{n}.

\pnum
\begin{note}
Accepting the length of the range and storing it to later return  from
\tcode{size()} enables \tcode{subrange} to model \libconcept{sized_range} even
when it stores an iterator and sentinel that do not model
\libconcept{sized_sentinel_for}.
\end{note}
\end{itemdescr}

\indexlibraryctor{subrange}%
\begin{itemdecl}
template<@\exposconcept{not-same-as}@<subrange> R>
  requires safe_range<R> &&
           convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
constexpr subrange(R&& r) requires (!@\exposid{StoreSize}@ || sized_range<R>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{itemize}
\item If \exposid{StoreSize} is \tcode{true},
\tcode{subrange\{ranges::begin(r), ranges::end(r), ranges::size(r)\}}.
\item Otherwise, \tcode{subrange\{ranges::begin(r), ranges::end(r)\}}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{operator \placeholder{PairLike}}{subrange}%
\begin{itemdecl}
template<@\exposconcept{not-same-as}@<subrange> PairLike>
  requires @\exposconcept{pair-like-convertible-from}@<PairLike, const I&, const S&>
constexpr operator PairLike() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return PairLike(\exposid{begin_}, \exposid{end_});}
\end{itemdescr}

\rSec3[range.subrange.access]{Accessors}

\indexlibrarymember{begin}{subrange}%
\begin{itemdecl}
constexpr I begin() const requires copyable<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{begin_};}
\end{itemdescr}

\indexlibrarymember{begin}{subrange}%
\begin{itemdecl}
[[nodiscard]] constexpr I begin() requires (!copyable<I>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::move(\exposid{begin_});}
\end{itemdescr}

\indexlibrarymember{end}{subrange}%
\begin{itemdecl}
constexpr S end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{end_};}
\end{itemdescr}

\indexlibrarymember{empty}{subrange}%
\begin{itemdecl}
constexpr bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{begin_} == \exposid{end_};}
\end{itemdescr}

\indexlibrarymember{size}{subrange}%
\begin{itemdecl}
constexpr @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) size() const
  requires (K == subrange_kind::sized);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item If \exposid{StoreSize} is \tcode{true}, equivalent to: \tcode{return \exposid{size_};}
\item Otherwise, equivalent to: \tcode{return \placeholdernc{make-unsigned-like}(\exposid{end_} - \exposid{begin_});}
\end{itemize}
\end{itemdescr}

\indexlibrarymember{next}{subrange}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const &
  requires forward_iterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(n);
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{next}{subrange}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
advance(n);
return std::move(*this);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{prev}{subrange}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
  requires bidirectional_iterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(-n);
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{advance}{subrange}%
\begin{itemdecl}
constexpr subrange& advance(iter_difference_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{itemize}
\item If \exposid{StoreSize} is \tcode{true},
\begin{codeblock}
auto d = n - ranges::advance(@\exposid{begin_}@, n, @\exposid{end_}@);
if (d >= 0)
  @\exposid{size_}@ -= @\placeholdernc{make-unsigned-like}@(d);
else
  @\exposid{size_}@ += @\placeholdernc{make-unsigned-like}@(-d);
return *this;
\end{codeblock}
\item Otherwise,
\begin{codeblock}
ranges::advance(@\exposid{begin_}@, n, @\exposid{end_}@);
return *this;
\end{codeblock}
\end{itemize}
\end{itemdescr}

\indexlibrarymember{get}{subrange}%
\begin{itemdecl}
template<size_t N, class I, class S, subrange_kind K>
  requires (N < 2)
  constexpr auto get(const subrange<I, S, K>& r);
template<size_t N, class I, class S, subrange_kind K>
  requires (N < 2)
  constexpr auto get(subrange<I, S, K>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (N == 0)
  return r.begin();
else
  return r.end();
\end{codeblock}
\end{itemdescr}

\rSec2[range.dangling]{Dangling iterator handling}

\pnum
The tag type \tcode{dangling} is used together
with the template aliases \tcode{safe_iterator_t} and \tcode{safe_subrange_t}
to indicate that an algorithm
that typically returns an iterator into or subrange of a \tcode{range} argument
does not return an iterator or subrange
which could potentially reference a range
whose lifetime has ended for a particular rvalue \tcode{range} argument
which does not model \libconcept{safe_range}\iref{range.range}.
\indexlibraryglobal{dangling}%
\begin{codeblock}
namespace std::ranges {
  struct dangling {
    constexpr dangling() noexcept = default;
    template<class... Args>
      constexpr dangling(Args&&...) noexcept { }
  };
}
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
vector<int> f();
auto result1 = ranges::find(f(), 42);                                   // \#1
static_assert(same_as<decltype(result1), ranges::dangling>);
auto vec = f();
auto result2 = ranges::find(vec, 42);                                   // \#2
static_assert(same_as<decltype(result2), vector<int>::iterator>);
auto result3 = ranges::find(subrange{vec}, 42);                         // \#3
static_assert(same_as<decltype(result3), vector<int>::iterator>);
\end{codeblock}
The call to \tcode{ranges::find} at \#1 returns \tcode{ranges::dangling}
since \tcode{f()} is an rvalue \tcode{vector};
the \tcode{vector} could potentially be destroyed
before a returned iterator is dereferenced.
However, the calls at \#2 and \#3 both return iterators
since the lvalue \tcode{vec} and specializations of \tcode{subrange}
model \libconcept{safe_range}.
\end{example}

\rSec1[range.factories]{Range factories}

\pnum
This subclause defines \term{range factories},
which are utilities to create a \libconcept{view}.

\pnum
Range factories are declared in namespace \tcode{std::ranges::views}.

\rSec2[range.empty]{Empty view}

\rSec3[range.empty.overview]{Overview}

\pnum
\tcode{empty_view} produces a \libconcept{view} of no elements of
a particular type.

\pnum
\begin{example}
\begin{codeblock}
empty_view<int> e;
static_assert(ranges::empty(e));
static_assert(0 == e.size());
\end{codeblock}
\end{example}

\rSec3[range.empty.view]{Class template \tcode{empty_view}}

\indexlibraryglobal{empty_view}%
\begin{codeblock}
namespace std::ranges {
  template<class T>
    requires is_object_v<T>
  class empty_view : public view_interface<empty_view<T>> {
  public:
    static constexpr T* begin() noexcept { return nullptr; }
    static constexpr T* end() noexcept { return nullptr; }
    static constexpr T* data() noexcept { return nullptr; }
    static constexpr size_t size() noexcept { return 0; }
    static constexpr bool empty() noexcept { return true; }
  };
}
\end{codeblock}

\rSec2[range.single]{Single view}

\rSec3[range.single.overview]{Overview}

\pnum
\tcode{single_view} produces a \libconcept{view} that contains
exactly one element of a specified value.

\pnum
The name \tcode{views::single} denotes a
customization point object\iref{customization.point.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::single(E)} is expression-equivalent to
\tcode{single_view\{E\}}.

\pnum
\begin{example}
\begin{codeblock}
single_view s{4};
for (int i : s)
  cout << i;        // prints \tcode{4}
\end{codeblock}
\end{example}

\rSec3[range.single.view]{Class template \tcode{single_view}}

\indexlibraryglobal{single_view}%
\begin{codeblock}
namespace std::ranges {
  template<copy_constructible T>
    requires is_object_v<T>
  class single_view : public view_interface<single_view<T>> {
  private:
    @\placeholdernc{semiregular-box}@<T> @\exposid{value_}@;      // \expos{} (see \ref{range.semi.wrap})
  public:
    single_view() = default;
    constexpr explicit single_view(const T& t);
    constexpr explicit single_view(T&& t);
    template<class... Args>
      requires constructible_from<T, Args...>
    constexpr single_view(in_place_t, Args&&... args);

    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    static constexpr size_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };
}
\end{codeblock}

\indexlibraryctor{single_view}%
\begin{itemdecl}
constexpr explicit single_view(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{value_} with \tcode{t}.
\end{itemdescr}

\indexlibraryctor{single_view}%
\begin{itemdecl}
constexpr explicit single_view(T&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{value_} with \tcode{std::move(t)}.
\end{itemdescr}

\indexlibraryctor{single_view}%
\begin{itemdecl}
template<class... Args>
constexpr single_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{value_} as if by
\tcode{\exposid{value_}\{in_place, std::forward<Args>(args)...\}}.
\end{itemdescr}

\indexlibrarymember{begin}{single_view}%
\begin{itemdecl}
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return data();}
\end{itemdescr}

\indexlibrarymember{end}{single_view}%
\begin{itemdecl}
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return data() + 1;}
\end{itemdescr}

\indexlibrarymember{size}{single_view}%
\begin{itemdecl}
static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return 1;}
\end{itemdescr}

\indexlibrarymember{data}{single_view}%
\begin{itemdecl}
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{value_}.operator->();}
\end{itemdescr}

\rSec2[range.iota]{Iota view}

\rSec3[range.iota.overview]{Overview}

\pnum
\tcode{iota_view} generates a
sequence of elements by repeatedly incrementing an initial value.

\pnum
The name \tcode{views::iota} denotes a
customization point object\iref{customization.point.object}.
Given subexpressions \tcode{E} and \tcode{F}, the expressions
\tcode{views::iota(E)} and \tcode{views::iota(E, F)}
are expression-equivalent to
\tcode{iota_view\{E\}} and \tcode{iota_view\{E, F\}}, respectively.

\pnum
\begin{example}
\begin{codeblock}
for (int i : iota_view{1, 10})
  cout << i << ' '; // prints: 1 2 3 4 5 6 7 8 9
\end{codeblock}
\end{example}

\rSec3[range.iota.view]{Class template \tcode{iota_view}}

\indexlibraryglobal{iota_view}%
\begin{codeblock}
namespace std::ranges {
  template<class I>
    concept @\exposconcept{decrementable}@ =     // \expos
      @\seebelow@;
  template<class I>
    concept @\exposconcept{advanceable}@ =       // \expos
      @\seebelow@;

  template<weakly_incrementable W, semiregular Bound = unreachable_sentinel_t>
    requires @\exposconcept{weakly-equality-comparable-with}@<W, Bound>
  class iota_view : public view_interface<iota_view<W, Bound>> {
  private:
    // \ref{range.iota.iterator}, class \tcode{iota_view::\exposid{iterator}}
    struct @\exposid{iterator}@;            // \expos
    // \ref{range.iota.sentinel}, class \tcode{iota_view::\exposid{sentinel}}
    struct @\exposid{sentinel}@;            // \expos
    W @\exposid{value_}@ = W();             // \expos
    Bound @\exposid{bound_}@ = Bound();     // \expos
  public:
    iota_view() = default;
    constexpr explicit iota_view(W value);
    constexpr iota_view(type_identity_t<W> value,
                        type_identity_t<Bound> bound);

    constexpr @\exposid{iterator}@ begin() const;
    constexpr auto end() const;
    constexpr @\exposid{iterator}@ end() const requires same_as<W, Bound>;

    constexpr auto size() const requires @\seebelow@;
  };

  template<class W, class Bound>
    requires (!@\exposconcept{is-integer-like}@<W> || !@\exposconcept{is-integer-like}@<Bound> ||
      (@\exposconcept{is-signed-integer-like}@<W> == @\exposconcept{is-signed-integer-like}@<Bound>))
    iota_view(W, Bound) -> iota_view<W, Bound>;
}
\end{codeblock}

\pnum
Let \tcode{\placeholdernc{IOTA-DIFF-T}(W)} be defined as follows:
\begin{itemize}
\item
  If \tcode{W} is not an integral type, or
  if it is an integral type and \tcode{sizeof(iter_difference_t<W>)}
  is greater than \tcode{sizeof(W)},
  then \tcode{\placeholdernc{IOTA-DIFF-T}(W)} denotes \tcode{iter_difference_t<W>}.
\item
  Otherwise, \tcode{\placeholdernc{IOTA-DIFF-T}(W)}
  is a signed integer type of width greater than the width of \tcode{W}
  if such a type exists.
\item
  Otherwise, \tcode{\placeholdernc{IOTA-DIFF-T}(W)}
  is an unspecified signed-integer-like type\iref{iterator.concept.winc}
  of width not less than the width of \tcode{W}.
  \begin{note}
  It is unspecified
  whether this type satisfies \libconcept{weakly_incrementable}.
  \end{note}
\end{itemize}

\pnum
The exposition-only \defexposconcept{decrementable} concept is equivalent to:
\begin{itemdecl}
template<class I>
  concept @\defexposconcept{decrementable}@ =
    incrementable<I> && requires(I i) {
      { --i } -> same_as<I&>;
      { i-- } -> same_as<I>;
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
When an object is in the domain of both pre- and post-decrement,
the object is said to be \term{decrementable}.

\pnum
Let \tcode{a} and \tcode{b} be equal objects of type \tcode{I}.
\tcode{I} models \exposconcept{decrementable} only if
\begin{itemize}
\item If \tcode{a} and \tcode{b} are decrementable,
  then the following are all true:
  \begin{itemize}
  \item \tcode{addressof(--a) == addressof(a)}
  \item \tcode{bool(a-- == b)}
  \item \tcode{bool(((void)a--, a) == --b)}
  \item \tcode{bool(++(--a) == b)}.
  \end{itemize}
\item If \tcode{a} and \tcode{b} are incrementable,
  then \tcode{bool(--(++a) == b)}.
\end{itemize}
\end{itemdescr}

\pnum
The exposition-only \defexposconcept{advanceable} concept is equivalent to:
\begin{itemdecl}
template<class I>
  concept @\defexposconcept{advanceable}@ =
    @\exposconcept{decrementable}@<I> && totally_ordered<I> &&
    requires(I i, const I j, const @\placeholdernc{IOTA-DIFF-T}@(I) n) {
      { i += n } -> same_as<I&>;
      { i -= n } -> same_as<I&>;
      I(j + n);
      I(n + j);
      I(j - n);
      { j - j } -> convertible_to<@\placeholdernc{IOTA-DIFF-T}@(I)>;
    };
\end{itemdecl}

Let \tcode{D} be \tcode{\placeholdernc{IOTA-DIFF-T}(I)}.
Let \tcode{a} and \tcode{b} be objects of type \tcode{I} such that
\tcode{b} is reachable from \tcode{a}
after \tcode{n} applications of \tcode{++a},
for some value \tcode{n} of type \tcode{D}.
\tcode{I} models \exposconcept{advanceable} only if
\begin{itemize}
\item \tcode{(a += n)} is equal to \tcode{b}.
\item \tcode{addressof(a += n)} is equal to \tcode{addressof(a)}.
\item \tcode{I(a + n)} is equal to \tcode{(a += n)}.
\item For any two positive values
  \tcode{x} and \tcode{y} of type \tcode{D},
  if \tcode{I(a + D(x + y))} is well-defined, then
  \tcode{I(a + D(x + y))} is equal to \tcode{I(I(a + x) + y)}.
\item \tcode{I(a + D(0))} is equal to \tcode{a}.
\item If \tcode{I(a + D(n - 1))} is well-defined, then
  \tcode{I(a + n)} is equal to \tcode{[](I c) \{ return ++c; \}(I(a + D(n - 1)))}.
\item \tcode{(b += -n)} is equal to \tcode{a}.
\item \tcode{(b -= n)} is equal to \tcode{a}.
\item \tcode{addressof(b -= n)} is equal to \tcode{addressof(b)}.
\item \tcode{I(b - n)} is equal to \tcode{(b -= n)}.
\item \tcode{D(b - a)} is equal to \tcode{n}.
\item \tcode{D(a - b)} is equal to \tcode{D(-n)}.
\item \tcode{bool(a <= b)} is \tcode{true}.
\end{itemize}

\indexlibraryctor{iota_view}%
\begin{itemdecl}
constexpr explicit iota_view(W value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Bound} denotes \tcode{unreachable_sentinel_t} or
\tcode{Bound()} is reachable from \tcode{value}.

\pnum
\effects
Initializes \exposid{value_} with \tcode{value}.
\end{itemdescr}

\indexlibraryctor{iota_view}%
\begin{itemdecl}
constexpr iota_view(type_identity_t<W> value, type_identity_t<Bound> bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Bound} denotes \tcode{unreachable_sentinel_t} or
\tcode{bound} is reachable from \tcode{value}.
When \tcode{W} and \tcode{Bound} model \libconcept{totally_ordered_with},
then \tcode{bool(value <= bound)} is \tcode{true}.

\pnum
\effects
Initializes \exposid{value_} with \tcode{value} and
\exposid{bound_} with \tcode{bound}.
\end{itemdescr}

\indexlibrarymember{begin}{iota_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{\exposid{value_}\};}
\end{itemdescr}

\indexlibrarymember{end}{iota_view}%
\begin{itemdecl}
constexpr auto end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (same_as<Bound, unreachable_sentinel_t>)
  return unreachable_sentinel;
else
  return @\exposid{sentinel}@{@\exposid{bound_}@};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{end}{iota_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ end() const requires same_as<W, Bound>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{bound_\};}
\end{itemdescr}

\indexlibrarymember{size}{iota_view}%
\begin{itemdecl}
constexpr auto size() const requires @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (@\exposconcept{is-integer-like}@<W> && @\exposconcept{is-integer-like}@<Bound>)
  return (@\exposid{value_}@ < 0)
    ? ((@\exposid{bound_}@ < 0)
      ? @\placeholdernc{make-unsigned-like}@(-@\exposid{value_}@) - @\placeholdernc{make-unsigned-like}@(-@\exposid{bound_}@)
      : @\placeholdernc{make-unsigned-like}@(@\exposid{bound_}@) + @\placeholdernc{make-unsigned-like}@(-@\exposid{value_}@))
    : @\placeholdernc{make-unsigned-like}@(@\exposid{bound_}@) - @\placeholdernc{make-unsigned-like}@(@\exposid{value_}@);
else
  return @\placeholdernc{make-unsigned-like}@(@\exposid{bound_}@ - @\exposid{value_}@);
\end{codeblock}

\pnum
\remarks
The expression in the \grammarterm{requires-clause} is equivalent to
\begin{codeblock}
(same_as<W, Bound> && @\placeholder{advanceable}@<W>) || (integral<W> && integral<Bound>) ||
  sized_sentinel_for<Bound, W>
\end{codeblock}
\end{itemdescr}

\rSec3[range.iota.iterator]{Class \tcode{iota_view::\exposid{iterator}}}

\indexlibraryglobal{iota_view::iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class W, class Bound>
  struct iota_view<W, Bound>::@\exposid{iterator}@ {
  private:
    W @\exposid{value_}@ = W();             // \expos
  public:
    using iterator_category = @\seebelow@;
    using value_type = W;
    using difference_type = @\placeholdernc{IOTA-DIFF-T}@(W);

    @\exposid{iterator}@() = default;
    constexpr explicit @\exposid{iterator}@(W value);

    constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);

    constexpr @\exposid{iterator}@& operator++();
    constexpr void operator++(int);
    constexpr @\exposid{iterator}@ operator++(int) requires incrementable<W>;

    constexpr @\exposid{iterator}@& operator--() requires @\exposconcept{decrementable}@<W>;
    constexpr @\exposid{iterator}@ operator--(int) requires @\exposconcept{decrementable}@<W>;

    constexpr @\exposid{iterator}@& operator+=(difference_type n)
      requires @\exposconcept{advanceable}@<W>;
    constexpr @\exposid{iterator}@& operator-=(difference_type n)
      requires @\exposconcept{advanceable}@<W>;
    constexpr W operator[](difference_type n) const
      requires @\exposconcept{advanceable}@<W>;

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires equality_comparable<W>;

    friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires totally_ordered<W>;
    friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires totally_ordered<W>;
    friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires totally_ordered<W>;
    friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires totally_ordered<W>;
    friend constexpr compare_three_way_result_t<W> operator<=>(
        const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires totally_ordered<W> && three_way_comparable<W>;

    friend constexpr @\exposid{iterator}@ operator+(@\exposid{iterator}@ i, difference_type n)
      requires @\exposconcept{advanceable}@<W>;
    friend constexpr @\exposid{iterator}@ operator+(difference_type n, @\exposid{iterator}@ i)
      requires @\exposconcept{advanceable}@<W>;

    friend constexpr @\exposid{iterator}@ operator-(@\exposid{iterator}@ i, difference_type n)
      requires @\exposconcept{advanceable}@<W>;
    friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires @\exposconcept{advanceable}@<W>;
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item If \tcode{W} models \tcode{\placeholder{advanceable}}, then
\tcode{iterator_category} is \tcode{random_access_iterator_tag}.
\item Otherwise, if \tcode{W} models \exposconcept{decrementable}, then
\tcode{iterator_category} is \tcode{bidirectional_iterator_tag}.
\item Otherwise, if \tcode{W} models \libconcept{incrementable}, then
\tcode{iterator_category} is \tcode{forward_iterator_tag}.
\item Otherwise, \tcode{iterator_category} is \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\begin{note}
Overloads for \tcode{iter_move} and \tcode{iter_swap} are omitted intentionally.
\end{note}

\indexlibraryctor{iota_view::iterator}
\begin{itemdecl}
constexpr explicit @\exposid{iterator}@(W value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{value_} with \tcode{value}.
\end{itemdescr}

\indexlibrarymember{operator*}{iota_view::iterator}
\begin{itemdecl}
constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{value_};}

\pnum
\begin{note}
The \tcode{noexcept} clause is needed by the default \tcode{iter_move}
implementation.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator++}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
++@\exposid{value_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{iota_view::iterator}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator++(int) requires incrementable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator--() requires @\exposconcept{decrementable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
--@\exposid{value_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator--(int) requires @\exposconcept{decrementable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+=}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator+=(difference_type n)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (@\exposconcept{is-integer-like}@<W> && !@\exposconcept{is-signed-integer-like}@<W>) {
  if (n >= difference_type(0))
    @\exposid{value_}@ += static_cast<W>(n);
  else
    @\exposid{value_}@ -= static_cast<W>(-n);
} else {
  @\exposid{value_}@ += n;
}
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator-=}{iota_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator-=(difference_type n)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (@\exposconcept{is-integer-like}@<W> && !@\exposconcept{is-signed-integer-like}@<W>) {
  if (n >= difference_type(0))
    @\exposid{value_}@ -= static_cast<W>(n);
  else
    @\exposid{value_}@ += static_cast<W>(-n);
} else {
  @\exposid{value_}@ -= n;
}
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator[]}{iota_view::iterator}
\begin{itemdecl}
constexpr W operator[](difference_type n) const
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return W(\exposid{value_} + n);}
\end{itemdescr}

\indexlibrarymember{operator==}{iota_view::iterator}
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires equality_comparable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{value_} == y.\exposid{value_};}
\end{itemdescr}

\indexlibrarymember{operator<}{iota_view::iterator}
\begin{itemdecl}
friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires totally_ordered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{value_} < y.\exposid{value_};}
\end{itemdescr}

\indexlibrarymember{operator>}{iota_view::iterator}
\begin{itemdecl}
friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires totally_ordered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\indexlibrarymember{operator<=}{iota_view::iterator}
\begin{itemdecl}
friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires totally_ordered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\indexlibrarymember{operator>=}{iota_view::iterator}
\begin{itemdecl}
friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires totally_ordered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\indexlibrarymember{operator<=>}{iota_view::iterator}
\begin{itemdecl}
friend constexpr compare_three_way_result_t<W>
  operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires totally_ordered<W> && three_way_comparable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{value_} <=> y.\exposid{value_};}
\end{itemdescr}

\indexlibrarymember{operator+}{iota_view::iterator}
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator+(@\exposid{iterator}@ i, difference_type n)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return i += n;}
\end{itemdescr}

\indexlibrarymember{operator+}{iota_view::iterator}
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator+(difference_type n, @\exposid{iterator}@ i)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return i + n;}
\end{itemdescr}

\indexlibrarymember{operator-}{iota_view::iterator}
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator-(@\exposid{iterator}@ i, difference_type n)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return i -= n;}
\end{itemdescr}

\indexlibrarymember{operator-}{iota_view::iterator}
\begin{itemdecl}
friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires @\exposconcept{advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
using D = difference_type;
if constexpr (@\placeholder{is-integer-like}@<W>) {
  if constexpr (@\placeholder{is-signed-integer-like}@<W>)
    return D(D(x.@\exposid{value_}@) - D(y.@\exposid{value_}@));
  else
    return (y.@\exposid{value_}@ > x.@\exposid{value_}@)
      ? D(-D(y.@\exposid{value_}@ - x.@\exposid{value_}@))
      : D(x.@\exposid{value_}@ - y.@\exposid{value_}@);
} else {
  return x.@\exposid{value_}@ - y.@\exposid{value_}@;
}
\end{codeblock}
\end{itemdescr}

\rSec3[range.iota.sentinel]{Class \tcode{iota_view::\exposid{sentinel}}}

\indexlibraryglobal{iota_view::sentinel}%
\begin{codeblock}
namespace std::ranges {
  template<class W, class Bound>
  struct iota_view<W, Bound>::@\exposid{sentinel}@ {
  private:
    Bound @\exposid{bound_}@ = Bound();     // \expos
  public:
    @\exposid{sentinel}@() = default;
    constexpr explicit @\exposid{sentinel}@(Bound bound);

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{sentinel}@& y);

    friend constexpr iter_difference_t<W> operator-(const @\exposid{iterator}@& x, const @\exposid{sentinel}@& y)
      requires sized_sentinel_for<Bound, W>;
    friend constexpr iter_difference_t<W> operator-(const @\exposid{sentinel}@& x, const @\exposid{iterator}@& y)
      requires sized_sentinel_for<Bound, W>;
  };
}
\end{codeblock}

\indexlibraryctor{iota_view::sentinel}
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(Bound bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{bound_} with \tcode{bound}.
\end{itemdescr}

\indexlibrarymember{operator==}{iota_view::sentinel}
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{value_} == y.\exposid{bound_};}
\end{itemdescr}

\begin{itemdecl}
friend constexpr iter_difference_t<W> operator-(const @\exposid{iterator}@& x, const sentinel& y)
  requires sized_sentinel_for<Bound, W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{value_} - y.\exposid{bound_};}
\end{itemdescr}

\begin{itemdecl}
friend constexpr iter_difference_t<W> operator-(const @\exposid{sentinel}@& x, const @\exposid{iterator}@& y)
  requires sized_sentinel_for<Bound, W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return -(y - x);}
\end{itemdescr}

\rSec2[range.istream]{Istream view}

\rSec3[range.istream.overview]{Overview}

\pnum
\tcode{basic_istream_view} models \libconcept{input_range} and
reads (using \tcode{operator>>}) successive elements
from its corresponding input stream.

\pnum
\begin{example}
\begin{codeblock}
auto ints = istringstream{"0 1  2   3     4"};
ranges::copy(istream_view<int>(ints), ostream_iterator<int>{cout, "-"});
// prints \tcode{0-1-2-3-4-}
\end{codeblock}
\end{example}

\rSec3[range.istream.view]{Class template \tcode{basic_istream_view}}

\indexlibraryglobal{basic_istream_view}%
\begin{codeblock}
namespace std::ranges {
  template<class Val, class CharT, class Traits>
    concept @\defexposconcept{stream-extractable}@ =                // \expos
      requires(basic_istream<CharT, Traits>& is, Val& t) {
         is >> t;
      };

  template<movable Val, class CharT, class Traits>
    requires default_constructible<Val> &&
      @\exposconcept{stream-extractable}@<Val, CharT, Traits>
  class basic_istream_view : public view_interface<basic_istream_view<Val, CharT, Traits>> {
  public:
    basic_istream_view() = default;
    constexpr explicit basic_istream_view(basic_istream<CharT, Traits>& stream);

    constexpr auto begin()
    {
      if (@\exposid{stream_}@) {
        *@\exposid{stream_}@ >> @\exposid{object_}@;
      }
      return @\exposid{iterator}@{*this};
    }

    constexpr default_sentinel_t end() const noexcept;

  private:
    struct @\exposid{iterator}@;                                    // \expos
    basic_istream<CharT, Traits>* @\exposid{stream_}@ = nullptr;    // \expos
    Val @\exposid{object_}@ = Val();                                // \expos
  };
}
\end{codeblock}

\indexlibraryctor{basic_istream_view}%
\begin{itemdecl}
constexpr explicit basic_istream_view(basic_istream<CharT, Traits>& stream);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{stream_} with \tcode{addressof(stream)}.
\end{itemdescr}

\indexlibrarymember{end}{basic_istream_view}%
\begin{itemdecl}
constexpr default_sentinel_t end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return default_sentinel;}
\end{itemdescr}

\indexlibraryglobal{istream_view}%
\begin{itemdecl}
template<class Val, class CharT, class Traits>
basic_istream_view<Val, CharT, Traits> istream_view(basic_istream<CharT, Traits>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return basic_istream_view<Val, CharT, Traits>\{s\};}
\end{itemdescr}

\rSec3[range.istream.iterator]{Class template \tcode{basic_istream_view::\exposid{iterator}}}

\indexlibraryglobal{basic_istream_view::iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class Val, class CharT, class Traits>
  class basic_istream_view<Val, CharT, Traits>::@\exposid{iterator}@ {      // \expos
  public:
    using iterator_category = input_iterator_tag;
    using difference_type = ptrdiff_t;
    using value_type = Val;

    @\exposid{iterator}@() = default;
    constexpr explicit @\exposid{iterator}@(basic_istream_view& parent) noexcept;

    @\exposid{iterator}@(const @\exposid{iterator}@&) = delete;
    @\exposid{iterator}@(@\exposid{iterator}@&&) = default;

    @\exposid{iterator}@& operator=(const @\exposid{iterator}@&) = delete;
    @\exposid{iterator}@& operator=(@\exposid{iterator}@&&) = default;

    @\exposid{iterator}@& operator++();
    void operator++(int);

    Val& operator*() const;

    friend bool operator==(const @\exposid{iterator}@& x, default_sentinel_t);

  private:
    basic_istream_view* @\exposid{parent_}@ = nullptr;                      // \expos
  };
}
\end{codeblock}

\indexlibraryctor{basic_istream_view::iterator}%
\begin{itemdecl}
constexpr explicit @\exposid{iterator}@(basic_istream_view& parent) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrarymember{operator++}{basic_istream_view::iterator}%
\begin{itemdecl}
@\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{\exposid{parent_}->\exposid{stream_} != nullptr} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
*@\exposid{parent_}@->@\exposid{stream_}@>> @\exposid{parent_}@->@\exposid{object_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{basic_istream_view::iterator}%
\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{\exposid{parent_}->\exposid{stream_} != nullptr} is \tcode{true}.

\pnum
\effects
Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrarymember{operator*}{basic_istream_view::iterator}%
\begin{itemdecl}
Val& operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{\exposid{parent_}->\exposid{stream_} != nullptr} is \tcode{true}.

\pnum
\effects
Equivalent to: \tcode{return \exposid{parent_}->\exposid{value_};}
\end{itemdescr}

\indexlibrarymember{operator==}{basic_istream_view::iterator}%
\begin{itemdecl}
friend bool operator==(const @\exposid{iterator}@& x, default_sentinel_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{parent_} == nullptr || !*x.\exposid{parent_}->\exposid{stream_};}
\end{itemdescr}

\rSec1[range.adaptors]{Range adaptors}

\pnum
This subclause defines \term{range adaptors}, which are utilities that transform a
\libconcept{range} into a \libconcept{view} with custom behaviors. These
adaptors can be chained to create pipelines of range transformations that
evaluate lazily as the resulting view is iterated.

\pnum
Range adaptors are declared in namespace \tcode{std::ranges::views}.

\pnum
The bitwise \logop{OR} operator is overloaded for the purpose of creating adaptor chain
pipelines. The adaptors also support function call syntax with equivalent
semantics.

\pnum
\begin{example}
\begin{codeblock}
vector<int> ints{0,1,2,3,4,5};
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i) { return i * i; };
for (int i : ints | views::filter(even) | views::transform(square)) {
  cout << i << ' '; // prints: 0 4 16
}
assert(ranges::equal(ints | views::filter(even), views::filter(ints, even)));
\end{codeblock}
\end{example}

\rSec2[range.adaptor.object]{Range adaptor objects}

\pnum
A \term{range adaptor closure object} is a unary function object that accepts
a \libconcept{viewable_range} argument and returns a \libconcept{view}. For
a range adaptor closure object \tcode{C} and an expression \tcode{R} such that
\tcode{decltype((R))} models \libconcept{viewable_range}, the following
expressions are equivalent and yield a \libconcept{view}:

\begin{codeblock}
C(R)
R | C
\end{codeblock}

Given an additional range adaptor closure object \tcode{D},
the expression \tcode{C | D} is well-formed and produces another range adaptor
closure object such that the following two expressions are equivalent:

\begin{codeblock}
R | C | D
R | (C | D)
\end{codeblock}

\pnum
A \term{range adaptor object} is a
customization point object\iref{customization.point.object}
that accepts a \libconcept{viewable_range} as its first argument and returns a
\libconcept{view}.

\pnum
If a range adaptor object accepts only one argument,
then it is a range adaptor closure object.

\pnum
If a range adaptor object accepts more than one argument,
then the following expressions are equivalent:

\begin{codeblock}
@\placeholdernc{adaptor}@(range, args...)
@\placeholdernc{adaptor}@(args...)(range)
range | @\placeholdernc{adaptor}@(args...)
\end{codeblock}

In this case, \tcode{\placeholdernc{adaptor}(args...)} is a range adaptor
closure object.

\rSec2[range.semi.wrap]{Semiregular wrapper}

\pnum
Many types in this subclause are specified in terms of
an exposition-only class template \tcode{\placeholder{semiregular-box}}.
\tcode{\placeholder{semiregular-box}<T>} behaves exactly like \tcode{optional<T>}
with the following differences:
\begin{itemize}
\item \tcode{\placeholder{semiregular-box}<T>} constrains
its type parameter \tcode{T} with
\tcode{\libconcept{copy_constructible}<T> \&\& is_object_v<T>}.

\item If \tcode{T} models \libconcept{default_constructible}, the default
constructor of \tcode{\placeholder{semiregular-box}<T>} is equivalent to:
\begin{codeblock}
constexpr @\placeholder{semiregular-box}@() noexcept(is_nothrow_default_constructible_v<T>)
  : @\placeholder{semiregular-box}@{in_place}
{ }
\end{codeblock}

\item If \tcode{\libconcept{assignable_from}<T\&, const T\&>} is not
modeled, the copy assignment operator is equivalent to:
\begin{codeblock}
@\placeholder{semiregular-box}@& operator=(const @\placeholder{semiregular-box}@& that)
  noexcept(is_nothrow_copy_constructible_v<T>)
{
  if (that) emplace(*that);
  else reset();
  return *this;
}
\end{codeblock}

\item If \tcode{\libconcept{assignable_from}<T\&, T>} is not modeled,
the move assignment operator is equivalent to:
\begin{codeblock}
@\placeholder{semiregular-box}@& operator=(@\placeholder{semiregular-box}@&& that)
  noexcept(is_nothrow_move_constructible_v<T>)
{
  if (that) emplace(std::move(*that));
  else reset();
  return *this;
}
\end{codeblock}
\end{itemize}

\rSec2[range.all]{All view}

\pnum
\tcode{views::all} returns a \libconcept{view} that includes all elements of
its \libconcept{range} argument.

\pnum
The name \tcode{views::all} denotes a
range adaptor object\iref{range.adaptor.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::all(E)} is expression-equivalent to:
\begin{itemize}
\item \tcode{\placeholdernc{decay-copy}(E)} if the decayed type of \tcode{E}
models \libconcept{view}.

\item Otherwise, \tcode{ref_view\{E\}} if that expression is well-formed.

\item Otherwise, \tcode{subrange\{E\}}.
\end{itemize}

\rSec3[range.ref.view]{Class template \tcode{ref_view}}

\pnum
\tcode{ref_view} is a \tcode{view} of the elements of some other \tcode{range}.
\indexlibraryglobal{ref_view}%
\begin{codeblock}
namespace std::ranges {
  template<range R>
    requires is_object_v<R>
  class ref_view : public view_interface<ref_view<R>> {
  private:
    R* @\exposid{r_}@ = nullptr;            // \expos
  public:
    constexpr ref_view() noexcept = default;

    template<@\placeholder{not-same-as}@<ref_view> T>
      requires @\seebelow@
    constexpr ref_view(T&& t);

    constexpr R& base() const { return *@\exposid{r_}@; }

    constexpr iterator_t<R> begin() const { return ranges::begin(*@\exposid{r_}@); }
    constexpr sentinel_t<R> end() const { return ranges::end(*@\exposid{r_}@); }

    constexpr bool empty() const
      requires requires { ranges::empty(*@\exposid{r_}@); }
    { return ranges::empty(*@\exposid{r_}@); }

    constexpr auto size() const requires sized_range<R>
    { return ranges::size(*@\exposid{r_}@); }

    constexpr auto data() const requires contiguous_range<R>
    { return ranges::data(*@\exposid{r_}@); }
  };
  template<class R>
    ref_view(R&) -> ref_view<R>;
}
\end{codeblock}

\indexlibraryglobal{ref_view}%
\begin{itemdecl}
template<@\placeholder{not-same-as}@<ref_view> T>
  requires @\seebelow@
constexpr ref_view(T&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Let \tcode{\placeholder{FUN}} denote the exposition-only functions
\begin{codeblock}
void @\placeholder{FUN}@(R&);
void @\placeholder{FUN}@(R&&) = delete;
\end{codeblock}
The expression in the \grammarterm{requires-clause} is equivalent to
\begin{codeblock}
convertible_to<T, R&> && requires { @\placeholder{FUN}@(declval<T>()); }
\end{codeblock}

\pnum
\effects
Initializes \exposid{r_} with
\tcode{addressof(static_cast<R\&>(std::forward<T>(t)))}.
\end{itemdescr}


\rSec2[range.filter]{Filter view}

\rSec3[range.filter.overview]{Overview}

\pnum
\tcode{filter_view} presents a \libconcept{view} of the elements
of an underlying sequence that satisfy a predicate.

\pnum
The name \tcode{views::filter} denotes a
range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{P},
the expression \tcode{views::filter(E, P)} is expression-equivalent to
\tcode{filter_view\{E, P\}}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
filter_view evens{is, [](int i) { return 0 == i % 2; }};
for (int i : evens)
  cout << i << ' '; // prints: 0 2 4 6
\end{codeblock}
\end{example}

\rSec3[range.filter.view]{Class template \tcode{filter_view}}

\indexlibraryglobal{filter_view}%
\indexlibrarymember{base}{filter_view}%
\indexlibrarymember{end}{filter_view}%
\begin{codeblock}
namespace std::ranges {
  template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
    requires view<V> && is_object_v<Pred>
  class filter_view : public view_interface<filter_view<V, Pred>> {
  private:
    V @\exposid{base_}@ = V();                      // \expos
    @\placeholdernc{semiregular-box}@<Pred> @\exposid{pred_}@;  // \expos

    // \ref{range.filter.iterator}, class \tcode{filter_view::\exposid{iterator}}
    class @\exposid{iterator}@;                     // \expos
    // \ref{range.filter.sentinel}, class \tcode{filter_view::\exposid{sentinel}}
    class @\exposid{sentinel}@;                     // \expos

  public:
    filter_view() = default;
    constexpr filter_view(V base, Pred pred);
    template<input_range R>
      requires viewable_range<R> && constructible_from<V, all_view<R>>
    constexpr filter_view(R&& r, Pred pred);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr @\exposid{iterator}@ begin();
    constexpr auto end() {
      if constexpr (common_range<V>)
        return @\exposid{iterator}@{*this, ranges::end(@\exposid{base_}@)};
      else
        return @\exposid{sentinel}@{*this};
    }
  };

  template<class R, class Pred>
    filter_view(R&&, Pred) -> filter_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibraryctor{filter_view}%
\begin{itemdecl}
constexpr filter_view(V base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and initializes
\exposid{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibraryctor{filter_view}%
\begin{itemdecl}
template<input_range R>
  requires viewable_range<R> && constructible_from<V, all_view<R>>
constexpr filter_view(R&& r, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}
and initializes \exposid{pred_} with \tcode{std::\brk{}move(pred)}.
\end{itemdescr}

\indexlibrarymember{begin}{filter_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{pred_.has_value()}.

\pnum
\returns
\tcode{\{*this, ranges::find_if(\exposid{base_}, ref(*\exposid{pred_}))\}}.

\pnum
\remarks
In order to provide the amortized constant time complexity required by
the \libconcept{range} concept
when \tcode{filter_view} models \libconcept{forward_range},
this function caches the result within the
\tcode{filter_view} for use on subsequent calls.
\end{itemdescr}

\rSec3[range.filter.iterator]{Class \tcode{filter_view::\exposid{iterator}}}

\indexlibrarymember{iterator}{filter_view}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pred>
  class filter_view<V, Pred>::@\exposid{iterator}@ {
  private:
    iterator_t<V> @\exposid{current_}@ = iterator_t<V>();   // \expos
    filter_view* @\exposid{parent_}@ = nullptr;             // \expos
  public:
    using iterator_concept  = @\seebelow@;
    using iterator_category = @\seebelow@;
    using value_type        = range_value_t<V>;
    using difference_type   = range_difference_t<V>;

    @\exposid{iterator}@() = default;
    constexpr @\exposid{iterator}@(filter_view& parent, iterator_t<V> current);

    constexpr iterator_t<V> base() const &
      requires copyable<iterator_t<V>>;
    constexpr iterator_t<V> base() &&;
    constexpr range_reference_t<V> operator*() const;
    constexpr iterator_t<V> operator->() const
      requires @\placeholder{has-arrow}@<iterator_t<V>> && copyable<iterator_t<V>>;

    constexpr @\exposid{iterator}@& operator++();
    constexpr void operator++(int);
    constexpr @\exposid{iterator}@ operator++(int) requires forward_range<V>;

    constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<V>;
    constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<V>;

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires equality_comparable<iterator_t<V>>;

    friend constexpr range_rvalue_reference_t<V> iter_move(const @\exposid{iterator}@& i)
      noexcept(noexcept(ranges::iter_move(i.@\exposid{current_}@)));
    friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      noexcept(noexcept(ranges::iter_swap(x.@\exposid{current_}@, y.@\exposid{current_}@)))
      requires indirectly_swappable<iterator_t<V>>;
  };
}
\end{codeblock}

\pnum
Modification of the element a \tcode{filter_view::\exposid{iterator}} denotes is
permitted, but results in undefined behavior if the resulting value does not
satisfy the filter predicate.

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{bidirectional_range}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{forward_range}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<V>>::iterator_category}.

\item If \tcode{C} models
\tcode{\libconcept{derived_from}<bidirectional_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{bi\-directional_iterator_tag}.

\item Otherwise, if  \tcode{C} models
\tcode{\libconcept{derived_from}<forward_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_category} denotes \tcode{C}.
\end{itemize}

\indexlibraryctor{filter_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@(filter_view& parent, iterator_t<V> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{current_} with \tcode{std::move(current)} and
\exposid{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrarymember{base}{filter_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<V> base() const &
  requires copyable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{current_};}
\end{itemdescr}

\indexlibrarymember{base}{filter_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<V> base() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::move(current_);}
\end{itemdescr}

\indexlibrarymember{operator*}{filter_view::iterator}%
\begin{itemdecl}
constexpr range_reference_t<V> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator->}{filter_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<V> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<V>> && copyable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator++}{filter_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{current_}@ = ranges::find_if(std::move(++@\exposid{current_}@), ranges::end(@\exposid{parent_}@->@\exposid{base_}@),
                           ref(*@\exposid{parent_}@->@\exposid{pred_}@));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{filter_view::iterator}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{filter_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator++(int) requires forward_range<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{filter_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
do
  --@\exposid{current_}@;
while (!invoke(*@\exposid{parent_}@->@\exposid{pred_}@, *@\exposid{current_}@));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{filter_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{filter_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires equality_comparable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{iter_move}{filter_view::iterator}%
\begin{itemdecl}
friend constexpr range_rvalue_reference_t<V> iter_move(const @\exposid{iterator}@& i)
  noexcept(noexcept(ranges::iter_move(i.@\exposid{current_}@)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return ranges::iter_move(i.\exposid{current_});}
\end{itemdescr}

\indexlibrarymember{iter_swap}{filter_view::iterator}%
\begin{itemdecl}
friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  noexcept(noexcept(ranges::iter_swap(x.@\exposid{current_}@, y.@\exposid{current_}@)))
  requires indirectly_swappable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{ranges::iter_swap(x.\exposid{current_}, y.\exposid{current_})}.
\end{itemdescr}

\rSec3[range.filter.sentinel]{Class \tcode{filter_view::\exposid{sentinel}}}

\indexlibrarymember{sentinel}{filter_view}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pred>
  class filter_view<V, Pred>::@\exposid{sentinel}@ {
  private:
    sentinel_t<V> @\exposid{end_}@ = sentinel_t<V>();       // \expos
  public:
    @\exposid{sentinel}@() = default;
    constexpr explicit @\exposid{sentinel}@(filter_view& parent);

    constexpr sentinel_t<V> base() const;

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{sentinel}@& y);
  };
}
\end{codeblock}

\indexlibraryctor{filter_view::sentinel}%
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(filter_view& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{ranges::end(parent.\exposid{base_})}.
\end{itemdescr}

\indexlibrarymember{base}{filter_view::sentinel}%
\begin{itemdecl}
constexpr sentinel_t<V> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{end_};}
\end{itemdescr}

\indexlibrarymember{operator==}{filter_view::sentinel}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{end_};}
\end{itemdescr}

\rSec2[range.transform]{Transform view}

\rSec3[range.transform.overview]{Overview}

\pnum
\tcode{transform_view} presents
a \libconcept{view} of an underlying sequence after
applying a transformation function to each element.

\pnum
The name \tcode{views::transform} denotes a
range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F}, the expression
\tcode{views::transform(E, F)} is expression-equivalent to
\tcode{transform_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4 };
transform_view squares{is, [](int i) { return i * i; }};
for (int i : squares)
  cout << i << ' '; // prints: 0 1 4 9 16
\end{codeblock}
\end{example}

\rSec3[range.transform.view]{Class template \tcode{transform_view}}

\indexlibraryglobal{transform_view}%
\indexlibrarymember{base}{transform_view}%
\indexlibrarymember{size}{transform_view}%
\begin{codeblock}
namespace std::ranges {
  template<input_range V, copy_constructible F>
    requires view<V> && is_object_v<F> &&
             regular_invocable<F&, range_reference_t<V>>
  class transform_view : public view_interface<transform_view<V, F>> {
  private:
    // \ref{range.transform.iterator}, class template \tcode{transform_view::\exposid{iterator}}
    template<bool> struct @\exposid{iterator}@;             // \expos
    // \ref{range.transform.sentinel}, class template \tcode{transform_view::\exposid{sentinel}}
    template<bool> struct @\exposid{sentinel}@;             // \expos

    V @\exposid{base_}@ = V();                              // \expos
    @\placeholdernc{semiregular-box}@<F> @\exposid{fun_}@;                    // \expos

  public:
    transform_view() = default;
    constexpr transform_view(V base, F fun);
    template<input_range R>
      requires viewable_range<R> && constructible_from<V, all_view<R>>
    constexpr transform_view(R&& r, F fun);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr @\exposid{iterator}@<false> begin();
    constexpr @\exposid{iterator}@<true> begin() const
      requires range<const V> &&
               regular_invocable<const F&, range_reference_t<const V>>;

    constexpr @\exposid{sentinel}@<false> end();
    constexpr @\exposid{iterator}@<false> end() requires common_range<V>;
    constexpr @\exposid{sentinel}@<true> end() const
      requires range<const V> &&
               regular_invocable<const F&, range_reference_t<const V>>;
    constexpr @\exposid{iterator}@<true> end() const
      requires common_range<const V> &&
               regular_invocable<const F&, range_reference_t<const V>>;

    constexpr auto size() requires sized_range<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires sized_range<const V>
    { return ranges::size(@\exposid{base_}@); }
  };

  template<class R, class F>
    transform_view(R&&, F) -> transform_view<all_view<R>, F>;
}
\end{codeblock}

\indexlibraryctor{transform_view}%
\begin{itemdecl}
constexpr transform_view(V base, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and
\exposid{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibraryctor{transform_view}%
\begin{itemdecl}
template<input_range R>
  requires viewable_range<R> && constructible_from<V, all_view<R>>
constexpr transform_view(R&& r, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}
and \exposid{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibrarymember{begin}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@<false> begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{iterator}@<false>{*this, ranges::begin(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{begin}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@<true> begin() const
  requires range<const V> &&
           regular_invocable<const F&, range_reference_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{iterator}@<true>{*this, ranges::begin(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{end}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@<false> end();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{sentinel}@<false>{ranges::end(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{end}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@<false> end() requires common_range<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{iterator}@<false>{*this, ranges::end(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{end}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@<true> end() const
  requires range<const V> &&
           regular_invocable<const F&, range_reference_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{sentinel}@<true>{ranges::end(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{end}{transform_view}%
\begin{itemdecl}
constexpr @\exposid{iterator}@<true> end() const
  requires common_range<const V> &&
           regular_invocable<const F&, range_reference_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return @\exposid{iterator}@<true>{*this, ranges::end(@\exposid{base_}@)};
\end{codeblock}
\end{itemdescr}

\rSec3[range.transform.iterator]{Class template \tcode{transform_view::\exposid{iterator}}}

\indexlibraryglobal{transform_view::iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class F>
  template<bool Const>
  class transform_view<V, F>::@\exposid{iterator}@ {
  private:
    using @\exposid{Parent}@ =                              // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using @\exposid{Base}@   =                              // \expos
      conditional_t<Const, const V, V>;
    iterator_t<@\exposid{Base}@> @\exposid{current_}@ =                 // \expos
      iterator_t<@\exposid{Base}@>();
    @\exposid{Parent}@* @\exposid{parent_}@ = nullptr;                  // \expos
  public:
    using iterator_concept  = @\seebelow@;
    using iterator_category = @\seebelow@;
    using value_type        =
      remove_cvref_t<invoke_result_t<F&, range_reference_t<@\exposid{Base}@>>>;
    using difference_type   = range_difference_t<@\exposid{Base}@>;

    @\exposid{iterator}@() = default;
    constexpr @\exposid{iterator}@(@\exposid{Parent}@& parent, iterator_t<@\exposid{Base}@> current);
    constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
      requires Const && convertible_to<iterator_t<V>, iterator_t<@\exposid{Base}@>>;

    constexpr iterator_t<@\exposid{Base}@> base() const &
      requires copyable<iterator_t<@\exposid{Base}@>>;
    constexpr iterator_t<@\exposid{Base}@> base() &&;
    constexpr decltype(auto) operator*() const
    { return invoke(*@\exposid{parent_}@->@\exposid{fun_}@, *@\exposid{current_}@); }

    constexpr @\exposid{iterator}@& operator++();
    constexpr void operator++(int);
    constexpr @\exposid{iterator}@ operator++(int) requires forward_range<@\exposid{Base}@>;

    constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<@\exposid{Base}@>;
    constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<@\exposid{Base}@>;

    constexpr @\exposid{iterator}@& operator+=(difference_type n)
      requires random_access_range<@\exposid{Base}@>;
    constexpr @\exposid{iterator}@& operator-=(difference_type n)
      requires random_access_range<@\exposid{Base}@>;
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range<@\exposid{Base}@>
    { return invoke(*@\exposid{parent_}@->@\exposid{fun_}@, @\exposid{current_}@[n]); }

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires equality_comparable<iterator_t<@\exposid{Base}@>>;

    friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr compare_three_way_result_t<iterator_t<@\exposid{Base}@>>
      operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@> && three_way_comparable<iterator_t<@\exposid{Base}@>>;

    friend constexpr @\exposid{iterator}@ operator+(@\exposid{iterator}@ i, difference_type n)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr @\exposid{iterator}@ operator+(difference_type n, @\exposid{iterator}@ i)
      requires random_access_range<@\exposid{Base}@>;

    friend constexpr @\exposid{iterator}@ operator-(@\exposid{iterator}@ i, difference_type n)
      requires random_access_range<@\exposid{Base}@>;
    friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{Base}@>;

    friend constexpr decltype(auto) iter_move(const @\exposid{iterator}@& i)
      noexcept(noexcept(invoke(*i.@\exposid{parent_}@->@\exposid{fun_}@, *i.@\exposid{current_}@)))
    {
      if constexpr (is_lvalue_reference_v<decltype(*i)>)
        return std::move(*i);
      else
        return *i;
    }

    friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      noexcept(noexcept(ranges::iter_swap(x.@\exposid{current_}@, y.@\exposid{current_}@)))
      requires indirectly_swappable<iterator_t<@\exposid{Base}@>>;
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{random_access_range}, then
\tcode{iterator_concept} denotes \tcode{random_access_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{bidirectional_range}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{forward_range}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<\exposid{Base}>>::iterator_category}.
If \tcode{C} models \tcode{\libconcept{derived_from}<contiguous_iterator_tag>},
then \tcode{iterator_category} denotes
\tcode{random_access_iterator_tag}; otherwise,
\tcode{iterator_category} denotes \tcode{C}.

\indexlibrarymember{iterator}{transform_view::iterator}
\begin{itemdecl}
constexpr @\exposid{iterator}@(@\exposid{Parent}@& parent, iterator_t<@\exposid{Base}@> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{current_} with \tcode{std::move(current)} and
\exposid{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibraryctor{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
  requires Const && convertible_to<iterator_t<V>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{current_} with \tcode{std::move(i.\exposid{current_})} and
\exposid{parent_} with \tcode{i.\exposid{parent_}}.
\end{itemdescr}

\indexlibrarymember{base}{transform_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<@\exposid{Base}@> base() const &
  requires copyable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{current_};}
\end{itemdescr}

\indexlibrarymember{base}{transform_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<@\exposid{Base}@> base() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::move(current_);}
\end{itemdescr}

\indexlibrarymember{operator++}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
++@\exposid{current_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{transform_view::iterator}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{++current_}.
\end{itemdescr}

\indexlibrarymember{operator++}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator++(int) requires forward_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
--@\exposid{current_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+=}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator+=(difference_type n)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{current_}@ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator-=}{transform_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator-=(difference_type n)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{current_}@ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires equality_comparable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator<}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} < y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator>}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\indexlibrarymember{operator<=}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\indexlibrarymember{operator>=}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\indexlibrarymember{operator<=>}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr compare_three_way_result_t<iterator_t<@\exposid{Base}@>>
  operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires random_access_range<@\exposid{Base}@> && three_way_comparable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} <=> y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator+}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator+(@\exposid{iterator}@ i, difference_type n)
  requires random_access_range<@\exposid{Base}@>;
friend constexpr @\exposid{iterator}@ operator+(difference_type n, @\exposid{iterator}@ i)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{*i.\exposid{parent_}, i.\exposid{current_} + n\};}
\end{itemdescr}

\indexlibrarymember{operator-}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator-(@\exposid{iterator}@ i, difference_type n)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{*i.\exposid{parent_}, i.\exposid{current_} - n\};}
\end{itemdescr}

\indexlibrarymember{operator-}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} - y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{iter_swap}{transform_view::iterator}%
\begin{itemdecl}
friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  noexcept(noexcept(ranges::iter_swap(x.\exposid{current_}, y.\exposid{current_})))
  requires indirectly_swappable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{ranges::iter_swap(x.\exposid{current_}, y.\exposid{current_})}.
\end{itemdescr}


\rSec3[range.transform.sentinel]{Class template \tcode{transform_view::\exposid{sentinel}}}

\indexlibraryglobal{transform_view::sentinel}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class F>
  template<bool Const>
  class transform_view<V, F>::@\exposid{sentinel}@ {
  private:
    using @\exposid{Parent}@ =                                      // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using @\exposid{Base}@ = conditional_t<Const, const V, V>;      // \expos
    sentinel_t<@\exposid{Base}@> @\exposid{end_}@ = sentinel_t<@\exposid{Base}@>();         // \expos
  public:
    @\exposid{sentinel}@() = default;
    constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
    constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> i)
      requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;

    constexpr sentinel_t<@\exposid{Base}@> base() const;

    friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);

    friend constexpr range_difference_t<@\exposid{Base}@>
      operator-(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y)
        requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
    friend constexpr range_difference_t<@\exposid{Base}@>
      operator-(const @\exposid{sentinel}@& y, const @\exposid{iterator}@<Const>& x)
        requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
  };
}
\end{codeblock}

\indexlibraryctor{transform_view::sentinel}%
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{end}.
\end{itemdescr}

\indexlibraryctor{transform_view::sentinel}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> i)
  requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{std::move(i.\exposid{end_})}.
\end{itemdescr}

\indexlibrarymember{base}{transform_view::sentinel}
\begin{itemdecl}
constexpr sentinel_t<@\exposid{Base}@> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{end_};}
\end{itemdescr}

\indexlibrarymember{operator==}{transform_view::sentinel}
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{end_};}
\end{itemdescr}

\indexlibrarymember{operator-}{transform_view::sentinel}%
\begin{itemdecl}
friend constexpr range_difference_t<@\exposid{Base}@>
  operator-(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y)
    requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} - y.\exposid{end_};}
\end{itemdescr}

\indexlibrarymember{operator-}{transform_view::sentinel}%
\begin{itemdecl}
friend constexpr range_difference_t<@\exposid{Base}@>
  operator-(const @\exposid{sentinel}@& y, const @\exposid{iterator}@<Const>& x)
    requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{end_} - y.\exposid{current_};}
\end{itemdescr}

\rSec2[range.take]{Take view}

\rSec3[range.take.overview]{Overview}

\pnum
\tcode{take_view} produces a \libconcept{view} of the first $N$ elements
from another \libconcept{view}, or all the elements if the adapted
\libconcept{view} contains fewer than $N$.

\pnum
The name \tcode{views::take} denotes a
range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F}, the expression
\tcode{views::take(E, F)} is expression-equivalent to
\tcode{take_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{0,1,2,3,4,5,6,7,8,9};
take_view few{is, 5};
for (int i : few)
  cout << i << ' '; // prints: 0 1 2 3 4
\end{codeblock}
\end{example}

\rSec3[range.take.view]{Class template \tcode{take_view}}

\indexlibraryglobal{take_view}%
\indexlibrarymember{base}{take_view}%
\indexlibrarymember{begin}{take_view}%
\indexlibrarymember{end}{take_view}%
\indexlibrarymember{size}{take_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V>
  class take_view : public view_interface<take_view<V>> {
  private:
    V @\exposid{base_}@ = V();                                      // \expos
    range_difference_t<V> @\exposid{count_}@ = 0;                   // \expos
    // \ref{range.take.sentinel}, class template \tcode{take_view::\exposid{sentinel}}
    template<bool> struct @\exposid{sentinel}@;                     // \expos
  public:
    take_view() = default;
    constexpr take_view(V base, range_difference_t<V> count);
    template<viewable_range R>
      requires constructible_from<V, all_view<R>>
    constexpr take_view(R&& r, range_difference_t<V> count);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin() requires (!@\placeholder{simple-view}@<V>) {
      if constexpr (sized_range<V>) {
        if constexpr (random_access_range<V>)
          return ranges::begin(@\exposid{base_}@);
        else
          return counted_iterator{ranges::begin(@\exposid{base_}@), size()};
      } else
        return counted_iterator{ranges::begin(@\exposid{base_}@), @\exposid{count_}@};
    }

    constexpr auto begin() const requires range<const V> {
      if constexpr (sized_range<const V>) {
        if constexpr (random_access_range<const V>)
          return ranges::begin(@\exposid{base_}@);
        else
          return counted_iterator{ranges::begin(@\exposid{base_}@), size()};
      } else
        return counted_iterator{ranges::begin(@\exposid{base_}@), @\exposid{count_}@};
    }

    constexpr auto end() requires (!@\placeholder{simple-view}@<V>) {
      if constexpr (sized_range<V>) {
        if constexpr (random_access_range<V>)
          return ranges::begin(@\exposid{base_}@) + size();
        else
          return default_sentinel;
      } else
        return @\exposid{sentinel}@<false>{ranges::end(@\exposid{base_}@)};
    }

    constexpr auto end() const requires range<const V> {
      if constexpr (sized_range<const V>) {
        if constexpr (random_access_range<const V>)
          return ranges::begin(@\exposid{base_}@) + size();
        else
          return default_sentinel;
      } else
        return @\exposid{sentinel}@<true>{ranges::end(@\exposid{base_}@)};
    }

    constexpr auto size() requires sized_range<V> {
      auto n = ranges::size(@\exposid{base_}@);
      return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
    }

    constexpr auto size() const requires sized_range<const V> {
      auto n = ranges::size(@\exposid{base_}@);
      return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
    }
  };

  template<range R>
    take_view(R&&, range_difference_t<R>)
      -> take_view<all_view<R>>;
}
\end{codeblock}

\indexlibraryctor{take_view}%
\begin{itemdecl}
constexpr take_view(V base, range_difference_t<V> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and
\exposid{count_} with \tcode{count}.
\end{itemdescr}

\indexlibraryctor{take_view}%
\begin{itemdecl}
template<viewable_range R>
  requires constructible_from<V, all_view<R>>
constexpr take_view(R&& r, range_difference_t<V> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}
and \exposid{count_} with \tcode{count}.
\end{itemdescr}

\rSec3[range.take.sentinel]{Class template \tcode{take_view::\exposid{sentinel}}}

\indexlibraryglobal{take_view::sentinel}%
\begin{codeblock}
namespace std::ranges {
  template<class V>
  template<bool Const>
  class take_view<V>::@\exposid{sentinel}@ {
  private:
    using @\exposid{Base}@ = conditional_t<Const, const V, V>;      // \expos
    using @\exposid{CI}@ = counted_iterator<iterator_t<@\exposid{Base}@>>;      // \expos
    sentinel_t<@\exposid{Base}@> @\exposid{end_}@ = sentinel_t<@\exposid{Base}@>();         // \expos
  public:
    @\exposid{sentinel}@() = default;
    constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
    constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
      requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;

    constexpr sentinel_t<@\exposid{Base}@> base() const;

    friend constexpr bool operator==(const @\exposid{CI}@& y, const @\exposid{sentinel}@& x);
  };
}
\end{codeblock}

\indexlibraryctor{take_view::sentinel}%
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{end}.
\end{itemdescr}

\indexlibraryctor{take_view::sentinel}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
  requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{std::move(s.\exposid{end_})}.
\end{itemdescr}

\indexlibrarymember{base}{take_view::sentinel}%
\begin{itemdecl}
constexpr sentinel_t<@\exposid{Base}@> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{end_};}
\end{itemdescr}

\indexlibrarymember{operator==}{take_view::sentinel}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{CI}@& y, const @\exposid{sentinel}@& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return y.count() == 0 || y.base() == x.\exposid{end_};}
\end{itemdescr}

\rSec2[range.take.while]{Take while view}

\rSec3[range.take.while.overview]{Overview}

\pnum
Given a unary predicate \tcode{pred} and a \tcode{view} \tcode{r},
\tcode{take_while_view} produces a \tcode{view}
of the range \range{begin(r)}{ranges::find_if_not(r, pred)}.

\indexlibraryglobal{take_while}%
\pnum
The name \tcode{views::take_while} denotes
a range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::take_while(E, F)}
is expression-equivalent to \tcode{take_while_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
auto input = istringstream{"0 1 2 3 4 5 6 7 8 9"};
auto small = [](const auto x) noexcept { return x < 5; };
auto small_ints = istream_view<int>(input) | views::take_while(small);
for (const auto i : small_ints) {
  cout << i << ' ';                             // prints \tcode{0 1 2 3 4}
}
auto i = 0;
input >> i;
cout << i;                                      // prints \tcode{6}
\end{codeblock}
\end{example}

\rSec3[range.take.while.view]{Class template \tcode{take_while_view}}

\indexlibraryglobal{take_while_view}%
\indexlibrarymember{base}{take_while_view}%
\indexlibrarymember{begin}{take_while_view}%
\indexlibrarymember{end}{take_while_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V, class Pred>
  requires input_range<V> && is_object_v<Pred> &&
    indirect_unary_predicate<const Pred, iterator_t<V>>
  class take_while_view : public view_interface<take_while_view<V, Pred>> {
    // \ref{range.take.while.sentinel}, class template \tcode{take_while_view::\exposid{sentinel}}
    template<bool> class @\exposid{sentinel}@;                      // \expos

    V @\exposid{base_}@;                                            // \expos
    @\placeholder{semiregular-box}@<Pred> @\exposid{pred_}@; @\itcorr[-1]@                       // \expos

  public:
    take_while_view() = default;
    constexpr take_while_view(V base, Pred pred);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr const Pred& pred() const;

    constexpr auto begin() requires (!@\placeholder{simple-view}@<V>)
    { return ranges::begin(@\exposid{base_}@); }

    constexpr auto begin() const requires range<const V>
    { return ranges::begin(@\exposid{base_}@); }

    constexpr auto end() requires (!@\placeholder{simple-view}@<V>)
    { return @\exposid{sentinel}@<false>(ranges::end(@\exposid{base_}@), addressof(*@\exposid{pred_}@)); }

    constexpr auto end() const requires range<const V>
    { return @\exposid{sentinel}@<true>(ranges::end(@\exposid{base_}@), addressof(*@\exposid{pred_}@)); }
  };

  template<class R, class Pred>
    take_while_view(R&&, Pred) -> take_while_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibraryctor{take_while_view}%
\begin{itemdecl}
constexpr take_while_view(V base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and
\exposid{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrarymember{pred}{take_while_view}%
\begin{itemdecl}
constexpr const Pred& pred() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *\exposid{pred_};}
\end{itemdescr}

\rSec3[range.take.while.sentinel]{Class template \tcode{take_while_view::\exposid{sentinel}}}

\indexlibraryglobal{take_while_view::sentinel}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pred>
  template<bool Const>
  class take_while_view<V, Pred>::@\exposid{sentinel}@ {            // \expos
    using @\exposid{base-t}@ = conditional_t<Const, const V, V>;    // \expos

    sentinel_t<@\exposid{base-t}@> @\exposid{end_}@ = sentinel_t<@\exposid{base-t}@>();     // \expos
    const Pred* @\exposid{pred_}@ = nullptr;                        // \expos
  public:
    @\exposid{sentinel}@() = default;
    constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{base-t}@> end, const Pred* pred);
    constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
      requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{base-t}@>>;

    constexpr sentinel_t<@\exposid{base-t}@> base() const { return @\exposid{end_}@; }

    friend constexpr bool operator==(const iterator_t<@\exposid{base-t}@>& x, const @\exposid{sentinel}@& y);
  };
}
\end{codeblock}

\indexlibraryctor{take_while_view::sentinel}%
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{base-t}@> end, const Pred* pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{end} and \exposid{pred_} with \tcode{pred}.
\end{itemdescr}

\indexlibraryctor{take_while_view::sentinel}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
  requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{s.\exposid{end_}} and
\exposid{pred_} with \tcode{s.\exposid{pred_}}.
\end{itemdescr}

\indexlibrarymember{operator==}{take_while_view::sentinel}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator_t<@\exposid{base-t}@>& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return y.\exposid{end_} == x || !invoke(*y.\exposid{pred_}, *x);}
\end{itemdescr}

\rSec2[range.drop]{Drop view}

\rSec3[range.drop.overview]{Overview}

\pnum
\tcode{drop_view} produces a \tcode{view}
excluding the first $N$ elements from another \tcode{view}, or
an empty range if the adapted \tcode{view} contains fewer than $N$ elements.

\pnum
The name \tcode{views::drop} denotes
a range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::drop(E, F)}
is expression-equivalent to \tcode{drop_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
auto ints = views::iota(0) | views::take(10);
auto latter_half = drop_view{ints, 5};
for (auto i : latter_half) {
  cout << i << ' ';                             // prints \tcode{5 6 7 8 9}
}
\end{codeblock}
\end{example}

\rSec3[range.drop.view]{Class template \tcode{drop_view}}

\indexlibraryglobal{drop_view}%
\indexlibrarymember{base}{drop_view}%
\indexlibrarymember{end}{drop_view}%
\indexlibrarymember{size}{drop_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V>
  class drop_view : public view_interface<drop_view<V>> {
  public:
    drop_view() = default;
    constexpr drop_view(V base, range_difference_t<V> count);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin()
      requires (!(@\placeholder{simple-view}@<V> && random_access_range<V>));
    constexpr auto begin() const
      requires random_access_range<const V>;

    constexpr auto end()
      requires (!@\placeholder{simple-view}@<V>)
    { return ranges::end(@\exposid{base_}@); }

    constexpr auto end() const
      requires range<const V>
    { return ranges::end(@\exposid{base_}@); }

    constexpr auto size()
      requires sized_range<V>
    {
      const auto s = ranges::size(@\exposid{base_}@);
      const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
      return s < c ? 0 : s - c;
    }

    constexpr auto size() const
      requires sized_range<const V>
    {
      const auto s = ranges::size(@\exposid{base_}@);
      const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
      return s < c ? 0 : s - c;
    }
  private:
    V @\exposid{base_}@;                                    // \expos
    range_difference_t<V> @\exposid{count_}@;               // \expos
  };

  template<class R>
    drop_view(R&&, range_difference_t<R>) -> drop_view<all_view<R>>;
}
\end{codeblock}

\indexlibraryctor{drop_view}%
\begin{itemdecl}
constexpr drop_view(V base, range_difference_t<V> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{count >= 0} is \tcode{true}.

\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and
\exposid{count_} with \tcode{count}.
\end{itemdescr}

\indexlibrarymember{begin}{drop_view}%
\begin{itemdecl}
constexpr auto begin()
  requires (!(@\placeholder{simple-view}@<V> && random_access_range<V>));
constexpr auto begin() const
  requires random_access_range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ranges::next(ranges::begin(base_), count_, ranges::end(base_))}.

\pnum
\remarks
In order to provide the amortized constant-time complexity required
by the \tcode{range} concept
when \tcode{drop_view} models \libconcept{forward_range},
the first overload caches the result within the \tcode{drop_view}
for use on subsequent calls.
\begin{note}
Without this,
applying a \tcode{reverse_view} over a \tcode{drop_view}
would have quadratic iteration complexity.
\end{note}
\end{itemdescr}

\rSec2[range.drop.while]{Drop while view}

\rSec3[range.drop.while.overview]{Overview}

\pnum
Given a unary predicate \tcode{pred} and a \tcode{view} \tcode{r},
\tcode{drop_while_view} produces a \tcode{view}
of the range \range{ranges::find_if_not(r, pred)}{ranges::end(r)}.

\pnum
The name \tcode{views::drop_while}
denotes a range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::drop_while(E, F)}
is expression-equivalent to \tcode{drop_while_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
constexpr auto source = "  \t   \t   \t   hello there";
auto is_invisible = [](const auto x) { return x == ' ' || x == '\t'; };
auto skip_ws = drop_while_view{source, is_invisible};
for (auto c : skip_ws) {
  cout << c;                                    // prints \tcode{hello there} with no leading space
}
\end{codeblock}
\end{example}

\rSec3[range.drop.while.view]{Class template \tcode{drop_while_view}}

\indexlibraryglobal{drop_while_view}%
\indexlibrarymember{base}{drop_while_view}%
\indexlibrarymember{end}{drop_while_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V, class Pred>
  requires input_range<V> && is_object_v<Pred> &&
    indirect_unary_predicate<const Pred, iterator_t<V>>
  class drop_while_view : public view_interface<drop_while_view<V, Pred>> {
  public:
    drop_while_view() = default;
    constexpr drop_while_view(V base, Pred pred);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr const Pred& pred() const;

    constexpr auto begin();

    constexpr auto end()
    { return ranges::end(@\exposid{base_}@); }

  private:
    V @\exposid{base_}@;                                            // \expos
    @\placeholder{semiregular-box}@<Pred> @\exposid{pred_}@; @\itcorr[-1]@                       // \expos
  };

  template<class R, class Pred>
    drop_while_view(R&&, Pred) -> drop_while_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibraryctor{drop_while_view}%
\begin{itemdecl}
constexpr drop_while_view(V base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)} and
\exposid{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrarymember{pred}{drop_while_view}%
\begin{itemdecl}
constexpr const Pred& pred() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *\exposid{pred_};}
\end{itemdescr}

\indexlibrarymember{begin}{drop_while_view}%
\begin{itemdecl}
constexpr auto begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ranges::find_if_not(base_, cref(*pred_))}.

\pnum
\remarks
In order to provide the amortized constant-time complexity
required by the \tcode{range} concept
when \tcode{drop_while_view} models \tcode{forward_range},
the first call caches the result within the \tcode{drop_while_view}
for use on subsequent calls.
\begin{note}
Without this,
applying a \tcode{reverse_view} over a \tcode{drop_while_view}
would have quadratic iteration complexity.
\end{note}
\end{itemdescr}

\rSec2[range.join]{Join view}

\rSec3[range.join.overview]{Overview}

\pnum
\tcode{join_view} flattens a \libconcept{view} of ranges into a
\libconcept{view}.

\pnum
The name \tcode{views::join} denotes a
range adaptor object\iref{range.adaptor.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::join(E)} is expression-equivalent to
\tcode{join_view\{E\}}.

\pnum
\begin{example}
\begin{codeblock}
vector<string> ss{"hello", " ", "world", "!"};
join_view greeting{ss};
for (char ch : greeting)
  cout << ch;                                   // prints: \tcode{hello world!}
\end{codeblock}
\end{example}

\rSec3[range.join.view]{Class template \tcode{join_view}}

\indexlibraryglobal{join_view}%
\indexlibrarymember{base}{join_view}%
\indexlibrarymember{begin}{join_view}%
\indexlibrarymember{end}{join_view}%
\begin{codeblock}
namespace std::ranges {
  template<input_range V>
    requires view<V> && input_range<range_reference_t<V>> &&
             (is_reference_v<range_reference_t<V>> ||
              view<range_value_t<V>>)
  class join_view : public view_interface<join_view<V>> {
  private:
    using @\exposid{InnerRng}@ =                    // \expos
      range_reference_t<V>;
    // \ref{range.join.iterator}, class template \tcode{join_view::\exposid{iterator}}
    template<bool Const>
      struct @\exposid{iterator}@;                  // \expos
    // \ref{range.join.sentinel}, class template \tcode{join_view::\exposid{sentinel}}
    template<bool Const>
      struct @\exposid{sentinel}@;                  // \expos

    V @\exposid{base_}@ = V();                      // \expos
    all_view<@\exposid{InnerRng}@> @\exposid{inner_}@ =         // \expos, present only when \tcode{!is_reference_v<\exposid{InnerRng}>}
      all_view<@\exposid{InnerRng}@>();
  public:
    join_view() = default;
    constexpr explicit join_view(V base);

    template<input_range R>
      requires viewable_range<R> && constructible_from<V, all_view<R>>
    constexpr explicit join_view(R&& r);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin() {
      return @\exposid{iterator}@<@\placeholder{simple-view}@<V>>{*this, ranges::begin(@\exposid{base_}@)};
    }

    constexpr auto begin() const
    requires input_range<const V> &&
             is_reference_v<range_reference_t<const V>> {
      return @\exposid{iterator}@<true>{*this, ranges::begin(@\exposid{base_}@)};
    }

    constexpr auto end() {
      if constexpr (forward_range<V> &&
                    is_reference_v<@\exposid{InnerRng}@> && forward_range<@\exposid{InnerRng}@> &&
                    common_range<V> && common_range<@\exposid{InnerRng}@>)
        return @\exposid{iterator}@<@\placeholder{simple-view}@<V>>{*this, ranges::end(@\exposid{base_}@)};
      else
        return @\exposid{sentinel}@<@\placeholder{simple-view}@<V>>{*this};
    }

    constexpr auto end() const
    requires input_range<const V> &&
             is_reference_v<range_reference_t<const V>> {
      if constexpr (forward_range<const V> &&
                    is_reference_v<range_reference_t<const V>> &&
                    forward_range<range_reference_t<const V>> &&
                    common_range<const V> &&
                    common_range<range_reference_t<const V>>)
        return @\exposid{iterator}@<true>{*this, ranges::end(@\exposid{base_}@)};
      else
        return @\exposid{sentinel}@<true>{*this};
    }
  };

  template<class R>
    explicit join_view(R&&) -> join_view<all_view<R>>;
}
\end{codeblock}

\indexlibraryctor{join_view}%
\begin{itemdecl}
constexpr explicit join_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibraryctor{join_view}%
\begin{itemdecl}
template<input_range R>
  requires viewable_range<R> && constructible_from<V, all_view<R>>
constexpr explicit join_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}.
\end{itemdescr}

\rSec3[range.join.iterator]{Class template \tcode{join_view::\exposid{iterator}}}

\indexlibraryglobal{join_view::iterator}%
\begin{codeblock}
namespace std::ranges {
template<class V>
  template<bool Const>
  struct join_view<V>::@\exposid{iterator}@ {
  private:
    using @\exposid{Parent}@ =                                              // \expos
      conditional_t<Const, const join_view, join_view>;
    using @\exposid{Base}@   = conditional_t<Const, const V, V>;            // \expos

    static constexpr bool @\exposid{ref-is-glvalue}@ =                      // \expos
      is_reference_v<range_reference_t<@\exposid{Base}@>>;

    iterator_t<@\exposid{Base}@> @\exposid{outer_}@ = iterator_t<@\exposid{Base}@>();               // \expos
    iterator_t<range_reference_t<@\exposid{Base}@>> @\exposid{inner_}@ =                // \expos
      iterator_t<range_reference_t<@\exposid{Base}@>>();
    @\exposid{Parent}@* @\exposid{parent_}@ = nullptr;                                  // \expos

    constexpr void @\exposid{satisfy}@();                                   // \expos
  public:
    using iterator_concept  = @\seebelow@;
    using iterator_category = @\seebelow@;
    using value_type        = range_value_t<range_reference_t<@\exposid{Base}@>>;
    using difference_type   = @\seebelow@;

    @\exposid{iterator}@() = default;
    constexpr @\exposid{iterator}@(@\exposid{Parent}@& parent, iterator_t<V> outer);
    constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
      requires Const &&
               convertible_to<iterator_t<V>, iterator_t<@\exposid{Base}@>> &&
               convertible_to<iterator_t<@\exposid{InnerRng}@>,
                              iterator_t<range_reference_t<@\exposid{Base}@>>>;

    constexpr decltype(auto) operator*() const { return *@\exposid{inner_}@; }

    constexpr iterator_t<@\exposid{Base}@> operator->() const
      requires @\placeholder{has-arrow}@<iterator_t<@\exposid{Base}@>> && copyable<iterator_t<@\exposid{Base}@>>;

    constexpr @\exposid{iterator}@& operator++();
    constexpr void operator++(int);
    constexpr @\exposid{iterator}@ operator++(int)
      requires @\exposid{ref-is-glvalue}@ && forward_range<@\exposid{Base}@> &&
               forward_range<range_reference_t<@\exposid{Base}@>>;

    constexpr @\exposid{iterator}@& operator--()
      requires @\exposid{ref-is-glvalue}@ && bidirectional_range<@\exposid{Base}@> &&
               bidirectional_range<range_reference_t<@\exposid{Base}@>>;

    constexpr @\exposid{iterator}@ operator--(int)
      requires @\exposid{ref-is-glvalue}@ && bidirectional_range<@\exposid{Base}@> &&
               bidirectional_range<range_reference_t<@\exposid{Base}@>>;

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires @\exposid{ref-is-glvalue}@ && equality_comparable<iterator_t<@\exposid{Base}@>> &&
               equality_comparable<iterator_t<range_reference_t<@\exposid{Base}@>>>;

    friend constexpr decltype(auto) iter_move(const @\exposid{iterator}@& i)
    noexcept(noexcept(ranges::iter_move(i.@\exposid{inner_}@))) {
      return ranges::iter_move(i.@\exposid{inner_}@);
    }

    friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      noexcept(noexcept(ranges::iter_swap(x.@\exposid{inner_}@, y.@\exposid{inner_}@)));
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \exposid{ref-is-glvalue} is \tcode{true} and
  \exposid{Base} and \tcode{range_reference_t<\exposid{Base}>} each model
  \libconcept{bidirectional_range}, then \tcode{iterator_concept} denotes
  \tcode{bidirectional_iterator_tag}.
\item Otherwise, if \exposid{ref-is-glvalue} is \tcode{true} and
  \exposid{Base} and \tcode{range_reference_t<\exposid{Base}>}
  each model \libconceptx{for\-ward_range}{forward_range}, then \tcode{iterator_concept} denotes
  \tcode{forward_iterator_tag}.
\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item Let \placeholder{OUTERC} denote
  \tcode{iterator_traits<iterator_t<\exposid{Base}>>::iterator_category}, and
  let \placeholder{INNERC} denote
  \tcode{iterator_traits<iterator_t<range_reference_t<\exposid{Base}>>>::iterator_category}.
\item If \exposid{ref-is-glvalue} is \tcode{true} and
  \placeholder{OUTERC} and \placeholder{INNERC} each model
  \tcode{derived_from<bidirectional_iterator_tag>}, \tcode{iterator_category}
  denotes \tcode{bidirectional_iterator_tag}.
\item Otherwise, if \exposid{ref-is-glvalue} is \tcode{true} and
  \placeholder{OUTERC} and \placeholder{INNERC} each model
  \tcode{derived_from<for\-ward_iterator_tag>}, \tcode{iterator_category}
  denotes \tcode{forward_iterator_tag}.
\item Otherwise, if \placeholder{OUTERC} and \placeholder{INNERC} each model
  \tcode{\libconcept{derived_from}<input_iterator_tag>},
  \tcode{iterator_category} denotes \tcode{input_iterator_tag}.
\item Otherwise, \tcode{iterator_category} denotes \tcode{output_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::difference_type} denotes the type:
\begin{codeblock}
common_type_t<
  range_difference_t<@\exposid{Base}@>,
  range_difference_t<range_reference_t<@\exposid{Base}@>>>
\end{codeblock}

\pnum
\tcode{join_view} iterators use the \exposid{satisfy} function to skip over
empty inner ranges.

\begin{itemdecl}
constexpr void @\exposid{satisfy}@();       // \expos
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto update_inner = [this](range_reference_t<@\exposid{Base}@> x) -> auto& {
  if constexpr (@\exposid{ref-is-glvalue}@) // \tcode{x} is a reference
    return x;
  else
    return (@\exposid{parent_}@->@\exposid{inner_}@ = views::all(std::move(x)));
};

for (; @\exposid{outer_}@ != ranges::end(@\exposid{parent_}@->@\exposid{base_}@); ++@\exposid{outer_}@) {
  auto& inner = update_inner(*@\exposid{outer_}@);
  @\exposid{inner_}@ = ranges::begin(inner);
  if (@\exposid{inner_}@ != ranges::end(inner))
    return;
}
if constexpr (@\exposid{ref-is-glvalue}@)
  @\exposid{inner_}@ = iterator_t<range_reference_t<@\exposid{Base}@>>();
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@(@\exposid{Parent}@& parent, iterator_t<V> outer)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{outer_} with \tcode{std::move(outer)} and
\exposid{parent_} with \tcode{addressof(parent)}; then calls \tcode{\exposid{satisfy}()}.
\end{itemdescr}

\indexlibraryctor{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
  requires Const &&
           convertible_to<iterator_t<V>, iterator_t<@\exposid{Base}@>> &&
           convertible_to<iterator_t<@\exposid{InnerRng}@>,
                          iterator_t<range_reference_t<@\exposid{Base}@>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{outer_} with \tcode{std::move(i.\exposid{outer_})},
\exposid{inner_} with \tcode{std::move(i.\exposid{inner_})}, and
\exposid{parent_} with \tcode{i.\exposid{parent_}}.
\end{itemdescr}

\indexlibrarymember{operator->}{join_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<@\exposid{Base}@> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<@\exposid{Base}@>> && copyable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{return \exposid{inner_};}
\end{itemdescr}

\indexlibrarymember{operator++}{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{\placeholder{inner-range}} be:
\begin{itemize}
\item If \exposid{ref-is-glvalue} is \tcode{true}, \tcode{*\exposid{outer_}}.
\item Otherwise, \tcode{\exposid{parent_}->\exposid{inner_}}.
\end{itemize}

\pnum
\effects
Equivalent to:
\begin{codeblock}
auto&& inner_rng = @\placeholder{inner-range}@;
if (++@\exposid{inner_}@ == ranges::end(inner_rng)) {
  ++@\exposid{outer_}@;
  @\exposid{satisfy}@();
}
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{join_view::iterator}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{++*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator++(int)
  requires @\exposid{ref-is-glvalue}@ && forward_range<@\exposid{Base}@> &&
           forward_range<range_reference_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator--()
  requires @\exposid{ref-is-glvalue}@ && bidirectional_range<@\exposid{Base}@> &&
           bidirectional_range<range_reference_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if (@\exposid{outer_}@ == ranges::end(@\exposid{parent_}@->@\exposid{base_}@))
  @\exposid{inner_}@ = ranges::end(*--@\exposid{outer_}@);
while (@\exposid{inner_}@ == ranges::begin(*@\exposid{outer_}@))
  @\exposid{inner_}@ = ranges::end(*--@\exposid{outer_}@);
--@\exposid{inner_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{join_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator--(int)
  requires @\exposid{ref-is-glvalue}@ && bidirectional_range<@\exposid{Base}@> &&
           bidirectional_range<range_reference_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{join_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires @\exposid{ref-is-glvalue}@ && equality_comparable<iterator_t<@\exposid{Base}@>> &&
           equality_comparable<iterator_t<range_reference_t<@\exposid{Base}@>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return x.\exposid{outer_} == y.\exposid{outer_} \&\& x.\exposid{inner_} == y.\exposid{inner_};}
\end{itemdescr}

\indexlibrarymember{iter_swap}{join_view::iterator}%
\begin{itemdecl}
friend constexpr void iter_swap(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  noexcept(noexcept(ranges::iter_swap(x.@\exposid{inner_}@, y.@\exposid{inner_}@)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return ranges::iter_swap(x.\exposid{inner_}, y.\exposid{inner_});}
\end{itemdescr}

\rSec3[range.join.sentinel]{Class template \tcode{join_view::\exposid{sentinel}}}

\indexlibraryglobal{join_view::sentinel}%
\begin{codeblock}
namespace std::ranges {
  template<class V>
  template<bool Const>
  struct join_view<V>::@\exposid{sentinel}@ {
  private:
    using @\exposid{Parent}@ =                                      // \expos
      conditional_t<Const, const join_view, join_view>;
    using @\exposid{Base}@   = conditional_t<Const, const V, V>;    // \expos
    sentinel_t<@\exposid{Base}@> @\exposid{end_}@ = sentinel_t<@\exposid{Base}@>();         // \expos
  public:
    @\exposid{sentinel}@() = default;

    constexpr explicit @\exposid{sentinel}@(@\exposid{Parent}@& parent);
    constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
      requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;

    friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);
  };
}
\end{codeblock}

\indexlibraryctor{join_view::sentinel}%
\begin{itemdecl}
constexpr explicit @\exposid{sentinel}@(@\exposid{Parent}@& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{ranges::end(\exposid{parent_}.\exposid{base_})}.
\end{itemdescr}

\indexlibraryctor{join_view::sentinel}%
\begin{itemdecl}
constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> s)
  requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{end_} with \tcode{std::move(s.\exposid{end_})}.
\end{itemdescr}

\indexlibrarymember{operator==}{join_view::sentinel}%3431

\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{outer_} == y.\exposid{end_};}
\end{itemdescr}

\rSec2[range.split]{Split view}

\rSec3[range.split.overview]{Overview}

\pnum
\tcode{split_view} takes a \libconcept{view} and a delimiter, and splits
the \libconcept{view} into subranges on the delimiter. The delimiter can be
a single element or a \libconcept{view} of elements.

\pnum
The name \tcode{views::split} denotes a
range adaptor object\iref{range.adaptor.object}.
Given subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::split(E, F)} is expression-equivalent to
\tcode{split_view\{E, F\}}.

\pnum
\begin{example}
\begin{codeblock}
string str{"the quick brown fox"};
split_view sentence{str, ' '};
for (auto word : sentence) {
  for (char ch : word)
    cout << ch;
  cout << '*';
}
// The above prints: the*quick*brown*fox*
\end{codeblock}
\end{example}

\rSec3[range.split.view]{Class template \tcode{split_view}}

\indexlibraryglobal{split_view}%
\indexlibrarymember{base}{split_view}%
\indexlibrarymember{begin}{split_view}%
\indexlibrarymember{end}{split_view}%
\begin{codeblock}
namespace std::ranges {
  template<auto> struct @\exposid{require-constant}@;       // \expos

  template<class R>
  concept @\defexposconcept{tiny-range}@ =                          // \expos
    sized_range<R> &&
    requires { typename @\exposid{require-constant}@<remove_reference_t<R>::size()>; } &&
    (remove_reference_t<R>::size() <= 1);

  template<input_range V, forward_range Pattern>
    requires view<V> && view<Pattern> &&
             indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
             (forward_range<V> || @\exposconcept{tiny-range}@<Pattern>)
  class split_view : public view_interface<split_view<V, Pattern>> {
  private:
    V @\exposid{base_}@ = V();                              // \expos
    Pattern @\exposid{pattern_}@ = Pattern();               // \expos
    iterator_t<V> @\exposid{current_}@ = iterator_t<V>();   // \expos, present only if \tcode{!forward_range<V>}
    // \ref{range.split.outer}, class template \tcode{split_view::\exposid{outer-iterator}}
    template<bool> struct @\exposid{outer-iterator}@;       // \expos
    // \ref{range.split.inner}, class template \tcode{split_view::\exposid{inner-iterator}}
    template<bool> struct @\exposid{inner-iterator}@;       // \expos
  public:
    split_view() = default;
    constexpr split_view(V base, Pattern pattern);

    template<input_range R, forward_range P>
      requires constructible_from<V, all_view<R>> &&
               constructible_from<Pattern, all_view<P>>
    constexpr split_view(R&& r, P&& p);

    template<input_range R>
      requires constructible_from<V, all_view<R>> &&
               constructible_from<Pattern, single_view<range_value_t<R>>>
    constexpr split_view(R&& r, range_value_t<R> e);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin() {
      if constexpr (forward_range<V>)
        return @\exposid{outer-iterator}@<@\placeholder{simple-view}@<V>>{*this, ranges::begin(@\exposid{base_}@)};
      else {
        @\exposid{current_}@ = ranges::begin(@\exposid{base_}@);
        return @\exposid{outer-iterator}@<false>{*this};
      }
    }

    constexpr auto begin() const requires forward_range<V> && forward_range<const V> {
      return @\exposid{outer-iterator}@<true>{*this, ranges::begin(@\exposid{base_}@)};
    }

    constexpr auto end() requires forward_range<V> && common_range<V> {
      return @\exposid{outer-iterator}@<@\placeholder{simple-view}@<V>>{*this, ranges::end(@\exposid{base_}@)};
    }

    constexpr auto end() const {
      if constexpr (forward_range<V> && forward_range<const V> && common_range<const V>)
        return @\exposid{outer-iterator}@<true>{*this, ranges::end(@\exposid{base_}@)};
      else
        return default_sentinel;
    }
  };

  template<class R, class P>
    split_view(R&&, P&&) -> split_view<all_view<R>, all_view<P>>;

  template<input_range R>
    split_view(R&&, range_value_t<R>)
      -> split_view<all_view<R>, single_view<range_value_t<R>>>;
}
\end{codeblock}

\indexlibraryctor{split_view}%
\begin{itemdecl}
constexpr split_view(V base, Pattern pattern);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)}, and
\exposid{pattern_} with \tcode{std::move(pattern)}.
\end{itemdescr}

\indexlibraryctor{split_view}%
\begin{itemdecl}
template<input_range R, forward_range P>
  requires constructible_from<V, all_view<R>> &&
           constructible_from<Pattern, all_view<P>>
constexpr split_view(R&& r, P&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}, and
\exposid{pattern_} with \tcode{views::all(\brk{}std::forward<P>(p))}.
\end{itemdescr}

\indexlibraryctor{split_view}%
\begin{itemdecl}
template<input_range R>
  requires constructible_from<V, all_view<R>> &&
           constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr split_view(R&& r, range_value_t<R> e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}, and
\exposid{pattern_} with \tcode{single_view\{\brk{}std::move(e)\}}.
\end{itemdescr}

\rSec3[range.split.outer]{Class template \tcode{split_view::\exposid{outer-iterator}}}

\indexlibraryglobal{split_view::outer-iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::@\exposid{outer-iterator}@ {
  private:
    using @\exposid{Parent}@ =                          // \expos
      conditional_t<Const, const split_view, split_view>;
    using @\exposid{Base}@   =                          // \expos
      conditional_t<Const, const V, V>;
    @\exposid{Parent}@* @\exposid{parent_}@ = nullptr;              // \expos
    iterator_t<@\exposid{Base}@> @\exposid{current_}@ =             // \expos, present only if \tcode{V} models \libconcept{forward_range}
      iterator_t<@\exposid{Base}@>();

  public:
    using iterator_concept  =
      conditional_t<forward_range<@\exposid{Base}@>, forward_iterator_tag, input_iterator_tag>;
    using iterator_category = input_iterator_tag;
    // \ref{range.split.outer.value}, class \tcode{split_view::\exposid{outer-iterator}::value_type}
    struct value_type;
    using difference_type   = range_difference_t<@\exposid{Base}@>;

    @\exposid{outer-iterator}@() = default;
    constexpr explicit @\exposid{outer-iterator}@(@\exposid{Parent}@& parent)
      requires (!forward_range<@\exposid{Base}@>);
    constexpr @\exposid{outer-iterator}@(@\exposid{Parent}@& parent, iterator_t<@\exposid{Base}@> current)
      requires forward_range<@\exposid{Base}@>;
    constexpr @\exposid{outer-iterator}@(@\exposid{outer-iterator}@<!Const> i)
      requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;

    constexpr value_type operator*() const;

    constexpr @\exposid{outer-iterator}@& operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range<@\exposid{Base}@>) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }

    friend constexpr bool operator==(const @\exposid{outer-iterator}@& x, const @\exposid{outer-iterator}@& y)
      requires forward_range<@\exposid{Base}@>;

    friend constexpr bool operator==(const @\exposid{outer-iterator}@& x, default_sentinel_t);
  };
}
\end{codeblock}

\pnum
Many of the following specifications refer to the notional member
\placeholder{current} of \exposid{outer-iterator}.
\placeholder{current} is equivalent to \exposid{current_} if \tcode{V}
models \libconcept{forward_range}, and \tcode{\exposid{parent_}->\exposid{current_}} otherwise.

\indexlibraryctor{split_view::outer-iterator}%
\begin{itemdecl}
constexpr explicit @\exposid{outer-iterator}@(@\exposid{Parent}@& parent)
  requires (!forward_range<@\exposid{Base}@>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibraryctor{split_view::outer-iterator}%
\begin{itemdecl}
constexpr @\exposid{outer-iterator}@(@\exposid{Parent}@& parent, iterator_t<@\exposid{Base}@> current)
  requires forward_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{parent_} with \tcode{addressof(parent)}
and \exposid{current_} with \tcode{std::move(current)}.
\end{itemdescr}

\indexlibraryctor{split_view::outer-iterator}%
\begin{itemdecl}
constexpr @\exposid{outer-iterator}@(@\exposid{outer-iterator}@<!Const> i)
  requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{parent_} with \tcode{i.\exposid{parent_}} and
\exposid{current_} with \tcode{std::move(i.\exposid{current_})}.
\end{itemdescr}

\indexlibrarymember{operator*}{split_view::outer-iterator}%
\begin{itemdecl}
constexpr value_type operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return value_type\{*this\};}
\end{itemdescr}

\indexlibrarymember{operator++}{split_view::outer-iterator}%
\begin{itemdecl}
constexpr @\exposid{outer-iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
const auto end = ranges::end(@\exposid{parent_}@->@\exposid{base_}@);
if (@\exposid{current_}@ == end) return *this;
const auto [pbegin, pend] = subrange{@\exposid{parent_}@->@\exposid{pattern_}@};
if (pbegin == pend) ++@\exposid{current_}@;
else {
  do {
    auto [b, p] = ranges::mismatch(std::move(@\exposid{current_}@), end, pbegin, pend);
    @\exposid{current_}@ = std::move(b);
    if (p == pend) {
      break;            // The pattern matched; skip it
    }
  } while (++@\exposid{current_}@ != end);
}
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{split_view::outer-iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{outer-iterator}@& x, const @\exposid{outer-iterator}@& y)
  requires forward_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator==}{split_view::outer-iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{outer-iterator}@& x, default_sentinel_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == ranges::end(x.\exposid{parent_}->\exposid{base_});}
\end{itemdescr}

\rSec3[range.split.outer.value]{Class \tcode{split_view::\exposid{outer-iterator}::value_type}}

\indexlibraryglobal{split_view::outer-iterator::value_type}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::@\exposid{outer-iterator}@<Const>::value_type
    : view_interface<value_type> {
  private:
    @\exposid{outer-iterator}@ @\exposid{i_}@ = @\exposid{outer-iterator}@();               // \expos
  public:
    value_type() = default;
    constexpr explicit value_type(@\exposid{outer-iterator}@ i);

    constexpr @\exposid{inner-iterator}@<Const> begin() const requires copyable<@\exposid{outer-iterator}@>;
    constexpr @\exposid{inner-iterator}@<Const> begin() requires (!copyable<@\exposid{outer-iterator}@>);
    constexpr default_sentinel_t end() const;
  };
}
\end{codeblock}

\indexlibraryctor{split_view::outer-iterator::value_type}%
\begin{itemdecl}
constexpr explicit value_type(@\exposid{outer-iterator}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{i_} with \tcode{std::move(i)}.
\end{itemdescr}

\indexlibrarymember{begin}{split_view::outer-iterator::value_type}%
\begin{itemdecl}
constexpr @\exposid{inner-iterator}@<Const> begin() const requires copyable<@\exposid{outer-iterator}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{inner-iterator}<Const>\{\exposid{i_}\};}
\end{itemdescr}

\indexlibrarymember{begin}{split_view::outer-iterator::value_type}%
\begin{itemdecl}
constexpr @\exposid{inner-iterator}@<Const> begin() requires (!copyable<@\exposid{outer-iterator}@>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{inner-iterator}<Const>\{std::move(\exposid{i_})\};}
\end{itemdescr}
\indexlibrarymember{end}{split_view::outer-iterator::value_type}%
\begin{itemdecl}
constexpr default_sentinel_t end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return default_sentinel;}
\end{itemdescr}

\rSec3[range.split.inner]{Class template \tcode{split_view::\exposid{inner-iterator}}}

\indexlibraryglobal{split_view::inner-iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::@\exposid{inner-iterator}@ {
  private:
    using @\exposid{Base}@ = conditional_t<Const, const V, V>;      // \expos
    @\exposid{outer-iterator}@<Const> @\exposid{i_}@ = @\exposid{outer-iterator}@<Const>(); // \expos
    bool @\exposid{incremented_}@ = false;                          // \expos
  public:
    using iterator_concept  = typename @\exposid{outer-iterator}@<Const>::iterator_concept;
    using iterator_category = @\seebelow@;
    using value_type        = range_value_t<@\exposid{Base}@>;
    using difference_type   = range_difference_t<@\exposid{Base}@>;

    @\exposid{inner-iterator}@() = default;
    constexpr explicit @\exposid{inner-iterator}@(@\exposid{outer-iterator}@<Const> i);

    constexpr decltype(auto) operator*() const { return *@\exposid{i_}@.@\exposid{current_}@; }

    constexpr @\exposid{inner-iterator}@& operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range<V>) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }

    friend constexpr bool operator==(const @\exposid{inner-iterator}@& x, const @\exposid{inner-iterator}@& y)
      requires forward_range<@\exposid{Base}@>;

    friend constexpr bool operator==(const @\exposid{inner-iterator}@& x, default_sentinel_t);

    friend constexpr decltype(auto) iter_move(const @\exposid{inner-iterator}@& i)
    noexcept(noexcept(ranges::iter_move(i.@\exposid{i_}@.@\placeholdernc{current}@))) {
      return ranges::iter_move(i.@\exposid{i_}@.@\placeholdernc{current}@);
    }

    friend constexpr void iter_swap(const @\exposid{inner-iterator}@& x, const @\exposid{inner-iterator}@& y)
      noexcept(noexcept(ranges::iter_swap(x.@\exposid{i_}@.@\placeholdernc{current}, y.@\exposid{i_}@.\placeholdernc{current}@)))
      requires indirectly_swappable<iterator_t<@\exposid{Base}@>>;
  };
}
\end{codeblock}

\pnum
The \grammarterm{typedef-name} \tcode{iterator_category} denotes:
\begin{itemize}
\item
\tcode{forward_iterator_tag} if
\tcode{iterator_traits<iterator_t<\exposid{Base}>>::iterator_category} models \linebreak
\tcode{derived_from<forward_iterator_tag>};
\item otherwise, \tcode{iterator_traits<iterator_t<\exposid{Base}>>::iterator_category}.
\end{itemize}

\indexlibraryctor{split_view::inner-iterator}%
\begin{itemdecl}
constexpr explicit @\exposid{inner-iterator}@(@\exposid{outer-iterator}@<Const> i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{i_} with \tcode{std::move(i)}.
\end{itemdescr}

\indexlibrarymember{operator++}{split_view::inner-iterator}%
\begin{itemdecl}
constexpr @\exposid{inner-iterator}@& operator++() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{incremented_}@ = true;
if constexpr (!forward_range<@\exposid{Base}@>) {
  if constexpr (Pattern::size() == 0) {
    return *this;
  }
}
++@\exposid{i_}@.@\placeholder{current}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{split_view::inner-iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{inner-iterator}@& x, const @\exposid{inner-iterator}@& y)
  requires forward_range<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{i_}.\placeholder{current} == y.\exposid{i_}.\placeholder{current};}
\end{itemdescr}

\indexlibrarymember{operator==}{split_view::inner-iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{inner-iterator}@& x, default_sentinel_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto [pcur, pend] = subrange{x.@\exposid{i_}@.@\exposid{parent_}@->@\exposid{pattern_}@};
auto end = ranges::end(x.@\exposid{i_}@.@\exposid{parent_}@->@\exposid{base_}@);
if constexpr (@\exposconcept{tiny-range}@<Pattern>) {
  const auto & cur = x.@\exposid{i_}@.@\placeholder{current}@;
  if (cur == end) return true;
  if (pcur == pend) return x.@\exposid{incremented_}@;
  return *cur == *pcur;
} else {
  auto cur = x.@\exposid{i_}@.@\placeholder{current}@;
  if (cur == end) return true;
  if (pcur == pend) return x.@\exposid{incremented_}@;
  do {
    if (*cur != *pcur) return false;
    if (++pcur == pend) return true;
  } while (++cur != end);
  return false;
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{iter_swap}{split_view::inner-iterator}%
\begin{itemdecl}
friend constexpr void iter_swap(const @\exposid{inner-iterator}@& x, const @\exposid{inner-iterator}@& y)
  noexcept(noexcept(ranges::iter_swap(x.@\exposid{i_}@.@\placeholdernc{current}@, y.@\exposid{i_}@.@\placeholdernc{current}@)))
  requires indirectly_swappable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\tcode{ranges::iter_swap(x.\exposid{i_}.\placeholdernc{current}, y.\exposid{i_}.\placeholdernc{current})}.
\end{itemdescr}

\rSec2[range.counted]{Counted view}

\pnum
\indextext{range!counted}%
A counted view presents a \libconcept{view} of the elements
of the counted range\iref{iterator.requirements.general} \countedrange{i}{n}
for an iterator \tcode{i} and non-negative integer \tcode{n}.

\pnum
The name \tcode{views::counted} denotes a
customization point object\iref{customization.point.object}.
Let \tcode{E} and \tcode{F} be expressions,
and let \tcode{T} be \tcode{decay_t<decltype((E))>}.
Then the expression \tcode{views::counted(E, F)} is expression-equivalent to:
\begin{itemize}
\item If \tcode{T} models \libconcept{input_or_output_iterator} and
  \tcode{decltype((F))} models \tcode{\libconcept{convertible_to}<iter_differ\-ence_t<T>>},
  \begin{itemize}
  \item \tcode{subrange\{E, E + static_cast<iter_difference_t<T>>(F)\}}
    if \tcode{T} models \libconceptx{random_access_\-it\-er\-ator}{random_access_iterator}.
  \item Otherwise,
    \tcode{subrange\{counted_iterator\{E, F\}, default_sentinel\}}.
\end{itemize}

\item Otherwise, \tcode{views::counted(E, F)} is ill-formed.
  \begin{note}
  This case can result in substitution failure when \tcode{views::counted(E, F)}
  appears in the immediate context of a template instantiation.
  \end{note}
\end{itemize}

\rSec2[range.common]{Common view}

\rSec3[range.common.overview]{Overview}

\pnum
\tcode{common_view} takes a \libconcept{view} which has different types for
its iterator and sentinel and turns it into a \libconcept{view} of the same
elements with an iterator and sentinel of the same type.

\pnum
\begin{note}
\tcode{common_view} is useful for calling legacy algorithms that expect
a range's iterator and sentinel types to be the same.
\end{note}

\pnum
The name \tcode{views::common} denotes a
range adaptor object\iref{range.adaptor.object}.
Given a subexpression \tcode{E},
the expression \tcode{views::common(E)} is expression-equivalent to:
\begin{itemize}
\item \tcode{views::all(E)},
  if \tcode{decltype((E))} models \libconcept{common_range}
  and \tcode{views::all(E)} is a well-formed expression.

\item Otherwise, \tcode{common_view\{E\}}.
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
// Legacy algorithm:
template<class ForwardIterator>
size_t count(ForwardIterator first, ForwardIterator last);

template<forward_range R>
void my_algo(R&& r) {
  auto&& common = common_view{r};
  auto cnt = count(common.begin(), common.end());
  // ...
}
\end{codeblock}
\end{example}

\rSec3[range.common.view]{Class template \tcode{common_view}}

\indexlibraryglobal{common_view}%
\indexlibrarymember{base}{common_view}%
\indexlibrarymember{size}{common_view}%
\indexlibrarymember{begin}{common_view}%
\indexlibrarymember{end}{common_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V>
    requires (!common_range<V> && copyable<iterator_t<V>>)
  class common_view : public view_interface<common_view<V>> {
  private:
    V @\exposid{base_}@ = V();  // \expos
  public:
    common_view() = default;

    constexpr explicit common_view(V r);

    template<viewable_range R>
      requires (!common_range<R> && constructible_from<V, all_view<R>>)
    constexpr explicit common_view(R&& r);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin() {
      if constexpr (random_access_range<V> && sized_range<V>)
        return ranges::begin(@\exposid{base_}@);
      else
        return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::begin(@\exposid{base_}@));
    }

    constexpr auto begin() const requires range<const V> {
      if constexpr (random_access_range<const V> && sized_range<const V>)
        return ranges::begin(@\exposid{base_}@);
      else
        return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::begin(@\exposid{base_}@));
    }

    constexpr auto end() {
      if constexpr (random_access_range<V> && sized_range<V>)
        return ranges::begin(@\exposid{base_}@) + ranges::size(@\exposid{base_}@);
      else
        return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::end(@\exposid{base_}@));
    }

    constexpr auto end() const requires range<const V> {
      if constexpr (random_access_range<const V> && sized_range<const V>)
        return ranges::begin(@\exposid{base_}@) + ranges::size(@\exposid{base_}@);
      else
        return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::end(@\exposid{base_}@));
    }

    constexpr auto size() requires sized_range<V> {
      return ranges::size(@\exposid{base_}@);
    }
    constexpr auto size() const requires sized_range<const V> {
      return ranges::size(@\exposid{base_}@);
    }
  };

  template<class R>
    common_view(R&&) -> common_view<all_view<R>>;
}
\end{codeblock}

\indexlibraryctor{common_view}%
\begin{itemdecl}
constexpr explicit common_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibraryctor{common_view}%
\begin{itemdecl}
template<viewable_range R>
  requires (!common_range<R> && constructible_from<V, all_view<R>>)
constexpr explicit common_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}.
\end{itemdescr}

\rSec2[range.reverse]{Reverse view}

\rSec3[range.reverse.overview]{Overview}

\pnum
\tcode{reverse_view} takes a bidirectional \libconcept{view} and produces
another \libconcept{view} that iterates the same elements in reverse order.

\pnum
The name \tcode{views::reverse} denotes a
range adaptor object\iref{range.adaptor.object}.
Given a subexpression \tcode{E}, the expression
\tcode{views::reverse(E)} is expression-equivalent to:
\begin{itemize}
\item
  If the type of \tcode{E} is
  a (possibly cv-qualified) specialization of \tcode{reverse_view},
  equivalent to \tcode{E.base()}.
\item
  Otherwise, if the type of \tcode{E} is cv-qualified
\begin{codeblock}
subrange<reverse_iterator<I>, reverse_iterator<I>, K>
\end{codeblock}
  for some iterator type \tcode{I} and
  value \tcode{K} of type \tcode{subrange_kind},
  \begin{itemize}
  \item
    if \tcode{K} is \tcode{subrange_kind::sized}, equivalent to:
\begin{codeblock}
subrange<I, I, K>(E.end().base(), E.begin().base(), E.size())
\end{codeblock}
  \item
    otherwise, equivalent to:
\begin{codeblock}
subrange<I, I, K>(E.end().base(), E.begin().base())
\end{codeblock}
  \end{itemize}
  However, in either case \tcode{E} is evaluated only once.
\item
  Otherwise, equivalent to \tcode{reverse_view\{E\}}.
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
vector<int> is {0,1,2,3,4};
reverse_view rv {is};
for (int i : rv)
  cout << i << ' '; // prints: 4 3 2 1 0
\end{codeblock}
\end{example}

\rSec3[range.reverse.view]{Class template \tcode{reverse_view}}

\indexlibraryglobal{reverse_view}%
\indexlibrarymember{base}{reverse_view}%
\indexlibrarymember{size}{reverse_view}%
\begin{codeblock}
namespace std::ranges {
  template<view V>
    requires bidirectional_range<V>
  class reverse_view : public view_interface<reverse_view<V>> {
  private:
    V @\exposid{base_}@ = V();  // \expos
  public:
    reverse_view() = default;

    constexpr explicit reverse_view(V r);

    template<viewable_range R>
      requires bidirectional_range<R> && constructible_from<V, all_view<R>>
    constexpr explicit reverse_view(R&& r);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr reverse_iterator<iterator_t<V>> begin();
    constexpr reverse_iterator<iterator_t<V>> begin() requires common_range<V>;
    constexpr reverse_iterator<iterator_t<const V>> begin() const
      requires common_range<const V>;

    constexpr reverse_iterator<iterator_t<V>> end();
    constexpr reverse_iterator<iterator_t<const V>> end() const
      requires common_range<const V>;

    constexpr auto size() requires sized_range<V> {
      return ranges::size(@\exposid{base_}@);
    }
    constexpr auto size() const requires sized_range<const V> {
      return ranges::size(@\exposid{base_}@);
    }
  };

  template<class R>
    reverse_view(R&&) -> reverse_view<all_view<R>>;
}
\end{codeblock}

\indexlibraryctor{reverse_view}%
\begin{itemdecl}
constexpr explicit reverse_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibraryctor{reverse_view}%
\begin{itemdecl}
template<viewable_range R>
  requires bidirectional_range<R> && constructible_from<V, all_view<R>>
constexpr explicit reverse_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{views::all(std::forward<R>(r))}.
\end{itemdescr}

\indexlibrarymember{begin}{reverse_view}%
\begin{itemdecl}
constexpr reverse_iterator<iterator_t<V>> begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
make_reverse_iterator(ranges::next(ranges::begin(@\exposid{base_}@), ranges::end(@\exposid{base_}@)))
\end{codeblock}

\pnum
\remarks
In order to provide the amortized constant time complexity required by
the \libconcept{range} concept, this function caches the result within the
\tcode{reverse_view} for use on subsequent calls.
\end{itemdescr}

\indexlibrarymember{begin}{reverse_view}%
\begin{itemdecl}
constexpr reverse_iterator<iterator_t<V>> begin() requires common_range<V>;
constexpr reverse_iterator<iterator_t<const V>> begin() const
  requires common_range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return make_reverse_iterator(ranges::end(base_));}
\end{itemdescr}

\indexlibrarymember{end}{reverse_view}%
\begin{itemdecl}
constexpr reverse_iterator<iterator_t<V>> end();
constexpr reverse_iterator<iterator_t<const V>> end() const
  requires common_range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return make_reverse_iterator(ranges::begin(base_));}
\end{itemdescr}

\rSec2[range.elements]{Elements view}

\rSec3[range.elements.overview]{Overview}

\pnum
\tcode{elements_view} takes
a \tcode{view} of tuple-like values and a \tcode{size_t}, and
produces a \tcode{view} with a value-type of the $N^\text{th}$ element
of the adapted \tcode{view}'s value-type.

\pnum
The name \tcode{views::elements<N>} denotes
a range adaptor object\iref{range.adaptor.object}.
Given a subexpression \tcode{E} and constant expression \tcode{N},
the expression \tcode{views::elements<N>(E)} is expression-equivalent to
\tcode{elements_view<all_view<decltype((E))>, N>\{E\}}.

\begin{example}
\begin{codeblock}
auto historical_figures = map{
  {"Lovelace"sv, 1815},
  {"Turing"sv, 1912},
  {"Babbage"sv, 1791},
  {"Hamilton"sv, 1936}
};

auto names = historical_figures | views::elements<0>;
for (auto&& name : names) {
  cout << name << ' ';          // prints \tcode{Babbage Hamilton Lovelace Turing }
}

auto birth_years = historical_figures | views::elements<1>;
for (auto&& born : birth_years) {
  cout << born << ' ';          // prints \tcode{1791 1936 1815 1912 }
}
\end{codeblock}
\end{example}

\pnum
\tcode{keys_view} is an alias for \tcode{elements_view<all_view<R>, 0>}, and
is useful for extracting keys from associative containers.

\begin{example}
\begin{codeblock}
auto names = keys_view{historical_figures};
for (auto&& name : names) {
  cout << name << ' ';          // prints \tcode{Babbage Hamilton Lovelace Turing }
}
\end{codeblock}
\end{example}

\pnum
\tcode{values_view} is an alias for \tcode{elements_view<all_view<R>, 1>}, and
is useful for extracting values from associative containers.

\begin{example}
\begin{codeblock}
auto is_even = [](const auto x) { return x % 2 == 0; };
cout << ranges::count_if(values_view{historical_figures}, is_even);     // prints \tcode{2}
\end{codeblock}
\end{example}

\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}
namespace std::ranges {
  template<class T, size_t N>
  concept @\defexposconcept{has-tuple-element}@ =                   // \expos
    requires(T t) {
      typename tuple_size<T>::type;
      requires N < tuple_size_v<T>;
      typename tuple_element_t<N, T>;
      { get<N>(t) } -> const tuple_element_t<N, T>&;
    };


  template<input_range V, size_t N>
    requires view<V> && @\placeholder{has-tuple-element}@<range_value_t<V>, N> &&
      @\placeholder{has-tuple-element}@<remove_reference_t<range_reference_t<V>>, N>
  class elements_view : public view_interface<elements_view<V, N>> {
  public:
    elements_view() = default;
    constexpr explicit elements_view(V base);

    constexpr V base() const& requires copy_constructible<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }

    constexpr auto begin() requires (!@\placeholder{simple-view}@<V>)
    { return @\exposid{iterator}@<false>(ranges::begin(@\exposid{base_}@)); }

    constexpr auto begin() const requires @\placeholder{simple-view}@<V>
    { return @\exposid{iterator}@<true>(ranges::begin(@\exposid{base_}@)); }

    constexpr auto end() requires (!@\placeholder{simple-view}@<V>)
    { return ranges::end(@\exposid{base_}@); }

    constexpr auto end() const requires @\placeholder{simple-view}@<V>
    { return ranges::end(@\exposid{base_}@); }

    constexpr auto size() requires sized_range<V>
    { return ranges::size(@\exposid{base_}@); }

    constexpr auto size() const requires sized_range<const V>
    { return ranges::size(@\exposid{base_}@); }

  private:
    template<bool> struct @\exposid{iterator}@;                     // \expos
    V @\exposid{base_}@ = V();                                      // \expos
  };
}
\end{codeblock}

\indexlibraryctor{elements_view}%
\begin{itemdecl}
constexpr explicit elements_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\rSec3[range.elements.iterator]{Class template \tcode{elements_view::\exposid{iterator}}}

\indexlibraryglobal{elements_view::iterator}%
\begin{codeblock}
namespace std::ranges {
  template<class V, size_t N>
  template<bool Const>
  class elements_view<V, N>::@\exposid{iterator}@ {                 // \expos
    using @\exposid{base-t}@ = conditional_t<Const, const V, V>;    // \expos
    friend @\exposid{iterator}@<!Const>;

    iterator_t<@\exposid{base-t}@> @\exposid{current_}@;
  public:
    using iterator_category = typename iterator_traits<iterator_t<@\exposid{base-t}@>>::iterator_category;
    using value_type = remove_cvref_t<tuple_element_t<N, range_value_t<@\exposid{base-t}@>>>;
    using difference_type = range_difference_t<@\exposid{base-t}@>;

    @\exposid{iterator}@() = default;
    constexpr explicit @\exposid{iterator}@(iterator_t<@\exposid{base-t}@> current);
    constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
      requires Const && convertible_to<iterator_t<V>, iterator_t<@\exposid{base-t}@>>;

    constexpr iterator_t<@\exposid{base-t}@> base() const&
      requires copyable<iterator_t<@\exposid{base-t}@>>;
    constexpr iterator_t<@\exposid{base-t}@> base() &&;

    constexpr decltype(auto) operator*() const
    { return get<N>(*@\exposid{current_}@); }

    constexpr @\exposid{iterator}@& operator++();
    constexpr void operator++(int) requires (!forward_range<@\exposid{base-t}@>);
    constexpr @\exposid{iterator}@ operator++(int) requires forward_range<@\exposid{base-t}@>;

    constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<@\exposid{base-t}@>;
    constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<@\exposid{base-t}@>;

    constexpr @\exposid{iterator}@& operator+=(difference_type x)
      requires random_access_range<@\exposid{base-t}@>;
    constexpr @\exposid{iterator}@& operator-=(difference_type x)
      requires random_access_range<@\exposid{base-t}@>;

    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range<@\exposid{base-t}@>
    { return get<N>(*(@\exposid{current_}@ + n)); }

    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires equality_comparable<iterator_t<@\exposid{base-t}@>>;
    friend constexpr bool operator==(const @\exposid{iterator}@& x, const sentinel_t<@\exposid{base-t}@>& y);

    friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr bool operator<=(const @\exposid{iterator}@& y, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr compare_three_way_result_t<iterator_t<@\exposid{base-t}@>>
      operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{base-t}@> && three_way_comparable<iterator_t<@\exposid{base-t}@>>;

    friend constexpr @\exposid{iterator}@ operator+(const @\exposid{iterator}@& x, difference_type y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr @\exposid{iterator}@ operator+(difference_type x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr @\exposid{iterator}@ operator-(const @\exposid{iterator}@& x, difference_type y)
      requires random_access_range<@\exposid{base-t}@>;
    friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
      requires random_access_range<@\exposid{base-t}@>;

    friend constexpr difference_type
      operator-(const @\exposid{iterator}@<Const>& x, const sentinel_t<@\exposid{base-t}@>& y)
        requires sized_sentinel_for<sentinel_t<@\exposid{base-t}@>, iterator_t<@\exposid{base-t}@>>;
    friend constexpr difference_type
      operator-(const sentinel_t<@\exposid{base-t}@>& x, const @\exposid{iterator}@<Const>& y)
        requires sized_sentinel_for<sentinel_t<@\exposid{base-t}@>, iterator_t<@\exposid{base-t}@>>;
  };
}
\end{codeblock}

\indexlibraryctor{elements_view::iterator}%
\begin{itemdecl}
constexpr explicit @\exposid{iterator}@(iterator_t<@\exposid{base-t}@> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{current_} with \tcode{std::move(current)}.
\end{itemdescr}

\indexlibraryctor{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
  requires Const && convertible_to<iterator_t<V>, iterator_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \exposid{current_} with \tcode{std::move(i.\exposid{current_})}.
\end{itemdescr}

\indexlibrarymember{base}{elements_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<@\exposid{base-t}@> base() const&
  requires copyable<iterator_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \exposid{current_};}
\end{itemdescr}

\indexlibrarymember{base}{elements_view::iterator}%
\begin{itemdecl}
constexpr iterator_t<@\exposid{base-t}@> base() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return std::move(\exposid{current_});}
\end{itemdescr}

\indexlibrarymember{operator++}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
++@\exposid{current_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator++}{elements_view::iterator}%
\begin{itemdecl}
constexpr void operator++(int) requires (!forward_range<@\exposid{base-t}@>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{++\exposid{current_}}.
\end{itemdescr}

\indexlibrarymember{operator++}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator++(int) requires forward_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto temp = *this;
++@\exposid{current_}@;
return temp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator--}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
--@\exposid{current_}@;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator--}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
auto temp = *this;
--@\exposid{current_}@;
return temp;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+=}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator+=(difference_type n);
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{current_}@ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator-=}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@& operator-=(difference_type n)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
@\exposid{current_}@ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires equality_comparable<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator==}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator==(const @\exposid{iterator}@& x, const sentinel_t<@\exposid{base-t}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} == y;}
\end{itemdescr}

\indexlibrarymember{operator<}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} < y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator>}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\indexlibrarymember{operator<=}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\indexlibrarymember{operator>=}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\indexlibrarymember{operator<=>}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr compare_three_way_result_t<iterator_t<@\exposid{base-t}@>>
  operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires random_access_range<@\exposid{base-t}@> && three_way_comparable<iterator_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} <=> y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator+}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator+(const @\exposid{iterator}@& x, difference_type y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{x\} += y;}
\end{itemdescr}

\indexlibrarymember{operator+}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr @\exposid{iterator}@ operator+(difference_type x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return y + x;}
\end{itemdescr}

\indexlibrarymember{operator-}{elements_view::iterator}%
\begin{itemdecl}
constexpr @\exposid{iterator}@ operator-(const @\exposid{iterator}@& x, difference_type y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return iterator\{x\} -= y;}
\end{itemdescr}

\indexlibrarymember{operator-}{elements_view::iterator}%
\begin{itemdecl}
constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
  requires random_access_range<@\exposid{base-t}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} - y.\exposid{current_};}
\end{itemdescr}

\indexlibrarymember{operator-}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr difference_type
  operator-(const @\exposid{iterator}@<Const>& x, const sentinel_t<@\exposid{base-t}@>& y)
    requires sized_sentinel_for<sentinel_t<@\exposid{base-t}@>, iterator_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\exposid{current_} - y;}
\end{itemdescr}

\indexlibrarymember{operator-}{elements_view::iterator}%
\begin{itemdecl}
friend constexpr difference_type
  operator-(const sentinel_t<@\exposid{base-t}@>& x, const @\exposid{iterator}@<Const>& y)
    requires sized_sentinel_for<sentinel_t<@\exposid{base-t}@>, iterator_t<@\exposid{base-t}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return -(y - x);}
\end{itemdescr}
