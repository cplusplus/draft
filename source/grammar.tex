\infannex{gram}{Grammar summary}

\begin{paras}

\pnum
\index{grammar}%
\index{summary, syntax}%
This summary of \Cpp\  syntax is intended to be an aid to comprehension.
It is not an exact statement of the language.
In particular, the grammar described here accepts
a superset of valid \Cpp\  constructs.
Disambiguation rules (\ref{stmt.ambig}, \ref{dcl.spec}, \ref{class.member.lookup})
must be applied to distinguish expressions from declarations.
Further, access control, ambiguity, and type rules must be used
to weed out syntactically valid but meaningless constructs.

\rSec1[gram.key]{Keywords}

\pnum
\index{keyword}%
New context-dependent keywords are introduced into a program by
\tcode{typedef}~(\ref{dcl.typedef}),
\tcode{namespace}~(\ref{namespace.def}),
class~(Clause \ref{class}), enumeration~(\ref{dcl.enum}), and
\tcode{template}~(Clause \ref{temp})
declarations.

\begin{bnf}
typedef-name:\br
	identifier
\end{bnf}

\begin{bnf}
namespace-name:\br
	original-namespace-name\br
	namespace-alias

original-namespace-name:\br
	identifier

namespace-alias:\br
	identifier
\end{bnf}

\begin{bnf}
class-name:\br
	identifier\br
	simple-template-id
\end{bnf}

\begin{bnf}
enum-name:\br
	identifier
\end{bnf}

\begin{bnf}
template-name:\br
	identifier
\end{bnf}

Note that a
\grammarterm{typedef-name}\ 
naming a class is also a
\grammarterm{class-name}\ 
(\ref{class.name}).

\end{paras}

% machine generated after this line; do not edit
\rSec1[gram.lex]{Lexical conventions}

\begin{bnf}
\nontermdef{hex-quad}\br
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad
\end{bnf}


\begin{bnf}
\indextext{token!preprocessing|(}%
\nontermdef{preprocessing-token}\br
    header-name\br
    identifier\br
    pp-number\br
    character-literal\br
    user-defined-character-literal\br
    string-literal\br
    user-defined-string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{each non-white-space character that cannot be one of the above}
\end{bnf}


\begin{bnf}
\nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator\br
    punctuator
\end{bnf}


\begin{bnf}
\nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}


\begin{bnf}
\nontermdef{h-char-sequence}\br
    h-char\br
    h-char-sequence h-char
\end{bnf}


\begin{bnf}
\nontermdef{h-char}\br
    \textnormal{any member of the source character set except new-line and \terminal{>}}
\end{bnf}


\begin{bnf}
\nontermdef{q-char-sequence}\br
    q-char\br
    q-char-sequence q-char
\end{bnf}


\begin{bnf}
\nontermdef{q-char}\br
    \textnormal{any member of the source character set except new-line and \terminal{"}}
\end{bnf}


\begin{bnf}
\nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number digit\br
    pp-number identifier-nondigit\br
    pp-number \terminal{'} digit\br
    pp-number \terminal{'} nondigit\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{.}
\end{bnf}


\begin{bnf}
\nontermdef{identifier}\br
    identifier-nondigit\br
    identifier identifier-nondigit\br
    identifier digit
\end{bnf}


\begin{bnf}
\nontermdef{identifier-nondigit}\br
    nondigit\br
    universal-character-name\br
    \textnormal{other implementation-defined characters}
\end{bnf}


\begin{bnf}
\nontermdef{nondigit} \textnormal{one of}\br
    \terminal{a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z _}
\end{bnf}


\begin{bnf}
\nontermdef{digit} \textnormal{one of}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}


\begin{bnfkeywordtab}
\nontermdef{preprocessing-op-or-punc} \textnormal{one of}\br
\>\{ \>\} \>[ \>] \>\# \>\#\# \>( \>)\br
\><: \>:> \><\% \>\%> \>\%: \>\%:\%: \>; \>: \>.{..}\br
\>new \>delete \>? \>:: \>. \>.*\br
\>+ \>- \>* \>/ \>\% \>\^{} \>\& \>| \>\tilde\br
\>! \>= \>< \>> \>+= \>-= \>*= \>/= \>\%=\br
\>\^{}= \>\&= \>|= \>\shl \>\shr \>\shr= \>\shl= \>== \>!=\br
\><= \>>= \>\&\& \>|| \>++ \>-{-} \>, \>->* \>->\br
\>and \>and_eq \>bitand \>bitor \>compl \>not \>not_eq\br
\>or \>or_eq \>xor \>xor_eq
\end{bnfkeywordtab}

\begin{bnf}
\nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-literal\br
    string-literal\br
    boolean-literal\br
    pointer-literal\br
    user-defined-literal
\end{bnf}


\begin{bnf}
\nontermdef{integer-literal}\br
    decimal-literal integer-suffix\opt\br
    octal-literal integer-suffix\opt\br
    hexadecimal-literal integer-suffix\opt\br
    binary-literal integer-suffix\opt
\end{bnf}


\begin{bnf}
\nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal \terminal{'}\opt digit
\end{bnf}


\begin{bnf}
\nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal \terminal{'}\opt octal-digit
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-literal}\br
    \terminal{0x} hexadecimal-digit\br
    \terminal{0X} hexadecimal-digit\br
    hexadecimal-literal \terminal{'}\opt hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{binary-literal}\br
    \terminal{0b} binary-digit\br
    \terminal{0B} binary-digit\br
    binary-literal \terminal{'}\opt binary-digit
\end{bnf}


\begin{bnf}
\nontermdef{nonzero-digit} \textnormal{one of}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}


\begin{bnf}
\nontermdef{octal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}


\begin{bnf}
\nontermdef{binary-digit}\br
    \terminal{0}\br
    \terminal{1}
\end{bnf}


\begin{bnf}
\nontermdef{integer-suffix}\br
    unsigned-suffix long-suffix\opt \br
    unsigned-suffix long-long-suffix\opt \br
    long-suffix unsigned-suffix\opt \br
    long-long-suffix unsigned-suffix\opt
\end{bnf}


\begin{bnf}
\nontermdef{unsigned-suffix} \textnormal{one of}\br
    \terminal{u  U}
\end{bnf}


\begin{bnf}
\nontermdef{long-suffix} \textnormal{one of}\br
    \terminal{l  L}
\end{bnf}


\begin{bnf}
\nontermdef{long-long-suffix} \textnormal{one of}\br
    \terminal{ll  LL}
\end{bnf}


\begin{bnf}
\nontermdef{character-literal}\br
    \terminal{'} c-char-sequence \terminal{'}\br
    u\terminal{'} c-char-sequence \terminal{'}\br
    U\terminal{'} c-char-sequence \terminal{'}\br
    L\terminal{'} c-char-sequence \terminal{'}
\end{bnf}


\begin{bnf}
\nontermdef{c-char-sequence}\br
    c-char\br
    c-char-sequence c-char
\end{bnf}


\begin{bnftab}
\nontermdef{c-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the single-quote \terminal{'}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}


\begin{bnf}
\nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence
\end{bnf}


\begin{bnf}
\nontermdef{simple-escape-sequence} \textnormal{one of}\br
    \terminal{\textbackslash'}\quad\terminal{\textbackslash"}\quad\terminal{\textbackslash ?}\quad\terminal{\textbackslash\textbackslash}\br
    \terminal{\textbackslash a}\quad\terminal{\textbackslash b}\quad\terminal{\textbackslash f}\quad\terminal{\textbackslash n}\quad\terminal{\textbackslash r}\quad\terminal{\textbackslash t}\quad\terminal{\textbackslash v}
\end{bnf}


\begin{bnf}
\nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} hexadecimal-digit\br
    hexadecimal-escape-sequence hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{floating-literal}\br
    fractional-constant exponent-part\opt floating-suffix\opt\br
    digit-sequence exponent-part floating-suffix\opt
\end{bnf}


\begin{bnf}
\nontermdef{fractional-constant}\br
    digit-sequence\opt \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}


\begin{bnf}
\nontermdef{exponent-part}\br
    \terminal{e} sign\opt digit-sequence\br
    \terminal{E} sign\opt digit-sequence
\end{bnf}


\begin{bnf}
\nontermdef{sign} \textnormal{one of}\br
    \terminal{+  -}
\end{bnf}


\begin{bnf}
\nontermdef{digit-sequence}\br
    digit\br
    digit-sequence \terminal{'}\opt digit
\end{bnf}


\begin{bnf}
\nontermdef{floating-suffix} \textnormal{one of}\br
    \terminal{f  l  F  L}
\end{bnf}


\begin{bnf}
\nontermdef{string-literal}\br
    encoding-prefix\opt \terminal{"} s-char-sequence\opt \terminal{"}\br
    encoding-prefix\opt \terminal{R} raw-string
\end{bnf}


\begin{bnf}
\nontermdef{encoding-prefix}\br
  \terminal{u8}\br
  \terminal{u}\br
  \terminal{U}\br
  \terminal{L}
\end{bnf}


\begin{bnf}
\nontermdef{s-char-sequence}\br
    s-char\br
    s-char-sequence s-char
\end{bnf}


\begin{bnftab}
\nontermdef{s-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the double-quote \terminal{"}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}


\begin{bnf}
\nontermdef{raw-string}\br
    \terminal{"} d-char-sequence\opt \terminal{(} r-char-sequence\opt \terminal{)} d-char-sequence\opt \terminal{"}
\end{bnf}


\begin{bnf}
\nontermdef{r-char-sequence}\br
    r-char\br
    r-char-sequence r-char
\end{bnf}


\begin{bnftab}
\nontermdef{r-char}\br
\>\textnormal{any member of the source character set, except}\br
\>\>\textnormal{a right parenthesis \terminal{)} followed by the initial \nonterminal{d-char-sequence}}\br
\>\>\textnormal{(which may be empty) followed by a double quote \terminal{"}.}
\end{bnftab}


\begin{bnf}
\nontermdef{d-char-sequence}\br
    d-char\br
    d-char-sequence d-char
\end{bnf}


\begin{bnftab}
\nontermdef{d-char}\br
\>\textnormal{any member of the basic source character set except:}\br
\>\>\textnormal{space, the left parenthesis \terminal{(}, the right parenthesis \terminal{)}, the backslash \terminal{\textbackslash},}\br
\>\>\textnormal{and the control characters representing horizontal tab,}\br
\>\>\textnormal{vertical tab, form feed, and newline.}
\end{bnftab}


\begin{bnf}
\nontermdef{boolean-literal}\br
    \terminal{false}\br
    \terminal{true}
\end{bnf}


\begin{bnf}
\nontermdef{pointer-literal}\br
    \terminal{nullptr}
\end{bnf}


\begin{bnf}
\nontermdef{user-defined-literal}\br
    user-defined-integer-literal\br
    user-defined-floating-literal\br
    user-defined-string-literal\br
    user-defined-character-literal
\end{bnf}


\begin{bnf}
\nontermdef{user-defined-integer-literal}\br
    decimal-literal ud-suffix\br
    octal-literal ud-suffix\br
    hexadecimal-literal ud-suffix\br
    binary-literal ud-suffix
\end{bnf}


\begin{bnf}
\nontermdef{user-defined-floating-literal}\br
    fractional-constant exponent-part\opt ud-suffix\br
    digit-sequence exponent-part ud-suffix
\end{bnf}


\begin{bnf}
\nontermdef{user-defined-string-literal}\br
    string-literal ud-suffix
\end{bnf}


\begin{bnf}
\nontermdef{user-defined-character-literal}\br
    character-literal ud-suffix
\end{bnf}


\begin{bnf}
\nontermdef{ud-suffix}\br
    identifier
\end{bnf}


\rSec1[gram.basic]{Basic concepts}

\begin{bnf}
\nontermdef{translation-unit}\br
    declaration-seq\opt
\end{bnf}


\rSec1[gram.expr]{Expressions}

\begin{bnf}
\nontermdef{primary-expression}\br
    literal\br
    \terminal{this}\br
    \terminal{(} expression \terminal{)}\br
    id-expression\br
    lambda-expression
\end{bnf}


\begin{bnf}
\nontermdef{id-expression}\br
    unqualified-id\br
    qualified-id
\end{bnf}


\begin{bnf}
\nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    literal-operator-id\br
    \terminal{\tilde} class-name\br
    \terminal{\tilde} decltype-specifier\br
    template-id
\end{bnf}


\begin{bnf}
\nontermdef{qualified-id}\br
    nested-name-specifier \terminal{template}\opt unqualified-id
\end{bnf}


\begin{bnf}
\nontermdef{nested-name-specifier}\br
    \terminal{::}\br
    type-name \terminal{::}\br
    namespace-name \terminal{::}\br
    decltype-specifier \terminal{::}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \terminal{template}\opt simple-template-id \terminal{::}
\end{bnf}


\begin{bnf}
\nontermdef{lambda-expression}\br
    lambda-introducer lambda-declarator\opt compound-statement
\end{bnf}


\begin{bnf}
\nontermdef{lambda-introducer}\br
    \terminal{[} lambda-capture\opt \terminal{]}
\end{bnf}


\begin{bnf}
\nontermdef{lambda-capture}\br
    capture-default\br
    capture-list\br
    capture-default \terminal{,} capture-list
\end{bnf}


\begin{bnf}
\nontermdef{capture-default}\br
    \terminal{\&}\br
    \terminal{=}
\end{bnf}


\begin{bnf}
\nontermdef{capture-list}\br
    capture \terminal{...\opt}\br
    capture-list \terminal{,} capture \terminal{...\opt}
\end{bnf}


\begin{bnf}
\nontermdef{capture}\br
    simple-capture\br
    init-capture
\end{bnf}


\begin{bnf}
\nontermdef{simple-capture}\br
    identifier\br
    \terminal{\&} identifier\br
    \terminal{this}
\end{bnf}


\begin{bnf}
\nontermdef{init-capture}\br
    identifier initializer\br
    \terminal{\&} identifier initializer
\end{bnf}


\begin{bnf}
\nontermdef{lambda-declarator}\br
    \terminal{(} parameter-declaration-clause \terminal{)} \terminal{mutable}\opt\br
    \hspace*{\bnfindentinc}exception-specification\opt attribute-specifier-seq\opt trailing-return-type\opt
\end{bnf}


\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expression \terminal{]}\br
    postfix-expression \terminal{[} braced-init-list \terminal{]}\br
    postfix-expression \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
    typename-specifier \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier braced-init-list\br
    typename-specifier braced-init-list\br
    postfix-expression \terminal{. template}\opt id-expression\br
    postfix-expression \terminal{-> template}\opt id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{expression-list}\br
    initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{pseudo-destructor-name}\br
    nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name\br
    nested-name-specifier \terminal{template} simple-template-id \terminal{::\,\tilde} type-name\br
    nested-name-specifier\opt \terminal{\tilde} type-name\br
    \terminal{\tilde} decltype-specifier
\end{bnf}


\begin{bnf}
\nontermdef{unary-expression}\br
    postfix-expression\br
    \terminal{++} cast-expression\br
    \terminal{-{-}} cast-expression\br
    unary-operator cast-expression\br
    \terminal{sizeof} unary-expression\br
    \terminal{sizeof (} type-id \terminal{)}\br
    \terminal{sizeof ...} \terminal{(} identifier \terminal{)}\br
    \terminal{alignof (} type-id \terminal{)}\br
    noexcept-expression\br
    new-expression\br
    delete-expression
\end{bnf}


\begin{bnf}
\nontermdef{unary-operator} \textnormal{one of}\br
    \terminal{*  \&  +  -  !  \tilde}
\end{bnf}


\begin{bnf}
\nontermdef{new-expression}\br
    \terminal{::}\opt \terminal{new} new-placement\opt new-type-id new-initializer\opt \br
    \terminal{::}\opt \terminal{new} new-placement\opt \terminal{(} type-id \terminal{)} new-initializer\opt
\end{bnf}


\begin{bnf}
\nontermdef{new-placement}\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{new-type-id}\br
    type-specifier-seq new-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{new-declarator}\br
    ptr-operator new-declarator\opt \br
    noptr-new-declarator
\end{bnf}


\begin{bnf}
\nontermdef{noptr-new-declarator}\br
    \terminal{[} expression \terminal{]} attribute-specifier-seq\opt\br
    noptr-new-declarator \terminal{[} constant-expression \terminal{]} attribute-specifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{new-initializer}\br
    \terminal{(} expression-list\opt \terminal{)}\br
    braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{delete-expression}\br
    \terminal{::}\opt \terminal{delete} cast-expression\br
    \terminal{::}\opt \terminal{delete [ ]} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{noexcept-expression}\br
  \terminal{noexcept} \terminal{(} expression \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{cast-expression}\br
    unary-expression\br
    \terminal{(} type-id \terminal{)} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{pm-expression}\br
    cast-expression\br
    pm-expression \terminal{.*} cast-expression\br
    pm-expression \terminal{->*} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{multiplicative-expression}\br
    pm-expression\br
    multiplicative-expression \terminal{*} pm-expression\br
    multiplicative-expression \terminal{/} pm-expression\br
    multiplicative-expression \terminal{\%} pm-expression
\end{bnf}


\begin{bnf}
\nontermdef{additive-expression}\br
    multiplicative-expression\br
    additive-expression \terminal{+} multiplicative-expression\br
    additive-expression \terminal{-} multiplicative-expression
\end{bnf}


\begin{bnf}
\nontermdef{shift-expression}\br
    additive-expression\br
    shift-expression \terminal{\shl} additive-expression\br
    shift-expression \terminal{\shr} additive-expression
\end{bnf}


\begin{bnf}
\nontermdef{relational-expression}\br
    shift-expression\br
    relational-expression \terminal{<} shift-expression\br
    relational-expression \terminal{>} shift-expression\br
    relational-expression \terminal{<=} shift-expression\br
    relational-expression \terminal{>=} shift-expression
\end{bnf}


\begin{bnf}
\nontermdef{equality-expression}\br
    relational-expression\br
    equality-expression \terminal{==} relational-expression\br
    equality-expression \terminal{!=} relational-expression
\end{bnf}


\begin{bnf}
\nontermdef{and-expression}\br
    equality-expression\br
    and-expression \terminal{\&} equality-expression
\end{bnf}


\begin{bnf}
\nontermdef{exclusive-or-expression}\br
    and-expression\br
    exclusive-or-expression \terminal{\^{}} and-expression
\end{bnf}


\begin{bnf}
\nontermdef{inclusive-or-expression}\br
    exclusive-or-expression\br
    inclusive-or-expression \terminal{|} exclusive-or-expression
\end{bnf}


\begin{bnf}
\nontermdef{logical-and-expression}\br
    inclusive-or-expression\br
    logical-and-expression \terminal{\&\&} inclusive-or-expression
\end{bnf}


\begin{bnf}
\nontermdef{logical-or-expression}\br
    logical-and-expression\br
    logical-or-expression \terminal{$||$} logical-and-expression
\end{bnf}


\begin{bnf}
\nontermdef{conditional-expression}\br
    logical-or-expression\br
    logical-or-expression \terminal{?} expression \terminal{:} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{assignment-expression}\br
    conditional-expression\br
    logical-or-expression assignment-operator initializer-clause\br
    throw-expression
\end{bnf}


\begin{bnf}
\nontermdef{assignment-operator} \textnormal{one of}\br
    \terminal{=  *=  /=  \%=   +=  -=  \shr=  \shl=  \&=  \^{}=  |=}
\end{bnf}


\begin{bnf}
\nontermdef{expression}\br
    assignment-expression\br
    expression \terminal{,} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{constant-expression}\br
    conditional-expression
\end{bnf}


\rSec1[gram.stmt]{Statements}

\begin{bnf}
\nontermdef{statement}\br
    labeled-statement\br
    attribute-specifier-seq\opt expression-statement\br
    attribute-specifier-seq\opt compound-statement\br
    attribute-specifier-seq\opt selection-statement\br
    attribute-specifier-seq\opt iteration-statement\br
    attribute-specifier-seq\opt jump-statement\br
    declaration-statement\br
    attribute-specifier-seq\opt try-block
\end{bnf}


\begin{bnf}
\nontermdef{labeled-statement}\br
    attribute-specifier-seq\opt identifier \terminal{:} statement\br
    attribute-specifier-seq\opt \terminal{case} constant-expression \terminal{:} statement\br
    attribute-specifier-seq\opt \terminal{default :} statement
\end{bnf}


\begin{bnf}
\nontermdef{expression-statement}\br
    expression\opt \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{compound-statement}\br
    \terminal{\{} statement-seq\opt \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{statement-seq}\br
    statement\br
    statement-seq statement
\end{bnf}


\begin{bnf}
\nontermdef{selection-statement}\br
    \terminal{if (} condition \terminal{)} statement\br
    \terminal{if (} condition \terminal{)} statement \terminal{else} statement\br
    \terminal{switch (} condition \terminal{)} statement
\end{bnf}


\begin{bnf}
\nontermdef{condition}\br
    expression\br
    attribute-specifier-seq\opt decl-specifier-seq declarator \terminal{=} initializer-clause\br
    attribute-specifier-seq\opt decl-specifier-seq declarator braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{iteration-statement}\br
    \terminal{while (} condition \terminal{)} statement\br
    \terminal{do} statement \terminal{while (} expression \terminal{) ;}\br
    \terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement\br
    \terminal{for (} for-range-declaration \terminal{:} for-range-initializer \terminal{)} statement
\end{bnf}


\begin{bnf}
\nontermdef{for-init-statement}\br
    expression-statement\br
    simple-declaration
\end{bnf}


\begin{bnf}
\nontermdef{for-range-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq declarator
\end{bnf}


\begin{bnf}
\nontermdef{for-range-initializer}\br
    expression\br
    braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{jump-statement}\br
    \terminal{break ;}\br
    \terminal{continue ;}\br
    \terminal{return} expression\opt \terminal{;}\br
    \terminal{return} braced-init-list \terminal{;}\br
    \terminal{goto} identifier \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{declaration-statement}\br
    block-declaration
\end{bnf}


\rSec1[gram.dcl]{Declarations}

\begin{bnf}
\nontermdef{declaration-seq}\br
    declaration\br
    declaration-seq declaration
\end{bnf}


\begin{bnf}
\nontermdef{declaration}\br
    block-declaration\br
    function-definition\br
    template-declaration\br
    explicit-instantiation\br
    explicit-specialization\br
    linkage-specification\br
    namespace-definition\br
    empty-declaration\br
    attribute-declaration
\end{bnf}


\begin{bnf}
\nontermdef{block-declaration}\br
    simple-declaration\br
    asm-definition\br
    namespace-alias-definition\br
    using-declaration\br
    using-directive\br
    static_assert-declaration\br
    alias-declaration\br
    opaque-enum-declaration
\end{bnf}


\begin{bnf}
\nontermdef{alias-declaration}\br
    \terminal{using} identifier attribute-specifier-seq\opt \terminal{=} type-id \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{simple-declaration}\br
    decl-specifier-seq\opt init-declarator-list\opt \terminal{;}\br
    attribute-specifier-seq decl-specifier-seq\opt init-declarator-list \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{static_assert-declaration}\br
  \terminal{static_assert} \terminal{(} constant-expression \terminal{,} string-literal \terminal{)} \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{empty-declaration}\br
    \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{attribute-declaration}\br
    attribute-specifier-seq \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{decl-specifier}\br
    storage-class-specifier\br
    type-specifier\br
    function-specifier\br
    \terminal{friend}\br
    \terminal{typedef}\br
    \terminal{constexpr}
\end{bnf}


\begin{bnf}
\nontermdef{decl-specifier-seq}\br
    decl-specifier attribute-specifier-seq\opt\br
    decl-specifier decl-specifier-seq
\end{bnf}


\begin{bnf}
\nontermdef{storage-class-specifier}\br
    \terminal{register}\br
    \terminal{static}\br
    \terminal{thread_local}\br
    \terminal{extern}\br
    \terminal{mutable}
\end{bnf}


\begin{bnf}
\nontermdef{function-specifier}\br
    \terminal{inline}\br
    \terminal{virtual}\br
    \terminal{explicit}
\end{bnf}


\begin{bnf}
\nontermdef{typedef-name}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{type-specifier}\br
    trailing-type-specifier\br
    class-specifier\br
    enum-specifier
\end{bnf}


\begin{bnf}
\nontermdef{trailing-type-specifier}\br
  simple-type-specifier\br
  elaborated-type-specifier\br
  typename-specifier\br
  cv-qualifier
\end{bnf}


\begin{bnf}
\nontermdef{type-specifier-seq}\br
    type-specifier attribute-specifier-seq\opt\br
    type-specifier type-specifier-seq
\end{bnf}


\begin{bnf}
\nontermdef{trailing-type-specifier-seq}\br
  trailing-type-specifier attribute-specifier-seq\opt\br
  trailing-type-specifier trailing-type-specifier-seq
\end{bnf}


\begin{bnf}
\nontermdef{simple-type-specifier}\br
    nested-name-specifier\opt type-name\br
    nested-name-specifier \terminal{template} simple-template-id\br
    \terminal{char}\br
    \terminal{char16_t}\br
    \terminal{char32_t}\br
    \terminal{wchar_t}\br
    \terminal{bool}\br
    \terminal{short}\br
    \terminal{int}\br
    \terminal{long}\br
    \terminal{signed}\br
    \terminal{unsigned}\br
    \terminal{float}\br
    \terminal{double}\br
    \terminal{void}\br
    \terminal{auto}\br
    decltype-specifier
\end{bnf}


\begin{bnf}
\nontermdef{type-name}\br
    class-name\br
    enum-name\br
    typedef-name\br
    simple-template-id
\end{bnf}


\begin{bnf}
\nontermdef{decltype-specifier}\br
  \terminal{decltype} \terminal{(} expression \terminal{)}\br
  \terminal{decltype} \terminal{(} \terminal{auto} \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{elaborated-type-specifier}\br
    class-key attribute-specifier-seq\opt nested-name-specifier\opt identifier\br
    class-key simple-template-id\br
    class-key nested-name-specifier \terminal{template}\opt simple-template-id\br
    \terminal{enum} nested-name-specifier\opt identifier
\end{bnf}


\begin{bnf}
\nontermdef{enum-name}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{enum-specifier}\br
    enum-head \terminal{\{} enumerator-list\opt \terminal{\}}\br
    enum-head \terminal{\{} enumerator-list \terminal{, \}}
\end{bnf}


\begin{bnf}
\nontermdef{enum-head}\br
    enum-key attribute-specifier-seq\opt identifier\opt enum-base\opt\br
    enum-key attribute-specifier-seq\opt nested-name-specifier identifier\br
\hspace*{\bnfindentinc}enum-base\opt
\end{bnf}


\begin{bnf}
\nontermdef{opaque-enum-declaration}\br
    enum-key attribute-specifier-seq\opt identifier enum-base\opt \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{enum-key}\br
    \terminal{enum}\br
    \terminal{enum class}\br
    \terminal{enum struct}
\end{bnf}


\begin{bnf}
\nontermdef{enum-base}\br
    \terminal{:} type-specifier-seq
\end{bnf}


\begin{bnf}
\nontermdef{enumerator-list}\br
    enumerator-definition\br
    enumerator-list \terminal{,} enumerator-definition
\end{bnf}


\begin{bnf}
\nontermdef{enumerator-definition}\br
    enumerator\br
    enumerator \terminal{=} constant-expression
\end{bnf}


\begin{bnf}
\nontermdef{enumerator}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-name}\br
        original-namespace-name\br
        namespace-alias
\end{bnf}


\begin{bnf}
\nontermdef{original-namespace-name}\br
        identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-definition}\br
        named-namespace-definition\br
        unnamed-namespace-definition
\end{bnf}


\begin{bnf}
\nontermdef{named-namespace-definition}\br
        original-namespace-definition\br
        extension-namespace-definition
\end{bnf}


\begin{bnf}
\nontermdef{original-namespace-definition}\br
        \terminal{inline\opt} \terminal{namespace} identifier \terminal{\{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{extension-namespace-definition}\br
        \terminal{inline\opt} \terminal{namespace} original-namespace-name \terminal{\{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{unnamed-namespace-definition}\br
        \terminal{inline\opt} \terminal{namespace \{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{namespace-body}\br
        declaration-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{namespace-alias}\br
        identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-alias-definition}\br
        \terminal{namespace} identifier \terminal{=} qualified-namespace-specifier \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{qualified-namespace-specifier}\br
    nested-name-specifier\opt namespace-name
\end{bnf}


\begin{bnf}
\nontermdef{using-declaration}\br
    \terminal{using typename\opt} nested-name-specifier unqualified-id \terminal{;}\br
    \terminal{using ::} unqualified-id \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{using-directive}\br
    attribute-specifier-seq\opt \terminal{using  namespace} nested-name-specifier\opt namespace-name \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{asm-definition}\br
    \terminal{asm (} string-literal \terminal{) ;}
\end{bnf}


\begin{bnf}
\nontermdef{linkage-specification}\br
    \terminal{extern} string-literal \terminal{\{} declaration-seq\opt \terminal{\}}\br
    \terminal{extern} string-literal declaration
\end{bnf}


\begin{bnf}
\nontermdef{attribute-specifier-seq}\br
  attribute-specifier-seq\opt attribute-specifier
\end{bnf}


\begin{bnf}
\nontermdef{attribute-specifier}\br
  \terminal{[} \terminal{[} attribute-list \terminal{]} \terminal{]}\br
  alignment-specifier
\end{bnf}


\begin{bnf}
\nontermdef{alignment-specifier}\br
  \terminal{alignas (} type-id \terminal{...}\opt \terminal{)}\br
  \terminal{alignas (} constant-expression \terminal{...}\opt \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{attribute-list}\br
  attribute\opt\br
  attribute-list \terminal{,} attribute\opt\br
  attribute \terminal{...}\br
  attribute-list \terminal{,} attribute \terminal{...}
\end{bnf}


\begin{bnf}
\nontermdef{attribute}\br
    attribute-token attribute-argument-clause\opt
\end{bnf}


\begin{bnf}
\nontermdef{attribute-token}\br
    identifier\br
    attribute-scoped-token
\end{bnf}


\begin{bnf}
\nontermdef{attribute-scoped-token}\br
    attribute-namespace \terminal{::} identifier
\end{bnf}


\begin{bnf}
\nontermdef{attribute-namespace}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{attribute-argument-clause}\br
    \terminal{(} balanced-token-seq \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{balanced-token-seq}\br
    balanced-token\opt\br
    balanced-token-seq balanced-token
\end{bnf}


\begin{bnf}
\nontermdef{balanced-token}\br
    \terminal{(} balanced-token-seq \terminal{)}\br
    \terminal{[} balanced-token-seq \terminal{]}\br
    \terminal{\{} balanced-token-seq \terminal{\}}\br
    \textnormal{any \grammarterm{token} other than a parenthesis, a bracket, or a brace}
\end{bnf}


\rSec1[gram.decl]{Declarators}

\begin{bnf}
\nontermdef{init-declarator-list}\br
    init-declarator\br
    init-declarator-list \terminal{,} init-declarator
\end{bnf}


\begin{bnf}
\nontermdef{init-declarator}\br
    declarator initializer\opt
\end{bnf}


\begin{bnf}
\nontermdef{declarator}\br
    ptr-declarator\br
    noptr-declarator parameters-and-qualifiers trailing-return-type
\end{bnf}


\begin{bnf}
\nontermdef{ptr-declarator}\br
    noptr-declarator\br
    ptr-operator ptr-declarator
\end{bnf}


\begin{bnf}
\nontermdef{noptr-declarator}\br
    declarator-id attribute-specifier-seq\opt\br
    noptr-declarator parameters-and-qualifiers\br
    noptr-declarator \terminal{[} constant-expression\opt \terminal{]} attribute-specifier-seq\opt\br
    \terminal{(} ptr-declarator \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{parameters-and-qualifiers}\br
    \terminal{(} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt\br
\hspace*{\bnfindentinc}ref-qualifier\opt exception-specification\opt attribute-specifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{trailing-return-type}\br
    \terminal{->} trailing-type-specifier-seq abstract-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{ptr-operator}\br
    \terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt\br
    \terminal{\&} attribute-specifier-seq\opt\br
    \terminal{\&\&} attribute-specifier-seq\opt\br
    nested-name-specifier \terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{cv-qualifier-seq}\br
    cv-qualifier cv-qualifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{cv-qualifier}\br
    \terminal{const}\br
    \terminal{volatile}
\end{bnf}


\begin{bnf}
\nontermdef{ref-qualifier}\br
    \terminal{\&}\br
    \terminal{\&\&}
\end{bnf}


\begin{bnf}
\nontermdef{declarator-id}\br
    \terminal{...}\opt id-expression
\end{bnf}


\begin{bnf}
\nontermdef{type-id}\br
    type-specifier-seq abstract-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{abstract-declarator}\br
    ptr-abstract-declarator\br
    noptr-abstract-declarator\opt parameters-and-qualifiers trailing-return-type\br
    abstract-pack-declarator
\end{bnf}


\begin{bnf}
\nontermdef{ptr-abstract-declarator}\br
    noptr-abstract-declarator\br
    ptr-operator ptr-abstract-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{noptr-abstract-declarator}\br
    noptr-abstract-declarator\opt parameters-and-qualifiers\br
    noptr-abstract-declarator\opt \terminal{[} constant-expression\opt{} \terminal{]} attribute-specifier-seq\opt\br
    \terminal{(} ptr-abstract-declarator \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{abstract-pack-declarator}\br
    noptr-abstract-pack-declarator\br
    ptr-operator abstract-pack-declarator
\end{bnf}


\begin{bnf}
\nontermdef{noptr-abstract-pack-declarator}\br
    noptr-abstract-pack-declarator parameters-and-qualifiers\br
    noptr-abstract-pack-declarator \terminal{[} constant-expression\opt\ \terminal{]} attribute-specifier-seq\opt\br
    \terminal{...}
\end{bnf}


\begin{bnf}
\nontermdef{parameter-declaration-clause}\br
    parameter-declaration-list\opt ...\opt\br
    parameter-declaration-list \terminal{,} ...
\end{bnf}


\begin{bnf}
\nontermdef{parameter-declaration-list}\br
    parameter-declaration\br
    parameter-declaration-list \terminal{,} parameter-declaration
\end{bnf}


\begin{bnf}
\nontermdef{parameter-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq declarator\br
    attribute-specifier-seq\opt decl-specifier-seq declarator \terminal{=} initializer-clause\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt \terminal{=} initializer-clause
\end{bnf}


\begin{bnf}
\nontermdef{function-definition}\br
    attribute-specifier-seq\opt decl-specifier-seq\opt declarator virt-specifier-seq\opt function-body
\end{bnf}


\begin{bnf}
function-body:\br
    ctor-initializer\opt compound-statement\br
    function-try-block\br
    \terminal{= default ;}\br
    \terminal{= delete ;}
\end{bnf}


\begin{bnf}
\nontermdef{initializer}\br
    brace-or-equal-initializer\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{brace-or-equal-initializer}\br
    \terminal{=} initializer-clause\br
    braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{initializer-clause}\br
    assignment-expression\br
    braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{initializer-list}\br
    initializer-clause \terminal{...}\opt\br
    initializer-list \terminal{,} initializer-clause \terminal{...}\opt
\end{bnf}


\begin{bnf}
\nontermdef{braced-init-list}\br
    \terminal{\{} initializer-list \terminal{,\opt} \terminal{\}}\br
    \terminal{\{} \terminal{\}}
\end{bnf}


\rSec1[gram.class]{Classes}

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    simple-template-id
\end{bnf}


\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} member-specification\opt \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{class-head}\br
    class-key attribute-specifier-seq\opt class-head-name class-virt-specifier\opt base-clause\opt\br
    class-key attribute-specifier-seq\opt base-clause\opt
\end{bnf}


\begin{bnf}
\nontermdef{class-head-name}\br
    nested-name-specifier\opt class-name
\end{bnf}


\begin{bnf}
\nontermdef{class-virt-specifier}\br
    \terminal{final}
\end{bnf}


\begin{bnf}
\nontermdef{class-key}\br
    \terminal{class}\br
    \terminal{struct}\br
    \terminal{union}
\end{bnf}


\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration member-specification\opt\br
    access-specifier \terminal{:} member-specification\opt
\end{bnf}


\begin{bnf}
\nontermdef{member-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq\opt member-declarator-list\opt \terminal{;}\br
    function-definition\br
    using-declaration\br
    static_assert-declaration\br
    template-declaration\br
    alias-declaration\br
    empty-declaration
\end{bnf}


\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}


\begin{bnf}
\nontermdef{member-declarator}\br
    declarator virt-specifier-seq\opt pure-specifier\opt\br
    declarator brace-or-equal-initializer\opt\br
    identifier\opt attribute-specifier-seq\opt \terminal{:} constant-expression
\end{bnf}


\begin{bnf}
\nontermdef{virt-specifier-seq}\br
    virt-specifier\br
    virt-specifier-seq virt-specifier
\end{bnf}


\begin{bnf}
\nontermdef{virt-specifier}\br
    \terminal{override}\br
    \terminal{final}
\end{bnf}


\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{= 0}
\end{bnf}


\rSec1[gram.derived]{Derived classes}

\begin{bnf}
\nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
\nontermdef{base-specifier-list}\br
    base-specifier \terminal{...}\opt\br
    base-specifier-list \terminal{,} base-specifier \terminal{...}\opt
\end{bnf}


\begin{bnf}
\nontermdef{base-specifier}\br
    attribute-specifier-seq\opt base-type-specifier\br
    attribute-specifier-seq\opt \terminal{virtual} access-specifier\opt base-type-specifier\br
    attribute-specifier-seq\opt access-specifier \terminal{virtual}\opt base-type-specifier
\end{bnf}


\begin{bnf}
\nontermdef{class-or-decltype}\br
    nested-name-specifier\opt class-name\br
    decltype-specifier
\end{bnf}


\begin{bnf}
\nontermdef{base-type-specifier}\br
    class-or-decltype
\end{bnf}


\begin{bnf}
\nontermdef{access-specifier}\br
    \terminal{private}\br
    \terminal{protected}\br
    \terminal{public}
\end{bnf}


\rSec1[gram.special]{Special member functions}

\begin{bnf}
\nontermdef{conversion-function-id}\br
    \terminal{operator} conversion-type-id
\end{bnf}


\begin{bnf}
\nontermdef{conversion-type-id}\br
    type-specifier-seq conversion-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{conversion-declarator}\br
    ptr-operator conversion-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{ctor-initializer}\br
    \terminal{:} mem-initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer-list}\br
    mem-initializer \terminal{...}\opt\br
    mem-initializer \terminal{...}\opt \terminal{,} mem-initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer}\br
    mem-initializer-id \terminal{(} expression-list\opt \terminal{)}\br
    mem-initializer-id braced-init-list
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer-id}\br
    class-or-decltype\br
    identifier
\end{bnf}


\rSec1[gram.over]{Overloading}

\begin{bnf}
\nontermdef{operator-function-id}\br
    \terminal{operator} operator
\end{bnf}


\begin{bnfkeywordtab}
\nontermdef{operator} \textnormal{one of}\br
\>new\>delete\>new[]\>delete[]\br
\>+\>-\>*\>/\>\%\>\^{}\>\&\>|\>\~\br
\>!\>=\><\>>\>+=\>-=\>*=\>/=\>\%=\br
\>\^{}=\>\&=\>|=\>\shl\>\shr\>\shr=\>\shl=\>={=}\>!=\br
\><=\>>=\>\&\&\>|{|}\>++\>-{-}\>,\>->*\>->\br
\>(\,)\>[\,]
\end{bnfkeywordtab}

\begin{bnf}
\nontermdef{literal-operator-id}\br
    \terminal{operator} string-literal identifier\br
    \terminal{operator} user-defined-string-literal
\end{bnf}


\rSec1[gram.temp]{Templates}

\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{template <} template-parameter-list \terminal{>} declaration
\end{bnf}


\begin{bnf}
\nontermdef{template-parameter-list}\br
  template-parameter\br
  template-parameter-list \terminal{,} template-parameter
\end{bnf}


\begin{bnf}
\nontermdef{template-parameter}\br
  type-parameter\br
  parameter-declaration
\end{bnf}


\begin{bnf}
\nontermdef{type-parameter}\br
  \terminal{class} \terminal{...}\opt identifier\opt\br
  \terminal{class} identifier\opt \terminal{=} type-id\br
  \terminal{typename} \terminal{...}\opt identifier\opt\br
  \terminal{typename} identifier\opt \terminal{=} type-id\br
  \terminal{template <} template-parameter-list \terminal{> class} \terminal{...}\opt identifier\opt\br
  \terminal{template <} template-parameter-list \terminal{> class} identifier\opt \terminal{=} id-expression
\end{bnf}


\begin{bnf}
\nontermdef{simple-template-id}\br
  template-name \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}


\begin{bnf}
\nontermdef{template-id}\br
  simple-template-id\br
  operator-function-id \terminal{<} template-argument-list\opt \terminal{>}\br
  literal-operator-id \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}


\begin{bnf}
\nontermdef{template-name}\br
  identifier
\end{bnf}


\begin{bnf}
\nontermdef{template-argument-list}\br
  template-argument \terminal{...}\opt\br
  template-argument-list \terminal{,} template-argument \terminal{...}\opt
\end{bnf}


\begin{bnf}
\nontermdef{template-argument}\br
  constant-expression\br
  type-id\br
  id-expression
\end{bnf}


\begin{bnf}
\nontermdef{typename-specifier}\br
  \terminal{typename} nested-name-specifier identifier\br
  \terminal{typename} nested-name-specifier \terminal{template\opt} simple-template-id
\end{bnf}


\begin{bnf}
\nontermdef{explicit-instantiation}\br
  \terminal{extern\opt} \terminal{template} declaration
\end{bnf}


\begin{bnf}
\nontermdef{explicit-specialization}\br
  \terminal{template < >} declaration
\end{bnf}


\rSec1[gram.except]{Exception handling}

\begin{bnf}
\nontermdef{try-block}\br
    \terminal{try} compound-statement handler-seq
\end{bnf}


\begin{bnf}
\nontermdef{function-try-block}\br
    \terminal{try} ctor-initializer\opt compound-statement handler-seq
\end{bnf}


\begin{bnf}
\nontermdef{handler-seq}\br
    handler handler-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{handler}\br
    \terminal{catch (} exception-declaration \terminal{)} compound-statement
\end{bnf}


\begin{bnf}
\nontermdef{exception-declaration}\br
    attribute-specifier-seq\opt type-specifier-seq declarator\br
    attribute-specifier-seq\opt type-specifier-seq abstract-declarator\opt\br
    \terminal{...}
\end{bnf}


\begin{bnf}
\nontermdef{throw-expression}\br
    \terminal{throw}  assignment-expression\opt
\end{bnf}


\begin{bnf}
\nontermdef{exception-specification}\br
    dynamic-exception-specification\br
    noexcept-specification
\end{bnf}


\begin{bnf}
\nontermdef{dynamic-exception-specification}\br
    \terminal{throw (} type-id-list\opt \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{type-id-list}\br
    type-id \terminal{...}\opt\br
    type-id-list \terminal{,} type-id \terminal{...}\opt
\end{bnf}


\begin{bnf}
\nontermdef{noexcept-specification}\br
    \terminal{noexcept} \terminal{(} constant-expression \terminal{)}\br
    \terminal{noexcept}
\end{bnf}


\rSec1[gram.cpp]{Preprocessing directives}

\begin{bnf}
\nontermdef{preprocessing-file}\br
    group\opt
\end{bnf}


\begin{bnf}
\nontermdef{group}\br
    group-part\br
    group group-part
\end{bnf}


\begin{bnf}
\nontermdef{group-part}\br
    if-section\br
    control-line\br
    text-line\br
    \terminal{\#} non-directive
\end{bnf}


\begin{bnf}
\nontermdef{if-section}\br
    if-group elif-groups\opt else-group\opt endif-line
\end{bnf}


\begin{bnftab}
\nontermdef{if-group}\br
\>\terminal{\# if}\>\>constant-expression new-line group\opt\br
\>\terminal{\# ifdef}\>\>identifier new-line group\opt\br
\>\terminal{\# ifndef}\>\>identifier new-line group\opt
\end{bnftab}


\begin{bnf}
\nontermdef{elif-groups}\br
    elif-group\br
    elif-groups elif-group
\end{bnf}


\begin{bnftab}
\nontermdef{elif-group}\br
\>\terminal{\# elif}\>\>constant-expression new-line group\opt
\end{bnftab}


\begin{bnftab}
\nontermdef{else-group}\br
\>\terminal{\# else}\>\>new-line group\opt
\end{bnftab}


\begin{bnftab}
\nontermdef{endif-line}\br
\>\terminal{\# endif}\>\>new-line
\end{bnftab}


\begin{bnftab}
\nontermdef{control-line}\br
\>\terminal{\# include}\>\>pp-tokens new-line\br
\>\terminal{\# define}\>\>identifier replacement-list new-line\br
\>\terminal{\# define}\>\>identifier lparen identifier-list\opt \terminal{)} replacement-list new-line\br
\>\terminal{\# define}\>\>identifier lparen \terminal{... )} replacement-list new-line\br
\>\terminal{\# define}\>\>identifier lparen identifier-list, \terminal{... )} replacement-list new-line\br
\>\terminal{\# undef}\>\>identifier new-line\br
\>\terminal{\# line}\>\>pp-tokens new-line\br
\>\terminal{\# error}\>\>pp-tokens\opt new-line\br
\>\terminal{\# pragma}\>\>pp-tokens\opt new-line\br
\>\terminal{\# }new-line
\end{bnftab}


\begin{bnf}
\nontermdef{text-line}\br
    pp-tokens\opt{} new-line
\end{bnf}


\begin{bnf}
\nontermdef{non-directive}\br
    pp-tokens new-line
\end{bnf}


\begin{bnf}
\nontermdef{lparen}\br
    \descr{a \terminal{(} character not immediately preceded by white-space}
\end{bnf}


\begin{bnf}
\nontermdef{identifier-list}\br
    identifier\br
    identifier-list \terminal{,} identifier
\end{bnf}


\begin{bnf}
\nontermdef{replacement-list}\br
    pp-tokens\opt
\end{bnf}


\begin{bnf}
\nontermdef{pp-tokens}\br
    preprocessing-token\br
    pp-tokens preprocessing-token
\end{bnf}


\begin{bnf}
\nontermdef{new-line}\br
    \descr{the new-line character}
\end{bnf}


