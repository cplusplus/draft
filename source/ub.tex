%!TEX root = std.tex
\infannex{ub}{Enumeration of Core Undefined Behavior}

\rSec1[ub.general]{General}

This Annex documents undefined behavior explicitly called out in the main standard text using the
following phrases: the behavior of the program is undefined, has undefined behavior, results in
undefined behavior, the behavior is undefined, have undefined behavior, is undefined, result has
undefined behavior. Undefined behavior that is implicit is not covered by this annex. Each entry contains
a title, a numeric cross reference to the main standard text, a summary of the issue and a code example
demonstrating the issue. The code examples are there to clarify the undefined behavior and will not
exhaustively cover all possible ways of invoking that case.

\rSec1[ub.basic]{\ref{basic}: Basics}

\rSec2[ub.intro.object]{Implicitly creating object and undefined behavior}

\pnum
\ubxref{intro.object.implicit.create}
For each
operation that is specified as implicitly creating objects, that operation implicitly creates and starts the
lifetime of zero or more objects of implicit-lifetime types \iref{basic.types} in its specified region of storage if doing so
would result in the program having defined behavior. If no such set of objects would give the program defined
behavior, the behavior of the program is undefined.

\pnum
\begin{example}
\begin{codeblock}
void f()
{
  void *p = malloc(sizeof(int) + sizeof(float));    // undefined behavior, cannot create
                                                    // both int and float in same place
  int& i = *reinterpret_cast<int*>(p);
  float& f = *reinterpret_cast<float*>(p);
}
\end{codeblock}
\end{example}


\pnum
\ubxref{intro.object.implicit.pointer}
After implicitly creating objects within a specified region of storage,
some operations are described as producing a pointer to a
suitable created object \iref{basic.types}.
These operations select one of the implicitly-created objects
whose address is the address of the start of the region of storage,
and produce a pointer value that points to that object,
if that value would result in the program having defined behavior.
If no such pointer value would give the program defined behavior,
the behavior of the program is undefined.

\pnum
\begin{example}
\begin{codeblock}
#include <cstdlib>
struct X {
  int a, b;
  ~X() = delete;        // deleted destructor makes \tcode{X} a non-implicit-lifetime class
};

X* make_x() {
        // The call to \tcode{std::malloc} can not implicitly create an object of type \tcode{X}
        // because \tcode{X} is not an implicit-lifetime class.
  X* p = (X*)std::malloc(sizeof(struct X));
  p->a = 1;     // undefined behavior, no set of objects give us defined behavior
  return p;
}
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
#include <cstdlib>

struct X {
  int a;
};

struct Y {
  int x;
};

*make_y() {
  X* p1 = (X*)std::malloc(sizeof(struct X));
  p1->a = 1;
  Y* p2 = (Y*)p1;
  p2->x = 2;    // undefined behavior, lifetime of \tcode{p1} was started but not
                // ended and lifetime of \tcode{p2} was not started.
  return p2;
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.align]{Object alignment}

\pnum
\ubxref{basic.align.object.alignment} \\
All instances of a type must be created in storage that meets the alignment
requirement of that type.

\pnum
\begin{example}
\begin{codeblock}
struct alignas(4) S {};

void make_misaligned()
{
    alignas(S) char s[sizeof(S) + 1];
    new (&s+1) S();     // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.life]{Object lifetime}

\pnum
\ubxref{lifetime.outside.pointer.delete}
For a pointer pointing to an object outside of its lifetime, behavior is
undefined if the object will be or was of a class type with a non-trivial destructor
and the pointer is used as the operand of a \grammarterm{delete-expression}.

\pnum
\begin{example}
\begin{codeblock}
struct S {
  float f = 0;
  ~S() {}
};

float f() {
  S* p = new S;
  p->~S();
  delete p;     // undefined behavior, operand of delete, lifetime has ended and \tcode{S}
                // has a non-trivial destructor
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.pointer.member}
For a pointer pointing to an object outside of its lifetime, behavior is
undefined if the pointer is used to access a non-static data member or call a
non-static member function of the object.

\pnum
\begin{example}
\begin{codeblock}
struct S {
  float f = 0;
};

float f() {
  S s;
  S* p = &s;
  s.~S();
  return p->f;  // undefined behavior, accessing non-static data member after
                // end of lifetime
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.pointer.virtual}
For a pointer pointing to an object outside of its lifetime, behavior is
undefined if pointer is implicitly converted\iref{conv.ptr} to a pointer
to a virtual base class.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D : virtual B {};
void f() {
  D d;
  D* p = &d;
  d.~D();
  B* b = p;     // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.pointer.static.cast}
For a pointer pointing to an object outside of its lifetime, behavior is
undefined if the pointer is used as the operand of a
\tcode{static_cast}, except when the conversion
is to pointer to \cv{}~\tcode{void}, or to pointer to \cv{}~\tcode{void}
and subsequently to pointer to
\cv{}~\tcode{char},
\cv{}~\tcode{unsigned char}, or
\cv{}~\tcode{std::byte}\iref{cstddef.syn}.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D : B {};
void f()
{
  D d;
  B* bp = &d;
  d.~D();
  void* vp = bp;                // OK
  D* dp = static_cast<D*>(bp);  // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.pointer.dynamic.cast}
For a pointer pointing to an object outside of its lifetime, behavior is
undefined if the pointer is used as the operand of a
\tcode{dynamic_cast}\iref{expr.dynamic.cast}.

\pnum
\begin{example}
\begin{codeblock}
struct B { virtual ~B() = default; };
struct D : B {};
void f()
{
  D d;
  B* bp = &d;
  d.~D();
  D* dp = dynamic_cast<D*>(bp);     // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.glvalue.access}
Behavior is undefined if a glvalue referring to an object outside of its
lifetime is used to access the object.

\pnum
\begin{example}
\begin{codeblock}
void f() {
  int x = int{10};
  using T = int;
  x.~T();
  int y = x;    // undefined behavior, glvalue used to access the
                // object after the lifetime has ended
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.glvalue.member}
Behavior is undefined if a glvalue referring to an object outside of its
lifetime is used to call a non-static member function of the object.

\pnum
\begin{example}
\begin{codeblock}
struct A {
  void f() {}
};

void f() {
  A a;
  a.~A();
  a.f();    // undefined behavior, glvalue used to access a
            // non-static member function after the lifetime has ended
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.glvalue.virtual}
Behavior is undefined if a glvalue referring to an object outside of its
lifetime is bound to a reference to a virtual base class.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D : virtual B {
};

void f() {
  D d;
  d.~D();
  B& b = d;     // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{lifetime.outside.glvalue.dynamic.cast}
Behavior is undefined if a glvalue referring to an object outside of its
lifetime is used as the operand of a
\keyword{dynamic_cast} or as the operand of \keyword{typeid}.

\pnum
\begin{example}
\begin{codeblock}
struct B { virtual ~B(); };
struct D : virtual B {};

void f() {
  D d;
  B& br = d;
  d.~D();
  D& dr = dynamic_cast<D&>(br);     // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{original.type.implicit.destructor} \\
The behavior of an implicit destructor call when the type that is not
the original type occupies the storage.

\pnum
\begin{example}
\begin{codeblock}
class T {};

struct B {
  ~B();
};

void h() {
  B b;
  new (&b) T;
}               // undefined behavior at block exit
\end{codeblock}
\end{example}


\pnum
\ubxref{creating.within.const.complete.obj} \\
Creating a new object within the storage that a const complete object with static, thread, or automatic
storage duration occupies, or within the storage that such a const object used to occupy before its lifetime
ended, results in undefined behavior

\pnum
\begin{example}
\begin{codeblock}
struct B {
  B();
  ~B();
};

const B b;

void h() {
  b.~B();
  new (const_cast<B*>(&b)) const B; // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.indet]{Indeterminate and erroneous values}

\pnum
\ubxref{basic.indet.value} \\
When the result of an evaluation is
an indeterminate value
(but not just an erroneous value)
the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
void g() {
  int x [[ indeterminate ]];
  int y = x;    // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.stc.dynamic]{Dynamic storage Duration}

\pnum
\ubxref{basic.stc.alloc.dealloc.constraint} \\
If the behavior of an allocation or deallocation function does not satisfy the semantic constraints
specified
in \iref{basic.stc.dynamic.allocation} and \iref{basic.stc.dynamic.deallocation}.
the behavior is undefined.


\pnum
\begin{example}
\begin{codeblock}
#include <new>
void* operator new(std::size_t sz) {
  if (sz == 0)
    return nullptr;             // undefined behavior,  should return non-null pointer

  return std::malloc(1);        // undefined behavior, if successful should return allocation with
                                // length in bytes is at least as large as the requested size
}
void operator delete(void* ptr) noexcept {
  throw 0;                      // undefined behavior, terminates by throwing an exception
}
\end{codeblock}
\end{example}

\pnum
\ubxref{basic.stc.alloc.dealloc.throw} \\
If a call to a deallocation function
terminates by throwing an exception
the behavior is undefined.
\pnum
\begin{example}
\begin{codeblock}
struct X {
  void operator delete(void*) { throw "oops"; }
};
void f()
{
  X* x = new X();
  delete x;     // undefined behavior
}
\end{codeblock}
\end{example}



\rSec2[ub.basic.stc.alloc.zero.dereference]{Zero-sized allocation dereference}

\pnum
\ubxref{basic.stc.alloc.zero.dereference} \\
The pointer returned when invoking an allocation function with a size of zero
cannot be dereferenced.

\pnum
\begin{example}
\begin{codeblock}
void test()
{
    char* c = static_cast<char*>(operator new(0z));
    c[0] = 'X';     // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.compound]{Compound types}

\pnum
\ubxref{basic.compound.invalid.pointer} \\
Indirection or
the invocation of a deallocation function
with a pointer value referencing storage
that has been freed
has undefined behavior.
(Most other uses of such a pointer have
implemention-defined behavior.)

\pnum
\begin{example}
\begin{codeblock}
void f()
{
    int *x = new int{5};
    delete x;
    int y = *x; // undefined behavior
    delete x;   // undefined behavior
}
\end{codeblock}
\end{example}


\rSec2[ub.intro.execution]{Sequential execution}

\pnum
\ubxref{intro.execution.unsequenced.modification} \\
If a side effect on a
memory location \iref{intro.memory} is unsequenced relative to either another side effect on the same memory location or
a value computation using the value of any object in the same memory location, and they are not potentially
concurrent \iref{intro.multithread}, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
void g(int i) {
  i = 7, i++, i++;  // i becomes 9

  i = i++ + 1;  // the value of i is incremented
  i = i++ + i;  // undefined behavior
  i = i + 1;    // the value of i is incremented
}
\end{codeblock}
\end{example}

\rSec2[ub.intro.races]{Data races}

\pnum
\ubxref{intro.races.data} \\
The execution of a program contains a data race if it contains two potentially concurrent conflicting actions,
at least one of which is not atomic, and neither happens before the other, except for the special case for
signal handlers described in \iref{intro.races}. Any such data race results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int count = 0;
auto f = [&] { count++; };
std::thread t1{f}, t2{f}, t3{f};
// undefined behavior t1, t2 and t3 have a data race on access of variable count
\end{codeblock}
\end{example}


\rSec2[ub.basic.start.main]{main function}

\pnum
\ubxref{basic.start.main.exit.during.destruction} \\
If \tcode{std::exit} is called to
end a program during the destruction of an object with static or thread storage duration, the program has
undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <cstdlib>

struct Exiter {
  ~Exiter() { std::exit(0); }
};

Exiter ex;  //

int main() {}
// undefined behavior when destructor of static variable \tcode{ex} is called it will call \tcode{std::exit}
\end{codeblock}
\end{example}


\rSec2[ub.basic.start.term]{Termination}

\pnum
\ubxref{basic.start.term.use.after.destruction} \\
If a function contains a block-scope object of static or thread storage duration that has been destroyed and the
function is called during the destruction of an object with static or thread storage duration, the program has
undefined behavior if the flow of control passes through the definition of the previously destroyed block-scope
object. Likewise, the behavior is undefined if the block-scope object is used indirectly (i.e., through a pointer)
after its destruction.

\pnum
\begin{example}
\begin{codeblock}
struct A {};
void f() {
  static A a;
}

struct B {
  B() { f(); }
};
struct C {
  ~C() { f(); }
};

C c;
B b;

int main() {}
// undefined behavior, static objects are destructed in reverse order, in this case \tcode{a} then \tcode{b} and
// finally \tcode{c}. When the destructor of \tcode{c} is called, it calls \tcode{f()} which passes through the definition of
// previously destroyed block-scope object
\end{codeblock}
\end{example}


\pnum
\ubxref{basic.start.term.signal.handler} \\
If there is a use of a standard library object or function not permitted within signal handlers \iref{support.runtime} that
does not happen before \iref{intro.multithread} completion of destruction of objects with static storage duration and execution
of std::atexit registered functions \iref{support.start.term}, the program has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
\end{codeblock}
\end{example}


\rSec1[ub.expr]{\ref{expr}: Expressions}
\rSec2[ub.expr.eval]{Result of Expression not Mathematically Defined/out of Range}

\pnum
\ubxref{expr.expr.eval} \\
If during the evaluation of an expression, the result is not mathematically defined or not in the range of
representable values for its type, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#include <limits>
int main() {
  // Assuming 32-bit int the range of values are: -2,147,483,648 to 2,147,483,647
  int x1 = std::numeric_limits<int>::max() + 1;     // undefined behavior, 2,147,483,647 + 1 is not representable as an int
  int x2 = std::numeric_limits<int>::min() / -1;    // undefined behavior, -2,147,483,648 / -1 is not representable as an int
}
\end{codeblock}
\end{example}

\rSec2[ub.basic.lval]{Value category}

\pnum
\ubxref{expr.basic.lvalue.strict.aliasing.violation} \\
If a program attempts to access \iref{defns.access} the stored value of an object
whose dynamic type is $T$ through a glvalue whose type is not
similar \iref{conv.rval} to $T$ (or its corresponding signed or unsigned types)
the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
int foo(float* f, int* i) {
  *i = 1;
  *f = 0.f;     // undefined behavior, glvalue is not similar to \tcode{int}

  return *i;
}

int main() {
  int x = 0;

  x = foo(reinterpret_cast<float*>(&x), &x);
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.basic.lvalue.union.initialization} \\
If a program invokes a defaulted copy/move constructor or copy/move assignment
operator of a union with an argument that is not an object of a similar type
within its lifetime, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
union U { int x; };
void f()
{
   char u[sizeof(U)];
   U o = reinterpret_cast<U&>(u);   // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.type]{Type}

\pnum
\ubxref{expr.type.reference.lifetime} \\
Evaluating a reference when an equivalent use of a pointer denoting the same object
would be invalid has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
void g()
{
  int* ip = new int(5);
  int& i = *ip;
  delete ip;
  i;    // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.conv.lval]{Lvalue-to-rvalue conversion}

\pnum
\ubxref{conv.lval.valid.representation} \\
Performing an
lvalue-to-rvalue conversion
on an object whose
value representation
is not valid for its type
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
bool f() {
  bool b = true;
  char c = 42;
  memcpy(&b, &c, 1);
  return b;         // undefined behavior if \tcode{42} is not a valid value representation for \keyword{bool}
}
\end{codeblock}
\end{example}


\rSec2[ub.conv.double]{Floating-point conversions}

\pnum
\ubxref{conv.double.out.of.range} \\
Converting a floating point value to a type that cannot represent the value is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <limits>

int main() {
  // Assuming 32-bit int, 32-bit float and 64-bit double
  double d2 = std::numeric_limits<double>::max();
  float f = d2; // undefined behavior on systems where the range of
                // representable values of float is [-max,+max] on system where
                // represetable values are [-inf,+inf] this would not be UB
  int i = d2;   // undefined behavior, the max value of double is not representable as int
}
\end{codeblock}
\end{example}


\rSec2[ub.conv.fpint]{Floating-integral conversions}

\pnum
\ubxref{conv.fpint.int.not.represented} \\
When converting a floating-point value to an integer type and vice versa if
the value is not representable in the destination type it is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <limits>

int main() {
  // Assuming 32-bit int the range of values are: -2,147,483,648 to
  // 2,147,483,647 Assuming 32-bit float and 64-bit double
  double d = (double)std::numeric_limits<int>::max() + 1;
  int x1 = d;   // undefined behavior 2,147,483,647 + 1 is not representable as int
}
\end{codeblock}
\end{example}

\pnum
\ubxref{conv.fpint.float.not.represented} \\
When converting a value of integer or unscoped enumeration type to a
floating-point type, if the value is not representable in the destination type
it is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
    int main() {
      __uint128_t x2 = -1;
      float f = x2; // undefined behavior on systems where the range of
      // representable values of float is [-max,+max] on system where
      // represetable values are [-inf,+inf] this would not be UB
    }
\end{codeblock}
\end{example}

\rSec2[ub.conv.ptr]{Pointer conversions}

\pnum
\ubxref{conv.ptr.virtual.base} \\
Converting
a pointer to a derived class \tcode{D}
to
a pointer to a virtual base class \tcode{B}
that does not point to
a valid object
within its lifetime
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D : virtual B {};
void f()
{
  D ds[1];
  B* b = &ds[1];    // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.conv.mem]{Pointer-to-member conversions}

\pnum
\ubxref{conv.member.missing.member} \\
The conversion of
a pointer to a member of a base class
to a pointer to member of a derived class
that could not contain that member
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D1 : B { int d1; };
struct D2 : B {};
void f()
{
  int (D1::*pd1) = &D1::d1;
  int (B::*pb) = static_cast<int (B::*)>(pd1);
  int (D2::*pd2) = pb;  // undefined behavior
}
\end{codeblock}
\end{example}



\rSec2[ub.expr.call]{Function call}

\pnum
\ubxref{expr.call.different.type} \\
Calling a function through an expression whose function type is different from the function type of the called
function's definition results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
using f_float = int (*)(float);
using f_int = int (*)(int);

int f1(float) { return 10; }

int f2(int) { return 20; }

int main() {
  return reinterpret_cast<f_int>(f1)(20);   // undefined behavior, the function type of the expression
                                            // is different from the called functions definition
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.ref]{Class member access}

\pnum
\ubxref{expr.ref.member.not.similar} \\
If \tcode{E2} is a non-static member and the result of \tcode{E1} is an object whose type
is not similar\iref{conv.qual} to the type of \tcode{E1}, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct A { int i; };
struct B { int j; };
struct D : A, B {};
void f() {
  D d;
  reinterpret_cast<B&>(d).j;    // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.dynamic.cast]{Dynamic cast}


\pnum
\ubxref{expr.dynamic.cast.pointer.lifetime} \\
Evaluating a \keyword{dynamic_cast} on a non-null pointer that points to
an object (of polymorphic type) of the wrong type or to an object
not within its lifetime has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
    struct B { virtual ~B(); };
    void f() {
      B bs[1];
      B* dp = dynamic_cast<B*>(bs+1);   // undefined behavior
    }
\end{codeblock}
\end{example}


\pnum
\ubxref{expr.dynamic.cast.glvalue.lifetime} \\
Evaluating a \keyword{dynamic_cast} on a reference that
denotes an object (of polymorphic type) of the wrong type or an object
not within its lifetime has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct B { virtual ~B(); };
void f() {
  B bs[1];
  B& dr = dynamic_cast<B&>(bs[1]);  // undefined behavior
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.static.cast]{Static cast}

\pnum
\ubxref{expr.static.cast.base.class} \\
We can cast a base class B to a reference to derived class D (with certain restrictions wrt to cv qualifiers)
as long B is a base class subobject of type D, otherwise the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
truct B {};
struct D1 : B {};
struct D2 : B {};

void f() {
  D1 d;
  B &b = d;
  static_cast<D2 &>(b); // undefined behavior, base class object of type \tcode{D1} not \tcode{D2}
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.static.cast.enum.outside.range} \\
If the enumeration type does not have a fixed underlying
type, the value is unchanged if the original value is within the range of the enumeration values \iref{dcl.enum}, and
otherwise, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
enum A { e1 = 1, e2 };

void f() {
  enum A a = static_cast<A>(4); // undefined behavior, 4 is not with the range of enumeration values
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.static.cast.fp.outside.range} \\
An explicit conversion of a
floating-point value that is outside the range of the
target type has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
void f() {
  double d = FLT_MAX * 16;
  d *= 16;
  float f = static_cast<float>(d);  // undefined behavior.
}
\end{codeblock}
\end{example}


\pnum
\begin{example}
\begin{codeblock}

\end{codeblock}
\end{example}

\pnum
\ubxref{expr.static.cast.downcast.wrong.derived.type} \\
Down-casting to the wrong derived type is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D1 : B {};
struct D2 : B {};

void f() {
  B *bp = new D1;
  static_cast<D2 *>(bp);        // undefined behavior, base class object of type \tcode{D1} not \tcode{D2}
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.static.cast.does.not.contain.orignal.member} \\
We can cast a pointer to mamber of dervied class D to a pointer to memeber of base class D (with certain restrictions wrt to cv qualifiers)
as long B contains the original member, is a base or derived class of the class containing the original member, otherwise the behavior is undefined.


\pnum
\begin{example}
\begin{codeblock}
struct A {
  char c;
};

struct B {
  int i;
};

struct D : A, B {};

int main() {
  char D::*p1 = &D::c;
  char B::*p2 = static_cast<char B::*>(p1); // undefined behavior, \tcode{B} does not contain the original member \tcode{c}
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.unary.op]{Unary operators}

\pnum
\ubxref{expr.unary.dereference} \\
Dereferencing a pointer that does not point to an object or function
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int f()
{
  int *p = nullptr;
  return *p;    // undefined behavior
}
\end{codeblock}
\end{example}


\rSec2[ub.expr.new]{New}

\pnum
\ubxref{expr.new.non.allocating.null} \\
If the allocation
function is a non-allocating form \iref{new.delete.placement} that returns null, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#include <new>
[[nodiscard]] void* operator new(std::size_t size, void* ptr) noexcept {
  return nullptr;       // undefined behavior,  should return non-null pointer
}
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
#include <new>

struct A {
  int x;
};

int main() {
  char *p = nullptr;
  A *a = new (p) A;     // undefined behavior, non-allocting new returning nullptr
}
\end{codeblock}
\end{example}


\rSec2[ub.expr.delete]{Delete}

\pnum
\ubxref{expr.delete.mismatch} \\
Using array delete on the result of a single object new expression is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int* x = new int;
delete[] x;         // undefined behavior, allocated using single object new expression
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.delete.array.mismatch} \\
Using single object delete on the result of an array new expression is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int* x = new int[10];
delete x;           // undefined behavior, allocated using array new expression
\end{codeblock}
\end{example}


\pnum
\ubxref{expr.delete.dynamic.type.differ} \\
If the static type of the object to be deleted is different from its dynamic
type and the selected deallocation function (see below) is not a destroying operator delete, the static type
shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual
destructor or the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct B {
  int a;
};

struct D : public B {
  int b;
};

void f() {
  B* b = new D;
  delete b;             // undefined behavior, no virtual destructor
}
\end{codeblock}
\end{example}


\pnum
\ubxref{expr.delete.dynamic.array.dynamic.type.differ} \\
In an array delete expression, if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct B {
  virtual ~B();
  void operator delete[](void*, std::size_t);
};

struct D : B {
  void operator delete[](void*, std::size_t);
};

void f(int i) {
  D* dp = new D[i];
  delete[] dp;          // uses \tcode{D::operator delete[](void*, std::size_t)}
  B* bp = new D[i];
  delete[] bp;          // undefined behavior
}
\end{codeblock}
\end{example}


\rSec2[ub.expr.mptr.oper]{Pointer-to-member operators}

\pnum
\ubxref{expr.mptr.oper.not.contain.member} \\
Abbreviating \grammarterm{pm-expression}.*\grammarterm{cast-expression} as \tcode{E1.*E2}, \tcode{E1} is called the object expression. If the dynamic type
of \tcode{E1} does not contain the member to which \tcode{E2} refers, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct D : B {
  int x;
};

void f() {
  B *b = new B;
  D *d = static_cast<D *>(b);
  int D::*p = &D::x;
  (*d).*p = 1;          // undefined behavior, dynamic type \tcode{B} does not contain \tcode{x}
}
\end{codeblock}
\end{example}


\pnum
\ubxref{expr.mptr.oper.member.func.null} \\
If the second operand is the null
member pointer value \iref{conv.mem}, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct S {
  int f();
};

void f() {
  S cs;
  int (S::*pm)() = nullptr;
  (cs.*pm)();           // undefined behavior, the second operand is null
}
\end{codeblock}
\end{example}


\rSec2[ub.expr.mul]{Multiplicative operators}

\pnum
\ubxref{expr.mul.div.by.zero} \\
Division by zero is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int main() {
  int x = 1 / 0;        // undefined behavior, division by zero
  double d = 1.0 / 0.0; // undefined behavior on systems where the range of
                        // representable values of float is [-max,+max] on system where
                        // represetable values are [-inf,+inf] this would not be UB
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.mul.representable.type.result} \\
If the
quotient a/b is representable in the type of the result, (a/b)*b + a\%b is equal to a; otherwise, the behavior
of both a/b and a\%b is undefined.

\pnum
\begin{example}
\begin{codeblock}
#include <limits>

int main() {
  int x =
      std::numeric_limits<int>::min() / -1; // Assuming LP64 -2147483648 which when divided by -1
                                            // gives us 2147483648 which is not representable by int
}
\end{codeblock}
\end{example}

\rSec2[ub.expr.add]{Additive operators}

\pnum
\ubxref{expr.add.out.of.bounds} \\
Creating an out of bounds pointer is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
static const int arrs[10]{};

int main() {
  const int *y = arrs + 11;             // undefined behavior, creating an out of bounds pointer
}
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
static const int arrs[10][10]{};

int main() {
  const int(*y)[10] = arrs + 11;        // undefined behavior, creating an out of bounds pointer.
                                        // We can't treat arrs as-if it was a pointer to 100 int,
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.add.sub.diff.pointers} \\
Subtracting pointers that are not part of the same array is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <cstddef>
void f() {
  int x[2];
  int y[2];
  int* p1 = x;
  int* p2 = y;
  std::ptrdiff_t off = p1 - p2; // undefined behavior, \tcode{p1} and \tcode{p2} point to different arrays
}
\end{codeblock}
\end{example}

\pnum
\ubxref{expr.add.not.similar} \\
For addition or subtraction, if the expressions P or Q have type ``pointer to cv T'', where T and the array
element type are not similar \iref{conv.rval}, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct S {
  int i;
};

struct T : S {
  double d;
};

void f(const S* s, std::size_t count) {
  for (const S* end = s + count; s != end; ++s) {
    ...
  }
}

int main() {
  T test[5];
  f(test, 5);
}
\end{codeblock}
\end{example}


\rSec2[ub.expr.shift]{Shift operators}

\pnum
\ubxref{expr.shift.neg.and.width} \\
Shifting by a negative amount or equal or greater than the bit-width of a type is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int y = 1 << -1;        // undefined behavior, shift is negative

static_assert(sizeof(int) == 4 && CHAR_BIT == 8);
int y1 = 1 << 32;       // undefined behavior, shift is equal to the bit width of int
int y2 = 1 >> 32;       // undefined behavior, shift is equal to the bit width of int
\end{codeblock}
\end{example}


\rSec2[ub.expr.assign]{Assignment and compound assignment operators}

\pnum
\ubxref{expr.assign.overlap} \\
Overlap in the storage between the source and destination may result in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int x = 1;
char* c = reinterpret_cast<char*>(&x);
x = *c;         // undefined behavior, source overlaps storage of destination
\end{codeblock}
\end{example}

\rSec1[ub.stmt.stmt]{\ref{stmt}: Statements}

\rSec2[ub.stmt.return]{The return statement}

\pnum
\ubxref{stmt.return.flow.off} \\
Flowing off the end of a function other
than main or a coroutine results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
int f(int x) {
  if (x)
    return 1;
  // undefined behavior if \tcode{x} is \tcode{0}
}

void b() {
  int x = f(0); // undefined behavior, using 0 as an argument will cause f(...) to flow off the end
                // with a return statement
}
\end{codeblock}
\end{example}

\rSec2[ub.return.coroutine]{The co_return statement}

\pnum
\ubxref{stmt.return.coroutine.flow.off} \\
Falling off the end of a coroutine function body that does not return void is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <cassert>
#include <coroutine>
#include <iostream>
#include <vector>

class resumable {
 public:
  struct promise_type;
  using coro_handle = std::coroutine_handle<promise_type>;
  resumable(coro_handle handle) : handle_(handle) { assert(handle); }
  resumable(resumable&) = delete;
  resumable(resumable&&) = delete;
  bool resume() {
    if (not handle_.done())
      handle_.resume();
    return not handle_.done();
  }
  ~resumable() { handle_.destroy(); }
  const char* return_val();

 private:
  coro_handle handle_;
};

struct resumable::promise_type {
  using coro_handle = std::experimental::coroutine_handle<promise_type>;
  const char* string_;
  auto get_return_object() { return coro_handle::from_promise(*this); }
  auto initial_suspend() { return std::experimental::suspend_always(); }
  auto final_suspend() noexcept { return std::experimental::suspend_always(); }
  void unhandled_exception() { std::terminate(); }
  void return_value(const char* string) { string_ = string; }
};

const char* resumable::return_val() {
  return handle_.promise().string_;
}

resumable foo() {
  std::cout << "Hello" << std::endl;
  co_await std::experimental::suspend_always();
  // undefined behavior, falling off the end of coroutine that does not return void
}

int main() {
  resumable res = foo();
  while (res.resume())
    ;
  std::cout << res.return_val() << std::endl;
}
\end{codeblock}
\end{example}

\rSec2[ub.stmt.dcl]{Declaration statement}

\pnum
\ubxref{stmt.dcl.local.static.init.recursive} \\
If control re-enters the declaration recursively while the
variable is being initialized, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
int foo(int i) {
  static int s = foo(2 * i);    // recursive call - undefined
  return i + 1;
}
\end{codeblock}
\end{example}




\rSec1[ub.dcl.dcl]{\ref{dcl}: Declarations}

\rSec2[ub.dcl.type.cv]{The cv-qualifiers}

\pnum
\ubxref{dcl.type.cv.modify.const.obj} \\
Any attempt to modify a const object during its lifetime results in
undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
const int* ciq = new const int(3);  // initialized as required
int* iq = const_cast<int*>(ciq);    // cast required
*iq = 4;                            // undefined: modifies a const object
\end{codeblock}
\end{example}


\pnum
\ubxref{dcl.type.cv.access.volatile} \\
If an attempt is made to
access an object defined with a volatile-qualified type through the use of a non-volatile glvalue, the behavior
is undefined

\pnum
\begin{example}
\begin{codeblock}
volatile int x = 0;
int& y = const_cast<int&>(x);
std::cout << y;         // undefined behavior, accessing volatile through non-volatile glvalue
\end{codeblock}
\end{example}

\rSec2[ub.dcl.ref]{References}

\pnum
\ubxref{dcl.ref.incompatible.function} \\
Initializing a reference to a function
with a value that is a function
that is not call-compatible\iref{expr.call}
with the type of the reference
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
void f(float x);
void (&g)(int) = reinterpret_cast<void (&)(int)>(f);    // undefined behavior
\end{codeblock}
\end{example}

\pnum
\ubxref{dcl.ref.incompatible.type} \\
Initializing a reference to an object
with a value that is not
type-accessible\iref{basic.lval} through
the type of the reference
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
float g;
int& i = reinterpret_cast<int&>(g);     // undefined behavior
\end{codeblock}
\end{example}

\pnum
\ubxref{dcl.ref.uninitialized.reference} \\
Evaluating a reference
prior to initializing that
reference has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
extern int &ir1;
int i2 = ir1;   // undefined behavior, \tcode{ir1} not yet initialized
int ir1 = 17;
\end{codeblock}
\end{example}




\rSec2[ub.dcl.fct.def.coroutine]{Coroutine definitions}

\pnum
\ubxref{dcl.fct.def.coroutine.resume.not.suspended} \\
Invoking a resumption member function for a coroutine that is not suspended results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <experimental/coroutine>

using namespace std::experimental;

struct minig {
  struct promise_type {
    int val;
    minig get_return_object() { return {*this}; }
    constexpr suspend_always initial_suspend() noexcept { return {}; }
    constexpr suspend_always final_suspend() noexcept { return {}; }
    constexpr void return_void() noexcept {}
    [[noreturn]] void unhandled_exception() noexcept { throw; }
    suspend_always yield_value(int v) noexcept {
      val = v;
      return {};
    }
  };
  using HDL = coroutine_handle<promise_type>;
  HDL coro;
  minig(promise_type& p) : coro(HDL::from_promise(p)) {}
  ~minig() { coro.destroy(); }
  bool move_next() {
    coro.resume();
    return !coro.done();
  }
  int current_value() { return coro.promise().val; }
};

static minig f(int n) {
  for (int i = 0; i < n; ++i)
    co_yield i;
}

int main() {
  auto g = f(10);
  int sum = 0;
  while (g.move_next())
    sum += g.current_value();
#if 0
  // undefined behavior to call move_next(), because coro.resume() is
  // UB after final_suspend returns, even when it returns
  // suspend_always
  g.move_next();
#endif
  return sum;
}
\end{codeblock}
\end{example}


\pnum
\ubxref{dcl.fct.def.coroutine.destroy.not.suspended} \\
Invoking destroy() on a coroutine that is not suspended is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <experimental/coroutine>

using namespace std::experimental;

struct minig {
  struct promise_type {
    int val;
    minig get_return_object() { return {*this}; }
    constexpr suspend_always initial_suspend() noexcept { return {}; }
    constexpr suspend_always final_suspend() noexcept { return {}; }
    constexpr void return_void() noexcept {}
    [[noreturn]] void unhandled_exception() { throw; }
    suspend_always yield_value(int v) noexcept {
      val = v;
      return {};
    }
  };
  using HDL = coroutine_handle<promise_type>;
  HDL coro;
  minig(promise_type& p) : coro(HDL::from_promise(p)) {}
  ~minig() { coro.destroy(); }
  bool move_next() {
    coro.resume();
    return !coro.done();
  }
  int current_value() {
    // this coroutine is not suspended therefore a call to destroy is undefined
    // behaviour
    coro.destroy();
    return coro.promise().val;
  }
};

static minig f(int n) {
  for (int i = 0; i < n; ++i)
    co_yield i;
}

int main() {
  auto g = f(10);
  int sum = 0;
  while (g.move_next())
    sum += g.current_value();

  return sum;
}
\end{codeblock}
\end{example}

\rSec2[ub.dcl.attr.assume]{Assumption attribute}

\pnum
\ubxref{dcl.attr.assume.false} \\
If am assumption expression would not evaluate to true at the point where it
appears the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
int g(int x) {
  [[assume(x >= 0)]];
  return x/32;
}

int f() {
    return g(-10);      // undefined behavior, assumption in \tcode{g} is \tcode{false}
}
\end{codeblock}
\end{example}


\rSec2[ub.dcl.attr.noreturn]{Noreturn attribute}

\pnum
\ubxref{dcl.attr.noreturn.eventually.returns} \\
If a function f is called where f was previously declared with the \tcode{noreturn} attribute and f eventually returns,
the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
[[noreturn]] void f(int i) {
  if (i > 0)
    throw "positive";
}

int main() {
  f(0);         // undefined behavior, returns from a [[noreturn]] function
}
\end{codeblock}
\end{example}


\rSec1[ub.class]{\ref{class}: Classes}

\rSec2[ub.class.dtor]{Destructors}

\pnum
\ubxref{class.dtor.no.longer.exists} \\
Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the
destructor is invoked for an object whose lifetime has ended.

\pnum
\begin{example}
\begin{codeblock}
struct A {
  ~A() {}
};

int main() {
  A a;
  a.~A();       // undefined behavior, destructor will be invoked again at scope exit
}
\end{codeblock}
\end{example}


\rSec2[ub.class.abstract]{Abstract classes}

\pnum
\ubxref{class.abstract.pure.virtual} \\
Calling a pure virtual function from a constructor or destructor in an abstract class is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct B {
  virtual void f() = 0;
  B() {
    f();        // undefined behavior, \tcode{f} is pure virtual and we are calling from the constructor
  }
};

struct D : B {
  void f() override;
};
\end{codeblock}
\end{example}


\rSec2[ub.class.base.init]{Initializing bases and members}

\pnum
\ubxref{class.base.init.mem.fun} \\
It is undefined behavior to call a member function before all the \grammarterm{mem-initializer}s for base classes have completed.

\pnum
\begin{example}
\begin{codeblock}
class A {
public:
  A(int);
};

class B : public A {
  int j;

public:
  int f();
  B()
      : A(f()),         // undefined: calls member function but base Ac not yet initialized
        j(f()) {}       // well-defined: bases are all initialized
};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;

public:
  D()
      : C(f()),         // undefined: calls member function but base \tcode{C} not yet initialized
        i(f()) {}       // well-defined: bases are all initialized
};
\end{codeblock}
\end{example}


\rSec2[ub.class.cdtor]{Construction and destruction}

\pnum
\ubxref{class.cdtor.before.ctor} \\
For an object with a non-trivial constructor, referring to any non-static member or base class of the object
before the constructor begins execution results in undefined behavior. For an object with a non-trivial
destructor, referring to any non-static member or base class of the object after the destructor finishes execution
results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct X {
  int i;
};
struct Y : X {
  Y();
};              // non-trivial
struct A {
  int a;
};
struct B : public A {
  int j;
  Y y;
};              // non-trivial

extern B bobj;
B *pb = &bobj;          // OK
int *p1 = &bobj.a;      // undefined, refers to base class member
int *p2 = &bobj.y.i;    // undefined, refers to member's member

A *pa = &bobj;          // undefined, upcast to a base class type
B bobj;                 // definition of \tcode{bobj}

extern X xobj;
int *p3 = &xobj.i;      // OK, \tcode{X} is a trivial class
X xobj;

struct W {
  int j;
};
struct X : public virtual W {};
struct Y {
  int *p;
  X x;
  Y() : p(&x.j) {       // undefined, \tcode{x} is not yet constructed
  }
};
\end{codeblock}
\end{example}


\pnum
\ubxref{class.cdtor.after.dtor} \\
For an object with a non-trivial destructor,
referring to any non-static member or base class of the object
after the destructor finishes execution
has undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct X {
  int i;
  ~X();     // non-trivial
};
X& g()
{
  static X x;
  return x;
}
void f()
{
  X& px = &g();
  px->~X();
  int*p = px->i;    // undefined behavior
}
\end{codeblock}
\end{example}

\pnum
\ubxref{class.cdtor.convert.pointer} \\
When converting a pointer to a base class of an object,
construction must have started and destruction must not have finished otherwise
this is undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    // undefined behavior: upcast from \tcode{E*} to \tcode{A*} might use path \tcode{E*} $\rightarrow$ \tcode{D*} $\rightarrow$ \tcode{A*}
                    // but \tcode{D} is not constructed

                    // ``\tcode{D((C*)this)}\!'' would be defined: \tcode{E*} $\rightarrow$ \tcode{C*} is defined because \tcode{E()} has started,
                    // and \tcode{C*} $\rightarrow$ \tcode{A*} is defined because \tcode{C} is fully constructed

  X(this) {}        // defined: upon construction of \tcode{X}, \tcode{C/B/D/A} sublattice is fully constructed
};
\end{codeblock}
\end{example}

\pnum
\ubxref{class.cdtor.form.pointer} \\
When forming a pointer to
a direct non-static member of a class,
construction must have started
and destruction must not have finished
otherwise the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct A {
  int i = 0;
};
struct B {
  int *p;
  A a;
  B() : p(&a.a) {}  // undefined behavior
};
\end{codeblock}
\end{example}

\pnum
\ubxref{class.cdtor.virtual.not.x} \\
When a virtual function is called directly or indirectly from a constructor or from a destructor,
including during the construction or destruction of the class's non-static data members, and the object to
which the call applies is the object (call it \tcode{x}) under construction or destruction, the function called is the
final overrider in the constructor's or destructor's class and not one overriding it in a more-derived class.
If the virtual function call uses an explicit class member access \iref{expr.ref} and the object expression refers
to the complete object of \tcode{x} or one of that object's base class subobjects but not \tcode{x} or one of its base class
subobjects, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V *, A *);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A *)this, this) {}
};

B::B(V *v, A *a) {
  f();          // calls \tcode{V::f}, not \tcode{A::f}
  g();          // calls \tcode{B::g}, not \tcode{D::g}
  v->g();       // \tcode{v} is base of \tcode{B}, the call is well-defined, calls \tcode{B::g}
  a->f();       // undefined behavior, \tcode{a}'s type not a base of \tcode{B}
}
\end{codeblock}
\end{example}


\pnum
\ubxref{class.cdtor.typeid} \\
If the operand of \tcode{typeid} refers to
the object under construction or destruction and the static type of the operand is neither the constructor or
destructor's class nor one of its bases, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
};

struct A : virtual V {};
struct B : virtual V {
  B(V *, A *);
};

struct D : A, B {
  D() : B((A *)this, this) {}
};

B::B(V *v, A *a) {
  typeid(*this);        // \tcode{std::type_info} for \tcode{B}
  typeid(*v);           // well-defined: \tcode{*v} has type \tcode{V}, a base of \tcode{B} yields \tcode{std::type_info} for \tcode{B}
  typeid(*a);           // undefined behavior: type \tcode{A} not a base of \tcode{B}
}
\end{codeblock}
\end{example}


\pnum
\ubxref{class.cdtor.dynamic.cast} \\
If the operand of the
\tcode{dynamic_cast} refers to the object under construction or destruction and the static type of the operand is
not a pointer to or object of the constructor or destructor's own class or one of its bases, the \tcode{dynamic_cast}
results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
};

struct A : virtual V {};
struct B : virtual V {
  B(V *, A *);
};

struct D : A, B {
  D() : B((A *)this, this) {}
};

B::B(V *v, A *a) {
  dynamic_cast<B *>(v); // well-defined: \tcode{v} of type \tcode{V*}, \tcode{V} base of \tcode{B} results in \tcode{B*}
  dynamic_cast<B *>(a); // undefined behavior: \tcode{a} has type \tcode{A*}, \tcode{A} not a base of \tcode{B}
}
\end{codeblock}
\end{example}


\rSec1[ub.temp]{\ref{temp}: Templates}
\rSec2[ub.temp.inst]{Implicit instantiation}

\pnum
\ubxref{temp.inst.inf.recursion} \\
The result of an infinite recursion in template instantiation is undefined.

\pnum
\begin{example}
\begin{codeblock}
template <class T>
class X {
  X<T> *p;      // OK
  X<T *> a;     // implicit instantiation of \tcode{X<T>} requires
                // the implicit instantiation of \tcode{X<T*>} which requires
                // the implicit instantiation of \tcode{X<T**>} which \ldots
};

int main() {
  X<int> x;     // undefined behavior, instantiation will kick off infinite recursion
}
\end{codeblock}
\end{example}


\rSec1[ub.except]{\ref{except}: Exception handling}

\rSec2[ub.except.handle]{Handling an exception}

\pnum
\ubxref{except.handle.handler.ctor.dtor} \\
Referring to any non-static member or base class of an object in the handler for a  \grammarterm{function-try-block} of a
constructor or destructor for that object results in undefined behavior.

\pnum
\begin{example}
\begin{codeblock}
#include <iostream>

struct A {
  A() try : x(0 ? 1 : throw 1) {
  } catch (int) {
    std::cout << "y: " << y << std::endl;   // undefined behavior, referring to non-static member y in
                                            // the handler of function-try-block
  }
  int x;
  int y = 42;
};
\end{codeblock}
\end{example}


\rSec1[ub.cpp]{\ref{cpp}: Preprocessing directives}

\rSec2[ub.cpp.cond]{Conditional inclusion}

\pnum
\ubxref{cpp.cond.defined} \\
If the token defined is generated as a result of this replacement process or use of
the defined unary operator does not match one of the two specified forms prior to macro replacement, the
behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define A
#define B defined(A)
#if B                   // undefined behavior, \tcode{defined} is generated by macro replacement for controlling expression
#endif
\end{codeblock}
\end{example}


\rSec2[ub.cpp.include]{Source file inclusion}

\pnum
\ubxref{cpp.include.one.of.two.forms} \\
If the an include directive after replacement does not match one of the two forms
outlined [cpp.indlude]\iref{cpp.include} then the behavior is undefined

\pnum
\begin{example}
\begin{codeblock}
#include "              // undefined behavior, does not match one of the allowable forms
\end{codeblock}
\end{example}


\rSec2[ub.cpp.replace]{Macro replacement}

\pnum
\ubxref{cpp.replace.macro.pptoken} \\
If there are sequences of preprocessing tokens within the list of arguments to a function-like macro
that would otherwise act as preprocessing directives, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define M(d, n) d = n

void f(int x) {
  M(x,
#ifdef D                // undefined behavior, preprocessing directive
    16
#else                   // undefined behavior, preprocessing directive
    32
#endif                  // undefined behavior, preprocessing directive
  );
}

int main() {
  int x;
  f(x);
}
\end{codeblock}
\end{example}


\rSec2[ub.cpp.stringize]{The \# operator}

\pnum
\ubxref{cpp.stringize.invalid.char} \\
If an invalid character results from using the stringize operator the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define s_lit(x) #x
s_lit( \ )              // stringizes to "\tcode{\textbackslash}"", which is not a valid token
\end{codeblock}
\end{example}


\rSec2[ub.cpp.concat]{The \#\# operator}

\pnum
\ubxref{cpp.concat.invalid.preprocessing.token} \\
If an invalid preprocessing token results from using the concat operator the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define cat(x, y) x##y

void f() {
  cat(/, /) // undefined behavior // is not a valid preprocessing token
}
\end{codeblock}
\end{example}


\rSec2[ub.cpp.line]{Line control}

\pnum
\ubxref{cpp.line.zero.or.overflow} \\
When using the \tcode{\#line} directive, if the digit sequence
specifies zero or a number greater than 2147483647, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#line 4294967295        // undefined behavior, number greater than 2147483647

int main() { return notdefined; }
\end{codeblock}
\end{example}

\pnum
\ubxref{cpp.line.pptoken.not.match} \\
When using the \grammarterm{pp-tokens} variant of the \tcode{\#line} directive, if the directive resulting after all replacements does not match
one of the two previous forms, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define cat(a, b) a##b
#line cat(10, e20)
\end{codeblock}
\end{example}

\rSec2[ub.cpp.predefined]{Predefined macro names}

\pnum
\ubxref{cpp.predefined.define.undef} \\
If any of the pre-defined macro names in [cpp.predefined], or the identifier defined, is the subject of a \tcode{\#define}
or a \tcode{\#undef} preprocessing directive, the behavior is undefined.

\pnum
\begin{example}
\begin{codeblock}
#define __cplusplus 300012L
\end{codeblock}
\end{example}
