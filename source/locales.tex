%!TEX root = std.tex
\rSec0[localization]{Localization library}

\rSec1[localization.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to
encapsulate (and therefore be more portable when confronting)
cultural differences.
The locale facility includes
internationalization support for character classification and string collation,
numeric, monetary, and date/time formatting and parsing, and
message retrieval.

\pnum
The following subclauses describe components for
locales themselves,
the standard facets, and
facilities from the ISO C library,
as summarized in \tref{localization.summary}.

\begin{libsumtab}{Localization library summary}{localization.summary}
\ref{locales} & Locales                   &   \tcode{<locale>}    \\
\ref{locale.categories} & Standard \tcode{locale} categories &   \\ \rowsep
\ref{c.locales} & C library locales       &   \tcode{<clocale>}   \\
\end{libsumtab}

\rSec1[locale.syn]{Header \tcode{<locale>} synopsis}

\indexheader{locale}%
\begin{codeblock}
namespace std {
  // \ref{locale}, locale
  class locale;
  template<class Facet> const Facet& use_facet(const locale&);
  template<class Facet> bool         has_facet(const locale&) noexcept;

  // \ref{locale.convenience}, convenience interfaces
  template<class charT> bool isspace (charT c, const locale& loc);
  template<class charT> bool isprint (charT c, const locale& loc);
  template<class charT> bool iscntrl (charT c, const locale& loc);
  template<class charT> bool isupper (charT c, const locale& loc);
  template<class charT> bool islower (charT c, const locale& loc);
  template<class charT> bool isalpha (charT c, const locale& loc);
  template<class charT> bool isdigit (charT c, const locale& loc);
  template<class charT> bool ispunct (charT c, const locale& loc);
  template<class charT> bool isxdigit(charT c, const locale& loc);
  template<class charT> bool isalnum (charT c, const locale& loc);
  template<class charT> bool isgraph (charT c, const locale& loc);
  template<class charT> bool isblank (charT c, const locale& loc);
  template<class charT> charT toupper(charT c, const locale& loc);
  template<class charT> charT tolower(charT c, const locale& loc);

  // \ref{category.ctype}, ctype
  class ctype_base;
  template<class charT> class ctype;
  template<>            class ctype<char>;      // specialization
  template<class charT> class ctype_byname;
  class codecvt_base;
  template<class internT, class externT, class stateT> class codecvt;
  template<class internT, class externT, class stateT> class codecvt_byname;

  // \ref{category.numeric}, numeric
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class num_get;
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class num_put;
  template<class charT>
    class numpunct;
  template<class charT>
    class numpunct_byname;

  // \ref{category.collate}, collation
  template<class charT> class collate;
  template<class charT> class collate_byname;

  // \ref{category.time}, date and time
  class time_base;
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class time_get;
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class time_get_byname;
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class time_put;
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class time_put_byname;

  // \ref{category.monetary}, money
  class money_base;
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class money_get;
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class money_put;
  template<class charT, bool Intl = false>
    class moneypunct;
  template<class charT, bool Intl = false>
    class moneypunct_byname;

  // \ref{category.messages}, message retrieval
  class messages_base;
  template<class charT> class messages;
  template<class charT> class messages_byname;
}
\end{codeblock}

\pnum
The header \libheader{locale}
defines classes and declares functions
that encapsulate and manipulate the information peculiar to a locale.
\begin{footnote}
In this subclause, the type name \tcode{tm}
is an incomplete type that is defined in \libheaderref{ctime}.
\end{footnote}

\rSec1[locales]{Locales}

\rSec2[locale]{Class \tcode{locale}}

\rSec3[locale.general]{General}

\begin{codeblock}
namespace std {
  class locale {
  public:
    // types
    class facet;
    class id;
    using category = int;
    static const category   // values assigned here are for exposition only
      none     = 0,
      collate  = 0x010, ctype    = 0x020,
      monetary = 0x040, numeric  = 0x080,
      time     = 0x100, messages = 0x200,
      all = collate | ctype | monetary | numeric | time  | messages;

    // construct/copy/destroy
    locale() noexcept;
    locale(const locale& other) noexcept;
    explicit locale(const char* std_name);
    explicit locale(const string& std_name);
    locale(const locale& other, const char* std_name, category);
    locale(const locale& other, const string& std_name, category);
    template<class Facet> locale(const locale& other, Facet* f);
    locale(const locale& other, const locale& one, category);
    ~locale();                  // not virtual
    const locale& operator=(const locale& other) noexcept;
    template<class Facet> locale combine(const locale& other) const;

    // locale operations
    string name() const;

    bool operator==(const locale& other) const;

    template<class charT, class traits, class Allocator>
      bool operator()(const basic_string<charT, traits, Allocator>& s1,
                      const basic_string<charT, traits, Allocator>& s2) const;

    // global locale objects
    static       locale  global(const locale&);
    static const locale& classic();
  };
}
\end{codeblock}

\pnum
Class \tcode{locale} implements a type-safe polymorphic set of facets,
indexed by facet \textit{type}.
In other words, a facet has a dual role:
in one sense, it's just a class interface;
at the same time, it's an index into a locale's set of facets.

\pnum
Access to the facets of a \tcode{locale} is via two function templates,
\tcode{use_facet<>} and \tcode{has_facet<>}.

\pnum
\begin{example}
An iostream \tcode{operator<<} can be implemented as:
\begin{footnote}
Note that in the call to \tcode{put},
the stream is implicitly converted
to an \tcode{ostreambuf_iterator<charT, traits>}.
\end{footnote}

\begin{codeblock}
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<< (basic_ostream<charT, traits>& s, Date d) {
  typename basic_ostream<charT, traits>::sentry cerberos(s);
  if (cerberos) {
    tm tmbuf; d.extract(tmbuf);
    bool failed =
      use_facet<time_put<charT, ostreambuf_iterator<charT, traits>>>(
        s.getloc()).put(s, s, s.fill(), &tmbuf, 'x').failed();
    if (failed)
      s.setstate(s.badbit);     // can throw
  }
  return s;
}
\end{codeblock}
\end{example}

\pnum
In the call to \tcode{use_facet<Facet>(loc)},
the type argument chooses a facet,
making available all members of the named type.
If \tcode{Facet} is not present in a locale,
it throws the standard exception \tcode{bad_cast}.
A \Cpp{} program can check if a locale implements a particular facet
with the function template \tcode{has_facet<Facet>()}.
User-defined facets may be installed in a locale, and
used identically as may standard facets.

\pnum
\begin{note}
All locale semantics are accessed via
\tcode{use_facet<>} and \tcode{has_facet<>},
except that:

\begin{itemize}
\item
A member operator template
\begin{codeblock}
operator()(const basic_string<C, T, A>&, const basic_string<C, T, A>&)
\end{codeblock}
is provided so that a locale can be used as a predicate argument to
the standard collections, to collate strings.
\item
Convenient global interfaces are provided for
traditional \tcode{ctype} functions such as
\tcode{isdigit()} and \tcode{isspace()},
so that given a locale object \tcode{loc}
a \Cpp{} program can call \tcode{isspace(c, loc)}.
(This eases upgrading existing extractors\iref{istream.formatted}.)
\end{itemize}
\end{note}

\pnum
Once a facet reference is obtained from a locale object
by calling \tcode{use_facet<>},
that reference remains usable,
and the results from member functions of it may be cached and re-used,
as long as some locale object refers to that facet.

\pnum
In successive calls to a locale facet member function
on a facet object installed in the same locale,
the returned result shall be identical.

\pnum
A \tcode{locale} constructed
from a name string (such as \tcode{"POSIX"}), or
from parts of two named locales, has a name;
all others do not.
Named locales may be compared for equality;
an unnamed locale is equal only to (copies of) itself.
For an unnamed locale, \tcode{locale::name()} returns the string \tcode{"*"}.

\pnum
Whether there is
one global locale object for the entire program or
one global locale object per thread
is \impldef{whether locale object is global or per-thread}.
Implementations should provide one global locale object per thread.
If there is a single global locale object for the entire program,
implementations are not required to
avoid data races on it\iref{res.on.data.races}.

\rSec3[locale.types]{Types}

\rSec4[locale.category]{Type \tcode{locale::category}}

\indexlibrarymember{locale}{category}%
\begin{itemdecl}
using category = int;
\end{itemdecl}

\pnum
\textit{Valid} \tcode{category} values
include the \tcode{locale} member bitmask elements
\tcode{collate},
\tcode{ctype},
\tcode{monetary},
\tcode{numeric},
\tcode{time},
and
\tcode{messages},
each of which represents a single locale category.
In addition, \tcode{locale} member bitmask constant \tcode{none}
is defined as zero and represents no category.
And \tcode{locale} member bitmask constant \tcode{all}
is defined such that the expression
\begin{codeblock}
(collate | ctype | monetary | numeric | time | messages | all) == all
\end{codeblock}
is \tcode{true},
and represents the union of all categories.
Further, the expression \tcode{(X | Y)},
where \tcode{X} and \tcode{Y} each represent a single category,
represents the union of the two categories.

\pnum
\tcode{locale} member functions
expecting a \tcode{category} argument
require one of the \tcode{category} values defined above, or
the union of two or more such values.
Such a \tcode{category} value identifies a set of locale categories.
Each locale category, in turn, identifies a set of locale facets,
including at least those shown in \tref{locale.category.facets}.

\begin{floattable}{Locale category facets}{locale.category.facets}
{ll}
\topline
\lhdr{Category} &   \rhdr{Includes facets}                                      \\ \capsep
collate     &   \tcode{collate<char>}, \tcode{collate<wchar_t>}                 \\ \rowsep
ctype       &   \tcode{ctype<char>}, \tcode{ctype<wchar_t>}                     \\
            &   \tcode{codecvt<char, char, mbstate_t>}                            \\
            &   \tcode{codecvt<char16_t, char8_t, mbstate_t>}        \\
            &   \tcode{codecvt<char32_t, char8_t, mbstate_t>}        \\
            &   \tcode{codecvt<wchar_t, char, mbstate_t>}                         \\ \rowsep
monetary    &   \tcode{moneypunct<char>}, \tcode{moneypunct<wchar_t>}           \\
            &   \tcode{moneypunct<char, true>}, \tcode{moneypunct<wchar_t, true>} \\
            &   \tcode{money_get<char>}, \tcode{money_get<wchar_t>}             \\
            &   \tcode{money_put<char>}, \tcode{money_put<wchar_t>}             \\ \rowsep
numeric     &   \tcode{numpunct<char>}, \tcode{numpunct<wchar_t>}               \\
            &   \tcode{num_get<char>}, \tcode{num_get<wchar_t>}                 \\
            &   \tcode{num_put<char>}, \tcode{num_put<wchar_t>}                 \\ \rowsep
time        &   \tcode{time_get<char>}, \tcode{time_get<wchar_t>}               \\
            &   \tcode{time_put<char>}, \tcode{time_put<wchar_t>}               \\ \rowsep
messages    &   \tcode{messages<char>}, \tcode{messages<wchar_t>}               \\
\end{floattable}

\pnum
For any locale \tcode{loc}
either constructed, or returned by \tcode{locale::classic()},
and any facet \tcode{Facet} shown in \tref{locale.category.facets},
\tcode{has_facet<Facet>(loc)} is \tcode{true}.
Each \tcode{locale} member function
which takes a \tcode{locale::category} argument
operates on the corresponding set of facets.

\pnum
An implementation is required to provide those specializations
for facet templates identified as members of a category, and
for those shown in \tref{locale.spec}.

\begin{floattable}{Required specializations}{locale.spec}
{ll}
\topline
\lhdr{Category} &   \rhdr{Includes facets}                                          \\ \capsep
collate     &   \tcode{collate_byname<char>}, \tcode{collate_byname<wchar_t>}       \\ \rowsep
ctype       &   \tcode{ctype_byname<char>}, \tcode{ctype_byname<wchar_t>}           \\
            &   \tcode{codecvt_byname<char, char, mbstate_t>}                       \\
            &   \tcode{codecvt_byname<char16_t, char8_t, mbstate_t>}                   \\
            &   \tcode{codecvt_byname<char32_t, char8_t, mbstate_t>}                   \\
            &   \tcode{codecvt_byname<wchar_t, char, mbstate_t>}                    \\ \rowsep
monetary    &   \tcode{moneypunct_byname<char, International>}                      \\
            &   \tcode{moneypunct_byname<wchar_t, International>}                   \\
            &   \tcode{money_get<C, InputIterator>}                                 \\
            &   \tcode{money_put<C, OutputIterator>}                                \\ \rowsep
numeric     &   \tcode{numpunct_byname<char>}, \tcode{numpunct_byname<wchar_t>}     \\
            &   \tcode{num_get<C, InputIterator>}, \tcode{num_put<C, OutputIterator>} \\ \rowsep
time        &   \tcode{time_get<char, InputIterator>}                               \\
            &   \tcode{time_get_byname<char, InputIterator>}                        \\
            &   \tcode{time_get<wchar_t, InputIterator>}                            \\
            &   \tcode{time_get_byname<wchar_t, InputIterator>}                     \\
            &   \tcode{time_put<char, OutputIterator>}                              \\
            &   \tcode{time_put_byname<char, OutputIterator>}                       \\
            &   \tcode{time_put<wchar_t, OutputIterator>}                           \\
            &   \tcode{time_put_byname<wchar_t, OutputIterator>}                    \\ \rowsep
messages    &   \tcode{messages_byname<char>}, \tcode{messages_byname<wchar_t>}     \\
\end{floattable}


\pnum
The provided implementation of members of
facets \tcode{num_get<charT>} and \tcode{num_put<charT>}
calls \tcode{use_fac\-et<F>(l)} only for facet \tcode{F} of
types \tcode{numpunct<charT>} and \tcode{ctype<charT>},
and for locale \tcode{l} the value obtained by calling member \tcode{getloc()}
on the \tcode{ios_base\&} argument to these functions.

\pnum
In declarations of facets,
a template parameter with name \tcode{InputIterator} or \tcode{OutputIterator}
indicates the set of all possible specializations on parameters that meet the
\oldconcept{InputIterator} requirements or
\oldconcept{OutputIterator} requirements,
respectively\iref{iterator.requirements}.
A template parameter with name \tcode{C} represents
the set of types containing \keyword{char}, \keyword{wchar_t}, and any other
\impldef{set of character types
that iostreams templates can be instantiated for}
character types
that meet the requirements for a character
on which any of the iostream components can be instantiated.
A template parameter with name \tcode{International}
represents the set of all possible specializations on a bool parameter.

\rSec4[locale.facet]{Class \tcode{locale::facet}}

\indexlibrarymember{locale}{facet}%
\begin{codeblock}
namespace std {
  class locale::facet {
  protected:
    explicit facet(size_t refs = 0);
    virtual ~facet();
    facet(const facet&) = delete;
    void operator=(const facet&) = delete;
  };
}
\end{codeblock}

\pnum
Class \tcode{facet} is the base class for locale feature sets.
A class is a \defn{facet}
if it is publicly derived from another facet, or
if it is a class derived from \tcode{locale::facet} and
contains a publicly accessible declaration as follows:
\begin{footnote}
This is a complete list of requirements; there are no other requirements.
Thus, a facet class need not have a public
copy constructor, assignment, default constructor, destructor, etc.
\end{footnote}
\begin{codeblock}
static ::std::locale::id id;
\end{codeblock}

\pnum
Template parameters in this Clause
which are required to be facets
are those named \tcode{Facet} in declarations.
A program that passes
a type that is \textit{not} a facet, or
a type that refers to a volatile-qualified facet,
as an (explicit or deduced) template parameter to
a locale function expecting a facet,
is ill-formed.
A const-qualified facet is a valid template argument to
any locale function that expects a \tcode{Facet} template parameter.

\pnum
The \tcode{refs} argument to the constructor is used for lifetime management.
For \tcode{refs == 0},
the implementation performs \tcode{delete static_cast<locale::facet*>(f)}
(where \tcode{f} is a point\-er to the facet)
when the last \tcode{locale} object containing the facet is destroyed;
for \tcode{refs == 1}, the implementation never destroys the facet.

\pnum
Constructors of all facets defined in this Clause
take such an argument and pass it along to
their \tcode{facet} base class constructor.
All one-argument constructors defined in this Clause are \term{explicit},
preventing their participation in implicit conversions.

\pnum
For some standard facets a standard ``$\ldots$\tcode{_byname}'' class,
derived from it, implements the virtual function semantics
equivalent to that facet of the locale
constructed by \tcode{locale(const char*)} with the same name.
Each such facet provides a constructor that takes
a \tcode{const char*} argument, which names the locale, and
a \tcode{refs} argument, which is passed to the base class constructor.
Each such facet also provides a constructor that takes
a \tcode{string} argument \tcode{str} and
a \tcode{refs} argument,
which has the same effect as calling the first constructor
with the two arguments \tcode{str.c_str()} and \tcode{refs}.
If there is no ``$\ldots$\tcode{_byname}'' version of a facet,
the base class implements named locale semantics itself
by reference to other facets.

\rSec4[locale.id]{Class \tcode{locale::id}}

\indexlibrarymember{locale}{id}%
\begin{codeblock}
namespace std {
  class locale::id {
  public:
    id();
    void operator=(const id&) = delete;
    id(const id&) = delete;
  };
}
\end{codeblock}

\pnum
The class \tcode{locale::id} provides
identification of a locale facet interface,
used as an index for lookup and to encapsulate initialization.

\pnum
\begin{note}
Because facets are used by iostreams,
potentially while static constructors are running,
their initialization cannot depend on programmed static initialization.
One initialization strategy is for \tcode{locale}
to initialize each facet's \tcode{id} member
the first time an instance of the facet is installed into a locale.
This depends only on static storage being zero
before constructors run\iref{basic.start.static}.
\end{note}

\rSec3[locale.cons]{Constructors and destructor}

\indexlibraryctor{locale}%
\begin{itemdecl}
locale() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a copy of the argument last passed to
\tcode{locale::global(locale\&)},
if it has been called;
else, the resulting facets have virtual function semantics identical to
those of \tcode{locale::classic()}.
\begin{note}
This constructor yields a copy of the current global locale.
It is commonly used as a default argument for
function parameters of type \tcode{const locale\&}.
\end{note}
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
explicit locale(const char* std_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a locale using standard C locale names, e.g., \tcode{"POSIX"}.
The resulting locale implements semantics defined to be associated
with that name.

\pnum
\throws
\tcode{runtime_error} if the argument is not valid, or is null.

\pnum
\remarks
The set of valid string argument values is
\tcode{"C"}, \tcode{""}, and any \impldef{locale names} values.
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
explicit locale(const string& std_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{locale(std_name.c_str())}.
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
locale(const locale& other, const char* std_name, category cats);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{cats} is a valid \tcode{category} value\iref{locale.category}.

\pnum
\effects
Constructs a locale as a copy of \tcode{other}
except for the facets identified by the \tcode{category} argument,
which instead implement the same semantics as \tcode{locale(std_name)}.

\pnum
\throws
\tcode{runtime_error} if the second argument is not valid, or is null.

\pnum
\remarks
The locale has a name if and only if \tcode{other} has a name.
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
locale(const locale& other, const string& std_name, category cats);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{locale(other, std_name.c_str(), cats)}.
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
template<class Facet> locale(const locale& other, Facet* f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a locale incorporating all facets from the first argument
except that of type \tcode{Facet},
and installs the second argument as the remaining facet.
If \tcode{f} is null, the resulting object is a copy of \tcode{other}.

\pnum
\remarks
If \tcode{f} is null,
the resulting locale has the same name as \tcode{other}.
Otherwise, the resulting locale has no name.
\end{itemdescr}

\indexlibraryctor{locale}%
\begin{itemdecl}
locale(const locale& other, const locale& one, category cats);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{cats} is a valid \tcode{category} value.

\pnum
\effects
Constructs a locale incorporating all facets from the first argument
except those that implement \tcode{cats},
which are instead incorporated from the second argument.

\pnum
\remarks
If \tcode{cats} is equal to \tcode{locale::none},
the resulting locale has a name if and only if the first argument has a name.
Otherwise, the resulting locale has a name if and only if
the first two arguments both have names.
\end{itemdescr}

\indexlibrarymember{operator=}{locale}%
\begin{itemdecl}
const locale& operator=(const locale& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Creates a copy of \tcode{other}, replacing the current value.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec3[locale.members]{Members}

\indexlibrarymember{locale}{combine}%
\begin{itemdecl}
template<class Facet> locale combine(const locale& other) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a locale incorporating all facets from \tcode{*this}
except for that one facet of \tcode{other} that is identified by \tcode{Facet}.

\pnum
\returns
The newly created locale.

\pnum
\throws
\tcode{runtime_error} if \tcode{has_facet<Facet>(other)} is \tcode{false}.

\pnum
\remarks
The resulting locale has no name.
\end{itemdescr}

\indexlibrarymember{locale}{name}%
\begin{itemdecl}
string name() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The name of \tcode{*this}, if it has one;
otherwise, the string \tcode{"*"}.
\end{itemdescr}

\rSec3[locale.operators]{Operators}

\indexlibrarymember{locale}{operator==}%
\begin{itemdecl}
bool operator==(const locale& other) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if
both arguments are the same locale, or
one is a copy of the other, or
each has a name and the names are identical;
\tcode{false} otherwise.
\end{itemdescr}

\indexlibrarymember{locale}{operator()}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator()(const basic_string<charT, traits, Allocator>& s1,
                  const basic_string<charT, traits, Allocator>& s2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares two strings according to the \tcode{collate<charT>} facet.

\pnum
\returns
\begin{codeblock}
use_facet<collate<charT>>(*this).compare(s1.data(), s1.data() + s1.size(),
                                         s2.data(), s2.data() + s2.size()) < 0
\end{codeblock}

\pnum
\remarks
This member operator template (and therefore \tcode{locale} itself)
meets the requirements for
a comparator predicate template argument\iref{algorithms} applied to strings.

\pnum
\begin{example}
A vector of strings \tcode{v}
can be collated according to collation rules in locale \tcode{loc}
simply by\iref{alg.sort,vector}:

\begin{codeblock}
std::sort(v.begin(), v.end(), loc);
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec3[locale.statics]{Static members}

\indexlibrarymember{locale}{global}%
\begin{itemdecl}
static locale global(const locale& loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets the global locale to its argument.
Causes future calls to the constructor \tcode{locale()}
to return a copy of the argument.
If the argument has a name, does
\begin{codeblock}
setlocale(LC_ALL, loc.name().c_str());
\end{codeblock}
otherwise, the effect on the C locale, if any, is
\impldef{effect on C locale of calling \tcode{locale::global}}.

\pnum
\returns
The previous value of \tcode{locale()}.

\pnum
\remarks
No library function other than \tcode{locale::global()}
affects the value returned by \tcode{locale()}.
\begin{note}
See~\ref{c.locales} for data race considerations
when \tcode{setlocale} is invoked.
\end{note}
\end{itemdescr}

\indexlibrarymember{locale}{classic}%
\begin{itemdecl}
static const locale& classic();
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{"C"} locale.

\pnum
\returns
A locale that implements the classic \tcode{"C"} locale semantics,
equivalent to the value \tcode{locale("C")}.

\pnum
\remarks
This locale, its facets, and their member functions, do not change with time.
\end{itemdescr}

\rSec2[locale.global.templates]{\tcode{locale} globals}

\indexlibrarymember{locale}{use_facet}%
\begin{itemdecl}
template<class Facet> const Facet& use_facet(const locale& loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{Facet} is a facet class
whose definition contains the public static member \tcode{id}
as defined in~\ref{locale.facet}.

\pnum
\returns
A reference to the corresponding facet of \tcode{loc}, if present.

\pnum
\throws
\tcode{bad_cast} if \tcode{has_facet<Facet>(loc)} is \tcode{false}.

\pnum
\remarks
The reference returned remains valid
at least as long as any copy of \tcode{loc} exists.
\end{itemdescr}

\indexlibrarymember{locale}{has_facet}%
\begin{itemdecl}
template<class Facet> bool has_facet(const locale& loc) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if the facet requested is present in \tcode{loc};
otherwise \tcode{false}.
\end{itemdescr}

\rSec2[locale.convenience]{Convenience interfaces}

\rSec3[classification]{Character classification}

\indexlibraryglobal{isspace}%
\indexlibraryglobal{isprint}%
\indexlibraryglobal{iscntrl}%
\indexlibraryglobal{isupper}%
\indexlibraryglobal{islower}%
\indexlibraryglobal{isalpha}%
\indexlibraryglobal{isdigit}%
\indexlibraryglobal{ispunct}%
\indexlibraryglobal{isxdigit}%
\indexlibraryglobal{isalnum}%
\indexlibraryglobal{isgraph}%
\indexlibraryglobal{isblank}%
\begin{itemdecl}
template<class charT> bool isspace (charT c, const locale& loc);
template<class charT> bool isprint (charT c, const locale& loc);
template<class charT> bool iscntrl (charT c, const locale& loc);
template<class charT> bool isupper (charT c, const locale& loc);
template<class charT> bool islower (charT c, const locale& loc);
template<class charT> bool isalpha (charT c, const locale& loc);
template<class charT> bool isdigit (charT c, const locale& loc);
template<class charT> bool ispunct (charT c, const locale& loc);
template<class charT> bool isxdigit(charT c, const locale& loc);
template<class charT> bool isalnum (charT c, const locale& loc);
template<class charT> bool isgraph (charT c, const locale& loc);
template<class charT> bool isblank (charT c, const locale& loc);
\end{itemdecl}

\pnum
Each of these functions \tcode{is\placeholder{F}}
returns the result of the expression:
\begin{codeblock}
use_facet<ctype<charT>>(loc).is(ctype_base::@\placeholder{F}@, c)
\end{codeblock}
where \tcode{\placeholder{F}} is the \tcode{ctype_base::mask} value
corresponding to that function\iref{category.ctype}.
\begin{footnote}
When used in a loop,
it is faster to cache the \tcode{ctype<>} facet and use it directly, or
use the vector form of \tcode{ctype<>::is}.
\end{footnote}

\rSec3[conversions.character]{Character conversions}

\indexlibraryglobal{toupper}%
\begin{itemdecl}
template<class charT> charT toupper(charT c, const locale& loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{use_facet<ctype<charT>>(loc).toupper(c)}.
\end{itemdescr}

\indexlibraryglobal{tolower}%
\begin{itemdecl}
template<class charT> charT tolower(charT c, const locale& loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{use_facet<ctype<charT>>(loc).tolower(c)}.
\end{itemdescr}

\rSec1[locale.categories]{Standard \tcode{locale} categories}

\rSec2[locale.categories.general]{General}

\pnum
Each of the standard categories includes a family of facets.
Some of these implement formatting or parsing of a datum,
for use by standard or users' iostream operators \tcode{<<} and \tcode{>>},
as members \tcode{put()} and \tcode{get()}, respectively.
Each such member function takes an
\indexlibrarymember{flags}{ios_base}%
\tcode{ios_base\&} argument whose members
\indexlibrarymember{flags}{ios_base}%
\tcode{flags()},
\indexlibrarymember{precision}{ios_base}%
\tcode{precision()},
and
\indexlibrarymember{width}{ios_base}%
\tcode{width()},
specify the format of the corresponding datum\iref{ios.base}.
Those functions which need to use other facets call its member \tcode{getloc()}
to retrieve the locale imbued there.
Formatting facets use the character argument \tcode{fill}
to fill out the specified width where necessary.

\pnum
The \tcode{put()} members make no provision for error reporting.
(Any failures of the OutputIterator argument can be extracted from
the returned iterator.)
The \tcode{get()} members take an \tcode{ios_base::iostate\&} argument
whose value they ignore,
but set to \tcode{ios_base::failbit} in case of a parse error.

\pnum
Within subclause \ref{locale.categories} it is unspecified whether
one virtual function calls another virtual function.

\rSec2[category.ctype]{The \tcode{ctype} category}

\rSec3[category.ctype.general]{General}

\indexlibraryglobal{ctype_base}%
\begin{codeblock}
namespace std {
  class ctype_base {
  public:
    using mask = @\seebelow@;

    // numeric values are for exposition only.
    static const mask space  = 1 << 0;
    static const mask print  = 1 << 1;
    static const mask cntrl  = 1 << 2;
    static const mask upper  = 1 << 3;
    static const mask lower  = 1 << 4;
    static const mask alpha  = 1 << 5;
    static const mask digit  = 1 << 6;
    static const mask punct  = 1 << 7;
    static const mask xdigit = 1 << 8;
    static const mask blank  = 1 << 9;
    static const mask alnum  = alpha | digit;
    static const mask graph  = alnum | punct;
  };
}
\end{codeblock}

\pnum
The type \tcode{mask} is a bitmask type\iref{bitmask.types}.

\rSec3[locale.ctype]{Class template \tcode{ctype}}

\rSec4[locale.ctype.general]{General}

\indexlibraryglobal{ctype}%
\begin{codeblock}
namespace std {
  template<class charT>
    class ctype : public locale::facet, public ctype_base {
    public:
      using char_type = charT;

      explicit ctype(size_t refs = 0);

      bool         is(mask m, charT c) const;
      const charT* is(const charT* low, const charT* high, mask* vec) const;
      const charT* scan_is(mask m, const charT* low, const charT* high) const;
      const charT* scan_not(mask m, const charT* low, const charT* high) const;
      charT        toupper(charT c) const;
      const charT* toupper(charT* low, const charT* high) const;
      charT        tolower(charT c) const;
      const charT* tolower(charT* low, const charT* high) const;

      charT        widen(char c) const;
      const char*  widen(const char* low, const char* high, charT* to) const;
      char         narrow(charT c, char dfault) const;
      const charT* narrow(const charT* low, const charT* high, char dfault, char* to) const;

      static locale::id id;

    protected:
      ~ctype();
      virtual bool         do_is(mask m, charT c) const;
      virtual const charT* do_is(const charT* low, const charT* high, mask* vec) const;
      virtual const charT* do_scan_is(mask m, const charT* low, const charT* high) const;
      virtual const charT* do_scan_not(mask m, const charT* low, const charT* high) const;
      virtual charT        do_toupper(charT) const;
      virtual const charT* do_toupper(charT* low, const charT* high) const;
      virtual charT        do_tolower(charT) const;
      virtual const charT* do_tolower(charT* low, const charT* high) const;
      virtual charT        do_widen(char) const;
      virtual const char*  do_widen(const char* low, const char* high, charT* dest) const;
      virtual char         do_narrow(charT, char dfault) const;
      virtual const charT* do_narrow(const charT* low, const charT* high,
                                     char dfault, char* dest) const;
    };
}
\end{codeblock}

\pnum
Class \tcode{ctype} encapsulates the C library \libheader{cctype} features.
\tcode{istream} members are required to use \tcode{ctype<>}
for character classing during input parsing.

\pnum
The specializations
required in \tref{locale.category.facets}\iref{locale.category},
namely \tcode{ctype<char>} and \tcode{ctype<wchar_t>},
implement character classing appropriate
to the implementation's native character set.

\rSec4[locale.ctype.members]{\tcode{ctype} members}

\indexlibrarymember{ctype}{is}%
\begin{itemdecl}
bool         is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high, mask* vec) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_is(m, c)} or \tcode{do_is(low, high, vec)}.
\end{itemdescr}

\indexlibrarymember{ctype}{scan_is}%
\begin{itemdecl}
const charT* scan_is(mask m, const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_scan_is(m, low, high)}.
\end{itemdescr}

\indexlibrarymember{ctype}{scan_not}%
\begin{itemdecl}
const charT* scan_not(mask m, const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_scan_not(m, low, high)}.
\end{itemdescr}

\indexlibrarymember{ctype}{toupper}%
\begin{itemdecl}
charT        toupper(charT) const;
const charT* toupper(charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_toupper(c)} or \tcode{do_toupper(low, high)}.
\end{itemdescr}

\indexlibrarymember{ctype}{tolower}%
\begin{itemdecl}
charT        tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_tolower(c)} or \tcode{do_tolower(low, high)}.
\end{itemdescr}

\indexlibrarymember{ctype}{widen}%
\begin{itemdecl}
charT       widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_widen(c)} or \tcode{do_widen(low, high, to)}.
\end{itemdescr}

\indexlibrarymember{ctype}{narrow}%
\begin{itemdecl}
char         narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT* high, char dfault, char* to) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_narrow(c, dfault)} or \tcode{do_narrow(low, high, dfault, to)}.
\end{itemdescr}

\rSec4[locale.ctype.virtuals]{\tcode{ctype} virtual functions}

\indexlibrarymember{ctype}{do_is}%
\begin{itemdecl}
bool         do_is(mask m, charT c) const;
const charT* do_is(const charT* low, const charT* high, mask* vec) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Classifies a character or sequence of characters.
For each argument character,
identifies a value \tcode{M} of type \tcode{ctype_base::mask}.
The second form identifies a value \tcode{M} of type \tcode{ctype_base::mask}
for each \tcode{*p} where \tcode{(low <= p \&\& p < high)},
and places it into \tcode{vec[p - low]}.

\pnum
\returns
The first form returns the result of the expression \tcode{(M \& m) != 0};
i.e., \tcode{true} if the character has the characteristics specified.
The second form returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype_base}{do_scan_is}%
\begin{itemdecl}
const charT* do_scan_is(mask m, const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Locates a character in a buffer that conforms to a classification \tcode{m}.

\pnum
\returns
The smallest pointer \tcode{p} in the range \range{low}{high}
such that \tcode{is(m, *p)} would return \tcode{true};
otherwise, returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype}{do_scan_not}%
\begin{itemdecl}
const charT* do_scan_not(mask m, const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Locates a character in a buffer that fails to conform to a classification
\tcode{m}.

\pnum
\returns
The smallest pointer \tcode{p}, if any, in the range \range{low}{high}
such that \tcode{is(m, *p)} would return \tcode{false};
otherwise, returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype}{do_toupper}%
\begin{itemdecl}
charT        do_toupper(charT c) const;
const charT* do_toupper(charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Converts a character or characters to upper case.
The second form replaces
each character \tcode{*p} in the range \range{low}{high}
for which a corresponding upper-case character exists,
with that character.

\pnum
\returns
The first form returns
the corresponding upper-case character if it is known to exist, or
its argument if not.
The second form returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype}{do_tolower}%
\begin{itemdecl}
charT        do_tolower(charT c) const;
const charT* do_tolower(charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Converts a character or characters to lower case.
The second form replaces
each character \tcode{*p} in the range \range{low}{high}
and for which a corresponding lower-case character exists,
with that character.

\pnum
\returns
The first form returns
the corresponding lower-case character if it is known to exist, or
its argument if not.
The second form returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype}{do_widen}%
\begin{itemdecl}
charT        do_widen(char c) const;
const char*  do_widen(const char* low, const char* high, charT* dest) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Applies the simplest reasonable transformation
from a \tcode{char} value or sequence of \tcode{char} values
to the corresponding \tcode{charT} value or values.
\begin{footnote}
The parameter \tcode{c} of \tcode{do_widen} is intended to
accept values derived from \grammarterm{character-literal}s
for conversion to the locale's encoding.
\end{footnote}
The only characters for which unique transformations are required
are those in the basic character set\iref{lex.charset}.

For any named \tcode{ctype} category with
a \tcode{ctype<charT>} facet \tcode{ctc} and
valid \tcode{ctype_base::mask} value \tcode{M},
\tcode{(ctc.\brk{}is(M, c) || !is(M, do_widen(c)) )} is \tcode{true}.
\begin{footnote}
In other words, the transformed character is not
a member of any character classification
that \tcode{c} is not also a member of.
\end{footnote}

The second form transforms
each character \tcode{*p} in the range \range{low}{high},
placing the result in \tcode{dest[p - low]}.

\pnum
\returns
The first form returns the transformed value.
The second form returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype}{do_narrow}%
\begin{itemdecl}
char         do_narrow(charT c, char dfault) const;
const charT* do_narrow(const charT* low, const charT* high, char dfault, char* dest) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Applies the simplest reasonable transformation
from a \tcode{charT} value or sequence of \tcode{charT} values
to the corresponding \tcode{char} value or values.

For any character \tcode{c} in the basic character set\iref{lex.charset}
the transformation is such that
\begin{codeblock}
do_widen(do_narrow(c, 0)) == c
\end{codeblock}

For any named \tcode{ctype} category with
a \tcode{ctype<char>} facet \tcode{ctc} however, and
\tcode{ctype_base::mask} value \tcode{M},
\begin{codeblock}
(is(M, c) || !ctc.is(M, do_narrow(c, dfault)) )
\end{codeblock}
is \tcode{true} (unless \tcode{do_narrow} returns \tcode{dfault}).
In addition, for any digit character \tcode{c},
the expression \tcode{(do_narrow(c, dfault) - '0')}
evaluates to the digit value of the character.
The second form transforms
each character \tcode{*p} in the range \range{low}{high},
placing the result
(or \tcode{dfault} if no simple transformation is readily available)
in \tcode{dest[p - low]}.

\pnum
\returns
The first form returns the transformed value;
or \tcode{dfault} if no mapping is readily available.
The second form returns \tcode{high}.
\end{itemdescr}

\rSec3[locale.ctype.byname]{Class template \tcode{ctype_byname}}

\indexlibraryglobal{ctype_byname}%
\begin{codeblock}
namespace std {
  template<class charT>
    class ctype_byname : public ctype<charT> {
    public:
      using mask = typename ctype<charT>::mask;
      explicit ctype_byname(const char*, size_t refs = 0);
      explicit ctype_byname(const string&, size_t refs = 0);

    protected:
      ~ctype_byname();
    };
}
\end{codeblock}

\rSec3[facet.ctype.special]{\tcode{ctype<char>} specialization}

\rSec4[facet.ctype.special.general]{General}

\indexlibraryglobal{ctype<char>}%
\begin{codeblock}
namespace std {
  template<>
    class ctype<char> : public locale::facet, public ctype_base {
    public:
      using char_type = char;

      explicit ctype(const mask* tab = nullptr, bool del = false, size_t refs = 0);

      bool is(mask m, char c) const;
      const char* is(const char* low, const char* high, mask* vec) const;
      const char* scan_is (mask m, const char* low, const char* high) const;
      const char* scan_not(mask m, const char* low, const char* high) const;

      char        toupper(char c) const;
      const char* toupper(char* low, const char* high) const;
      char        tolower(char c) const;
      const char* tolower(char* low, const char* high) const;

      char  widen(char c) const;
      const char* widen(const char* low, const char* high, char* to) const;
      char  narrow(char c, char dfault) const;
      const char* narrow(const char* low, const char* high, char dfault, char* to) const;

      static locale::id id;
      static const size_t table_size = @\impdef@;

      const mask* table() const noexcept;
      static const mask* classic_table() noexcept;

    protected:
      ~ctype();
      virtual char        do_toupper(char c) const;
      virtual const char* do_toupper(char* low, const char* high) const;
      virtual char        do_tolower(char c) const;
      virtual const char* do_tolower(char* low, const char* high) const;

      virtual char        do_widen(char c) const;
      virtual const char* do_widen(const char* low, const char* high, char* to) const;
      virtual char        do_narrow(char c, char dfault) const;
      virtual const char* do_narrow(const char* low, const char* high,
                                    char dfault, char* to) const;
    };
}
\end{codeblock}

\pnum
A specialization \tcode{ctype<char>} is provided
so that the member functions on type \tcode{char} can be implemented inline.
\begin{footnote}
Only the \tcode{char} (not \tcode{unsigned char} and \tcode{signed char})
form is provided.
The specialization is specified in the standard,
and not left as an implementation detail,
because it affects the derivation interface for \tcode{ctype<char>}.
\end{footnote}
The \impldef{value of \tcode{ctype<char>::table_size}} value of
member \tcode{table_size} is at least 256.

\rSec4[facet.ctype.char.dtor]{Destructor}

\indexlibrarydtor{ctype<char>}%
\begin{itemdecl}
~ctype();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the constructor's first argument was nonzero, and
its second argument was \tcode{true},
does \tcode{delete [] table()}.
\end{itemdescr}

\rSec4[facet.ctype.char.members]{Members}

\pnum
\indexlibrarymember{ctype<char>}{ctype<char>}%
In the following member descriptions,
for \tcode{unsigned char} values \tcode{v} where \tcode{v >= table_size},
\tcode{table()[v]} is assumed to have an implementation-specific value
(possibly different for each such value \tcode{v})
without performing the array lookup.

\indexlibraryctor{ctype<char>}%
\begin{itemdecl}
explicit ctype(const mask* tbl = nullptr, bool del = false, size_t refs = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
Either \tcode{tbl == nullptr} is \tcode{true} or
\range{tbl}{tbl+table_size} is a valid range.

\pnum
\effects
Passes its \tcode{refs} argument to its base class constructor.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{is}%
\begin{itemdecl}
bool        is(mask m, char c) const;
const char* is(const char* low, const char* high, mask* vec) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The second form, for all \tcode{*p} in the range \range{low}{high},
assigns into \tcode{vec[p - low]} the value \tcode{table()[(unsigned char)*p]}.

\pnum
\returns
The first form returns \tcode{table()[(unsigned char)c] \& m};
the second form returns \tcode{high}.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{scan_is}%
\begin{itemdecl}
const char* scan_is(mask m, const char* low, const char* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The smallest \tcode{p} in the range \range{low}{high} such that
\begin{codeblock}
table()[(unsigned char) *p] & m
\end{codeblock}
is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{scan_not}%
\begin{itemdecl}
const char* scan_not(mask m, const char* low, const char* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The smallest \tcode{p} in the range \range{low}{high} such that
\begin{codeblock}
table()[(unsigned char) *p] & m
\end{codeblock}
is \tcode{false}.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{toupper}%
\begin{itemdecl}
char        toupper(char c) const;
const char* toupper(char* low, const char* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_toupper(c)} or \tcode{do_toupper(low, high)}, respectively.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{tolower}%
\begin{itemdecl}
char        tolower(char c) const;
const char* tolower(char* low, const char* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_tolower(c)} or \tcode{do_tolower(low, high)}, respectively.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{widen}%
\begin{itemdecl}
char  widen(char c) const;
const char* widen(const char* low, const char* high, char* to) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_widen(c)} or
\indexlibraryglobal{do_widen}%
\tcode{do_widen(low, high, to)}, respectively.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{narrow}%
\begin{itemdecl}
char        narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high, char dfault, char* to) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\indexlibraryglobal{do_narrow}%
\tcode{do_narrow(c, dfault)} or
\indexlibraryglobal{do_narrow}%
\tcode{do_narrow(low, high, dfault, to)},
respectively.
\end{itemdescr}

\indexlibrarymember{ctype<char>}{table}%
\begin{itemdecl}
const mask* table() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first constructor argument, if it was nonzero,
otherwise \tcode{classic_table()}.
\end{itemdescr}

\rSec4[facet.ctype.char.statics]{Static members}

\indexlibrarymember{ctype<char>}{classic_table}%
\begin{itemdecl}
static const mask* classic_table() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the initial element of an array of size \tcode{table_size}
which represents the classifications of characters in the \tcode{"C"} locale.
\end{itemdescr}

\rSec4[facet.ctype.char.virtuals]{Virtual functions}

\indexlibrarymember{ctype<char>}{do_toupper}%
\indexlibrarymember{ctype<char>}{do_tolower}%
\indexlibrarymember{ctype<char>}{do_widen}%
\indexlibrarymember{ctype<char>}{do_narrow}%
\begin{codeblock}
char        do_toupper(char) const;
const char* do_toupper(char* low, const char* high) const;
char        do_tolower(char) const;
const char* do_tolower(char* low, const char* high) const;

virtual char        do_widen(char c) const;
virtual const char* do_widen(const char* low, const char* high, char* to) const;
virtual char        do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low, const char* high,
                              char dfault, char* to) const;
\end{codeblock}

\pnum
These functions are described identically as those members of the same name
in the \tcode{ctype} class template\iref{locale.ctype.members}.

\rSec3[locale.codecvt]{Class template \tcode{codecvt}}

\rSec4[locale.codecvt.general]{General}

\indexlibraryglobal{codecvt}%
\begin{codeblock}
namespace std {
  class codecvt_base {
  public:
    enum result { ok, partial, error, noconv };
  };

  template<class internT, class externT, class stateT>
    class codecvt : public locale::facet, public codecvt_base {
    public:
      using intern_type = internT;
      using extern_type = externT;
      using state_type  = stateT;

      explicit codecvt(size_t refs = 0);

      result out(
        stateT& state,
        const internT* from, const internT* from_end, const internT*& from_next,
              externT*   to,       externT*   to_end,       externT*&   to_next) const;

      result unshift(
        stateT& state,
              externT*    to,      externT*   to_end,       externT*&   to_next) const;

      result in(
        stateT& state,
        const externT* from, const externT* from_end, const externT*& from_next,
              internT*   to,       internT*   to_end,       internT*&   to_next) const;

      int encoding() const noexcept;
      bool always_noconv() const noexcept;
      int length(stateT&, const externT* from, const externT* end, size_t max) const;
      int max_length() const noexcept;

      static locale::id id;

    protected:
      ~codecvt();
      virtual result do_out(
        stateT& state,
        const internT* from, const internT* from_end, const internT*& from_next,
              externT* to,         externT*   to_end,       externT*&   to_next) const;
      virtual result do_in(
        stateT& state,
        const externT* from, const externT* from_end, const externT*& from_next,
              internT* to,         internT*   to_end,       internT*&   to_next) const;
      virtual result do_unshift(
        stateT& state,
              externT* to,         externT*   to_end,       externT*&   to_next) const;

      virtual int do_encoding() const noexcept;
      virtual bool do_always_noconv() const noexcept;
      virtual int do_length(stateT&, const externT* from, const externT* end, size_t max) const;
      virtual int do_max_length() const noexcept;
    };
}
\end{codeblock}

\pnum
The class \tcode{codecvt<internT, externT, stateT>} is for use
when converting from one character encoding to another,
such as from wide characters to multibyte characters or
between wide character encodings such as UTF-32 and EUC.

\pnum
The \tcode{stateT} argument selects
the pair of character encodings being mapped between.

\pnum
The specializations required
in \tref{locale.category.facets}\iref{locale.category}
convert the implementation-defined native character set.
\tcode{codecvt<char, char, mbstate_t>} implements a degenerate conversion;
it does not convert at all.
\indextext{UTF-8}%
\indextext{UTF-16}%
\indextext{UTF-32}%
The specialization \tcode{codecvt<char16_t, char8_t, mbstate_t>}
converts between the UTF-16 and UTF-8 encoding forms, and
the specialization \tcode{codecvt<char32_t, char8_t, mbstate_t>}
converts between the UTF-32 and UTF-8 encoding forms.
\tcode{codecvt<wchar_t, char, mbstate_t>}
converts between the native character sets for ordinary and wide characters.
Specializations on \tcode{mbstate_t}
perform conversion between encodings known to the library implementer.
Other encodings can be converted by specializing on
a program-defined \tcode{stateT} type.
Objects of type \tcode{stateT} can contain any state
that is useful to communicate to or from
the specialized \tcode{do_in} or \tcode{do_out} members.

\rSec4[locale.codecvt.members]{Members}

\indexlibrarymember{codecvt}{out}%
\begin{itemdecl}
result out(
  stateT& state,
  const internT* from, const internT* from_end, const internT*& from_next,
  externT* to, externT* to_end, externT*& to_next) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_out(state, from, from_end, from_next, to, to_end, to_next)}.
\end{itemdescr}

\indexlibrarymember{codecvt}{unshift}%
\begin{itemdecl}
result unshift(stateT& state, externT* to, externT* to_end, externT*& to_next) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_unshift(state, to, to_end, to_next)}.
\end{itemdescr}

\indexlibrarymember{codecvt}{in}%
\begin{itemdecl}
result in(
  stateT& state,
  const externT* from, const externT* from_end, const externT*& from_next,
  internT* to, internT* to_end, internT*& to_next) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_in(state, from, from_end, from_next, to, to_end, to_next)}.
\end{itemdescr}

\indexlibrarymember{codecvt}{encoding}%
\begin{itemdecl}
int encoding() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_encoding()}.
\end{itemdescr}

\indexlibrarymember{codecvt}{always_noconv}%
\begin{itemdecl}
bool always_noconv() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_always_noconv()}.
\end{itemdescr}

\indexlibrarymember{codecvt}{length}%
\begin{itemdecl}
int length(stateT& state, const externT* from, const externT* from_end, size_t max) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_length(state, from, from_end, max)}.
\end{itemdescr}

\indexlibrarymember{codecvt}{max_length}%
\begin{itemdecl}
int max_length() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_max_length()}.
\end{itemdescr}

\rSec4[locale.codecvt.virtuals]{Virtual functions}

\indexlibrarymember{codecvt}{do_out}%
\indexlibrarymember{codecvt}{do_in}%
\begin{itemdecl}
result do_out(
  stateT& state,
  const internT* from, const internT* from_end, const internT*& from_next,
  externT* to, externT* to_end, externT*& to_next) const;

result do_in(
  stateT& state,
  const externT* from, const externT* from_end, const externT*& from_next,
  internT* to, internT* to_end, internT*& to_next) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{(from <= from_end \&\& to <= to_end)} is well-defined and \tcode{true};
\tcode{state} is initialized, if at the beginning of a sequence,
or else is equal to the result of converting
the preceding characters in the sequence.

\pnum
\effects
Translates characters in the source range \range{from}{from_end},
placing the results in sequential positions starting at destination \tcode{to}.
Converts no more than \tcode{(from_end - from)} source elements, and
stores no more than \tcode{(to_end - to)} destination elements.

\pnum
Stops if it encounters a character it cannot convert.
It always leaves the \tcode{from_next} and \tcode{to_next} pointers
pointing one beyond the last element successfully converted.
If returns \tcode{noconv},
\tcode{internT} and \tcode{externT} are the same type and
the converted sequence is identical to
the input sequence \range{from}{from\textunderscore\nobreak next}.
\tcode{to_next} is set equal to \tcode{to},
the value of \tcode{state} is unchanged, and
there are no changes to the values in \range{to}{to_end}.

\pnum
A \tcode{codecvt} facet
that is used by \tcode{basic_filebuf}\iref{file.streams}
shall have the property that if
\begin{codeblock}
do_out(state, from, from_end, from_next, to, to_end, to_next)
\end{codeblock}
would return \tcode{ok},
where \tcode{from != from_end},
then
\begin{codeblock}
do_out(state, from, from + 1, from_next, to, to_end, to_next)
\end{codeblock}
shall also return \tcode{ok},
and that if
\begin{codeblock}
do_in(state, from, from_end, from_next, to, to_end, to_next)
\end{codeblock}
would return \tcode{ok},
where \tcode{to != to_end},
then
\begin{codeblock}
do_in(state, from, from_end, from_next, to, to + 1, to_next)
\end{codeblock}
shall also return \tcode{ok}.
\begin{footnote}
Informally, this means that \tcode{basic_filebuf}
assumes that the mappings from internal to external characters is 1 to N:
that a \tcode{codecvt} facet that is used by \tcode{basic_filebuf}
can translate characters one internal character at a time.
\end{footnote}
\begin{note}
As a result of operations on \tcode{state},
it can return \tcode{ok} or \tcode{partial} and
set \tcode{from_next == from} and \tcode{to_next != to}.
\end{note}

\pnum
\returns
An enumeration value, as summarized in \tref{locale.codecvt.inout}.

\begin{floattable}{\tcode{do_in/do_out} result values}{locale.codecvt.inout}
{lp{3in}}
\topline
\lhdr{Value}    &   \rhdr{Meaning}                                  \\ \capsep
\tcode{ok}                  &   completed the conversion            \\
\tcode{partial}             &   not all source characters converted \\
\tcode{error}               &
encountered a character in \range{from}{from_end}
that cannot be converted                                           \\
\tcode{noconv}              &
\tcode{internT} and \tcode{externT} are the same type, and input
sequence is identical to converted sequence                         \\
\end{floattable}

A return value of \tcode{partial},
if \tcode{(from_next == from_end)},
indicates
that either the destination sequence has not absorbed
all the available destination elements, or
that additional source elements are needed
before another destination element can be produced.

\pnum
\remarks
Its operations on \tcode{state} are unspecified.
\begin{note}
This argument can be used, for example,
to maintain shift state,
to specify conversion options (such as count only), or
to identify a cache of seek offsets.
\end{note}
\end{itemdescr}

\indexlibrarymember{codecvt}{do_unshift}%
\begin{itemdecl}
result do_unshift(stateT& state, externT* to, externT* to_end, externT*& to_next) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{(to <= to_end)} is well-defined and \tcode{true};
\tcode{state} is initialized, if at the beginning of a sequence,
or else is equal to the result of converting
the preceding characters in the sequence.

\pnum
\effects
Places characters starting at \tcode{to}
that should be appended to terminate a sequence
when the current \tcode{stateT} is given by \tcode{state}.
\begin{footnote}
Typically these will be characters to return the state to \tcode{stateT()}.
\end{footnote}
Stores no more than \tcode{(to_end - to)} destination elements, and
leaves the \tcode{to_next} pointer
pointing one beyond the last element successfully stored.

\pnum
\returns
An enumeration value, as summarized in \tref{locale.codecvt.unshift}.

\begin{floattable}{\tcode{do_unshift} result values}{locale.codecvt.unshift}
{lp{.50\hsize}}
\topline
\lhdr{Value}                &   \rhdr{Meaning}                                          \\ \capsep
\tcode{ok}                  &   completed the sequence                                  \\
\tcode{partial}             &
space for more than \tcode{to_end - to} destination elements was needed
to terminate a sequence given the value of \tcode{state}\\
\tcode{error}               &   an unspecified error has occurred \\
\tcode{noconv}              &   no termination is needed for this \tcode{state_type}    \\
\end{floattable}
\end{itemdescr}

\indexlibrarymember{codecvt}{do_encoding}%
\begin{itemdecl}
int do_encoding() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{-1} if the encoding of the \tcode{externT} sequence is state-dependent;
else the constant number of \tcode{externT} characters
needed to produce an internal character;
or \tcode{0} if this number is not a constant.
\begin{footnote}
If \tcode{encoding()} yields \tcode{-1},
then more than \tcode{max_length()} \tcode{externT} elements
can be consumed when producing a single \tcode{internT} character, and
additional \tcode{externT} elements can appear at the end of a sequence
after those that yield the final \tcode{internT} character.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{codecvt}{do_always_noconv}%
\begin{itemdecl}
bool do_always_noconv() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{do_in()} and \tcode{do_out()} return \tcode{noconv}
for all valid argument values.
\tcode{codecvt<char, char, mbstate_t>} returns \tcode{true}.
\end{itemdescr}

\indexlibrarymember{codecvt}{do_length}%
\begin{itemdecl}
int do_length(stateT& state, const externT* from, const externT* from_end, size_t max) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{(from <= from_end)} is well-defined and \tcode{true};
\tcode{state} is initialized, if at the beginning of a sequence,
or else is equal to the result of converting
the preceding characters in the sequence.

\pnum
\effects
The effect on the \tcode{state} argument is as if
it called \tcode{do_in(state, from, from_end, from, to, to+max, to)}
for \tcode{to} pointing to a buffer of at least \tcode{max} elements.

\pnum
\returns
\tcode{(from_next-from)} where
\tcode{from_next} is the largest value in the range \crange{from}{from_end}
such that the sequence of values in the range \range{from}{from_next}
represents
\tcode{max} or fewer valid complete characters of type \tcode{internT}.
The specialization \tcode{codecvt<char, char, mbstate_t>},
returns the lesser of \tcode{max} and \tcode{(from_end-from)}.
\end{itemdescr}

\indexlibrarymember{codecvt}{do_max_length}%
\begin{itemdecl}
int do_max_length() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The maximum value that \tcode{do_length(state, from, from_end, 1)} can return
for any valid range \range{from}{from_end}
and \tcode{stateT} value \tcode{state}.
The specialization \tcode{codecvt<char, char, mbstate_t>::do_max_length()}
returns 1.
\end{itemdescr}

\rSec3[locale.codecvt.byname]{Class template \tcode{codecvt_byname}}

\indexlibraryglobal{codecvt_byname}%
\begin{codeblock}
namespace std {
  template<class internT, class externT, class stateT>
    class codecvt_byname : public codecvt<internT, externT, stateT> {
    public:
      explicit codecvt_byname(const char*, size_t refs = 0);
      explicit codecvt_byname(const string&, size_t refs = 0);

    protected:
      ~codecvt_byname();
    };
}
\end{codeblock}

\rSec2[category.numeric]{The numeric category}

\rSec3[category.numeric.general]{General}

\pnum
The classes \tcode{num_get<>} and \tcode{num_put<>}
handle numeric formatting and parsing.
Virtual functions are provided for several numeric types.
Implementations may (but are not required to) delegate
extraction of smaller types to extractors for larger types.
\begin{footnote}
Parsing \tcode{"-1"} correctly into, e.g., an \tcode{unsigned short}
requires that the corresponding member \tcode{get()}
at least extract the sign before delegating.
\end{footnote}

\pnum
All specifications of member functions for \tcode{num_put} and \tcode{num_get}
in the subclauses of~\ref{category.numeric} only apply to
the specializations required in Tables~\ref{tab:locale.category.facets}
and~\ref{tab:locale.spec}\iref{locale.category}, namely
\tcode{num_get<char>},
\tcode{num_get<wchar_t>},
\tcode{num_get<C, InputIterator>},
\tcode{num_put<char>},
\tcode{num_put<wchar_t>}, and
\tcode{num_put<C, OutputIterator>}.
These specializations refer to the \tcode{ios_base\&} argument for
formatting specifications\iref{locale.categories},
and to its imbued locale for the \tcode{numpunct<>} facet to
identify all numeric punctuation preferences,
and also for the \tcode{ctype<>} facet to perform character classification.

\pnum
Extractor and inserter members of the standard iostreams use
\tcode{num_get<>} and \tcode{num_put<>} member functions for
formatting and parsing
numeric values\iref{istream.formatted.reqmts,ostream.formatted.reqmts}.

\rSec3[locale.num.get]{Class template \tcode{num_get}}

\rSec4[locale.num.get.general]{General}

\indexlibraryglobal{num_get}%
\begin{codeblock}
namespace std {
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class num_get : public locale::facet {
    public:
      using char_type = charT;
      using iter_type = InputIterator;

      explicit num_get(size_t refs = 0);

      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, bool& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, long& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, long long& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned short& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned int& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned long& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned long long& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, float& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, double& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, long double& v) const;
      iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, void*& v) const;

      static locale::id id;

    protected:
      ~num_get();
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, bool& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, long& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, long long& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, unsigned short& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, unsigned int& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, unsigned long& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, unsigned long long& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, float& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, double& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, long double& v) const;
      virtual iter_type do_get(iter_type, iter_type, ios_base&,
                               ios_base::iostate& err, void*& v) const;
    };
}
\end{codeblock}

\pnum
The facet \tcode{num_get} is used to parse numeric values
from an input sequence such as an istream.

\rSec4[facet.num.get.members]{Members}

\indexlibrarymember{num_get}{get}%
\begin{itemdecl}
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, bool& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, unsigned short& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, unsigned int& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, unsigned long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, unsigned long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, float& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, long double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
              ios_base::iostate& err, void*& val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get(in, end, str, err, val)}.
\end{itemdescr}

\rSec4[facet.num.get.virtuals]{Virtual functions}

\indexlibrarymember{num_get}{do_get}%
\begin{itemdecl}
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, unsigned short& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, unsigned int& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, unsigned long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, unsigned long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, float& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, long double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                ios_base::iostate& err, void*& val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters from \tcode{in},
interpreting them according to
\tcode{str.flags()},
\tcode{use_facet<ctype<\brk{}charT>>(loc)}, and
\tcode{use_facet<numpunct<charT>>(loc)},
where \tcode{loc} is \tcode{str.getloc()}.

\pnum
The details of this operation occur in three stages

\begin{itemize}
\item
Stage 1:
Determine a conversion specifier
\item
Stage 2:
Extract characters from \tcode{in} and
determine a corresponding \tcode{char} value for
the format expected by the conversion specification determined in stage 1.
\item
Stage 3:
Store results
\end{itemize}

\pnum
The details of the stages are presented below.

\begin{description}
\stage{1}
The function initializes local variables via
\begin{codeblock}
fmtflags flags = str.flags();
fmtflags basefield = (flags & ios_base::basefield);
fmtflags uppercase = (flags & ios_base::uppercase);
fmtflags boolalpha = (flags & ios_base::boolalpha);
\end{codeblock}

For conversion to an integral type,
the function determines the integral conversion specifier
as indicated in \tref{facet.num.get.int}.
The table is ordered.
That is, the first line whose condition is true applies.

\begin{floattable}{Integer conversions}{facet.num.get.int}
{lc}
\topline
\lhdr{State}                    &   \tcode{stdio} equivalent   \\ \capsep
\tcode{basefield == oct}        &   \tcode{\%o}                 \\ \rowsep
\tcode{basefield == hex}        &   \tcode{\%X}                 \\ \rowsep
\tcode{basefield == 0}          &   \tcode{\%i}                 \\ \capsep
\tcode{signed} integral type    &   \tcode{\%d}                 \\ \rowsep
\tcode{unsigned} integral type  &   \tcode{\%u}                 \\
\end{floattable}

For conversions to a floating-point type the specifier is \tcode{\%g}.

For conversions to \tcode{void*} the specifier is \tcode{\%p}.

A length modifier is added to the conversion specification, if needed,
as indicated in \tref{facet.num.get.length}.

\begin{floattable}{Length modifier}{facet.num.get.length}
{lc}
\topline
\lhdr{Type}                 &   Length modifier \\ \capsep
\tcode{short}               &   \tcode{h}       \\ \rowsep
\tcode{unsigned short}      &   \tcode{h}       \\ \rowsep
\tcode{long}                &   \tcode{l}       \\ \rowsep
\tcode{unsigned long}       &   \tcode{l}       \\ \rowsep
\tcode{long long}           &   \tcode{ll}      \\ \rowsep
\tcode{unsigned long long}  &   \tcode{ll}      \\ \rowsep
\tcode{double}              &   \tcode{l}       \\ \rowsep
\tcode{long double}         &   \tcode{L}       \\
\end{floattable}

\stage{2}
If \tcode{in == end} then stage 2 terminates.
Otherwise a \tcode{charT} is taken from \tcode{in} and
local variables are initialized as if by
\begin{codeblock}
char_type ct = *in;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct == use_facet<numpunct<charT>>(loc).decimal_point())
  c = '.';
bool discard =
  ct == use_facet<numpunct<charT>>(loc).thousands_sep()
  && use_facet<numpunct<charT>>(loc).grouping().length() != 0;
\end{codeblock}
where the values \tcode{src} and \tcode{atoms} are defined as if by:
\begin{codeblock}
static const char src[] = "0123456789abcdefpxABCDEFPX+-";
char_type atoms[sizeof(src)];
use_facet<ctype<charT>>(loc).widen(src, src + sizeof(src), atoms);
\end{codeblock}
for this value of \tcode{loc}.

If \tcode{discard} is \tcode{true},
then if \tcode{'.'} has not yet been accumulated,
then the position of the character is remembered,
but the character is otherwise ignored.
Otherwise, if \tcode{'.'} has already been accumulated,
the character is discarded and Stage 2 terminates.
If it is not discarded,
then a check is made to determine
if \tcode{c} is allowed as the next character of
an input field of the conversion specifier returned by Stage 1.
If so, it is accumulated.

If the character is either discarded or accumulated
then \tcode{in} is advanced by \tcode{++in}
and processing returns to the beginning of stage 2.

\begin{example}
Given an input sequence of \tcode{"0x1a.bp+07p"},
\begin{itemize}
\item
if the conversion specifier returned by Stage 1 is \tcode{\%d},
\tcode{"0"} is accumulated;
\item
if the conversion specifier returned by Stage 1 is \tcode{\%i},
\tcode{"0x1a"} are accumulated;
\item
if the conversion specifier returned by Stage 1 is \tcode{\%g},
\tcode{"0x1a.bp+07"} are accumulated.
\end{itemize}
In all cases, the remainder is left in the input.
\end{example}

\stage{3}
The sequence of \tcode{char}{s} accumulated in stage 2 (the field)
is converted to a numeric value by the rules of one of the functions
declared in the header \libheader{cstdlib}:

\begin{itemize}
\item
For a signed integer value, the function \tcode{strtoll}.
\item
For an unsigned integer value, the function \tcode{strtoull}.
\item
For a \tcode{float} value, the function \tcode{strtof}.
\item
For a \tcode{double} value, the function \tcode{strtod}.
\item
For a \tcode{long double} value, the function \tcode{strtold}.
\end{itemize}

The numeric value to be stored can be one of:
\begin{itemize}
\item
zero, if the conversion function does not convert the entire field.
\item
the most positive (or negative) representable value,
if the field to be converted to a signed integer type represents a value
too large positive (or negative) to be represented in \tcode{val}.
\item
the most positive representable value,
if the field to be converted to an unsigned integer type represents a value
that cannot be represented in \tcode{val}.
\item
the converted value, otherwise.
\end{itemize}

The resultant numeric value is stored in \tcode{val}.
If the conversion function does not convert the entire field, or
if the field represents a value outside the range of representable values,
\tcode{ios_base::failbit} is assigned to \tcode{err}.

\end{description}

\pnum
Digit grouping is checked.
That is, the positions of discarded
separators are examined for consistency with
\tcode{use_facet<numpunct<charT>>(loc).grouping()}.
If they are not consistent
then \tcode{ios_base::failbit} is assigned to \tcode{err}.

\pnum
In any case,
if stage 2 processing was terminated by the test for \tcode{in == end}
then \tcode{err |= ios_base::eofbit} is performed.
\end{itemdescr}

\indexlibrarymember{do_get}{num_get}%
\begin{itemdecl}
iter_type do_get(iter_type in, iter_type end, ios_base& str,
                 ios_base::iostate& err, bool& val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{(str.flags()\&ios_base::boolalpha) == 0}
then input proceeds as it would for a \tcode{long}
except that if a value is being stored into \tcode{val},
the value is determined according to the following:
If the value to be stored is 0 then \tcode{false} is stored.
If the value is \tcode{1} then \tcode{true} is stored.
Otherwise \tcode{true} is stored and
\tcode{ios_base::failbit} is assigned to \tcode{err}.

\pnum
Otherwise target sequences are determined ``as if'' by
calling the members \tcode{falsename()} and \tcode{truename()} of
the facet obtained by \tcode{use_facet<numpunct<charT>>(str.getloc())}.
Successive characters in the range \range{in}{end} (see~\ref{sequence.reqmts})
are obtained and matched against
corresponding positions in the target sequences
only as necessary to identify a unique match.
The input iterator \tcode{in} is compared to \tcode{end}
only when necessary to obtain a character.
If a target sequence is uniquely matched,
\tcode{val} is set to the corresponding value.
Otherwise \tcode{false} is stored and
\tcode{ios_base::failbit} is assigned to \tcode{err}.

\pnum
The \tcode{in} iterator is always left pointing one position beyond
the last character successfully matched.
If \tcode{val} is set, then \tcode{err} is set to \tcode{str.goodbit};
or to \tcode{str.eofbit} if,
when seeking another character to match,
it is found that \tcode{(in == end)}.
If \tcode{val} is not set, then \tcode{err} is set to \tcode{str.failbit};
or to \tcode{(str.failbit|str.eofbit)}
if the reason for the failure was that \tcode{(in == end)}.
\begin{example}
For targets \tcode{true}: \tcode{"a"} and \tcode{false}: \tcode{"abb"},
the input sequence \tcode{"a"} yields
\tcode{val == true} and \tcode{err == str.eofbit};
the input sequence \tcode{"abc"} yields
\tcode{err = str.failbit}, with \tcode{in} ending at the \tcode{'c'} element.
For targets \tcode{true}: \tcode{"1"} and \tcode{false}: \tcode{"0"},
the input sequence \tcode{"1"} yields
\tcode{val == true} and \tcode{err == str.goodbit}.
For empty targets \tcode{("")},
any input sequence yields \tcode{err == str.failbit}.
\end{example}

\pnum
\returns
\tcode{in}.
\end{itemdescr}

\rSec3[locale.nm.put]{Class template \tcode{num_put}}

\rSec4[locale.nm.put.general]{General}

\indexlibraryglobal{num_put}%
\begin{codeblock}
namespace std {
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class num_put : public locale::facet {
    public:
      using char_type = charT;
      using iter_type = OutputIterator;

      explicit num_put(size_t refs = 0);

      iter_type put(iter_type s, ios_base& f, char_type fill, bool v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, long v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, long long v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, unsigned long v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, unsigned long long v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, double v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, long double v) const;
      iter_type put(iter_type s, ios_base& f, char_type fill, const void* v) const;

      static locale::id id;

    protected:
      ~num_put();
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, bool v) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, long v) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, long long v) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, unsigned long) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, unsigned long long) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, double v) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, long double v) const;
      virtual iter_type do_put(iter_type, ios_base&, char_type fill, const void* v) const;
    };
}
\end{codeblock}

\pnum
The facet
\tcode{num_put}
is used to format numeric values to a character sequence such as an ostream.

\rSec4[facet.num.put.members]{Members}

\indexlibrarymember{num_put}{put}%
\begin{itemdecl}
iter_type put(iter_type out, ios_base& str, char_type fill, bool val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, unsigned long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, unsigned long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, const void* val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_put(out, str, fill, val)}.
\end{itemdescr}

\rSec4[facet.num.put.virtuals]{Virtual functions}

\indexlibrarymember{num_put}{do_put}%
\begin{itemdecl}
iter_type do_put(iter_type out, ios_base& str, char_type fill, long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, unsigned long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, unsigned long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, long double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, const void* val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Writes characters to the sequence \tcode{out},
formatting \tcode{val} as desired.
In the following description, \tcode{loc} names a local variable initialized as
\begin{codeblock}
locale loc = str.getloc();
\end{codeblock}

\pnum
The details of this operation occur in several stages:

\begin{itemize}
\item
Stage 1:
Determine a printf conversion specifier \tcode{spec} and
determine the characters
that would be printed by \tcode{printf}\iref{c.files}
given this conversion specifier for
\begin{codeblock}
printf(spec, val)
\end{codeblock}
assuming that the current locale is the \tcode{"C"} locale.
\item
Stage 2:
Adjust the representation by converting
each \tcode{char} determined by stage 1 to a \tcode{charT}
using a conversion and
values returned by members of \tcode{use_facet<numpunct<charT>>(loc)}.
\item
Stage 3:
Determine where padding is required.
\item
Stage 4:
Insert the sequence into the \tcode{out}.
\end{itemize}

\pnum
Detailed descriptions of each stage follow.

\pnum
\returns
\tcode{out}.

\pnum
\begin{description}
\stage{1}
The first action of stage 1 is to determine a conversion specifier.
The tables that describe this determination use the following local variables

\begin{codeblock}
fmtflags flags = str.flags();
fmtflags basefield =  (flags & (ios_base::basefield));
fmtflags uppercase =  (flags & (ios_base::uppercase));
fmtflags floatfield = (flags & (ios_base::floatfield));
fmtflags showpos =    (flags & (ios_base::showpos));
fmtflags showbase =   (flags & (ios_base::showbase));
fmtflags showpoint =  (flags & (ios_base::showpoint));
\end{codeblock}

All tables used in describing stage 1 are ordered.
That is, the first line whose condition is true applies.
A line without a condition is the default behavior
when none of the earlier lines apply.

For conversion from an integral type other than a character type,
the function determines the integral conversion specifier
as indicated in \tref{facet.num.put.int}.

\begin{floattable}{Integer conversions}{facet.num.put.int}
{lc}
\topline
\lhdr{State}                        &   \tcode{stdio} equivalent       \\ \capsep
\tcode{basefield == ios_base::oct}                      &   \tcode{\%o} \\ \rowsep
\tcode{(basefield == ios_base::hex) \&\& !uppercase}    &   \tcode{\%x} \\ \rowsep
\tcode{(basefield == ios_base::hex)}                    &   \tcode{\%X} \\ \rowsep
for a \tcode{signed} integral type                     &   \tcode{\%d} \\ \rowsep
for an \tcode{unsigned} integral type                  &   \tcode{\%u} \\
\end{floattable}

For conversion from a floating-point type,
the function determines the floating-point conversion specifier
as indicated in \tref{facet.num.put.fp}.

\begin{floattable}{Floating-point conversions}{facet.num.put.fp}
{lc}
\topline
\lhdr{State}            &   \tcode{stdio} equivalent                       \\ \capsep
\tcode{floatfield == ios_base::fixed}                       &   \tcode{\%f} \\ \rowsep
\tcode{floatfield == ios_base::scientific \&\& !uppercase}  &   \tcode{\%e} \\ \rowsep
\tcode{floatfield == ios_base::scientific}                  &   \tcode{\%E} \\ \rowsep
\tcode{floatfield == (ios_base::fixed | ios_base::scientific) \&\& !uppercase} & \tcode{\%a} \\ \rowsep
\tcode{floatfield == (ios_base::fixed | ios_base::scientific)} & \tcode{\%A} \\ \rowsep
\tcode{!uppercase}                                          &   \tcode{\%g} \\ \rowsep
\textit{otherwise}                                          &   \tcode{\%G} \\
\end{floattable}

For conversions from an integral or floating-point type
a length modifier is added to the conversion specifier
as indicated in \tref{facet.num.put.length}.

\begin{floattable}{Length modifier}{facet.num.put.length}
{lc}
\topline
\lhdr{Type}                 &   Length modifier \\ \capsep
\tcode{long}                &   \tcode{l}       \\ \rowsep
\tcode{long long}           &   \tcode{ll}      \\ \rowsep
\tcode{unsigned long}       &   \tcode{l}       \\ \rowsep
\tcode{unsigned long long}  &   \tcode{ll}      \\ \rowsep
\tcode{long double}         &   \tcode{L}       \\ \rowsep
\textit{otherwise}          &   \textit{none}   \\
\end{floattable}

The conversion specifier has the following optional additional qualifiers
prepended as indicated in \tref{facet.num.put.conv}.

\begin{floattable}{Numeric conversions}{facet.num.put.conv}
{llc}
\topline
\lhdr{Type(s)}                  &   \chdr{State}       &   \tcode{stdio} equivalent   \\ \capsep
an integral type                &   \tcode{showpos}    &   \tcode{+}                   \\
                                &   \tcode{showbase}   &   \tcode{\#}                  \\ \rowsep
a floating-point type           &   \tcode{showpos}    &   \tcode{+}                   \\
                                &   \tcode{showpoint}  &   \tcode{\#}                  \\
\end{floattable}

For conversion from a floating-point type,
if \tcode{floatfield != (ios_base::fixed | ios_base::\brk{}scientific)},
\tcode{str.precision()} is specified as precision
in the conversion specification.
Otherwise, no precision is specified.

For conversion from \tcode{void*} the specifier is \tcode{\%p}.

The representations at the end of stage 1 consists of the \tcode{char}'s
that would be printed by a call of \tcode{printf(s, val)}
where \tcode{s} is the conversion specifier determined above.

\stage{2}
Any character \tcode{c} other than a decimal point(.) is converted to
a \tcode{charT} via
\begin{codeblock}
use_facet<ctype<charT>>(loc).widen(c)
\end{codeblock}

A local variable \tcode{punct} is initialized via
\begin{codeblock}
const numpunct<charT>& punct = use_facet<numpunct<charT>>(loc);
\end{codeblock}

For arithmetic types,
\tcode{punct.thousands_sep()} characters are inserted into
the sequence as determined by the value returned by \tcode{punct.do_grouping()}
using the method described in~\ref{facet.numpunct.virtuals}.

Decimal point characters(.) are replaced by \tcode{punct.decimal_point()}.

\stage{3}
A local variable is initialized as
\begin{codeblock}
fmtflags adjustfield = (flags & (ios_base::adjustfield));
\end{codeblock}

The location of any padding
\begin{footnote}
The conversion specification \tcode{\#o} generates a leading \tcode{0}
which is \textit{not} a padding character.
\end{footnote}
is determined according to \tref{facet.num.put.fill}.

\begin{floattable}{Fill padding}{facet.num.put.fill}
{p{3in}l}
\topline
\lhdr{State}                            &   \rhdr{Location}                 \\ \capsep
\tcode{adjustfield == ios_base::left}   &   pad after                       \\ \rowsep
\tcode{adjustfield == ios_base::right}  &   pad before                      \\ \rowsep
\tcode{adjustfield == internal} and a sign occurs in the representation
                                        &   pad after the sign              \\ \rowsep
\tcode{adjustfield == internal} and representation after stage 1
began with 0x or 0X                     &   pad after x or X                \\ \rowsep
\textit{otherwise}                      &   pad before                      \\
\end{floattable}

If \tcode{str.width()} is nonzero and the number of \tcode{charT}'s
in the sequence after stage 2 is less than \tcode{str.\brk{}width()},
then enough \tcode{fill} characters are added to the sequence
at the position indicated for padding
to bring the length of the sequence to \tcode{str.width()}.

\tcode{str.width(0)} is called.

\stage{4}
The sequence of \tcode{charT}'s at the end of stage 3 are output via
\begin{codeblock}
*out++ = c
\end{codeblock}
\end{description}
\end{itemdescr}

\indexlibrarymember{do_put}{num_put}%
\begin{itemdecl}
iter_type do_put(iter_type out, ios_base& str, char_type fill, bool val) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{(str.flags() \& ios_base::boolalpha) == 0}
returns \tcode{do_put(out, str, fill,\\(int)val)},
otherwise obtains a string \tcode{s} as if by
\begin{codeblock}
string_type s =
  val ? use_facet<numpunct<charT>>(loc).truename()
      : use_facet<numpunct<charT>>(loc).falsename();
\end{codeblock}
and then inserts each character \tcode{c} of \tcode{s} into \tcode{out}
via \tcode{*out++ = c}
and returns \tcode{out}.
\end{itemdescr}

\rSec2[facet.numpunct]{The numeric punctuation facet}

\rSec3[locale.numpunct]{Class template \tcode{numpunct}}

\rSec4[locale.numpunct.general]{General}

\indexlibraryglobal{numpunct}%
\begin{codeblock}
namespace std {
  template<class charT>
    class numpunct : public locale::facet {
    public:
      using char_type   = charT;
      using string_type = basic_string<charT>;

      explicit numpunct(size_t refs = 0);

      char_type    decimal_point()   const;
      char_type    thousands_sep()   const;
      string       grouping()        const;
      string_type  truename()        const;
      string_type  falsename()       const;

      static locale::id id;

    protected:
      ~numpunct();                                              // virtual
      virtual char_type    do_decimal_point() const;
      virtual char_type    do_thousands_sep() const;
      virtual string       do_grouping()      const;
      virtual string_type  do_truename()      const;            // for \tcode{bool}
      virtual string_type  do_falsename()     const;            // for \tcode{bool}
    };
}
\end{codeblock}

\pnum
\tcode{numpunct<>} specifies numeric punctuation.
The specializations
required in \tref{locale.category.facets}\iref{locale.category},
namely \tcode{numpunct<\brk{}wchar_t>} and \tcode{numpunct<char>},
provide classic \tcode{"C"} numeric formats,
i.e., they contain information
equivalent to that contained in the \tcode{"C"} locale or
their wide character counterparts as if obtained by a call to \tcode{widen}.

% FIXME: For now, keep the locale grammar productions out of the index;
% they are conceptually unrelated to the main C++ grammar.
% Consider renaming these en masse (to locale-* ?) to avoid this problem.
\newcommand{\locnontermdef}[1]{{\BnfNontermshape#1\itcorr}\textnormal{:}}
\newcommand{\locgrammarterm}[1]{\gterm{#1}}

\pnum
The syntax for number formats is as follows,
where \locgrammarterm{digit} represents the radix set
specified by the \tcode{fmtflags} argument value, and
\locgrammarterm{thousands-sep} and \locgrammarterm{decimal-point}
are the results of corresponding \tcode{numpunct<charT>} members.
Integer values have the format:
\begin{ncbnf}
\locnontermdef{intval}\br
    \opt{sign} units
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{sign}\br
    \terminal{+}\br
    \terminal{-}
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{units}\br
    digits\br
    digits thousands-sep units
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{digits}\br
    digit \opt{digits}
\end{ncbnf}
and floating-point values have:
\begin{ncbnf}
\locnontermdef{floatval}\br
    \opt{sign} units \opt{fractional} \opt{exponent}\br
    \opt{sign} decimal-point digits \opt{exponent}
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{fractional}\br
    decimal-point \opt{digits}
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{exponent}\br
    e \opt{sign} digits
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{e}\br
    \terminal{e}\br
    \terminal{E}
\end{ncbnf}
where the number of digits between \locgrammarterm{thousands-sep}{s}
is as specified by \tcode{do_grouping()}.
For parsing,
if the \locgrammarterm{digits} portion contains no thousands-separators,
no grouping constraint is applied.

\rSec4[facet.numpunct.members]{Members}

\indexlibrarymember{numpunct}{decimal_point}%
\begin{itemdecl}
char_type decimal_point() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_decimal_point()}.
\end{itemdescr}

\indexlibrarymember{numpunct}{thousands_sep}%
\begin{itemdecl}
char_type thousands_sep() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_thousands_sep()}.
\end{itemdescr}

\indexlibrarymember{numpunct}{grouping}%
\begin{itemdecl}
string grouping()  const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_grouping()}.
\end{itemdescr}

\indexlibrarymember{numpunct}{truename}%
\indexlibrarymember{numpunct}{falsename}%
\begin{itemdecl}
string_type truename()  const;
string_type falsename() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_truename()}
or
\tcode{do_falsename()},
respectively.
\end{itemdescr}

\rSec4[facet.numpunct.virtuals]{Virtual functions}

\indexlibrarymember{numpunct}{do_decimal_point}%
\begin{itemdecl}
char_type do_decimal_point() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A character for use as the decimal radix separator.
The required specializations return \tcode{'.'} or \tcode{L'.'}.
\end{itemdescr}

\indexlibrarymember{numpunct}{do_thousands_sep}%
\begin{itemdecl}
char_type do_thousands_sep() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A character for use as the digit group separator.
The required specializations return \tcode{','} or \tcode{L','}.
\end{itemdescr}

\indexlibrarymember{numpunct}{do_grouping}%
\begin{itemdecl}
string do_grouping() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{string} \tcode{vec} used as a vector of integer values,
in which each element \tcode{vec[i]} represents the number of digits
\begin{footnote}
Thus,
the string \tcode{"\textbackslash003"} specifies groups of 3 digits each, and
\tcode{"3"} probably indicates groups of 51 (!) digits each,
because 51 is the ASCII value of \tcode{"3"}.
\end{footnote}
in the group at position \tcode{i},
starting with position 0 as the rightmost group.
If \tcode{vec.size() <= i},
the number is the same as group \tcode{(i - 1)};
if \tcode{(i < 0 || vec[i] <= 0 || vec[i] == CHAR_MAX)},
the size of the digit group is unlimited.

\pnum
The required specializations return the empty string, indicating no grouping.
\end{itemdescr}

\indexlibrarymember{numpunct}{do_truename}%
\indexlibrarymember{numpunct}{do_falsename}%
\begin{itemdecl}
string_type do_truename()  const;
string_type do_falsename() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string representing the name of
the boolean value \tcode{true} or \tcode{false}, respectively.

\pnum
In the base class implementation
these names are \tcode{"true"} and \tcode{"false"},
or \tcode{L"true"} and \tcode{L"false"}.
\end{itemdescr}

\rSec3[locale.numpunct.byname]{Class template \tcode{numpunct_byname}}

\indexlibraryglobal{numpunct_byname}%
\begin{codeblock}
namespace std {
  template<class charT>
    class numpunct_byname : public numpunct<charT> {
    // this class is specialized for \tcode{char} and \keyword{wchar_t}.
    public:
      using char_type   = charT;
      using string_type = basic_string<charT>;

      explicit numpunct_byname(const char*, size_t refs = 0);
      explicit numpunct_byname(const string&, size_t refs = 0);

    protected:
      ~numpunct_byname();
    };
}
\end{codeblock}

\rSec2[category.collate]{The collate category}

\rSec3[locale.collate]{Class template \tcode{collate}}

\rSec4[locale.collate.general]{General}

\indexlibraryglobal{collate}%
\begin{codeblock}
namespace std {
  template<class charT>
    class collate : public locale::facet {
    public:
      using char_type   = charT;
      using string_type = basic_string<charT>;

      explicit collate(size_t refs = 0);

      int compare(const charT* low1, const charT* high1,
                  const charT* low2, const charT* high2) const;
      string_type transform(const charT* low, const charT* high) const;
      long hash(const charT* low, const charT* high) const;

      static locale::id id;

    protected:
      ~collate();
      virtual int do_compare(const charT* low1, const charT* high1,
                             const charT* low2, const charT* high2) const;
      virtual string_type do_transform(const charT* low, const charT* high) const;
      virtual long do_hash (const charT* low, const charT* high) const;
    };
}
\end{codeblock}

\pnum
The class \tcode{collate<charT>} provides features
for use in the collation (comparison) and hashing of strings.
A locale member function template, \tcode{operator()},
uses the collate facet to allow a locale to act directly as
the predicate argument for standard algorithms\iref{algorithms} and
containers operating on strings.
The specializations
required in \tref{locale.category.facets}\iref{locale.category},
namely \tcode{collate<char>} and \tcode{collate<wchar_t>},
apply lexicographical ordering\iref{alg.lex.comparison}.

\pnum
Each function compares a string of characters \tcode{*p}
in the range \range{low}{high}.

\rSec4[locale.collate.members]{Members}

\indexlibrarymember{collate}{compare}%
\begin{itemdecl}
int compare(const charT* low1, const charT* high1,
            const charT* low2, const charT* high2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_compare(low1, high1, low2, high2)}.
\end{itemdescr}

\indexlibrarymember{collate}{transform}%
\begin{itemdecl}
string_type transform(const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_transform(low, high)}.
\end{itemdescr}

\indexlibrarymember{collate}{hash}%
\begin{itemdecl}
long hash(const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_hash(low, high)}.
\end{itemdescr}

\rSec4[locale.collate.virtuals]{Virtual functions}

\indexlibrarymember{collate}{do_compare}%
\begin{itemdecl}
int do_compare(const charT* low1, const charT* high1,
               const charT* low2, const charT* high2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{1} if the first string is greater than the second,
\tcode{-1} if less,
zero otherwise.
The specializations
required in \tref{locale.category.facets}\iref{locale.category},
namely \tcode{collate<char>} and \tcode{collate<wchar_t>},
implement a lexicographical comparison\iref{alg.lex.comparison}.
\end{itemdescr}

\indexlibrarymember{collate}{do_transform}%
\begin{itemdecl}
string_type do_transform(const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{basic_string<charT>} value that,
compared lexicographically with
the result of calling \tcode{transform()} on another string,
yields the same result as calling \tcode{do_compare()} on the same two strings.
\begin{footnote}
This function is useful when one string is being compared to many other strings.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{collate}{do_hash}%
\begin{itemdecl}
long do_hash(const charT* low, const charT* high) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An integer value equal to the result of calling \tcode{hash()}
on any other string for which \tcode{do_compare()} returns 0 (equal)
when passed the two strings.

\pnum
\recommended
The probability that the result equals that for another string
which does not compare equal should be very small,
approaching \tcode{(1.0/numeric_limits<unsigned long>::max())}.
\end{itemdescr}

\rSec3[locale.collate.byname]{Class template \tcode{collate_byname}}

\indexlibraryglobal{collate_byname}%
\begin{codeblock}
namespace std {
  template<class charT>
    class collate_byname : public collate<charT> {
    public:
      using string_type = basic_string<charT>;

      explicit collate_byname(const char*, size_t refs = 0);
      explicit collate_byname(const string&, size_t refs = 0);

    protected:
      ~collate_byname();
    };
}
\end{codeblock}

\rSec2[category.time]{The time category}

\rSec3[category.time.general]{General}

\pnum
Templates
\tcode{time_get<charT, InputIterator>} and
\tcode{time_put<charT, OutputIterator>}
provide date and time formatting and parsing.
All specifications of member functions for \tcode{time_put} and \tcode{time_get}
in the subclauses of~\ref{category.time} only apply to the
specializations required in Tables~\ref{tab:locale.category.facets}
and~\ref{tab:locale.spec}\iref{locale.category}.
Their members use their
\tcode{ios_base\&}, \tcode{ios_base::iostate\&}, and \tcode{fill} arguments
as described in~\ref{locale.categories},
and the \tcode{ctype<>} facet,
to determine formatting details.

\rSec3[locale.time.get]{Class template \tcode{time_get}}

\rSec4[locale.time.get.general]{General}

\indexlibraryglobal{time_get}%
\begin{codeblock}
namespace std {
  class time_base {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class time_get : public locale::facet, public time_base {
    public:
      using char_type = charT;
      using iter_type = InputIterator;

      explicit time_get(size_t refs = 0);

      dateorder date_order()  const { return do_date_order(); }
      iter_type get_time(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t)  const;
      iter_type get_date(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t)  const;
      iter_type get_weekday(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t) const;
      iter_type get_monthname(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t) const;
      iter_type get_year(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t) const;
      iter_type get(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t, char format, char modifier = 0) const;
      iter_type get(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t, const char_type* fmt,
                         const char_type* fmtend) const;

      static locale::id id;

    protected:
      ~time_get();
      virtual dateorder do_date_order()  const;
      virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
      virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
      virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
                                       ios_base::iostate& err, tm* t) const;
      virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&,
                                         ios_base::iostate& err, tm* t) const;
      virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
      virtual iter_type do_get(iter_type s, iter_type end, ios_base& f,
                               ios_base::iostate& err, tm* t, char format, char modifier) const;
    };
}
\end{codeblock}

\pnum
\tcode{time_get} is used to parse a character sequence,
extracting components of a time or date into a \tcode{tm} object.
Each \tcode{get} member parses a format as produced by a corresponding format specifier to
\tcode{time_put<>::put}.
If the sequence being parsed matches the correct format, the corresponding
members of the
\tcode{tm}
argument are set to the values used to produce the sequence; otherwise
either an error is reported or unspecified values are assigned.
\begin{footnote}
In
other words, user confirmation is required for reliable parsing of
user-entered dates and times, but machine-generated formats can be
parsed reliably.
This allows parsers to be aggressive about
interpreting user variations on standard formats.
\end{footnote}

\pnum
If the end iterator is reached during parsing by any of the
\tcode{get()}
member functions, the member sets
\tcode{ios_base::eof\-bit}
in \tcode{err}.

\rSec4[locale.time.get.members]{Members}

\indexlibrarymember{time_get}{date_order}%
\begin{itemdecl}
dateorder date_order() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_date_order()}.
\end{itemdescr}

\indexlibrarymember{time_get}{get_time}%
\begin{itemdecl}
iter_type get_time(iter_type s, iter_type end, ios_base& str,
                   ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get_time(s, end, str, err, t)}.
\end{itemdescr}

\indexlibrarymember{time_get}{get_date}%
\begin{itemdecl}
iter_type get_date(iter_type s, iter_type end, ios_base& str,
                   ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get_date(s, end, str, err, t)}.
\end{itemdescr}

\indexlibrarymember{time_get}{get_weekday}%
\indexlibrarymember{time_get}{get_monthname}%
\begin{itemdecl}
iter_type get_weekday(iter_type s, iter_type end, ios_base& str,
                      ios_base::iostate& err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base& str,
                        ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get_weekday(s, end, str, err, t)}
or
\tcode{do_get_monthname(s, end, str, err, t)}.
\end{itemdescr}

\indexlibrarymember{time_get}{get_year}%
\begin{itemdecl}
iter_type get_year(iter_type s, iter_type end, ios_base& str,
                   ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get_year(s, end, str, err, t)}.
\end{itemdescr}

\indexlibrarymember{get}{time_get}%
\begin{itemdecl}
iter_type get(iter_type s, iter_type end, ios_base& f, ios_base::iostate& err,
              tm* t, char format, char modifier = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get(s, end, f, err, t, format, modifier)}.
\end{itemdescr}

\indexlibrarymember{get}{time_get}%
\begin{itemdecl}
iter_type get(iter_type s, iter_type end, ios_base& f, ios_base::iostate& err,
              tm* t, const char_type* fmt, const char_type* fmtend) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{fmt}{fmtend} is a valid range.

\pnum
\effects
The function starts by evaluating \tcode{err = ios_base::goodbit}.
It then enters a loop,
reading zero or more characters from \tcode{s} at each iteration.
Unless otherwise specified below,
the loop terminates when the first of the following conditions holds:

\begin{itemize}
\item
The expression \tcode{fmt == fmtend} evaluates to \tcode{true}.
\item
The expression \tcode{err == ios_base::goodbit} evaluates to \tcode{false}.
\item
The expression \tcode{s == end} evaluates to \tcode{true},
in which case
the function evaluates \tcode{err = ios_base::eofbit | ios_base::failbit}.
\item
The next element of \tcode{fmt} is equal to \tcode{'\%'},
optionally followed by a modifier character,
followed by a conversion specifier character, \tcode{format},
together forming a conversion specification
valid for the POSIX function \tcode{strptime}.
If the number of elements in the range \range{fmt}{fmtend}
is not sufficient to unambiguously determine
whether the conversion specification is complete and valid,
the function evaluates \tcode{err = ios_base::failbit}.
Otherwise,
the function evaluates \tcode{s = do_get(s, end, f, err, t, format, modifier)},
where the value of \tcode{modifier} is \tcode{'\textbackslash0'}
when the optional modifier is absent from the conversion specification.
If \tcode{err == ios_base::goodbit} holds
after the evaluation of the expression,
the function increments \tcode{fmt}
to point just past the end of the conversion specification and
continues looping.

\item
The expression \tcode{isspace(*fmt, f.getloc())} evaluates to \tcode{true},
in which case the function first increments \tcode{fmt} until
\tcode{fmt == fmtend || !isspace(*fmt, f.getloc())} evaluates to \tcode{true},
then advances \tcode{s}
until \tcode{s == end || !isspace(*s, f.getloc())} is \tcode{true}, and
finally resumes looping.

\item
The next character read from \tcode{s}
matches the element pointed to by \tcode{fmt} in a case-insensitive comparison,
in which case the function evaluates \tcode{++fmt, ++s} and continues looping.
Otherwise, the function evaluates \tcode{err = ios_base::failbit}.
\end{itemize}

\pnum
\begin{note}
The function uses the \tcode{ctype<charT>} facet
installed in \tcode{f}'s locale
to determine valid whitespace characters.
It is unspecified
by what means the function performs case-insensitive comparison or
whether multi-character sequences are considered while doing so.
\end{note}

\pnum
\returns
\tcode{s}.
\end{itemdescr}

\rSec4[locale.time.get.virtuals]{Virtual functions}

\indexlibrarymember{time_get}{do_date_order}%
\begin{itemdecl}
dateorder do_date_order() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An enumeration value indicating the preferred order of components
for those date formats that are composed of day, month, and year.
\begin{footnote}
This function is intended as a convenience only, for common formats, and
can return \tcode{no_order} in valid locales.
\end{footnote}
Returns \tcode{no_order} if the date format specified by \tcode{'x'}
contains other variable components (e.g., Julian day, week number, week day).
\end{itemdescr}

\indexlibrarymember{time_get}{do_get_time}%
\begin{itemdecl}
iter_type do_get_time(iter_type s, iter_type end, ios_base& str,
                      ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters starting at \tcode{s}
until it has extracted those \tcode{tm} members, and
remaining format characters,
used by \tcode{time_put<>::put}
to produce the format specified by \tcode{"\%H:\%M:\%S"},
or until it encounters an error or end of sequence.

\pnum
\returns
An iterator pointing immediately beyond
the last character recognized as possibly part of a valid time.
\end{itemdescr}

\indexlibrarymember{time_get}{do_get_date}%
\begin{itemdecl}
iter_type do_get_date(iter_type s, iter_type end, ios_base& str,
                      ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters starting at \tcode{s}
until it has extracted those \tcode{tm} members and
remaining format characters
used by \tcode{time_put<>::put}
to produce one of the following formats,
or until it encounters an error.
The format depends on the value returned by \tcode{date_order()}
as shown in \tref{locale.time.get.dogetdate}.

\begin{libtab2}{\tcode{do_get_date} effects}{locale.time.get.dogetdate}
{ll}{\tcode{date_order()}}{Format}
\tcode{no_order}  & \tcode{"\%m\%d\%y"} \\
\tcode{dmy}       & \tcode{"\%d\%m\%y"} \\
\tcode{mdy}       & \tcode{"\%m\%d\%y"} \\
\tcode{ymd}       & \tcode{"\%y\%m\%d"} \\
\tcode{ydm}       & \tcode{"\%y\%d\%m"} \\
\end{libtab2}

\pnum
An implementation may also accept additional
\impldef{additional formats for \tcode{time_get::do_get_date}} formats.

\pnum
\returns
An iterator pointing immediately beyond
the last character recognized as possibly part of a valid date.
\end{itemdescr}

\indexlibrarymember{time_get}{do_get_weekday}%
\indexlibrarymember{time_get}{do_get_monthname}%
\begin{itemdecl}
iter_type do_get_weekday(iter_type s, iter_type end, ios_base& str,
                         ios_base::iostate& err, tm* t) const;
iter_type do_get_monthname(iter_type s, iter_type end, ios_base& str,
                           ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters starting at \tcode{s}
until it has extracted the (perhaps abbreviated) name of a weekday or month.
If it finds an abbreviation
that is followed by characters that can match a full name,
it continues reading until it matches the full name or fails.
It sets the appropriate \tcode{tm} member accordingly.

\pnum
\returns
An iterator pointing immediately beyond the last character recognized
as part of a valid name.
\end{itemdescr}

\indexlibrarymember{time_get}{do_get_year}%
\begin{itemdecl}
iter_type do_get_year(iter_type s, iter_type end, ios_base& str,
                      ios_base::iostate& err, tm* t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters starting at \tcode{s}
until it has extracted an unambiguous year identifier.
It is
\impldef{whether \tcode{time_get::do_get_year} accepts two-digit year numbers}
whether two-digit year numbers are accepted,
and (if so) what century they are assumed to lie in.
Sets the \tcode{t->tm_year} member accordingly.

\pnum
\returns
An iterator pointing immediately beyond
the last character recognized as part of a valid year identifier.
\end{itemdescr}

\indexlibrarymember{do_get}{time_get}%
\begin{itemdecl}
iter_type do_get(iter_type s, iter_type end, ios_base& f,
                 ios_base::iostate& err, tm* t, char format, char modifier) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{t} points to an object.

\pnum
\effects
The function starts by evaluating \tcode{err = ios_base::goodbit}.
It then reads characters starting at \tcode{s} until it encounters an error, or
until it has extracted and assigned those \tcode{tm} members, and
any remaining format characters,
corresponding to a conversion specification appropriate for
the POSIX function \tcode{strptime},
formed by concatenating \tcode{'\%'},
the \tcode{modifier} character, when non-NUL, and
the \tcode{format} character.
When the concatenation fails to yield a complete valid directive
the function leaves the object pointed to by \tcode{t} unchanged and
evaluates \tcode{err |= ios_base::failbit}.
When \tcode{s == end} evaluates to \tcode{true} after reading a character
the function evaluates \tcode{err |= ios_base::eofbit}.

\pnum
For complex conversion specifications
such as \tcode{\%c}, \tcode{\%x}, or \tcode{\%X}, or
conversion specifications that involve the optional modifiers \tcode{E} or \tcode{O},
when the function is unable to unambiguously determine
some or all \tcode{tm} members from the input sequence \range{s}{end},
it evaluates \tcode{err |= ios_base::eofbit}.
In such cases the values of those \tcode{tm} members are unspecified
and may be outside their valid range.

\pnum
\returns
An iterator pointing immediately beyond
the last character recognized as possibly part of
a valid input sequence for the given \tcode{format} and \tcode{modifier}.

\pnum
\remarks
It is unspecified whether multiple calls to \tcode{do_get()}
with the address of the same \tcode{tm} object
will update the current contents of the object or simply overwrite its members.
Portable programs should zero out the object before invoking the function.
\end{itemdescr}

\rSec3[locale.time.get.byname]{Class template \tcode{time_get_byname}}

\indexlibraryglobal{time_get_byname}%
\begin{codeblock}
namespace std {
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class time_get_byname : public time_get<charT, InputIterator> {
    public:
      using dateorder = time_base::dateorder;
      using iter_type = InputIterator;

      explicit time_get_byname(const char*, size_t refs = 0);
      explicit time_get_byname(const string&, size_t refs = 0);

    protected:
      ~time_get_byname();
    };
}
\end{codeblock}

\rSec3[locale.time.put]{Class template \tcode{time_put}}

\indexlibraryglobal{time_put}%
\begin{codeblock}
namespace std {
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class time_put : public locale::facet {
    public:
      using char_type = charT;
      using iter_type = OutputIterator;

      explicit time_put(size_t refs = 0);

      // the following is implemented in terms of other member functions.
      iter_type put(iter_type s, ios_base& f, char_type fill, const tm* tmb,
                    const charT* pattern, const charT* pat_end) const;
      iter_type put(iter_type s, ios_base& f, char_type fill,
                    const tm* tmb, char format, char modifier = 0) const;

      static locale::id id;

    protected:
      ~time_put();
      virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,
                               char format, char modifier) const;
    };
}
\end{codeblock}

\rSec4[locale.time.put.members]{Members}

\indexlibrarymember{time_put}{put}%
\begin{itemdecl}
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
              const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
              char format, char modifier = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first form steps through the sequence
from \tcode{pattern} to \tcode{pat_end},
identifying characters that are part of a format sequence.
Each character that is not part of a format sequence
is written to \tcode{s} immediately, and
each format sequence, as it is identified, results in a call to \tcode{do_put};
thus, format elements and other characters are interleaved in the output
in the order in which they appear in the pattern.
Format sequences are identified by converting each character \tcode{c} to
a \tcode{char} value as if by \tcode{ct.narrow(c, 0)},
where \tcode{ct} is a reference to \tcode{ctype<charT>}
obtained from \tcode{str.getloc()}.
The first character of each sequence is equal to \tcode{'\%'},
followed by an optional modifier character \tcode{mod}
\begin{footnote}
Although the C programming language defines no modifiers, most vendors do.
\end{footnote}
and a format specifier character \tcode{spec}
as defined for the function \tcode{strftime}.
If no modifier character is present, \tcode{mod} is zero.
For each valid format sequence identified,
calls \tcode{do_put(s, str, fill, t, spec, mod)}.

\pnum
The second form calls \tcode{do_put(s, str, fill, t, format, modifier)}.

\pnum
\begin{note}
The \tcode{fill} argument can be used
in the implementation-defined formats or by derivations.
A space character is a reasonable default for this argument.
\end{note}

\pnum
\returns
An iterator pointing immediately after the last character produced.
\end{itemdescr}

\rSec4[locale.time.put.virtuals]{Virtual functions}

\indexlibrarymember{time_put}{do_put}%
\begin{itemdecl}
iter_type do_put(iter_type s, ios_base&, char_type fill, const tm* t,
                 char format, char modifier) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Formats the contents of the parameter \tcode{t}
into characters placed on the output sequence \tcode{s}.
Formatting is controlled by the parameters \tcode{format} and \tcode{modifier},
interpreted identically as the format specifiers
in the string argument to the standard library function
\indexlibraryglobal{strftime}%
\tcode{strftime()},
except that the sequence of characters produced for those specifiers
that are described as depending on the C locale
are instead
\impldef{formatted character sequence generated by \tcode{time_put::do_put}
in C locale}.
\begin{note}
Interpretation of the \tcode{modifier} argument is implementation-defined.
\end{note}

\pnum
\returns
An iterator pointing immediately after the last character produced.
\begin{note}
The \tcode{fill} argument can be used
in the implementation-defined formats or by derivations.
A space character is a reasonable default for this argument.
\end{note}

\pnum
\recommended
Interpretation of the \tcode{modifier} should follow POSIX conventions.
Implementations should refer to other standards such as POSIX
for a specification of the character sequences produced for
those specifiers described as depending on the C locale.
\end{itemdescr}

\rSec3[locale.time.put.byname]{Class template \tcode{time_put_byname}}

\indexlibraryglobal{time_put_byname}%
\begin{codeblock}
namespace std {
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class time_put_byname : public time_put<charT, OutputIterator> {
    public:
      using char_type = charT;
      using iter_type = OutputIterator;

      explicit time_put_byname(const char*, size_t refs = 0);
      explicit time_put_byname(const string&, size_t refs = 0);

    protected:
      ~time_put_byname();
    };
}
\end{codeblock}

\rSec2[category.monetary]{The monetary category}

\rSec3[category.monetary.general]{General}

\pnum
These templates handle monetary formats.
A template parameter indicates
whether local or international monetary formats are to be used.

\pnum
All specifications of member functions
for \tcode{money_put} and \tcode{money_get}
in the subclauses of~\ref{category.monetary} only apply to
the specializations required in Tables~\ref{tab:locale.category.facets}
and~\ref{tab:locale.spec}\iref{locale.category}.
Their members use their \tcode{ios_base\&}, \tcode{ios_base::io\-state\&},
and \tcode{fill} arguments as described in~\ref{locale.categories}, and
the \tcode{moneypunct<>} and \tcode{ctype<>} facets,
to determine formatting details.

\rSec3[locale.money.get]{Class template \tcode{money_get}}

\indexlibraryglobal{money_get}%
\begin{codeblock}
namespace std {
  template<class charT, class InputIterator = istreambuf_iterator<charT>>
    class money_get : public locale::facet {
    public:
      using char_type   = charT;
      using iter_type   = InputIterator;
      using string_type = basic_string<charT>;

      explicit money_get(size_t refs = 0);

      iter_type get(iter_type s, iter_type end, bool intl,
                    ios_base& f, ios_base::iostate& err,
                    long double& units) const;
      iter_type get(iter_type s, iter_type end, bool intl,
                    ios_base& f, ios_base::iostate& err,
                    string_type& digits) const;

      static locale::id id;

    protected:
      ~money_get();
      virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
                               ios_base::iostate& err, long double& units) const;
      virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
                               ios_base::iostate& err, string_type& digits) const;
    };
}
\end{codeblock}

\rSec4[locale.money.get.members]{Members}

\indexlibrarymember{money_get}{get}%
\begin{itemdecl}
iter_type get(iter_type s, iter_type end, bool intl, ios_base& f,
              ios_base::iostate& err, long double& quant) const;
iter_type get(iter_type s, iter_type end, bool intl, ios_base& f,
              ios_base::iostate& err, string_type& quant) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get(s, end, intl, f, err, quant)}.
\end{itemdescr}

\rSec4[locale.money.get.virtuals]{Virtual functions}

\indexlibrarymember{money_get}{do_get}%
\begin{itemdecl}
iter_type do_get(iter_type s, iter_type end, bool intl, ios_base& str,
                 ios_base::iostate& err, long double& units) const;
iter_type do_get(iter_type s, iter_type end, bool intl, ios_base& str,
                 ios_base::iostate& err, string_type& digits) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads characters from \tcode{s} to parse and construct a monetary value
according to the format specified by
a \tcode{moneypunct<charT, Intl>} facet reference \tcode{mp}
and the character mapping specified by
a \tcode{ctype<charT>} facet reference \tcode{ct}
obtained from the locale returned by \tcode{str.getloc()}, and
\tcode{str.flags()}.
If a valid sequence is recognized, does not change \tcode{err};
otherwise, sets \tcode{err} to \tcode{(err|str.failbit)}, or
\tcode{(err|str.failbit|str.eof\-bit)} if no more characters are available,
and does not change \tcode{units} or \tcode{digits}.
Uses the pattern returned by \tcode{mp.neg_format()} to parse all values.
The result is returned as an integral value stored in \tcode{units}
or as a sequence of digits possibly preceded by a minus sign
(as produced by \tcode{ct.widen(c)}
where \tcode{c} is \tcode{'-'} or
in the range from \tcode{'0'} through \tcode{'9'} (inclusive))
stored in \tcode{digits}.
\begin{example}
The sequence \tcode{\$1,056.23} in a common United States locale would yield,
for \tcode{units}, \tcode{105623}, or,
for \tcode{digits}, \tcode{"105623"}.
\end{example}
If \tcode{mp.grouping()} indicates that no thousands separators are permitted,
any such characters are not read, and
parsing is terminated at the point where they first appear.
Otherwise, thousands separators are optional;
if present, they are checked for correct placement only after
all format components have been read.

\pnum
Where \tcode{money_base::space} or \tcode{money_base::none}
appears as the last element in the format pattern,
no whitespace is consumed.
Otherwise, where \tcode{money_base::space} appears in any of
the initial elements of the format pattern,
at least one whitespace character is required.
Where \tcode{money_base::none} appears
in any of the initial elements of the format pattern,
whitespace is allowed but not required.
If \tcode{(str.flags() \& str.showbase)} is \tcode{false},
the currency symbol is optional and
is consumed only if other characters are needed to complete the format;
otherwise, the currency symbol is required.

\pnum
If the first character (if any) in
the string \tcode{pos} returned by \tcode{mp.positive_sign()} or
the string \tcode{neg} returned by \tcode{mp.negative_sign()}
is recognized in the position indicated by \tcode{sign} in the format pattern,
it is consumed and
any remaining characters in the string are required
after all the other format components.
\begin{example}
If \tcode{showbase} is off,
then for a \tcode{neg} value of \tcode{"()"} and
a currency symbol of \tcode{"L"},
in \tcode{"(100 L)"} the \tcode{"L"} is consumed;
but if \tcode{neg} is \tcode{"-"},
the \tcode{"L"} in \tcode{"-100 L"} is not consumed.
\end{example}
If \tcode{pos} or \tcode{neg} is empty,
the sign component is optional, and
if no sign is detected,
the result is given the sign that corresponds to the source of the empty string.
Otherwise,
the character in the indicated position must match
the first character of \tcode{pos} or \tcode{neg},
and the result is given the corresponding sign.
If the first character of \tcode{pos} is equal to
the first character of \tcode{neg},
or if both strings are empty,
the result is given a positive sign.

\pnum
Digits in the numeric monetary component are extracted and
placed in \tcode{digits}, or into a character buffer \tcode{buf1}
for conversion to produce a value for \tcode{units},
in the order in which they appear,
preceded by a minus sign if and only if the result is negative.
The value \tcode{units} is produced as if by
\begin{footnote}
The semantics here are different from \tcode{ct.narrow}.
\end{footnote}
\begin{codeblock}
for (int i = 0; i < n; ++i)
  buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &units);
\end{codeblock}
where \tcode{n} is the number of characters placed in \tcode{buf1},
\tcode{buf2} is a character buffer, and
the values \tcode{src} and \tcode{atoms} are defined as if by
\begin{codeblock}
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
\end{codeblock}

\pnum
\returns
An iterator pointing immediately beyond
the last character recognized as part of a valid monetary quantity.
\end{itemdescr}

\rSec3[locale.money.put]{Class template \tcode{money_put}}

\indexlibraryglobal{money_put}%
\begin{codeblock}
namespace std {
  template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
    class money_put : public locale::facet {
    public:
      using char_type   = charT;
      using iter_type   = OutputIterator;
      using string_type = basic_string<charT>;

      explicit money_put(size_t refs = 0);

      iter_type put(iter_type s, bool intl, ios_base& f,
                    char_type fill, long double units) const;
      iter_type put(iter_type s, bool intl, ios_base& f,
                    char_type fill, const string_type& digits) const;

      static locale::id id;

    protected:
      ~money_put();
      virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
                               long double units) const;
      virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
                               const string_type& digits) const;
    };
}
\end{codeblock}

\rSec4[locale.money.put.members]{Members}

\indexlibrarymember{money_put}{put}%
\begin{itemdecl}
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill, long double quant) const;
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill, const string_type& quant) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_put(s, intl, f, loc, quant)}.
\end{itemdescr}

\rSec4[locale.money.put.virtuals]{Virtual functions}

\indexlibrarymember{money_put}{do_put}%
\begin{itemdecl}
iter_type do_put(iter_type s, bool intl, ios_base& str,
                 char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base& str,
                 char_type fill, const string_type& digits) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Writes characters to \tcode{s} according to
the format specified by
a \tcode{moneypunct<charT, Intl>} facet reference \tcode{mp} and
the character mapping specified by
a \tcode{ctype<charT>} facet reference \tcode{ct}
obtained from the locale returned by \tcode{str.getloc()},
and \tcode{str.flags()}.
The argument \tcode{units} is transformed into
a sequence of wide characters as if by
\begin{codeblock}
ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)
\end{codeblock}
for character buffers \tcode{buf1} and \tcode{buf2}.
If the first character in \tcode{digits} or \tcode{buf2}
is equal to \tcode{ct.widen('-')},
then the pattern used for formatting is the result of \tcode{mp.neg_format()};
otherwise the pattern is the result of \tcode{mp.pos_format()}.
Digit characters are written,
interspersed with any thousands separators and decimal point
specified by the format,
in the order they appear (after the optional leading minus sign) in
\tcode{digits} or \tcode{buf2}.
In \tcode{digits},
only the optional leading minus sign and
the immediately subsequent digit characters
(as classified according to \tcode{ct})
are used;
any trailing characters
(including digits appearing after a non-digit character)
are ignored.
Calls \tcode{str.width(0)}.

\pnum
\returns
An iterator pointing immediately after the last character produced.

\pnum
\remarks
% issues 22-021, 22-030, 22-034 from 97-0058/N1096, 97-0036/N1074
The currency symbol is generated
if and only if \tcode{(str.flags() \& str.showbase)} is nonzero.
If the number of characters generated for the specified format
is less than the value returned by \tcode{str.width()} on entry to the function,
then copies of \tcode{fill} are inserted as necessary
to pad to the specified width.
For the value \tcode{af} equal to \tcode{(str.flags() \& str.adjustfield)},
if \tcode{(af == str.internal)} is \tcode{true},
the fill characters are placed
where \tcode{none} or \tcode{space} appears in the formatting pattern;
otherwise if \tcode{(af == str.left)} is \tcode{true},
they are placed after the other characters;
otherwise, they are placed before the other characters.
\begin{note}
It is possible, with some combinations of format patterns and flag values,
to produce output that cannot be parsed using \tcode{num_get<>::get}.
\end{note}
\end{itemdescr}

\rSec3[locale.moneypunct]{Class template \tcode{moneypunct}}

\rSec4[locale.moneypunct.general]{General}

\indexlibraryglobal{moneypunct}%
\begin{codeblock}
namespace std {
  class money_base {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
  };

  template<class charT, bool International = false>
    class moneypunct : public locale::facet, public money_base {
    public:
      using char_type   = charT;
      using string_type = basic_string<charT>;

      explicit moneypunct(size_t refs = 0);

      charT        decimal_point() const;
      charT        thousands_sep() const;
      string       grouping()      const;
      string_type  curr_symbol()   const;
      string_type  positive_sign() const;
      string_type  negative_sign() const;
      int          frac_digits()   const;
      pattern      pos_format()    const;
      pattern      neg_format()    const;

      static locale::id id;
      static const bool intl = International;

    protected:
      ~moneypunct();
      virtual charT        do_decimal_point() const;
      virtual charT        do_thousands_sep() const;
      virtual string       do_grouping()      const;
      virtual string_type  do_curr_symbol()   const;
      virtual string_type  do_positive_sign() const;
      virtual string_type  do_negative_sign() const;
      virtual int          do_frac_digits()   const;
      virtual pattern      do_pos_format()    const;
      virtual pattern      do_neg_format()    const;
    };
}
\end{codeblock}

\pnum
The \tcode{moneypunct<>} facet defines monetary formatting parameters
used by \tcode{money_get<>} and \tcode{money_put<>}.
A monetary format is a sequence of four components,
specified by a \tcode{pattern} value \tcode{p},
such that the \tcode{part} value \tcode{static_cast<part>(p.field[i])}
determines the $\tcode{i}^\text{th}$ component of the format
\begin{footnote}
An array of \tcode{char},
rather than an array of \tcode{part},
is specified for \tcode{pattern::field} purely for efficiency.
\end{footnote}
In the \tcode{field} member of a \tcode{pattern} object,
each value \tcode{symbol}, \tcode{sign}, \tcode{value}, and
either \tcode{space} or \tcode{none}
appears exactly once.
The value \tcode{none}, if present, is not first;
the value \tcode{space}, if present, is neither first nor last.

\pnum
Where \tcode{none} or \tcode{space} appears,
whitespace is permitted in the format,
except where \tcode{none} appears at the end,
in which case no whitespace is permitted.
The value \tcode{space} indicates that
at least one space is required at that position.
Where \tcode{symbol} appears,
the sequence of characters returned by \tcode{curr_symbol()} is permitted, and
can be required.
Where \tcode{sign} appears,
the first (if any) of the sequence of characters returned by
\tcode{positive_sign()} or \tcode{negative_sign()}
(respectively as the monetary value is non-negative or negative) is required.
Any remaining characters of the sign sequence are required after
all other format components.
Where \tcode{value} appears, the absolute numeric monetary value is required.

\pnum
The format of the numeric monetary value is a decimal number:
\begin{ncbnf}
\locnontermdef{value}\br
    units \opt{fractional}\br
    decimal-point digits
\end{ncbnf}
\begin{ncbnf}
\locnontermdef{fractional}\br
    decimal-point \opt{digits}
\end{ncbnf}
if \tcode{frac_digits()} returns a positive value, or
\begin{ncbnf}
\locnontermdef{value}\br
    units
\end{ncbnf}
otherwise.
The symbol \locgrammarterm{decimal-point}
indicates the character returned by \tcode{decimal_point()}.
The other symbols are defined as follows:

\begin{ncbnf}
\locnontermdef{units}\br
    digits\br
    digits thousands-sep units
\end{ncbnf}

\begin{ncbnf}
\locnontermdef{digits}\br
    adigit \opt{digits}
\end{ncbnf}

In the syntax specification,
the symbol \locgrammarterm{adigit} is any of the values \tcode{ct.widen(c)}
for \tcode{c} in the range \tcode{'0'} through \tcode{'9'} (inclusive) and
\tcode{ct} is a reference of type \tcode{const ctype<charT>\&}
obtained as described in the definitions
of \tcode{money_get<>} and \tcode{money_put<>}.
The symbol \locgrammarterm{thousands-sep}
is the character returned by \tcode{thousands_sep()}.
The space character used is the value \tcode{ct.widen(' ')}.
Whitespace characters are those characters \tcode{c}
for which \tcode{ci.is(space, c)} returns \tcode{true}.
The number of digits required after the decimal point (if any)
is exactly the value returned by \tcode{frac_digits()}.

\pnum
The placement of thousands-separator characters (if any)
is determined by the value returned by \tcode{grouping()},
defined identically as the member \tcode{numpunct<>::do_grouping()}.

\rSec4[locale.moneypunct.members]{Members}

\indexlibrarymember{moneypunct}{decimal_point}%
\indexlibrarymember{moneypunct}{thousands_sep}%
\indexlibrarymember{moneypunct}{grouping}%
\indexlibrarymember{moneypunct}{curr_symbol}%
\indexlibrarymember{moneypunct}{positive_sign}%
\indexlibrarymember{moneypunct}{negative_sign}%
\indexlibrarymember{moneypunct}{frac_digits}%
\indexlibrarymember{moneypunct}{positive_sign}%
\indexlibrarymember{moneypunct}{negative_sign}%
\begin{codeblock}
charT        decimal_point() const;
charT        thousands_sep() const;
string       grouping()      const;
string_type  curr_symbol()   const;
string_type  positive_sign() const;
string_type  negative_sign() const;
int          frac_digits()   const;
pattern      pos_format()    const;
pattern      neg_format()    const;
\end{codeblock}

\pnum
Each of these functions \tcode{\placeholder{F}}
returns the result of calling the corresponding
virtual member function
\tcode{do_\placeholder{F}()}.

\rSec4[locale.moneypunct.virtuals]{Virtual functions}

\indexlibrarymember{moneypunct}{do_decimal_point}%
\begin{itemdecl}
charT do_decimal_point() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The radix separator to use
in case \tcode{do_frac_digits()} is greater than zero.
\begin{footnote}
In common U.S. locales this is \tcode{'.'}.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_thousands_sep}%
\begin{itemdecl}
charT do_thousands_sep() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The digit group separator to use
in case \tcode{do_grouping()} specifies a digit grouping pattern.
\begin{footnote}
In common U.S. locales this is \tcode{','}.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_grouping}%
\begin{itemdecl}
string do_grouping() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pattern defined identically as, but not necessarily equal to,
the result of \tcode{numpunct<charT>::\brk{}do_grouping()}.
\begin{footnote}
To specify grouping by 3s,
the value is \tcode{"\textbackslash003"} \textit{not} \tcode{"3"}.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_curr_symbol}%
\begin{itemdecl}
string_type do_curr_symbol() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A string to use as the currency identifier symbol.
\begin{note}
For specializations where the second template parameter is \tcode{true},
this is typically four characters long:
a three-letter code as specified by ISO 4217 followed by a space.
\end{note}
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_positive_sign}%
\indexlibrarymember{moneypunct}{do_negative_sign}%
\begin{itemdecl}
string_type do_positive_sign() const;
string_type do_negative_sign() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_positive_sign()}
returns the string to use to indicate a positive monetary value;
\begin{footnote}
This is usually the empty string.
\end{footnote}
\tcode{do_negative_sign()}
returns the string to use to indicate a negative value.
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_frac_digits}%
\begin{itemdecl}
int do_frac_digits() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The number of digits after the decimal radix separator, if any.
\begin{footnote}
In common U.S.\ locales, this is 2.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{moneypunct}{do_pos_format}%
\indexlibrarymember{moneypunct}{do_neg_format}%
\begin{itemdecl}
pattern do_pos_format() const;
pattern do_neg_format() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The specializations required in \tref{locale.spec}\iref{locale.category}, namely
\begin{itemize}
\item \tcode{moneypunct<char>},
\item \tcode{moneypunct<wchar_t>},
\item \tcode{moneypunct<char, true>}, and
\item \tcode{moneypunct<wchar_t, true>},
\end{itemize}
return an object of type \tcode{pattern}
initialized to \tcode{\{ symbol, sign, none, value \}}.
\begin{footnote}
Note that the international symbol returned by \tcode{do_curr_symbol()}
usually contains a space, itself;
for example, \tcode{"USD "}.
\end{footnote}
\end{itemdescr}

\rSec3[locale.moneypunct.byname]{Class template \tcode{moneypunct_byname}}

\indexlibraryglobal{moneypunct_byname}%
\begin{codeblock}
namespace std {
  template<class charT, bool Intl = false>
  class moneypunct_byname : public moneypunct<charT, Intl> {
    public:
      using pattern     = money_base::pattern;
      using string_type = basic_string<charT>;

      explicit moneypunct_byname(const char*, size_t refs = 0);
      explicit moneypunct_byname(const string&, size_t refs = 0);

    protected:
      ~moneypunct_byname();
    };
}
\end{codeblock}

\rSec2[category.messages]{The message retrieval category}

\rSec3[category.messages.general]{General}

\pnum
Class \tcode{messages<charT>}
implements retrieval of strings from message catalogs.

\rSec3[locale.messages]{Class template \tcode{messages}}

\rSec4[locale.messages.general]{General}

\indexlibraryglobal{messages}%
\begin{codeblock}
namespace std {
  class messages_base {
  public:
    using catalog = @\textit{unspecified signed integer type}@;
  };

  template<class charT>
    class messages : public locale::facet, public messages_base {
    public:
      using char_type   = charT;
      using string_type = basic_string<charT>;

      explicit messages(size_t refs = 0);

      catalog open(const string& fn, const locale&) const;
      string_type get(catalog c, int set, int msgid,
                      const string_type& dfault) const;
      void close(catalog c) const;

      static locale::id id;

    protected:
      ~messages();
      virtual catalog do_open(const string&, const locale&) const;
      virtual string_type do_get(catalog, int set, int msgid,
                                 const string_type& dfault) const;
      virtual void do_close(catalog) const;
    };
}
\end{codeblock}

\pnum
Values of type \tcode{messages_base::catalog}
usable as arguments to members \tcode{get} and \tcode{close}
can be obtained only by calling member \tcode{open}.

\rSec4[locale.messages.members]{Members}

\indexlibrarymember{messages}{open}%
\begin{itemdecl}
catalog open(const string& name, const locale& loc) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_open(name, loc)}.
\end{itemdescr}

\indexlibrarymember{messages}{get}%
\begin{itemdecl}
string_type get(catalog cat, int set, int msgid, const string_type& dfault) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{do_get(cat, set, msgid, dfault)}.
\end{itemdescr}

\indexlibrarymember{messages}{close}%
\begin{itemdecl}
void close(catalog cat) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{do_close(cat)}.
\end{itemdescr}

\rSec4[locale.messages.virtuals]{Virtual functions}

\indexlibrarymember{messages}{do_open}%
\begin{itemdecl}
catalog do_open(const string& name, const locale& loc) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A value that may be passed to \tcode{get()}
to retrieve a message from the message catalog
identified by the string \tcode{name}
according to an \impldef{mapping from name to catalog when calling
\tcode{mes\-sages::do_open}} mapping.
The result can be used until it is passed to \tcode{close()}.

\pnum
Returns a value less than 0 if no such catalog can be opened.

\pnum
\remarks
The locale argument \tcode{loc} is used for
character set code conversion when retrieving messages, if needed.
\end{itemdescr}

\indexlibrarymember{messages}{do_get}%
\begin{itemdecl}
string_type do_get(catalog cat, int set, int msgid, const string_type& dfault) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{cat} is a catalog obtained from \tcode{open()} and not yet closed.

\pnum
\returns
A message identified by
arguments \tcode{set}, \tcode{msgid}, and \tcode{dfault},
according to
an \impldef{mapping to message when calling \tcode{messages::do_get}} mapping.
If no such message can be found, returns \tcode{dfault}.
\end{itemdescr}

\indexlibrarymember{message}{do_close}%
\begin{itemdecl}
void do_close(catalog cat) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{cat} is a catalog obtained from \tcode{open()} and not yet closed.

\pnum
\effects
Releases unspecified resources associated with  \tcode{cat}.

\pnum
\remarks
The limit on such resources, if any, is
\impldef{resource limits on a message catalog}.
\end{itemdescr}

\rSec3[locale.messages.byname]{Class template \tcode{messages_byname}}

\indexlibraryglobal{messages_byname}%
\begin{codeblock}
namespace std {
  template<class charT>
    class messages_byname : public messages<charT> {
    public:
      using catalog     = messages_base::catalog;
      using string_type = basic_string<charT>;

      explicit messages_byname(const char*, size_t refs = 0);
      explicit messages_byname(const string&, size_t refs = 0);

    protected:
      ~messages_byname();
    };
}
\end{codeblock}

\rSec1[c.locales]{C library locales}

\rSec2[clocale.syn]{Header \tcode{<clocale>} synopsis}

\indexlibraryglobal{lconv}%
\indexlibraryglobal{setlocale}%
\indexlibraryglobal{localeconv}%
\indexlibraryglobal{NULL}%
\indexlibraryglobal{LC_ALL}%
\indexlibraryglobal{LC_COLLATE}%
\indexlibraryglobal{LC_CTYPE}%
\indexlibraryglobal{LC_MONETARY}%
\indexlibraryglobal{LC_NUMERIC}%
\indexlibraryglobal{LC_TIME}%
\begin{codeblock}
namespace std {
  struct lconv;

  char* setlocale(int category, const char* locale);
  lconv* localeconv();
}

#define NULL @\textit{see \ref{support.types.nullptr}}@
#define LC_ALL @\seebelow@
#define LC_COLLATE @\seebelow@
#define LC_CTYPE @\seebelow@
#define LC_MONETARY @\seebelow@
#define LC_NUMERIC @\seebelow@
#define LC_TIME @\seebelow@
\end{codeblock}

\pnum
The contents and meaning of the header \libheaderdef{clocale}
are the same as the C standard library header \libheader{locale.h}.

\rSec2[clocale.data.races]{Data races}

\pnum
Calls to the function \tcode{setlocale}
may introduce a data race\iref{res.on.data.races}
with other calls to \tcode{setlocale} or
with calls to the functions listed in \tref{setlocale.data.races}.

\xrefc{7.11}

\begin{floattable}
{Potential \tcode{setlocale} data races}
{setlocale.data.races}
{lllll}
\topline

\tcode{fprintf}     &
\tcode{isprint}     &
\tcode{iswdigit}    &
\tcode{localeconv}  &
\tcode{tolower}     \\

\tcode{fscanf}      &
\tcode{ispunct}     &
\tcode{iswgraph}    &
\tcode{mblen}       &
\tcode{toupper}     \\

\tcode{isalnum}     &
\tcode{isspace}     &
\tcode{iswlower}    &
\tcode{mbstowcs}    &
\tcode{towlower}    \\

\tcode{isalpha}     &
\tcode{isupper}     &
\tcode{iswprint}    &
\tcode{mbtowc}      &
\tcode{towupper}    \\

\tcode{isblank}     &
\tcode{iswalnum}    &
\tcode{iswpunct}    &
\tcode{setlocale}   &
\tcode{wcscoll}     \\

\tcode{iscntrl}     &
\tcode{iswalpha}    &
\tcode{iswspace}    &
\tcode{strcoll}     &
\tcode{wcstod}      \\

\tcode{isdigit}     &
\tcode{iswblank}    &
\tcode{iswupper}    &
\tcode{strerror}    &
\tcode{wcstombs}    \\

\tcode{isgraph}     &
\tcode{iswcntrl}    &
\tcode{iswxdigit}   &
\tcode{strtod}      &
\tcode{wcsxfrm}     \\

\tcode{islower}     &
\tcode{iswctype}    &
\tcode{isxdigit}    &
\tcode{strxfrm}     &
\tcode{wctomb}      \\
\end{floattable}
