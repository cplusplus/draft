%!TEX root = std.tex
\rSec0[temp]{Templates}%
\indextext{template|(}

%gram: \rSec1[gram.temp]{Templates}
%gram:

\indextext{parameterized type|see{template}}%
\indextext{type generator|see{template}}

\pnum
A \term{template} defines a family of classes or functions or an alias for a
family of types.

\indextext{\idxcode{template}}%
%
\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{template <} template-parameter-list \terminal{>} declaration
\end{bnf}

\begin{bnf}
\nontermdef{template-parameter-list}\br
  template-parameter\br
  template-parameter-list \terminal{,} template-parameter
\end{bnf}

\enternote The \tcode{>} token following the
\nonterminal{template-parameter-list} of a
\nonterminal{template-declaration}
may be the product of replacing a
\tcode{>{>}} token by two consecutive \tcode{>}
tokens~(\ref{temp.names}).\exitnote

The
\grammarterm{declaration}
in a
\grammarterm{template-declaration}
shall

\begin{itemize}
\item declare or define a function, a class, or a variable, or

\item define a member function, a member class, a member enumeration, or a static data member of a
class template or of a class nested within a class template, or

\item define a member template of a class or class template, or

\item be an \grammarterm{alias-declaration}.
\end{itemize}

A \grammarterm{template-declaration} is a \grammarterm{declaration}.
\indextext{template!definition~of}%
A \grammarterm{template-declaration} is also a definition
if its \grammarterm{declaration} defines a function, a class, a variable, or a
static data member. A declaration introduced by a template declaration of a
\indextext{variable template!definition~of}%
\indextext{template!variable}%
\indextext{template!static data member}%
variable is a \term{variable template}. A variable template at class scope is a
\term{static data member template}.

\enterexample
\begin{codeblock}
template<class T>
  constexpr T pi = T(3.1415926535897932385L);
template<class T>
T circular_area(T r) {
  return pi<T> * r * r;
}
struct matrix_constants {
  template<class T>
   using pauli = hermitian_matrix<T, 2>;
  template<class T>
   constexpr pauli<T> sigma1 = { { 0, 1 }, { 1, 0 } };
  template<class T>
   constexpr pauli<T> sigma2 = { { 0, -1i }, { 1i, 0 } };
  template<class T>
   constexpr pauli<T> sigma3 = { { 1, 0 }, { 0, -1 } };
};
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{template-declaration}
can appear only as a namespace scope or class scope declaration.
In a function template declaration, the last component of the
\grammarterm{declarator-id}
shall not be a
\grammarterm{template-id}.
\enternote
That last component may be an \grammarterm{identifier}, an \grammarterm{operator-function-id},
a \grammarterm{conversion-function-id}, or a \grammarterm{literal-operator-id}. In
a class template declaration, if the
class name
is a
\grammarterm{simple-template-id},
the declaration declares a class template partial specialization~(\ref{temp.class.spec}).
\exitnote

\pnum
In a
\grammarterm{template-declaration},
explicit specialization, or explicit instantiation the
\grammarterm{init-declarator-list}
in the declaration shall contain at most one declarator.
When such a declaration is used to declare a class template,
no declarator is permitted.

\pnum
\indextext{template~name!linkage~of}%
A template name has linkage~(\ref{basic.link}).
A non-member
function template can have internal linkage; any other
template name shall have external linkage.
Specializations (explicit or implicit) of
a template that has internal linkage are
distinct from all specializations in other translation
units.
A template, a template explicit specialization~(\ref{temp.expl.spec}), and a class
template partial specialization shall not have C linkage. Use of a linkage specification
other than C or C++ with any of these constructs is conditionally-supported, with
\impldef{semantics of linkage specification on templates} semantics.
Template definitions shall obey the one definition rule~(\ref{basic.def.odr}).
\enternote
Default arguments for function templates and for member functions of
class templates are considered definitions for the purpose of template
instantiation~(\ref{temp.decls}) and must also obey the one definition rule.
\exitnote

\pnum
A class template shall not have the same name as any other
template, class, function, variable, enumeration, enumerator, namespace, or
type in the same scope~(\ref{basic.scope}), except as specified in~(\ref{temp.class.spec}).
Except that a function template can be overloaded either by non-template
functions~(\ref{dcl.fct}) with the same name or by other function templates
with the same name~(\ref{temp.over}),
a template name declared in namespace scope or in class scope shall be unique
in that scope.

\pnum
A function template, member function of a class template, variable template,
or static data
member of a class template shall be defined in every translation unit in
which it is implicitly instantiated~(\ref{temp.inst}) unless the
corresponding specialization is explicitly instantiated~(\ref{temp.explicit})
in some translation unit; no diagnostic is required.

\rSec1[temp.param]{Template parameters}

\pnum
The syntax for
\grammarterm{template-parameter}{s}
is:

\begin{bnf}
\nontermdef{template-parameter}\br
  type-parameter\br
  parameter-declaration
\end{bnf}

\begin{bnf}
\nontermdef{type-parameter}\br
  \terminal{class} \terminal{...}\opt identifier\opt\br
  \terminal{class} identifier\opt \terminal{=} type-id\br
  \terminal{typename} \terminal{...}\opt identifier\opt\br
  \terminal{typename} identifier\opt \terminal{=} type-id\br
  \terminal{template <} template-parameter-list \terminal{> class} \terminal{...}\opt identifier\opt\br
  \terminal{template <} template-parameter-list \terminal{> class} identifier\opt \terminal{=} id-expression
\end{bnf}

\enternote The \tcode{>} token following the
\nonterminal{template-parameter-list} of a
\nonterminal{type-parameter}
may be the product of replacing a
\tcode{>{>}} token by two consecutive \tcode{>}
tokens~(\ref{temp.names}).\exitnote

\pnum
There is no semantic difference between
\tcode{class}
and
\tcode{typename}
in a
\grammarterm{template-parameter}.
\tcode{typename}
followed by an
\grammarterm{unqualified-id}
names a template type parameter.
\tcode{typename}
followed by a
\grammarterm{qualified-id}
denotes the type in a non-type \footnote{Since template
\grammarterm{template-parameter}{s}
and template
\grammarterm{template-argument}{s}
are treated as types for descriptive purposes, the terms
\grammarterm{non-type parameter}
and
\grammarterm{non-type argument}
are used to refer to non-type, non-template parameters and arguments.}
\grammarterm{parameter-declaration}.
A storage class shall not be specified in a
\grammarterm{template-parameter}
declaration.
Types shall not be defined in a \grammarterm{template-parameter}
declaration.
\enternote
A template parameter may be a class template.
For example,

\begin{codeblock}
template<class T> class myarray { /* ... */ };

template<class K, class V, template<class T> class C = myarray>
class Map {
  C<K> key;
  C<V> value;
};
\end{codeblock}
\exitnote

\pnum
A
\grammarterm{type-parameter}
whose identifier does not follow an ellipsis
defines its
\grammarterm{identifier}
to be a
\grammarterm{typedef-name}
(if declared with
\tcode{class}
or
\tcode{typename})
or
\grammarterm{template-name}
(if declared with
\tcode{template})
in the scope of the template declaration.
\enternote
Because of the name lookup rules, a
\grammarterm{template-parameter}
that could be interpreted as either a non-type
\grammarterm{template-parameter}
or a
\grammarterm{type-parameter}
(because its
\grammarterm{identifier}
is the name of an already existing class) is taken as a
\grammarterm{type-parameter}.
For example,

\begin{codeblock}
class T { /* ... */ };
int i;

template<class T, T i> void f(T t) {
  T t1 = i;         // template-parameters \tcode{T} and \tcode{i}
  ::T t2 = ::i;     // global namespace members \tcode{T} and \tcode{i}
}
\end{codeblock}

Here, the template
\tcode{f}
has a
\grammarterm{type-parameter}
called
\tcode{T},
rather than an unnamed non-type
\grammarterm{template-parameter}
of class
\tcode{T}.
\exitnote

\pnum
A non-type
\grammarterm{template-parameter}
shall have one of the following (optionally
\grammarterm{cv-qualified})
types:

\begin{itemize}
\item integral or enumeration type,

\item pointer to object or pointer to function,

\item lvalue reference to object or lvalue reference to function,

\item pointer to member,

\item \tcode{std::nullptr_t}.
\end{itemize}

\pnum
\enternote
Other types are disallowed either explicitly below or implicitly by
the rules governing the form of
\grammarterm{template-argument}{s}~(\ref{temp.arg}).
\exitnote
The top-level
\grammarterm{cv-qualifiers}
on the
\grammarterm{template-parameter}
are ignored when determining its type.

\pnum
A non-type non-reference
\grammarterm{template-parameter}
is a prvalue.
It shall not be assigned to or in any other way have its value changed.
A non-type non-reference
\grammarterm{template-parameter}
cannot have its address taken.
When a non-type non-reference
\grammarterm{template-parameter}
is used as an initializer for a reference, a temporary is always used.
\enterexample

\begin{codeblock}
template<const X& x, int i> void f() {
  i++;                          // error: change of template-parameter value

  &x;                           // OK
  &i;                           // error: address of non-reference template-parameter

  int& ri = i;                  // error: non-const reference bound to temporary
  const int& cri = i;           // OK: const reference bound to temporary
}
\end{codeblock}
\exitexample

\pnum
A non-type
\grammarterm{template-parameter}
shall not be declared to have floating point, class, or void type.
\enterexample

\begin{codeblock}
template<double d> class X;     // error
template<double* pd> class Y;   // OK
template<double& rd> class Z;   // OK
\end{codeblock}
\exitexample

\pnum
A non-type
\grammarterm{template-parameter}
of type ``array of
\tcode{T}''
or ``function returning
\tcode{T}''
is adjusted to be of type
``pointer to
\tcode{T}''
or ``pointer to function returning
\tcode{T}'',
respectively.
\enterexample

\begin{codeblock}
template<int* a>   struct R { /* ... */ };
template<int b[5]> struct S { /* ... */ };
int p;
R<&p> w;                        // OK
S<&p> x;                        // OK due to parameter adjustment
int v[5];
R<v> y;                         // OK due to implicit argument conversion
S<v> z;                         // OK due to both adjustment and conversion
\end{codeblock}
\exitexample

\pnum
A
\term{default template-argument}
is a
\grammarterm{template-argument}~(\ref{temp.arg}) specified after
\tcode{=}
in a
\grammarterm{template-parameter}.
A default
\grammarterm{tem\-plate-argument}
may be specified for any kind of
\grammarterm{template-parameter}
(type, non-type, template)
that is not a template parameter pack~(\ref{temp.variadic}).
A default
\grammarterm{template-argument}
may be specified in a template declaration.
A default
\grammarterm{template-argument}
shall not be specified in the
\grammarterm{template-parameter-list}{s}
of the definition of a member of a class template that appears outside
of the member's class.
A default
\grammarterm{template-argument}
shall not be specified in a friend class template declaration.
If a friend function template declaration
specifies a default
\grammarterm{template-argument},
that declaration shall be a definition and shall be the only declaration of
the function template in the translation unit.

\pnum
The set of default
\grammarterm{template-argument}{s}
available for use with a template
declaration or definition is obtained by merging the default arguments
from the definition (if in scope) and all declarations in scope in the
same way default function arguments are~(\ref{dcl.fct.default}).
\enterexample

\begin{codeblock}
template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;
\end{codeblock}

is equivalent to

\begin{codeblock}
template<class T1 = int, class T2 = int> class A;
\end{codeblock}
\exitexample

\pnum
If a
\grammarterm{template-parameter}
of a class template or alias template has a default
\grammarterm{template-argument},
each subsequent
\grammarterm{template-parameter}
shall either have a default
\grammarterm{template-argument}
supplied
or be a template parameter pack. If a \grammarterm{template-parameter}
of a primary class template or alias template is a template parameter pack, it shall be the last
\grammarterm{template-parameter}.
A template parameter pack of a function template shall not be followed by
another
template parameter unless that template parameter can be deduced from the
\grammarterm{parameter-type-list} of the function template or has a
default argument~(\ref{temp.deduct}).
\enterexample

\begin{codeblock}
template<class T1 = int, class T2> class B;   // error

// \tcode{U} can be neither deduced from the \grammarterm{parameter-type-list} nor specified
template<class... T, class... U> void f() { } // error
template<class... T, class U> void g() { }    // error
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{template-parameter}
shall
not be given default arguments by two different declarations in the same scope.
\enterexample

\begin{codeblock}
template<class T = int> class X;
template<class T = int> class X { /*... */ }; // error
\end{codeblock}
\exitexample

\indextext{\idxcode{<}!template~and}%
\pnum
When parsing a
default
\grammarterm{template-argument}
for a non-type
\grammarterm{template-parameter},
the first non-nested
\tcode{>}
is taken as the end of the
\grammarterm{template-parameter-list}
rather than a greater-than operator.
\enterexample

\begin{codeblock}
template<int i = 3 > 4 >        // syntax error
class X { /* ... */ };

template<int i = (3 > 4) >      // OK
class Y { /* ... */ };
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{template-parameter}
of a template
\grammarterm{template-parameter}
is permitted to have a default
\grammarterm{template-argument}.
When such default arguments are specified, they apply to the template
\grammarterm{template-parameter}
in the scope of the template
\grammarterm{template-parameter}.
\enterexample
\begin{codeblock}
template <class T = float> struct B {};
template <template <class TT = float> class T> struct A {
  inline void f();
  inline void g();
};
template <template <class TT> class T> void A<T>::f() {
  T<> t;            // error - \tcode{TT} has no default template argument
}
template <template <class TT = char> class T> void A<T>::g() {
    T<> t;          // OK - \tcode{T<char>}
}
\end{codeblock}
\exitexample

\pnum
If a \grammarterm{template-parameter} is a
\grammarterm{type-parameter} with an ellipsis prior to its
optional \grammarterm{identifier} or is a
\grammarterm{parameter-declaration} that declares a parameter
pack~(\ref{dcl.fct}), then the \grammarterm{template-parameter}
is a template parameter pack~(\ref{temp.variadic}).
A template parameter pack that is a \grammarterm{parameter-declaration} whose type
contains one or more unexpanded parameter packs is a pack expansion. Similarly,
a template parameter pack that is a \grammarterm{type-parameter} with a
\grammarterm{template-parameter-list} containing one or more unexpanded
parameter packs is a pack expansion. A template parameter pack that is a pack
expansion shall not expand a parameter pack declared in the same
\grammarterm{template-parameter-list}.
\enterexample
\begin{codeblock}
template <class... Types> class Tuple;                // \tcode{Types} is a template type parameter pack
                                                      // but not a pack expansion
template <class T, int... Dims> struct multi_array;   // \tcode{Dims} is a non-type template parameter pack
                                                      // but not a pack expansion
template<class... T> struct value_holder {
  template<T... Values> struct apply { };             // \tcode{Values} is a non-type template parameter pack
                                                      // and a pack expansion
};
template<class... T, T... Values> struct static_array;// error: \tcode{Values} expands template type parameter
                                                      // pack \tcode{T} within the same template parameter list
\end{codeblock}
\exitexample

\rSec1[temp.names]{Names of template specializations}

\pnum
A template specialization~(\ref{temp.spec}) can be referred to by a
\grammarterm{template-id}:

\begin{bnf}
\nontermdef{simple-template-id}\br
  template-name \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}

\begin{bnf}
\nontermdef{template-id}\br
  simple-template-id\br
  operator-function-id \terminal{<} template-argument-list\opt \terminal{>}\br
  literal-operator-id \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}

\begin{bnf}
\nontermdef{template-name}\br
  identifier
\end{bnf}

\begin{bnf}
\nontermdef{template-argument-list}\br
  template-argument \terminal{...}\opt\br
  template-argument-list \terminal{,} template-argument \terminal{...}\opt
\end{bnf}

\begin{bnf}
\nontermdef{template-argument}\br
  constant-expression\br
  type-id\br
  id-expression
\end{bnf}

\enternote
The name lookup rules~(\ref{basic.lookup}) are used to associate the use of
a name with a template declaration;
that is, to identify a name as a
\grammarterm{template-name}.
\exitnote

\pnum
For a
\grammarterm{template-name}
to be explicitly qualified by the template arguments,
the name must be known to refer to a template.

\pnum
\indextext{\idxcode{<}!template~and}%
After name lookup~(\ref{basic.lookup}) finds that a name is a
\grammarterm{template-name}
or that an \grammarterm{operator-function-id} or a \grammarterm{literal-operator-id} refers to a set of
overloaded functions any member of which is a function template,
if this is followed by a
\tcode{<},
the
\tcode{<}
is always taken as the delimiter of a
\grammarterm{template-argument-list}
and never as the less-than operator.
When parsing a \grammarterm{template-argument-list},
the first non-nested
\tcode{>}\footnote{A \tcode{>} that encloses the \grammarterm{type-id}
of a \tcode{dynamic_cast}, \tcode{static_cast}, \tcode{reinterpret_cast}
or \tcode{const_cast}, or which encloses the \grammarterm{template-argument}{s}
of a subsequent \grammarterm{template-id}, is considered nested for the purpose
of this description.
}
is taken as the ending delimiter
rather than a greater-than operator.
Similarly, the first non-nested \tcode{>{>}} is treated as two
consecutive but distinct \tcode{>} tokens, the first of which is taken
as the end of the \nonterminal{template-argument-list} and completes
the \nonterminal{template-id}. \enternote The second \tcode{>}
token produced by this replacement rule may terminate an enclosing
\nonterminal{template-id} construct or it may be part of a different
construct (e.g. a cast).\exitnote
\enterexample

\begin{codeblock}
template<int i> class X @\tcode{\{ /* ... */ \};}@

X< 1>2 > x1;                        // syntax error
X<(1>2)> x2;                        // OK

template<class T> class Y @\tcode{\{ /* ... */ \};}@
Y<X<1>> x3;                         // OK, same as \tcode{Y<X<1> > x3;}
Y<X<6>>1>> x4;                      // syntax error
Y<X<(6>>1)>> x5;                    // OK
\end{codeblock}
\exitexample

\pnum
When the name of a member template specialization appears after
\tcode{.}
or
\tcode{->}
in a
\grammarterm{postfix-expression}
or after a
\grammarterm{nested-name-specifier}
in a
\grammarterm{qualified-id},
and the
object expression of the
\grammarterm{postfix-expression}
is type-dependent
or
the \grammarterm{nested-name-specifier} in the
\grammarterm{qualified-id}
refers to a dependent type, but the name is not
a member of the current instantiation~(\ref{temp.dep.type}),
the member template name must be prefixed by the keyword
\tcode{template}.
Otherwise the name is assumed to name a non-template.
\enterexample

\begin{codeblock}
struct X {
  template<std::size_t> X* alloc();
  template<std::size_t> static X* adjust();
};
template<class T> void f(T* p) {
  T* p1 = p->alloc<200>();          // ill-formed: \tcode{<} means less than
  T* p2 = p->template alloc<200>(); // OK: \tcode{<} starts template argument list
  T::adjust<100>();                 // ill-formed: \tcode{<} means less than
  T::template adjust<100>();        // OK: \tcode{<} starts template argument list
}
\end{codeblock}
\exitexample

\pnum
A name prefixed by the keyword
\tcode{template}
shall be a \grammarterm{template-id} or the name shall refer to a class template.
\enternote
The keyword
\tcode{template}
may not be applied to non-template members of class templates.
\exitnote
\enternote
As is the case with the
\tcode{typename}
prefix, the
\tcode{template}
prefix is allowed in cases where it is not strictly
necessary; i.e., when the \grammarterm{nested-name-specifier} or
the expression on the left of
the
\tcode{->}
or
\tcode{.}
is not dependent on a
\grammarterm{template-parameter}, or the use does not appear in the
scope of a template.
\exitnote
\enterexample
\begin{codeblock}
template <class T> struct A {
  void f(int);
  template <class U> void f(U);
};

template <class T> void f(T t) {
  A<T> a;
  a.template f<>(t);                // OK: calls template
  a.template f(t);                  // error: not a \grammarterm{template-id}
}

template <class T> struct B {
  template <class T2> struct C { };
};

// OK: \tcode{T::template C} names a class template:
template <class T, template <class X> class TT = T::template C> struct D { };
D<B<int> > db;
\end{codeblock}
\exitexample

\pnum
\indextext{specialization!class template}%
A
\grammarterm{simple-template-id}
that names a class template specialization is a
\grammarterm{class-name}
(Clause~\ref{class}).

\pnum
A \grammarterm{template-id} that names an alias template
specialization is a \grammarterm{type-name}.

\rSec1[temp.arg]{Template arguments}

\pnum
\indextext{argument!template}%
There are three forms of
\grammarterm{template-argument},
corresponding to the three forms of
\grammarterm{template-parameter}:
type, non-type and template.
The type and form of each
\grammarterm{template-argument}
specified in a
\grammarterm{template-id}
shall match the type and form specified for the corresponding
parameter declared by the template in its
\grammarterm{template-parameter-list}.
When the parameter declared by the template is a template
parameter pack~(\ref{temp.variadic}), it will correspond to zero or more
\grammarterm{template-argument}{s}.
\enterexample

\begin{codeblock}
template<class T> class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T& operator[](int);
  T& elem(int i) { return v[i]; }
};

Array<int> v1(20);
typedef std::complex<double> dcomplex;  // \tcode{std::complex} is a standard
                                        // library template
Array<dcomplex> v2(30);
Array<dcomplex> v3(40);

void bar() {
  v1[3] = 7;
  v2[3] = v3.elem(4) = dcomplex(7,8);
}
\end{codeblock}
\exitexample

\pnum
In a
\grammarterm{template-argument},
an ambiguity between a
\grammarterm{type-id}
and an expression is resolved to a
\grammarterm{type-id},
regardless of the form of the corresponding
\grammarterm{template-parameter}.\footnote{There is no such ambiguity in a default
\grammarterm{template-argument}
because the form of the
\grammarterm{template-parameter}
determines the allowable forms of the
\grammarterm{template-argument}.}
\enterexample

\begin{codeblock}
template<class T> void f();
template<int I> void f();

void g() {
  f<int()>();       // \tcode{int()} is a type-id: call the first \tcode{f()}
}
\end{codeblock}
\exitexample

\pnum
The name of a
\grammarterm{template-argument}
shall be accessible at the point where it is used as a
\grammarterm{template-argument}.
\enternote
If the name of the
\grammarterm{template-argument}
is accessible at the point where it is used as a
\grammarterm{template-argument},
there is no further access restriction in the resulting instantiation where the
corresponding
\grammarterm{template-parameter}
name is used.
\exitnote
\enterexample

\begin{codeblock}
template<class T> class X {
  static T t;
};

class Y {
private:
  struct S { /* ... */ };
  X<S> x;           // OK: \tcode{S} is accessible
                    // \tcode{X<Y::S>} has a static member of type \tcode{Y::S}
                    // OK: even though \tcode{Y::S} is private
};

X<Y::S> y;          // error: \tcode{S} not accessible
\end{codeblock}
\exitexample
For a
\grammarterm{template-argument}
that is a class type or a class template, the template
definition has no special access rights to the
members of the \grammarterm{template-argument}. \enterexample

\begin{codeblock}
template <template <class TT> class T> class A {
  typename T<int>::S s;
};

template <class U> class B {
private:
  struct S { /* ... */ };
};

A<B> b;             // ill-formed: \tcode{A} has no access to \tcode{B::S}
\end{codeblock}
\exitexample

\pnum
When template argument packs or default
\grammarterm{template-argument}{s}
are used, a
\grammarterm{template-argument}
list can be empty.
In that case the empty
\tcode{<>}
brackets shall still be used as the
\grammarterm{template-argument-list.}
\enterexample

\begin{codeblock}
template<class T = char> class String;
String<>* p;                    // OK: \tcode{String<char>}
String* q;                      // syntax error
template<class ... Elements> class Tuple;
Tuple<>* t;                     // OK: \tcode{Elements} is empty
Tuple* u;                       // syntax error
\end{codeblock}
\exitexample

\pnum
An explicit destructor call~(\ref{class.dtor}) for an object that has a type
that is a class template specialization may explicitly specify the
\grammarterm{template-argument}{s}.
\enterexample

\begin{codeblock}
template<class T> struct A {
  ~A();
};
void f(A<int>* p, A<int>* q) {
  p->A<int>::~A();              // OK: destructor call
  q->A<int>::~A<int>();         // OK: destructor call
}
\end{codeblock}
\exitexample

\pnum
If the use of a
\grammarterm{template-argument}
gives rise to an ill-formed construct in the instantiation of a
template specialization, the program is ill-formed.

\pnum
When the template in a
\grammarterm{template-id}
is an overloaded function template, both non-template functions in the overload
set and function templates in the overload set for
which the
\grammarterm{template-argument}{s}
do not match the
\grammarterm{template-parameter}{s}
are ignored.
If none of the function templates have matching
\grammarterm{template-parameter}{s},
the program is ill-formed.

\pnum
A \grammarterm{template-argument} followed by an ellipsis is
a pack expansion~(\ref{temp.variadic}).

\rSec2[temp.arg.type]{Template type arguments}

\pnum
A
\grammarterm{template-argument}
for a
\grammarterm{template-parameter}
which is a type
shall be a
\grammarterm{type-id}.

\pnum
\enterexample
\begin{codeblock}
template <class T> class X { };
template <class T> void f(T t) { }
struct { } unnamed_obj;

void f() {
  struct A { };
  enum { e1 };
  typedef struct { } B;
  B b;
  X<A> x1;          // OK
  X<A*> x2;         // OK
  X<B> x3;          // OK
  f(e1);            // OK
  f(unnamed_obj);   // OK
  f(b);             // OK
}
\end{codeblock}
\exitexample
\enternote
A template type argument may be an incomplete type~(\ref{basic.types}).
\exitnote

\pnum
If a declaration acquires a function type through a type dependent on a
\grammarterm{template-parameter}
and this causes a declaration that does not use the
syntactic form of a function declarator to have function type,
the program is ill-formed.
\enterexample

\begin{codeblock}
template<class T> struct A {
  static T t;
};
typedef int function();
A<function> a;                  // ill-formed: would declare \tcode{A<function>::t}
                                // as a static member function
\end{codeblock}
\exitexample

\rSec2[temp.arg.nontype]{Template non-type arguments}

\pnum
A
\grammarterm{template-argument}
for a non-type, non-template
\grammarterm{template-parameter}
shall be one of:
\begin{itemize}
\item
for a non-type \grammarterm{template-parameter} of integral or enumeration type,
a converted
constant expression~(\ref{expr.const})
of the type of the \grammarterm{template-parameter}{}; or
\item
the name of a non-type
\grammarterm{template-parameter};
or
\item
a constant expression~(\ref{expr.const}) that designates
the address of a complete object
with static storage duration and external or internal linkage
or a function with external or internal linkage,
including function templates and function
\grammarterm{template-id}{s}
but
excluding non-static class members, expressed (ignoring parentheses) as
\tcode{\&}
\grammarterm{id-expression}{},
where the \grammarterm{id-expression} is the name of an object or function,
except that the \tcode{\&}
may be omitted if the name refers to a function or
array and shall be omitted if the corresponding
\grammarterm{template-parameter}
is a reference;
or
\item
a constant expression that evaluates to a null pointer
value~(\ref{conv.ptr});
or
\item
a constant expression that evaluates to a null member pointer
value~(\ref{conv.mem});
or
\item
a pointer to member expressed as described in~\ref{expr.unary.op};
or
\item
a constant expression of type \tcode{std::nullptr_t}.
\end{itemize}

\pnum
\enternote
A string literal~(\ref{lex.string})
does not satisfy the requirements of any of these
categories and thus is not an acceptable
\grammarterm{template-argument}.
\enterexample

\begin{codeblock}
template<class T, const char* p> class X {
  /* ... */
};

X<int, "Studebaker"> x1;        // error: string literal as template-argument

const char p[] = "Vivisectionist";
X<int,p> x2;                    // OK
\end{codeblock}
\exitexample
\exitnote

\pnum
\enternote
Addresses of array elements and names or addresses of non-static class
members are not acceptable
\grammarterm{template-argument}{s}.
\enterexample

\begin{codeblock}
template<int* p> class X { };

int a[10];
struct S { int m; static int s; } s;

X<&a[2]> x3;                    // error: address of array element
X<&s.m> x4;                     // error: address of non-static member
X<&s.s> x5;                     // error: \tcode{\&S::s} must be used
X<&S::s> x6;                    // OK: address of static member
\end{codeblock}
\exitexample
\exitnote

\pnum
\enternote
Temporaries, unnamed lvalues, and named lvalues
with no linkage
are not acceptable
\grammarterm{template-argument}{s}
when the corresponding
\grammarterm{template-parameter}
has reference type.
\enterexample

\begin{codeblock}
template<const int& CRI> struct B { /* ... */ };

B<1> b2;                        // error: temporary would be required for template argument

int c = 1;
B<c> b1;                        // OK
\end{codeblock}
\exitexample
\exitnote

\pnum
The following conversions are performed on each expression used as a non-type
\grammarterm{template-argument}.
If a non-type
\grammarterm{template-argument}
cannot be converted to the type of the corresponding
\grammarterm{template-parameter}
then the program is ill-formed.

\begin{itemize}
\item
For a non-type
\grammarterm{template-parameter}
of integral or enumeration type,
conversions permitted in a converted constant expression~(\ref{expr.const})
are applied.
\item
for a non-type
\grammarterm{template-parameter}
of type pointer to object,
qualification conversions~(\ref{conv.qual}) and
the array-to-pointer conversion~(\ref{conv.array}) are applied; if the
\grammarterm{template-argument} is of type \tcode{std::nullptr_t}, the null
pointer conversion~(\ref{conv.ptr}) is applied.
\enternote
In particular, neither the null pointer conversion for a zero-valued integer
literal~(\ref{conv.ptr}) nor the
derived-to-base conversion~(\ref{conv.ptr}) are applied.
Although
\tcode{0}
is a valid
\grammarterm{template-argument}
for a non-type
\grammarterm{template-parameter}
of integral type, it is not a valid
\grammarterm{template-argument}
for a non-type
\grammarterm{template-parameter}
of pointer type.
However, both \tcode{(int*)0} and \tcode{nullptr} are valid \grammarterm{template-argument}{s}
for a non-type \grammarterm{template-parameter} of type ``pointer to int.''
\exitnote
\item
For a non-type
\grammarterm{template-parameter}
of type reference to object,
no conversions apply.
The type referred to by the reference may be more cv-qualified than the
(otherwise identical) type of the
\grammarterm{template-argument}.
The
\grammarterm{template-parameter}
is bound directly to the
\grammarterm{template-argument},
which shall be an lvalue.
\item
For a non-type
\grammarterm{template-parameter}
of type pointer to function, the function-to-pointer conversion~(\ref{conv.func})
is applied; if the \grammarterm{template-argument} is of type
\tcode{std::nullptr_t}, the null pointer conversion~(\ref{conv.ptr}) is applied.
If the
\grammarterm{template-argument}
represents a set of overloaded functions (or a pointer to such), the matching
function is selected from the set~(\ref{over.over}).
\item
For a non-type
\grammarterm{template-parameter}
of type reference to function, no conversions apply.
If the
\grammarterm{template-argument}
represents a set of overloaded functions, the matching function is selected
from the set~(\ref{over.over}).
\item
For a non-type
\grammarterm{template-parameter}
of type pointer to member function,
if the \grammarterm{template-argument} is of type \tcode{std::nullptr_t}, the
null member pointer conversion~(\ref{conv.mem}) is applied; otherwise,
no conversions apply.
If the
\grammarterm{template-argument}
represents a set of overloaded member functions, the matching
member function is selected from the set~(\ref{over.over}).
\item
For a non-type
\grammarterm{template-parameter}
of type pointer to data member,
qualification conversions~(\ref{conv.qual})
are applied; if the \grammarterm{template-argument} is of type
\tcode{std::nullptr_t}, the null member pointer conversion~(\ref{conv.mem}) is
applied.
\end{itemize}

\enterexample
\begin{codeblock}
template<const int* pci> struct X { /* ... */ };
int ai[10];
X<ai> xi;                       // array to pointer and qualification conversions

struct Y { /* ... */ };
template<const Y& b> struct Z { /* ... */ };
Y y;
Z<y> z;                         // no conversion, but note extra cv-qualification

template<int (&pa)[5]> struct W { /* ... */ };
int b[5];
W<b> w;                         // no conversion

void f(char);
void f(int);

template<void (*pf)(int)> struct A { /* ... */ };

A<&f> a;                        // selects \tcode{f(int)}
\end{codeblock}
\exitexample

\rSec2[temp.arg.template]{Template template arguments}

\pnum
A
\grammarterm{template-argument}
for a template
\grammarterm{template-parameter}
shall be the name of a class template or an alias template, expressed as
\grammarterm{id-expression}.
When the \grammarterm{template-argument} names a class
template, only primary class templates are considered when matching the template template
argument with the corresponding parameter; partial specializations are not
considered even if their parameter lists match that of the template template
parameter.

\pnum
Any partial specializations~(\ref{temp.class.spec}) associated with the
primary class template or primary variable template are considered when a
specialization based on the template
\grammarterm{template-parameter}
is instantiated.
If a specialization is not visible at the point of instantiation,
and it would have been selected had it been visible, the program is ill-formed;
no diagnostic is required.
\enterexample

\begin{codeblock}
template<class T> class A {     // primary template
  int x;
};
template<class T> class A<T*> { // partial specialization
  long x;
};
template<template<class U> class V> class C {
  V<int>  y;
  V<int*> z;
};
C<A> c;                         // \tcode{V<int>} within \tcode{C<A>} uses the primary template,
                                // so \tcode{c.y.x} has type \tcode{int}
                                // \tcode{V<int*>} within \tcode{C<A>} uses the partial specialization,
                                // so \tcode{c.z.x} has type \tcode{long}
\end{codeblock}
\exitexample

\pnum A \grammarterm{template-argument} matches a template
\grammarterm{template-parameter} (call it \tcode{P}) when each of the template
parameters in the \grammarterm{template-parameter-list} of the
\grammarterm{template-argument}'s corresponding class template or alias template (call
it \tcode{A}) matches the corresponding template parameter in the
\grammarterm{template-parameter-list} of \tcode{P}. 
Two template parameters match if they are of the same kind (type, non-type, template),
for non-type \grammarterm{template-parameter}{s}, their types are
equivalent~(\ref{temp.over.link}), and for template \grammarterm{template-parameter}{s},
each of their corresponding \grammarterm{template-parameter}{s} matches, recursively.
When \tcode{P}'s \grammarterm{template-parameter-list} contains a template parameter
pack~(\ref{temp.variadic}), the template parameter pack will match zero or more template
parameters or template parameter packs in the \grammarterm{template-parameter-list} of
\tcode{A} with the same type and form as the template parameter pack in \tcode{P}
(ignoring whether those template parameters are template parameter packs).

\enterexample
\begin{codeblock}
template<class T> class A { /* ... */ };
template<class T, class U = T> class B { /* ... */ };
template <class ... Types> class C { /* ... */ };

template<template<class> class P> class X { /* ... */ };
template<template<class ...> class Q> class Y { /* ... */ };

X<A> xa;            // OK
X<B> xb;            // ill-formed: default arguments for the parameters of a template argument are ignored
X<C> xc;            // ill-formed: a template parameter pack does not match a template parameter

Y<A> ya;            // OK
Y<B> yb;            // OK
Y<C> yc;            // OK
\end{codeblock}
\exitexample

\enterexample
\begin{codeblock}
template <class T> struct eval;

template <template <class, class...> class TT, class T1, class... Rest>
struct eval<TT<T1, Rest...>> { };

template <class T1> struct A;
template <class T1, class T2> struct B;
template <int N> struct C;
template <class T1, int N> struct D;
template <class T1, class T2, int N = 17> struct E;

eval<A<int>> eA;                // OK: matches partial specialization of \tcode{eval}
eval<B<int, float>> eB;         // OK: matches partial specialization of \tcode{eval}
eval<C<17>> eC;                 // error: \tcode{C} does not match \tcode{TT} in partial specialization
eval<D<int, 17>> eD;            // error: \tcode{D} does not match \tcode{TT} in partial specialization
eval<E<int, float>> eE;         // error: \tcode{E} does not match \tcode{TT} in partial specialization
\end{codeblock}
\exitexample

\rSec1[temp.type]{Type equivalence}

\pnum
\indextext{equivalence!template type}%
Two \grammarterm{template-id}{s} refer to the same
class, function, or variable if
\begin{itemize}
\item {their \grammarterm{template-name}{s},
\grammarterm{operator-function-id}{s}, or \grammarterm{literal-operator-id}{s}
refer to the same template and}
\item {their corresponding type \grammarterm{template-argument}{s} are the
same type and}
\item {their corresponding non-type
template arguments of
integral or enumeration type have identical values and}
\item {their corresponding non-type \grammarterm{template-argument}{s} of
pointer type refer to the same external object or function or are both the null
pointer value and}
\item {their corresponding non-type \grammarterm{template-argument}{s} of
pointer-to-member type refer to the same class member or are both the null member
pointer value and}
\item {their corresponding non-type \grammarterm{template-argument}{s} of
reference type refer to the same external object or function and}
\item {their corresponding template \grammarterm{template-argument}{s} refer
to the same template.}
\end{itemize}
\enterexample

\begin{codeblock}
template<class E, int size> class buffer { /* ... */ };
buffer<char,2*512> x;
buffer<char,1024> y;
\end{codeblock}

declares
\tcode{x}
and
\tcode{y}
to be of the same type, and

\begin{codeblock}
template<class T, void(*err_fct)()> class list { /* ... */ };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;
\end{codeblock}

declares
\tcode{x2}
and
\tcode{x3}
to be of the same type.
Their type differs from the types of
\tcode{x1}
and
\tcode{x4}.

\begin{codeblock}
template<class T> struct X { };
template<class> struct Y { };
template<class T> using Z = Y<T>;
X<Y<int> > y;
X<Z<int> > z;
\end{codeblock}

declares \tcode{y} and \tcode{z} to be of the same type.
\exitexample

\pnum
If an expression $e$ involves a template parameter, \tcode{decltype($e$)}
denotes a unique dependent type. Two such \grammarterm{decltype-specifier}{s}
refer to the same type only if their \grammarterm{expression}{s} are
equivalent~(\ref{temp.over.link}). \enternote however, it may be aliased,
e.g., by a \grammarterm{typedef-name}. \exitnote

\rSec1[temp.decls]{Template declarations}

\pnum
A
\grammarterm{template-id},
that is, the
\grammarterm{template-name}
followed by a
\grammarterm{template-argument-list}
shall not be specified in the declaration of a primary template declaration.
\enterexample

\begin{codeblock}
template<class T1, class T2, int I> class A<T1, T2, I> { };     // error
template<class T1, int I> void sort<T1, I>(T1 data[I]);         // error
\end{codeblock}
\exitexample
\enternote
However, this syntax is allowed in class template partial specializations~(\ref{temp.class.spec}).
\exitnote

\pnum
For purposes of name lookup and instantiation,
default arguments and \grammarterm{exception-specification}{s} of function
templates and default arguments and \grammarterm{exception-specification}{s} of
member functions of class templates are considered definitions;
each default argument or \grammarterm{exception-specification} is a separate
definition which is unrelated to
the function template definition or to any other default arguments or
\grammarterm{exception-specification}{s}.

\pnum
Because an \grammarterm{alias-declaration} cannot declare a
\grammarterm{template-id}, it is not possible to partially or
explicitly specialize an alias template.

\rSec2[temp.class]{Class templates}

\pnum
A class
\term{template}
defines the layout and operations
for an unbounded set of related types.
\enterexample
a single class template
\tcode{List}
might provide a common definition for
list of
\tcode{int},
list of
\tcode{float},
and list of pointers to
\tcode{Shape}s.
\exitexample

\enterexample
An array class template might be declared like this:

\begin{codeblock}
template<class T> class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T& operator[](int);
  T& elem(int i) { return v[i]; }
};
\end{codeblock}

\pnum
The prefix
\tcode{template}
\tcode{<class}
\tcode{T>}
specifies that a template is being declared and that a
\grammarterm{type-name}
\tcode{T}
will be used in the declaration.
In other words,
\tcode{Array}
is a parameterized type with
\tcode{T}
as its parameter.
\exitexample

\pnum
When a member function, a member class, a member enumeration, a static data member or
a member template of a class
template is defined outside of the class template definition,
the member definition is defined as a template definition in which the
\grammarterm{template-parameter}{s}
are those of the class template.
The names of the template parameters used in the definition of the member may
be different from the template parameter names used in the class
template definition.
The template argument list following the class template name in the member
definition shall name the parameters in the same order as the one used in
the template parameter list of the member. Each template
parameter pack shall be expanded with an ellipsis in the template
argument list.
\enterexample

\begin{codeblock}
template<class T1, class T2> struct A {
  void f1();
  void f2();
};

template<class T2, class T1> void A<T2,T1>::f1() { }    // OK
template<class T2, class T1> void A<T1,T2>::f2() { }    // error
\end{codeblock}

\begin{codeblock}
template<class ... Types> struct B {
  void f3();
  void f4();
};

template<class ... Types> void B<Types ...>::f3() { }    // OK
template<class ... Types> void B<Types>::f4() { }        // error
\end{codeblock}

\exitexample

\pnum
In a redeclaration, partial
specialization,
explicit specialization or explicit
instantiation of a class template, the
\grammarterm{class-key}
shall agree in kind with the original class template declaration~(\ref{dcl.type.elab}).

\rSec3[temp.mem.func]{Member functions of class templates}

\pnum
\indextext{template!member~function}%
A member function
of a class template
may be defined outside of the class
template definition in which it is declared.
\enterexample

\begin{codeblock}
template<class T> class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T& operator[](int);
  T& elem(int i) { return v[i]; }
};
\end{codeblock}

declares three function templates.
The subscript function might be defined like this:

\begin{codeblock}
template<class T> T& Array<T>::operator[](int i) {
  if (i<0 || sz<=i) error("Array: range error");
  return v[i];
}
\end{codeblock}
\exitexample

\pnum
The
\grammarterm{template-argument}{s}
for a member function of a class template are determined by the
\grammarterm{template-argument}{s}
of the type of the object for which the member function is called.
\enterexample
the
\grammarterm{template-argument}
for
\tcode{Array<T>\,::\,op\-er\-a\-tor\,[]\,()}
will be determined by the
\tcode{Array}
to which the subscripting operation is applied.

\begin{codeblock}
Array<int> v1(20);
Array<dcomplex> v2(30);

v1[3] = 7;                      // \tcode{Array<int>::operator[]()}
v2[3] = dcomplex(7,8);          // \tcode{Array<dcomplex>::operator[]()}
\end{codeblock}
\exitexample

\rSec3[temp.mem.class]{Member classes of class templates}

\pnum
A member class of a class template may be defined outside the class template
definition in which it is declared.
\enternote
The member class must be defined before its first use that requires
an instantiation~(\ref{temp.inst}).
For example,

\begin{codeblock}
template<class T> struct A {
  class B;
};
A<int>::B* b1;                  // OK: requires \tcode{A} to be defined but not \tcode{A::B}
template<class T> class A<T>::B { };
A<int>::B  b2;                  // OK: requires \tcode{A::B} to be defined
\end{codeblock}
\exitnote

\rSec3[temp.static]{Static data members of class templates}

\pnum
\indextext{member!template~and \tcode{static}}%
A definition for a static data member or static data member template may be
provided in a namespace scope enclosing the definition of the static member's
class template.
\enterexample

\begin{codeblock}
template<class T> class X {
  static T s;
};
template<class T> T X<T>::s = 0;

struct limits {
  template<class T>
    static const T min;           // declaration
};

template<class T>
  const T limits::min = { };      // definition
\end{codeblock}
\exitexample

\pnum
An explicit specialization of a static data member declared as an array of unknown
bound can have a different bound from its definition, if any. \enterexample

\begin{codeblock}
template <class T> struct A {
  static int i[];
};
template <class T> int A<T>::i[4];    // 4 elements
template <> int A<int>::i[] = { 1 };  // OK: 1 element
\end{codeblock}
\exitexample

\rSec3[temp.mem.enum]{Enumeration members of class templates}

\pnum
An enumeration member of a class template may be defined outside the class
template definition. \enterexample

\begin{codeblock}
template<class T> struct A {
  enum E : T;
};
A<int> a;
template<class T> enum A<T>::E : T { e1, e2 };
A<int>::E e = A<int>::e1;
\end{codeblock}
\exitexample

\rSec2[temp.mem]{Member templates}

\pnum
A template can be declared within a class or class template; such a template
is called a member template.
A member template can be defined within or outside its class definition or
class template definition.
A member template of a class template that is defined outside of its class
template definition shall be specified with the
\grammarterm{template-parameter}{s}
of the class template followed by the
\grammarterm{template-parameter}{s}
of the member template.
\enterexample

\begin{codeblock}
template<class T> struct string {
  template<class T2> int compare(const T2&);
  template<class T2> string(const string<T2>& s) { /* ... */ }
};

template<class T> template<class T2> int string<T>::compare(const T2& s) {
}
\end{codeblock}
\exitexample

\pnum
A local class of non-closure type shall not have member templates.
Access control rules (Clause~\ref{class.access})
apply to member template names.
A destructor shall not be a member
template.
A non-template member function~(\ref{dcl.fct}) with a given name
and type and a member function template of the same name, which could be
used to generate a specialization of the same type, can both be
declared in a class.
When both exist, a use of that name and type refers to the
non-template member unless an explicit template argument list is supplied.
\enterexample

\begin{codeblock}
template <class T> struct A {
  void f(int);
  template <class T2> void f(T2);
};

template <> void A<int>::f(int) { }                     // non-template member function
template <> template <> void A<int>::f<>(int) { }       // member function template specialization

int main() {
  A<char> ac;
  ac.f(1);          // non-template
  ac.f('c');        // template
  ac.f<>(1);        // template
}
\end{codeblock}
\exitexample

\pnum
A member function template shall not be virtual.
\enterexample

\begin{codeblock}
template <class T> struct AA {
  template <class C> virtual void g(C);   // error
  virtual void f();                       // OK
};
\end{codeblock}
\exitexample

\pnum
A specialization of
a member function template does not override a virtual function from a
base class.
\enterexample

\begin{codeblock}
class B {
  virtual void f(int);
};

class D : public B {
  template <class T> void f(T); // does not override \tcode{B::f(int)}
  void f(int i) { f<>(i); }     // overriding function that calls
                                // the template instantiation
};
\end{codeblock}
\exitexample

\pnum
A specialization of a
conversion function template
is referenced in
the same way as a non-template conversion function that converts to
the same type.
\enterexample

\begin{codeblock}
struct A {
  template <class T> operator T*();
};
template <class T> A::operator T*(){ return 0; }
template <> A::operator char*(){ return 0; }    // specialization
template A::operator void*();                   // explicit instantiation

int main() {
  A a;
  int* ip;
  ip = a.operator int*();       // explicit call to template operator
                                // \tcode{A::operator int*()}
}
\end{codeblock}
\exitexample
\enternote
Because the explicit template argument list follows the function template
name, and because conversion member function templates and constructor
member function templates are called without using a function name,
there is no way to provide an explicit template argument list for these
function templates.
\exitnote

\pnum
A specialization of a
conversion function template
is not found by name
lookup.
Instead, any
conversion function templates
visible in the
context of the use are considered.
For each such operator, if argument
deduction succeeds~(\ref{temp.deduct.conv}), the resulting specialization is
used as if found by name lookup.

\pnum
A \grammarterm{using-declaration} in a derived class cannot refer to a specialization
of a
conversion function template
in a base class.

\pnum
Overload resolution~(\ref{over.ics.rank}) and partial
ordering~(\ref{temp.func.order}) are used to select the best conversion function
among multiple
specializations of conversion function templates
and/or non-template
conversion functions.

\rSec2[temp.variadic]{Variadic templates}

\pnum
A \term{template parameter pack} is a template parameter
that accepts zero or more template arguments. \enterexample

\begin{codeblock}
template<class ... Types> struct Tuple { };

Tuple<> t0;                     // \tcode{Types} contains no arguments
Tuple<int> t1;                  // \tcode{Types} contains one argument: \tcode{int}
Tuple<int, float> t2;           // \tcode{Types} contains two arguments: \tcode{int} and \tcode{float}
Tuple<0> error;                 // error: 0 is not a type
\end{codeblock}

\exitexample

\pnum
A \term{function parameter pack} is a function parameter
that accepts zero or more function arguments. \enterexample

\begin{codeblock}
template<class ... Types> void f(Types ... args);

f();                // OK: \tcode{args} contains no arguments
f(1);               // OK: \tcode{args} contains one argument: \tcode{int}
f(2, 1.0);          // OK: \tcode{args} contains two arguments: \tcode{int} and \tcode{double}
\end{codeblock}

\exitexample

\pnum
A \term{parameter pack} is either a template parameter
pack or a function parameter pack.

\pnum
A \term{pack expansion}
consists of a \term{pattern} and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
\item In a function parameter pack~(\ref{dcl.fct}); the pattern is the
\grammarterm{parameter-declaration} without the ellipsis.

\item In a template parameter pack that is a pack expansion~(\ref{temp.param}):

\begin{itemize}
\item if the template parameter pack is a \grammarterm{parameter-declaration};
the pattern is the \grammarterm{parameter-declaration} without the ellipsis;

\item if the template parameter pack is a \grammarterm{type-parameter} with a
\grammarterm{template-parameter-list}; the pattern is the corresponding
\grammarterm{type-parameter} without the ellipsis.
\end{itemize}

\item In an \grammarterm{initializer-list}~(\ref{dcl.init});
the pattern is an \grammarterm{initializer-clause}.

\item In a \grammarterm{base-specifier-list} (Clause~\ref{class.derived});
the pattern is a \grammarterm{base-specifier}.

\item In a \grammarterm{mem-initializer-list}~(\ref{class.base.init}) for a
\grammarterm{mem-initializer} whose \grammarterm{mem-initializer-id} denotes a
base class; the pattern is the \grammarterm{mem-initializer}.

\item In a \grammarterm{template-argument-list}~(\ref{temp.arg});
the pattern is a \grammarterm{template-argument}.

\item In a \grammarterm{dynamic-exception-specification}~(\ref{except.spec});
the pattern is a \grammarterm{type-id}.

\item In an \grammarterm{attribute-list}~(\ref{dcl.attr.grammar}); the pattern is
an \grammarterm{attribute}.

\item In an \grammarterm{alignment-specifier}~(\ref{dcl.align}); the pattern is
the \grammarterm{alignment-specifier} without the ellipsis.

\item In a \grammarterm{capture-list}~(\ref{expr.prim.lambda}); the pattern is
a \grammarterm{capture}.

\item In a \tcode{sizeof...} expression~(\ref{expr.sizeof}); the pattern is an
\grammarterm{identifier}.
\end{itemize}

\pnum
For the purpose of determining whether a parameter pack satisfies a rule
regarding entities other than parameter packs, the parameter pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.

\enterexample

\begin{codeblock}
template<class ... Types> void f(Types ... rest);
template<class ... Types> void g(Types ... rest) {
  f(&rest ...);     // ``\tcode{\&rest ...}'' is a pack expansion; ``\tcode{\&rest}'' is its pattern
}
\end{codeblock}

\exitexample

\pnum
A parameter pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a parameter pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more parameter packs that
are not expanded by a nested pack expansion; such parameter packs are called
\term{unexpanded} parameter packs in the pattern. All of the parameter packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a parameter pack that is not expanded is
ill-formed. \enterexample

\begin{codeblock}
template<typename...> struct Tuple {};
template<typename T1, typename T2> struct Pair {};

template<class ... Args1> struct zip {
  template<class ... Args2> struct with {
    typedef Tuple<Pair<Args1, Args2> ... > type;
  };
};

typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
    // \tcode{T1} is \tcode{Tuple<Pair<short, unsigned short>, Pair<int, unsigned>{>}}
typedef zip<short>::with<unsigned short, unsigned>::type T2;
    // error: different number of arguments specified for \tcode{Args1} and \tcode{Args2}

template<class ... Args>
  void g(Args ... args) {               // OK: \tcode{Args} is expanded by the function parameter pack \tcode{args}
    f(const_cast<const Args*>(&args)...); // OK: ``\tcode{Args}'' and ``\tcode{args}'' are expanded
    f(5 ...);                             // error: pattern does not contain any parameter packs
    f(args);                              // error: parameter pack ``\tcode{args}'' is not expanded
    f(h(args ...) + args ...);            // OK: first ``\tcode{args}'' expanded within \tcode{h}, second
                                          // ``\tcode{args}'' expanded within \tcode{f}
  }
\end{codeblock}

\exitexample

\pnum
The instantiation of a pack expansion
that is not a \tcode{sizeof...} expression
produces a
list
$\mathtt{E}_1, \mathtt{E}_2, ..., \mathtt{E}_N$,
where
$N$ is the number of elements in the pack expansion parameters. Each
$\mathtt{E}_i$ is generated by instantiating the pattern and
replacing each pack expansion parameter with its $i$th element.
Such an element, in the context of the instantiation, is interpreted as
follows:

\begin{itemize}
\item
if the pack is a template parameter pack, the element is a template
parameter~(\ref{temp.param}) of the corresponding kind (type or
non-type) designating the type or value from the template
argument; otherwise,

\item
if the pack is a function parameter pack, the element is an
\grammarterm{id-expression}
designating the function parameter that resulted from
the instantiation of the pattern where the pack is declared.
\end{itemize}

All of the $\mathtt{E}_i$ become elements in the enclosing list.
\enternote The variety of list varies with the context:
\grammarterm{expression-list},
\grammarterm{base-specifier-list},
\grammarterm{template-argument-list}, etc.\exitnote
When $N$ is zero, the instantiation of the expansion produces an empty list.
Such an instantiation does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the list entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.
\enterexample
\begin{codeblock}
template<class... T> struct X : T... { };
template<class... T> void f(T... values) {
  X<T...> x(values...);
}

template void f<>();  // OK: \tcode{X<>} has no base classes
                      // \tcode{x} is a variable of type \tcode{X<>} that is value-initialized
\end{codeblock}
\exitexample

\pnum
The instantiation of a \tcode{sizeof...} expression~(\ref{expr.sizeof}) produces
an integral constant containing the number of elements in the parameter pack
it expands.

\rSec2[temp.friend]{Friends}

\pnum
\indextext{friend!template~and}%
A friend of a class or class template can be a function template or
class template, a specialization of a function template or class
template, or a non-template function or class.
For a friend function declaration that is not a template declaration:

\begin{itemize}
\item
if the name of the friend is a qualified or unqualified \grammarterm{template-id},
the friend declaration refers to a specialization of a function
template, otherwise,
\item
if the name of the friend is a \grammarterm{qualified-id} and a matching non-template
function is found in the specified class or namespace, the friend
declaration refers to that function, otherwise,
\item
if the name of the friend is a \grammarterm{qualified-id} and a matching
function template
is found in the specified class
or namespace, the friend declaration refers to
the deduced specialization of that function template~(\ref{temp.deduct.decl}), otherwise,
\item
the name shall be an \grammarterm{unqualified-id} that declares (or redeclares) a
non-template function.
\end{itemize}

\enterexample
\begin{codeblock}
template<class T> class task;
template<class T> task<T>* preempt(task<T>*);

template<class T> class task {
  friend void next_time();
  friend void process(task<T>*);
  friend task<T>* preempt<T>(task<T>*);
  template<class C> friend int func(C);

  friend class task<int>;
  template<class P> friend class frd;
};
\end{codeblock}

Here,
each specialization of the
\tcode{task}
class template has the function
\tcode{next_time}
as a friend;
because
\tcode{process}
does not have explicit
\grammarterm{template-argument}{s},
each specialization of the
\tcode{task}
class template has an appropriately typed function
\tcode{process}
as a friend, and this friend is not a function template specialization;
because the friend
\tcode{preempt}
has an explicit
\grammarterm{template-argument}
\tcode{T},
each specialization of the
\tcode{task}
class template has the appropriate specialization of the function
template
\tcode{preempt}
as a friend;
and each specialization of the
\tcode{task}
class template has all specializations of the function template
\tcode{func}
as friends.
Similarly,
each specialization of the
\tcode{task}
class template has the class template specialization
\tcode{task<int>}
as a friend, and has all specializations of the class template
\tcode{frd}
as friends.
\exitexample

\pnum
A friend template may be declared within a class or class template.
A friend function template may be defined within a class or class
template, but a friend class template may not be defined in a class
or class template.
In these cases, all specializations of the friend class or friend function
template are friends of the class or class template granting friendship.
\enterexample

\begin{codeblock}
class A {
  template<class T> friend class B;                 // OK
  template<class T> friend void f(T)@\tcode{\{ /* ... */ \}}@  // OK
};
\end{codeblock}
\exitexample

\pnum
A template friend declaration specifies that all specializations of that
template, whether they are implicitly instantiated~(\ref{temp.inst}), partially
specialized~(\ref{temp.class.spec}) or explicitly specialized~(\ref{temp.expl.spec}),
are friends of the class containing the template friend declaration.
\enterexample

\begin{codeblock}
class X {
  template<class T> friend struct A;
  class Y { };
};

template<class T> struct A { X::Y ab; };            // OK
template<class T> struct A<T*> { X::Y ab; };        // OK
\end{codeblock}
\exitexample

\pnum
When a function is defined in a friend function declaration in a class
template, the function is instantiated when the function is
odr-used~(\ref{basic.def.odr}). The
same restrictions on multiple declarations and definitions that apply
to non-template function declarations and definitions also apply to
these implicit definitions.

\pnum
A member of a class template may be declared to be a friend of a
non-template class.
In this case, the corresponding member of every specialization of
the class template is a friend of the class granting friendship.
For explicit specializations the corresponding member is the member (if any)
that has the same name, kind (type, function, class template, or function
template), template parameters, and signature as the member of the class
template instantiation that would otherwise have been generated.
\enterexample

\begin{codeblock}
template<class T> struct A {
  struct B { };
  void f();
  struct D {
    void g();
  };
};
template<> struct A<int> {
  struct B { };
  int f();
  struct D {
    void g();
  };
};

class C {
  template<class T> friend struct A<T>::B;    // grants friendship to \tcode{A<int>::B} even though
                                              // it is not a specialization of \tcode{A<T>::B}
  template<class T> friend void A<T>::f();    // does not grant friendship to \tcode{A<int>::f()}
                                              // because its return type does not match
  template<class T> friend void A<T>::D::g(); // does not grant friendship to \tcode{A<int>::D::g()}
                                              // because \tcode{A<int>::D} is not a specialization of \tcode{A<T>::D}
};
\end{codeblock}
\exitexample

\pnum
\enternote
A friend declaration may first declare a member of an enclosing namespace scope~(\ref{temp.inject}).
\exitnote

\pnum
A friend template shall not be declared in a local class.

\pnum
Friend declarations shall not declare partial specializations.
\enterexample

\begin{codeblock}
template<class T> class A { };
class X {
  template<class T> friend class A<T*>; // error
};
\end{codeblock}
\exitexample

\pnum
When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, nor shall the inline specifier be used in such a
declaration.

\rSec2[temp.class.spec]{Class template partial specializations}

\pnum
\indextext{specialization!class template partial}%
\indextext{template!primary}%
A
\term{primary}
class template declaration is one in which the class template name is an
identifier.
A template declaration in which the class template name is a
\grammarterm{simple-template-id}
is a
\term{partial specialization}
of the class template named in the
\grammarterm{simple-template-id}.
A partial specialization of a class template provides an alternative definition
of the template that is used instead of the primary definition when the
arguments in a specialization match those given in the partial
specialization~(\ref{temp.class.spec.match}).
The primary template shall be declared before any specializations of
that template.
A partial specialization shall be declared before the first use of a class template
specialization that would make use of the partial specialization as the result of
an implicit or explicit instantiation in every translation unit in which such a use
occurs; no diagnostic is required.

\pnum
Each class template partial specialization is a distinct template and
definitions shall be provided for the members of a template partial
specialization~(\ref{temp.class.spec.mfunc}).

\pnum
\enterexample
\begin{codeblock}
template<class T1, class T2, int I> class A             { };    // \#1
template<class T, int I>            class A<T, T*, I>   { };    // \#2
template<class T1, class T2, int I> class A<T1*, T2, I> { };    // \#3
template<class T>                   class A<int, T*, 5> { };    // \#4
template<class T1, class T2, int I> class A<T1, T2*, I> { };    // \#5
\end{codeblock}

The first declaration declares the primary (unspecialized) class template.
The second and subsequent declarations declare partial specializations of
the primary template.
\exitexample

\pnum
The template parameters are specified in the angle bracket enclosed list
that immediately follows the keyword
\tcode{tem\-plate}.
For partial specializations, the template argument list is explicitly
written immediately following the class template name.
For primary templates, this list is implicitly described by the
template parameter list.
Specifically, the order of the template arguments is the sequence in
which they appear in the template parameter list.
\enterexample
the template argument list for the primary template in the example
above is
\tcode{<T1,}
\tcode{T2,}
\tcode{I>}.
\exitexample
\enternote
The template argument list shall not be specified in the primary template
declaration.
For example,

\begin{codeblock}
template<class T1, class T2, int I> class A<T1, T2, I>  { };    // error
\end{codeblock}
\exitnote

\pnum
A class template partial specialization may be declared or redeclared in any
namespace scope in which its definition may be defined~(\ref{temp.class} and~\ref{temp.mem}).
\enterexample

\begin{codeblock}
template<class T> struct A {
  struct C {
    template<class T2> struct B { };
  };
};

// partial specialization of \tcode{A<T>::C::B<T2>}
template<class T> template<class T2>
  struct A<T>::C::B<T2*> { };

A<short>::C::B<int*> absip;     // uses partial specialization
\end{codeblock}
\exitexample

\pnum
Partial specialization declarations themselves are not found by name lookup.
Rather, when the primary template name is used, any previously-declared partial
specializations of the primary template are also considered.
One consequence is
that a
\grammarterm{using-declaration}
which refers to a class template does not restrict the set of partial specializations
which may be found through the
\grammarterm{using-declaration}.
\enterexample

\begin{codeblock}
namespace N {
  template<class T1, class T2> class A { };         // primary template
}

using N::A;                             // refers to the primary template

namespace N {
  template<class T> class A<T, T*> { }; // partial specialization
}

A<int,int*> a;                  // uses the partial specialization, which is found through
                                // the using declaration which refers to the primary template
\end{codeblock}
\exitexample

\pnum
A non-type argument is non-specialized if it is the name of a non-type
parameter.
All other non-type arguments are specialized.

\pnum
Within the argument list of a class template partial specialization,
the following restrictions apply:

\begin{itemize}
\item
A partially specialized non-type argument expression shall not involve
a template parameter of the partial specialization except when the argument
expression is a simple
\grammarterm{identifier}.
\enterexample
\begin{codeblock}
template <int I, int J> struct A {};
template <int I> struct A<I+5, I*2> {}; // error

template <int I, int J> struct B {};
template <int I> struct B<I, I> {};     // OK
\end{codeblock}
\exitexample
\item
The type of a template parameter corresponding to a specialized non-type argument
shall not be dependent on a parameter of the specialization.
\enterexample

\begin{codeblock}
template <class T, T t> struct C {};
template <class T> struct C<T, 1>;                  // error

template< int X, int (*array_ptr)[X] > class A {};
int array[5];
template< int X > class A<X,&array> { };            // error
\end{codeblock}

\exitexample
\item
The argument list of the specialization shall not be identical to the
implicit argument list of the primary template.

\item
The specialization shall be more specialized than the primary
template~(\ref{temp.class.order}).

\item
The template parameter list of a specialization shall not contain default
template argument values.\footnote{There is no way in which they could be used.}
\item
An argument shall not contain an unexpanded parameter pack. If
an argument is a pack expansion~(\ref{temp.variadic}), it shall be
the last argument in the template argument list.
\end{itemize}

\rSec3[temp.class.spec.match]{Matching of class template partial specializations}

\pnum
When a class template is used in a context that requires an instantiation of
the class,
it is necessary to determine whether the instantiation is to be generated
using the primary template or one of the partial specializations.
This is done by matching the template arguments of the class template
specialization with the template argument lists of the partial
specializations.

\begin{itemize}
\item
If exactly one matching specialization is found, the instantiation is
generated from that specialization.
\item
If more than one matching specialization is found,
the partial order rules~(\ref{temp.class.order}) are used to determine
whether one of the specializations is more specialized than the
others.
If none of the specializations is more specialized than all of the
other matching specializations, then the use of the class template
is ambiguous and the program is ill-formed.
\item
If no matches are found, the instantiation is generated from the
primary template.
\end{itemize}

\pnum
A partial specialization matches a given actual template argument
list if the template arguments of the partial specialization can be
deduced from the actual template argument list~(\ref{temp.deduct}).
\enterexample

\begin{codeblock}
A<int, int, 1>   a1;            // uses \#1
A<int, int*, 1>  a2;            // uses \#2, \tcode{T} is \tcode{int}, \tcode{I} is \tcode{1}
A<int, char*, 5> a3;            // uses \#4, \tcode{T} is \tcode{char}
A<int, char*, 1> a4;            // uses \#5, \tcode{T1} is \tcode{int}, \tcode{T2} is \tcode{char}, \tcode{I} is \tcode{1}
A<int*, int*, 2> a5;            // ambiguous: matches \#3 and \#5
\end{codeblock}
\exitexample

\pnum
A non-type template argument can also be deduced from the value of an actual
template argument of a non-type parameter of the primary template.
\enterexample
the declaration of
\tcode{a2}
above.
\exitexample

\pnum
In a type name that refers to a class template specialization, (e.g.,
\tcode{A<int, int, 1>})
the argument list shall match the template parameter list of the primary
template.
The template arguments of a specialization are deduced from the arguments
of the primary template.

\rSec3[temp.class.order]{Partial ordering of class template specializations}

\pnum
For two class template partial specializations,
the first is at least as specialized as the second if, given the following
rewrite to two function templates, the first function template is at least
as specialized as the second according to the ordering rules for function
templates~(\ref{temp.func.order}):

\begin{itemize}
\item
the first function template has the same template parameters as
the first partial specialization and has a single function parameter
whose type is a class template specialization with the template arguments of
the first partial specialization, and
\item
the second function template has the same template parameters as
the second partial specialization and has a single function parameter
whose type is a class template specialization with the template arguments of
the second partial specialization.
\end{itemize}

\pnum
\enterexample
\begin{codeblock}
template<int I, int J, class T> class X { };
template<int I, int J>          class X<I, J, int> { }; // \#1
template<int I>                 class X<I, I, int> { }; // \#2

template<int I, int J> void f(X<I, J, int>);            // A
template<int I>        void f(X<I, I, int>);            // B
\end{codeblock}

The partial specialization
\tcode{\#2}
is more specialized than the partial specialization
\tcode{\#1}
because the function template
\tcode{B}
is more specialized than the function template
\tcode{A}
according to the ordering rules for function templates.
\exitexample

\rSec3[temp.class.spec.mfunc]{Members of class template specializations}

\pnum
The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.
A class template specialization is a distinct template.
The members of the class template partial specialization are
unrelated to the members of the primary template.
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class
template partial specialization.
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.
\enterexample

\begin{codeblock}
// primary template
template<class T, int I> struct A {
  void f();
};

template<class T, int I> void A<T,I>::f() { }

// class template partial specialization
template<class T> struct A<T,2> {
  void f();
  void g();
  void h();
};

// member of class template partial specialization
template<class T> void A<T,2>::g() { }

// explicit specialization
template<> void A<char,2>::h() { }

int main() {
  A<char,0> a0;
  A<char,2> a2;
  a0.f();                       // OK, uses definition of primary template's member
  a2.g();                       // OK, uses definition of
                                // partial specialization's member
  a2.h();                       // OK, uses definition of
                                // explicit specialization's member
  a2.f();                       // ill-formed, no definition of \tcode{f} for \tcode{A<T,2>}
                                // the primary template is not used here
}
\end{codeblock}
\exitexample

\pnum
If a member template of a class template is partially specialized,
the member template partial specializations are member templates of
the enclosing class template;
if the enclosing class template is instantiated~(\ref{temp.inst}, \ref{temp.explicit}),
a declaration for every member template partial specialization is also
instantiated as part of creating the members of the class template
specialization.
If the primary member template is explicitly specialized for a given
(implicit) specialization of the enclosing class template,
the partial specializations of the member template are ignored for this
specialization of the enclosing class template.
If a partial specialization of the member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are
still considered for this specialization of the enclosing class template.
\enterexample

\begin{codeblock}
template<class T> struct A {
  template<class T2> struct B {};                     // \#1
  template<class T2> struct B<T2*> {};                // \#2
};

template<> template<class T2> struct A<short>::B {};  // \#3

A<char>::B<int*>  abcip;  // uses \#2
A<short>::B<int*> absip;  // uses \#3
A<char>::B<int>  abci;    // uses \#1
\end{codeblock}
\exitexample

\rSec2[temp.fct]{Function templates}

\pnum
A function template defines an unbounded set of related functions.
\enterexample
a family of sort functions might be declared like this:

\begin{codeblock}
template<class T> class Array { };
template<class T> void sort(Array<T>&);
\end{codeblock}
\exitexample

\pnum
A function template can be overloaded with other function templates
and with non-template functions~(\ref{dcl.fct}).
A non-template function is not
related to a function template
(i.e., it is never considered to be a specialization),
even if it has the same name and type
as a potentially generated function template specialization.\footnote{That is,
declarations of non-template functions do not merely guide
overload resolution of
function template specializations
with the same name.
If such a non-template function is odr-used~(\ref{basic.def.odr}) in a program, it must be defined;
it will not be implicitly instantiated using the function template definition.}

\rSec3[temp.over.link]{Function template overloading}

\pnum
\indextext{overloading}%
It is possible to overload function templates so that two different
function template specializations have the same type.
\enterexample

\begin{minipage}{.45\hsize}
\begin{codeblock}
// file1.c
template<class T>
  void f(T*);
void g(int* p) {
  f(p); // calls \tcode{f<int>(int*)}
}
\end{codeblock}
\end{minipage}
\begin{minipage}{.45\hsize}
\begin{codeblock}
// file2.c
template<class T>
  void f(T);
void h(int* p) {
  f(p); // calls \tcode{f<int*>(int*)}
}
\end{codeblock}
\end{minipage}

\exitexample

\pnum
Such specializations are distinct functions and do not violate the one
definition rule~(\ref{basic.def.odr}).

\pnum
The signature of a function template
is defined in~\ref{intro.defs}.
The names of the template parameters are significant only for establishing
the relationship between the template parameters and the rest of the
signature.
\enternote
Two distinct function templates may have identical function return types and
function parameter lists, even if overload resolution alone cannot distinguish
them.

\begin{codeblock}
template<class T> void f();
template<int I> void f();       // OK: overloads the first template
                                // distinguishable with an explicit template argument list
\end{codeblock}
\exitnote

\pnum
When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template.
This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another.
\enterexample

\begin{codeblock}
template <int I, int J> A<I+J> f(A<I>, A<J>);   // \#1
template <int K, int L> A<K+L> f(A<K>, A<L>);   // same as \#1
template <int I, int J> A<I-J> f(A<I>, A<J>);   // different from \#1
\end{codeblock}
\exitexample
\enternote
Most expressions that use template parameters use non-type template
parameters, but it is possible for an expression to reference a type
parameter.
For example, a template type parameter can be used in the
\tcode{sizeof} operator.
\exitnote

\pnum
Two expressions involving template parameters are considered
\term{equivalent}
if two function definitions containing the expressions would satisfy
the one definition rule~(\ref{basic.def.odr}), except that the tokens used
to name the template parameters may differ as long as a token used to
name a template parameter in one expression is replaced by another token
that names the same template parameter in the other expression. For
determining whether two dependent names (\ref{temp.dep}) are
equivalent, only the name itself is considered, not the result of name
lookup in the context of the template. If multiple declarations of the
same function template differ in the result of this name lookup, the
result for the first declaration is used.
\enterexample

\begin{codeblock}
template <int I, int J> void f(A<I+J>);         // \#1
template <int K, int L> void f(A<K+L>);         // same as \#1

template <class T> decltype(g(T())) h();
int g(int);
template <class T> decltype(g(T())) h()         // redeclaration of \tcode{h()} uses the earlier lookup
  { return g(T()); }                            // ...although the lookup here does find \tcode{g(int)}
int i = h<int>();                               // template argument substitution fails; \tcode{g(int)}
                                                // was not in scope at the first declaration of \tcode{h()}
\end{codeblock}
\exitexample
Two expressions involving template parameters that are not equivalent are
\term{functionally equivalent}
if, for any given set of template arguments, the evaluation of the
expression results in the same value.

\pnum
Two function templates are
\term{equivalent}
if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter
lists that are equivalent using the rules described above to compare
expressions involving
template parameters.
Two function templates are
\term{functionally equivalent}
if they are equivalent except that one or more
expressions
that involve template parameters in the return types and parameter
lists are functionally equivalent using the rules described above to
compare expressions involving
template parameters.
If a program contains declarations of function templates that are
functionally equivalent but not equivalent, the program is ill-formed;
no diagnostic is required.

\pnum
\enternote
This rule guarantees that equivalent declarations will be linked with
one another, while not requiring implementations to use heroic efforts
to guarantee that functionally equivalent declarations will be treated
as distinct.
For example, the last two declarations are functionally
equivalent and would cause a program to be ill-formed:

\begin{codeblock}
// Guaranteed to be the same
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+10>);

// Guaranteed to be different
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+11>);

// Ill-formed, no diagnostic required
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);
\end{codeblock}
\exitnote

\rSec3[temp.func.order]{Partial ordering of function templates}

\pnum
\indextext{overloading!resolution!template}%
\indextext{ordering!function template partial}%
If a function template is overloaded,
the use of a function template specialization might be ambiguous because
template argument deduction~(\ref{temp.deduct}) may associate the function
template specialization with more than one function template declaration.
\term{Partial ordering}
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:

\begin{itemize}
\item
during overload resolution for a call to a function template specialization~(\ref{over.match.best});
\item
when the address of a function template specialization is taken;
\item
when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new~(\ref{basic.stc.dynamic.deallocation}, \ref{expr.new});
\item
when a friend function declaration~(\ref{temp.friend}), an
explicit instantiation~(\ref{temp.explicit}) or an explicit specialization~(\ref{temp.expl.spec}) refers to
a function template specialization.
\end{itemize}

\pnum
Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type.
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.

\pnum
To produce the transformed template, for each type, non-type, or template
template parameter (including template parameter packs~(\ref{temp.variadic})
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template.
If only one of the function templates is a non-static member of some
class \tcode{A}, that function
template is considered to have a new first parameter inserted in its function
parameter list. Given \cv{} as the cv-qualifiers of the function
template (if any), the new parameter is of type ``rvalue reference to
\cv{} \tcode{A}'' if the optional \grammarterm{ref-qualifier} of the
function template is \tcode{\&\&}, or of type ``lvalue reference to
\cv{} \tcode{A}'' otherwise. \enternote This allows a non-static
member to be ordered with respect to a nonmember function and for the results
to be equivalent to the ordering of two equivalent nonmembers. \exitnote
\enterexample
\begin{codeblock}
struct A { };
template<class T> struct B {
  template<class R> int operator*(R&);              // \#1
};

template<class T, class R> int operator*(T&, R&);   // \#2

// The declaration of \tcode{B::operator*} is transformed into the equivalent of
// \tcode{template<class R> int operator*(B<A>\&, R\&);}\quad\quad\quad// \#1a

int main() {
  A a;
  B<A> b;
  b * a;                                            // calls \#1a
}
\end{codeblock}
\exitexample

\pnum
Using the transformed function template's function type,
perform type deduction against the other template as described in~\ref{temp.deduct.partial}.

\enterexample

\begin{codeblock}
template<class T> struct A { A(); };

template<class T> void f(T);
template<class T> void f(T*);
template<class T> void f(const T*);

template<class T> void g(T);
template<class T> void g(T&);

template<class T> void h(const T&);
template<class T> void h(A<T>&);

void m() {
  const int* p;
  f(p);             // \tcode{f(const T*)} is more specialized than \tcode{f(T)} or \tcode{f(T*)}
  float x;
  g(x);             // Ambiguous: \tcode{g(T)} or \tcode{g(T\&)}
  A<int> z;
  h(z);             // overload resolution selects \tcode{h(A<T>\&)}
  const A<int> z2;
  h(z2);            // \tcode{h(const T\&)} is called because \tcode{h(A<T>\&)} is not callable
}
\end{codeblock}
\exitexample

\pnum
\enternote Since partial ordering in a call context considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters).
\enterexample

\begin{codeblock}
template<class T> void f(T);            // \#1
template<class T> void f(T*, int=1);    // \#2
template<class T> void g(T);            // \#3
template<class T> void g(T*, ...);      // \#4

\end{codeblock}
\begin{codeblock}
int main() {
  int* ip;
  f(ip);            // calls \#2
  g(ip);            // calls \#4
}
\end{codeblock}
\exitexample\enterexample
\begin{codeblock}
template<class T, class U> struct A { };

template<class T, class U> void f(U, A<U, T>* p = 0); // \#1
template<         class U> void f(U, A<U, U>* p = 0); // \#2
template<class T         > void g(T, T = T());        // \#3
template<class T, class... U> void g(T, U ...);       // \#4

void h() {
  f<int>(42, (A<int, int>*)0);                        // calls \#2
  f<int>(42);                                         // error: ambiguous
  g(42);                                              // error: ambiguous
}
\end{codeblock}
\exitexample\enterexample
\begin{codeblock}
template<class T, class... U> void f(T, U...);        // \#1
template<class T            > void f(T);              // \#2
template<class T, class... U> void g(T*, U...);       // \#3
template<class T            > void g(T);              // \#4

void h(int i) {
  f(&i);                                              // error: ambiguous
  g(&i);                                              // OK: calls \#3
}
\end{codeblock}
\exitexample\exitnote

\rSec2[temp.alias]{Alias templates}

\pnum
A \grammarterm{template-declaration} in which the \grammarterm{declaration} is an
\grammarterm{alias-declaration} (Clause~\ref{dcl.dcl}) declares the
\grammarterm{identifier} to be a \defn{alias template}.
An alias template is a name for a family of
types. The name of the alias template is a \grammarterm{template-name}.

\pnum
When a \grammarterm{template-id} refers to the specialization of
an alias template, it is equivalent to the associated type obtained by
substitution of its \grammarterm{template-argument}{s} for the
\grammarterm{template-parameter}{s} in the \grammarterm{type-id} of
the alias template.
\enternote An alias template name is never deduced.\exitnote
\enterexample

\begin{codeblock}
template<class T> struct Alloc { /* ... */ };
template<class T> using Vec = vector<T, Alloc<T>>;
Vec<int> v;         // same as \tcode{vector<int, Alloc<int>{>} v;}

template<class T>
  void process(Vec<T>& v)
  { /* ... */ }

template<class T>
  void process(vector<T, Alloc<T>>& w)
  { /* ... */ }     // error: redefinition

template<template<class> class TT>
  void f(TT<int>);

f(v);               // error: \tcode{Vec} not deduced

template<template<class,class> class TT>
  void g(TT<int, Alloc<int>>);
g(v);               // OK: \tcode{TT} = \tcode{vector}
\end{codeblock}

\exitexample

\pnum
The \grammarterm{type-id} in an alias template declaration shall not refer to
the alias template being declared. The type produced by an alias template
specialization shall not directly or indirectly make use of that specialization.
\enterexample

\begin{codeblock}
template <class T> struct A;
template <class T> using B = typename A<T>::U;
template <class T> struct A {
  typedef B<T> U;
};
B<short> b;         // error: instantiation of \tcode{B<short>} uses own type via \tcode{A<short>::U}
\end{codeblock}
\exitexample

\rSec1[temp.res]{Name resolution}

\pnum
\indextext{overloading!resolution!template name}%
\indextext{lookup!template name}%
Three kinds of names can be used within a template definition:

\begin{itemize}
\item
The name of the template itself,
and names declared within the template itself.
\item
Names dependent on a
\grammarterm{template-parameter}~(\ref{temp.dep}).
\item
Names from scopes which are visible within the template definition.
\end{itemize}

\pnum
A name used in a template declaration or definition and that is
dependent on a
\grammarterm{template-parameter}
is assumed not to name a type unless
the applicable name lookup finds a type name or the name
is qualified by the keyword
\tcode{typename}.
\enterexample

\begin{codeblock}
// no \tcode{B} declared here

class X;

template<class T> class Y {
  class Z;                      // forward declaration of member class

  void f() {
    X* a1;                      // declare pointer to \tcode{X}
    T* a2;                      // declare pointer to \tcode{T}
    Y* a3;                      // declare pointer to \tcode{Y<T>}
    Z* a4;                      // declare pointer to \tcode{Z}
    typedef typename T::A TA;
    TA* a5;                     // declare pointer to \tcode{T}'s \tcode{A}
    typename T::A* a6;          // declare pointer to \tcode{T}'s \tcode{A}
    T::A* a7;                   // \tcode{T::A} is not a type name:
                                // multiply \tcode{T::A} by \tcode{a7}; ill-formed,
                                // no visible declaration of \tcode{a7}
    B* a8;                      // \tcode{B} is not a type name:
                                // multiply \tcode{B} by \tcode{a8}; ill-formed,
                                // no visible declarations of \tcode{B} and \tcode{a8}
  }
};
\end{codeblock}
\exitexample

\pnum
When a \nonterminal{qualified-id} is intended to refer to a type
that is not a member of the current instantiation~(\ref{temp.dep.type})
and its \nonterminal{nested-name-specifier}
refers to a dependent type,
it shall be
prefixed by the keyword \tcode{typename}, forming a
\nonterminal{typename-specifier}.
If the \grammarterm{qualified-id} in a \grammarterm{typename-specifier}
does not denote a type, the program is ill-formed.

\begin{bnf}
\nontermdef{typename-specifier}\br
  \terminal{typename} nested-name-specifier identifier\br
  \terminal{typename} nested-name-specifier \terminal{template\opt} simple-template-id
\end{bnf}

\pnum
If a specialization of a template is instantiated for a set of
\grammarterm{template-argument}{s}
such that the
\grammarterm{qualified-id}
prefixed by
\tcode{typename}
does not denote a type, the specialization is ill-formed.
The usual qualified name lookup~(\ref{basic.lookup.qual}) is used to find the
\grammarterm{qualified-id}
even in the presence of
\tcode{typename}.
\enterexample

\begin{codeblock}
struct A {
  struct X { };
  int X;
};
struct B {
  struct X { };
};
template<class T> void f(T t) {
  typename T::X x;
}
void foo() {
  A a;
  B b;
  f(b);             // OK: \tcode{T::X} refers to \tcode{B::X}
  f(a);             // error: \tcode{T::X} refers to the data member \tcode{A::X} not the struct \tcode{A::X}
}
\end{codeblock}
\exitexample

\pnum
A qualified name used as the name in a
\grammarterm{mem-initializer-id},
a
\grammarterm{base-specifier},
or an
\grammarterm{elaborated-type-specifier}
is implicitly assumed to name a type, without the use of the
\tcode{typename}
keyword.
In a \grammarterm{nested-name-specifier} that immediately contains a \grammarterm{nested-name-specifier}
that depends on a template parameter, the \grammarterm{identifier} or \grammarterm{simple-template-id}
is implicitly assumed to name a type, without the use of the \tcode{typename} keyword.
\enternote
The
\tcode{typename}
keyword is not permitted by the syntax of these constructs.
\exitnote

\pnum
If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a \grammarterm{qualified-id} that denotes a type,
and the
\grammarterm{qualified-id} refers to a member of an unknown specialization,
the \grammarterm{qualified-id} shall either be
prefixed by \tcode{typename} or shall be used in a context in which it
implicitly names a type as described above. \enterexample

\begin{codeblock}
template <class T> void f(int i) {
  T::x * i;         // \tcode{T::x} must not be a type
}

struct Foo {
  typedef int x;
};

struct Bar {
  static int const x = 5;
};

int main() {
  f<Bar>(1);        // OK
  f<Foo>(1);        // error: \tcode{Foo::x} is a type
}
\end{codeblock}
\exitexample

\pnum
Within the definition of a class template or within the definition of a
member of a class template following the \grammarterm{declarator-id}, the keyword
\tcode{typename}
is not required when referring to the name of a previously
declared member of the class template that declares a type.
\enternote such names can be found using unqualified name lookup~(\ref{basic.lookup.unqual}),
class member lookup~(\ref{class.qual}) into the current instantiation~(\ref{temp.dep.type}),
or class member access expression lookup~(\ref{basic.lookup.classref}) when the
type of the object expression is the current instantiation~(\ref{temp.dep.expr}).
\exitnote
\enterexample

\begin{codeblock}
template<class T> struct A {
  typedef int B;
  B b;              // OK, no typename required
};
\end{codeblock}
\exitexample

\pnum
\indextext{checking!syntax}%
\indextext{checking!point~of error}%
Knowing which names are type names allows the syntax of every template
to be checked.
No diagnostic shall be issued for a template
for which a valid specialization can be generated.
If no valid specialization can be generated
for a template,
and that template is not instantiated, the template is ill-formed,
no diagnostic required.
If every valid specialization of a variadic template requires an empty template
parameter pack, the template is ill-formed, no diagnostic required.
If a type used in a non-dependent name is incomplete
at the point at which a template is defined but is
complete at the point at which an instantiation is done,
and if the completeness of that type affects whether or
not the program is well-formed or affects the semantics
of the program, the program is ill-formed; no diagnostic
is required.
\enternote
If a template is instantiated, errors will be diagnosed according
to the other rules in this Standard.
Exactly when these errors are diagnosed is a quality of implementation issue.
\exitnote
\enterexample

\begin{codeblock}
int j;
template<class T> class X {
  void f(T t, int i, char* p) {
    t = i;          // diagnosed if \tcode{X::f} is instantiated
                    // and the assignment to \tcode{t} is an error
    p = i;          // may be diagnosed even if \tcode{X::f} is
                    // not instantiated
    p = j;          // may be diagnosed even if \tcode{X::f} is
                    // not instantiated
  }
  void g(T t) {
    +;              // may be diagnosed even if \tcode{X::g} is
                    // not instantiated
  }
};

template<class... T> struct A {
  void operator++(int, T... t);                 // error: too many parameters
};
template<class... T> union X : T... { };        // error: union with base class
template<class... T> struct A : T...,  T... { };// error: duplicate base class
\end{codeblock}
\exitexample

\pnum
When looking for the declaration of a name used in a template definition,
the usual lookup rules~(\ref{basic.lookup.unqual}, \ref{basic.lookup.argdep})
are used for non-dependent names.
The lookup of names dependent on the template parameters
is postponed until the actual template argument is known~(\ref{temp.dep}).
\enterexample

\begin{codeblock}
#include <iostream>
using namespace std;

template<class T> class Set {
  T* p;
  int cnt;
public:
  Set();
  Set<T>(const Set<T>&);
  void printall() {
    for (int i = 0; i<cnt; i++)
      cout << p[i] << '@\textbackslash@n';
  }
};
\end{codeblock}

in the example,
\tcode{i}
is the local variable
\tcode{i}
declared in
\tcode{printall},
\tcode{cnt}
is the member
\tcode{cnt}
declared in
\tcode{Set},
and
\tcode{cout}
is the standard output stream declared in
\tcode{iostream}.
However, not every declaration can be found this way; the resolution of
some names must be postponed
until the actual
\grammarterm{template-argument}{s}
are known.
For example, even though the name
\tcode{operator\shl}
is known within the definition of
\tcode{printall()}
and a declaration of it can be found in
\tcode{<iostream>},
the actual declaration of
\tcode{operator\shl}
needed to print
\tcode{p[i]}
cannot be known until it is known what type
\tcode{T}
is~(\ref{temp.dep}).
\exitexample

\pnum
If a name does not depend on a
\grammarterm{template-parameter}
(as defined in~\ref{temp.dep}), a declaration (or set of declarations) for that
name shall be in scope at the point where the name appears in the template
definition; the name is bound to the declaration (or declarations) found
at that point and this binding is not affected by declarations that are
visible at the point of instantiation.
\enterexample

\begin{codeblock}
void f(char);

template<class T> void g(T t) {
  f(1);             // \tcode{f(char)}
  f(T(1));          // dependent
  f(t);             // dependent
  dd++;             // not dependent
                    // error: declaration for dd not found
}

enum E { e };
void f(E);

double dd;
void h() {
  g(e);             // will cause one call of \tcode{f(char)} followed
                    // by two calls of \tcode{f(E)}
  g('a');           // will cause three calls of \tcode{f(char)}
}
\end{codeblock}
\exitexample

\pnum
\enternote
For purposes of name lookup, default arguments and
\grammarterm{exception-specification}{s} of function templates and default
arguments and \grammarterm{exception-specification}{s} of
member functions of class templates are considered definitions~(\ref{temp.decls}).
\exitnote

\rSec2[temp.local]{Locally declared names}

\pnum
Like normal (non-template) classes, class templates have an
injected-class-name (Clause~\ref{class}).
The
injected-class-name can be used
as a \grammarterm{template-name} or a \grammarterm{type-name}.
When it is used with a
\grammarterm{template-argument-list},
as a \grammarterm{template-argument} for a template \grammarterm{template-parameter},
or as the final identifier in the \grammarterm{elaborated-type-specifier} of
a friend class template declaration,
it refers to the
class template itself. Otherwise, it is equivalent to the \grammarterm{template-name}
followed by the \grammarterm{template-parameter}{s} of the class template
enclosed in \tcode{<>}.

\pnum
Within the scope of a class template specialization or
partial specialization, when the injected-class-name is
used as a \grammarterm{type-name},
it is equivalent to the \grammarterm{template-name} followed by the
\grammarterm{template-argument}{s}
of the class template specialization or partial
specialization enclosed in
\tcode{<>}.
\enterexample
\begin{codeblock}
template<template<class> class T> class A { };
template<class T> class Y;
template<> class Y<int> {
  Y* p;                               // meaning \tcode{Y<int>}
  Y<char>* q;                         // meaning \tcode{Y<char>}
  A<Y>* a;                            // meaning \tcode{A<::Y>}
  class B {
    template<class> friend class Y;   // meaning \tcode{::Y}
  };
};
\end{codeblock}
\exitexample

\pnum
The injected-class-name of a class template or class
template specialization can be used either
as a \grammarterm{template-name} or a \grammarterm{type-name}
wherever it is in scope.
\enterexample

\begin{codeblock}
template <class T> struct Base {
  Base* p;
};

template <class T> struct Derived: public Base<T> {
  typename Derived::Base* p;    // meaning \tcode{Derived::Base<T>}
};

template<class T, template<class> class U = T::template Base> struct Third { };
Third<Base<int> > t;            // OK: default argument uses injected-class-name as a template
\end{codeblock}
\exitexample

\pnum
A lookup that finds an injected-class-name~(\ref{class.member.lookup}) can result in an ambiguity in
certain cases (for example, if it is found in more than one
base class).
If all of the injected-class-names that are
found refer to specializations of the same class template,
and if the name
is used as a \grammarterm{template-name},
the reference refers to the class template itself and not a
specialization thereof, and is not ambiguous.
\enterexample

\begin{codeblock}
template <class T> struct Base { };
template <class T> struct Derived: Base<int>, Base<char> {
  typename Derived::Base b;             // error: ambiguous
  typename Derived::Base<double> d;     // OK
};
\end{codeblock}
\exitexample

\pnum
When the normal name of the template (i.e., the name from
the enclosing scope, not the injected-class-name) is
used,
it always refers to the class template itself and not a
specialization of the template.
\enterexample

\begin{codeblock}
template<class T> class X {
  X* p;             // meaning \tcode{X<T>}
  X<T>* p2;
  X<int>* p3;
  ::X* p4;          // error: missing template argument list
                    // \tcode{::X} does not refer to the injected-class-name
};
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{template-parameter}
shall not be redeclared within its scope (including nested scopes).
A
\grammarterm{template-parameter}
shall not have the same name as the template name.
\enterexample

\begin{codeblock}
template<class T, int i> class Y {
  int T;            // error: template-parameter redeclared
  void f() {
    char T;         // error: template-parameter redeclared
  }
};

template<class X> class X;      // error: template-parameter redeclared
\end{codeblock}
\exitexample

\pnum
In the definition of a member of
a class template that appears outside of the class template definition,
the name of a member of the class template hides the name of a
\grammarterm{template-parameter}
of any enclosing class templates (but not a \grammarterm{template-parameter} of the
member if the member is a class or function template).
\enterexample

\begin{codeblock}
template<class T> struct A {
  struct B @\texttt{\{ /* ... */ \};}@
  typedef void C;
  void f();
  template<class U> void g(U);
};

template<class B> void A<B>::f() {
  B b;              // \tcode{A}'s \tcode{B}, not the template parameter
}

template<class B> template<class C> void A<B>::g(C) {
  B b;              // \tcode{A}'s \tcode{B}, not the template parameter
  C c;              // the template parameter \tcode{C}, not \tcode{A}'s \tcode{C}
}
\end{codeblock}
\exitexample

\pnum
In the definition of a member of a class template that appears outside of the
namespace containing the class template definition,
the name of a
\grammarterm{template-parameter}
hides the name of a member of this namespace.
\enterexample

\begin{codeblock}
namespace N {
  class C { };
  template<class T> class B {
    void f(T);
  };
}
template<class C> void N::B<C>::f(C) {
  C b;              // \tcode{C} is the template parameter, not \tcode{N::C}
}
\end{codeblock}
\exitexample

\pnum
In the definition of a class template or in the definition of a member of such
a template that appears outside of the template definition,
for each base class which does not depend on a
\grammarterm{template-parameter}~(\ref{temp.dep}), if the name of the base class
or the name of a member of the
base class is the same as the name of a
\grammarterm{template-parameter},
the base class name or member name hides the
\grammarterm{template-parameter}
name~(\ref{basic.scope.hiding}).
\enterexample

\begin{codeblock}
struct A {
  struct B { /* ... */ };
  int a;
  int Y;
};

template<class B, class a> struct X : A {
  B b;              // \tcode{A}'s \tcode{B}
  a b;              // error: \tcode{A}'s \tcode{a} isn't a type name
};
\end{codeblock}
\exitexample

\rSec2[temp.dep]{Dependent names}

\pnum
\indextext{name!dependent}%
Inside a template, some constructs have semantics which may differ from one
instantiation to another.
Such a construct
\term{depends}
on the template parameters.
In particular, types and expressions may depend on the type
and/or
value of
template parameters (as determined by the template arguments) and this determines
the context for name lookup for certain names.
Expressions may be
\grammarterm{type-dependent}
(on the type of a template parameter) or
\grammarterm{value-dependent}
(on the value of a non-type template parameter).
In an expression of the form:

\begin{ncbnftab}
postfix-expression \terminal{(} expression-list\opt \terminal{)}
\end{ncbnftab}

where the
\grammarterm{postfix-expression}
is an
\grammarterm{unqualified-id},
the
\grammarterm{unqualified-id}
denotes a
\indextext{name!dependent}%
\term{dependent name}
if

\begin{itemize}
\item 
any of the expressions in the \grammarterm{expression-list} is a pack
expansion~(\ref{temp.variadic}),

\item
any of the expressions in the
\grammarterm{expression-list}
is a type-dependent expression~(\ref{temp.dep.expr}), or

\item
if the \grammarterm{unqualified-id}
is a \grammarterm{template-id} in which any of the template arguments depends
on a template parameter.
\end{itemize}

If an operand of an operator is a type-dependent expression, the operator
also denotes a dependent name.
Such names are unbound and
are looked up at the point of the template instantiation~(\ref{temp.point}) in
both the context of the template definition and the
context of the point of instantiation.

\pnum
\enterexample
\begin{codeblock}
template<class T> struct X : B<T> {
  typename T::A* pa;
  void f(B<T>* pb) {
    static int i = B<T>::i;
    pb->j++;
  }
};
\end{codeblock}

the base class name
\tcode{B<T>},
the type name
\tcode{T::A},
the names
\tcode{B<T>::i}
and
\tcode{pb->j}
explicitly depend on the
\grammarterm{template-parameter}.
\exitexample

\pnum
In the definition of a class or class template, if a base class
depends on a
\grammarterm{template-parameter},
the base class scope is not examined during unqualified
name lookup either at the point of definition of the
class template or member or during an instantiation of
the class template or member.
\enterexample

\begin{codeblock}
typedef double A;
template<class T> class B {
  typedef int A;
};
template<class T> struct X : B<T> {
  A a;              // \tcode{a} has type \tcode{double}
};
\end{codeblock}

The type name
\tcode{A}
in the definition of
\tcode{X<T>}
binds to the typedef name defined in the global
namespace scope, not to the typedef name
defined in the base class
\tcode{B<T>}.
\exitexample
\enterexample

\begin{codeblock}
struct A {
  struct B { /* ... */ };
  int a;
  int Y;
};

int a;

template<class T> struct Y : T {
  struct B { /* ... */ };
  B b;                          // The \tcode{B} defined in \tcode{Y}
  void f(int i) { a = i; }      // \tcode{::a}
  Y* p;                         // \tcode{Y<T>}
};

Y<A> ya;
\end{codeblock}

The members
\tcode{A::B},
\tcode{A::a},
and
\tcode{A::Y}
of the template argument
\tcode{A}
do not affect the binding of names in
\tcode{Y<A>}.
\exitexample

\rSec3[temp.dep.type]{Dependent types}

\pnum
A name refers to the
\term{current instantiation}
if it is

\begin{itemize}
\item
in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause~\ref{class}) of the class template or nested class,
\item
in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
\tcode{<>} (or an equivalent template alias specialization),
\item
in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
\item
in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
\tcode{<>} (or an equivalent template alias specialization).
If the \textit{n}th template parameter is
a parameter pack, the \textit{n}th template argument is a pack
expansion~(\ref{temp.variadic}) whose pattern is the name of
the parameter pack.
\end{itemize}

\pnum
The template argument list of a primary template is a
template argument list in which the
\textit{n}th
template argument has the value of the
\textit{n}th
template parameter of the class template.
If the \textit{n}th template parameter is a template
parameter pack~(\ref{temp.variadic}), the \textit{n}th template argument is a pack
expansion~(\ref{temp.variadic}) whose pattern is the name of
the template parameter pack.

\pnum
A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
\enterexample
\begin{codeblock}
template <class T> class A {
  A* p1;                        // \tcode{A} is the current instantiation
  A<T>* p2;                     // \tcode{A<T>} is the current instantiation
  A<T*> p3;                     // \tcode{A<T*>} is not the current instantiation
  ::A<T>* p4;                   // \tcode{::A<T>} is the current instantiation
  class B {
    B* p1;                      // \tcode{B} is the current instantiation
    A<T>::B* p2;                // \tcode{A<T>::B} is the current instantiation
    typename A<T*>::B* p3;      // \tcode{A<T*>::B} is not the
                                // current instantiation
  };
};

template <class T> class A<T*> {
  A<T*>* p1;                    // \tcode{A<T*>} is the current instantiation
  A<T>* p2;                     // \tcode{A<T>} is not the current instantiation
};

template <class T1, class T2, int I> struct B {
  B<T1, T2, I>* b1;             // refers to the current instantiation
  B<T2, T1, I>* b2;             // not the current instantiation
  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B<my_T1, T2, my_I>* b3;       // refers to the current instantiation
  B<my_T1, T2, my_I2>* b4;      // not the current instantiation
  B<my_T1, T2, my_I3>* b5;      // refers to the current instantiation
};
\end{codeblock}
\exitexample

\pnum
\indextext{instantiation!member of the current}%
A name is a
\term{member of the current instantiation}
if it is

\begin{itemize}
\item
An unqualified name that, when looked up, refers to
at least one member of a class that is
the current instantiation or a non-dependent base class thereof.
\enternote
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
\exitnote
\item
A
\grammarterm{qualified-id}
in which the
\grammarterm{nested-name-specifier}
refers to the current instantiation
and that, when looked up, refers to at least one member of a class that is
the current
instantiation or a non-dependent base class thereof. \enternote if no such
member is found, and the current instantiation has any dependent base classes,
then the \grammarterm{qualified-id} is a member of an unknown specialization;
see below. \exitnote

\item
An \grammarterm{id-expression} denoting the member in a class member access
expression~(\ref{expr.ref}) for which the type of the object expression is the
current instantiation, and the \grammarterm{id-expression}, when looked
up~(\ref{basic.lookup.classref}), refers to at least one member of a class
that is the current
instantiation or a non-dependent base class thereof. \enternote if no such
member is found, and the current instantiation has any dependent base classes,
then the \grammarterm{id-expression} is a member of an unknown specialization;
see below. \exitnote
\end{itemize}

\enterexample
\begin{codeblock}
template <class T> class A {
  static const int i = 5;
  int n1[i];        // \tcode{i} refers to a member of the current instantiation
  int n2[A::i];     // \tcode{A::i} refers to a member of the current instantiation
  int n3[A<T>::i];  // \tcode{A<T>::i} refers to a member of the current instantiation
  int f();
};

template <class T> int A<T>::f() {
  return i;         // \tcode{i} refers to a member of the current instantiation
}
\end{codeblock}
\exitexample

\indextext{instantiation!dependent member of the current}%
A name is a \term{dependent member of the current instantiation} if it is a
member of the current instantiation that, when looked up, refers to at least
one member of a class that is the current instantiation.

\pnum
A name is a
\term{member of an unknown specialization}
if it is

\begin{itemize}
\item 
A
\grammarterm{qualified-id}
in which the
\grammarterm{nested-name-specifier}
names a dependent type that is not the current instantiation.

\item A \grammarterm{qualified-id} in which the \grammarterm{nested-name-specifier}
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the \grammarterm{qualified-id} does not
find any member of a class that is the current instantiation or a non-dependent
base class thereof.

\item An \grammarterm{id-expression} denoting the member in a class member access
expression~(\ref{expr.ref}) in which either
\begin{itemize}
\item the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the \grammarterm{id-expression} does not find a member of a class that is
the current instantiation or a non-dependent base class thereof; or

\item the type of the object expression is dependent and is not the current
instantiation.
\end{itemize}
\end{itemize}

\pnum
If a \grammarterm{qualified-id} in which the \grammarterm{nested-name-specifier}
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the \grammarterm{qualified-id} is not instantiated; no
diagnostic required. Similarly, if the \grammarterm{id-expression} in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. \enterexample
\begin{codeblock}
template<class T> class A {
  typedef int type;
  void f() {
    A<T>::type i;           // OK: refers to a member of the current instantiation
    typename A<T>::other j; // error: neither a member of the current instantiation nor
                            // a member of an unknown specialization
  }
};
\end{codeblock}
\exitexample

\pnum
If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
\grammarterm{qualified-id} or class member access expression, the name in the
\grammarterm{qualified-id} or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous. \enternote the result of name lookup differs only when the member of
the current instantiation was found in a non-dependent base class of the current
instantiation and a member with the same name is also introduced by the
substitution for a dependent base class of the current instantiation. \exitnote

\pnum
A type is dependent if it is
\begin{itemize}
\item
a template parameter,
\item
a member of an unknown specialization,
\item
a nested class or enumeration that is a dependent member of the current
instantiation,
\item
a cv-qualified type where the cv-unqualified type is dependent,
\item
a compound type constructed from any dependent type,
\item
an array type constructed from any dependent type or whose
size is specified by a constant expression that is value-dependent,
\item
a
\grammarterm{simple-template-id}
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent, or
\item denoted by \tcode{decltype(}\grammarterm{expression}{}\tcode{)},
where \grammarterm{expression} is type-dependent~(\ref{temp.dep.expr}).
\end{itemize}

\pnum
\enternote
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
\exitnote

\rSec3[temp.dep.expr]{Type-dependent expressions}

\pnum
Except as described below, an expression is type-dependent if any
subexpression is type-dependent.

\pnum
\tcode{this}
is type-dependent if the class type of the enclosing member function is
dependent~(\ref{temp.dep.type}).

\pnum
An
\grammarterm{id-expression}
is type-dependent if it contains

\begin{itemize}
\item
an
\grammarterm{identifier}
associated by name lookup with one or more declarations
declared with a dependent type,

\item
an \grammarterm{identifier} associated by name lookup with one or more
declarations of member functions of the current instantiation declared
with a return type that contains a placeholder type~(\ref{dcl.spec.auto}),

\item
a
\grammarterm{template-id}
that is dependent,

\item
a
\grammarterm{conversion-function-id}
that specifies a dependent type, or

\item
a
\grammarterm{nested-name-specifier}
or a
\grammarterm{qualified-id}
that names a member of an unknown specialization;
\end{itemize}

or if it names a dependent member of the current instantiation that is a static
data member of type
``array of unknown bound of \tcode{T}'' for some \tcode{T}~(\ref{temp.static}).
Expressions of the following forms are type-dependent only if the type
specified by the
\grammarterm{type-id},
\grammarterm{simple-type-specifier}
or
\grammarterm{new-type-id}
is dependent, even if any subexpression is type-dependent:

\begin{ncbnftab}
simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
\terminal{::\opt new} new-placement\opt new-type-id new-initializer\opt\br
\terminal{::\opt new} new-placement\opt \terminal{(} type-id \terminal{)} new-initializer\opt\br
\terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{(} type-id \terminal{)} cast-expression
\end{ncbnftab}

\pnum
Expressions of the following forms are never type-dependent (because the type
of the expression cannot be dependent):

\begin{ncbnftab}
literal\br
postfix-expression \terminal{.} pseudo-destructor-name\br
postfix-expression \terminal{->} pseudo-destructor-name\br
\terminal{sizeof} unary-expression\br
\terminal{sizeof (} type-id \terminal{)}\br
\terminal{sizeof} \terminal{...} \terminal{(} identifier \terminal{)}\br
\terminal{alignof (} type-id \terminal{)}\br
\terminal{typeid (} expression \terminal{)}\br
\terminal{typeid (} type-id \terminal{)}\br
\terminal{::\opt delete} cast-expression\br
\terminal{::\opt delete [ ]} cast-expression\br
\terminal{throw} assignment-expression\opt\br
\terminal{noexcept} \terminal{(} expression \terminal{)}
\end{ncbnftab}

\enternote For the standard library macro \tcode{offsetof},
see~\ref{support.types}.\exitnote

\pnum
A class member access expression~(\ref{expr.ref}) is
type-dependent if
the expression refers to a member of the current instantiation and
the type of the referenced member is dependent, or the class member access
expression refers to a member of an unknown specialization.
\enternote
In an expression of the form
\tcode{x.y}
or
\tcode{xp->y}
the type of the expression is usually the type of the member
\tcode{y}
of the class of
\tcode{x}
(or the class pointed to by
\tcode{xp}).
However, if
\tcode{x}
or
\tcode{xp}
refers to a dependent type that is not the current instantiation,
the type of
\tcode{y}
is always dependent. If
\tcode{x}
or \tcode{xp}
refers to a non-dependent type or refers to the current instantiation, the
type of
\tcode{y}
is the type of the class member access expression.
\exitnote

\rSec3[temp.dep.constexpr]{Value-dependent expressions}

\pnum
Except as described below, a constant expression is value-dependent if any
subexpression is value-dependent.

\pnum
An
\grammarterm{id-expression}
is value-dependent if:

\begin{itemize}
\item
it is a name declared with a dependent type,
\item
it is the name of a non-type template parameter,
\item
it names a member of an unknown specialization,
\item
it names a static data member that is a dependent member of the current
instantiation and is not initialized in a \grammarterm{member-declarator},
\item
it names a static member function that is a dependent member of the current
instantiation, or
\item
it is a constant with literal type and is initialized with an
expression that is value-dependent.
\end{itemize}

Expressions of the following form are value-dependent if the
\grammarterm{unary-expression} or \grammarterm{expression}
is type-dependent or the
\grammarterm{type-id}
is dependent:

\begin{ncbnftab}
\terminal{sizeof} unary-expression\br
\terminal{sizeof (} type-id \terminal{)}\br
\terminal{typeid (} expression \terminal{)}\br
\terminal{typeid (} type-id \terminal{)}\br
\terminal{alignof (} type-id \terminal{)}\br
\terminal{noexcept} \terminal{(} expression \terminal{)}
\end{ncbnftab}

\enternote For the standard library macro \tcode{offsetof},
see~\ref{support.types}.\exitnote

\pnum
Expressions of the following form are value-dependent if either the
\grammarterm{type-id}
or
\grammarterm{simple-type-specifier}
is dependent or the
\grammarterm{expression}
or
\grammarterm{cast-expression}
is value-dependent:

\begin{ncbnftab}
simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
\terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
\terminal{(} type-id \terminal{)} cast-expression
\end{ncbnftab}

\pnum
Expressions of the following form are value-dependent:

\begin{ncbnftab}
\terminal{sizeof} \terminal{...} \terminal{(} identifier \terminal{)}
\end{ncbnftab}

\pnum
An expression of the form \tcode{\&}\grammarterm{qualified-id} where the
\grammarterm{qualified-id} names a dependent member of the current
instantiation is value-dependent.

\rSec3[temp.dep.temp]{Dependent template arguments}

\pnum
A type
\grammarterm{template-argument}
is dependent if the type it specifies is dependent.

\pnum
A non-type
\grammarterm{template-argument}
is dependent if its type is dependent or the constant
expression it specifies is value-dependent.

\pnum
Furthermore, a non-type
\grammarterm{template-argument}
is dependent if the corresponding non-type \grammarterm{template-parameter}
is of reference or pointer type and the \grammarterm{template-argument}
designates or points to a member of the current instantiation or a member of
a dependent type.

\pnum
A template
\grammarterm{template-argument}
is dependent if it names a
\grammarterm{template-parameter}
or is a
\grammarterm{qualified-id}
that refers to a member of an unknown specialization.

\rSec2[temp.nondep]{Non-dependent names}

\pnum
Non-dependent names used in a template definition are found using the
usual name lookup and bound at the point they are used.
\enterexample

\begin{codeblock}
void g(double);
void h();

template<class T> class Z {
public:
  void f() {
    g(1);           // calls \tcode{g(double)}
    h++;            // ill-formed: cannot increment function;
                    // this could be diagnosed either here or
                    // at the point of instantiation
  }
};

void g(int);        // not in scope at the point of the template
                    // definition, not considered for the call \tcode{g(1)}
\end{codeblock}
\exitexample

\rSec2[temp.dep.res]{Dependent name resolution}

\pnum
\indextext{name!dependent}%
In resolving dependent names, names from the following sources are considered:

\begin{itemize}
\item
Declarations that are visible at the point of definition of the
template.
\item
Declarations from namespaces associated with the types of the
function arguments both from the instantiation context~(\ref{temp.point})
and from the definition context.
\end{itemize}

\rSec3[temp.point]{Point of instantiation}

\pnum
\indextext{instantiation!point~of}%
For a function template specialization, a member function template
specialization, or a specialization for a member function or static data member
of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization and
the context from which it is referenced depends on a template parameter,
the point of instantiation of the specialization is the point of instantiation
of the enclosing specialization.
Otherwise, the point of instantiation for such a specialization immediately
follows the namespace scope declaration
or definition that refers to the specialization.

\pnum
If a function template or member function of a class template is called
in a way which uses the definition of a default argument of that function
template or member function,
the point of instantiation of the default argument is the point of
instantiation of the function template or member function specialization.

\pnum
For an \grammarterm{exception-specification} of a function template
specialization or specialization of a member function of a class template, if
the \grammarterm{exception-specification} is implicitly instantiated because
it is needed by another template specialization and the context that requires
it depends on a template parameter, the point of instantiation of the
\grammarterm{exception-specification} is the point of instantiation of the
specialization that requires it. Otherwise, the point of instantiation for such
an \grammarterm{exception-specification} immediately follows the namespace
scope declaration or definition that requires the
\grammarterm{exception-specification}.



\pnum
For a class template specialization, a class member template specialization,
or a specialization for a class member of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization,
if the context from which the specialization is referenced depends on a
template parameter,
and if the specialization is not instantiated previous to the instantiation of
the enclosing template,
the point of instantiation is immediately before the point of instantiation of
the enclosing template.
Otherwise, the point of instantiation for such a specialization immediately
precedes the namespace scope declaration
or definition that refers to the specialization.

\pnum
If a virtual function is implicitly instantiated, its point of instantiation
is immediately following the point of instantiation of its enclosing class
template specialization.

\pnum
An explicit instantiation definition is an instantiation
point for the specialization or specializations specified by the explicit
instantiation.

\pnum
The instantiation context of an expression that depends on the template
arguments is the set of declarations with external linkage declared prior to the
point of instantiation of the template specialization in the same translation
unit.

\pnum
A specialization for a function template, a member function template,
or of a member function or static data member of a class template may have
multiple points of instantiations within a translation unit, and in addition
to the points of instantiation described above, for any such specialization
that has a point of instantiation within the translation unit, the end of the
translation unit is also considered a point of instantiation.
A specialization for a class template has at most one point of instantiation
within a translation unit.
A specialization for any template may have points of instantiation in multiple
translation units.
If two different points of instantiation give a template specialization
different meanings according to the one definition rule~(\ref{basic.def.odr}),
the program is ill-formed, no diagnostic required.

\rSec3[temp.dep.candidate]{Candidate functions}

\pnum
\indextext{functions!candidate}%
For a function call where the \grammarterm{postfix-expression} is a
dependent name,
the candidate functions are found using the usual lookup
rules~(\ref{basic.lookup.unqual}, \ref{basic.lookup.argdep}) except that:

\begin{itemize}
\item
For the part of the lookup using unqualified name lookup~(\ref{basic.lookup.unqual}),
only function declarations
from the template definition context are found.
\item
For the part of the lookup using associated namespaces~(\ref{basic.lookup.argdep}),
only function declarations found in either the template
definition context or the template instantiation context are found.
\end{itemize}

If
the call would be ill-formed or would find a better match had the lookup
within the associated namespaces considered all the function declarations with
external linkage introduced in those namespaces in all translation units,
not just considering those declarations found in the template definition and
template instantiation contexts, then the program has undefined behavior.

\rSec2[temp.inject]{Friend names declared within a class template}

\pnum
Friend classes or functions can be declared within a class template.
When a template is instantiated, the names of its friends are treated
as if the specialization had been explicitly declared at its point of
instantiation.

\pnum
As with non-template classes, the names of namespace-scope friend
functions of a class template specialization are not visible during
an ordinary lookup unless explicitly declared at namespace scope~(\ref{class.friend}).
Such names may be found under the rules for associated
classes~(\ref{basic.lookup.argdep}).\footnote{Friend declarations do not
introduce new names into any scope, either
when the template is declared or when it is instantiated.}
\enterexample
\begin{codeblock}
template<typename T> struct number {
  number(int);
  friend number gcd(number x, number y) { return 0; };
};

void g() {
  number<double> a(3), b(4);
  a = gcd(a,b);     // finds \tcode{gcd} because \tcode{number<double>} is an
                    // associated class, making \tcode{gcd} visible
                    // in its namespace (global scope)
  b = gcd(3,4);     // ill-formed; \tcode{gcd} is not visible
}
\end{codeblock}
\exitexample

\rSec1[temp.spec]{Template instantiation and specialization}

\pnum
\indextext{specialization!template}%
The act of instantiating a function, a class, a member of a class template or
a member template is referred to as
\term{template instantiation}.

\pnum
A function instantiated from a function template is called an instantiated
function.
A class instantiated from a class template is called an instantiated class.
A member function, a member class, a member enumeration, or a static data member of a class template
instantiated from the member definition of the class template is called,
respectively, an instantiated member function, member class, member enumeration, or static data
member.
A member function instantiated from a member function template is called an
instantiated member function.
A member class instantiated from a member class template is called an
instantiated member class.

\pnum
An explicit specialization may be declared for a function template,
a class template, a member of a class template or a member template.
An explicit specialization declaration is introduced by
\tcode{template<>}.
In an explicit specialization declaration for a class template,
a member of a class template or a class member template,
the name of the class that is explicitly specialized shall be a
\grammarterm{simple-template-id}.
In the explicit specialization declaration for a function template or
a member function template,
the name of the function or member function explicitly specialized may be a
\grammarterm{template-id}.
\enterexample

\begin{codeblock}
template<class T = int> struct A {
  static int x;
};
template<class U> void g(U) { }

template<> struct A<double> { };        // specialize for \tcode{T == double}
template<> struct A<> { };              // specialize for \tcode{T == int}
template<> void g(char) { }             // specialize for \tcode{U == char}
                                        // \tcode{U} is deduced from the parameter type
template<> void g<int>(int) { }         // specialize for \tcode{U == int}
template<> int A<char>::x = 0;          // specialize for \tcode{T == char}

template<class T = int> struct B {
  static int x;
};
template<> int B<>::x = 1;              // specialize for \tcode{T == int}
\end{codeblock}
\exitexample

\pnum
An instantiated template specialization can be either implicitly
instantiated~(\ref{temp.inst}) for a given argument list or be explicitly
instantiated~(\ref{temp.explicit}).
A specialization is a class, function, or class member that is either
instantiated or explicitly specialized~(\ref{temp.expl.spec}).

\pnum
For a given template and a given set of
\grammarterm{template-argument}{s},
\begin{itemize}
\item
an explicit instantiation definition shall appear at most once in a program,
\item
an explicit specialization shall be defined at most once
in a program (according to~\ref{basic.def.odr}), and
\item
both an explicit instantiation and a declaration of an
explicit specialization shall not appear in a program unless
the explicit instantiation follows a declaration of the explicit
specialization.
\end{itemize}
An implementation is not required to diagnose a violation of this rule.

\pnum
Each class template specialization instantiated from a template has its own
copy of any static members.
\enterexample

\begin{codeblock}
template<class T> class X {
  static T s;
};
template<class T> T X<T>::s = 0;
X<int> aa;
X<char*> bb;
\end{codeblock}

\tcode{X<int>}
has a static member
\tcode{s}
of type
\tcode{int}
and
\tcode{X<char*>}
has a static member
\tcode{s}
of type
\tcode{char*}.
\exitexample

\rSec2[temp.inst]{Implicit instantiation}

\pnum
\indextext{instantiation!template implicit}%
Unless a class template specialization has been explicitly
instantiated~(\ref{temp.explicit}) or explicitly
specialized~(\ref{temp.expl.spec}),
the class template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a completely-defined
object type or when the completeness of the class type affects the semantics
of the program.
The implicit instantiation of a class template specialization causes
the implicit instantiation of the declarations, but not of the definitions,
default arguments, or \grammarterm{exception-specification}{s} of the class member functions,
member classes, scoped member enumerations, static data members and member templates; and it causes the
implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions.
However, for the purpose of determining whether an instantiated redeclaration
of a member is valid according to~\ref{class.mem}, a declaration that
corresponds to a definition in the template is considered to be a
definition.
\enterexample
\begin{codeblock}
template<class T, class U>
struct Outer {
  template<class X, class Y> struct Inner;
  template<class Y> struct Inner<T, Y>;         // \#1a
  template<class Y> struct Inner<T, Y> { };     // \#1b; OK: valid redeclaration of \#1a
  template<class Y> struct Inner<U, Y> { };     // \#2
};

Outer<int, int> outer;                          // error at \#2
\end{codeblock}

\tcode{Outer<int, int>::Inner<int, Y>} is redeclared at \#1b. (It is not defined
but noted as being associated with a definition in \tcode{Outer<T, U>}.) \#2
is also a redeclaration of \#1a. It is noted as associated with a definition,
so it is an invalid redeclaration of the same partial specialization.
\exitexample

\pnum
Unless a member of a class template or a member template has been explicitly
instantiated or explicitly specialized,
the specialization of the member is implicitly instantiated when the
specialization is referenced in a context that requires the member definition
to exist;
in particular, the initialization (and any associated side-effects) of a
static data member does not occur unless the static data member is itself used
in a way that requires the definition of the static data member to exist.

\pnum
Unless a function template specialization has been explicitly instantiated or
explicitly specialized,
the function template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a function definition
to exist.
Unless a call is to a function template explicit specialization or
to a member function of an explicitly specialized class template,
a default argument for a function template or a member function of a
class template is implicitly instantiated when the function is
called in a context that requires the value of the default argument.

\pnum
\enterexample
\begin{codeblock}
template<class T> struct Z {
  void f();
  void g();
};

void h() {
  Z<int> a;         // instantiation of class \tcode{Z<int>} required
  Z<char>* p;       // instantiation of class \tcode{Z<char>} not required
  Z<double>* q;     // instantiation of class \tcode{Z<double>} not required

  a.f();            // instantiation of \tcode{Z<int>::f()} required
  p->g();           // instantiation of class \tcode{Z<char>} required, and
                    // instantiation of \tcode{Z<char>::g()} required
}
\end{codeblock}

Nothing in this example requires
\tcode{class}
\tcode{Z<double>},
\tcode{Z<int>::g()},
or
\tcode{Z<char>::f()}
to be implicitly instantiated.
\exitexample

\pnum
Unless a variable template specialization has been explicitly instantiated or
explicitly specialized, the variable template specialization is implicitly
instantiated when the specialization is used. A default template argument for a
variable template is implicitly instantiated when the variable template is
referenced in a context that requires the value of the default argument.

\pnum
A class template specialization is implicitly instantiated if the
class type is used in a context that requires a completely-defined
object type or if the completeness of the class type might affect the
semantics of the program.
\enternote
In particular, if the semantics of an expression depend on the member
or base class lists of a class template specialization, the class
template specialization is implicitly generated. For instance,
deleting a pointer to class type depends on whether or not the class
declares a destructor, and conversion between pointer to class types
depends on the inheritance relationship between the two classes
involved.
\exitnote
\enterexample

\begin{codeblock}
template<class T> class B { /* ... */ };
template<class T> class D : public B<T> { /* ... */ };

void f(void*);
void f(B<int>*);

void g(D<int>* p, D<char>* pp, D<double>* ppp) {
  f(p);             // instantiation of \tcode{D<int>} required: call \tcode{f(B<int>*)}
  B<char>* q = pp;  // instantiation of \tcode{D<char>} required:
                    // convert \tcode{D<char>*} to \tcode{B<char>*}
  delete ppp;       // instantiation of \tcode{D<double>} required
}
\end{codeblock}
\exitexample

\pnum
If the overload resolution process can determine the correct function to
call without instantiating a class template definition, it is unspecified
whether that instantiation actually takes place.
\enterexample

\begin{codeblock}
template <class T> struct S {
  operator int();
};

void f(int);
void f(S<int>&);
void f(S<float>);

void g(S<int>& sr) {
  f(sr);            // instantiation of \tcode{S<int>} allowed but not required
                    // instantiation of \tcode{S<float>} allowed but not required
};
\end{codeblock}
\exitexample

\pnum
If an implicit instantiation of a class template specialization is required and
the template is declared but not defined, the program is ill-formed.
\enterexample

\begin{codeblock}
template<class T> class X;

X<char> ch;         // error: definition of \tcode{X} required
\end{codeblock}
\exitexample

\pnum
The implicit instantiation of a class template does not cause any static data
members of that class to be implicitly instantiated.

\pnum
If a function template or a member function template specialization is used in
a way that involves overload resolution,
a declaration of the specialization is implicitly instantiated~(\ref{temp.over}).

\pnum
An implementation shall not implicitly instantiate a function template,
a variable template,
a member template, a non-virtual member function, a member class, or a
static data member of a class template that does not require instantiation.
It is unspecified whether or not an implementation implicitly instantiates a
virtual member function of a class template if the virtual member function would
not otherwise be instantiated.
The use of a template specialization in a default argument
shall not cause the template to be implicitly instantiated except that a
class template may be instantiated where its complete type is needed to determine
the correctness of the default argument.
The use of a default argument in a
function call causes specializations in the default argument to be implicitly
instantiated.

\pnum
Implicitly instantiated class, function, and variable template specializations
are placed in the namespace where the template is defined.
Implicitly instantiated specializations for members of a class template are
placed in the namespace where the enclosing class template is defined.
Implicitly instantiated member templates are placed in the namespace where the
enclosing class or class template is defined.
\enterexample

\begin{codeblock}
namespace N {
  template<class T> class List {
  public:
    T* get();
  };
}

template<class K, class V> class Map {
public:
  N::List<V> lt;
  V get(K);
};

void g(Map<const char*,int>& m) {
  int i = m.get("Nicholas");
}
\end{codeblock}

a call of
\tcode{lt.get()}
from
\tcode{Map<const char*,int>::get()}
would place
\tcode{List<int>::get()}
in the namespace
\tcode{N}
rather than in the global namespace.
\exitexample

\pnum
If a function template
\tcode{f}
is called in a way that requires a default argument to be used,
the dependent names are looked up, the semantics constraints are checked,
and the instantiation of any template used in the default argument
is done as if the default argument had been
an initializer used in a function template specialization with the same scope,
the same template parameters and the same access as that of the function template
\tcode{f}
used at that point, except that the scope in which a closure type is
declared~(\ref{expr.prim.lambda}) -- and therefore its associated namespaces --
remain as determined from the context of the definition for the default
argument.
This analysis is called
\term{default argument instantiation}.
The instantiated default argument is then used as the argument of
\tcode{f}.

\pnum
Each default argument is instantiated independently.
\enterexample

\begin{codeblock}
template<class T> void f(T x, T y = ydef(T()), T z = zdef(T()));

class  A { };

A zdef(A);

void g(A a, A b, A c) {
  f(a, b, c);       // no default argument instantiation
  f(a, b);          // default argument \tcode{z = zdef(T())} instantiated
  f(a);             // ill-formed; \tcode{ydef} is not declared
}
\end{codeblock}
\exitexample

\pnum
The \grammarterm{exception-specification} of a function template specialization
is not instantiated along with the function declaration; it is instantiated
when needed~(\ref{except.spec}). If such an
\grammarterm{exception-specification} is needed but has not yet been
instantiated, the dependent names are looked up, the semantics constraints are
checked, and the instantiation of any template used in the
\grammarterm{exception-specification} is done as if it were being done as part
of instantiating the declaration of the specialization at that point.

\pnum
\enternote
\ref{temp.point} defines the point of instantiation of a template specialization.
\exitnote

\pnum
There is an implementation-defined quantity that specifies the limit on
the total depth of recursive instantiations, which could involve more than one
template.
The result of an infinite recursion in instantiation is undefined.
\enterexample

\begin{codeblock}
template<class T> class X {
  X<T>* p;          // OK
  X<T*> a;          // implicit generation of \tcode{X<T>} requires
                    // the implicit instantiation of \tcode{X<T*>} which requires
                    // the implicit instantiation of \tcode{X<T**>} which ...
};
\end{codeblock}
\exitexample

\rSec2[temp.explicit]{Explicit instantiation}

\pnum
\indextext{instantiation!explicit}%
A class, function, variable, or member template specialization can be explicitly
instantiated from its template.
A member function, member class or static data member of a class template can
be explicitly instantiated from the member definition associated with its class
template. An explicit instantiation of a function template
or member function of a class template
shall not
use the \tcode{inline} or \tcode{constexpr} specifiers.

\pnum
The syntax for explicit instantiation is:

\begin{bnf}
\nontermdef{explicit-instantiation}\br
  \terminal{extern\opt} \terminal{template} declaration
\end{bnf}

There are two forms of explicit instantiation: an explicit instantiation
definition and an explicit instantiation declaration. An explicit instantiation
declaration begins with the \tcode{extern} keyword.

\pnum
If the explicit instantiation is for a class or member class, the
\grammarterm{elaborated-type-specifier} in the \grammarterm{declaration} shall
include a \grammarterm{simple-template-id}. If the explicit instantiation is for
a function or member function,
the
\grammarterm{unqualified-id}
in the
\grammarterm{declaration}
shall be either a
\grammarterm{template-id}
or, where all template arguments can be deduced, a
\grammarterm{template-name} or \grammarterm{operator-function-id}.
\enternote
The declaration may declare a
\grammarterm{qualified-id},
in which case the
\grammarterm{unqualified-id}
of the
\grammarterm{qualified-id}
must be a
\grammarterm{template-id}.
\exitnote
If the explicit instantiation is for a member function, a member class or
a static data member of a class template specialization,
the name of the class template specialization in the
\grammarterm{qualified-id}
for the member name shall be a \grammarterm{simple-template-id}.
If the explicit instantiation is for a variable, the
\grammarterm{unqualified-id} in the declaration shall be a
\grammarterm{template-id}.
An explicit instantiation shall appear in an enclosing namespace
of its template. If the name declared in the explicit
instantiation is an unqualified name, the explicit instantiation
shall appear in the namespace where its template is declared or, if that
namespace is inline~(\ref{namespace.def}), any namespace from its enclosing
namespace set.
\enternote
Regarding qualified names in declarators, see~\ref{dcl.meaning}.
\exitnote
\enterexample

\begin{codeblock}
template<class T> class Array { void mf(); };
template class Array<char>;
template void Array<int>::mf();

template<class T> void sort(Array<T>& v) { /* ... */ }
template void sort(Array<char>&);       // argument is deduced here

namespace N {
  template<class T> void f(T&) { }
}
template void N::f<int>(int&);
\end{codeblock}
\exitexample

\pnum
A declaration of a function template, a variable template, a member function
or static data member
of a class template, or a member function template of a class or class
template shall precede an explicit instantiation of that entity. A definition
of a class template, a member class of a class template, or a member class
template of a class or class template shall precede an explicit instantiation
of that entity unless the explicit instantiation is preceded by an explicit
specialization of the entity with the same template arguments.
If the
\grammarterm{declaration}
of the explicit instantiation names an implicitly-declared special member
function (Clause~\ref{special}), the program is ill-formed.

\pnum
For a given set of template arguments, if an explicit
instantiation of a template appears after a declaration of
an explicit specialization for that template, the explicit
instantiation has no effect. Otherwise, for an explicit instantiation
definition the definition of a
function template, a variable template, a member
function template, or a member function or static
data member of a class template shall be present in every
translation unit in which it is explicitly instantiated.

\pnum
An explicit instantiation of a class, function template, or variable template
specialization is
placed in the namespace in which the template is defined.
An explicit instantiation for a member of a class template is placed in
the namespace where the enclosing class template is defined.
An explicit instantiation for a member template is placed in the namespace
where the enclosing class or class template is defined.
\enterexample

\begin{codeblock}
namespace N {
  template<class T> class Y { void mf() { } };
}

template class Y<int>;                  // error: class template \tcode{Y} not visible
                                        // in the global namespace

using N::Y;
template class Y<int>;                  // error: explicit instantiation outside of the
                                        // namespace of the template

template class N::Y<char*>;             // OK: explicit instantiation in namespace \tcode{N}
template void N::Y<double>::mf();       // OK: explicit instantiation
                                        // in namespace \tcode{N}
\end{codeblock}
\exitexample

\pnum
A trailing
\grammarterm{template-argument}
can be left unspecified in an explicit instantiation of a function template
specialization or of a member function template specialization provided
it can be deduced from the type of a function parameter~(\ref{temp.deduct}).
\enterexample

\begin{codeblock}
template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v) { /* ... */ }

// instantiate \tcode{sort(Array<int>\&)} - template-argument deduced
template void sort<>(Array<int>&);
\end{codeblock}
\exitexample

\pnum
An explicit instantiation that names a class
template specialization is also an explicit
instantiation of the same kind (declaration or definition) of each
of its members (not including members inherited from base classes and members
that are templates) that has not been previously explicitly specialized in
the translation unit containing the explicit instantiation,
except as described below.
\enternote In addition, it will typically be an explicit instantiation of certain
implementation-dependent data about the class. \exitnote

\pnum
An explicit instantiation definition that names a class template
specialization explicitly instantiates the class template specialization
and is an explicit instantiation definition of only those
members that have been defined at the point of instantiation.

\pnum
Except for inline functions, declarations with types deduced from their
initializer or return value~(\ref{dcl.spec.auto}), \tcode{const} variables of
literal types,
variables of reference types, and class template specializations,
explicit instantiation declarations have the
effect of suppressing the implicit instantiation of the entity to which they
refer. \enternote The intent is that an inline function that is the
subject of an explicit instantiation declaration will still be implicitly
instantiated when odr-used~(\ref{basic.def.odr}) so that the body can be considered for inlining, but
that no out-of-line copy of the inline function would be generated in the
translation unit.\exitnote

\pnum
If an entity is the subject of both an explicit instantiation declaration
and an explicit instantiation definition in the same translation unit, the
definition shall follow the declaration. An entity that is the subject of an
explicit instantiation declaration and that is also used
in a way that would otherwise cause an implicit instantiation~(\ref{temp.inst})
in the translation unit
shall be the subject of an explicit instantiation definition somewhere in the
program; otherwise the program is ill-formed, no diagnostic required.
\enternote This rule does apply to inline functions even though an
explicit instantiation declaration of such an entity has no other normative
effect. This is needed to ensure that if the address of an inline function is
taken in a translation unit in which the implementation chose to suppress the
out-of-line body, another translation unit will supply the body.\exitnote
An explicit instantiation declaration shall not name a specialization of a
template with internal linkage.



\pnum
The usual access checking rules do not apply to names used to specify
explicit instantiations.
\enternote
In particular, the template arguments and names used in the function
declarator (including parameter types, return types and exception
specifications) may be private types or objects which would normally
not be accessible and the template may be a member template or member
function which would not normally be accessible.
\exitnote

\pnum
An explicit instantiation does not constitute a use of a default argument,
so default argument instantiation is not done.
\enterexample

\begin{codeblock}
char* p = 0;
template<class T> T g(T x = &p) { return x; }
template int g<int>(int);       // OK even though \tcode{\&p} isn't an \tcode{int}.
\end{codeblock}
\exitexample

\rSec2[temp.expl.spec]{Explicit specialization}

\pnum
\indextext{specialization!template explicit}%
An explicit specialization of any of the following:

\begin{itemize}
\item
function template
\item
class template
\item
variable template
\item
member function of a class template
\item
static data member of a class template
\item
member class of a class template
\item
member enumeration of a class template
\item
member class template of a class or class template
\item
member function template of a class or class template
\end{itemize}

can be declared by a declaration introduced by
\tcode{template<>};
that is:
\indextext{\idxgram{explicit-specialization}}%

\begin{bnf}
\nontermdef{explicit-specialization}\br
  \terminal{template < >} declaration
\end{bnf}

\enterexample
\begin{codeblock}
template<class T> class stream;

template<> class stream<char> { /* ... */ };

template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v) { /* ... */ }

template<> void sort<char*>(Array<char*>&) ;
\end{codeblock}

Given these declarations,
\tcode{stream<char>}
will be used as the definition of streams of
\tcode{char}s;
other streams will be handled by class template specializations instantiated
from the class template.
Similarly,
\tcode{sort<char*>}
will be used as the sort function for arguments
of type
\tcode{Array<char*>};
other
\tcode{Array}
types will be sorted by functions generated from the template.
\exitexample

\pnum
An explicit specialization shall be declared in a namespace enclosing the specialized template.
An explicit specialization
whose \grammarterm{declarator-id} is not qualified
shall be declared in the nearest enclosing namespace of the template,
or, if the namespace is inline~(\ref{namespace.def}), any namespace from its enclosing namespace set.
Such a declaration may also be a definition.
If the declaration is not a definition, the specialization may be
defined later~(\ref{namespace.memdef}).

\pnum
A declaration of a function template, class template, or variable template being explicitly
specialized shall precede the declaration of
the explicit
specialization.
\enternote
A declaration, but not a definition of the template is required.
\exitnote
The definition of a class or class template shall precede the
declaration of an explicit specialization for a member template of the class
or class template.
\enterexample

\begin{codeblock}
template<> class X<int> { /* ... */ };          // error: \tcode{X} not a template

template<class T> class X;

template<> class X<char*> { /* ... */ };        // OK: \tcode{X} is a template
\end{codeblock}
\exitexample

\pnum
A member function, a member function template, a member class,
a member enumeration, a
member class template,
a static data member, or a static data member template of a class template
may be explicitly specialized for a class specialization that is implicitly
instantiated;
in this case, the definition of the class template shall
precede the explicit specialization for the member of the class
template.
If such an explicit specialization for the member of a class template names an
implicitly-declared special member function (Clause~\ref{special}),
the program is ill-formed.

\pnum
A member of an explicitly specialized class is not implicitly
instantiated from the member declaration of the class template;
instead, the member of the class template specialization shall itself be
explicitly defined if its definition is required.
In this case, the definition of the class template explicit specialization
shall be in scope at the point at which the member is defined.
The definition of an explicitly specialized class is unrelated to the
definition of a generated specialization.
That is, its members need
not have the same names, types, etc. as the members of a generated
specialization.
Members of an explicitly specialized
class template are defined in the same manner as members of normal classes, and
not using the \tcode{template<>} syntax.
The same is true when defining a member of an explicitly specialized member
class. However, \tcode{template<>} is used in defining a member of an explicitly
specialized member class template that is specialized as a class template.
\enterexample

\begin{codeblock}
template<class T> struct A {
  struct B { };
  template<class U> struct C { };
};

template<> struct A<int> {
  void f(int);
};

void h() {
  A<int> a;
  a.f(16);          // \tcode{A<int>::f} must be defined somewhere
}

// \tcode{template<>} not used for a member of an
// explicitly specialized class template
void A<int>::f(int) { /* ... */ }

template<> struct A<char>::B {
  void f();
};
// \tcode{template<>} also not used when defining a member of
// an explicitly specialized member class
void A<char>::B::f() { /* ... */ }

template<> template<class U> struct A<char>::C {
  void f();
};
// \tcode{template<>} is used when defining a member of an explicitly
// specialized member class template specialized as a class template
template<>
template<class U> void A<char>::C<U>::f() { /* ... */ }

template<> struct A<short>::B {
  void f();
};
template<> void A<short>::B::f() { /* ... */ }  // error: \tcode{template<>} not permitted

template<> template<class U> struct A<short>::C {
  void f();
};
template<class U> void A<short>::C<U>::f() { /* ... */ }  // error: \tcode{template<>} required
\end{codeblock}
\exitexample

\pnum
If a template, a member template or a member of a class template is explicitly
specialized then that specialization shall be declared before the first use of
that specialization that would cause an implicit instantiation to take place,
in every translation unit in which such a use occurs;
no diagnostic is required.
If the program does not provide a definition for an explicit specialization and
either the specialization is used in a way that would cause an implicit
instantiation to take place or the member is a virtual member function,
the program is ill-formed, no diagnostic required.
An implicit instantiation is never generated for an explicit specialization
that is declared but not defined.
\enterexample

\begin{codeblock}
class String { };
template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v) { /* ... */ }

void f(Array<String>& v) {
  sort(v);          // use primary template
                    // \tcode{sort(Array<T>\&)}, \tcode{T} is \tcode{String}
}

template<> void sort<String>(Array<String>& v); // error: specialization
                                                // after use of primary template
template<> void sort<>(Array<char*>& v);        // OK: \tcode{sort<char*>} not yet used
template<class T> struct A {
  enum E : T;
  enum class S : T;
};
template<> enum A<int>::E : int { eint };         // OK
template<> enum class A<int>::S : int { sint };   // OK
template<class T> enum A<T>::E : T { eT };
template<class T> enum class A<T>::S : T { sT };
template<> enum A<char>::E : char { echar };       // ill-formed, \tcode{A<char>::E} was instantiated
                                                   // when \tcode{A<char>} was instantiated
template<> enum class A<char>::S : char { schar }; // OK
\end{codeblock}
\exitexample

\pnum
The placement of explicit specialization declarations for function templates, class
templates, variable templates,
member functions of class templates, static data members of class
templates, member classes of class templates, member enumerations of class
templates, member class templates of class
templates, member function templates of class templates,
static data member templates of class templates,
member functions of
member templates of class templates, member functions of member templates of
non-template classes,
static data member templates of non-template classes,
member function templates of member classes of class
templates, etc., and the placement of partial specialization declarations
of class templates, variable templates,
member class templates of non-template classes,
static data member templates of non-template classes, member
class templates of class templates, etc., can affect whether a program is
well-formed according to the relative positioning of the explicit specialization
declarations and their points of instantiation in the translation unit as
specified above and below.
\indextext{immolation!self}%
When writing a specialization, be careful about its location;
or to make it compile will be such a trial as to kindle its self-immolation.

\pnum
A template explicit specialization is in the scope of the namespace in which
the template was defined.
\enterexample

\begin{codeblock}
namespace N {
  template<class T> class X { /* ... */ };
  template<class T> class Y { /* ... */ };

  template<> class X<int> { /* ... */ };          // OK: specialization
                                                // in same namespace
  template<> class Y<double>;                   // forward declare intent to
                                                // specialize for \tcode{double}
}

template<> class N::Y<double> { /* ... */ };      // OK: specialization
                                                // in enclosing namespace
template<> class N::Y<short> { /* ... */ };       // OK: specialization
                                                // in enclosing namespace
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{simple-template-id}
that names a class template explicit specialization that has been declared but
not defined can be used exactly like the names of other incompletely-defined
classes~(\ref{basic.types}).
\enterexample

\begin{codeblock}
template<class T> class X;      // \tcode{X} is a class template
template<> class X<int>;

X<int>* p;                      // OK: pointer to declared class \tcode{X<int>}
X<int> x;                       // error: object of incomplete class \tcode{X<int>}
\end{codeblock}
\exitexample

\pnum
A trailing
\grammarterm{template-argument}
can be left unspecified in the
\grammarterm{template-id}
naming an explicit function template specialization
provided it can be deduced from the function argument type.
\enterexample

\begin{codeblock}
template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v);

// explicit specialization for \tcode{sort(Array<int>\&)}
// with deduced template-argument of type \tcode{int}
template<> void sort(Array<int>&);
\end{codeblock}
\exitexample

\pnum
A function with the same name as a template and a type that exactly matches that
of a template specialization is not an explicit specialization~(\ref{temp.fct}).

\pnum
An explicit specialization of a function template is inline
only if it is declared with the \tcode{inline}
specifier or defined as deleted, and independently of whether its
function template is inline.
\enterexample

\begin{codeblock}
template<class T> void f(T) { /* ... */ }
template<class T> inline T g(T) { /* ... */ }

template<> inline void f<>(int) { /* ... */ }   // OK: inline
template<> int g<>(int) { /* ... */ }           // OK: not inline
\end{codeblock}
\exitexample

\pnum
An explicit specialization of a static data member of a template
or an explicit specialization of a static data member template is a
definition if the declaration includes an initializer;
otherwise, it is a declaration.
\enternote
The definition of a static data member of a template
that requires default initialization must use a \grammarterm{braced-init-list}:

\begin{codeblock}
template<> X Q<int>::x;         // declaration
template<> X Q<int>::x ();      // error: declares a function
template<> X Q<int>::x { };     // definition
\end{codeblock}
\exitnote

\pnum
A member or a member template of a class template may be explicitly specialized
for a given implicit instantiation of the class template, even if the member
or member template is defined in the class template definition.
An explicit specialization of a member or member template is specified using the
syntax for explicit specialization.
\enterexample

\begin{codeblock}
template<class T> struct A {
  void f(T);
  template<class X1> void g1(T, X1);
  template<class X2> void g2(T, X2);
  void h(T) { }
};

// specialization
template<> void A<int>::f(int);

// out of class member template definition
template<class T> template<class X1> void A<T>::g1(T, X1) { }

// member template specialization
template<> template<class X1> void A<int>::g1(int, X1);

//member template specialization
template<> template<>
  void A<int>::g1(int, char);           // \tcode{X1} deduced as \tcode{char}
template<> template<>
  void A<int>::g2<char>(int, char);     // \tcode{X2} specified as \tcode{char}

// member specialization even if defined in class definition
template<> void A<int>::h(int) { }
\end{codeblock}
\exitexample

\pnum
A member or a member template may be nested within many enclosing class
templates.
In an explicit specialization for such a member,
the member declaration shall be preceded by a
\tcode{template<>}
for each enclosing class template that is explicitly specialized.
\enterexample

\begin{codeblock}
template<class T1> class A {
  template<class T2> class B {
    void mf();
  };
};
template<> template<> class A<int>::B<double>;
template<> template<> void A<char>::B<char>::mf();
\end{codeblock}
\exitexample

\pnum
In an explicit specialization declaration for a member of a class template or
a member template that appears in namespace scope,
the member template and some of its enclosing class templates may remain
unspecialized,
except that the declaration shall not explicitly specialize a class member
template if its enclosing class templates are not explicitly specialized
as well.
In such explicit specialization declaration, the keyword
\tcode{template}
followed by a
\grammarterm{template-parameter-list}
shall be provided instead of the
\tcode{template<>}
preceding the explicit specialization declaration of the member.
The types of the
\grammarterm{template-parameters}
in the
\grammarterm{template-parameter-list}
shall be the same as those specified in the primary template definition.
\enterexample

\begin{codeblock}
template <class T1> class A {
  template<class T2> class B {
    template<class T3> void mf1(T3);
    void mf2();
  };
};
template <> template <class X>
  class A<int>::B {
      template <class T> void mf1(T);
  };
template <> template <> template<class T>
  void A<int>::B<double>::mf1(T t) { }
template <class Y> template <>
  void A<Y>::B<double>::mf2() { }       // ill-formed; \tcode{B<double>} is specialized but
                                        // its enclosing class template \tcode{A} is not
\end{codeblock}
\exitexample

\pnum
A specialization of a member function template, member class template,
or static data member template of
a non-specialized class template is itself a template.

\pnum
An explicit specialization declaration shall not be a friend declaration.

\pnum
Default function arguments shall not be specified in a declaration or
a definition for one of the following explicit specializations:

\begin{itemize}
\item
the explicit specialization of a function template;
\item
the explicit specialization of a member function template;
\item
the explicit specialization of a member function of a class template where
the class template specialization to which the member function specialization
belongs is implicitly instantiated.
\enternote
Default function arguments may be specified in the declaration or
definition of a member function of a class template specialization that is
explicitly specialized.
\exitnote
\end{itemize}

\rSec1[temp.fct.spec]{Function template specializations}

\pnum
\indextext{template!function}%
A function instantiated from a function template is called a function template
specialization; so is an explicit specialization of a function template.
Template arguments can be explicitly specified when naming the function
template specialization, deduced from the context (e.g.,
deduced from the function arguments in a call to the function template
specialization, see~\ref{temp.deduct}), or obtained from default template arguments.

\pnum
Each function template specialization instantiated from a template
has its own copy of any static variable.
\enterexample

\begin{codeblock}
template<class T> void f(T* p) {
  static T s;
};

void g(int a, char* b) {
  f(&a);            // calls \tcode{f<int>(int*)}
  f(&b);            // calls \tcode{f<char*>(char**)}
}
\end{codeblock}

Here
\tcode{f<int>(int*)}
has a static variable
\tcode{s}
of type
\tcode{int}
and
\tcode{f<char*>(char**)}
has a static variable
\tcode{s}
of type
\tcode{char*}.
\exitexample

\rSec2[temp.arg.explicit]{Explicit template argument specification}

\pnum
\indextext{specification!template argument}%
Template arguments can be specified when referring to a function
template specialization by qualifying the function template
name with the list of
\grammarterm{template-argument}{s}
in the same way as
\grammarterm{template-argument}{s}
are specified in uses of a class template specialization.
\enterexample

\begin{codeblock}
template<class T> void sort(Array<T>& v);
void f(Array<dcomplex>& cv, Array<int>& ci) {
  sort<dcomplex>(cv);           // \tcode{sort(Array<dcomplex>\&)}
  sort<int>(ci);                // \tcode{sort(Array<int>\&)}
}
\end{codeblock}

and

\begin{codeblock}
template<class U, class V> U convert(V v);

void g(double d) {
  int i = convert<int,double>(d);       // \tcode{int convert(double)}
  char c = convert<char,double>(d);     // \tcode{char convert(double)}
}
\end{codeblock}
\exitexample

\pnum
A template argument list may be specified when referring to a specialization
of a function template

\begin{itemize}
\item
when a function is called,
\item
when the address of a function is taken, when a function initializes a
reference to function, or when a pointer to member function is formed,
\item
in an explicit specialization,
\item
in an explicit instantiation, or
\item
in a friend declaration.
\end{itemize}

\pnum
Trailing template arguments that can be deduced~(\ref{temp.deduct}) or
obtained from default
\grammarterm{template-argument}{s}
may be omitted from the list of explicit
\grammarterm{template-argument}{s}.
A trailing template parameter pack~(\ref{temp.variadic}) not otherwise deduced will be
deduced to an empty sequence of template arguments.
If all of the template arguments can be deduced, they may all be omitted;
in this case, the empty template argument list
\tcode{<>}
itself may also be omitted.
In contexts where deduction is done and fails, or in contexts where
deduction is not done, if a template argument list is specified and it,
along with any default template arguments, identifies a single function
template specialization, then the
\grammarterm{template-id}
is an lvalue for the function template specialization.
\enterexample

\begin{codeblock}
template<class X, class Y> X f(Y);
template<class X, class Y, class ... Z> X g(Y);
void h() {
  int i = f<int>(5.6);          // \tcode{Y} is deduced to be \tcode{double}
  int j = f(5.6);               // ill-formed: \tcode{X} cannot be deduced
  f<void>(f<int, bool>);        // \tcode{Y} for outer \tcode{f} deduced to be
                                // \tcode{int (*)(bool)}
  f<void>(f<int>);              // ill-formed: \tcode{f<int>} does not denote a
                                // single function template specialization
  int k = g<int>(5.6);          // \tcode{Y} is deduced to be double, \tcode{Z} is deduced to an empty sequence
  f<void>(g<int, bool>);        // \tcode{Y} for outer \tcode{f} is deduced to be
                                // \tcode{int (*)(bool)}, \tcode{Z} is deduced to an empty sequence
}
\end{codeblock}
\exitexample

\pnum
\enternote
An empty template argument list can be used to indicate that a given
use refers to a specialization of a function template even when a
non-template function~(\ref{dcl.fct}) is visible that would otherwise be used.
For example:

\begin{codeblock}
template <class T> int f(T);    // \#1
int f(int);                     // \#2
int k = f(1);                   // uses \#2
int l = f<>(1);                 // uses \#1
\end{codeblock}
\exitnote

\pnum
Template arguments that are present shall be specified in the declaration
order of their corresponding
\grammarterm{template-parameter}{s}.
The template argument list shall not specify more
\grammarterm{template-argument}{s}
than there are corresponding
\grammarterm{template-parameter}{s}
unless one of the \grammarterm{template-parameter}{s} is a template
parameter pack.
\enterexample

\begin{codeblock}
template<class X, class Y, class Z> X f(Y,Z);
template<class ... Args> void f2();
void g() {
  f<int,const char*,double>("aa",3.0);
  f<int,const char*>("aa",3.0);       // \tcode{Z} is deduced to be \tcode{double}
  f<int>("aa",3.0);             // \tcode{Y} is deduced to be \tcode{const char*}, and
                                // \tcode{Z} is deduced to be \tcode{double}
  f("aa",3.0);                  // error: \tcode{X} cannot be deduced
  f2<char, short, int, long>(); // OK
}
\end{codeblock}
\exitexample

\pnum
Implicit conversions (Clause~\ref{conv}) will be performed on a function argument
to convert it to the type of the corresponding function parameter if
the parameter type contains no
\grammarterm{template-parameter}{s}
that participate in template argument deduction.
\enternote
Template parameters do not participate in template argument deduction if
they are explicitly specified.
For example,

\begin{codeblock}
template<class T> void f(T);

class Complex {
  Complex(double);
};

void g() {
  f<Complex>(1);                // OK, means \tcode{f<Complex>(Complex(1))}
}
\end{codeblock}
\exitnote

\pnum
\enternote
Because the explicit template argument list follows the function
template name, and because conversion member function templates and
constructor member function templates are called without using a
function name, there is no way to provide an explicit template
argument list for these function templates.
\exitnote
% L7048 USA Core3 1.18 / 14.8.1 [temp.arg.explicit]
% WG21 decided not to address this issue except to document that
% argument-dependent lookup does not apply in this context.

\pnum
\enternote
For simple function names, argument dependent lookup~(\ref{basic.lookup.argdep})
applies even when the function name is not visible within the scope of the call.
This is because the call still has the syntactic form of a function call~(\ref{basic.lookup.unqual}).
But when a function template with explicit template arguments is used,
the call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call.
If no such name is visible,
the call is not syntactically well-formed and argument-dependent lookup
does not apply.
If some such name is visible,
argument dependent lookup applies and additional function templates
may be found in other namespaces.
\enterexample

% Argument added to f per Usenet posting from martin von Loewis, 6 Sep 1998
\begin{codeblock}
namespace A {
  struct B { };
  template<int X> void f(B);
}
namespace C {
  template<class T> void f(T t);
}
void g(A::B b) {
  f<3>(b);                      // ill-formed: not a function call
  A::f<3>(b);                   // well-formed
  C::f<3>(b);                   // ill-formed; argument dependent lookup
                                // applies only to unqualified names
  using C::f;
  f<3>(b);                      // well-formed because \tcode{C::f} is visible; then
                                // \tcode{A::f} is found by argument dependent lookup
}
\end{codeblock}
\exitexample
\exitnote

\pnum
Template argument deduction can extend the sequence of template
arguments corresponding to a template parameter pack, even when the
sequence contains explicitly specified template arguments.
\enterexample
\begin{codeblock}
template<class ... Types> void f(Types ... values);

void g() {
  f<int*, float*>(0, 0, 0);     // \tcode{Types} is deduced to the sequence \tcode{int*}, \tcode{float*}, \tcode{int}
}
\end{codeblock}
\exitexample

\rSec2[temp.deduct]{Template argument deduction}

\pnum
When a
function template
specialization is referenced, all of the
template arguments shall have values.
The values can be
explicitly specified or, in some cases, be deduced from the use
or obtained from default
\grammarterm{template-argument}{s}.
\enterexample

\begin{codeblock}
void f(Array<dcomplex>& cv, Array<int>& ci) {
  sort(cv);                     // calls \tcode{sort(Array<dcomplex>\&)}
  sort(ci);                     // calls \tcode{sort(Array<int>\&)}
}
\end{codeblock}

and

\begin{codeblock}
void g(double d) {
  int i = convert<int>(d);      // calls \tcode{convert<int,double>(double)}
  int c = convert<char>(d);     // calls \tcode{convert<char,double>(double)}
}
\end{codeblock}
\exitexample

\pnum
When an explicit template argument list is specified, the template
arguments must be compatible with the template parameter list and must
result in a valid function type as described below; otherwise type
deduction fails.  Specifically, the following steps are performed when
evaluating an explicitly specified template argument list with respect
to a given function template:

\begin{itemize}
\item The specified template arguments must match the template parameters in
kind (i.e., type, non-type, template). There
must not be more arguments than there are parameters
unless at least one parameter is a template parameter pack, and there shall be
an argument for each non-pack parameter.
Otherwise, type deduction fails.

\item Non-type arguments must match the types of the corresponding non-type
template parameters, or must be convertible to the types of the
corresponding non-type parameters as specified in~\ref{temp.arg.nontype}, otherwise type deduction fails.

\item The specified template argument values are substituted for the
corresponding template parameters as specified below.
\end{itemize}

\pnum
After this substitution is performed, the function parameter type
adjustments described in~\ref{dcl.fct} are performed.
\enterexample
A parameter type of ``\tcode{void ()(const int, int[5])}'' becomes
``\tcode{void(*)(int,int*)}''.
\exitexample
\enternote
A top-level qualifier in a function parameter declaration does not affect
the function type but still affects the type of the function parameter
variable within the function.
\exitnote
\enterexample

\begin{codeblock}
template <class T> void f(T t);
template <class X> void g(const X x);
template <class Z> void h(Z, Z*);

int main() {
  // \#1: function type is \tcode{f(int)}, \tcode{t} is non \tcode{const}
  f<int>(1);

  // \#2: function type is \tcode{f(int)}, \tcode{t} is \tcode{const}
  f<const int>(1);

  // \#3: function type is \tcode{g(int)}, \tcode{x} is \tcode{const}
  g<int>(1);

  // \#4: function type is \tcode{g(int)}, \tcode{x} is \tcode{const}
  g<const int>(1);

  // \#5: function type is \tcode{h(int, const int*)}
  h<const int>(1,0);
}
\end{codeblock}
\exitexample

\pnum
\enternote
\tcode{f<int>(1)} and \tcode{f<const int>(1)} call distinct functions
even though both of the functions called have the same function type.
\exitnote

\pnum
The resulting substituted and adjusted function type is used as
the type of the function template for template argument
deduction.  If a template argument has not been deduced and its
corresponding template parameter has a default argument, the
template argument is determined by substituting the template 
arguments determined for preceding template parameters into the
default argument. If the substitution results in an invalid type,
as described above, type deduction fails.
\enterexample
\begin{codeblock}
template <class T, class U = double>
void f(T t = 0, U u = 0);

void g() {
  f(1, 'c');        // \tcode{f<int,char>(1,'c')}
  f(1);             // \tcode{f<int,double>(1,0)}
  f();              // error: \tcode{T} cannot be deduced
  f<int>();         // \tcode{f<int,double>(0,0)}
  f<int,char>();    // \tcode{f<int,char>(0,0)}
}
\end{codeblock}
\exitexample

When all template arguments have been deduced or obtained from
default template arguments, all uses of template parameters in
the template parameter list of the template and the function type
are replaced with the corresponding deduced
or default argument values. If the substitution results in an
invalid type, as described above, type deduction fails.

\pnum
At certain points in the template argument deduction process it is necessary
to take a function type that makes use of template parameters and replace those
template parameters with the corresponding template arguments. This is done at
the beginning of template argument deduction when any explicitly specified
template arguments are substituted into the function type, and again at the end
of template argument deduction when any template arguments that were deduced or
obtained from default arguments are substituted.

\pnum
The substitution occurs in all types and expressions that are used in the function
type and in template parameter declarations. The expressions include not only
constant expressions such as those that appear in array bounds or as nontype
template arguments but also general expressions (i.e., non-constant expressions)
inside \tcode{sizeof}, \tcode{decltype}, and other contexts that allow non-constant
expressions. The substitution proceeds in lexical order and stops when
a condition that causes deduction to fail is encountered. \enternote The equivalent substitution in exception specifications is
done only when the \grammarterm{exception-specification} is instantiated, at which point a program is ill-formed
if the substitution results in an invalid type or
expression. \exitnote
\enterexample
\begin{codeblock}
template <class T> struct A { using X = typename T::X; };
template <class T> typename T::X f(typename A<T>::X);
template <class T> void f(...) { }
template <class T> auto g(typename A<T>::X) -> typename T::X;
template <class T> void g(...) { }

void h() {
  f<int>(0); // OK, substituting return type causes deduction to fail
  g<int>(0); // error, substituting parameter type instantiates \tcode{A<int>}
}
\end{codeblock}
\exitexample

\pnum
If a substitution results in an invalid type or expression, type deduction fails. An
invalid type or expression is one that would be ill-formed, with a diagnostic
required, if written using the substituted arguments. \enternote If no
diagnostic is required, the program is still ill-formed. Access checking is done
as part of the substitution
process. \exitnote Only invalid types and expressions in the immediate
context of the function type and its template parameter types can result in a deduction
failure. \enternote The evaluation of the substituted types and expressions can result
in side effects such as the instantiation of class template specializations and/or
function template specializations, the generation of implicitly-defined functions,
etc. Such side effects are not in the ``immediate context'' and can result in the
program being ill-formed.\exitnote

\enterexample
\begin{codeblock}
struct X { };
struct Y {
  Y(X){}
};

template <class T> auto f(T t1, T t2) -> decltype(t1 + t2); // \#1
X f(Y, Y);  // \#2

X x1, x2;
X x3 = f(x1, x2);  // deduction fails on \#1 (cannot add \tcode{X+X}), calls \#2\end{codeblock}
\exitexample

\enternote Type deduction may fail for
the following reasons:

\begin{itemize}
\item Attempting to instantiate a pack expansion containing multiple parameter packs of differing lengths.
\item
Attempting to create an array with an element type that is \tcode{void}, a
function type, a reference type, or an abstract class type, or attempting
to create an array with a size that is zero or negative.
\enterexample

\begin{codeblock}
template <class T> int f(T[5]);
int I = f<int>(0);
int j = f<void>(0);             // invalid array
\end{codeblock}
\exitexample
\item
Attempting to use a type that is not a class or enumeration type in a qualified name.
\enterexample

\begin{codeblock}
template <class T> int f(typename T::B*);
int i = f<int>(0);
\end{codeblock}
\exitexample
\item
Attempting to use a type in a \grammarterm{nested-name-specifier} of a
\grammarterm{qualified-id} when
that type does not contain the specified member, or
\begin{itemize}
\item
the specified member is not a type where a type is required, or
\item
the specified member is not a template where a template is required, or
\item
the specified member is not a non-type where a non-type is required.
\end{itemize}
\enterexample

\begin{codeblock}
template <int I> struct X { };
template <template <class T> class> struct Z { };
template <class T> void f(typename T::Y*){}
template <class T> void g(X<T::N>*){}
template <class T> void h(Z<T::template TT>*){}
struct A {};
struct B { int Y; };
struct C {
  typedef int N;
};
struct D {
  typedef int TT;
};

int main() {
  // Deduction fails in each of these cases:
  f<A>(0);  // \tcode{A} does not contain a member \tcode{Y}
  f<B>(0);  // The \tcode{Y} member of \tcode{B} is not a type
  g<C>(0);  // The \tcode{N} member of \tcode{C} is not a non-type
  h<D>(0);  // The \tcode{TT} member of \tcode{D} is not a template
}
\end{codeblock}
\exitexample
\item
Attempting to create a pointer to reference type.
\item
Attempting to create a reference to \tcode{void}.
\item
Attempting to create ``pointer to member of \tcode{T}'' when \tcode{T} is not a
class type.
\enterexample

\begin{codeblock}
template <class T> int f(int T::*);
int i = f<int>(0);
\end{codeblock}
\exitexample
\item
Attempting to give an invalid type to a non-type template parameter.
\enterexample
\begin{codeblock}
template <class T, T> struct S {};
template <class T> int f(S<T, T()>*);
struct X {};
int i0 = f<X>(0);
\end{codeblock}
\exitexample

\item
Attempting to perform an invalid conversion in either a template
argument expression, or an expression used in the function
declaration.
\enterexample

\begin{codeblock}
template <class T, T*> int f(int);
int i2 = f<int,1>(0);           // can't conv \tcode{1} to \tcode{int*}
\end{codeblock}
\exitexample

\item
Attempting to create a function type in which a parameter has a type
of \tcode{void}, or in which the return type is a function type
or array type.

\item
Attempting to create a function type in which a parameter type or the return type is an
abstract class type~(\ref{class.abstract}).
\end{itemize}
\exitnote

\pnum
Except as described above, the use of an invalid value shall not cause
type deduction to fail.
\enterexample
In the following example 1000 is converted to \tcode{signed char} and results
in an implementation-defined value as specified in~(\ref{conv.integral}).
In other words, both templates are considered even though 1000,
when converted to \tcode{signed char}, results in an implementation-defined
value.

\begin{codeblock}
template <int> int f(int);
template <signed char> int f(int);
int i1 = f<1>(0);               // ambiguous
int i2 = f<1000>(0);            // ambiguous
\end{codeblock}
\exitexample

\rSec3[temp.deduct.call]{Deducing template arguments from a function call}

\pnum
Template argument deduction is done by comparing each function
template parameter type (call it
\tcode{P})
with the type of the corresponding argument of the call (call it
\tcode{A})
as described below.
If removing references and cv-qualifiers from \tcode{P} gives
\tcode{std::initializer_list<$P^\prime$>} for some \tcode{$P^\prime$} and the
argument is an initializer list~(\ref{dcl.init.list}), then deduction is
performed instead for each element of the initializer list, taking
\tcode{$P^\prime$} as a function template parameter type and the initializer
element as its argument. Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context~(\ref{temp.deduct.type}).
\enterexample
\begin{codeblock}
template<class T> void f(std::initializer_list<T>);
f({1,2,3});                 // \tcode{T} deduced to \tcode{int}
f({1,"asdf"});              // error: \tcode{T} deduced to both \tcode{int} and \tcode{const char*}

template<class T> void g(T);
g({1,2,3});                 // error: no argument deduced for \tcode{T}
\end{codeblock}
\exitexample
For a function parameter pack that occurs at the end of the \grammarterm{parameter-declaration-list},
the type \tcode{A} of each
remaining argument of the call is compared with the type \tcode{P}
of the \grammarterm{declarator-id} of the function parameter pack.
Each comparison deduces template arguments for subsequent positions in
the template parameter packs expanded by the function parameter pack.
When a function parameter pack appears in a non-deduced
context~(\ref{temp.deduct.type}), the type of that parameter pack is
never deduced.
\enterexample

\begin{codeblock}
template<class ... Types> void f(Types& ...);
template<class T1, class ... Types> void g(T1, Types ...);
template<class T1, class ... Types> void g1(Types ..., T1);

void h(int x, float& y) {
  const int z = x;
  f(x, y, z);                  // \tcode{Types} is deduced to \tcode{int}, \tcode{float}, \tcode{const int}
  g(x, y, z);                  // \tcode{T1} is deduced to \tcode{int}; \tcode{Types} is deduced to \tcode{float}, \tcode{int}
  g1(x, y, z);                 // error: \tcode{Types} is not deduced
  g1<int, int, int>(x, y, z);  // OK, no deduction occurs

}
\end{codeblock}

\exitexample

\pnum
If
\tcode{P}
is not a reference type:

\begin{itemize}
\item
If
\tcode{A}
is an array type, the pointer type produced by the array-to-pointer
standard conversion~(\ref{conv.array}) is used in place of
\tcode{A}
for type deduction;
otherwise,
\item
If
\tcode{A}
is a function type, the pointer type produced by the
function-to-pointer standard conversion~(\ref{conv.func}) is used in place
of
\tcode{A}
for type
deduction; otherwise,
\item
If
\tcode{A}
is a cv-qualified type, the top level cv-qualifiers of
\tcode{A}'s
type are ignored for type deduction.
\end{itemize}

\pnum
If
\tcode{P}
is a cv-qualified type, the top level cv-qualifiers of
\tcode{P}'s
type are ignored for type deduction.
If
\tcode{P}
is a reference type, the type
referred to by
\tcode{P}
is used for type deduction.
If \tcode{P} is an rvalue reference to a cv-unqualified template parameter and the argument is an
lvalue, the type ``lvalue reference to \tcode{A}'' is used in place of \tcode{A} for type
deduction. \enterexample
\begin{codeblock}
template <class T> int f(T&&);
template <class T> int g(const T&&);
int i;
int n1 = f(i);                  // calls \tcode{f<int\&>(int\&)}
int n2 = f(0);                  // calls \tcode{f<int>(int\&\&)}
int n3 = g(i);                  // error: would call \tcode{g<int>(const int\&\&)}, which
                                // would bind an rvalue reference to an lvalue
\end{codeblock}
\exitexample

\pnum
In general, the deduction process attempts to find template argument
values that will make the deduced
\tcode{A}
identical to
\tcode{A}
(after
the type
\tcode{A}
is transformed as described above).
However, there are
three cases that allow a difference:

\begin{itemize}
\item
If the original
\tcode{P}
is a reference type, the deduced
\tcode{A}
(i.e.,
the type referred to by the reference) can be more cv-qualified than
the transformed \tcode{A}.
\item
The transformed \tcode{A}
can be another pointer or pointer to member type that can be converted
to the deduced
\tcode{A}
via a qualification conversion~(\ref{conv.qual}).

\item
If
\tcode{P}
is a class and
\tcode{P}
has the form
\grammarterm{simple-template-id},
then
the transformed \tcode{A}
can be a derived class of the
deduced
\tcode{A}.
Likewise, if
\tcode{P}
is a pointer to a class of the form
\grammarterm{simple-template-id},
the transformed \tcode{A}
can be a pointer to a
derived class pointed to by the deduced
\tcode{A}.
\end{itemize}

\enternote as specified in~\ref{temp.arg.explicit}, implicit conversions will be
performed on a function argument to convert it to the type of the corresponding
function parameter if the parameter contains no \grammarterm{template-parameter}{s}
that participate in template argument deduction. Such conversions are also
allowed, in addition to the ones described in the preceding list. \exitnote

\pnum
These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
\tcode{A},
the type deduction fails.
\enternote
If a
\grammarterm{template-parameter}
is not used in any of the function parameters of a function template,
or is used only in a non-deduced context, its corresponding
\grammarterm{template-argument}
cannot be deduced from a function call and the
\grammarterm{template-argument}
must be explicitly specified.
\exitnote

\pnum
When P is a function type, pointer to function type, or pointer to member
function type:
\begin{itemize}
\item
If the argument is an overload set containing one or more function templates,
the parameter is treated as a non-deduced context.
\item
If the argument is an overload set (not containing function templates), trial
argument deduction is attempted using each of the members of the set. If
deduction succeeds for only one of the overload set members, that member is
used as the argument value for the deduction. If deduction succeeds for more than
one member of the overload set the parameter is treated as a non-deduced context.

\pnum
\enterexample
\begin{codeblock}
// Only one function of an overload set matches the call so the function
// parameter is a deduced context.
template <class T> int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g);       // calls \tcode{f(int (*)(int))}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// Ambiguous deduction causes the second function parameter to be a
// non-deduced context.
template <class T> int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g);    // calls \tcode{f(int, int (*)(int))}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// The overload set contains a template, causing the second function
// parameter to be a non-deduced context.
template <class T> int f(T, T (*p)(T));
char g(char);
template <class T> T g(T);
int i = f(1, g);    // calls \tcode{f(int, int (*)(int))}
\end{codeblock}
\exitexample
\end{itemize}

\rSec3[temp.deduct.funcaddr]{Deducing template arguments taking the address of a function template}

\pnum
Template arguments can be deduced from the type specified when taking
the address of an overloaded function~(\ref{over.over}).
The function template's function type and the specified type
are used as the types of
\tcode{P}
and
\tcode{A},
and the deduction is done as
described in~\ref{temp.deduct.type}.

\pnum
A placeholder type~(\ref{dcl.spec.auto}) in the return type of a
function template is a non-deduced context. If template argument
deduction succeeds for such a function, the return type is determined
from instantiation of the function body.

\rSec3[temp.deduct.conv]{Deducing conversion function template arguments}

\pnum
Template argument deduction is done by comparing the return type of
the
conversion function template
(call it
\tcode{P})
with the type that is
required as the result of the conversion (call it
\tcode{A}; see~\ref{dcl.init}, \ref{over.match.conv}, and \ref{over.match.ref}
for the determination of that type)
as described in~\ref{temp.deduct.type}.

\pnum
If \tcode{P} is a reference type, the type referred to by \tcode{P} is used in place
of \tcode{P} for type deduction and for any further references to or transformations of
\tcode{P} in the remainder of this section.

\pnum
If
\tcode{A}
is not a reference type:

\begin{itemize}
\item
If
\tcode{P}
is an array type, the pointer type produced by the
array-to-pointer standard conversion~(\ref{conv.array}) is used in place of
\tcode{P}
for type
deduction; otherwise,
\item
If
\tcode{P}
is a function type, the pointer type produced by the
function-to-pointer standard conversion~(\ref{conv.func}) is used in place of
\tcode{P}
for
type deduction; otherwise,
\item
If
\tcode{P}
is a cv-qualified type, the top level cv-qualifiers of
\tcode{P}'s
type are ignored for type deduction.
\end{itemize}

\pnum
If
\tcode{A}
is a cv-qualified type, the top level cv-qualifiers of
\tcode{A}'s
type are ignored for type deduction.
If
\tcode{A}
is a
reference type, the type referred to by
\tcode{A}
is used for type deduction.

\pnum
In general, the deduction process attempts to find template argument
values that will make the deduced
\tcode{A}
identical to
\tcode{A}.
However, there are two cases that allow a difference:

\begin{itemize}
\item
If the original
\tcode{A}
is a reference type,
\tcode{A}
can be more cv-qualified
than the deduced
\tcode{A}
(i.e., the type referred to by the reference)
\item
The deduced
\tcode{A}
can be another pointer or pointer to member type that
can be converted to
\tcode{A}
via a qualification conversion.
\end{itemize}

\pnum
These alternatives are considered only if type deduction would
otherwise fail.
If they yield more than one possible deduced
\tcode{A},
the type deduction fails.

\pnum
When the deduction process requires a qualification conversion for a
pointer or pointer to member type as described above, the following
process is used to determine the deduced template argument values:

If
\tcode{A}
is a type
\begin{indented}
$\mathit{cv}_{1,0}$ ``pointer to $\ldots$'' $\mathit{cv}_{1,n-1}$ ``pointer to''
$\mathit{cv}_{1,n}\mathit{T1}$
\end{indented}
and
\tcode{P}
is a type
\begin{indented}
$\mathit{cv}_{2,0}$ ``pointer to $\ldots$'' $\mathit{cv}_{2,n-1}$ ``pointer to''
$\mathit{cv}_{2,n}\mathit{T2}$
\end{indented}
The cv-unqualified
\tcode{T1}
and
\tcode{T2}
are used as the types of
\tcode{A}
and
\tcode{P}
respectively for type deduction.
\enterexample
\begin{codeblock}
struct A {
  template <class T> operator T***();
};
A a;
const int * const * const * p1 = a;     // \tcode{T} is deduced as \tcode{int}, not \tcode{const int}
\end{codeblock}
\exitexample

\rSec3[temp.deduct.partial]{Deducing template arguments during partial ordering}

\pnum
Template argument deduction is done by comparing certain types associated with
the two function templates being compared.

\pnum
Two sets of types are used to determine the partial ordering.  For each of
the templates involved there is the original function type and the
transformed function type.
\enternote
The creation of the transformed type is described in~\ref{temp.func.order}.
\exitnote
The deduction process uses the
transformed type as the argument template and the original type of the
other template as the parameter template.  This process is done twice
for each type involved in the partial ordering comparison: once using
the transformed template-1 as the argument template and template-2 as
the parameter template and again using the transformed template-2 as
the argument template and template-1 as the parameter template.

\pnum
The types used to determine the ordering depend on the context in which
the partial ordering is done:

\begin{itemize}
\item
In the context of a function call, the types used are those function parameter types
for which the function call has arguments.\footnote{Default arguments
are not considered to be arguments in this context; they only become arguments
after a function has been selected.}
\item
In the context of a call to a conversion function, the return types of
the conversion function templates are used.
\item
In other contexts~(\ref{temp.func.order}) the function template's function
type is used.
\end{itemize}

\pnum
Each type nominated above from the parameter template and the corresponding type from the
argument template are used as the types of
\tcode{P}
and
\tcode{A}.

\pnum
Before the partial ordering is done, certain transformations are performed
on the types used for partial ordering:

\begin{itemize}
\item
If
\tcode{P}
is a reference type,
\tcode{P}
is replaced by the type referred to.
\item
If
\tcode{A}
is a reference type,
\tcode{A}
is replaced by the type referred to.
\end{itemize}

\pnum
If both
\tcode{P}
and
\tcode{A}
were reference types (before being replaced with the type referred to
above), determine which of the two types (if any) is more cv-qualified
than the other; otherwise the types are considered to be equally
cv-qualified for partial ordering purposes. The result of this
determination will be used below.

\pnum
Remove any top-level cv-qualifiers:
\begin{itemize}
\item
If
\tcode{P}
is a cv-qualified type,
\tcode{P}
is replaced by the cv-unqualified version of
\tcode{P}.
\item
If
\tcode{A}
is a cv-qualified type,
\tcode{A}
is replaced by the cv-unqualified version of
\tcode{A}.
\end{itemize}

\pnum
If \tcode{A} was transformed from a function parameter pack and \tcode{P} is not
a parameter pack, type deduction fails. Otherwise, using
the resulting types
\tcode{P}
and
\tcode{A},
the deduction is then done as described in~\ref{temp.deduct.type}.
If \tcode{P} is a function parameter pack, the type \tcode{A} of each remaining
parameter type of the argument template is compared with the type \tcode{P} of
the \grammarterm{declarator-id} of the function parameter pack. Each comparison
deduces template arguments for subsequent positions in the template parameter
packs expanded by the function parameter pack.
If deduction succeeds for a given type,
the type from the argument template is considered to be at least as specialized
as the type from the parameter template.
\enterexample
\begin{codeblock}
template<class... Args>           void f(Args... args);           // \#1
template<class T1, class... Args> void f(T1 a1, Args... args);    // \#2
template<class T1, class T2>      void f(T1 a1, T2 a2);           // \#3

f();                  // calls \#1
f(1, 2, 3);           // calls \#2
f(1, 2);              // calls \#3; non-variadic template \#3 is more
                      // specialized than the variadic templates \#1 and \#2
\end{codeblock}
\exitexample

\pnum
If, for a given type, deduction succeeds in both directions (i.e., the
types are identical after the transformations above)
and both \tcode{P} and \tcode{A} were reference types (before being replaced with the
type referred to above):

\begin{itemize}
\item if the type from the argument template was an lvalue reference and the type
from the parameter template was not, the argument type is considered to be
more specialized than the other; otherwise,

\item if the type from
the argument template is more cv-qualified than the type from the
parameter template (as described above), the argument type is considered to be
more specialized than the other; otherwise,

\item neither type is more specialized than the other.
\end{itemize}

\pnum
If for each type being considered a given template is at least as specialized
for all types and more specialized for some set of types and the
other template is not more specialized for any types or is not
at least as specialized for any types, then
the given template is more specialized than the other template.
Otherwise, neither template is more specialized than the other.

\pnum
In most cases, all template parameters must have values in order for
deduction to succeed, but for partial ordering purposes a template
parameter may remain without a value provided it is not used in the
types being used for partial ordering.
\enternote
A template parameter used in a non-deduced context is considered used.
\exitnote
\enterexample
\begin{codeblock}
template <class T> T f(int);        // \#1
template <class T, class U> T f(U); // \#2
void g() {
  f<int>(1);        // calls \#1
}
\end{codeblock}
\exitexample

\pnum
\enternote Partial ordering of function templates containing
template parameter packs is independent of the number of deduced arguments
for those template parameter packs. \exitnote \enterexample

\begin{codeblock}
template<class ...> struct Tuple { };
template<class ... Types> void g(Tuple<Types ...>);                 // \#1
template<class T1, class ... Types> void g(Tuple<T1, Types ...>);   // \#2
template<class T1, class ... Types> void g(Tuple<T1, Types& ...>);  // \#3

g(Tuple<>());                   // calls \#1
g(Tuple<int, float>());         // calls \#2
g(Tuple<int, float&>());        // calls \#3
g(Tuple<int>());                // calls \#3
\end{codeblock}

\exitexample

\rSec3[temp.deduct.type]{Deducing template arguments from a type}

\pnum
Template arguments can be deduced in several different contexts, but
in each case a type that is specified in terms of template parameters
(call it
\tcode{P})
is compared with an actual type (call it
\tcode{A}),
and an attempt is made to find template argument values (a type for a type
parameter, a value for a non-type parameter, or a template for a
template parameter) that will make
\tcode{P},
after substitution of the deduced values (call it the deduced
\tcode{A}),
compatible with
\tcode{A}.

\pnum
In some cases, the deduction is done using a single set of types
\tcode{P}
and
\tcode{A},
in other cases, there will be a set of corresponding types
\tcode{P}
and
\tcode{A}.
Type deduction is done
independently for each
\tcode{P/A}
pair, and the deduced template
argument values are then combined.
If type deduction cannot be done
for any
\tcode{P/A}
pair, or if for any pair the deduction leads to more than
one possible set of deduced values, or if different pairs yield
different deduced values, or if any template argument remains neither
deduced nor explicitly specified, template argument deduction fails.

\pnum
A given type
\tcode{P}
can be composed from a number of other
types, templates, and non-type values:

\begin{itemize}
\item
A function type includes the types of each of the function parameters
and the return type.
\item
A pointer to member type includes the type of the class object pointed to
and the type of the member pointed to.
\item
A type that is a specialization of a class template (e.g.,
\tcode{A<int>})
includes the types, templates, and non-type values referenced by the
template argument list of the specialization.
\item
An array type includes the array element type and the value of the
array bound.
\end{itemize}

\pnum
In most cases, the types, templates, and non-type values that are used
to compose
\tcode{P}
participate in template argument deduction.
That is,
they may be used to determine the value of a template argument, and
the value so determined must be consistent with the values determined
elsewhere.
In certain contexts, however, the value does not
participate in type deduction, but instead uses the values of template
arguments that were either deduced elsewhere or explicitly specified.
If a template parameter is used only in non-deduced contexts and is not
explicitly specified, template argument deduction fails.

\pnum
The non-deduced contexts are:

\indextext{context!non-deduced}%
\begin{itemize}
\item
The
\grammarterm{nested-name-specifier}
of a type that was specified using a
\grammarterm{qualified-id}.
\item
The \grammarterm{expression} of a \grammarterm{decltype-specifier}.
\item
A non-type template argument or an array bound in which a subexpression
references a template parameter.
\item
A template parameter used in the parameter type of a function parameter that
has a default argument that is being used in the call for which argument
deduction is being done.
\item
A function parameter for which argument deduction cannot be done because the
associated function argument is a function, or a set of overloaded
functions~(\ref{over.over}), and one or more of the following apply:
\begin{itemize}
\item
more than one function matches the function parameter type (resulting in
an ambiguous deduction), or
\item
no function matches the function parameter type, or
\item
the set of functions supplied as an argument contains one or more function templates.
\end{itemize}
\item A function parameter for which the associated argument is an initializer
list~(\ref{dcl.init.list}) but the parameter does not have
\tcode{std::initializer_list} or reference to possibly cv-qualified
\tcode{std::initializer_list} type. \enterexample
\begin{codeblock}
template<class T> void g(T);
g({1,2,3});                 // error: no argument deduced for \tcode{T}
\end{codeblock}
\exitexample
\item A function parameter pack that does not occur at the end of the 
\grammarterm{parameter-declaration-list}.
\end{itemize}

\pnum
When a type name is specified in a way that includes a non-deduced
context, all of the types that comprise that type name are also
non-deduced.
However, a compound type can include both deduced and non-deduced types.
\enterexample
If a type is specified as
\tcode{A<T>::B<T2>},
both
\tcode{T}
and
\tcode{T2}
are non-deduced.
Likewise, if a type is specified as
\tcode{A<I+J>::X<T>},
\tcode{I},
\tcode{J},
and
\tcode{T}
are non-deduced.
If a type is specified as
\tcode{void}
\tcode{f(typename}
\tcode{A<T>::B,}
\tcode{A<T>)},
the
\tcode{T}
in
\tcode{A<T>::B}
is non-deduced but
the
\tcode{T}
in
\tcode{A<T>}
is deduced.
\exitexample

\pnum
\enterexample
Here is an example in which different parameter/argument pairs produce
inconsistent template argument deductions:

\begin{codeblock}
template<class T> void f(T x, T y) { /* ... */ }
struct A { /* ... */ };
struct B : A { /* ... */ };
void g(A a, B b) {
  f(a,b);           // error: \tcode{T} could be \tcode{A} or \tcode{B}
  f(b,a);           // error: \tcode{T} could be \tcode{A} or \tcode{B}
  f(a,a);           // OK: \tcode{T} is \tcode{A}
  f(b,b);           // OK: \tcode{T} is \tcode{B}
}
\end{codeblock}

Here is an example where two template arguments are deduced from a
single function parameter/argument pair.
This can lead to conflicts
that cause type deduction to fail:

\begin{codeblock}
template <class T, class U> void f(  T (*)( T, U, U )  );

int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);

void r() {
  f(g1);            // OK: \tcode{T} is \tcode{int} and \tcode{U} is \tcode{float}
  f(g2);            // error: \tcode{T} could be \tcode{char} or \tcode{int}
  f(g3);            // error: \tcode{U} could be \tcode{char} or \tcode{float}
}
\end{codeblock}

Here is an example where a qualification conversion applies between the
argument type on the function call and the deduced template argument type:

\begin{codeblock}
template<class T> void f(const T*) { }
int* p;
void s() {
  f(p);             // \tcode{f(const int*)}
}
\end{codeblock}

Here is an example where the template argument is used to instantiate
a derived class type of the corresponding function parameter type:

\begin{codeblock}
template <class T> struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int> {};
template <class T> void f(B<T>&){}
void t() {
  D<int> d;
  D2     d2;
  f(d);             // calls \tcode{f(B<int>\&)}
  f(d2);            // calls \tcode{f(B<int>\&)}
}
\end{codeblock}
\exitexample

\pnum
A template type argument
\tcode{T},
a template template argument
\tcode{TT}
or a template non-type argument
\tcode{i}
can be deduced if
\tcode{P}
and
\tcode{A}
have one of the following forms:

\begin{codeblock}
T
@\grammarterm{cv-list}@ T
T*
T&
T&&
T[@\grammarterm{integer-constant}@]
@\grammarterm{template-name}@<T>  (where @\grammarterm{template-name}@ refers to a class template)
@\term{type}@(T)
T()
T(T)
T @\term{type}@::*
@\term{type}@ T::*
T T::*
T (@\term{type}@::*)()
@\term{type}@ (T::*)()
@\term{type}@ (@\term{type}@::*)(T)
@\term{type}@ (T::*)(T)
T (@\term{type}@::*)(T)
T (T::*)()
T (T::*)(T)
@\term{type}@[i]
@\grammarterm{template-name}@<i>  (where @\grammarterm{template-name}@ refers to a class template)
TT<T>
TT<i>
TT<>
\end{codeblock}

where
\tcode{(T)}
represents
a \grammarterm{parameter-type-list}
where at least one parameter type contains a
\tcode{T},
and
\tcode{()}
represents
a \grammarterm{parameter-type-list}
where no parameter type contains a
\tcode{T}.
Similarly,
\tcode{<T>}
represents template argument lists where at least one argument contains a
\tcode{T},
\tcode{<i>}
represents template argument lists where at least one argument contains an
\tcode{i}
and
\tcode{<>}
represents template argument lists where no argument contains a
\tcode{T}
or an
\tcode{i}.

\pnum
If \tcode{P} has a form that contains \tcode{<T>}
or \tcode{<i>}, then each argument $\mathtt{P}_i$ of the
respective template argument list \tcode{P} is compared with the
corresponding argument $\mathtt{A}_i$ of the corresponding
template argument list of \tcode{A}. If the template argument list
of \tcode{P} contains a pack expansion that is not the last
template argument, the entire template argument list is a non-deduced
context. If $\texttt{P}_i$ is a pack expansion, then the pattern
of $\texttt{P}_i$ is compared with each remaining argument in the
template argument list of \tcode{A}. Each comparison deduces
template arguments for subsequent positions in the template parameter
packs expanded by $\texttt{P}_i$.
During partial ordering~(\ref{temp.deduct.partial}), if $\texttt{A}_i$ was
originally a pack expansion:

\begin{itemize}
\item if \tcode{P} does not contain a template argument corresponding to
$\texttt{A}_i$ then $\texttt{A}_i$ is ignored;

\item otherwise, if $\texttt{P}_i$ is not a pack expansion, template argument
deduction fails.
\end{itemize}
\enterexample
\begin{codeblock}
template<class T1, class... Z> class S;                               // \#1
template<class T1, class... Z> class S<T1, const Z&...> { };          // \#2
template<class T1, class T2>   class S<T1, const T2&> { };            // \#3
S<int, const int&> s;         // both \#2 and \#3 match; \#3 is more specialized

template<class T, class... U>            struct A { };                // \#1
template<class T1, class T2, class... U> struct A<T1, T2*, U...> { }; // \#2
template<class T1, class T2>             struct A<T1, T2> { };        // \#3
template struct A<int, int*>; // selects \#2
\end{codeblock}
\exitexample

\pnum
Similarly, if \tcode{P} has a form that contains
\tcode{(T)}, then each parameter type $\texttt{P}_i$
of the respective \grammarterm{parameter-type-list} of
\tcode{P} is compared with the corresponding parameter type
$\texttt{A}_i$ of the corresponding \grammarterm{parameter-type-list}
of \tcode{A}.
If \tcode{P} and \tcode{A} are function types that originated from deduction when
taking the address of a function template~(\ref{temp.deduct.funcaddr}) or when
deducing template arguments from a function declaration~(\ref{temp.deduct.decl})
and $\texttt{P}_i$ and $\texttt{A}_i$ are parameters of the top-level
\grammarterm{parameter-type-list} of \tcode{P} and \tcode{A}, respectively,
$\texttt{P}_i$ is adjusted if it is an rvalue reference to a cv-unqualified template
parameter and $\texttt{A}_i$ is an lvalue reference, in which case the type of
$\texttt{P}_i$ is changed to be the template parameter type (i.e., \tcode{T\&\&} is
changed to simply \tcode{T}). \enternote As a result, when $\texttt{P}_i$ is \tcode{T\&\&}
and $\texttt{A}_i$ is \tcode{X\&}, the adjusted $\texttt{P}_i$ will be \tcode{T},
causing \tcode{T} to be deduced as \tcode{X\&}. \exitnote
\enterexample
\begin{codeblock}
template <class T> void f(T&&);
template <> void f(int&) { }  // \#1
template <> void f(int&&) { } // \#2
void g(int i) {
  f(i);                       // calls \tcode{f<int\&>(int\&)}, i.e., \#1
  f(0);                       // calls \tcode{f<int>(int\&\&)}, i.e., \#2
}
\end{codeblock}
\exitexample

If the \grammarterm{parameter-declaration}
corresponding to $\texttt{P}_i$ is a function parameter pack,
then the type of its \grammarterm{declarator-id} is compared with
each remaining parameter type in the \grammarterm{parameter-type-list}
of \tcode{A}. Each comparison deduces template arguments for
subsequent positions in the template parameter packs expanded by the
function parameter pack.
During partial ordering~(\ref{temp.deduct.partial}), if $\texttt{A}_i$ was
originally a function parameter pack:

\begin{itemize}
\item if \tcode{P} does not contain a function parameter type corresponding to
$\texttt{A}_i$ then $\texttt{A}_i$ is ignored;

\item otherwise, if $\texttt{P}_i$ is not a function parameter pack, template
argument deduction fails.
\end{itemize}
\enterexample
\begin{codeblock}
template<class T, class... U> void f(T*, U...) { }    // \#1
template<class T>             void f(T) { }           // \#2
template void f(int*);      // selects \#1
\end{codeblock}
\exitexample

\pnum
These forms can be used in the same way as
\tcode{T}
is for further composition of types.
\enterexample

\begin{codeblock}
X<int> (*)(char[6])
\end{codeblock}

is of the form

\begin{codeblock}
@\grammarterm{template-name}@<T> (*)(@\term{type}@[i])
\end{codeblock}

which is a variant of

\begin{codeblock}
@\term{type}@ (*)(T)
\end{codeblock}

where type is
\tcode{X<int>}
and
\tcode{T}
is
\tcode{char[6]}.
\exitexample

\pnum
Template arguments cannot be deduced from function arguments involving
constructs other than the ones specified above.

\pnum
A template type argument cannot be deduced from the type of a non-type
\grammarterm{template-argument}.

\pnum
\enterexample
\begin{codeblock}
template<class T, T i> void f(double a[10][i]);
int v[10][20];
f(v);               // error: argument for template-parameter \tcode{T} cannot be deduced
\end{codeblock}
\exitexample

\pnum
\enternote
Except for reference and pointer types, a major array bound is not part of a
function parameter type and cannot be deduced from an argument:

\begin{codeblock}
template<int i> void f1(int a[10][i]);
template<int i> void f2(int a[i][20]);
template<int i> void f3(int (&a)[i][20]);

void g() {
  int v[10][20];
  f1(v);            // OK: \tcode{i} deduced to be \tcode{20}
  f1<20>(v);        // OK
  f2(v);            // error: cannot deduce template-argument \tcode{i}
  f2<10>(v);        // OK
  f3(v);            // OK: \tcode{i} deduced to be \tcode{10}
}
\end{codeblock}

\pnum
If, in the declaration of a function template with a non-type
template parameter, the non-type template parameter
is used in a subexpression in the function parameter list,
the expression is a non-deduced context as specified above.
\enterexample
\begin{codeblock}
template <int i> class A { /* ... */ };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {
  A<1> a1;
  A<2> a2;
  g(a1);            // error: deduction fails for expression \tcode{i+1}
  g<0>(a1);         // OK
  f(a1, a2);        // OK
}
\end{codeblock}
\exitexample
\exitnote
\enternote
Template parameters do not participate in template argument deduction if
they are used only in non-deduced contexts.
For example,

\begin{codeblock}
template<int i, typename T>
T deduce(typename A<T>::X x,    // \tcode{T} is not deduced here
  T t,                          // but \tcode{T} is deduced here
  typename B<i>::Y y);          // \tcode{i} is not deduced here
A<int> a;
B<77>  b;

int    x = deduce<77>(a.xm, 62, b.ym);
// \tcode{T} is deduced to be \tcode{int}, \tcode{a.xm} must be convertible to
// \tcode{A<int>::X}
// \tcode{i} is explicitly specified to be \tcode{77}, \tcode{b.ym} must be convertible
// to \tcode{B<77>::Y}
\end{codeblock}
\exitnote

\pnum
If \tcode{P} has a form that contains \tcode{<i>}, and if the type of the
corresponding value of \tcode{A} differs from the type of \tcode{i}, deduction
fails. If \tcode{P} has a form that contains \tcode{[i]}, and if the type of
\tcode{i} is not an integral type, deduction fails.\footnote{Although the
\grammarterm{template-argument}
corresponding to a
\grammarterm{template-parameter}
of type
\tcode{bool}
may be deduced from an array bound, the resulting value will always be
\tcode{true}
because the array bound will be non-zero.}
\enterexample

\begin{codeblock}
template<int i> class A { /* ... */ };
template<short s> void f(A<s>);
void k1() {
  A<1> a;
  f(a);             // error: deduction fails for conversion from \tcode{int} to \tcode{short}
  f<1>(a);          // OK
}

template<const short cs> class B { };
template<short s> void g(B<s>);
void k2() {
  B<1> b;
  g(b);             // OK: cv-qualifiers are ignored on template parameter types
}
\end{codeblock}
\exitexample

\pnum
A
\grammarterm{template-argument}
can be deduced from a function, pointer to function, or pointer to
member function type.

\enterexample

\begin{codeblock}
template<class T> void f(void(*)(T,int));
template<class T> void foo(T,int);
void g(int,int);
void g(char,int);

void h(int,int,int);
void h(char,int);
int m() {
  f(&g);            // error: ambiguous
  f(&h);            // OK: void \tcode{h(char,int)} is a unique match
  f(&foo);          // error: type deduction fails because \tcode{foo} is a template
}
\end{codeblock}
\exitexample

\pnum
A template
\grammarterm{type-parameter}
cannot be deduced from the type of a function default argument.
\enterexample

\begin{codeblock}
template <class T> void f(T = 5, T = 7);
void g() {
  f(1);             // OK: call \tcode{f<int>(1,7)}
  f();              // error: cannot deduce \tcode{T}
  f<int>();         // OK: call \tcode{f<int>(5,7)}
}
\end{codeblock}
\exitexample

\pnum
The
\grammarterm{template-argument}
corresponding to a template
\grammarterm{template-parameter}
is deduced from the type of the
\grammarterm{template-argument}
of a class template specialization used in the argument list of a function call.
\enterexample

\begin{codeblock}
template <template <class T> class X> struct A { };
template <template <class T> class X> void f(A<X>) { }
template<class T> struct B { };
A<B> ab;
f(ab);              // calls \tcode{f(A<B>)}
\end{codeblock}
\exitexample

\pnum
\enternote Template argument deduction involving parameter
packs~(\ref{temp.variadic}) can deduce zero or more arguments for
each parameter pack. \exitnote\enterexample

\begin{codeblock}
template<class> struct X { };
template<class R, class ... ArgTypes> struct X<R(int, ArgTypes ...)> { };
template<class ... Types> struct Y { };
template<class T, class ... Types> struct Y<T, Types& ...> { };

template<class ... Types> int f(void (*)(Types ...));
void g(int, float);

X<int> x1;                      // uses primary template
X<int(int, float, double)> x2;  // uses partial specialization; \tcode{ArgTypes} contains \tcode{float}, \tcode{double}
X<int(float, int)> x3;          // uses primary template
Y<> y1;                         // use primary template; \tcode{Types} is empty
Y<int&, float&, double&> y2;    // uses partial specialization; \tcode{T} is \tcode{int\&}, \tcode{Types} contains \tcode{float}, \tcode{double}
Y<int, float, double> y3;       // uses primary template; \tcode{Types} contains \tcode{int}, \tcode{float}, \tcode{double}
int fv = f(g);                  // OK; \tcode{Types} contains \tcode{int}, \tcode{float}
\end{codeblock}

\exitexample

\rSec3[temp.deduct.decl]{Deducing template arguments from a function declaration}

\pnum
In a declaration whose \grammarterm{declarator-id} refers to a specialization
of a function template, template argument deduction is performed to identify
the specialization to which the declaration refers. Specifically, this is done
for explicit instantiations~(\ref{temp.explicit}), explicit specializations~(\ref{temp.expl.spec}),
and certain friend declarations~(\ref{temp.friend}). This is also done to
determine whether a deallocation function template specialization matches a placement
\tcode{operator new}~(\ref{basic.stc.dynamic.deallocation},~\ref{expr.new}).
In all these cases, \tcode{P} is the type of the function template being considered
as a potential match and \tcode{A} is either the function type from the
declaration
or the type of the deallocation function that would match the placement
\tcode{operator new} as described in~\ref{expr.new}. The
deduction is done as described in~\ref{temp.deduct.type}.

\pnum
If, for the set of function templates so considered, there is either no match or
more than one match after partial ordering has been considered~(\ref{temp.func.order}),
deduction fails and, in the declaration cases, the
program is ill-formed.

\rSec2[temp.over]{Overload resolution}

\pnum
\indextext{overloading!resolution!function template}%
A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name.
When a call to that name is written (explicitly, or implicitly using the
operator notation), template argument deduction~(\ref{temp.deduct})
and checking of any explicit template arguments~(\ref{temp.arg}) are performed
for each function template to find the template argument values (if any) that
can be used with that function template to instantiate a function template
specialization that can be invoked with the call arguments.
For each function template, if the argument deduction and checking succeeds,
the
\grammarterm{template-argument}{s}
(deduced and/or explicit)
are used to synthesize the declaration of
a single function template specialization which is
added to the candidate functions set to be used in overload resolution.
If, for a given function template, argument deduction fails, no such function
is added to the set of candidate functions for that template.
The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of
the same name.
The synthesized declarations are
treated like any other functions in
the remainder of overload resolution, except as explicitly noted
in~\ref{over.match.best}.\footnote{The parameters of function template
specializations contain no
template parameter types.
The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions.
Non-deduced arguments allow the full range of conversions.
Note also that~\ref{over.match.best} specifies that a non-template function will
be given preference over a template specialization if the two functions
are otherwise equally good candidates for an overload match.}

\enterexample
\begin{codeblock}
template<class T> T max(T a, T b) { return a>b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            // \tcode{max(int a, int b)}
  char m2 = max(c,d);           // \tcode{max(char a, char b)}
  int m3 = max(a,c);            // error: cannot generate \tcode{max(int,char)}
}
\end{codeblock}

\pnum
Adding the non-template function

\begin{codeblock}
int max(int,int);
\end{codeblock}

to the example above would resolve the third call, by providing a function that
could be called for
\tcode{max(a,c)}
after using the standard conversion of
\tcode{char}
to
\tcode{int}
for
\tcode{c}.

\pnum
Here is an example involving conversions on a function argument involved in
\grammarterm{template-argument}
deduction:

\begin{codeblock}
template<class T> struct B { /* ... */ };
template<class T> struct D : public B<T> { /* ... */ };
template<class T> void f(B<T>&);

void g(B<int>& bi, D<int>& di) {
  f(bi);            // \tcode{f(bi)}
  f(di);            // \tcode{f((B<int>\&)di)}
}
\end{codeblock}

\pnum
Here is an example involving conversions on a function argument not involved in
\grammarterm{template-parameter}
deduction:

\begin{codeblock}
template<class T> void f(T*,int);       // \#1
template<class T> void f(T,char);       // \#2

void h(int* pi, int i, char c) {
  f(pi,i);          // \#1: \tcode{f<int>(pi,i)}
  f(pi,c);          // \#2: \tcode{f<int*>(pi,c)}

  f(i,c);           // \#2: \tcode{f<int>(i,c);}
  f(i,i);           // \#2: \tcode{f<int>(i,char(i))}
}
\end{codeblock}
\exitexample

\pnum
Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions.
Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate.
\enterexample

\begin{codeblock}
template<class T> void f(T);    // declaration

void g() {
  f("Annemarie");               // call of \tcode{f<const char*>}
}
\end{codeblock}

\pnum
The call of
\tcode{f}
is well-formed even if the template
\tcode{f}
is only declared and not defined at the point of the call.
The program will be ill-formed unless a specialization for
\tcode{f<const char*>},
either implicitly or explicitly generated,
is present in some translation unit.
\exitexample%
\indextext{template|)}
