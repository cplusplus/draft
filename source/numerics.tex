%!TEX root = std.tex
\rSec0[numerics]{Numerics library}

\rSec1[numerics.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to perform
seminumerical operations.

\pnum
The following subclauses describe components for
complex number types, random number generation,
numeric (%
\textit{n}-at-a-time)
arrays, generalized numeric algorithms, and
mathematical constants and functions for floating-point types,
as summarized in \tref{numerics.summary}.

\begin{libsumtab}{Numerics library summary}{numerics.summary}
\ref{numeric.requirements}  & Requirements &           \\ \rowsep
\ref{cfenv}           & Floating-point environment & \tcode{<cfenv>}  \\ \rowsep
\ref{complex.numbers} & Complex numbers & \tcode{<complex>} \\ \rowsep
\ref{rand}  & Random number generation & \tcode{<random>} \\ \rowsep
\ref{numarray}  & Numeric arrays     & \tcode{<valarray>}  \\ \rowsep
\ref{c.math}  & Mathematical functions for floating-point types &
  \tcode{<cmath>}, \tcode{<cstdlib>} \\ \rowsep
\ref{numbers}  & Numbers & \tcode{<numbers>} \\
\end{libsumtab}

\rSec1[numeric.requirements]{Numeric type requirements}
\indextext{requirements!numeric type}

\pnum
The
\tcode{complex}
and
\tcode{valarray}
components are parameterized by the type of information they contain and manipulate.
A \Cpp{} program shall instantiate these components only with a numeric type.
A \defnadj{numeric}{type} is a cv-unqualified object type \tcode{T}
that meets the
\oldconcept{DefaultConstructible},
\oldconcept{CopyConstructible},
\oldconcept{CopyAssignable}, and
\oldconcept{Destructible}
requirements\iref{utility.arg.requirements}.
\begin{footnote}
In other words, value types.
These include arithmetic types,
pointers, the library class
\tcode{complex},
and instantiations of
\tcode{valarray}
for value types.
\end{footnote}

\pnum
If any operation on \tcode{T}
throws an exception the effects are undefined.

\pnum
In addition, many member and related functions of
\tcode{valarray<T>}
can be successfully instantiated
and will exhibit well-defined behavior if and only if
\tcode{T} meets additional requirements specified for each such member
or related function.

\pnum
\begin{example}
It is valid to instantiate
\tcode{valarray<complex>},
but
\tcode{operator>()}
will not be successfully instantiated for
\tcode{valarray<complex>}
operands, since
\tcode{complex}
does not have any ordering operators.
\end{example}

\rSec1[cfenv]{The floating-point environment}
\rSec2[cfenv.syn]{Header \tcode{<cfenv>} synopsis}

\indexheader{cfenv}%
\indexlibraryglobal{fenv_t}%
\indexlibraryglobal{fexcept_t}%
\indexlibraryglobal{feclearexcept}%
\indexlibraryglobal{fegetexceptflag}%
\indexlibraryglobal{feraiseexcept}%
\indexlibraryglobal{fesetexceptflag}%
\indexlibraryglobal{fetestexcept}%
\indexlibraryglobal{fegetround}%
\indexlibraryglobal{fesetround}%
\indexlibraryglobal{fegetenv}%
\indexlibraryglobal{feholdexcept}%
\indexlibraryglobal{fesetenv}%
\indexlibraryglobal{feupdateenv}%
\indexlibraryglobal{FE_ALL_EXCEPT}%
\indexlibraryglobal{FE_DIVBYZERO}%
\indexlibraryglobal{FE_INEXACT}%
\indexlibraryglobal{FE_INVALID}%
\indexlibraryglobal{FE_OVERFLOW}%
\indexlibraryglobal{FE_UNDERFLOW}%
\indexlibraryglobal{FE_DOWNWARD}%
\indexlibraryglobal{FE_TONEAREST}%
\indexlibraryglobal{FE_TOWARDZERO}%
\indexlibraryglobal{FE_UPWARD}%
\indexlibraryglobal{FE_DFL_ENV}%
\begin{codeblock}
#define FE_ALL_EXCEPT @\seebelow@
#define FE_DIVBYZERO @\seebelow@    // optional
#define FE_INEXACT @\seebelow@      // optional
#define FE_INVALID @\seebelow@      // optional
#define FE_OVERFLOW @\seebelow@     // optional
#define FE_UNDERFLOW @\seebelow@    // optional

#define FE_DOWNWARD @\seebelow@     // optional
#define FE_TONEAREST @\seebelow@    // optional
#define FE_TOWARDZERO @\seebelow@   // optional
#define FE_UPWARD @\seebelow@       // optional

#define FE_DFL_ENV @\seebelow@

namespace std {
  // types
  using fenv_t    = @\textit{object type}@;
  using fexcept_t = @\textit{integer type}@;

  // functions
  int feclearexcept(int except);
  int fegetexceptflag(fexcept_t* pflag, int except);
  int feraiseexcept(int except);
  int fesetexceptflag(const fexcept_t* pflag, int except);
  int fetestexcept(int except);

  int fegetround();
  int fesetround(int mode);

  int fegetenv(fenv_t* penv);
  int feholdexcept(fenv_t* penv);
  int fesetenv(const fenv_t* penv);
  int feupdateenv(const fenv_t* penv);
}
\end{codeblock}

\pnum
The contents and meaning of the header \libheader{cfenv}
are the same as the C standard library header \libheader{fenv.h}.
\begin{note}
This document does not require an implementation to support the
\tcode{FENV_ACCESS} pragma;
it is \impldef{whether pragma \tcode{FENV_ACCESS} is supported}\iref{cpp.pragma}
whether the pragma is supported. As a consequence,
it is \impldef{whether \tcode{<cfenv>} functions can be used to manage floating-point status}
whether these functions can be used to test floating-point status flags,
set floating-point control modes, or run under non-default mode settings.
If the pragma is used to enable control over the floating-point environment,
this document does not specify the effect on
floating-point evaluation in constant expressions.
\end{note}

\xrefc{7.6}

\rSec2[cfenv.thread]{Threads}

\pnum
The floating-point environment has thread storage
duration\iref{basic.stc.thread}. The initial state for a thread's floating-point
environment is the state of the floating-point environment of the thread that constructs
the corresponding \tcode{thread} object\iref{thread.thread.class}
or \tcode{jthread} object\iref{thread.jthread.class}
at the time it
constructed the object.
\begin{note}
That is, the child thread gets the floating-point
state of the parent thread at the time of the child's creation.
\end{note}

\pnum
A separate floating-point environment is maintained for each thread. Each function
accesses the environment corresponding to its calling thread.

\rSec1[complex.numbers]{Complex numbers}

\rSec2[complex.numbers.general]{General}

\pnum
The header \libheader{complex} defines a class template,
and numerous functions for representing and manipulating complex numbers.

\pnum
The effect of instantiating the template \tcode{complex} for any type
that is not a cv-unqualified floating-point type\iref{basic.fundamental}
is unspecified.
Specializations of \tcode{complex} for cv-unqualified floating-point types
are trivially-copyable literal types\iref{term.literal.type}.

\pnum
If the result of a function is not mathematically defined or not in
the range of representable values for its type, the behavior is
undefined.

\pnum
If \tcode{z} is an lvalue of type \cv{} \tcode{complex<T>} then:
\begin{itemize}
\item the expression \tcode{reinterpret_cast<\cv{} T(\&)[2]>(z)} is well-formed,
\item \tcode{reinterpret_cast<\cv{} T(\&)[2]>(z)[0]} designates the real part of \tcode{z}, and
\item \tcode{reinterpret_cast<\cv{} T(\&)[2]>(z)[1]} designates the imaginary part of \tcode{z}.
\end{itemize}

Moreover, if \tcode{a} is an expression of type \cv{}~\tcode{complex<T>*} and the expression \tcode{a[i]} is well-defined for an integer expression \tcode{i}, then:
\begin{itemize}
\item \tcode{reinterpret_cast<\cv{} T*>(a)[2*i]} designates the real part of \tcode{a[i]}, and
\item \tcode{reinterpret_cast<\cv{} T*>(a)[2*i + 1]} designates the imaginary part of \tcode{a[i]}.
\end{itemize}

\rSec2[complex.syn]{Header \tcode{<complex>} synopsis}

\indexheader{complex}%
\begin{codeblock}
namespace std {
  // \ref{complex}, class template \tcode{complex}
  template<class T> class complex;

  // \ref{complex.ops}, operators
  template<class T> constexpr complex<T> operator+(const complex<T>&, const complex<T>&);
  template<class T> constexpr complex<T> operator+(const complex<T>&, const T&);
  template<class T> constexpr complex<T> operator+(const T&, const complex<T>&);

  template<class T> constexpr complex<T> operator-(const complex<T>&, const complex<T>&);
  template<class T> constexpr complex<T> operator-(const complex<T>&, const T&);
  template<class T> constexpr complex<T> operator-(const T&, const complex<T>&);

  template<class T> constexpr complex<T> operator*(const complex<T>&, const complex<T>&);
  template<class T> constexpr complex<T> operator*(const complex<T>&, const T&);
  template<class T> constexpr complex<T> operator*(const T&, const complex<T>&);

  template<class T> constexpr complex<T> operator/(const complex<T>&, const complex<T>&);
  template<class T> constexpr complex<T> operator/(const complex<T>&, const T&);
  template<class T> constexpr complex<T> operator/(const T&, const complex<T>&);

  template<class T> constexpr complex<T> operator+(const complex<T>&);
  template<class T> constexpr complex<T> operator-(const complex<T>&);

  template<class T> constexpr bool operator==(const complex<T>&, const complex<T>&);
  template<class T> constexpr bool operator==(const complex<T>&, const T&);

  template<class T, class charT, class traits>
    basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>&, complex<T>&);

  template<class T, class charT, class traits>
    basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, const complex<T>&);

  // \ref{complex.value.ops}, values
  template<class T> constexpr T real(const complex<T>&);
  template<class T> constexpr T imag(const complex<T>&);

  template<class T> T abs(const complex<T>&);
  template<class T> T arg(const complex<T>&);
  template<class T> constexpr T norm(const complex<T>&);

  template<class T> constexpr complex<T> conj(const complex<T>&);
  template<class T> complex<T> proj(const complex<T>&);
  template<class T> complex<T> polar(const T&, const T& = T());

  // \ref{complex.transcendentals}, transcendentals
  template<class T> complex<T> acos(const complex<T>&);
  template<class T> complex<T> asin(const complex<T>&);
  template<class T> complex<T> atan(const complex<T>&);

  template<class T> complex<T> acosh(const complex<T>&);
  template<class T> complex<T> asinh(const complex<T>&);
  template<class T> complex<T> atanh(const complex<T>&);

  template<class T> complex<T> cos  (const complex<T>&);
  template<class T> complex<T> cosh (const complex<T>&);
  template<class T> complex<T> exp  (const complex<T>&);
  template<class T> complex<T> log  (const complex<T>&);
  template<class T> complex<T> log10(const complex<T>&);

  template<class T> complex<T> pow  (const complex<T>&, const T&);
  template<class T> complex<T> pow  (const complex<T>&, const complex<T>&);
  template<class T> complex<T> pow  (const T&, const complex<T>&);

  template<class T> complex<T> sin  (const complex<T>&);
  template<class T> complex<T> sinh (const complex<T>&);
  template<class T> complex<T> sqrt (const complex<T>&);
  template<class T> complex<T> tan  (const complex<T>&);
  template<class T> complex<T> tanh (const complex<T>&);

  // \ref{complex.literals}, complex literals
  inline namespace literals {
  inline namespace complex_literals {
    constexpr complex<long double> operator""il(long double);
    constexpr complex<long double> operator""il(unsigned long long);
    constexpr complex<double> operator""i(long double);
    constexpr complex<double> operator""i(unsigned long long);
    constexpr complex<float> operator""if(long double);
    constexpr complex<float> operator""if(unsigned long long);
  }
  }
}
\end{codeblock}

\rSec2[complex]{Class template \tcode{complex}}

\indexlibraryglobal{complex}%
\indexlibrarymember{value_type}{complex}%
\begin{codeblock}
namespace std {
  template<class T> class complex {
  public:
    using value_type = T;

    constexpr complex(const T& re = T(), const T& im = T());
    constexpr complex(const complex&) = default;
    template<class X> constexpr explicit(@\seebelow@) complex(const complex<X>&);

    constexpr T real() const;
    constexpr void real(T);
    constexpr T imag() const;
    constexpr void imag(T);

    constexpr complex& operator= (const T&);
    constexpr complex& operator+=(const T&);
    constexpr complex& operator-=(const T&);
    constexpr complex& operator*=(const T&);
    constexpr complex& operator/=(const T&);

    constexpr complex& operator=(const complex&);
    template<class X> constexpr complex& operator= (const complex<X>&);
    template<class X> constexpr complex& operator+=(const complex<X>&);
    template<class X> constexpr complex& operator-=(const complex<X>&);
    template<class X> constexpr complex& operator*=(const complex<X>&);
    template<class X> constexpr complex& operator/=(const complex<X>&);
  };
}
\end{codeblock}

\pnum
The class
\tcode{complex}
describes an object that can
store the Cartesian components,
\tcode{real()}
and
\tcode{imag()},
of a complex
number.

\rSec2[complex.members]{Member functions}

\indexlibraryctor{complex}%
\begin{itemdecl}
constexpr complex(const T& re = T(), const T& im = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{real() == re \&\& imag() == im} is \tcode{true}.
\end{itemdescr}

\indexlibraryctor{complex}%
\begin{itemdecl}
template<class X> constexpr explicit(@\seebelow@) complex(const complex<X>& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the real part with \tcode{other.real()} and
the imaginary part with \tcode{other.imag()}.

\pnum
\remarks
The expression inside \tcode{explicit} evaluates to \tcode{false}
if and only if the floating-point conversion rank of \tcode{T}
is greater than or equal to the floating-point conversion rank of \tcode{X}.
\end{itemdescr}

\indexlibrarymember{real}{complex}%
\begin{itemdecl}
constexpr T real() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the real component.
\end{itemdescr}

\indexlibrarymember{real}{complex}%
\begin{itemdecl}
constexpr void real(T val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns \tcode{val} to the real component.
\end{itemdescr}

\indexlibrarymember{imag}{complex}%
\begin{itemdecl}
constexpr T imag() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the imaginary component.
\end{itemdescr}

\indexlibrarymember{imag}{complex}%
\begin{itemdecl}
constexpr void imag(T val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns \tcode{val} to the imaginary component.
\end{itemdescr}

\rSec2[complex.member.ops]{Member operators}

\indexlibrarymember{operator+=}{complex}%
\begin{itemdecl}
constexpr complex& operator+=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Adds the scalar value \tcode{rhs} to the real part of the complex value
\tcode{*this}
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{complex}%
\begin{itemdecl}
constexpr complex& operator-=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Subtracts the scalar value \tcode{rhs} from the real part of the complex value
\tcode{*this}
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*=}{complex}%
\begin{itemdecl}
constexpr complex& operator*=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Multiplies the scalar value \tcode{rhs} by the complex value
\tcode{*this}
and stores the result in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator/=}{complex}%
\begin{itemdecl}
constexpr complex& operator/=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Divides the scalar value \tcode{rhs} into the complex value
\tcode{*this}
and stores the result in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{complex}%
\begin{itemdecl}
template<class X> constexpr complex& operator+=(const complex<X>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Adds the complex value \tcode{rhs} to the complex value
\tcode{*this}
and stores the sum in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{complex}%
\begin{itemdecl}
template<class X> constexpr complex& operator-=(const complex<X>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Subtracts the complex value \tcode{rhs} from the complex value
\tcode{*this}
and stores the difference in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*=}{complex}%
\begin{itemdecl}
template<class X> constexpr complex& operator*=(const complex<X>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Multiplies the complex value \tcode{rhs} by the complex value
\tcode{*this}
and stores the product in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator/=}{complex}%
\begin{itemdecl}
template<class X> constexpr complex& operator/=(const complex<X>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Divides the complex value \tcode{rhs} into the complex value
\tcode{*this}
and stores the quotient in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec2[complex.ops]{Non-member operations}

\indexlibrarymember{operator+}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> operator+(const complex<T>& lhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs)}.

\end{itemdescr}

\begin{itemdecl}
template<class T> constexpr complex<T> operator+(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator+(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator+(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) += rhs}.
\end{itemdescr}

\indexlibrarymember{operator-}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> operator-(const complex<T>& lhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(-lhs.real(),-lhs.imag())}.
\end{itemdescr}

\indexlibrarymember{operator-}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> operator-(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator-(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator-(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) -= rhs}.
\end{itemdescr}

\indexlibrarymember{operator*}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> operator*(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator*(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator*(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) *= rhs}.
\end{itemdescr}

\indexlibrarymember{operator/}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> operator/(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator/(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator/(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) /= rhs}.
\end{itemdescr}

\indexlibrarymember{operator==}{complex}%
\begin{itemdecl}
template<class T> constexpr bool operator==(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr bool operator==(const complex<T>& lhs, const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.real() == rhs.real() \&\& lhs.imag() == rhs.imag()}.

\pnum
\remarks
The imaginary part is assumed to be
\tcode{T()},
or 0.0, for the
\tcode{T}
arguments.
\end{itemdescr}

\indexlibrarymember{operator>>}{complex}%
\begin{itemdecl}
template<class T, class charT, class traits>
  basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is, complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
The input values are convertible to
\tcode{T}.

\pnum
\effects
Extracts a complex number \tcode{x} of the form:
\tcode{u},
\tcode{(u)},
or
\tcode{(u,v)},
where
\tcode{u}
is the real part and
\tcode{v}
is the imaginary part\iref{istream.formatted}.

\pnum
If bad input is encountered, calls
\tcode{is.setstate(ios_base::failbit)}
(which may throw
\tcode{ios_base::\brk{}failure}\iref{iostate.flags}).

\pnum
\returns
\tcode{is}.

\pnum
\remarks
This extraction is performed as a series of simpler
extractions.
Therefore, the skipping of whitespace is specified to be
the same for each of the simpler extractions.
\end{itemdescr}

\indexlibrarymember{operator<<}{complex}%
\begin{itemdecl}
template<class T, class charT, class traits>
  basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts the complex number \tcode{x}
onto the stream \tcode{o} as if it were implemented as follows:

\begin{codeblock}
basic_ostringstream<charT, traits> s;
s.flags(o.flags());
s.imbue(o.getloc());
s.precision(o.precision());
s << '(' << x.real() << ',' << x.imag() << ')';
return o << s.str();
\end{codeblock}

\pnum
\begin{note}
In a locale in which comma is used as a decimal point character, the
use of comma as a field separator can be ambiguous. Inserting
\tcode{showpoint} into the output stream forces all outputs to
show an explicit decimal point character; as a result, all inserted sequences of
complex numbers can be extracted unambiguously.
\end{note}
\end{itemdescr}

\rSec2[complex.value.ops]{Value operations}

\indexlibrarymember{real}{complex}%
\begin{itemdecl}
template<class T> constexpr T real(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.real()}.
\end{itemdescr}

\indexlibrarymember{imag}{complex}%
\begin{itemdecl}
template<class T> constexpr T imag(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.imag()}.
\end{itemdescr}

\indexlibrarymember{abs}{complex}%
\begin{itemdecl}
template<class T> T abs(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The magnitude of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{arg}{complex}%
\begin{itemdecl}
template<class T> T arg(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The phase angle of \tcode{x}, or \tcode{atan2(imag(x), real(x))}.
\end{itemdescr}

\indexlibrarymember{norm}{complex}%
\begin{itemdecl}
template<class T> constexpr T norm(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The squared magnitude of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{conj}{complex}%
\begin{itemdecl}
template<class T> constexpr complex<T> conj(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex conjugate of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{proj}{complex}%
\begin{itemdecl}
template<class T> complex<T> proj(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The projection of \tcode{x} onto the Riemann sphere.

\pnum
\remarks
Behaves the same as the C function \tcode{cproj}.
\xrefc{7.3.9.5}
\end{itemdescr}

\indexlibrarymember{polar}{complex}%
\begin{itemdecl}
template<class T> complex<T> polar(const T& rho, const T& theta = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{rho} is non-negative and non-NaN\@. \tcode{theta} is finite.

\pnum
\returns
The
\tcode{complex}
value corresponding
to a complex number whose magnitude is \tcode{rho} and whose phase angle
is \tcode{theta}.
\end{itemdescr}

\rSec2[complex.transcendentals]{Transcendentals}

\indexlibrarymember{acos}{complex}%
\indexlibrarymember{cacos}{complex}%
\begin{itemdecl}
template<class T> complex<T> acos(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc cosine of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{cacos}.
\xrefc{7.3.5.1}
\end{itemdescr}

\indexlibrarymember{asin}{complex}%
\indexlibrarymember{casin}{complex}%
\begin{itemdecl}
template<class T> complex<T> asin(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc sine of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{casin}.
\xrefc{7.3.5.2}
\end{itemdescr}

\indexlibrarymember{atan}{complex}%
\indexlibrarymember{catan}{complex}%
\begin{itemdecl}
template<class T> complex<T> atan(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc tangent of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{catan}.
\xrefc{7.3.5.3}
\end{itemdescr}

\indexlibrarymember{acosh}{complex}%
\indexlibrarymember{cacosh}{complex}%
\begin{itemdecl}
template<class T> complex<T> acosh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc hyperbolic cosine of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{cacosh}.
\xrefc{7.3.6.1}
\end{itemdescr}

\indexlibrarymember{asinh}{complex}%
\indexlibrarymember{casinh}{complex}%
\begin{itemdecl}
template<class T> complex<T> asinh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc hyperbolic sine of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{casinh}.
\xrefc{7.3.6.2}
\end{itemdescr}

\indexlibrarymember{atanh}{complex}%
\indexlibrarymember{catanh}{complex}%
\begin{itemdecl}
template<class T> complex<T> atanh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex arc hyperbolic tangent of \tcode{x}.

\pnum
\remarks
Behaves the same as the C function \tcode{catanh}.
\xrefc{7.3.6.3}
\end{itemdescr}

\indexlibrarymember{cos}{complex}%
\begin{itemdecl}
template<class T> complex<T> cos(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex cosine of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{cosh}{complex}%
\begin{itemdecl}
template<class T> complex<T> cosh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex hyperbolic cosine of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{exp}{complex}%
\begin{itemdecl}
template<class T> complex<T> exp(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex base-$e$ exponential of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{log}{complex}%
\begin{itemdecl}
template<class T> complex<T> log(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex natural (base-$e$) logarithm of \tcode{x}. For all \tcode{x},
\tcode{imag(log(x))} lies in the interval \crange{$-\pi$}{$\pi$}.
\begin{note}
The semantics of this function are intended to be the same in \Cpp{}
as they are for \tcode{clog} in C.
\end{note}

\pnum
\remarks
The branch cuts are along the negative real axis.
\end{itemdescr}

\indexlibrarymember{log10}{complex}%
\begin{itemdecl}
template<class T> complex<T> log10(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex common (base-$10$) logarithm of \tcode{x}, defined as
\tcode{log(x) / log(10)}.

\pnum
\remarks
The branch cuts are along the negative real axis.
\end{itemdescr}

\indexlibrarymember{pow}{complex}%
\begin{itemdecl}
template<class T> complex<T> pow(const complex<T>& x, const complex<T>& y);
template<class T> complex<T> pow(const complex<T>& x, const T& y);
template<class T> complex<T> pow(const T& x, const complex<T>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex power of base \tcode{x} raised to the $\tcode{y}^\text{th}$ power,
defined as
\tcode{exp(y * log(x))}.
The value returned for
\tcode{pow(0, 0)}
is \impldef{value of \tcode{pow(0,0)}}.

\pnum
\remarks
The branch cuts are along the negative real axis.
\end{itemdescr}

\indexlibrarymember{sin}{complex}%
\begin{itemdecl}
template<class T> complex<T> sin(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex sine of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{sinh}{complex}%
\begin{itemdecl}
template<class T> complex<T> sinh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex hyperbolic sine of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{sqrt}{complex}%
\begin{itemdecl}
template<class T> complex<T> sqrt(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex square root of \tcode{x}, in the range of the right
half-plane.
\begin{note}
The semantics of this function are intended to be the same in \Cpp{}
as they are for \tcode{csqrt} in C.
\end{note}

\pnum
\remarks
The branch cuts are along the negative real axis.
\end{itemdescr}

\indexlibrarymember{tan}{complex}%
\begin{itemdecl}
template<class T> complex<T> tan(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex tangent of \tcode{x}.
\end{itemdescr}

\indexlibrarymember{tanh}{complex}%
\begin{itemdecl}
template<class T> complex<T> tanh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The complex hyperbolic tangent of \tcode{x}.
\end{itemdescr}

\rSec2[cmplx.over]{Additional overloads}

\pnum
\indexlibraryglobal{arg}%
\indexlibraryglobal{conj}%
\indexlibraryglobal{imag}%
\indexlibraryglobal{norm}%
\indexlibraryglobal{real}%
The following function templates shall have additional overloads:
\begin{codeblock}
arg                   norm
conj                  proj
imag                  real
\end{codeblock}
where \tcode{norm}, \tcode{conj}, \tcode{imag}, and \tcode{real} are \keyword{constexpr} overloads.

\pnum
\indextext{overloads!floating-point}%
The additional overloads shall be sufficient to ensure:
\begin{itemize}
\item
If the argument has a floating-point type \tcode{T},
then it is effectively cast to \tcode{complex<T>}.
\item
Otherwise, if the argument has integer type,
then it is effectively cast to \tcode{complex<double>}.
\end{itemize}

\pnum
\indexlibraryglobal{pow}%
Function template \tcode{pow} has additional overloads sufficient to ensure,
for a call with one argument of type \tcode{complex<T1>} and
the other argument of type \tcode{T2} or \tcode{complex<T2>},
both arguments are effectively cast to \tcode{complex<common_type_t<T1, T2>>}.
If \tcode{common_type_t<T1, T2>} is not well-formed,
then the program is ill-formed.

\rSec2[complex.literals]{Suffixes for complex number literals}

\indextext{literal!complex}%
\pnum
This subclause describes literal suffixes for constructing complex number literals.
The suffixes \tcode{i}, \tcode{il}, and \keyword{if} create complex numbers of
the types \tcode{complex<double>}, \tcode{complex<long double>}, and
\tcode{complex<float>} respectively, with their imaginary part denoted by the
given literal number and the real part being zero.

\indexlibrarymember{operator""""il}{complex}%
\begin{itemdecl}
constexpr complex<long double> operator""il(long double d);
constexpr complex<long double> operator""il(unsigned long long d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<long double>\{0.0L, static_cast<long double>(d)\}}.
\end{itemdescr}

\indexlibrarymember{operator""""i}{complex}%
\begin{itemdecl}
constexpr complex<double> operator""i(long double d);
constexpr complex<double> operator""i(unsigned long long d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<double>\{0.0, static_cast<double>(d)\}}.
\end{itemdescr}

\indexlibrarymember{operator""""if}{complex}%
\begin{itemdecl}
constexpr complex<float> operator""if(long double d);
constexpr complex<float> operator""if(unsigned long long d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<float>\{0.0f, static_cast<float>(d)\}}.
\end{itemdescr}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                %%%
%%%                                                                %%%
%%%      Numerical facilities:  Random number generation           %%%
%%%                    (without concepts)                          %%%
%%%                                                                %%%
%%%                                                                %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec1[rand]{Random number generation}

\rSec2[rand.general]{General}

\indextext{random number generation|(}%
\indextext{distribution|see{random number distribution}}%
\indextext{engine|see{random number engine}}%
\indextext{engine adaptor|see{random number engine adaptor}}%
\indextext{random number generator|see{uniform random bit generator}}

\pnum
Subclause \ref{rand} defines a facility
for generating (pseudo-)random numbers.

\pnum
In addition to a few utilities,
four categories of entities are described:
\term{uniform random bit generators},
\term{random number engines},
\term{random number engine adaptors},
and
\term{random number distributions}.
These categorizations are applicable
to types that meet the corresponding requirements,
to objects instantiated from such types,
and to templates producing such types when instantiated.
\begin{note}
 These entities are specified in such a way
 as to permit the binding
 of any uniform random bit generator object \tcode{e}
 as the argument
 to any random number distribution object \tcode{d},
 thus producing a zero-argument function object
 such as given by
 \tcode{bind(d,e)}.
\end{note}

\pnum
Each of the entities specified in \ref{rand}
has an associated arithmetic type\iref{basic.fundamental}
identified as \tcode{result_type}.
With \tcode{T} as the \tcode{result_type}
thus associated with such an entity,
that entity is characterized:
\begin{itemize}
 \item
   as \term{boolean} or equivalently as \term{boolean-valued},
   if \tcode{T} is \tcode{bool};
 \item
   otherwise
   as \term{integral} or equivalently as \term{integer-valued},
   if \tcode{numeric_limits<T>::is_integer} is \tcode{true};
 \item
   otherwise
   as \term{floating-point} or equivalently as \term{real-valued}.
\end{itemize}
\noindent
If integer-valued,
an entity may optionally be further characterized as
\term{signed} or \term{unsigned},
according to \tcode{numeric_limits<T>::is_signed}.

\pnum
Unless otherwise specified,
all descriptions of calculations
in \ref{rand}
use mathematical real numbers.

\pnum
Throughout \ref{rand},
the operators
\bitand, \bitor, and \xor{}
denote the respective conventional bitwise operations.
Further:
\begin{itemize}
 \item
   the operator \rightshift{} denotes a bitwise right shift
   with zero-valued bits appearing in the high bits of the result, and
 \item
   the operator \leftshift{w} denotes a bitwise left shift
   with zero-valued bits appearing in the low bits of the result,
   and whose result is always taken modulo $2^w$.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Header synopsis subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.synopsis]{Header \tcode{<random>} synopsis}

\indexheader{random}
\indextext{random number generation!synopsis|(}

\begin{codeblock}
#include <initializer_list>     // see \ref{initializer.list.syn}

namespace std {
  // \ref{rand.req.urng}, uniform random bit generator requirements
  template<class G>
    concept uniform_random_bit_generator = @\seebelow@;

  // \ref{rand.eng.lcong}, class template \tcode{linear_congruential_engine}
  template<class UIntType, UIntType a, UIntType c, UIntType m>
    class linear_congruential_engine;

  // \ref{rand.eng.mers}, class template \tcode{mersenne_twister_engine}
  template<class UIntType, size_t w, size_t n, size_t m, size_t r,
           UIntType a, size_t u, UIntType d, size_t s,
           UIntType b, size_t t,
           UIntType c, size_t l, UIntType f>
    class mersenne_twister_engine;

  // \ref{rand.eng.sub}, class template \tcode{subtract_with_carry_engine}
  template<class UIntType, size_t w, size_t s, size_t r>
    class subtract_with_carry_engine;

  // \ref{rand.adapt.disc}, class template \tcode{discard_block_engine}
  template<class Engine, size_t p, size_t r>
    class discard_block_engine;

  // \ref{rand.adapt.ibits}, class template \tcode{independent_bits_engine}
  template<class Engine, size_t w, class UIntType>
    class independent_bits_engine;

  // \ref{rand.adapt.shuf}, class template \tcode{shuffle_order_engine}
  template<class Engine, size_t k>
    class shuffle_order_engine;

  // \ref{rand.predef}, engines and engine adaptors with predefined parameters
  using minstd_rand0  = @\seebelow@;
  using minstd_rand   = @\seebelow@;
  using mt19937       = @\seebelow@;
  using mt19937_64    = @\seebelow@;
  using ranlux24_base = @\seebelow@;
  using ranlux48_base = @\seebelow@;
  using ranlux24      = @\seebelow@;
  using ranlux48      = @\seebelow@;
  using knuth_b       = @\seebelow@;

  using default_random_engine = @\seebelow@;

  // \ref{rand.device}, class \tcode{random_device}
  class random_device;

  // \ref{rand.util.seedseq}, class \tcode{seed_seq}
  class seed_seq;

  // \ref{rand.util.canonical}, function template \tcode{generate_canonical}
  template<class RealType, size_t bits, class URBG>
    RealType generate_canonical(URBG& g);

  // \ref{rand.dist.uni.int}, class template \tcode{uniform_int_distribution}
  template<class IntType = int>
    class uniform_int_distribution;

  // \ref{rand.dist.uni.real}, class template \tcode{uniform_real_distribution}
  template<class RealType = double>
    class uniform_real_distribution;

  // \ref{rand.dist.bern.bernoulli}, class \tcode{bernoulli_distribution}
  class bernoulli_distribution;

  // \ref{rand.dist.bern.bin}, class template \tcode{binomial_distribution}
  template<class IntType = int>
    class binomial_distribution;

  // \ref{rand.dist.bern.geo}, class template \tcode{geometric_distribution}
  template<class IntType = int>
    class geometric_distribution;

  // \ref{rand.dist.bern.negbin}, class template \tcode{negative_binomial_distribution}
  template<class IntType = int>
    class negative_binomial_distribution;

  // \ref{rand.dist.pois.poisson}, class template \tcode{poisson_distribution}
  template<class IntType = int>
    class poisson_distribution;

  // \ref{rand.dist.pois.exp}, class template \tcode{exponential_distribution}
  template<class RealType = double>
    class exponential_distribution;

  // \ref{rand.dist.pois.gamma}, class template \tcode{gamma_distribution}
  template<class RealType = double>
    class gamma_distribution;

  // \ref{rand.dist.pois.weibull}, class template \tcode{weibull_distribution}
  template<class RealType = double>
    class weibull_distribution;

  // \ref{rand.dist.pois.extreme}, class template \tcode{extreme_value_distribution}
  template<class RealType = double>
    class extreme_value_distribution;

  // \ref{rand.dist.norm.normal}, class template \tcode{normal_distribution}
  template<class RealType = double>
    class normal_distribution;

  // \ref{rand.dist.norm.lognormal}, class template \tcode{lognormal_distribution}
  template<class RealType = double>
    class lognormal_distribution;

  // \ref{rand.dist.norm.chisq}, class template \tcode{chi_squared_distribution}
  template<class RealType = double>
    class chi_squared_distribution;

  // \ref{rand.dist.norm.cauchy}, class template \tcode{cauchy_distribution}
  template<class RealType = double>
    class cauchy_distribution;

  // \ref{rand.dist.norm.f}, class template \tcode{fisher_f_distribution}
  template<class RealType = double>
    class fisher_f_distribution;

  // \ref{rand.dist.norm.t}, class template \tcode{student_t_distribution}
  template<class RealType = double>
    class student_t_distribution;

  // \ref{rand.dist.samp.discrete}, class template \tcode{discrete_distribution}
  template<class IntType = int>
    class discrete_distribution;

  // \ref{rand.dist.samp.pconst}, class template \tcode{piecewise_constant_distribution}
  template<class RealType = double>
    class piecewise_constant_distribution;

  // \ref{rand.dist.samp.plinear}, class template \tcode{piecewise_linear_distribution}
  template<class RealType = double>
    class piecewise_linear_distribution;
}
\end{codeblock}%
\indextext{random number generation!synopsis|)}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Requirements subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec2[rand.req]{Requirements}%
\indextext{random number generation!requirements|(}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  general requirements subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.req.genl]{General requirements}%

\pnum
Throughout this subclause \ref{rand},
the effect of instantiating a template:
\begin{itemize}
  \item
    that has a template type parameter
    named \tcode{Sseq}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    meets the requirements
    of seed sequence\iref{rand.req.seedseq}.
  \item
    that has a template type parameter
    named \tcode{URBG}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    meets the requirements
    of uniform random bit generator\iref{rand.req.urng}.
  \item
    that has a template type parameter
    named \tcode{Engine}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    meets the requirements
    of random number engine\iref{rand.req.eng}.
  \item
    that has a template type parameter
    named \tcode{RealType}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    is one of
    \tcode{float}, \tcode{double}, or \tcode{long double}.
  \item
    that has a template type parameter
    named \tcode{IntType}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    is one of
      \tcode{short},
      \tcode{int},
      \tcode{long},
      \tcode{long long},
      \tcode{unsigned short},
      \tcode{unsigned int},
      \tcode{unsigned long},
      or
      \tcode{unsigned long long}.
  \item
    that has a template type parameter
    named \tcode{UIntType}
    is undefined unless the corresponding template argument
    is cv-unqualified and
    is one of
      \tcode{unsigned short},
      \tcode{unsigned int},
      \tcode{unsigned long},
      or
      \tcode{unsigned long long}.
\end{itemize}

\pnum
Throughout this subclause \ref{rand},
phrases of the form ``\tcode{x} is an iterator of a specific kind''
shall be interpreted as equivalent to the more formal requirement that
``\tcode{x} is a value
of a type meeting the requirements
of the specified iterator type''.

\pnum
Throughout this subclause \ref{rand},
any constructor that can be called with a single argument
and that meets a requirement specified in this subclause
shall be declared \keyword{explicit}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Seed Sequence requirements:

\rSec3[rand.req.seedseq]{Seed sequence requirements}%
\indextext{seed sequence!requirements|(}%
\indextext{requirements!seed sequence|(}

\pnum
 A \defn{seed sequence}
 is an object
 that consumes a sequence
 of integer-valued data
 and produces a requested number
 of unsigned integer values $i$, $0 \le i < 2^{32}$,
 based on the consumed data.
\begin{note}
 Such an object provides a mechanism
 to avoid replication of streams of random variates.
 This can be useful, for example, in applications
 requiring large numbers of random number engines.
\end{note}

\pnum
A class \tcode{S}
meets the requirements
of a seed sequence
if the expressions shown
in \tref{rand.req.seedseq}
are valid and have the indicated semantics,
and if \tcode{S} also meets all other requirements
of this subclause \ref{rand.req.seedseq}.
In that Table and throughout this subclause:
\begin{itemize}
  \item
    \tcode{T} is the type named by
    \tcode{S}'s associated \tcode{result_type};
  \item
    \tcode{q} is a value of type \tcode{S}
    and
    \tcode{r} is a value of type \tcode{S} or \tcode{const S};
  \item
    \tcode{ib} and \tcode{ie} are input iterators
    with an unsigned integer \tcode{value_type} of at least 32 bits;
  \item
    \tcode{rb} and \tcode{re} are mutable random access iterators
    with an unsigned integer \tcode{value_type} of at least 32 bits;
  \item
    \tcode{ob} is an output iterator;
  and
  \item
    \tcode{il} is a value of type \tcode{initializer_list<T>}.
\end{itemize}


\begin{libreqtab4d}
  {Seed sequence requirements}
  {rand.req.seedseq}
\\ \topline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endhead
\tcode{S::result_type}
  & \tcode{T}
  & \tcode{T} is an unsigned integer type\iref{basic.fundamental}
    of at least 32 bits.
  & compile-time
  \\ \rowsep
\tcode{S()}%
  &
  & Creates a seed sequence
    with the same initial state as all other default-constructed seed sequences
    of type \tcode{S}.
  & constant
  \\ \rowsep
\tcode{S(ib,ie)}%
  &
  & Creates a seed sequence
    having internal state
    that depends on some or all of the bits
    of the supplied sequence $[\tcode{ib},\tcode{ie})$.
  & \bigoh{\tcode{ie} - \tcode{ib}}
  \\ \rowsep
\tcode{S(il)}%
  &
  & Same as \tcode{S(il.begin(), il.end())}.
  & same as \tcode{S(il.begin(), il.end())}
  \\ \rowsep
\tcode{q.generate(rb,re)}%
  & \keyword{void}
  & Does nothing if \tcode{rb == re}.
    Otherwise,
    fills the supplied sequence $[\tcode{rb},\tcode{re})$
    with 32-bit quantities
    that depend on the sequence supplied to the constructor
    and possibly also depend on the history
    of \tcode{generate}'s previous invocations.
  & \bigoh{\tcode{re} - \tcode{rb}}
  \\ \rowsep
\tcode{r.size()}%
  & \tcode{size_t}
  & The number of 32-bit units
    that would be copied
    by a call to \tcode{r.param}.
  & constant
  \\ \rowsep
\tcode{\tcode{r.param(ob)}}%
  & \keyword{void}
  & Copies to the given destination
    a sequence of 32-bit units
    that can be provided
    to the constructor of a second object of type \tcode{S},
    and that would reproduce in that second object
    a state indistinguishable
    from the state of the first object.
  & \bigoh{\tcode{r.size()}}
  \\
\end{libreqtab4d}%

\indextext{requirements!seed sequence|)}
\indextext{seed sequence!requirements|)}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Uniform Random Number Generator requirements:

\rSec3[rand.req.urng]{Uniform random bit generator requirements}%
\indextext{uniform random bit generator!requirements|(}%
\indextext{requirements!uniform random bit generator|(}

\pnum
A \term{uniform random bit generator}
\tcode{g} of type \tcode{G}
is a function object
returning unsigned integer values
such that each value
in the range of possible results
has (ideally) equal probability
of being returned.
\begin{note}
 The degree to which \tcode{g}'s results
 approximate the ideal
 is often determined statistically.
\end{note}

\begin{codeblock}
template<class G>
  concept @\deflibconcept{uniform_random_bit_generator}@ =
    @\libconcept{invocable}@<G&> && @\libconcept{unsigned_integral}@<invoke_result_t<G&>> &&
    requires {
      { G::min() } -> @\libconcept{same_as}@<invoke_result_t<G&>>;
      { G::max() } -> @\libconcept{same_as}@<invoke_result_t<G&>>;
      requires bool_constant<(G::min() < G::max())>::value;
    };
\end{codeblock}

\pnum
Let \tcode{g} be an object of type \tcode{G}. \tcode{G} models
\libconcept{uniform_random_bit_generator} only if
\begin{itemize}
\item \tcode{G::min() <= g()},
\item \tcode{g() <= G::max()}, and
\item \tcode{g()} has amortized constant complexity.
\end{itemize}

\indextext{requirements!uniform random bit generator|)}%
\indextext{uniform random bit generator!requirements|)}%
\pnum
A class \tcode{G} meets the \term{uniform random bit generator} requirements if
\tcode{G} models \libconcept{uniform_random_bit_generator},
\tcode{invoke_result_t<G\&>} is an unsigned integer type\iref{basic.fundamental},
and
\tcode{G} provides a nested \grammarterm{typedef-name} \tcode{result_type}
that denotes the same type as \tcode{invoke_result_t<G\&>}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Random Number Engine requirements:

\rSec3[rand.req.eng]{Random number engine requirements}%
\indextext{random number engine!requirements|(}%
\indextext{requirements!random number engine|(}

\pnum
A \term{random number engine}
(commonly shortened to \term{engine})
\tcode{e} of type \tcode{E}
is a uniform random bit generator
that additionally meets the requirements
(e.g., for seeding and for input/output)
specified in this subclause.

\pnum
At any given time,
\tcode{e} has a state \state{e}{i}
for some integer $i \geq 0$.
Upon construction,
\tcode{e}
has an initial state \state{e}{0}.
An engine's state may be established via
 a constructor,
 a \tcode{seed} function,
 assignment,
 or a suitable \tcode{operator>>}.

\pnum
\tcode{E}'s specification shall define:
\begin{itemize}
 \item
   the size of \tcode{E}'s state
   in multiples of the size of \tcode{result_type},
   given as an integral constant expression;
 \item
   the \term{transition algorithm}
   $\mathsf{TA}$
   by which \tcode{e}'s state \state{e}{i}
   is advanced to its \term{successor state}
   \state{e}{i+1};
 and
 \item
   the \term{generation algorithm}
   $\mathsf{GA}$
   by which an engine's state is mapped
   to a value of type \tcode{result_type}.
\end{itemize}

\pnum
A class \tcode{E}
that meets the requirements
of a uniform random bit generator\iref{rand.req.urng}
also meets the requirements
of a \term{random number engine}
if the expressions shown
in \tref{rand.req.eng}
are valid and have the indicated semantics,
and if \tcode{E} also meets all other requirements
of this subclause \ref{rand.req.eng}.
In that Table and throughout this subclause:
\begin{itemize}
  \item
    \tcode{T} is the type named by
    \tcode{E}'s associated \tcode{result_type};
  \item
    \tcode{e} is a value of \tcode{E},
    \tcode{v} is an lvalue of \tcode{E},
    \tcode{x} and \tcode{y} are (possibly const) values of \tcode{E};
  \item
    \tcode{s} is a value of \tcode{T};
  \item
    \tcode{q} is an lvalue
    meeting the requirements of a seed sequence\iref{rand.req.seedseq};
  \item
    \tcode{z} is a value
    of type \tcode{unsigned long long};
  \item
    \tcode{os} is an lvalue of the type of some class template specialization
    \tcode{basic_ostream<charT,} \tcode{traits>};
  and
  \item
    \tcode{is} is an lvalue of the type of some class template specialization
    \tcode{basic_istream<charT,} \tcode{traits>};
\end{itemize}
where \tcode{charT} and \tcode{traits} are constrained
according to \ref{strings} and \ref{input.output}.

\begin{libreqtab4d}
  {Random number engine requirements}
  {rand.req.eng}
\\ \topline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endfirsthead
\hline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endhead
\tcode{E()}%
  &
  & Creates an engine
    with the same initial state
    as all other default-constructed engines
    of type \tcode{E}.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{E(x)}
  &
  & Creates an engine
    that compares equal to \tcode{x}.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{E(s)}%
  &
  & Creates an engine
      with initial state determined by \tcode{s}.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{E(q)}%
\begin{footnote}
  This constructor
  (as well as the subsequent corresponding \tcode{seed()} function)
  can be particularly useful
  to applications requiring
  a large number of independent random sequences.
\end{footnote}
  &
  & Creates an engine
    with an initial state
    that depends on a sequence
    produced by one call
    to \tcode{q.generate}.
  & same as complexity of \tcode{q.generate}
    called on a sequence
    whose length is size of state
  \\ \rowsep
\tcode{e.seed()}%
  & \keyword{void}
  & \ensures
    \tcode{e == E()}.
  & same as \tcode{E()}
  \\ \rowsep
\tcode{e.seed(s)}%
  & \keyword{void}
  & \ensures
    \tcode{e == E(s)}.
  & same as \tcode{E(s)}
  \\ \rowsep
\tcode{e.seed(q)}%
  & \keyword{void}
  & \ensures
    \tcode{e == E(q)}.
  & same as \tcode{E(q)}
  \\ \rowsep
\tcode{e()}%
  & \tcode{T}
  & Advances \tcode{e}'s state \state{e}{i} to
      \state{e}{i+1} $= \mathsf{TA}($\state{e}{i}$)$
    and returns
      $\mathsf{GA}($\state{e}{i}$)$.
  & per \ref{rand.req.urng}
  \\ \rowsep
\tcode{e.discard(z)}%
\begin{footnote}
  This operation is common
  in user code,
  and can often be implemented
  in an engine-specific manner
  so as to provide significant performance improvements
  over an equivalent naive loop
  that makes \tcode{z} consecutive calls \tcode{e()}.
\end{footnote}
  & \keyword{void}
  & Advances \tcode{e}'s state \state{e}{i}
      to $\tcode{e}_{i+\tcode{z}}$
      by any means equivalent to \tcode{z} consecutive calls \tcode{e()}.
  & no worse than the complexity
    of \tcode{z} consecutive calls \tcode{e()}
  \\ \rowsep
\tcode{x == y}%
  & \tcode{bool}
  & This operator is an equivalence relation.
    With $S_x$ and $S_y$
    as the infinite sequences of values
    that would be generated
    by repeated future calls
    to \tcode{x()} and \tcode{y()},
    respectively,
    returns \tcode{true}
      if $S_x = S_y$;
    else returns \tcode{false}.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{x != y}%
  & \tcode{bool}
  & \tcode{!(x == y)}.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{os << x}%
  & reference to the type of \tcode{os}
  & With \tcode{os.}\textit{fmtflags} set to
    \tcode{ios_base::dec|ios_base::left}
    and the fill character set to the space character,
    writes to \tcode{os}
    the textual representation
    of \tcode{x}'s current state.
    In the output,
    adjacent numbers are separated
    by one or more space characters.

    \ensures The \tcode{os.}\textit{fmtflags} and fill character are unchanged.
  & \bigoh{$\text{size of state}$}
  \\ \rowsep
\tcode{is >> v}%
  & reference to the type of \tcode{is}
  & With \tcode{is.fmtflags}
    set to \tcode{ios_base::dec},
    sets \tcode{v}'s state
    as determined by reading its textual representation from \tcode{is}.
    If bad input is encountered,
    ensures that \tcode{v}'s state is unchanged by the operation
    and
    calls \tcode{is.setstate(ios_base::failbit)}
    (which may throw \tcode{ios_base::failure}\iref{iostate.flags}).
    If a textual representation written via \tcode{os << x}
    was subsequently read via \tcode{is >> v},
    then \tcode{x == v}
    provided that there have been no intervening invocations
    of \tcode{x} or of \tcode{v}.

    \expects
    \tcode{is} provides a textual representation
    that was previously written
    using an output stream
    whose imbued locale
    was the same as that of \tcode{is},
    and whose type's template specialization arguments
    \tcode{charT} and \tcode{traits}
    were respectively the same as those of \tcode{is}.

    \ensures The \tcode{is.}\textit{fmtflags} are unchanged.
  & \bigoh{$\text{size of state}$}
  \\
\end{libreqtab4d}

\pnum
\tcode{E} shall meet the
\oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible})
and \oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}) requirements.
These operations shall each be of complexity
no worse than \bigoh{\text{size of state}}.


\indextext{requirements!random number engine|)}
\indextext{random number engine!requirements|)}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Random Number Engine Adaptor requirements:

\rSec3[rand.req.adapt]{Random number engine adaptor requirements}%

\pnum
A \term{random number engine adaptor}
(commonly shortened to \term{adaptor})
\tcode{a} of type \tcode{A}
is a random number engine
that takes values
produced by some other random number engine,
and applies an algorithm to those values
in order to deliver a sequence of values
with different randomness properties.
An engine \tcode{b} of type \tcode{B} adapted in this way
is termed a \term{base engine}
in this context.
The expression \tcode{a.base()} shall be valid and shall return a
const reference to \tcode{a}'s base engine.

\pnum
The requirements of a random number engine type
shall be interpreted as follows
with respect to a random number engine adaptor type.

\begin{itemdecl}
A::A();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 The base engine is initialized
 as if by its default constructor.
\end{itemdescr}

\begin{itemdecl}
bool operator==(const A& a1, const A& a2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
 \tcode{true} if \tcode{a1}'s base engine is equal to \tcode{a2}'s base engine.
 Otherwise returns \tcode{false}.
\end{itemdescr}

\begin{itemdecl}
A::A(result_type s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 The base engine is initialized
 with \tcode{s}.
\end{itemdescr}

\begin{itemdecl}
template<class Sseq> A::A(Sseq& q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 The base engine is initialized
 with \tcode{q}.
\end{itemdescr}

\begin{itemdecl}
void seed();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With \tcode{b} as the base engine, invokes \tcode{b.seed()}.
\end{itemdescr}

\begin{itemdecl}
void seed(result_type s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With \tcode{b} as the base engine, invokes \tcode{b.seed(s)}.
\end{itemdescr}

\begin{itemdecl}
template<class Sseq> void seed(Sseq& q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With \tcode{b} as the base engine, invokes \tcode{b.seed(q)}.
\end{itemdescr}

\pnum
\tcode{A} shall also meet
the following additional requirements:
\begin{itemize}
 \item
   The complexity
   of each function
   shall not exceed the complexity
   of the corresponding function
   applied to the base engine.
 \item
   The state
   of \tcode{A}
   shall include the state
   of its base engine.
   The size of \tcode{A}'s state
   shall be no less than the size of the base engine.
 \item
   Copying \tcode{A}'s state
   (e.g., during copy construction or copy assignment)
   shall include copying
   the state of the base engine of \tcode{A}.
 \item
   The textual representation
   of \tcode{A}
   shall include
   the textual representation of its base engine.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Random Number Distribution requirements:

\rSec3[rand.req.dist]{Random number distribution requirements}%
\indextext{random number distribution!requirements|(}%
\indextext{requirements!random number distribution|(}

\pnum
A \term{random number distribution}
(commonly shortened to \term{distribution})
\tcode{d} of type \tcode{D}
is a function object
returning values
that are distributed according to
an associated mathematical \term{probability density function}
$p(z)$
or according to
an associated \term{discrete probability function}
$P(z_i)$.
A distribution's specification
identifies its associated probability function
$p(z)$ or $P(z_i)$.

\pnum
An associated probability function is typically expressed
using certain externally-supplied quantities
known as the \term{parameters of the distribution}.
Such distribution parameters are identified
in this context by writing, for example,
  $p(z\,|\,a,b)$ or $P(z_i\,|\,a,b)$,
  to name specific parameters,
or by writing, for example,
  $p(z\,|\left\{\tcode{p}\right\})$
  or $P(z_i\,|\left\{\tcode{p}\right\})$,
  to denote a distribution's parameters \tcode{p} taken as a whole.

\pnum
A class \tcode{D}
meets the requirements
of a \term{random number distribution}
if the expressions shown
in \tref{rand.req.dist}
are valid and have the indicated semantics,
and if \tcode{D} and its associated types
also meet all other requirements
of this subclause \ref{rand.req.dist}.
In that Table and throughout this subclause,
\begin{itemize}
  \item
    \tcode{T} is the type named by
    \tcode{D}'s associated \tcode{result_type};
  \item
    \tcode{P} is the type named by
    \tcode{D}'s associated \tcode{param_type};
  \item
    \tcode{d} is a
    value of \tcode{D},
    and
    \tcode{x} and \tcode{y} are (possibly const) values of \tcode{D};
  \item
    \tcode{glb} and \tcode{lub}
    are values of \tcode{T}
    respectively corresponding to
    the greatest lower bound and the least upper bound
    on the values potentially returned by \tcode{d}'s \tcode{operator()},
    as determined by the current values of \tcode{d}'s parameters;
  \item
    \tcode{p} is a (possibly const) value of \tcode{P};
  \item
    \tcode{g}, \tcode{g1}, and \tcode{g2} are lvalues of a type
    meeting the requirements
    of a uniform random bit generator\iref{rand.req.urng};
  \item
    \tcode{os} is an lvalue of the type of some class template specialization
    \tcode{basic_ostream<charT,} \tcode{traits>};
  and
  \item
    \tcode{is} is an lvalue of the type of some class template specialization
    \tcode{basic_istream<charT,} \tcode{traits>};
\end{itemize}
where \tcode{charT} and \tcode{traits} are constrained
according to \ref{strings} and \ref{input.output}.

\begin{libreqtab4d}
  {Random number distribution requirements}
  {rand.req.dist}
\\ \topline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endfirsthead
\hline
\lhdr{Expression}
  & \chdr{Return type}
  & \chdr{Pre/post-condition}
  & \rhdr{Complexity}
  \\ \capsep
\endhead
\tcode{D::result_type}
  & \tcode{T}
  & \tcode{T} is an arithmetic type\iref{basic.fundamental}.
  & compile-time
  \\ \rowsep
\tcode{D::param_type}
  & \tcode{P}
  &
  & compile-time
  \\ \rowsep
\tcode{D()}%
  &
  & Creates a distribution whose behavior is indistinguishable
    from that of any other newly default-constructed distribution
    of type \tcode{D}.
  & constant
  \\ \rowsep
\tcode{D(p)}
  &
  & Creates a distribution whose behavior is indistinguishable
    from that of a distribution
    newly constructed directly from the values used to construct \tcode{p}.
  & same as \tcode{p}'s construction
  \\ \rowsep
\tcode{d.reset()}
  & \keyword{void}
  & Subsequent uses of \tcode{d} do not depend
    on values produced by any engine
    prior to invoking \tcode{reset}.
  & constant
  \\ \rowsep
\tcode{x.param()}
  & \tcode{P}
  & Returns a value
    \tcode{p} such that \tcode{D(p).param() == p}.
  & no worse than the complexity of \tcode{D(p)}
  \\ \rowsep
\tcode{d.param(p)}
  & \keyword{void}
  & \ensures \tcode{d.param() == p}.
  & no worse than the complexity of \tcode{D(p)}
  \\ \rowsep
\tcode{d(g)}
  & \tcode{T}
  & With $\texttt{p} = \texttt{d.param()}$,
    the sequence of numbers
    returned by successive invocations
    with the same object \tcode{g}
    is randomly distributed
    according to the associated
      $p(z\,|\left\{\texttt{p}\right\})$
    or
      $P(z_i\,|\left\{\texttt{p}\right\})$
    function.
  & amortized constant number of invocations of \tcode{g}
  \\ \rowsep
\tcode{d(g,p)}
  & \tcode{T}
  & The sequence of numbers
    returned by successive invocations
    with the same objects \tcode{g} and \tcode{p}
    is randomly distributed
    according to the associated
      $p(z\,|\left\{\texttt{p}\right\})$
    or
      $P(z_i\,|\left\{\texttt{p}\right\})$
    function.
  & amortized constant number of invocations of \tcode{g}
  \\ \rowsep
\tcode{x.min()}
  & \tcode{T}
  & Returns \tcode{glb}.
  & constant
  \\ \rowsep
\tcode{x.max()}
  & \tcode{T}
  & Returns \tcode{lub}.
  & constant
  \\ \rowsep
\tcode{x == y}%
  & \tcode{bool}
  & This operator is an equivalence relation.
    Returns \tcode{true}
      if \tcode{x.param() == y.param()} and $S_1 = S_2$,
      where $S_1$ and $S_2$ are
      the infinite sequences of values
      that would be generated, respectively,
      by repeated future calls
      to \tcode{x(g1)} and \tcode{y(g2)}
      whenever \tcode{g1 == g2}.
      Otherwise returns \tcode{false}.
  & constant
  \\ \rowsep
\tcode{x != y}%
  & \tcode{bool}
  & \tcode{!(x == y)}.
  & same as \tcode{x == y}.
  \\ \rowsep
\tcode{os << x}
  & reference to the type of \tcode{os}
  & Writes to \tcode{os} a textual representation
    for the parameters and the additional internal data of \tcode{x}.

    \ensures The \tcode{os.}\textit{fmtflags} and fill character are unchanged.
  &
  \\ \rowsep
\tcode{is >> d}
  & reference to the type of \tcode{is}
  & Restores from \tcode{is}
    the parameters and additional internal data of the lvalue \tcode{d}.
    If bad input is encountered,
    ensures that \tcode{d} is unchanged by the operation
    and
    calls \tcode{is.setstate(ios_base::failbit)}
    (which may throw \tcode{ios_base::failure}\iref{iostate.flags}).

    \expects
    \tcode{is} provides a textual representation
    that was previously written
    using an \tcode{os} whose imbued locale
    and whose type's template specialization arguments
    \tcode{charT} and \tcode{traits}
    were the same as those of \tcode{is}.

    \ensures The \tcode{is.}\textit{fmtflags} are unchanged.
  &
  \\
\end{libreqtab4d}

\pnum
\tcode{D} shall meet the
\oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible})
and \oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}) requirements.

\pnum
The sequence of numbers
produced by repeated invocations of \tcode{d(g)}
shall be independent of any invocation of
\tcode{os << d}
or of
any \keyword{const} member function of \tcode{D}
between any of the invocations of \tcode{d(g)}.

\pnum
If a textual representation is written using \tcode{os << x}
and that representation is restored
into the same or a different object \tcode{y}
of the same type using \tcode{is >> y},
repeated invocations of \tcode{y(g)}
shall produce the same sequence of numbers
as would repeated invocations of \tcode{x(g)}.

\pnum
It is unspecified whether \tcode{D::param_type}
is declared as a (nested) \keyword{class}
or via a \keyword{typedef}.
In this subclause \ref{rand},
declarations of \tcode{D::param_type}
are in the form of \keyword{typedef}s
for convenience of exposition only.

\pnum
\tcode{P} shall meet the
\oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible}),
\oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}),
and
\oldconcept{Equality\-Comp\-arable} (\tref{cpp17.equalitycomparable}) requirements.

\pnum
For each of the constructors of \tcode{D}
taking arguments corresponding to parameters of the distribution,
\tcode{P} shall have a corresponding constructor
subject to the same requirements
and taking arguments identical in number, type, and default values.
Moreover,
for each of the member functions of \tcode{D}
that return values corresponding to parameters of the distribution,
\tcode{P} shall have a corresponding member function
with the identical name, type, and semantics.

\pnum
\tcode{P} shall have a declaration of the form
\begin{codeblock}
using distribution_type =  D;
\end{codeblock}

\indextext{requirements!random number distribution|)}%
\indextext{random number distribution!requirements|)}%
\indextext{random number generation!requirements|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Engine class templates subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.eng]{Random number engine class templates}%

\rSec3[rand.eng.general]{General}%
\indextext{random number generation!engines|(}

\pnum
Each type instantiated
from a class template specified in \ref{rand.eng}
meets the requirements
of a random number engine\iref{rand.req.eng} type.

\pnum
Except where specified otherwise,
the complexity of each function
specified in \ref{rand.eng}
is constant.

\pnum
Except where specified otherwise,
no function described in \ref{rand.eng}
throws an exception.

\pnum
Every function described in \ref{rand.eng}
that has a function parameter \tcode{q} of type \tcode{Sseq\&}
for a template type parameter named \tcode{Sseq}
that is different from type \tcode{seed_seq}
throws what and when the invocation of \tcode{q.generate} throws.

\pnum
Descriptions are provided in \ref{rand.eng}
only for engine operations
that are not described in \ref{rand.req.eng}
or for operations where there is additional semantic information.
In particular,
declarations for copy constructors,
for copy assignment operators,
for streaming operators,
and for equality and inequality operators
are not shown in the synopses.

\pnum
Each template specified in \ref{rand.eng}
requires one or more relationships,
involving the value(s) of its non-type template parameter(s), to hold.
A program instantiating any of these templates
is ill-formed
if any such required relationship fails to hold.

\pnum
For every random number engine and for every random number engine adaptor \tcode{X}
defined in \ref{rand.eng} and in \ref{rand.adapt}:
\begin{itemize}
\item
if the constructor
\begin{codeblock}
template<class Sseq> explicit X(Sseq& q);
\end{codeblock}
is called with a type \tcode{Sseq} that does not qualify as a seed sequence, then this
constructor shall not participate in overload resolution;

\item
if the member function
\begin{codeblock}
template<class Sseq> void seed(Sseq& q);
\end{codeblock}
is called with a type \tcode{Sseq} that does not qualify as a seed sequence, then this
function shall not participate in overload resolution.
\end{itemize}

The extent to which an implementation determines that a type cannot be a seed sequence
is unspecified, except that as a minimum a type shall not qualify as a seed sequence
if it is implicitly convertible to \tcode{X::result_type}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% linear_congruential_engine engine:

\rSec3[rand.eng.lcong]{Class template \tcode{linear_congruential_engine}}%
\indexlibraryglobal{linear_congruential_engine}%

\pnum
A \tcode{linear_congruential_engine} random number engine
produces unsigned integer random numbers.
The state \state{x}{i}
of a \tcode{linear_congruential_engine} object \tcode{x}
is of size $1$
and consists of a single integer.
The transition algorithm
is a modular linear function of the form
$\mathsf{TA}(\state{x}{i}) = (a \cdot \state{x}{i} + c) \bmod m$;
the generation algorithm
is $\mathsf{GA}(\state{x}{i}) = \state{x}{i+1}$.

\indexlibraryglobal{linear_congruential_engine}%
\indexlibrarymember{result_type}{linear_congruential_engine}%
\begin{codeblock}
namespace std {
  template<class UIntType, UIntType a, UIntType c, UIntType m>
  class linear_congruential_engine {
  public:
    // types
    using result_type = UIntType;

    // engine characteristics
    static constexpr result_type multiplier = a;
    static constexpr result_type increment = c;
    static constexpr result_type modulus = m;
    static constexpr result_type min() { return c == 0u ? 1u: 0u; }
    static constexpr result_type max() { return m - 1u; }
    static constexpr result_type default_seed = 1u;

    // constructors and seeding functions
    linear_congruential_engine() : linear_congruential_engine(default_seed) {}
    explicit linear_congruential_engine(result_type s);
    template<class Sseq> explicit linear_congruential_engine(Sseq& q);
    void seed(result_type s = default_seed);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const linear_congruential_engine& x,
                           const linear_congruential_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const linear_congruential_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, linear_congruential_engine& x);
  };
}
\end{codeblock}

\pnum
If the template parameter
\tcode{m} is $0$,
the modulus $m$
used throughout this subclause~\ref{rand.eng.lcong}
is \tcode{numeric_limits<result_type>::max()} plus $1$.
\begin{note}
 $m$ need not be representable
 as a value of type \tcode{result_type}.
\end{note}

\pnum
If the template parameter
\tcode{m} is not $0$,
the following relations shall hold:
  \tcode{a < m}
and
  \tcode{c < m}.

\pnum
The textual representation
consists of
the value of \state{x}{i}.

\indexlibraryctor{linear_congruential_engine}%
\begin{itemdecl}
explicit linear_congruential_engine(result_type s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 If $c \bmod m$ is $0$ and $\tcode{s} \bmod m$ is $0$,
 sets the engine's state to $1$,
 otherwise sets the engine's state to $\tcode{s} \bmod m$.
\end{itemdescr}

\indexlibraryctor{linear_congruential_engine}%
\begin{itemdecl}
template<class Sseq> explicit linear_congruential_engine(Sseq& q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With
 $k = \left\lceil \frac{\log_2 m}{32} \right\rceil$
 and $a$ an array (or equivalent)
 of length $k + 3$,
 invokes \tcode{q.generate($a + 0$, $a + k + 3$)}
 and then computes
 $S = \left(\sum_{j = 0}^{k - 1} a_{j + 3} \cdot 2^{32j} \right) \bmod m$.
 If $c \bmod m$ is $0$ and $S$ is $0$,
 sets the engine's state to $1$,
 else sets the engine's state
 to $S$.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% mersenne_twister_engine engine:

\rSec3[rand.eng.mers]{Class template \tcode{mersenne_twister_engine}}%
\indexlibraryglobal{mersenne_twister_engine}%

\pnum
A \tcode{mersenne_twister_engine} random number
engine
\begin{footnote}
The name of this engine refers, in part, to a property of its period:
 For properly-selected values of the parameters,
 the period is closely related to a large Mersenne prime number.
\end{footnote}
produces unsigned integer random numbers
in the closed interval $[0,2^w-1]$.
The
state
\state{x}{i}
of a \tcode{mersenne_twister_engine} object \tcode{x}
is of size $n$
and consists of a sequence $X$
of $n$ values of the type delivered by \tcode{x};
all subscripts applied to $X$ are to be taken modulo $n$.

\pnum
The transition algorithm
employs a twisted generalized feedback shift register
defined by shift values $n$ and $m$, a twist value $r$,
and a conditional xor-mask $a$.
To improve the uniformity of the result,
the bits of the raw shift register are additionally \term{tempered}
(i.e., scrambled) according to a bit-scrambling matrix
defined by values $u$, $d$, $s$, $b$, $t$, $c$, and $\ell$.

The state transition is performed as follows:
\begin{itemize}
 \item
   Concatenate
     the upper $w-r$ bits of $X_{i-n}$
   with
     the lower $r$ bits of $X_{i+1-n}$
   to obtain an unsigned integer value $Y$.
 \item
   With $\alpha = a \cdot (Y \bitand 1)$,
   set $X_i$ to
     $X_{i+m-n} \xor (Y \rightshift 1) \xor \alpha$.
\end{itemize}
The sequence $X$ is initialized
with the help of an initialization multiplier $f$.

\pnum
The generation algorithm
 determines the unsigned integer values $z_1, z_2, z_3, z_4$ as follows,
 then delivers $z_4$ as its result:
\begin{itemize}
 \item
   Let $z_1 = X_i \xor \bigl(( X_i \rightshift u ) \bitand d\bigr)$.
 \item
   Let $z_2 = z_1 \xor \bigl( (z_1 \leftshift{w} s) \bitand b \bigr)$.
 \item
   Let $z_3 = z_2 \xor \bigl( (z_2 \leftshift{w} t) \bitand c \bigr)$.
 \item
   Let $z_4 = z_3 \xor ( z_3 \rightshift \ell )$.
\end{itemize}

\indexlibraryglobal{mersenne_twister_engine}%
\indexlibrarymember{result_type}{mersenne_twister_engine}%
\begin{codeblock}
namespace std {
  template<class UIntType, size_t w, size_t n, size_t m, size_t r,
           UIntType a, size_t u, UIntType d, size_t s,
           UIntType b, size_t t,
           UIntType c, size_t l, UIntType f>
  class mersenne_twister_engine {
  public:
    // types
    using result_type = UIntType;

    // engine characteristics
    static constexpr size_t word_size = w;
    static constexpr size_t state_size = n;
    static constexpr size_t shift_size = m;
    static constexpr size_t mask_bits = r;
    static constexpr UIntType xor_mask = a;
    static constexpr size_t tempering_u = u;
    static constexpr UIntType tempering_d = d;
    static constexpr size_t tempering_s = s;
    static constexpr UIntType tempering_b = b;
    static constexpr size_t tempering_t = t;
    static constexpr UIntType tempering_c = c;
    static constexpr size_t tempering_l = l;
    static constexpr UIntType initialization_multiplier = f;
    static constexpr result_type min() { return 0; }
    static constexpr result_type max() { return  @$2^w - 1$@; }
    static constexpr result_type default_seed = 5489u;

    // constructors and seeding functions
    mersenne_twister_engine() : mersenne_twister_engine(default_seed) {}
    explicit mersenne_twister_engine(result_type value);
    template<class Sseq> explicit mersenne_twister_engine(Sseq& q);
    void seed(result_type value = default_seed);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const mersenne_twister_engine& x, const mersenne_twister_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const mersenne_twister_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, mersenne_twister_engine& x);
  };
}
\end{codeblock}

\pnum
The following relations shall hold:
  \tcode{0 < m},
  \tcode{m <= n},
  \tcode{2u < w},
  \tcode{r <= w},
  \tcode{u <= w},
  \tcode{s <= w},
  \tcode{t <= w},
  \tcode{l <= w},
  \tcode{w <= numeric_limits<UIntType>::digits},
  \tcode{a <= (1u<<w) - 1u},
  \tcode{b <= (1u<<w) - 1u},
  \tcode{c <= (1u<<w) - 1u},
  \tcode{d <= (1u<<w) - 1u},
and
  \tcode{f <= (1u<<w) - 1u}.

\pnum
The textual representation
of \state{x}{i}
consists of the values of $X_{i - n}, \dotsc, X_{i - 1}$,
in that order.

\indexlibraryctor{mersenne_twister_engine}%
\begin{itemdecl}
explicit mersenne_twister_engine(result_type value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets $X_{-n}$ to $\tcode{value} \bmod 2^w$.
Then, iteratively for $i = 1 - n, \dotsc, -1$, sets $X_i$ to
\[%
 \bigl[f \cdot
       \bigl(X_{i-1} \xor \bigl(X_{i-1} \rightshift (w-2)\bigr)
       \bigr)
       + i \bmod n
 \bigr] \bmod 2^w
\; \mbox{.}
\]%

\pnum
\complexity
\bigoh{n}.
\end{itemdescr}

\indexlibraryctor{mersenne_twister_engine}%
\begin{itemdecl}
template<class Sseq> explicit mersenne_twister_engine(Sseq& q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With
 $k = \left\lceil w / 32 \right\rceil$
 and $a$ an array (or equivalent)
 of length $n \cdot k$,
 invokes \tcode{q.generate($a+0$, $a+n \cdot k$)}
 and then, iteratively for $i = -n,\dotsc,-1$,
 sets $X_i$
 to $\left(\sum_{j=0}^{k-1}a_{k(i+n)+j} \cdot 2^{32j} \right) \bmod 2^w$.
 Finally,
 if the most significant $w-r$ bits of $X_{-n}$
 are zero,
 and if each of the other resulting $X_i$ is $0$,
 changes $X_{-n}$
 to $ 2^{w-1} $.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subtract_with_carry_engine engine:

\rSec3[rand.eng.sub]{Class template \tcode{subtract_with_carry_engine}}%
\indexlibraryglobal{subtract_with_carry_engine}%

\pnum
A \tcode{subtract_with_carry_engine} random number engine
produces unsigned integer random numbers.

\pnum
The state \state{x}{i}
of a \tcode{subtract_with_carry_engine} object \tcode{x}
is of size
\bigoh{r},
and consists of
a sequence $X$ of $r$ integer values $0 \leq X_i < m \,= 2^w$;
all subscripts applied to $X$ are to be taken modulo $r$.
The state \state{x}{i}
additionally consists of an integer $c$
(known as the \term{carry})
whose value is either $0$ or $1$.

\pnum
The state transition
is performed as follows:
\begin{itemize}
 \item
   Let $Y = X_{i-s} - X_{i-r} - c$.
 \item
   Set $X_i$ to $y = Y \bmod m$.
   Set $c$ to 1 if $Y < 0$,
   otherwise set $c$ to 0.
\end{itemize}
\begin{note}
 This algorithm corresponds
 to a modular linear function
 of the form
 $\mathsf{TA}(\state{x}{i}) = (a \cdot \state{x}{i}) \bmod b$,
 where $b$ is of the form
 $m^r - m^s + 1$
 and $a = b - (b - 1) / m$.
\end{note}

\pnum
The generation algorithm
is given by $\mathsf{GA}(\state{x}{i}) = y$,
where $y$ is the value produced as a result
of advancing the engine's state as described above.

\indexlibraryglobal{subtract_with_carry_engine}%
\indexlibrarymember{result_type}{subtract_with_carry_engine}%
\begin{codeblock}
namespace std {
  template<class UIntType, size_t w, size_t s, size_t r>
  class subtract_with_carry_engine {
  public:
    // types
    using result_type = UIntType;

    // engine characteristics
    static constexpr size_t word_size = w;
    static constexpr size_t short_lag = s;
    static constexpr size_t long_lag = r;
    static constexpr result_type min() { return 0; }
    static constexpr result_type max() { return @$m - 1$@; }
    static constexpr result_type default_seed = 19780503u;

    // constructors and seeding functions
    subtract_with_carry_engine() : subtract_with_carry_engine(default_seed) {}
    explicit subtract_with_carry_engine(result_type value);
    template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);
    void seed(result_type value = default_seed);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const subtract_with_carry_engine& x,
                           const subtract_with_carry_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const subtract_with_carry_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, subtract_with_carry_engine& x);
  };
}
\end{codeblock}

\pnum
The following relations shall hold:
  \tcode{0u < s},
  \tcode{s < r},
  \tcode{0 < w},
and
  \tcode{w <= numeric_limits<UIntType>::digits}.

\pnum
The textual representation
consists of the values of
 $X_{i-r}, \dotsc, X_{i-1}$,
in that order, followed by $c$.

\indexlibraryctor{subtract_with_carry_engine}%
\begin{itemdecl}
explicit subtract_with_carry_engine(result_type value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 Sets the values of
 $X_{-r}, \dotsc, X_{-1}$,
 in that order, as specified below.
 If $X_{-1}$ is then $0$,
 sets $c$ to $1$;
 otherwise sets $c$ to $0$.

 To set the values $X_k$,
 first construct \tcode{e}, a \tcode{linear_congruential_engine} object,
 as if by the following definition:
\begin{codeblock}
linear_congruential_engine<result_type,
                          40014u,0u,2147483563u> e(value == 0u ? default_seed : value);
\end{codeblock}
 Then, to set each $X_k$,
 obtain new values $z_0, \dotsc, z_{n-1}$
 from $n = \lceil w/32 \rceil$ successive invocations
 of \tcode{e}.
 Set $X_k$ to $\left( \sum_{j=0}^{n-1} z_j \cdot 2^{32j}\right) \bmod m$.

\pnum
\complexity
Exactly $n \cdot \tcode{r}$ invocations
 of \tcode{e}.
\end{itemdescr}

\indexlibraryctor{subtract_with_carry_engine}%
\begin{itemdecl}
template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 With
 $k = \left\lceil w / 32 \right\rceil$
 and $a$ an array (or equivalent)
 of length $r \cdot k$,
 invokes \tcode{q.generate($a + 0$, $a + r \cdot k$)}
 and then, iteratively for $i = -r, \dotsc, -1$,
 sets $X_i$
 to $ \left(\sum_{j=0}^{k-1}a_{k(i+r)+j} \cdot 2^{32j} \right) \bmod m $.
 If $X_{-1}$ is then $0$,
 sets $c$ to $1$;
 otherwise sets $c$ to $0$.
\end{itemdescr}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Engine adaptors class templates subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.adapt]{Random number engine adaptor class templates}

\rSec3[rand.adapt.general]{In general}

\pnum
Each type instantiated
from a class template specified in this subclause~\ref{rand.adapt}
meets the requirements
of a random number engine adaptor\iref{rand.req.adapt} type.

\pnum
Except where specified otherwise,
the complexity of each function
specified in this subclause~\ref{rand.adapt}
is constant.

\pnum
Except where specified otherwise,
no function described in this subclause~\ref{rand.adapt}
throws an exception.

\pnum
Every function described in this subclause~\ref{rand.adapt}
that has a function parameter \tcode{q} of type \tcode{Sseq\&}
for a template type parameter named \tcode{Sseq}
that is different from type \tcode{seed_seq}
throws what and when the invocation of \tcode{q.generate} throws.

\pnum
Descriptions are provided in this subclause~\ref{rand.adapt}
only for adaptor operations
that are not described in subclause~\ref{rand.req.adapt}
or for operations where there is additional semantic information.
In particular,
declarations for copy constructors,
for copy assignment operators,
for streaming operators,
and for equality and inequality operators
are not shown in the synopses.

\pnum
Each template specified in this subclause~\ref{rand.adapt}
requires one or more relationships,
involving the value(s) of its non-type template parameter(s), to hold.
A program instantiating any of these templates
is ill-formed
if any such required relationship fails to hold.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% discard_block_engine engine adaptor:

\rSec3[rand.adapt.disc]{Class template \tcode{discard_block_engine}}%
\indexlibraryglobal{discard_block_engine}%

\pnum
A \tcode{discard_block_engine} random number engine adaptor
produces random numbers
selected from those produced by some base engine $e$.
The state \state{x}{i}
of a \tcode{discard_block_engine} engine adaptor object \tcode{x}
consists of the state \state{e}{i} of its base engine \tcode{e}
and an additional integer $n$.
The size of the state is
 the size of $e$'s state plus $1$.

\pnum
The transition algorithm
discards all but $r > 0$ values
from each block of $p \geq r$ values delivered by $e$.
The state transition is performed as follows:
If $n \geq r$,
 advance the state of \tcode{e} from \state{e}{i} to \state{e}{i+p-r}
 and set $n$ to $0$.
In any case,
 then increment $n$
 and advance \tcode{e}'s then-current state \state{e}{j}
 to \state{e}{j+1}.

\pnum
The generation algorithm
yields the value returned by the last invocation of \tcode{e()}
 while advancing \tcode{e}'s state as described above.

\indexlibraryglobal{discard_block_engine}%
\indexlibrarymember{result_type}{discard_block_engine}%
\begin{codeblock}
namespace std {
  template<class Engine, size_t p, size_t r>
  class discard_block_engine {
  public:
    // types
    using result_type = typename Engine::result_type;

    // engine characteristics
    static constexpr size_t block_size = p;
    static constexpr size_t used_block = r;
    static constexpr result_type min() { return Engine::min(); }
    static constexpr result_type max() { return Engine::max(); }

    // constructors and seeding functions
    discard_block_engine();
    explicit discard_block_engine(const Engine& e);
    explicit discard_block_engine(Engine&& e);
    explicit discard_block_engine(result_type s);
    template<class Sseq> explicit discard_block_engine(Sseq& q);
    void seed();
    void seed(result_type s);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const discard_block_engine& x, const discard_block_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // property functions
    const Engine& base() const noexcept { return e; }

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const discard_block_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, discard_block_engine& x);

  private:
    Engine e;   // \expos
    size_t n;   // \expos
  };
}
\end{codeblock}

\pnum
The following relations shall hold:
  \tcode{0 < r}
and
  \tcode{r <= p}.

\pnum
The textual representation
consists of
 the textual representation of \tcode{e}
followed by
 the value of \tcode{n}.

\pnum
In addition to its behavior
pursuant to subclause~\ref{rand.req.adapt},
each constructor%
\indexlibraryctor{discard_block_engine}
that is not a copy constructor
sets \tcode{n} to $0$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% independent_bits_engine engine adaptor:\exposid{

\rSec3[rand.adapt.ibits]{Class template \tcode{independent_bits_engine}}%
\indexlibraryglobal{independent_bits_engine}%

\pnum
An \tcode{independent_bits_engine}
random number engine adaptor
combines random numbers
that are produced by some base engine $e$,
so as to produce random numbers
with a specified number of bits $w$.
The state \state{x}{i}
of an \tcode{independent_bits_engine}
engine adaptor object \tcode{x}
consists of
 the state \state{e}{i} of its base engine \tcode{e};
the size of the state is
 the size of $e$'s state.

\pnum
The transition and generation algorithms
are described in terms
of the following integral constants:%
\begin{itemize}
 \item
   Let
     $R = \tcode{e.max() - e.min() + 1}$
   and
     $m = \left\lfloor \log_2 R \right\rfloor$.
 \item
   With $n$ as determined below,
   let
     $w_0 = \left\lfloor w / n \right\rfloor$,
     $n_0 = n - w \bmod n$,
     $y_0 = 2^{w_0} \left\lfloor R / 2^{w_0} \right\rfloor$,
   and
     $y_1 = 2^{w_0 + 1} \left\lfloor R / 2^{w_0 + 1} \right\rfloor$.
 \item
   Let
     $n = \left\lceil w / m \right\rceil$
   if and only if the relation
     $R - y_0 \leq \left\lfloor y_0 / n \right\rfloor$
   holds as a result.
   Otherwise let
     $n = 1 + \left\lceil w / m \right\rceil$.
\end{itemize}
\begin{note}
 The relation
 $w = n_0 w_0 + (n - n_0)(w_0 + 1)$
 always holds.
\end{note}

\pnum
The transition algorithm
is carried out by invoking \tcode{e()}
as often as needed to obtain $n_0$
values less than $y_0 + \tcode{e.min()}$
and $n - n_0$ values less than $y_1 + \tcode{e.min()}$.

\pnum
The generation algorithm
uses the values produced
while advancing the state as described above
to yield a quantity $S$
obtained as if by the following algorithm:
\begin{codeblock}
@$S$@ = 0;
for (@$k$@ = @$0$@; @$k \neq n_0$@; @$k$@ += @$1$@)  {
 do @$u$@ = e() - e.min(); while (@$u \ge y_0$@);
 @$S$@ = @$2^{w_0} \cdot S + u \bmod 2^{w_0}$@;
}
for (@$k$@ = @$n_0$@; @$k \neq n$@; @$k$@ += @$1$@)  {
 do @$u$@ = e() - e.min(); while (@$u \ge y_1$@);
 @$S$@ = @$2^{w_0 + 1} \cdot S + u \bmod 2^{w_0 + 1}$@;
}
\end{codeblock}

\indexlibraryglobal{independent_bits_engine}%
\indexlibrarymember{result_type}{independent_bits_engine}%
\begin{codeblock}
template<class Engine, size_t w, class UIntType>
  class independent_bits_engine {
  public:
    // types
    using result_type = UIntType;

    // engine characteristics
    static constexpr result_type min() { return 0; }
    static constexpr result_type max() { return @$2^w - 1$@; }

    // constructors and seeding functions
    independent_bits_engine();
    explicit independent_bits_engine(const Engine& e);
    explicit independent_bits_engine(Engine&& e);
    explicit independent_bits_engine(result_type s);
    template<class Sseq> explicit independent_bits_engine(Sseq& q);
    void seed();
    void seed(result_type s);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const independent_bits_engine& x, const independent_bits_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // property functions
    const Engine& base() const noexcept { return e; }

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const independent_bits_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, independent_bits_engine& x);

  private:
    Engine e;   // \expos
  };
\end{codeblock}%

\pnum
The following relations shall hold:
  \tcode{0 < w}
and
  \tcode{w <= numeric_limits<result_type>::digits}.

\pnum
The textual representation
consists of the textual representation of \tcode{e}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% shuffle_order_engine engine adaptor:

\rSec3[rand.adapt.shuf]{Class template \tcode{shuffle_order_engine}}%
\indexlibraryglobal{shuffle_order_engine}%

\pnum
A \tcode{shuffle_order_engine} random number engine adaptor
produces the same random numbers
that are produced by some base engine $e$,
but delivers them in a different sequence.
The state \state{x}{i}
of a \tcode{shuffle_order_engine} engine adaptor object \tcode{x}
consists of
 the state \state{e}{i} of its base engine \tcode{e},
 an additional value $Y$ of the type delivered by \tcode{e},
and
 an additional sequence $V$ of $k$ values
 also of the type delivered by \tcode{e}.
The size of the state is
 the size of $e$'s state plus $k + 1$.

\pnum
The transition algorithm
permutes the values produced by $e$.
The state transition is performed as follows:
\begin{itemize}
 \item
   Calculate an integer
   $j = \left\lfloor \frac{k \cdot (Y - e_{\min})}
                          {e_{\max} - e_{\min} +1}
        \right\rfloor
   $%
   .
 \item
   Set $Y$ to $V_j$ and then set $V_j$ to $\tcode{e()}$.
\end{itemize}

\pnum
The generation algorithm
yields the last value of \tcode{Y}
 produced while advancing \tcode{e}'s state as described above.

\indexlibraryglobal{shuffle_order_engine}%
\indexlibrarymember{result_type}{shuffle_order_engine}%
\begin{codeblock}
namespace std {
  template<class Engine, size_t k>
  class shuffle_order_engine {
  public:
    // types
    using result_type = typename Engine::result_type;

    // engine characteristics
    static constexpr size_t table_size = k;
    static constexpr result_type min() { return Engine::min(); }
    static constexpr result_type max() { return Engine::max(); }

    // constructors and seeding functions
    shuffle_order_engine();
    explicit shuffle_order_engine(const Engine& e);
    explicit shuffle_order_engine(Engine&& e);
    explicit shuffle_order_engine(result_type s);
    template<class Sseq> explicit shuffle_order_engine(Sseq& q);
    void seed();
    void seed(result_type s);
    template<class Sseq> void seed(Sseq& q);

    // equality operators
    friend bool operator==(const shuffle_order_engine& x, const shuffle_order_engine& y);

    // generating functions
    result_type operator()();
    void discard(unsigned long long z);

    // property functions
    const Engine& base() const noexcept { return e; }

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const shuffle_order_engine& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, shuffle_order_engine& x);

  private:
    Engine e;           // \expos
    result_type V[k];   // \expos
    result_type Y;      // \expos
  };
}
\end{codeblock}

\pnum
The following relation shall hold:
  \tcode{0 < k}.

\pnum
The textual representation
consists of
 the textual representation of \tcode{e},
followed by
 the \tcode{k} values of $V$,
followed by
 the value of $Y$.

\pnum
In addition to its behavior
pursuant to subclause~\ref{rand.req.adapt},
each constructor%
\indexlibraryctor{shuffle_order_engine}
that is not a copy constructor
initializes $\tcode{V[0]}, \dotsc, \tcode{V[k-1]}$ and $Y$,
in that order,
with values returned by successive invocations of \tcode{e()}.%
\indextext{random number generation!engines|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Engines with predefined parameters subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.predef]{Engines and engine adaptors with predefined parameters}%
\indextext{random number engine!with predefined parameters|(}%
\indextext{random number engine adaptor!with predefined parameters|(}%
\indextext{random number generation!predefined engines and adaptors|(}

\indexlibraryglobal{minstd_rand0}%
\begin{itemdecl}
using minstd_rand0 =
      linear_congruential_engine<uint_fast32_t, 16'807, 0, 2'147'483'647>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{minstd_rand0}
 produces the value $1043618065$.
\end{itemdescr}

\indexlibraryglobal{minstd_rand}%
\begin{itemdecl}
using minstd_rand =
      linear_congruential_engine<uint_fast32_t, 48'271, 0, 2'147'483'647>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{minstd_rand}
 produces the value $399268537$.
\end{itemdescr}

\indexlibraryglobal{mt19937}%
\begin{itemdecl}
using mt19937 =
      mersenne_twister_engine<uint_fast32_t, 32, 624, 397, 31,
       0x9908'b0df, 11, 0xffff'ffff, 7, 0x9d2c'5680, 15, 0xefc6'0000, 18, 1'812'433'253>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{mt19937}
 produces the value $4123659995$.
\end{itemdescr}

\indexlibraryglobal{mt19937_64}%
\begin{itemdecl}
using mt19937_64 =
      mersenne_twister_engine<uint_fast64_t, 64, 312, 156, 31,
       0xb502'6f5a'a966'19e9, 29, 0x5555'5555'5555'5555, 17,
       0x71d6'7fff'eda6'0000, 37, 0xfff7'eee0'0000'0000, 43, 6'364'136'223'846'793'005>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{mt19937_64}
 produces the value $9981545732273789042$.
\end{itemdescr}

\indexlibraryglobal{ranlux24_base}%
\begin{itemdecl}
using ranlux24_base =
      subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{ran\-lux24_base}
 produces the value
 $7937952$.
\end{itemdescr}

\indexlibraryglobal{ranlux48_base}%
\begin{itemdecl}
using ranlux48_base =
      subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{ran\-lux48_base}
 produces the value
 $61839128582725$.
\end{itemdescr}

\indexlibraryglobal{ranlux24}%
\begin{itemdecl}
using ranlux24 = discard_block_engine<ranlux24_base, 223, 23>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{ranlux24}
 produces the value
 $9901578$.
\end{itemdescr}

\indexlibraryglobal{ranlux48}%
\begin{itemdecl}
using ranlux48 = discard_block_engine<ranlux48_base, 389, 11>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{ranlux48}
 produces the value
 $249142670248501$.
\end{itemdescr}

\indexlibraryglobal{knuth_b}%
\begin{itemdecl}
using knuth_b = shuffle_order_engine<minstd_rand0,256>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\required
 The $10000^\text{th}$ consecutive invocation
 of a default-constructed object
 of type \tcode{knuth_b}
 produces the value $1112339016$.
\end{itemdescr}%

\indexlibraryglobal{default_random_engine}%
\begin{itemdecl}
using default_random_engine = @\textit{\impldef{type of \tcode{default_random_engine}}}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
The choice of engine type
named by this \keyword{typedef}
is \impldef{type of \tcode{default_random_engine}}.
\begin{note}
 The implementation
 can select this type
 on the basis of performance,
 size,
 quality,
 or any combination of such factors,
 so as to provide at least acceptable engine behavior
 for relatively casual, inexpert, and/or lightweight use.
 Because different implementations
 can select different underlying engine types,
 code that uses this \keyword{typedef}
 need not generate identical sequences across implementations.
\end{note}
\end{itemdescr}%
\indextext{random number generation!predefined engines and adaptors|)}%
\indextext{random number engine adaptor!with predefined parameters|)}%
\indextext{random number engine!with predefined parameters|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% random_device class subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.device]{Class \tcode{random_device}}%
\indexlibraryglobal{random_device}%

\pnum
A \tcode{random_device}
uniform random bit generator
produces nondeterministic random numbers.

\pnum
If implementation limitations
prevent generating nondeterministic random numbers,
the implementation may employ a random number engine.

\indexlibraryglobal{random_device}%
\indexlibrarymember{result_type}{random_device}%
\begin{codeblock}
namespace std {
  class random_device {
  public:
    // types
    using result_type = unsigned int;

    // generator characteristics
    static constexpr result_type min() { return numeric_limits<result_type>::min(); }
    static constexpr result_type max() { return numeric_limits<result_type>::max(); }

    // constructors
    random_device() : random_device(@\textit{implementation-defined}@) {}
    explicit random_device(const string& token);

    // generating functions
    result_type operator()();

    // property functions
    double entropy() const noexcept;

    @\textit{// no copy functions}@
    random_device(const random_device&) = delete;
    void operator=(const random_device&) = delete;
  };
}
\end{codeblock}


\indexlibraryctor{random_device}%
\begin{itemdecl}
explicit random_device(const string& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
A value of an \impldef{exception type when \tcode{random_device} constructor fails} type
 derived from \tcode{exception}
 if the \tcode{random_device} cannot be initialized.

\pnum
\remarks
 The semantics of the \tcode{token} parameter
 and the token value used by the default constructor are
 \impldef{semantics of \tcode{token} parameter and default token value used by \tcode{random_device} constructors}.
\begin{footnote}
The parameter is intended
   to allow an implementation to differentiate
   between different sources of randomness.
\end{footnote}
\end{itemdescr}

\indexlibrarymember{entropy}{random_device}%
\begin{itemdecl}
double entropy() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If the implementation employs a random number engine,
 returns $0.0$.
 Otherwise, returns an entropy estimate
\begin{footnote}
If a device has $n$ states
   whose respective probabilities are
   $P_0, \dotsc, P_{n-1}$,
   the device entropy $S$ is defined as\\
   $S = - \sum_{i=0}^{n-1} P_i \cdot \log P_i$.
\end{footnote}
 for the random numbers returned by \tcode{operator()},
 in the range
   \tcode{min()}
 to
   $\log_2( \tcode{max()}+1)$.
\end{itemdescr}

\indexlibrarymember{operator()}{random_device}%
\begin{itemdecl}
result_type operator()();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A nondeterministic random value,
 uniformly distributed
 between \tcode{min()} and \tcode{max()} (inclusive).
 It is \impldef{how \tcode{random_device::operator()} generates values}
 how these values are generated.

\pnum
\throws
A value of an \impldef{exception type when \tcode{random_device::operator()} fails}
 type derived from \tcode{exception}
 if a random number cannot be obtained.
\end{itemdescr}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% utilities subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.util]{Utilities}%
\indextext{random number generation!utilities|(}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% class seed_seq:

\rSec3[rand.util.seedseq]{Class \tcode{seed_seq}}%

\indexlibraryglobal{seed_seq}%
\indexlibrarymember{result_type}{seed_seq}%
\begin{codeblock}
namespace std {
  class seed_seq {
  public:
    // types
    using result_type = uint_least32_t;

    // constructors
    seed_seq() noexcept;
    template<class T>
      seed_seq(initializer_list<T> il);
    template<class InputIterator>
      seed_seq(InputIterator begin, InputIterator end);

    // generating functions
    template<class RandomAccessIterator>
      void generate(RandomAccessIterator begin, RandomAccessIterator end);

    // property functions
    size_t size() const noexcept;
    template<class OutputIterator>
      void param(OutputIterator dest) const;

    // no copy functions
    seed_seq(const seed_seq&) = delete;
    void operator=(const seed_seq&) = delete;

  private:
    vector<result_type> v;      // \expos
  };
}
\end{codeblock}


\indexlibraryctor{seed_seq}%
\begin{itemdecl}
seed_seq() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{v.empty()} is \tcode{true}.
\end{itemdescr}


\indexlibraryctor{seed_seq}%
\begin{itemdecl}
template<class T>
  seed_seq(initializer_list<T> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{T} is an integer type.

\pnum
\effects
 Same as \tcode{seed_seq(il.begin(), il.end())}.
\end{itemdescr}


\indexlibraryctor{seed_seq}%
\begin{itemdecl}
template<class InputIterator>
  seed_seq(InputIterator begin, InputIterator end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  \tcode{iterator_traits<InputIterator>::value_type}
  is an integer type.

\pnum
\expects
  \tcode{InputIterator} meets the
  \oldconcept{InputIterator} requirements\iref{input.iterators}.

\pnum
\effects
Initializes \tcode{v}
by the following algorithm:
\begin{codeblock}
for (InputIterator s = begin; s != end; ++s)
 v.push_back((*s)@$\bmod 2^{32}$@);
\end{codeblock}%
\end{itemdescr}

\indexlibrarymember{generate}{seed_seq}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void generate(RandomAccessIterator begin, RandomAccessIterator end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  \tcode{iterator_traits<RandomAccessIterator>::\brk{}value_type}
  is an unsigned integer type capable of accommodating 32-bit quantities.

\pnum
\expects
  \tcode{RandomAccessIterator} meets the
  \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}
  and the requirements of a mutable iterator.

\pnum
\effects
 Does nothing if \tcode{begin == end}.
 Otherwise,
 with $s = \tcode{v.size()}$
 and  $n = \tcode{end} - \tcode{begin}$,
 fills the supplied range $[\tcode{begin},\tcode{end})$
 according to the following algorithm
 in which
 each operation is to be carried out modulo $2^{32}$,
 each indexing operator applied to \tcode{begin} is to be taken modulo $n$,
 and $T(x)$ is defined as $x \xor (x \rightshift 27)$:

\begin{itemize}
 \item
   By way of initialization,
   set each element of the range to the value \tcode{0x8b8b8b8b}.
   Additionally,
   for use in subsequent steps,
   let $p = (n - t) / 2$
   and let $q = p + t$,
   where
   \[%
     t = (n \ge 623) \mbox{ ? } 11 \mbox{ : } (n \ge 68) \mbox{ ? } 7 \mbox{ : } (n \ge 39) \mbox{ ? } 5 \mbox{ : } (n \ge 7) \mbox{ ? } 3 \mbox{ : } (n - 1)/2;
   \]%
 \item
   With $m$ as the larger of $s + 1$ and $n$,
   transform the elements of the range:
   iteratively for $k = 0, \dotsc, m - 1$,
   calculate values
   \begin{eqnarray*}
     r_1 & = &
       1664525 \cdot T(    \tcode{begin[}k\tcode{]}
                      \xor \tcode{begin[}k+p\tcode{]}
                      \xor \tcode{begin[}k-1 \tcode{]}
                      )
     \\
     r_2 & = & r_1 + \left\{
       \begin{array}{cl}
         s                                  & \mbox{,  } k = 0
         \\
         k \bmod n + \tcode{v[}k-1\tcode{]} & \mbox{,  } 0 < k \le s
         \\
         k \bmod n                          & \mbox{,  } s < k
       \end{array}
     \right.
   \end{eqnarray*}
   and, in order,
   increment \tcode{begin[$k+p$]} by $r_1$,
   increment \tcode{begin[$k+q$]} by $r_2$,
   and
   set \tcode{begin[$k$]} to $r_2$.
 \item
   Transform the elements of the range again,
   beginning where the previous step ended:
   iteratively for $k = m, \dotsc, m + n - 1$,
   calculate values
   \begin{eqnarray*}
     r_3 & = &
       1566083941 \cdot T( \tcode{begin[}k  \tcode{]}
                         + \tcode{begin[}k+p\tcode{]}
                         + \tcode{begin[}k-1\tcode{]}
                         )
     \\
     r_4 & = & r_3 - (k \bmod n)
   \end{eqnarray*}
   and, in order,
   \noindent
   update \tcode{begin[$k+p$]} by xoring it with $r_3$,
   update \tcode{begin[$k+q$]} by xoring it with $r_4$,
   and
   set \tcode{begin[$k$]} to $r_4$.
\end{itemize}

\pnum
\throws
What and when \tcode{RandomAccessIterator} operations of \tcode{begin}
and \tcode{end} throw.
\end{itemdescr}

\indexlibrarymember{size}{seed_seq}%
\begin{itemdecl}
size_t size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The number of 32-bit units
 that would be returned
 by a call to \tcode{param()}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{param}{seed_seq}%
\begin{itemdecl}
template<class OutputIterator>
  void param(OutputIterator dest) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  Values of type \tcode{result_type} are writable\iref{iterator.requirements.general} to \tcode{dest}.

\pnum
\expects
  \tcode{OutputIterator} meets the
  \oldconcept{OutputIterator} requirements\iref{output.iterators}.

\pnum
\effects
Copies the sequence of prepared 32-bit units
 to the given destination,
 as if by executing the following statement:
\begin{codeblock}
copy(v.begin(), v.end(), dest);
\end{codeblock}

\pnum
\throws
What and when \tcode{OutputIterator} operations of \tcode{dest} throw.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% generate_canonical function template:

\rSec3[rand.util.canonical]{Function template \tcode{generate_canonical}}%

\indexlibraryglobal{generate_canonical}%
\begin{itemdecl}
template<class RealType, size_t bits, class URBG>
  RealType generate_canonical(URBG& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 Invokes \tcode{g()} $k$ times
 to obtain values $g_0, \dotsc, g_{k-1}$, respectively.
 Calculates a quantity
 \[
   S = \sum_{i=0}^{k-1} (g_i - \tcode{g.min()})
                        \cdot R^i
 \]
 using arithmetic of type
 \tcode{RealType}.

\pnum
\returns
$S / R^k$.
\begin{note}
$0 \leq S / R^k < 1$.
\end{note}

\pnum
\throws
What and when \tcode{g} throws.

\pnum
\complexity
Exactly
 $k = \max(1, \left\lceil b / \log_2 R \right\rceil)$
 invocations
 of \tcode{g},
 where $b$
\begin{footnote}
$b$ is introduced
   to avoid any attempt
   to produce more bits of randomness
   than can be held in \tcode{RealType}.
\end{footnote}
   is the lesser of \tcode{numeric_limits<RealType>::digits}
                and \tcode{bits},
 and
   $R$ is the value of $\tcode{g.max()} - \tcode{g.min()} + 1$.

\pnum
\begin{note}
If the values $g_i$ produced by \tcode{g} are uniformly distributed,
the instantiation's results are distributed as uniformly as possible.
Obtaining a value in this way
can be a useful step
in the process of transforming
a value generated by a uniform random bit generator
into a value
that can be delivered by a random number distribution.
\end{note}
\end{itemdescr}

\indextext{random number generation!utilities|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Distribution class templates subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\rSec2[rand.dist]{Random number distribution class templates}%
\indextext{random number generation!distributions|(}

\rSec3[rand.dist.general]{In general}

\pnum
Each type instantiated
from a class template specified in this subclause~\ref{rand.dist}
meets the requirements
of a random number distribution\iref{rand.req.dist} type.

\pnum
Descriptions are provided in this subclause~\ref{rand.dist}
only for distribution operations
that are not described in \ref{rand.req.dist}
or for operations where there is additional semantic information.
In particular,
declarations for copy constructors,
for copy assignment operators,
for streaming operators,
and for equality and inequality operators
are not shown in the synopses.

\pnum
The algorithms for producing each
of the specified distributions are
\impldef{algorithms for producing the standard random number distributions}.

\pnum
The value of each probability density function $p(z)$
and of each discrete probability function $P(z_i)$
specified in this subclause
is $0$
everywhere outside its stated domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Uniform distributions subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.dist.uni]{Uniform distributions}%
\indextext{uniform distributions|(}%
\indextext{random number distributions!uniform|(}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% uniform_int_distribution distribution:

\rSec4[rand.dist.uni.int]{Class template \tcode{uniform_int_distribution}}%
\indexlibraryglobal{uniform_int_distribution}%

\pnum
A \tcode{uniform_int_distribution} random number distribution
produces random integers $i$,
$a \leq i \leq b$,
distributed according to
the constant discrete probability function%
\[  P(i\,|\,a,b) = 1 / (b - a + 1) \text{ .} \]

\indexlibraryglobal{uniform_int_distribution}%
\indexlibrarymember{result_type}{uniform_int_distribution}%
\begin{codeblock}
namespace std {
  template<class IntType = int>
  class uniform_int_distribution {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    uniform_int_distribution() : uniform_int_distribution(0) {}
    explicit uniform_int_distribution(IntType a, IntType b = numeric_limits<IntType>::max());
    explicit uniform_int_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const uniform_int_distribution& x, const uniform_int_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    result_type a() const;
    result_type b() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const uniform_int_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, uniform_int_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{uniform_int_distribution}%
\begin{itemdecl}
explicit uniform_int_distribution(IntType a, IntType b = numeric_limits<IntType>::max());
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$\tcode{a} \leq \tcode{b}$.

\pnum
\remarks
 \tcode{a} and \tcode{b}
 correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{a}{uniform_int_distribution}%
\begin{itemdecl}
result_type a() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{a} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{b}{uniform_int_distribution}%
\begin{itemdecl}
result_type b() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{b} parameter
 with which the object was constructed.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% uniform_real distribution:

\rSec4[rand.dist.uni.real]{Class template \tcode{uniform_real_distribution}}%
\indexlibraryglobal{uniform_real_distribution}%

\pnum
A \tcode{uniform_real_distribution} random number distribution
produces random numbers $x$,
$a \leq x < b$,
distributed according to
the constant probability density function%
\[ p(x\,|\,a,b) = 1 / (b - a) \text{ .} \]
\begin{note}
This implies that $p(x\,|\,a,b)$ is undefined when \tcode{a == b}.
\end{note}

\indexlibraryglobal{uniform_real_distribution}%
\indexlibrarymember{result_type}{uniform_real_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class uniform_real_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    uniform_real_distribution() : uniform_real_distribution(0.0) {}
    explicit uniform_real_distribution(RealType a, RealType b = 1.0);
    explicit uniform_real_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const uniform_real_distribution& x,
                           const uniform_real_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    result_type a() const;
    result_type b() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const uniform_real_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, uniform_real_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{uniform_real_distribution}%
\begin{itemdecl}
explicit uniform_real_distribution(RealType a, RealType b = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$\tcode{a} \leq \tcode{b}$
and
$\tcode{b} - \tcode{a} \leq \tcode{numeric_limits<RealType>::max()}$.

\pnum
\remarks
 \tcode{a} and \tcode{b}
 correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{a}{uniform_real_distribution}%
\begin{itemdecl}
result_type a() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{a} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{b}{uniform_real_distribution}%
\begin{itemdecl}
result_type b() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{b} parameter
 with which the object was constructed.
\end{itemdescr}%
\indextext{random number distributions!uniform|)}%
\indextext{uniform distributions|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Bernoulli distributions subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.dist.bern]{Bernoulli distributions}%
\indextext{Bernoulli distributions|(}%
\indextext{random number distributions!Bernoulli|(}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% bernoulli_distribution

\rSec4[rand.dist.bern.bernoulli]{Class \tcode{bernoulli_distribution}}%
\indexlibraryglobal{bernoulli_distribution}%

\pnum
A \tcode{bernoulli_distribution} random number distribution
produces \tcode{bool} values $b$
distributed according to
the discrete probability function
\[  P(b\,|\,p) = \left\{ \begin{array}{ll}
                          p     & \text{ if $b = \tcode{true}$, or} \\
                          1 - p & \text{ if $b = \tcode{false}$.}
                          \end{array}\right.
\]

\indexlibraryglobal{bernoulli_distribution}%
\indexlibrarymember{result_type}{bernoulli_distribution}%
\begin{codeblock}
namespace std {
  class bernoulli_distribution {
  public:
    // types
    using result_type = bool;
    using param_type  = @\unspec@;

    // constructors and reset functions
    bernoulli_distribution() : bernoulli_distribution(0.5) {}
    explicit bernoulli_distribution(double p);
    explicit bernoulli_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const bernoulli_distribution& x, const bernoulli_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    double p() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const bernoulli_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, bernoulli_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{bernoulli_distribution}%
\begin{itemdecl}
explicit bernoulli_distribution(double p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 \leq \tcode{p} \leq 1$.

\pnum
\remarks
 \tcode{p}
 corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{p}{bernoulli_distribution}%
\begin{itemdecl}
double p() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{p} parameter
 with which the object was constructed.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% binomial_distribution

\rSec4[rand.dist.bern.bin]{Class template \tcode{binomial_distribution}}%
\indexlibraryglobal{binomial_distribution}%

\pnum
A \tcode{binomial_distribution} random number distribution
produces integer values $i \geq 0$
distributed according to
the discrete probability function%
\[ P(i\,|\,t,p) = \binom{t}{i} \cdot p^i \cdot (1-p)^{t-i} \text{ .} \]

\indexlibraryglobal{binomial_distribution}%
\indexlibrarymember{result_type}{binomial_distribution}%
\begin{codeblock}
namespace std {
  template<class IntType = int>
  class binomial_distribution {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    binomial_distribution() : binomial_distribution(1) {}
    explicit binomial_distribution(IntType t, double p = 0.5);
    explicit binomial_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const binomial_distribution& x, const binomial_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    IntType t() const;
    double p() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const binomial_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, binomial_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{binomial_distribution}%
\begin{itemdecl}
explicit binomial_distribution(IntType t, double p = 0.5);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 \leq \tcode{p} \leq 1$ and $0 \leq \tcode{t} $.

\pnum
\remarks
 \tcode{t} and \tcode{p}
 correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{t}{binomial_distribution}%
\begin{itemdecl}
IntType t() const;
\end{itemdecl}%
\begin{itemdescr}
\pnum
\returns
The value of the \tcode{t} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{p}{binomial_distribution}%
\begin{itemdecl}
double p() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{p} parameter
 with which the object was constructed.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% geometric_distribution

\rSec4[rand.dist.bern.geo]{Class template \tcode{geometric_distribution}}
\indexlibraryglobal{geometric_distribution}%

\pnum
A \tcode{geometric_distribution} random number distribution
produces integer values $i \geq 0$
distributed according to
the discrete probability function
\[ P(i\,|\,p) = p \cdot (1-p)^{i} \text{ .} \]

\indexlibraryglobal{geometric_distribution}%
\indexlibrarymember{result_type}{geometric_distribution}%
\begin{codeblock}
namespace std {
  template<class IntType = int>
  class geometric_distribution {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    geometric_distribution() : geometric_distribution(0.5) {}
    explicit geometric_distribution(double p);
    explicit geometric_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const geometric_distribution& x, const geometric_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    double p() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const geometric_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, geometric_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{geometric_distribution}%
\begin{itemdecl}
explicit geometric_distribution(double p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{p} < 1$.

\pnum
\remarks
 \tcode{p}
 corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{p}{geometric_distribution}%
\begin{itemdecl}
double p() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{p} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template negative_binomial_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.bern.negbin]{Class template \tcode{negative_binomial_distribution}}
\indexlibraryglobal{negative_binomial_distribution}%

\pnum
A \tcode{negative_binomial_distribution} random number distribution
produces random integers $i \geq 0$
distributed according to
the discrete probability function
\[ P(i\,|\,k,p) = \binom{k+i-1}{i} \cdot p^k \cdot (1-p)^i \text{ .} \]
\begin{note}
This implies that $P(i\,|\,k,p)$ is undefined when \tcode{p == 1}.
\end{note}

\indexlibraryglobal{negative_binomial_distribution}%
\indexlibrarymember{result_type}{negative_binomial_distribution}%
\begin{codeblock}
namespace std {
  template<class IntType = int>
  class negative_binomial_distribution {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    negative_binomial_distribution() : negative_binomial_distribution(1) {}
    explicit negative_binomial_distribution(IntType k, double p = 0.5);
    explicit negative_binomial_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const negative_binomial_distribution& x,
                           const negative_binomial_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    IntType k() const;
    double p() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const negative_binomial_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, negative_binomial_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{negative_binomial_distribution}%
\begin{itemdecl}
explicit negative_binomial_distribution(IntType k, double p = 0.5);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{p} \leq 1$
and $0 < \tcode{k} $.

\pnum
\remarks
 \tcode{k} and \tcode{p}
 correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{k}{negative_binomial_distribution}%
\begin{itemdecl}
IntType k() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{k} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{p}{negative_binomial_distribution}%
\begin{itemdecl}
double p() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{p} parameter
 with which the object was constructed.
\end{itemdescr}%
\indextext{random number distributions!Bernoulli|)}%
\indextext{Bernoulli distributions|)}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Poisson distributions subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.dist.pois]{Poisson distributions}%
\indextext{Poisson distributions|(}%
\indextext{random number distributions!Poisson|(}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% poisson_distribution

\rSec4[rand.dist.pois.poisson]{Class template \tcode{poisson_distribution}}%
\indexlibraryglobal{poisson_distribution}%

\pnum
A \tcode{poisson_distribution} random number distribution
produces integer values $i \geq 0$
distributed according to
the discrete probability function
\[ P(i\,|\,\mu) = \frac{e^{-\mu} \mu^{i}}{i\,!} \text{ .} \]
The distribution parameter $\mu$
is also known as this distribution's \term{mean}%
.

\indexlibraryglobal{poisson_distribution}%
\indexlibrarymember{result_type}{poisson_distribution}%
\begin{codeblock}
template<class IntType = int>
  class poisson_distribution
  {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    poisson_distribution() : poisson_distribution(1.0) {}
    explicit poisson_distribution(double mean);
    explicit poisson_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const poisson_distribution& x, const poisson_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    double mean() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const poisson_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, poisson_distribution& x);
  };
\end{codeblock}

\indexlibraryctor{poisson_distribution}%
\begin{itemdecl}
explicit poisson_distribution(double mean);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{mean}$.

\pnum
\remarks
\tcode{mean} corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{mean}{poisson_distribution}%
\begin{itemdecl}
double mean() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{mean} parameter
 with which the object was constructed.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% exponential_distribution

\rSec4[rand.dist.pois.exp]{Class template \tcode{exponential_distribution}}%
\indexlibraryglobal{exponential_distribution}%

\pnum
An \tcode{exponential_distribution} random number distribution
produces random numbers $x > 0$
distributed according to
the probability density function%
\[ p(x\,|\,\lambda) = \lambda e^{-\lambda x} \text{ .} \]

\indexlibraryglobal{exponential_distribution}%
\indexlibrarymember{result_type}{exponential_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class exponential_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    exponential_distribution() : exponential_distribution(1.0) {}
    explicit exponential_distribution(RealType lambda);
    explicit exponential_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const exponential_distribution& x, const exponential_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType lambda() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const exponential_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, exponential_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{exponential_distribution}%
\begin{itemdecl}
explicit exponential_distribution(RealType lambda);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{lambda}$.

\pnum
\remarks
\tcode{lambda} corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{lambda}{exponential_distribution}%
\begin{itemdecl}
RealType lambda() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{lambda} parameter
 with which the object was constructed.
\end{itemdescr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% gamma_distribution

\rSec4[rand.dist.pois.gamma]{Class template \tcode{gamma_distribution}}%
\indexlibraryglobal{gamma_distribution}%

\pnum
A \tcode{gamma_distribution} random number distribution
produces random numbers $x > 0$
distributed according to
the probability density function%
\[ p(x\,|\,\alpha,\beta) =
     \frac{e^{-x/\beta}}{\beta^{\alpha} \cdot \Gamma(\alpha)} \, \cdot \, x^{\, \alpha-1}
     \text{ .} \]

\indexlibraryglobal{gamma_distribution}%
\indexlibrarymember{result_type}{gamma_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class gamma_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    gamma_distribution() : gamma_distribution(1.0) {}
    explicit gamma_distribution(RealType alpha, RealType beta = 1.0);
    explicit gamma_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const gamma_distribution& x, const gamma_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType alpha() const;
    RealType beta() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const gamma_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, gamma_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{gamma_distribution}%
\begin{itemdecl}
explicit gamma_distribution(RealType alpha, RealType beta = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{alpha}$ and $0 < \tcode{beta}$.

\pnum
\remarks
\tcode{alpha} and \tcode{beta}
correspond to the parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{alpha}{gamma_distribution}%
\begin{itemdecl}
RealType alpha() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{alpha} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{beta}{gamma_distribution}%
\begin{itemdecl}
RealType beta() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{beta} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template weibull_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.pois.weibull]{Class template \tcode{weibull_distribution}}%
\indexlibraryglobal{weibull_distribution}%

\pnum
A \tcode{weibull_distribution} random number distribution
produces random numbers $x \geq 0$
distributed according to
the probability density function%
\[ p(x\,|\,a,b) = \frac{a}{b}
     \cdot \left(\frac{x}{b}\right)^{a-1}
     \cdot \, \exp\left( -\left(\frac{x}{b}\right)^a\right)
     \text{ .} \]

\indexlibraryglobal{weibull_distribution}%
\indexlibrarymember{result_type}{weibull_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class weibull_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    weibull_distribution() : weibull_distribution(1.0) {}
    explicit weibull_distribution(RealType a, RealType b = 1.0);
    explicit weibull_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const weibull_distribution& x, const weibull_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType a() const;
    RealType b() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const weibull_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, weibull_distribution& x);
  };
}
\end{codeblock}

\indexlibraryctor{weibull_distribution}%
\begin{itemdecl}
explicit weibull_distribution(RealType a, RealType b = 1.0);
\end{itemdecl}%

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{a}$ and $0 < \tcode{b}$.

\pnum
\remarks
\tcode{a} and \tcode{b}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{a}{weibull_distribution}%
\begin{itemdecl}
RealType a() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{a} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{b}{weibull_distribution}%
\begin{itemdecl}
RealType b() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{b} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template extreme_value_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.pois.extreme]{Class template \tcode{extreme_value_distribution}}
\indexlibraryglobal{extreme_value_distribution}%

\pnum
An \tcode{extreme_value_distribution} random number distribution
produces random numbers $x$
distributed according to
the probability density function
\begin{footnote}
The distribution corresponding to
 this probability density function
 is also known
 (with a possible change of variable)
 as the Gumbel Type I,
 the log-Weibull,
 or the Fisher-Tippett Type I
 distribution.
\end{footnote}
\[ p(x\,|\,a,b) = \frac{1}{b}
     \cdot \exp\left(\frac{a-x}{b} - \exp\left(\frac{a-x}{b}\right)\right)
     \text{ .} \]

\indexlibraryglobal{extreme_value_distribution}%
\indexlibrarymember{result_type}{extreme_value_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class extreme_value_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    extreme_value_distribution() : extreme_value_distribution(0.0) {}
    explicit extreme_value_distribution(RealType a, RealType b = 1.0);
    explicit extreme_value_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const extreme_value_distribution& x,
                           const extreme_value_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType a() const;
    RealType b() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const extreme_value_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, extreme_value_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{extreme_value_distribution}%
\begin{itemdecl}
explicit extreme_value_distribution(RealType a, RealType b = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{b}$.

\pnum
\remarks
\tcode{a} and \tcode{b}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{a}{extreme_value_distribution}%
\begin{itemdecl}
RealType a() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{a} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{b}{extreme_value_distribution}%
\begin{itemdecl}
RealType b() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{b} parameter
 with which the object was constructed.
\end{itemdescr}%
\indextext{random number distributions!Poisson|)}%
\indextext{Poisson distributions|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Normal distributions subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.dist.norm]{Normal distributions}%
\indextext{normal distributions|(}%
\indextext{random number distributions!normal|(}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% normal_distribution

\rSec4[rand.dist.norm.normal]{Class template \tcode{normal_distribution}}%
\indexlibraryglobal{normal_distribution}%

\pnum
A \tcode{normal_distribution} random number distribution
produces random numbers $x$
distributed according to
the probability density function%
\[%
 p(x\,|\,\mu,\sigma)
      = \frac{1}{\sigma \sqrt{2\pi}}
        \cdot
        % e^{-(x-\mu)^2 / (2\sigma^2)}
        \exp{\left(- \, \frac{(x - \mu)^2}
                             {2 \sigma^2}
             \right)
            }
 \text{ .}
\]
The distribution parameters $\mu$ and $\sigma$
are also known as this distribution's \term{mean}
and \term{standard deviation}.

\indexlibraryglobal{normal_distribution}%
\indexlibrarymember{result_type}{normal_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class normal_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructors and reset functions
    normal_distribution() : normal_distribution(0.0) {}
    explicit normal_distribution(RealType mean, RealType stddev = 1.0);
    explicit normal_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const normal_distribution& x, const normal_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType mean() const;
    RealType stddev() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const normal_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, normal_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{normal_distribution}%
\begin{itemdecl}
explicit normal_distribution(RealType mean, RealType stddev = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{stddev}$.

\pnum
\remarks
\tcode{mean} and \tcode{stddev}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{mean}{normal_distribution}%
\begin{itemdecl}
RealType mean() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{mean} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{stddev}{normal_distribution}%
\begin{itemdecl}
RealType stddev() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{stddev} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template lognormal_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.norm.lognormal]{Class template \tcode{lognormal_distribution}}%
\indexlibraryglobal{lognormal_distribution}%

\pnum
A \tcode{lognormal_distribution} random number distribution
produces random numbers $x > 0$
distributed according to
the probability density function%
\[ p(x\,|\,m,s) = \frac{1}{s x \sqrt{2 \pi}}
     \cdot \exp{\left(-\frac{(\ln{x} - m)^2}{2 s^2}\right)}
     \text{ .} \]

\indexlibraryglobal{lognormal_distribution}%
\indexlibrarymember{result_type}{lognormal_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class lognormal_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    lognormal_distribution() : lognormal_distribution(0.0) {}
    explicit lognormal_distribution(RealType m, RealType s = 1.0);
    explicit lognormal_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const lognormal_distribution& x, const lognormal_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType m() const;
    RealType s() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const lognormal_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, lognormal_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{lognormal_distribution}%
\begin{itemdecl}
explicit lognormal_distribution(RealType m, RealType s = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{s}$.

\pnum
\remarks
\tcode{m} and \tcode{s}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{m}{lognormal_distribution}%
\begin{itemdecl}
RealType m() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{m} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{s}{lognormal_distribution}%
\begin{itemdecl}
RealType s() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{s} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template chi_squared_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.norm.chisq]{Class template \tcode{chi_squared_distribution}}%
\indexlibraryglobal{chi_squared_distribution}%

\pnum
A \tcode{chi_squared_distribution} random number distribution
produces random numbers $x > 0$
distributed according to
the probability density function%
\[ p(x\,|\,n) = \frac{x^{(n/2)-1} \cdot e^{-x/2}}{\Gamma(n/2) \cdot 2^{n/2}} \text{ .} \]

\indexlibraryglobal{chi_squared_distribution}%
\indexlibrarymember{result_type}{chi_squared_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class chi_squared_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    chi_squared_distribution() : chi_squared_distribution(1.0) {}
    explicit chi_squared_distribution(RealType n);
    explicit chi_squared_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const chi_squared_distribution& x, const chi_squared_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType n() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const chi_squared_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, chi_squared_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{chi_squared_distribution}%
\begin{itemdecl}
explicit chi_squared_distribution(RealType n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{n}$.

\pnum
\remarks
\tcode{n} corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{n}{chi_squared_distribution}%
\begin{itemdecl}
RealType n() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{n} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template cauchy_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.norm.cauchy]{Class template \tcode{cauchy_distribution}}%
\indexlibraryglobal{cauchy_distribution}%

\pnum
A \tcode{cauchy_distribution} random number distribution
produces random numbers $x$
distributed according to
the probability density function%
\[  p(x\,|\,a,b) = \left(\pi b \left(1 + \left(\frac{x-a}{b} \right)^2 \, \right)\right)^{-1} \text{ .} \]

\indexlibraryglobal{cauchy_distribution}%
\indexlibrarymember{result_type}{cauchy_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class cauchy_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    cauchy_distribution() : cauchy_distribution(0.0) {}
    explicit cauchy_distribution(RealType a, RealType b = 1.0);
    explicit cauchy_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const cauchy_distribution& x, const cauchy_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType a() const;
    RealType b() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const cauchy_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, cauchy_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{cauchy_distribution}%
\begin{itemdecl}
explicit cauchy_distribution(RealType a, RealType b = 1.0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{b}$.

\pnum
\remarks
\tcode{a} and \tcode{b}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{a}{cauchy_distribution}%
\begin{itemdecl}
RealType a() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{a} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{b}{cauchy_distribution}%
\begin{itemdecl}
RealType b() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{b} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template fisher_f_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.norm.f]{Class template \tcode{fisher_f_distribution}}%
\indexlibraryglobal{fisher_f_distribution}%

\pnum
A \tcode{fisher_f_distribution} random number distribution
produces random numbers $x \ge 0$
distributed according to
the probability density function%
\[ p(x\,|\,m,n) = \frac{\Gamma\big((m+n)/2\big)}{\Gamma(m/2) \; \Gamma(n/2)}
     \cdot \left(\frac{m}{n}\right)^{m/2}
     \cdot x^{(m/2)-1}
     \cdot \left(1 + \frac{m x}{n}\right)^{-(m + n)/2}
     \text{ .} \]

\indexlibraryglobal{fisher_f_distribution}%
\indexlibrarymember{result_type}{fisher_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class fisher_f_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    fisher_f_distribution() : fisher_f_distribution(1.0) {}
    explicit fisher_f_distribution(RealType m, RealType n = 1.0);
    explicit fisher_f_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const fisher_f_distribution& x, const fisher_f_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType m() const;
    RealType n() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const fisher_f_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, fisher_f_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{fisher_f_distribution}%
\begin{itemdecl}
explicit fisher_f_distribution(RealType m, RealType n = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{m}$ and $0 < \tcode{n}$.

\pnum
\remarks
\tcode{m} and \tcode{n}
correspond to the respective parameters of the distribution.
\end{itemdescr}

\indexlibrarymember{m}{fisher_f_distribution}%
\begin{itemdecl}
RealType m() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{m} parameter
 with which the object was constructed.
\end{itemdescr}

\indexlibrarymember{n}{fisher_f_distribution}%
\begin{itemdecl}
RealType n() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{n} parameter
 with which the object was constructed.
\end{itemdescr}

% ----------------------------------------------------------------------
% Class template student_t_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.norm.t]{Class template \tcode{student_t_distribution}}%
\indexlibraryglobal{student_t_distribution}%

\pnum
A \tcode{student_t_distribution} random number distribution
produces random numbers $x$
distributed according to
the probability density function%
\[ p(x\,|\,n) = \frac{1}{\sqrt{n \pi}}
     \cdot \frac{\Gamma\big((n+1)/2\big)}{\Gamma(n/2)}
     \cdot \left(1 + \frac{x^2}{n} \right)^{-(n+1)/2}
     \text{ .} \]

\indexlibraryglobal{student_t_distribution}%
\indexlibrarymember{result_type}{student_t_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class student_t_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    student_t_distribution() : student_t_distribution(1.0) {}
    explicit student_t_distribution(RealType n);
    explicit student_t_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const student_t_distribution& x, const student_t_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    RealType n() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const student_t_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, student_t_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{student_t_distribution}%
\begin{itemdecl}
explicit student_t_distribution(RealType n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
$0 < \tcode{n}$.

\pnum
\remarks
\tcode{n} corresponds to the parameter of the distribution.
\end{itemdescr}

\indexlibrarymember{mean}{student_t_distribution}%
\begin{itemdecl}
RealType n() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{n} parameter
 with which the object was constructed.
\end{itemdescr}%
\indextext{random number distributions!normal|)}%
\indextext{normal distributions|)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Sampling distributions subclause
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec3[rand.dist.samp]{Sampling distributions}%
\indextext{sampling distributions|(}%
\indextext{random number distributions!sampling|(}


% ----------------------------------------------------------------------
% Class template discrete_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.samp.discrete]{Class template \tcode{discrete_distribution}}%
\indexlibraryglobal{discrete_distribution}%

\pnum
A \tcode{discrete_distribution} random number distribution
produces random integers $i$, $0 \leq i < n$,
distributed according to
the discrete probability function%
\[  P(i \,|\, p_0, \dotsc, p_{n-1}) = p_i \text{ .} \]

\pnum
Unless specified otherwise,
the distribution parameters are calculated as:
$p_k = {w_k / S}$ for $k = 0, \dotsc, n - 1$,
in which the values $w_k$,
commonly known as the \term{weights}%
, shall be non-negative, non-NaN, and non-infinity.
Moreover, the following relation shall hold:
$0 < S = w_0 + \dotsb + w_{n - 1}$.

\indexlibraryglobal{discrete_distribution}%
\indexlibrarymember{result_type}{discrete_distribution}%
\begin{codeblock}
namespace std {
  template<class IntType = int>
  class discrete_distribution {
  public:
    // types
    using result_type = IntType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    discrete_distribution();
    template<class InputIterator>
      discrete_distribution(InputIterator firstW, InputIterator lastW);
    discrete_distribution(initializer_list<double> wl);
    template<class UnaryOperation>
      discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);
    explicit discrete_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const discrete_distribution& x, const discrete_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    vector<double> probabilities() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const discrete_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, discrete_distribution& x);
  };
}
\end{codeblock}

\indexlibraryctor{discrete_distribution}
\begin{itemdecl}
discrete_distribution();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{discrete_distribution} object
with $n = 1$ and $p_0 = 1$.
\begin{note}
Such an object will always deliver the value $0$.
\end{note}
\end{itemdescr}


\indexlibraryctor{discrete_distribution}%
\begin{itemdecl}
template<class InputIterator>
  discrete_distribution(InputIterator firstW, InputIterator lastW);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_convertible_v<iterator_traits<InputIterator>::value_type,
double>} is \tcode{true}.

\pnum
\expects
  \tcode{InputIterator} meets the
  \oldconcept{InputIterator} requirements\iref{input.iterators}.
 If \tcode{firstW == lastW},
 let $n = 1$ and $w_0 = 1$.
 Otherwise,
 $\bigl[\tcode{firstW}, \tcode{lastW}\bigr)$
 forms a sequence $w$ of length $n > 0$.

\pnum
\effects
Constructs a \tcode{discrete_distribution} object
with probabilities given by the formula above.
\end{itemdescr}


\indexlibraryctor{discrete_distribution}%
\begin{itemdecl}
discrete_distribution(initializer_list<double> wl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
 Same as \tcode{discrete_distribution(wl.begin(), wl.end())}.
\end{itemdescr}

\indexlibraryctor{discrete_distribution}
\begin{itemdecl}
template<class UnaryOperation>
  discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\expects
 If $\tcode{nw} = 0$, let $n = 1$, otherwise let $n = \tcode{nw}$.
 The relation
   $0 < \delta = (\tcode{xmax} - \tcode{xmin}) / n$
 holds.

\pnum
\effects
Constructs a \tcode{discrete_distribution} object
 with probabilities given by the formula above,
 using the following values:
 If $\tcode{nw} = 0$,
 let $w_0 = 1$.
 Otherwise,
 let $w_k = \tcode{fw}(\tcode{xmin} + k \cdot \delta + \delta / 2)$
 for $k = 0, \dotsc, n - 1$.

\pnum
\complexity
The number of invocations of \tcode{fw} does not exceed $n$.
\end{itemdescr}

\indexlibrarymember{probabilities}{discrete_distribution}%
\begin{itemdecl}
vector<double> probabilities() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{vector<double>}
 whose \tcode{size} member returns $n$
 and whose \tcode{operator[]} member returns $p_k$
 when invoked with argument $k$ for $k = 0, \dotsc, n - 1$.
\end{itemdescr}


% ----------------------------------------------------------------------
% Class template piecewise_constant_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.samp.pconst]{Class template \tcode{piecewise_constant_distribution}}%
\indexlibraryglobal{piecewise_constant_distribution}%

\pnum
A \tcode{piecewise_constant_distribution} random number distribution
produces random numbers $x$,
$b_0 \leq x < b_n$,
uniformly distributed over each subinterval
$[ b_i, b_{i+1} )$
according to the probability density function
\[ p(x \,|\, b_0, \dotsc, b_n, \; \rho_0, \dotsc, \rho_{n-1}) = \rho_i
   \text{ , for $b_i \le x < b_{i+1}$.} \]

\pnum
The $n + 1$ distribution parameters $b_i$,
also known as this distribution's \term{interval boundaries}%
, shall satisfy the relation
$b_i < b_{i + 1}$ for $i = 0, \dotsc, n - 1$.
Unless specified otherwise,
the remaining $n$ distribution parameters are calculated as:
\[ \rho_k = \frac{w_k}{S \cdot (b_{k+1}-b_k)} \text{ for } k = 0, \dotsc, n - 1 \text{ ,} \]
in which the values $w_k$,
commonly known as the \term{weights}%
, shall be non-negative, non-NaN, and non-infinity.
Moreover, the following relation shall hold:
 $0 < S = w_0 + \dotsb + w_{n-1}$.

\indexlibraryglobal{piecewise_constant_distribution}%
\indexlibrarymember{result_type}{piecewise_constant_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class piecewise_constant_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    piecewise_constant_distribution();
    template<class InputIteratorB, class InputIteratorW>
      piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                      InputIteratorW firstW);
    template<class UnaryOperation>
      piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);
    template<class UnaryOperation>
      piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax,
                                      UnaryOperation fw);
    explicit piecewise_constant_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const piecewise_constant_distribution& x,
                           const piecewise_constant_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    vector<result_type> intervals() const;
    vector<result_type> densities() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const piecewise_constant_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, piecewise_constant_distribution& x);
  };
}
\end{codeblock}


\indexlibraryctor{piecewise_constant_distribution}%
\begin{itemdecl}
piecewise_constant_distribution();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{piecewise_constant_distribution} object
 with $n = 1$,
 $\rho_0 = 1$,
 $b_0 = 0$,
 and $b_1 = 1$.
\end{itemdescr}


\indexlibraryctor{piecewise_constant_distribution}%
\begin{itemdecl}
template<class InputIteratorB, class InputIteratorW>
 piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                 InputIteratorW firstW);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
Both of
\begin{itemize}
\item{\tcode{is_convertible_v<iterator_traits<InputIteratorB>::value_type, double>}}
\item{\tcode{is_convertible_v<iterator_traits<InputIteratorW>::value_type, double>}}
\end{itemize}
are \tcode{true}.

\pnum
\expects
  \tcode{InputIteratorB} and \tcode{InputIteratorW}
   each meet the
  \oldconcept{InputIterator} requirements\iref{input.iterators}.
 If \tcode{firstB == lastB}
 or \tcode{++firstB == lastB},
 let $n = 1$,
     $w_0 = 1$,
     $b_0 = 0$,
 and $b_1 = 1$.
 Otherwise,
 $\bigl[\tcode{firstB}, \tcode{lastB}\bigr)$
 forms a sequence $b$ of length $n+1$,
 the length of the sequence $w$ starting from \tcode{firstW}
 is at least $n$,
 and any $w_k$ for  $k \geq n$ are ignored by the distribution.

\pnum
\effects
Constructs a \tcode{piecewise_constant_distribution} object
 with parameters as specified above.
\end{itemdescr}


\indexlibraryctor{piecewise_constant_distribution}%
\begin{itemdecl}
template<class UnaryOperation>
 piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\effects
Constructs a \tcode{piecewise_constant_distribution} object
 with parameters taken or calculated
 from the following values:
 If $\tcode{bl.size()} < 2$,
 let $n = 1$,
     $w_0 = 1$,
     $b_0 = 0$,
 and $b_1 = 1$.
 Otherwise,
 let $\bigl[\tcode{bl.begin()}, \tcode{bl.end()}\bigr)$
 form a sequence $b_0, \dotsc, b_n$,
 and
 let $w_k = \tcode{fw}\bigl(\bigl(b_{k+1} + b_k\bigr) / 2\bigr)$
 for $k = 0, \dotsc, n - 1$.

\pnum
\complexity
The number of invocations of \tcode{fw} does not exceed $n$.
\end{itemdescr}


\indexlibraryctor{piecewise_constant_distribution}%
\begin{itemdecl}
template<class UnaryOperation>
 piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\expects
 If $\tcode{nw} = 0$, let $n = 1$, otherwise let $n = \tcode{nw}$.
 The relation $0 < \delta = (\tcode{xmax} - \tcode{xmin}) / n$
 holds.

\pnum
\effects
Constructs a \tcode{piecewise_constant_distribution} object
 with parameters taken or calculated
 from the following values:
 Let $b_k = \tcode{xmin} + k \cdot \delta $ for $ k = 0, \dotsc, n$,
 and $w_k = \tcode{fw}(b_k + \delta / 2) $ for $ k = 0, \dotsc, n - 1$.

\pnum
\complexity
The number of invocations of \tcode{fw} does not exceed $n$.
\end{itemdescr}

\indexlibrarymember{intervals}{piecewise_constant_distribution}%
\begin{itemdecl}
vector<result_type> intervals() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{vector<result_type>}
 whose \tcode{size} member returns $n + 1$
 and whose $ \tcode{operator[]} $ member returns $b_k$
 when invoked with argument $k$ for $k = 0, \dotsc, n $.
\end{itemdescr}

\indexlibrarymember{densities}{piecewise_constant_distribution}%
\begin{itemdecl}
vector<result_type> densities() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{vector<result_type>}
 whose \tcode{size} member returns $n$
 and whose $ \tcode{operator[]} $ member returns $\rho_k$
 when invoked with argument $k$ for $k = 0, \dotsc, n - 1$.
\end{itemdescr}


% ----------------------------------------------------------------------
% Class template piecewise_linear_distribution
% ----------------------------------------------------------------------

\rSec4[rand.dist.samp.plinear]{Class template \tcode{piecewise_linear_distribution}}%
\indexlibraryglobal{piecewise_linear_distribution}%

\pnum
A \tcode{piecewise_linear_distribution} random number distribution
produces random numbers $x$,
$b_0 \leq x < b_n$,
distributed over each subinterval
$[b_i, b_{i+1})$
according to the probability density function
\[ p(x \,|\, b_0, \dotsc, b_n, \; \rho_0, \dotsc, \rho_n)
     = \rho_{i}   \cdot {\frac{b_{i+1} - x}{b_{i+1} - b_i}}
     + \rho_{i+1} \cdot {\frac{x - b_i}{b_{i+1} - b_i}}
     \text{ , for $b_i \le x < b_{i+1}$.} \]

\pnum
The $n + 1$ distribution parameters $b_i$,
also known as this distribution's \term{interval boundaries}%
, shall satisfy the relation $b_i < b_{i+1}$ for $i = 0, \dotsc, n - 1$.
Unless specified otherwise,
the remaining $n + 1$ distribution parameters are calculated as
$\rho_k = {w_k / S}$ for $k = 0, \dotsc, n$, in which the values $w_k$,
commonly known as the \term{weights at boundaries}%
, shall be non-negative, non-NaN, and non-infinity.
Moreover, the following relation shall hold:
\[ 0 < S = \frac{1}{2} \cdot \sum_{k=0}^{n-1} (w_k + w_{k+1}) \cdot (b_{k+1} - b_k) \text{ .} \]

\indexlibraryglobal{piecewise_linear_distribution}%
\indexlibrarymember{result_type}{piecewise_linear_distribution}%
\begin{codeblock}
namespace std {
  template<class RealType = double>
  class piecewise_linear_distribution {
  public:
    // types
    using result_type = RealType;
    using param_type  = @\unspec@;

    // constructor and reset functions
    piecewise_linear_distribution();
    template<class InputIteratorB, class InputIteratorW>
      piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                    InputIteratorW firstW);
    template<class UnaryOperation>
      piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);
    template<class UnaryOperation>
      piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
    explicit piecewise_linear_distribution(const param_type& parm);
    void reset();

    // equality operators
    friend bool operator==(const piecewise_linear_distribution& x,
                           const piecewise_linear_distribution& y);

    // generating functions
    template<class URBG>
      result_type operator()(URBG& g);
    template<class URBG>
      result_type operator()(URBG& g, const param_type& parm);

    // property functions
    vector<result_type> intervals() const;
    vector<result_type> densities() const;
    param_type param() const;
    void param(const param_type& parm);
    result_type min() const;
    result_type max() const;

    // inserters and extractors
    template<class charT, class traits>
      friend basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const piecewise_linear_distribution& x);
    template<class charT, class traits>
      friend basic_istream<charT, traits>&
        operator>>(basic_istream<charT, traits>& is, piecewise_linear_distribution& x);
  };
}
\end{codeblock}

\indexlibraryctor{piecewise_linear_distribution}
\begin{itemdecl}
piecewise_linear_distribution();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{piecewise_linear_distribution} object
 with $n = 1$,
 $\rho_0 = \rho_1 = 1$,
 $b_0 = 0$,
 and $b_1 = 1$.
\end{itemdescr}

\indexlibraryctor{piecewise_linear_distribution}
\begin{itemdecl}
template<class InputIteratorB, class InputIteratorW>
 piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                               InputIteratorW firstW);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\expects
  \tcode{InputIteratorB} and \tcode{InputIteratorW}
   each meet the
  \oldconcept{InputIterator} requirements\iref{input.iterators}.
 If \tcode{firstB == lastB}
 or \tcode{++firstB == lastB},
 let $n = 1$,
     $\rho_0 = \rho_1 = 1$,
     $b_0 = 0$,
 and $b_1 = 1$.
 Otherwise,
 $\bigl[\tcode{firstB}, \tcode{lastB}\bigr)$
 forms a sequence $b$ of length $n+1$,
 the length of the sequence $w$ starting from \tcode{firstW}
 is at least $n+1$,
 and any $w_k$ for $k \geq n + 1$ are ignored by the distribution.

\pnum
\effects
Constructs a \tcode{piecewise_linear_distribution} object
 with parameters as specified above.
\end{itemdescr}


\indexlibraryctor{piecewise_linear_distribution}%
\begin{itemdecl}
template<class UnaryOperation>
 piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\effects
Constructs a \tcode{piecewise_linear_distribution} object
 with parameters taken or calculated
 from the following values:
 If $\tcode{bl.size()} < 2$,
 let $n = 1$,
     $\rho_0 = \rho_1 = 1$,
     $b_0 = 0$,
 and $b_1 = 1$.
 Otherwise,
 let $\bigl[\tcode{bl.begin(),} \tcode{bl.end()}\bigr)$
 form a sequence $b_0, \dotsc, b_n$,
 and
 let $w_k = \tcode{fw}(b_k)$
 for $k = 0, \dotsc, n$.

\pnum
\complexity
The number of invocations of \tcode{fw} does not exceed $n+1$.
\end{itemdescr}


\indexlibraryctor{piecewise_linear_distribution}%
\begin{itemdecl}
template<class UnaryOperation>
 piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_invocable_r_v<double, UnaryOperation\&, double>} is \tcode{true}.

\pnum
\expects
 If $\tcode{nw} = 0$, let $n = 1$, otherwise let $n = \tcode{nw}$.
 The relation $0 < \delta = (\tcode{xmax} - \tcode{xmin}) / n$
 holds.

\pnum
\effects
Constructs a \tcode{piecewise_linear_distribution} object
 with parameters taken or calculated
 from the following values:
 Let $b_k = \tcode{xmin} + k \cdot \delta$ for $k = 0, \dotsc, n$,
 and $w_k = \tcode{fw}(b_k)$ for $k = 0, \dotsc, n$.

\pnum
\complexity
The number of invocations of \tcode{fw} does not exceed $n+1$.
\end{itemdescr}

\indexlibrarymember{intervals}{piecewise_linear_distribution}%
\begin{itemdecl}
vector<result_type> intervals() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{vector<result_type>}
 whose \tcode{size} member returns $n + 1$
 and whose $ \tcode{operator[]} $ member returns $b_k$
 when invoked with argument $k$ for $k = 0, \dotsc, n$.
\end{itemdescr}

\indexlibrarymember{densities}{piecewise_linear_distribution}%
\begin{itemdecl}
vector<result_type> densities() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{vector<result_type>}
 whose \tcode{size} member returns $n$
 and whose $ \tcode{operator[]} $ member returns $\rho_k$
 when invoked with argument $k$ for $k = 0, \dotsc, n$.
\end{itemdescr}%
%
\indextext{random number distributions!sampling|)}%
\indextext{sampling distributions|)}%
\indextext{random number generation!distributions|)}%

\rSec2[c.math.rand]{Low-quality random number generation}

\pnum
\begin{note}
The header \libheaderref{cstdlib}
declares the functions described in this subclause.
\end{note}

\indexlibraryglobal{rand}%
\indexlibraryglobal{srand}%
\begin{itemdecl}
int rand();
void srand(unsigned int seed);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\tcode{rand} and \tcode{srand}
functions have the semantics specified in the C standard library.

\pnum
\remarks
The implementation
may specify that particular library functions may call
\tcode{rand}.
It is \impldef{whether \tcode{rand} may introduce a data race}
whether the \tcode{rand} function
may introduce data races\iref{res.on.data.races}.
\begin{note}
\indexlibrary{\idxcode{rand}!discouraged}%
The other random
number generation facilities in this document\iref{rand} are often preferable
to \tcode{rand}, because \tcode{rand}'s underlying algorithm is unspecified.
Use of \tcode{rand} therefore continues to be non-portable, with unpredictable
and oft-questionable quality and performance.
\end{note}
\end{itemdescr}

\xrefc{7.22.2}

\indextext{random number generation|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec1[numarray]{Numeric arrays}

\rSec2[valarray.syn]{Header \tcode{<valarray>} synopsis}
\indexheader{valarray}%
\begin{codeblock}
#include <initializer_list>     // see \ref{initializer.list.syn}

namespace std {
  template<class T> class valarray;         // An array of type \tcode{T}
  class slice;                              // a BLAS-like slice out of an array
  template<class T> class slice_array;
  class gslice;                             // a generalized slice out of an array
  template<class T> class gslice_array;
  template<class T> class mask_array;       // a masked array
  template<class T> class indirect_array;   // an indirected array

  template<class T> void swap(valarray<T>&, valarray<T>&) noexcept;

  template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator* (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator* (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator/ (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator/ (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator% (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator% (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator+ (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator+ (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator- (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator- (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator^ (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator^ (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator& (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator& (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator| (const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator| (const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator<<(const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator<<(const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator>>(const valarray<T>&,
                                           const typename valarray<T>::value_type&);
  template<class T> valarray<T> operator>>(const typename valarray<T>::value_type&,
                                           const valarray<T>&);

  template<class T> valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator&&(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator&&(const typename valarray<T>::value_type&,
                                              const valarray<T>&);

  template<class T> valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator||(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator||(const typename valarray<T>::value_type&,
                                              const valarray<T>&);

  template<class T> valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator==(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator==(const typename valarray<T>::value_type&,
                                              const valarray<T>&);
  template<class T> valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator!=(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator!=(const typename valarray<T>::value_type&,
                                              const valarray<T>&);

  template<class T> valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator< (const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator< (const typename valarray<T>::value_type&,
                                              const valarray<T>&);
  template<class T> valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator> (const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator> (const typename valarray<T>::value_type&,
                                              const valarray<T>&);
  template<class T> valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator<=(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator<=(const typename valarray<T>::value_type&,
                                              const valarray<T>&);
  template<class T> valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator>=(const valarray<T>&,
                                              const typename valarray<T>::value_type&);
  template<class T> valarray<bool> operator>=(const typename valarray<T>::value_type&,
                                              const valarray<T>&);

  template<class T> valarray<T> abs  (const valarray<T>&);
  template<class T> valarray<T> acos (const valarray<T>&);
  template<class T> valarray<T> asin (const valarray<T>&);
  template<class T> valarray<T> atan (const valarray<T>&);

  template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> atan2(const valarray<T>&,
                                      const typename valarray<T>::value_type&);
  template<class T> valarray<T> atan2(const typename valarray<T>::value_type&,
                                      const valarray<T>&);

  template<class T> valarray<T> cos  (const valarray<T>&);
  template<class T> valarray<T> cosh (const valarray<T>&);
  template<class T> valarray<T> exp  (const valarray<T>&);
  template<class T> valarray<T> log  (const valarray<T>&);
  template<class T> valarray<T> log10(const valarray<T>&);

  template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> pow(const valarray<T>&, const typename valarray<T>::value_type&);
  template<class T> valarray<T> pow(const typename valarray<T>::value_type&, const valarray<T>&);

  template<class T> valarray<T> sin  (const valarray<T>&);
  template<class T> valarray<T> sinh (const valarray<T>&);
  template<class T> valarray<T> sqrt (const valarray<T>&);
  template<class T> valarray<T> tan  (const valarray<T>&);
  template<class T> valarray<T> tanh (const valarray<T>&);

  template<class T> @\unspec{1}@ begin(valarray<T>& v);
  template<class T> @\unspec{2}@ begin(const valarray<T>& v);
  template<class T> @\unspec{1}@ end(valarray<T>& v);
  template<class T> @\unspec{2}@ end(const valarray<T>& v);
}
\end{codeblock}

\pnum
The header \libheader{valarray} defines five class templates
(\tcode{valarray},
\tcode{slice_array},
\tcode{gslice_array},
\tcode{mask_array},
and
\tcode{indirect_array}),
two classes (\tcode{slice}
and
\tcode{gslice}),
and a series of related
function templates
for representing
and manipulating arrays of values.

\pnum
The
\tcode{valarray}
array classes
are defined to be free of certain forms of aliasing, thus allowing
operations on these classes to be optimized.

\pnum
Any function returning a
\tcode{valarray<T>}
is permitted to return an object of another type, provided all the
const member functions of
\tcode{valarray<T>}
are also applicable to this type.
This return type shall not add
more than two levels of template nesting over the most deeply nested
argument type.
\begin{footnote}
\ref{implimits} recommends a minimum number
of recursively nested template
instantiations.
This requirement thus indirectly suggests a minimum
allowable complexity for valarray expressions.
\end{footnote}

\pnum
Implementations introducing such replacement types shall provide
additional functions and operators as follows:
\begin{itemize}
\item
for every function taking a
\tcode{const valarray<T>\&} other than \tcode{begin} and
\tcode{end}\iref{valarray.range},
identical functions taking the replacement types shall be added;
\item
for every function taking two
\tcode{const valarray<T>\&}
arguments, identical functions taking every combination of
\tcode{const valarray<T>\&}
and replacement types shall be added.
\end{itemize}

\pnum
In particular, an implementation shall allow a
\tcode{valarray<T>}
to be constructed from such replacement types and shall allow assignments
and compound assignments of such types to
\tcode{valarray<T>},
\tcode{slice_array<T>},
\tcode{gslice_array<T>},
\tcode{mask_array<T>}
and
\tcode{indirect_array<T>}
objects.

\pnum
These library functions are permitted to throw a
\tcode{bad_alloc}\iref{bad.alloc} exception if there are not sufficient resources available
to carry out the operation.
Note that the exception is not mandated.

\rSec2[template.valarray]{Class template \tcode{valarray}}

\rSec3[template.valarray.overview]{Overview}

\indexlibraryglobal{valarray}%
\begin{codeblock}
namespace std {
  template<class T> class valarray {
  public:
    using value_type = T;

    // \ref{valarray.cons}, construct/destroy
    valarray();
    explicit valarray(size_t);
    valarray(const T&, size_t);
    valarray(const T*, size_t);
    valarray(const valarray&);
    valarray(valarray&&) noexcept;
    valarray(const slice_array<T>&);
    valarray(const gslice_array<T>&);
    valarray(const mask_array<T>&);
    valarray(const indirect_array<T>&);
    valarray(initializer_list<T>);
    ~valarray();

    // \ref{valarray.assign}, assignment
    valarray& operator=(const valarray&);
    valarray& operator=(valarray&&) noexcept;
    valarray& operator=(initializer_list<T>);
    valarray& operator=(const T&);
    valarray& operator=(const slice_array<T>&);
    valarray& operator=(const gslice_array<T>&);
    valarray& operator=(const mask_array<T>&);
    valarray& operator=(const indirect_array<T>&);

    // \ref{valarray.access}, element access
    const T&          operator[](size_t) const;
    T&                operator[](size_t);

    // \ref{valarray.sub}, subset operations
    valarray          operator[](slice) const;
    slice_array<T>    operator[](slice);
    valarray          operator[](const gslice&) const;
    gslice_array<T>   operator[](const gslice&);
    valarray          operator[](const valarray<bool>&) const;
    mask_array<T>     operator[](const valarray<bool>&);
    valarray          operator[](const valarray<size_t>&) const;
    indirect_array<T> operator[](const valarray<size_t>&);

    // \ref{valarray.unary}, unary operators
    valarray operator+() const;
    valarray operator-() const;
    valarray operator~() const;
    valarray<bool> operator!() const;

    // \ref{valarray.cassign}, compound assignment
    valarray& operator*= (const T&);
    valarray& operator/= (const T&);
    valarray& operator%= (const T&);
    valarray& operator+= (const T&);
    valarray& operator-= (const T&);
    valarray& operator^= (const T&);
    valarray& operator&= (const T&);
    valarray& operator|= (const T&);
    valarray& operator<<=(const T&);
    valarray& operator>>=(const T&);

    valarray& operator*= (const valarray&);
    valarray& operator/= (const valarray&);
    valarray& operator%= (const valarray&);
    valarray& operator+= (const valarray&);
    valarray& operator-= (const valarray&);
    valarray& operator^= (const valarray&);
    valarray& operator|= (const valarray&);
    valarray& operator&= (const valarray&);
    valarray& operator<<=(const valarray&);
    valarray& operator>>=(const valarray&);

    // \ref{valarray.members}, member functions
    void swap(valarray&) noexcept;

    size_t size() const;

    T sum() const;
    T min() const;
    T max() const;

    valarray shift (int) const;
    valarray cshift(int) const;
    valarray apply(T func(T)) const;
    valarray apply(T func(const T&)) const;
    void resize(size_t sz, T c = T());
  };

  template<class T, size_t cnt> valarray(const T(&)[cnt], size_t) -> valarray<T>;
}
\end{codeblock}

\pnum
The
class template
\tcode{valarray<T>}
is a
one-dimensional smart array, with elements numbered sequentially from zero.
It is a representation of the mathematical concept
of an ordered set of values.
For convenience, an object of type \tcode{valarray<T>} is referred
to as an ``array'' throughout the remainder of~\ref{numarray}.
The illusion of higher dimensionality
may be produced by the familiar idiom of computed indices, together
with the powerful subsetting capabilities provided
by the generalized subscript operators.
\begin{footnote}
The intent is to specify
an array template that has the minimum functionality
necessary to address aliasing ambiguities and the proliferation of
temporary objects.
Thus, the
\tcode{valarray}
template is neither a
matrix class nor a field class.
However, it is a very useful building block for designing such classes.
\end{footnote}

\rSec3[valarray.cons]{Constructors}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{valarray}
that has zero length.
\begin{footnote}
This default constructor is essential,
since arrays of
\tcode{valarray}
can be useful.
After initialization, the length of an empty array can be increased with the
\tcode{resize}
member function.
\end{footnote}
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
explicit valarray(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{valarray} that has length \tcode{n}.
Each element of the array is value-initialized\iref{dcl.init}.
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(const T& v, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{valarray} that has length \tcode{n}.
Each element of the array is initialized with \tcode{v}.
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(const T* p, size_t n);
\end{itemdecl}

\begin{itemdescr}

\pnum
\expects
\range{p}{p + n} is a valid range.

\pnum
\effects
Constructs a \tcode{valarray} that has length \tcode{n}.
The values of the elements of the array are initialized with the
first
\tcode{n}
values pointed to by the first argument.
\begin{footnote}
This constructor is the
preferred method for converting a C array to a
\tcode{valarray}
object.
\end{footnote}
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(const valarray& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{valarray} that has the same length as \tcode{v}.
The elements are initialized with the values of the corresponding
elements of \tcode{v}.
\begin{footnote}
This copy constructor creates
a distinct array rather than an alias.
Implementations in which arrays share storage are permitted, but they
would need to implement a copy-on-reference mechanism to ensure that arrays are
conceptually distinct.
\end{footnote}
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(valarray&& v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{valarray} that has the same length as \tcode{v}.
The elements are initialized with the values of the corresponding
elements of \tcode{v}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(initializer_list<T> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{valarray(il.begin(), il.size())}.
\end{itemdescr}

\indexlibraryctor{valarray}%
\begin{itemdecl}
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These conversion constructors convert one of the four reference templates
to a
\tcode{valarray}.
\end{itemdescr}

\indexlibrarydtor{valarray}%
\begin{itemdecl}
~valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The destructor is applied to every element of
\tcode{*this};
an implementation may return all allocated memory.
\end{itemdescr}

\rSec3[valarray.assign]{Assignment}

\indexlibrarymember{operator=}{valarray}%
\begin{itemdecl}
valarray& operator=(const valarray& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Each element of the
\tcode{*this}
array is assigned the value of the corresponding element of \tcode{v}.
If the length of \tcode{v} is not equal to the length of \tcode{*this},
resizes \tcode{*this} to make the two arrays the same length,
as if by calling \tcode{resize(v.size())}, before performing the assignment.

\pnum
\ensures
\tcode{size() == v.size()}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{valarray}%
\begin{itemdecl}
valarray& operator=(valarray&& v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{*this} obtains the value of \tcode{v}.
The value of \tcode{v} after the assignment is not specified.

\pnum
\returns
\tcode{*this}.

\pnum
\complexity
Linear.
\end{itemdescr}

\indexlibrarymember{operator=}{valarray}%
\begin{itemdecl}
valarray& operator=(initializer_list<T> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *this = valarray(il);}
\end{itemdescr}


\indexlibrarymember{operator=}{valarray}%
\begin{itemdecl}
valarray& operator=(const T& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns \tcode{v} to each element of \tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{valarray}%
\begin{itemdecl}
valarray& operator=(const slice_array<T>&);
valarray& operator=(const gslice_array<T>&);
valarray& operator=(const mask_array<T>&);
valarray& operator=(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
The length of the array to which the argument refers equals \tcode{size()}.
The value of an element in the left-hand side of a \tcode{valarray} assignment
operator does not depend on the value of another element in that left-hand side.

\pnum
These operators allow the results of a generalized subscripting operation
to be assigned directly to a
\tcode{valarray}.
\end{itemdescr}

\rSec3[valarray.access]{Element access}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
const T&  operator[](size_t n) const;
T& operator[](size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n < size()} is \tcode{true}.

\pnum
\returns
A reference to the corresponding element of the array.
\begin{note}
The expression \tcode{(a[i] = q, a[i]) == q}
evaluates to \tcode{true} for any non-constant \tcode{valarray<T> a},
any \tcode{T q}, and for any \tcode{size_t i}
such that the value of \tcode{i} is less than the length of \tcode{a}.
\end{note}

\pnum
\remarks
The expression \tcode{addressof(a[i+j]) == addressof(a[i]) + j}
evaluates to \tcode{true} for all \tcode{size_t i} and \tcode{size_t j}
such that \tcode{i+j < a.size()}.

\pnum
The expression \tcode{addressof(a[i]) != addressof(b[j])}
evaluates to \tcode{true} for any two arrays
\tcode{a} and \tcode{b} and for any
\tcode{size_t i} and \tcode{size_t j}
such that \tcode{i < a.size()}
and \tcode{j < b.size()}.
\begin{note}
This property indicates an absence of aliasing and can be used to
advantage by optimizing compilers. Compilers can take advantage
of inlining, constant propagation, loop fusion,
tracking of pointers obtained from
\tcode{operator new},
and other techniques to generate efficient
\tcode{valarray}s.
\end{note}

\pnum
The reference returned by the subscript operator for an array shall
be valid until the member function
\tcode{resize(size_t, T)}\iref{valarray.members} is called for that array or until the lifetime of
that array ends, whichever happens first.
\end{itemdescr}

\rSec3[valarray.sub]{Subset operations}

\indexlibrary{\idxcode{operator[]}!\idxcode{valarray}}%
\pnum
The member \tcode{operator[]} is overloaded to provide several ways to select
sequences of elements from among those controlled by \tcode{*this}. Each of these
operations returns a subset of the array. The const-qualified versions return this
subset as a new \tcode{valarray} object. The non-const versions return a class
template object which has reference semantics to the original array, working in
conjunction with various overloads of \tcode{operator=} and other assigning
operators to allow selective replacement (slicing) of the controlled sequence.
In each case the selected element(s) shall exist.

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
valarray operator[](slice slicearr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} containing those
elements of the controlled sequence designated by \tcode{slicearr}.
\begin{example}
\begin{codeblock}
const valarray<char> v0("abcdefghijklmnop", 16);
// \tcode{v0[slice(2, 5, 3)]} returns \tcode{valarray<char>("cfilo", 5)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
slice_array<T> operator[](slice slicearr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object that holds references to elements of the controlled
sequence selected by \tcode{slicearr}.
\begin{example}
\begin{codeblock}
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// \tcode{v0 == valarray<char>("abAdeBghCjkDmnEp", 16);}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
valarray operator[](const gslice& gslicearr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} containing those
elements of the controlled sequence designated by \tcode{gslicearr}.
\begin{example}
\begin{codeblock}
const valarray<char> v0("abcdefghijklmnop", 16);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
// \tcode{v0[gslice(3, len, str)]} returns
// \tcode{valarray<char>("dfhkmo", 6)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
gslice_array<T> operator[](const gslice& gslicearr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object that holds references to elements of the controlled
sequence selected by \tcode{gslicearr}.
\begin{example}
\begin{codeblock}
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDEF", 6);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// \tcode{v0 == valarray<char>("abcAeBgCijDlEnFp", 16)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
valarray operator[](const valarray<bool>& boolarr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} containing those
elements of the controlled sequence designated by \tcode{boolarr}.
\begin{example}
\begin{codeblock}
const valarray<char> v0("abcdefghijklmnop", 16);
const bool vb[] = { false, false, true, true, false, true };
// \tcode{v0[valarray<bool>(vb, 6)]} returns
// \tcode{valarray<char>("cdf", 3)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
mask_array<T> operator[](const valarray<bool>& boolarr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object that holds references to elements of the controlled
sequence selected by \tcode{boolarr}.
\begin{example}
\begin{codeblock}
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABC", 3);
const bool vb[] = { false, false, true, true, false, true };
v0[valarray<bool>(vb, 6)] = v1;
// \tcode{v0 == valarray<char>("abABeCghijklmnop", 16)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
valarray operator[](const valarray<size_t>& indarr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} containing those
elements of the controlled sequence designated by \tcode{indarr}.
\begin{example}
\begin{codeblock}
const valarray<char> v0("abcdefghijklmnop", 16);
const size_t vi[] = { 7, 5, 2, 3, 8 };
// \tcode{v0[valarray<size_t>(vi, 5)]} returns
// \tcode{valarray<char>("hfcdi", 5)}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator[]}{valarray}%
\begin{itemdecl}
indirect_array<T> operator[](const valarray<size_t>& indarr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An object that holds references to elements of the controlled
sequence selected by \tcode{indarr}.
\begin{example}
\begin{codeblock}
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
const size_t vi[] = { 7, 5, 2, 3, 8 };
v0[valarray<size_t>(vi, 5)] = v1;
// \tcode{v0 == valarray<char>("abCDeBgAEjklmnop", 16)}
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec3[valarray.unary]{Unary operators}

\indexlibrarymember{operator+}{valarray}%
\indexlibrarymember{operator-}{valarray}%
\indexlibrarymember{operator\~{}}{valarray}%
\indexlibrarymember{operator"!}{valarray}%
\begin{itemdecl}
valarray operator+() const;
valarray operator-() const;
valarray operator~() const;
valarray<bool> operator!() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to operands of type \tcode{T}
and returns a value of type \tcode{T} (\tcode{bool} for
\tcode{operator!}) or which may be unambiguously implicitly converted to type
\tcode{T} (\tcode{bool} for \tcode{operator!}).

\pnum
\returns
A \tcode{valarray} whose length is \tcode{size()}.
Each element of the returned array is initialized with the result of
applying the indicated operator to the corresponding element of the array.
\end{itemdescr}

\rSec3[valarray.cassign]{Compound assignment}

\indexlibrarymember{operator*=}{valarray}%
\indexlibrarymember{operator/=}{valarray}%
\indexlibrarymember{operator\%=}{valarray}%
\indexlibrarymember{operator+=}{valarray}%
\indexlibrarymember{operator-=}{valarray}%
\indexlibrarymember{operator\caret=}{valarray}%
\indexlibrarymember{operator\&=}{valarray}%
\indexlibrarymember{operator"|=}{valarray}%
\indexlibrarymember{operator<<=}{valarray}%
\indexlibrarymember{operator>>=}{valarray}%
\begin{itemdecl}
valarray& operator*= (const valarray& v);
valarray& operator/= (const valarray& v);
valarray& operator%= (const valarray& v);
valarray& operator+= (const valarray& v);
valarray& operator-= (const valarray& v);
valarray& operator^= (const valarray& v);
valarray& operator&= (const valarray& v);
valarray& operator|= (const valarray& v);
valarray& operator<<=(const valarray& v);
valarray& operator>>=(const valarray& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to two operands of type \tcode{T}.

\pnum
\expects
\tcode{size() == v.size()} is \tcode{true}.

The value of an element in the left-hand side of a valarray compound
assignment operator does not depend on the value of another element in that left
hand side.

\pnum
\effects
Each of these operators
performs the indicated operation on each of the elements of \tcode{*this} and the
corresponding element of \tcode{v}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
The appearance of an array on the left-hand side of a compound assignment
does not invalidate references or pointers.
\end{itemdescr}

\indexlibrarymember{operator*=}{valarray}%
\indexlibrarymember{operator/=}{valarray}%
\indexlibrarymember{operator\%=}{valarray}%
\indexlibrarymember{operator+=}{valarray}%
\indexlibrarymember{operator-=}{valarray}%
\indexlibrarymember{operator\caret=}{valarray}%
\indexlibrarymember{operator\&=}{valarray}%
\indexlibrarymember{operator"|=}{valarray}%
\indexlibrarymember{operator<<=}{valarray}%
\indexlibrarymember{operator>>=}{valarray}%
\begin{itemdecl}
valarray& operator*= (const T& v);
valarray& operator/= (const T& v);
valarray& operator%= (const T& v);
valarray& operator+= (const T& v);
valarray& operator-= (const T& v);
valarray& operator^= (const T& v);
valarray& operator&= (const T& v);
valarray& operator|= (const T& v);
valarray& operator<<=(const T& v);
valarray& operator>>=(const T& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to two operands of type \tcode{T}.

\pnum
\effects
Each of these operators applies the indicated operation to each element
of \tcode{*this} and \tcode{v}.

\pnum
\returns
\tcode{*this}

\pnum
\remarks
The appearance of an array on the left-hand side of a compound assignment
does not
invalidate references or pointers to the elements of the array.
\end{itemdescr}

\rSec3[valarray.members]{Member functions}

\indexlibrarymember{swap}{valarray}%
\begin{itemdecl}
void swap(valarray& v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{*this} obtains the value of
\tcode{v}. \tcode{v} obtains the value of \tcode{*this}.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrarymember{size}{valarray}%
\begin{itemdecl}
size_t size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The number of elements in the array.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{sum}{valarray}%
\begin{itemdecl}
T sum() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{operator+=} can be applied to operands of type \tcode{T}.

\pnum
\expects
\tcode{size() > 0} is \tcode{true}.

\pnum
\returns
The sum of all the elements of the array.
If the array has length 1, returns the value of element 0.
Otherwise, the returned value is calculated by applying
\tcode{operator+=}
to a copy of an element of the array and
all other elements of the array in an unspecified order.%
\end{itemdescr}

\indexlibrarymember{min}{valarray}%
\begin{itemdecl}
T min() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{size() > 0} is \tcode{true}.

\pnum
\returns
The minimum value contained in \tcode{*this}.
For an array of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\indexlibrarymember{max}{valarray}%
\begin{itemdecl}
T max() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{size() > 0} is \tcode{true}.

\pnum
\returns
The maximum value contained in \tcode{*this}.
For an array of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\indexlibrarymember{shift}{valarray}%
\begin{itemdecl}
valarray shift(int n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} of length \tcode{size()}, each of whose elements
\placeholder{I} is
\tcode{(*this)[\placeholder{I} + n]}
if \tcode{\placeholder{I} + n}
is non-negative and less than
\tcode{size()}, otherwise \tcode{T()}.
\begin{note}
If element zero is taken as the leftmost element,
a positive value of \tcode{n} shifts the elements left \tcode{n}
places, with zero fill.
\end{note}

\pnum
\begin{example}
If the argument has the value $-2$,
the first two elements of the result will be value-initialized\iref{dcl.init}; the third element of the result will be assigned the value
of the first element of \tcode{*this}; etc.
\end{example}
\end{itemdescr}

\indexlibrarymember{cshift}{valarray}%
\begin{itemdecl}
valarray cshift(int n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} of length \tcode{size()}
that is a circular shift of \tcode{*this}. If element zero is taken as
the leftmost element, a non-negative value of $n$ shifts
the elements circularly left $n$ places and a negative
value of $n$ shifts the elements circularly right $-n$ places.
\end{itemdescr}

\indexlibrarymember{apply}{valarray}%
\begin{itemdecl}
valarray apply(T func(T)) const;
valarray apply(T func(const T&)) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{valarray} whose length is \tcode{size()}.
Each element of the returned array is assigned
the value returned by applying the argument function to the
corresponding element of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{resize}{valarray}%
\begin{itemdecl}
void resize(size_t sz, T c = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Changes the length of the \tcode{*this} array to \tcode{sz}
and then assigns to each element the value of the second argument.
Resizing invalidates all pointers and references to elements in the array.
\end{itemdescr}

\rSec2[valarray.nonmembers]{\tcode{valarray} non-member operations}

\rSec3[valarray.binary]{Binary operators}

\indexlibrarymember{operator*}{valarray}%
\indexlibrarymember{operator/}{valarray}%
\indexlibrarymember{operator\%}{valarray}%
\indexlibrarymember{operator+}{valarray}%
\indexlibrarymember{operator-}{valarray}%
\indexlibrarymember{operator\caret}{valarray}%
\indexlibrarymember{operator\&}{valarray}%
\indexlibrarymember{operator"|}{valarray}%
\indexlibrarymember{operator<<}{valarray}%
\indexlibrarymember{operator>>}{valarray}%
\begin{itemdecl}
template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to operands of type \tcode{T} and returns
a value of type \tcode{T} or which can be unambiguously
implicitly converted to \tcode{T}.

\pnum
\expects
The argument arrays have the same length.

\pnum
\returns
A \tcode{valarray} whose length is equal to the
lengths of the argument arrays.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding elements of the argument arrays.
\end{itemdescr}

\indexlibrarymember{operator*}{valarray}%
\indexlibrarymember{operator/}{valarray}%
\indexlibrarymember{operator\%}{valarray}%
\indexlibrarymember{operator+}{valarray}%
\indexlibrarymember{operator-}{valarray}%
\indexlibrarymember{operator\caret}{valarray}%
\indexlibrarymember{operator\&}{valarray}%
\indexlibrarymember{operator"|}{valarray}%
\indexlibrarymember{operator<<}{valarray}%
\indexlibrarymember{operator>>}{valarray}%
\begin{itemdecl}
template<class T> valarray<T> operator* (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator* (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator/ (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator% (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator+ (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator- (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator^ (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator& (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator| (const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator<<(const typename valarray<T>::value_type&,
                                         const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&,
                                         const typename valarray<T>::value_type&);
template<class T> valarray<T> operator>>(const typename valarray<T>::value_type&,
                                         const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to operands of type \tcode{T} and returns
a value of type \tcode{T} or which can be unambiguously
implicitly converted to \tcode{T}.

\pnum
\returns
A \tcode{valarray} whose length is equal to the
length of the array argument.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding element of the array argument and the non-array argument.
\end{itemdescr}

\rSec3[valarray.comparison]{Logical operators}

\indexlibrarymember{operator==}{valarray}%
\indexlibrarymember{operator"!=}{valarray}%
\indexlibrarymember{operator<}{valarray}%
\indexlibrarymember{operator>}{valarray}%
\indexlibrarymember{operator<=}{valarray}%
\indexlibrarymember{operator>=}{valarray}%
\indexlibrarymember{operator\&\&}{valarray}%
\indexlibrarymember{operator"|"|}{valarray}%
\begin{itemdecl}
template<class T> valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to operands of type \tcode{T} and returns
a value of type \tcode{bool} or which can be unambiguously
implicitly converted to \tcode{bool}.

\pnum
\expects
The two array arguments have the same length.
\indextext{undefined}

\pnum
\returns
A \tcode{valarray<bool>} whose length
is equal to the length of the array arguments.
Each element of the returned
array is initialized with the result of applying the indicated
operator to the corresponding elements of the argument arrays.
\end{itemdescr}

\indexlibrarymember{operator==}{valarray}%
\indexlibrarymember{operator"!=}{valarray}%
\indexlibrarymember{operator<}{valarray}%
\indexlibrarymember{operator>}{valarray}%
\indexlibrarymember{operator<=}{valarray}%
\indexlibrarymember{operator>=}{valarray}%
\indexlibrarymember{operator\&\&}{valarray}%
\indexlibrarymember{operator"|"|}{valarray}%
\begin{itemdecl}
template<class T> valarray<bool> operator==(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator==(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator!=(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator< (const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator> (const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator<=(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator>=(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator&&(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&,
                                            const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator||(const typename valarray<T>::value_type&,
                                            const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The indicated operator can be applied to operands of type \tcode{T} and returns
a value of type \tcode{bool} or which can be unambiguously
implicitly converted to \tcode{bool}.

\pnum
\returns
A \tcode{valarray<bool>} whose
length is equal to the length of the array argument.
Each element
of the returned array is initialized with the result of applying the
indicated operator to the corresponding element of the array and the non-array argument.
\end{itemdescr}

\rSec3[valarray.transcend]{Transcendentals}

\indexlibrarymember{abs}{valarray}%
\indexlibrarymember{acos}{valarray}%
\indexlibrarymember{asin}{valarray}%
\indexlibrarymember{atan}{valarray}%
\indexlibrarymember{atan2}{valarray}%
\indexlibrarymember{cos}{valarray}%
\indexlibrarymember{cosh}{valarray}%
\indexlibrarymember{exp}{valarray}%
\indexlibrarymember{log}{valarray}%
\indexlibrarymember{log10}{valarray}%
\indexlibrarymember{pow}{valarray}%
\indexlibrarymember{sin}{valarray}%
\indexlibrarymember{sinh}{valarray}%
\indexlibrarymember{sqrt}{valarray}%
\indexlibrarymember{tan}{valarray}%
\indexlibrarymember{tanh}{valarray}%
\begin{itemdecl}
template<class T> valarray<T> abs  (const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const typename valarray<T>::value_type&);
template<class T> valarray<T> atan2(const typename valarray<T>::value_type&, const valarray<T>&);
template<class T> valarray<T> cos  (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp  (const valarray<T>&);
template<class T> valarray<T> log  (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);
template<class T> valarray<T> pow  (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow  (const valarray<T>&, const typename valarray<T>::value_type&);
template<class T> valarray<T> pow  (const typename valarray<T>::value_type&, const valarray<T>&);
template<class T> valarray<T> sin  (const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
template<class T> valarray<T> tan  (const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
A unique function with the indicated name can be applied (unqualified)
to an operand of type \tcode{T}.
This function returns a value of type \tcode{T}
or which can be unambiguously implicitly converted to type \tcode{T}.

\end{itemdescr}

\rSec3[valarray.special]{Specialized algorithms}

\indexlibrarymember{swap}{valarray}%
\begin{itemdecl}
template<class T> void swap(valarray<T>& x, valarray<T>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{x.swap(y)}.
\end{itemdescr}


\rSec2[class.slice]{Class \tcode{slice}}

\rSec3[class.slice.overview]{Overview}

\indexlibraryglobal{slice}%
\begin{codeblock}
namespace std {
  class slice {
  public:
    slice();
    slice(size_t, size_t, size_t);
    slice(const slice&);

    size_t start() const;
    size_t size() const;
    size_t stride() const;

    friend bool operator==(const slice& x, const slice& y);
  };
}
\end{codeblock}

\pnum
The \tcode{slice}
class represents a BLAS-like slice from an array.
Such a slice is specified by a starting index, a length, and a
stride.
\begin{footnote}
BLAS stands for
\textit{Basic Linear Algebra Subprograms}.
\Cpp{} programs can instantiate this class.
See, for example,
Dongarra, Du Croz, Duff, and Hammerling:
\textit{A set of Level 3 Basic Linear Algebra Subprograms};
Technical Report MCS-P1-0888,
Argonne National Laboratory (USA),
Mathematics and Computer Science Division,
August, 1988.
\end{footnote}

\rSec3[cons.slice]{Constructors}

\indexlibraryctor{slice}%
\begin{itemdecl}
slice();
slice(size_t start, size_t length, size_t stride);
\end{itemdecl}

\begin{itemdescr}
\pnum
The default constructor is equivalent to \tcode{slice(0, 0, 0)}.
A default constructor is provided only to permit the declaration of arrays of slices.
The constructor with arguments for a slice takes a start, length, and stride
parameter.

\pnum
\begin{example}
\tcode{slice(3, 8, 2)}
constructs a slice which selects elements $3, 5, 7, \dotsc, 17$ from an array.
\end{example}
\end{itemdescr}

\rSec3[slice.access]{Access functions}
\indexlibrarymember{start}{slice}%
\indexlibrarymember{size}{slice}%
\indexlibrarymember{stride}{slice}%
\begin{itemdecl}
size_t start() const;
size_t size() const;
size_t stride() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The start, length, or stride specified
by a \tcode{slice} object.

\pnum
\complexity
Constant time.
\end{itemdescr}

\rSec3[slice.ops]{Operators}

\indexlibrarymember{stride}{slice}%
\begin{itemdecl}
friend bool operator==(const slice& x, const slice& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return x.start() == y.start() && x.size() == y.size() && x.stride() == y.stride();
\end{codeblock}
\end{itemdescr}

\rSec2[template.slice.array]{Class template \tcode{slice_array}}

\rSec3[template.slice.array.overview]{Overview}

\indexlibraryglobal{slice_array}%
\indexlibrarymember{value_type}{slice_array}%
\begin{codeblock}
namespace std {
  template<class T> class slice_array {
  public:
    using value_type = T;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    slice_array(const slice_array&);
    ~slice_array();
    const slice_array& operator=(const slice_array&) const;
    void operator=(const T&) const;

    slice_array() = delete;     // as implied by declaring copy constructor above
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the
\tcode{slice} subscript operator
\begin{codeblock}
slice_array<T> valarray<T>::operator[](slice);
\end{codeblock}

\pnum
It has reference semantics to a subset of an array specified by a
\tcode{slice}
object.
\begin{example}
The expression
\tcode{a[slice(1, 5, 3)] = b;}
has the effect of assigning the elements of
\tcode{b}
to a slice of the elements in
\tcode{a}.
For the slice shown, the elements
selected from
\tcode{a}
are $1, 4, \dotsc, 13$.
\end{example}

\rSec3[slice.arr.assign]{Assignment}

\indexlibrarymember{operator=}{slice_array}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
const slice_array& operator=(const slice_array&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics,
assigning the values of the argument array elements to selected
elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec3[slice.arr.comp.assign]{Compound assignment}

\indexlibrarymember{operator*=}{slice_array}%
\indexlibrarymember{operator/=}{slice_array}%
\indexlibrarymember{operator\%=}{slice_array}%
\indexlibrarymember{operator+=}{slice_array}%
\indexlibrarymember{operator-=}{slice_array}%
\indexlibrarymember{operator\caret=}{slice_array}%
\indexlibrarymember{operator\&=}{slice_array}%
\indexlibrarymember{operator"|=}{slice_array}%
\indexlibrarymember{operator<<=}{slice_array}%
\indexlibrarymember{operator>>=}{slice_array}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array
and selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec3[slice.arr.fill]{Fill function}

\indexlibrarymember{operator=}{slice_array}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec2[class.gslice]{The \tcode{gslice} class}

\rSec3[class.gslice.overview]{Overview}

\indexlibraryglobal{gslice}%
\begin{codeblock}
namespace std {
  class gslice {
  public:
    gslice();
    gslice(size_t s, const valarray<size_t>& l, const valarray<size_t>& d);

    size_t           start() const;
    valarray<size_t> size() const;
    valarray<size_t> stride() const;
  };
}
\end{codeblock}

\pnum
This class represents a generalized slice out of an array.
A
\tcode{gslice}
is defined by a starting offset ($s$),
a set of lengths ($l_j$),
and a set of strides ($d_j$).
The number of lengths shall equal the number of strides.

\pnum
A
\tcode{gslice}
represents a mapping from a set of indices ($i_j$),
equal in number to the number of strides, to a single index $k$.
It is useful for building multidimensional array classes using
the
\tcode{valarray}
template, which is one-dimensional.
The set of one-dimensional index values specified by a \tcode{gslice} are
\[ k = s + \sum_j i_j d_j \]
where the multidimensional indices $i_j$ range in value from
0 to $l_{ij} - 1$.

\pnum
\begin{example}
The
\tcode{gslice}
specification
\begin{codeblock}
start  = 3
length = {2, 4, 3}
stride = {19, 4, 1}
\end{codeblock}
yields the sequence of one-dimensional indices
\[ k = 3 + (0, 1) \times 19 + (0, 1, 2, 3) \times 4 + (0, 1, 2) \times 1 \]
which are ordered as shown in the following table:

\begin{tabbing}
\hspace{.5in}\=\hspace{.4in}\=\kill%
\>$(i_0,\quad i_1,\quad i_2,\quad k)\quad =$\\
\>\>$(0,\quad 0,\quad 0,\quad \ 3)$,    \\
\>\>$(0,\quad 0,\quad 1,\quad \ 4)$,    \\
\>\>$(0,\quad 0,\quad 2,\quad \ 5)$,    \\
\>\>$(0,\quad 1,\quad 0,\quad \ 7)$,    \\
\>\>$(0,\quad 1,\quad 1,\quad \ 8)$,    \\
\>\>$(0,\quad 1,\quad 2,\quad \ 9)$,    \\
\>\>$(0,\quad 2,\quad 0,\quad 11)$, \\
\>\>$(0,\quad 2,\quad 1,\quad 12)$, \\
\>\>$(0,\quad 2,\quad 2,\quad 13)$, \\
\>\>$(0,\quad 3,\quad 0,\quad 15)$, \\
\>\>$(0,\quad 3,\quad 1,\quad 16)$, \\
\>\>$(0,\quad 3,\quad 2,\quad 17)$, \\
\>\>$(1,\quad 0,\quad 0,\quad 22)$, \\
\>\>$(1,\quad 0,\quad 1,\quad 23)$, \\
\>\>$\ldots$      \\
\>\>$(1,\quad 3,\quad 2,\quad 36)$
\end{tabbing}

That is, the highest-ordered index turns fastest.
\end{example}

\pnum
It is possible to have degenerate generalized slices in which an address
is repeated.

\pnum
\begin{example}
If the stride parameters in the previous
example are changed to \{1, 1, 1\}, the first few elements of the
resulting sequence of indices will be

\begin{tabbing}
\hspace{.9in}\=\kill%
\>$(0,\quad 0,\quad 0,\quad \ 3)$,  \\
\>$(0,\quad 0,\quad 1,\quad \ 4)$,  \\
\>$(0,\quad 0,\quad 2,\quad \ 5)$,  \\
\>$(0,\quad 1,\quad 0,\quad \ 4)$,  \\
\>$(0,\quad 1,\quad 1,\quad \ 5)$,  \\
\>$(0,\quad 1,\quad 2,\quad \ 6)$,  \\
\>$\ldots$
\end{tabbing}
\end{example}

\pnum
If a degenerate slice is used as the argument to the
non-\keyword{const}
version of
\tcode{operator[](const gslice\&)},
the behavior is undefined.
\indextext{undefined}%

\rSec3[gslice.cons]{Constructors}

\indexlibraryctor{gslice}%
\begin{itemdecl}
gslice();
gslice(size_t start, const valarray<size_t>& lengths,
       const valarray<size_t>& strides);
\end{itemdecl}

\begin{itemdescr}
\pnum
The default constructor is equivalent to
\tcode{gslice(0, valarray<size_t>(), valarray<size_t>())}.
The constructor with arguments builds a
\tcode{gslice}
based on a specification of start, lengths, and strides, as explained
in the previous subclause.
\end{itemdescr}

\rSec3[gslice.access]{Access functions}

\indexlibrarymember{start}{gslice}%
\indexlibrarymember{size}{gslice}%
\indexlibrarymember{stride}{gslice}%
\begin{itemdecl}
size_t           start()  const;
valarray<size_t> size() const;
valarray<size_t> stride() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The representation of the
start, lengths, or strides specified for the \tcode{gslice}.

\pnum
\complexity
\tcode{start()} is constant time. \tcode{size()} and \tcode{stride()}
are linear in the number of strides.
\end{itemdescr}

\rSec2[template.gslice.array]{Class template \tcode{gslice_array}}

\rSec3[template.gslice.array.overview]{Overview}

\indexlibraryglobal{gslice_array}%
\indexlibrarymember{value_type}{gslice_array}%
\begin{codeblock}
namespace std {
  template<class T> class gslice_array {
  public:
    using value_type = T;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    gslice_array(const gslice_array&);
    ~gslice_array();
    const gslice_array& operator=(const gslice_array&) const;
    void operator=(const T&) const;

    gslice_array() = delete;    // as implied by declaring copy constructor above
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the
\tcode{gslice}
subscript operator

\indexlibraryglobal{gslice_array}%
\indexlibraryglobal{valarray}%
\begin{itemdecl}
gslice_array<T> valarray<T>::operator[](const gslice&);
\end{itemdecl}

\pnum
It has reference semantics to a subset of an array specified by a
\tcode{gslice}
object.
Thus, the expression
\tcode{a[gslice(1, length, stride)] = b}
has the effect of assigning the elements of
\tcode{b}
to a
generalized slice of the elements in
\tcode{a}.

\rSec3[gslice.array.assign]{Assignment}

\indexlibrarymember{operator=}{gslice_array}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
const gslice_array& operator=(const gslice_array&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
refers.
\end{itemdescr}

\rSec3[gslice.array.comp.assign]{Compound assignment}

\indexlibrarymember{operator*=}{gslice_array}%
\indexlibrarymember{operator/=}{gslice_array}%
\indexlibrarymember{operator\%=}{gslice_array}%
\indexlibrarymember{operator+=}{gslice_array}%
\indexlibrarymember{operator-=}{gslice_array}%
\indexlibrarymember{operator\caret=}{gslice_array}%
\indexlibrarymember{operator\&=}{gslice_array}%
\indexlibrarymember{operator"|=}{gslice_array}%
\indexlibrarymember{operator<<=}{gslice_array}%
\indexlibrarymember{operator>>=}{gslice_array}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected
elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
object refers.
\end{itemdescr}

\rSec3[gslice.array.fill]{Fill function}

\indexlibrarymember{operator=}{gslice_array}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
object refers.
\end{itemdescr}

\rSec2[template.mask.array]{Class template \tcode{mask_array}}

\rSec3[template.mask.array.overview]{Overview}

\indexlibraryglobal{mask_array}%
\indexlibrarymember{value_type}{mask_array}%
\begin{codeblock}
namespace std {
  template<class T> class mask_array {
  public:
    using value_type = T;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    mask_array(const mask_array&);
    ~mask_array();
    const mask_array& operator=(const mask_array&) const;
    void operator=(const T&) const;

    mask_array() = delete;      // as implied by declaring copy constructor above
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the mask subscript operator:

\indexlibrarymember{operator[]}{mask_array}%
\begin{itemdecl}
mask_array<T> valarray<T>::operator[](const valarray<bool>&);
\end{itemdecl}

\pnum
It has reference semantics to a subset of an array specified by a boolean mask.
Thus, the expression \tcode{a[mask] = b;}
has the effect of assigning the elements of
\tcode{b} to the masked elements in \tcode{a}
(those for which the corresponding element in
\tcode{mask} is \tcode{true}).

\rSec3[mask.array.assign]{Assignment}

\indexlibrarymember{operator=}{mask_array}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
const mask_array& operator=(const mask_array&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which the \tcode{mask_array} object refers.
\end{itemdescr}

\rSec3[mask.array.comp.assign]{Compound assignment}

\indexlibrarymember{operator*=}{mask_array}%
\indexlibrarymember{operator/=}{mask_array}%
\indexlibrarymember{operator\%=}{mask_array}%
\indexlibrarymember{operator+=}{mask_array}%
\indexlibrarymember{operator-=}{mask_array}%
\indexlibrarymember{operator\caret=}{mask_array}%
\indexlibrarymember{operator\&=}{mask_array}%
\indexlibrarymember{operator"|=}{mask_array}%
\indexlibrarymember{operator<<=}{mask_array}%
\indexlibrarymember{operator>>=}{mask_array}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected elements
of the
\tcode{valarray<T>}
object to which the \tcode{mask_array} object refers.
\end{itemdescr}

\rSec3[mask.array.fill]{Fill function}

\indexlibrarymember{operator=}{mask_array}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its
argument to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{mask_array}
object refers.
\end{itemdescr}

\rSec2[template.indirect.array]{Class template \tcode{indirect_array}}

\rSec3[template.indirect.array.overview]{Overview}

\indexlibraryglobal{indirect_array}%
\indexlibrarymember{value_type}{indirect_array}%
\begin{codeblock}
namespace std {
  template<class T> class indirect_array {
  public:
    using value_type = T;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    indirect_array(const indirect_array&);
    ~indirect_array();
    const indirect_array& operator=(const indirect_array&) const;
    void operator=(const T&) const;

    indirect_array() = delete;  // as implied by declaring copy constructor above
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the indirect subscript operator

\indexlibrarymember{operator[]}{indirect_array}%
\begin{itemdecl}
indirect_array<T> valarray<T>::operator[](const valarray<size_t>&);
\end{itemdecl}

\pnum
It has reference semantics to a subset of an array specified by an
\tcode{indirect_array}.
Thus, the expression
\tcode{a[\brk{}indirect] = b;}
has the effect of assigning the elements of
\tcode{b}
to the elements in
\tcode{a}
whose indices appear in
\tcode{indirect}.

\rSec3[indirect.array.assign]{Assignment}

\indexlibrarymember{operator=}{indirect_array}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
const indirect_array& operator=(const indirect_array&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which it refers.

\pnum
If the
\tcode{indirect_array}
specifies an element in the
\tcode{valarray<T>}
object to which it refers more than once, the behavior is undefined.
\indextext{undefined}%

\pnum
\begin{example}
\begin{codeblock}
int addr[] = {2, 3, 1, 4, 4};
valarray<size_t> indirect(addr, 5);
valarray<double> a(0., 10), b(1., 5);
a[indirect] = b;
\end{codeblock}
results in undefined behavior since element 4 is specified twice in the
indirection.
\end{example}
\end{itemdescr}

\rSec3[indirect.array.comp.assign]{Compound assignment}

\indexlibrarymember{operator*=}{indirect_array}%
\indexlibrarymember{operator/=}{indirect_array}%
\indexlibrarymember{operator\%=}{indirect_array}%
\indexlibrarymember{operator+=}{indirect_array}%
\indexlibrarymember{operator-=}{indirect_array}%
\indexlibrarymember{operator\caret=}{indirect_array}%
\indexlibrarymember{operator\&=}{indirect_array}%
\indexlibrarymember{operator"|=}{indirect_array}%
\indexlibrarymember{operator<<=}{indirect_array}%
\indexlibrarymember{operator>>=}{indirect_array}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These compound assignments have reference semantics, applying the indicated
operation to the elements of the argument array and selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{indirect_array}
object refers.

\pnum
If the
\tcode{indirect_array}
specifies an element in the
\tcode{valarray<T>}
object to which it refers more than once,
the behavior is undefined.
\indextext{undefined}
\end{itemdescr}

\rSec3[indirect.array.fill]{Fill function}

\indexlibrarymember{operator=}{indirect_array}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{indirect_array}
object refers.
\end{itemdescr}

\rSec2[valarray.range]{\tcode{valarray} range access}

\pnum
In the \tcode{begin} and \tcode{end} function templates that follow, \unspec{1}
is a type that meets the requirements of a mutable
\oldconcept{RandomAccessIterator}\iref{random.access.iterators}
and models \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous},
whose \tcode{value_type} is the template
parameter \tcode{T} and whose \tcode{reference} type is \tcode{T\&}. \unspec{2} is a
type that meets the requirements of a constant
\oldconcept{RandomAccessIterator}
and models \libconcept{contiguous_iterator},
whose \tcode{value_type} is the template
parameter \tcode{T} and whose \tcode{reference} type is \tcode{const T\&}.

\pnum
The iterators returned by \tcode{begin} and \tcode{end} for an array
are guaranteed to be valid until the member function
\tcode{resize(size_t, T)}\iref{valarray.members} is called for that
array or until the lifetime of that array ends, whichever happens
first.

\indexlibrarymember{begin}{valarray}%
\begin{itemdecl}
template<class T> @\unspec{1}@ begin(valarray<T>& v);
template<class T> @\unspec{2}@ begin(const valarray<T>& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referencing the first value in the array.
\end{itemdescr}

\indexlibrarymember{end}{valarray}%
\begin{itemdecl}
template<class T> @\unspec{1}@ end(valarray<T>& v);
template<class T> @\unspec{2}@ end(const valarray<T>& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referencing one past the last value in the array.
\end{itemdescr}

\rSec1[c.math]{Mathematical functions for floating-point types}

\rSec2[cmath.syn]{Header \tcode{<cmath>} synopsis}

\indexheader{cmath}%
\indexlibraryglobal{FP_FAST_FMA}%
\indexlibraryglobal{FP_FAST_FMAF}%
\indexlibraryglobal{FP_FAST_FMAL}%
\indexlibraryglobal{FP_ILOGB0}%
\indexlibraryglobal{FP_ILOGBNAN}%
\indexlibraryglobal{FP_INFINITE}%
\indexlibraryglobal{FP_NAN}%
\indexlibraryglobal{FP_NORMAL}%
\indexlibraryglobal{FP_SUBNORMAL}%
\indexlibraryglobal{FP_ZERO}%
\indexlibraryglobal{HUGE_VAL}%
\indexlibraryglobal{HUGE_VALF}%
\indexlibraryglobal{HUGE_VALL}%
\indexlibraryglobal{INFINITY}%
\indexlibraryglobal{MATH_ERREXCEPT}%
\indexlibraryglobal{MATH_ERRNO}%
\indexlibraryglobal{NAN}%
\indexlibraryglobal{abs}%
\indexlibraryglobal{acos}%
\indexlibraryglobal{acosf}%
\indexlibraryglobal{acosh}%
\indexlibraryglobal{acoshf}%
\indexlibraryglobal{acoshl}%
\indexlibraryglobal{acosl}%
\indexlibraryglobal{asin}%
\indexlibraryglobal{asinf}%
\indexlibraryglobal{asinh}%
\indexlibraryglobal{asinhf}%
\indexlibraryglobal{asinhl}%
\indexlibraryglobal{asinl}%
\indexlibraryglobal{atan}%
\indexlibraryglobal{atan2}%
\indexlibraryglobal{atan2f}%
\indexlibraryglobal{atan2l}%
\indexlibraryglobal{atanf}%
\indexlibraryglobal{atanh}%
\indexlibraryglobal{atanhf}%
\indexlibraryglobal{atanhl}%
\indexlibraryglobal{atanl}%
\indexlibraryglobal{cbrt}%
\indexlibraryglobal{cbrtf}%
\indexlibraryglobal{cbrtl}%
\indexlibraryglobal{ceil}%
\indexlibraryglobal{ceilf}%
\indexlibraryglobal{ceill}%
\indexlibraryglobal{copysign}%
\indexlibraryglobal{copysignf}%
\indexlibraryglobal{copysignl}%
\indexlibraryglobal{cos}%
\indexlibraryglobal{cosf}%
\indexlibraryglobal{cosh}%
\indexlibraryglobal{coshf}%
\indexlibraryglobal{coshl}%
\indexlibraryglobal{cosl}%
\indexlibraryglobal{double_t}%
\indexlibraryglobal{erf}%
\indexlibraryglobal{erfc}%
\indexlibraryglobal{erfcf}%
\indexlibraryglobal{erfcl}%
\indexlibraryglobal{erff}%
\indexlibraryglobal{erfl}%
\indexlibraryglobal{exp}%
\indexlibraryglobal{exp2}%
\indexlibraryglobal{exp2f}%
\indexlibraryglobal{exp2l}%
\indexlibraryglobal{expf}%
\indexlibraryglobal{expl}%
\indexlibraryglobal{expm1}%
\indexlibraryglobal{expm1f}%
\indexlibraryglobal{expm1l}%
\indexlibraryglobal{fabs}%
\indexlibraryglobal{fabsf}%
\indexlibraryglobal{fabsl}%
\indexlibraryglobal{fdim}%
\indexlibraryglobal{fdimf}%
\indexlibraryglobal{fdiml}%
\indexlibraryglobal{float_t}%
\indexlibraryglobal{floor}%
\indexlibraryglobal{floorf}%
\indexlibraryglobal{floorl}%
\indexlibraryglobal{fma}%
\indexlibraryglobal{fmaf}%
\indexlibraryglobal{fmal}%
\indexlibraryglobal{fmax}%
\indexlibraryglobal{fmaxf}%
\indexlibraryglobal{fmaxl}%
\indexlibraryglobal{fmin}%
\indexlibraryglobal{fminf}%
\indexlibraryglobal{fminl}%
\indexlibraryglobal{fmod}%
\indexlibraryglobal{fmodf}%
\indexlibraryglobal{fmodl}%
\indexlibraryglobal{fpclassify}%
\indexlibraryglobal{frexp}%
\indexlibraryglobal{frexpf}%
\indexlibraryglobal{frexpl}%
\indexlibraryglobal{hypot}%
\indexlibraryglobal{hypotf}%
\indexlibraryglobal{hypotl}%
\indexlibraryglobal{ilogb}%
\indexlibraryglobal{ilogbf}%
\indexlibraryglobal{ilogbl}%
\indexlibraryglobal{isfinite}%
\indexlibraryglobal{isgreater}%
\indexlibraryglobal{isgreaterequal}%
\indexlibraryglobal{isinf}%
\indexlibraryglobal{isless}%
\indexlibraryglobal{islessequal}%
\indexlibraryglobal{islessgreater}%
\indexlibraryglobal{isnan}%
\indexlibraryglobal{isnormal}%
\indexlibraryglobal{isunordered}%
\indexlibraryglobal{ldexp}%
\indexlibraryglobal{ldexpf}%
\indexlibraryglobal{ldexpl}%
\indexlibraryglobal{lgamma}%
\indexlibraryglobal{lgammaf}%
\indexlibraryglobal{lgammal}%
\indexlibraryglobal{llrint}%
\indexlibraryglobal{llrintf}%
\indexlibraryglobal{llrintl}%
\indexlibraryglobal{llround}%
\indexlibraryglobal{llroundf}%
\indexlibraryglobal{llroundl}%
\indexlibraryglobal{log}%
\indexlibraryglobal{log10}%
\indexlibraryglobal{log10f}%
\indexlibraryglobal{log10l}%
\indexlibraryglobal{log1p}%
\indexlibraryglobal{log1pf}%
\indexlibraryglobal{log1pl}%
\indexlibraryglobal{log2}%
\indexlibraryglobal{log2f}%
\indexlibraryglobal{log2l}%
\indexlibraryglobal{logb}%
\indexlibraryglobal{logbf}%
\indexlibraryglobal{logbl}%
\indexlibraryglobal{logf}%
\indexlibraryglobal{logl}%
\indexlibraryglobal{lrint}%
\indexlibraryglobal{lrintf}%
\indexlibraryglobal{lrintl}%
\indexlibraryglobal{lround}%
\indexlibraryglobal{lroundf}%
\indexlibraryglobal{lroundl}%
\indexlibraryglobal{math_errhandling}%
\indexlibraryglobal{modf}%
\indexlibraryglobal{modff}%
\indexlibraryglobal{modfl}%
\indexlibraryglobal{nan}%
\indexlibraryglobal{nanf}%
\indexlibraryglobal{nanl}%
\indexlibraryglobal{nearbyint}%
\indexlibraryglobal{nearbyintf}%
\indexlibraryglobal{nearbyintl}%
\indexlibraryglobal{nextafter}%
\indexlibraryglobal{nextafterf}%
\indexlibraryglobal{nextafterl}%
\indexlibraryglobal{nexttoward}%
\indexlibraryglobal{nexttowardf}%
\indexlibraryglobal{nexttowardl}%
\indexlibraryglobal{pow}%
\indexlibraryglobal{powf}%
\indexlibraryglobal{powl}%
\indexlibraryglobal{remainder}%
\indexlibraryglobal{remainderf}%
\indexlibraryglobal{remainderl}%
\indexlibraryglobal{remquo}%
\indexlibraryglobal{remquof}%
\indexlibraryglobal{remquol}%
\indexlibraryglobal{rint}%
\indexlibraryglobal{rintf}%
\indexlibraryglobal{rintl}%
\indexlibraryglobal{round}%
\indexlibraryglobal{roundf}%
\indexlibraryglobal{roundl}%
\indexlibraryglobal{scalbln}%
\indexlibraryglobal{scalblnf}%
\indexlibraryglobal{scalblnl}%
\indexlibraryglobal{scalbn}%
\indexlibraryglobal{scalbnf}%
\indexlibraryglobal{scalbnl}%
\indexlibraryglobal{signbit}%
\indexlibraryglobal{sin}%
\indexlibraryglobal{sinf}%
\indexlibraryglobal{sinh}%
\indexlibraryglobal{sinhf}%
\indexlibraryglobal{sinhl}%
\indexlibraryglobal{sinl}%
\indexlibraryglobal{sqrt}%
\indexlibraryglobal{sqrtf}%
\indexlibraryglobal{sqrtl}%
\indexlibraryglobal{tan}%
\indexlibraryglobal{tanf}%
\indexlibraryglobal{tanh}%
\indexlibraryglobal{tanhf}%
\indexlibraryglobal{tanhl}%
\indexlibraryglobal{tanl}%
\indexlibraryglobal{tgamma}%
\indexlibraryglobal{tgammaf}%
\indexlibraryglobal{tgammal}%
\indexlibraryglobal{trunc}%
\indexlibraryglobal{truncf}%
\indexlibraryglobal{truncl}%
\begin{codeblock}
namespace std {
  using float_t = @\seebelow@;
  using double_t = @\seebelow@;
}

#define HUGE_VAL @\seebelow@
#define HUGE_VALF @\seebelow@
#define HUGE_VALL @\seebelow@
#define INFINITY @\seebelow@
#define NAN @\seebelow@
#define FP_INFINITE @\seebelow@
#define FP_NAN @\seebelow@
#define FP_NORMAL @\seebelow@
#define FP_SUBNORMAL @\seebelow@
#define FP_ZERO @\seebelow@
#define FP_FAST_FMA @\seebelow@
#define FP_FAST_FMAF @\seebelow@
#define FP_FAST_FMAL @\seebelow@
#define FP_ILOGB0 @\seebelow@
#define FP_ILOGBNAN @\seebelow@
#define MATH_ERRNO @\seebelow@
#define MATH_ERREXCEPT @\seebelow@

#define math_errhandling @\seebelow@

namespace std {
  @\placeholder{floating-point-type}@ acos(@\placeholder{floating-point-type}@ x);
  float acosf(float x);
  long double acosl(long double x);

  @\placeholder{floating-point-type}@ asin(@\placeholder{floating-point-type}@ x);
  float asinf(float x);
  long double asinl(long double x);

  @\placeholder{floating-point-type}@ atan(@\placeholder{floating-point-type}@ x);
  float atanf(float x);
  long double atanl(long double x);

  @\placeholder{floating-point-type}@ atan2(@\placeholder{floating-point-type}@ y, @\placeholder{floating-point-type}@ x);
  float atan2f(float y, float x);
  long double atan2l(long double y, long double x);

  @\placeholder{floating-point-type}@ cos(@\placeholder{floating-point-type}@ x);
  float cosf(float x);
  long double cosl(long double x);

  @\placeholder{floating-point-type}@ sin(@\placeholder{floating-point-type}@ x);
  float sinf(float x);
  long double sinl(long double x);

  @\placeholder{floating-point-type}@ tan(@\placeholder{floating-point-type}@ x);
  float tanf(float x);
  long double tanl(long double x);

  @\placeholder{floating-point-type}@ acosh(@\placeholder{floating-point-type}@ x);
  float acoshf(float x);
  long double acoshl(long double x);

  @\placeholder{floating-point-type}@ asinh(@\placeholder{floating-point-type}@ x);
  float asinhf(float x);
  long double asinhl(long double x);

  @\placeholder{floating-point-type}@ atanh(@\placeholder{floating-point-type}@ x);
  float atanhf(float x);
  long double atanhl(long double x);

  @\placeholder{floating-point-type}@ cosh(@\placeholder{floating-point-type}@ x);
  float coshf(float x);
  long double coshl(long double x);

  @\placeholder{floating-point-type}@ sinh(@\placeholder{floating-point-type}@ x);
  float sinhf(float x);
  long double sinhl(long double x);

  @\placeholder{floating-point-type}@ tanh(@\placeholder{floating-point-type}@ x);
  float tanhf(float x);
  long double tanhl(long double x);

  @\placeholder{floating-point-type}@ exp(@\placeholder{floating-point-type}@ x);
  float expf(float x);
  long double expl(long double x);

  @\placeholder{floating-point-type}@ exp2(@\placeholder{floating-point-type}@ x);
  float exp2f(float x);
  long double exp2l(long double x);

  @\placeholder{floating-point-type}@ expm1(@\placeholder{floating-point-type}@ x);
  float expm1f(float x);
  long double expm1l(long double x);

  constexpr @\placeholder{floating-point-type}@ frexp(@\placeholder{floating-point-type}@ value, int* exp);
  constexpr float frexpf(float value, int* exp);
  constexpr long double frexpl(long double value, int* exp);

  constexpr int ilogb(@\placeholder{floating-point-type}@ x);
  constexpr int ilogbf(float x);
  constexpr int ilogbl(long double x);

  constexpr @\placeholder{floating-point-type}@ ldexp(@\placeholder{floating-point-type}@ x, int exp);
  constexpr float ldexpf(float x, int exp);
  constexpr long double ldexpl(long double x, int exp);

  @\placeholder{floating-point-type}@ log(@\placeholder{floating-point-type}@ x);
  float logf(float x);
  long double logl(long double x);

  @\placeholder{floating-point-type}@ log10(@\placeholder{floating-point-type}@ x);
  float log10f(float x);
  long double log10l(long double x);

  @\placeholder{floating-point-type}@ log1p(@\placeholder{floating-point-type}@ x);
  float log1pf(float x);
  long double log1pl(long double x);

  @\placeholder{floating-point-type}@ log2(@\placeholder{floating-point-type}@ x);
  float log2f(float x);
  long double log2l(long double x);

  constexpr @\placeholder{floating-point-type}@ logb(@\placeholder{floating-point-type}@ x);
  constexpr float logbf(float x);
  constexpr long double logbl(long double x);

  constexpr @\placeholder{floating-point-type}@ modf(@\placeholder{floating-point-type}@ value, @\placeholder{floating-point-type}@* iptr);
  constexpr float modff(float value, float* iptr);
  constexpr long double modfl(long double value, long double* iptr);

  constexpr @\placeholder{floating-point-type}@ scalbn(@\placeholder{floating-point-type}@ x, int n);
  constexpr float scalbnf(float x, int n);
  constexpr long double scalbnl(long double x, int n);

  constexpr @\placeholder{floating-point-type}@ scalbln(@\placeholder{floating-point-type}@ x, long int n);
  constexpr float scalblnf(float x, long int n);
  constexpr long double scalblnl(long double x, long int n);

  @\placeholder{floating-point-type}@ cbrt(@\placeholder{floating-point-type}@ x);
  float cbrtf(float x);
  long double cbrtl(long double x);

  // \ref{c.math.abs}, absolute values
  constexpr int abs(int j);
  constexpr long int abs(long int j);
  constexpr long long int abs(long long int j);
  constexpr @\placeholder{floating-point-type}@ abs(@\placeholder{floating-point-type}@ j);

  constexpr @\placeholder{floating-point-type}@ fabs(@\placeholder{floating-point-type}@ x);
  constexpr float fabsf(float x);
  constexpr long double fabsl(long double x);

  @\placeholder{floating-point-type}@ hypot(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  float hypotf(float x, float y);
  long double hypotl(long double x, long double y);

  // \ref{c.math.hypot3}, three-dimensional hypotenuse
  @\placeholder{floating-point-type}@ hypot(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y,
                            @\placeholder{floating-point-type}@ z);

  @\placeholder{floating-point-type}@ pow(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  float powf(float x, float y);
  long double powl(long double x, long double y);

  @\placeholder{floating-point-type}@ sqrt(@\placeholder{floating-point-type}@ x);
  float sqrtf(float x);
  long double sqrtl(long double x);

  @\placeholder{floating-point-type}@ erf(@\placeholder{floating-point-type}@ x);
  float erff(float x);
  long double erfl(long double x);

  @\placeholder{floating-point-type}@ erfc(@\placeholder{floating-point-type}@ x);
  float erfcf(float x);
  long double erfcl(long double x);

  @\placeholder{floating-point-type}@ lgamma(@\placeholder{floating-point-type}@ x);
  float lgammaf(float x);
  long double lgammal(long double x);

  @\placeholder{floating-point-type}@ tgamma(@\placeholder{floating-point-type}@ x);
  float tgammaf(float x);
  long double tgammal(long double x);

  constexpr @\placeholder{floating-point-type}@ ceil(@\placeholder{floating-point-type}@ x);
  constexpr float ceilf(float x);
  constexpr long double ceill(long double x);

  constexpr @\placeholder{floating-point-type}@ floor(@\placeholder{floating-point-type}@ x);
  constexpr float floorf(float x);
  constexpr long double floorl(long double x);

  @\placeholder{floating-point-type}@ nearbyint(@\placeholder{floating-point-type}@ x);
  float nearbyintf(float x);
  long double nearbyintl(long double x);

  @\placeholder{floating-point-type}@ rint(@\placeholder{floating-point-type}@ x);
  float rintf(float x);
  long double rintl(long double x);

  long int lrint(@\placeholder{floating-point-type}@ x);
  long int lrintf(float x);
  long int lrintl(long double x);

  long long int llrint(@\placeholder{floating-point-type}@ x);
  long long int llrintf(float x);
  long long int llrintl(long double x);

  constexpr @\placeholder{floating-point-type}@ round(@\placeholder{floating-point-type}@ x);
  constexpr float roundf(float x);
  constexpr long double roundl(long double x);

  constexpr long int lround(@\placeholder{floating-point-type}@ x);
  constexpr long int lroundf(float x);
  constexpr long int lroundl(long double x);

  constexpr long long int llround(@\placeholder{floating-point-type}@ x);
  constexpr long long int llroundf(float x);
  constexpr long long int llroundl(long double x);

  constexpr @\placeholder{floating-point-type}@ trunc(@\placeholder{floating-point-type}@ x);
  constexpr float truncf(float x);
  constexpr long double truncl(long double x);

  constexpr @\placeholder{floating-point-type}@ fmod(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float fmodf(float x, float y);
  constexpr long double fmodl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ remainder(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float remainderf(float x, float y);
  constexpr long double remainderl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ remquo(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y, int* quo);
  constexpr float remquof(float x, float y, int* quo);
  constexpr long double remquol(long double x, long double y, int* quo);

  constexpr @\placeholder{floating-point-type}@ copysign(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float copysignf(float x, float y);
  constexpr long double copysignl(long double x, long double y);

  double nan(const char* tagp);
  float nanf(const char* tagp);
  long double nanl(const char* tagp);

  constexpr @\placeholder{floating-point-type}@ nextafter(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float nextafterf(float x, float y);
  constexpr long double nextafterl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ nexttoward(@\placeholder{floating-point-type}@ x, long double y);
  constexpr float nexttowardf(float x, long double y);
  constexpr long double nexttowardl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ fdim(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float fdimf(float x, float y);
  constexpr long double fdiml(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ fmax(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float fmaxf(float x, float y);
  constexpr long double fmaxl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ fmin(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr float fminf(float x, float y);
  constexpr long double fminl(long double x, long double y);

  constexpr @\placeholder{floating-point-type}@ fma(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y,
                                  @\placeholder{floating-point-type}@ z);
  constexpr float fmaf(float x, float y, float z);
  constexpr long double fmal(long double x, long double y, long double z);

  // \ref{c.math.lerp}, linear interpolation
  constexpr @\placeholder{floating-point-type}@ lerp(@\placeholder{floating-point-type}@ a, @\placeholder{floating-point-type}@ b,
                                    @\placeholder{floating-point-type}@ t) noexcept;

  // \ref{c.math.fpclass}, classification / comparison functions
  constexpr int fpclassify(@\placeholder{floating-point-type}@ x);
  constexpr bool isfinite(@\placeholder{floating-point-type}@ x);
  constexpr bool isinf(@\placeholder{floating-point-type}@ x);
  constexpr bool isnan(@\placeholder{floating-point-type}@ x);
  constexpr bool isnormal(@\placeholder{floating-point-type}@ x);
  constexpr bool signbit(@\placeholder{floating-point-type}@ x);
  constexpr bool isgreater(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr bool isgreaterequal(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr bool isless(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr bool islessequal(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr bool islessgreater(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  constexpr bool isunordered(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);

  // \ref{sf.cmath}, mathematical special functions

  // \ref{sf.cmath.assoc.laguerre}, associated Laguerre polynomials
  @\placeholder{floating-point-type}@ assoc_laguerre(unsigned n, unsigned m, @\placeholder{floating-point-type}@ x);
  float        assoc_laguerref(unsigned n, unsigned m, float x);
  long double  assoc_laguerrel(unsigned n, unsigned m, long double x);

  // \ref{sf.cmath.assoc.legendre}, associated Legendre functions
  @\placeholder{floating-point-type}@ assoc_legendre(unsigned l, unsigned m, @\placeholder{floating-point-type}@ x);
  float        assoc_legendref(unsigned l, unsigned m, float x);
  long double  assoc_legendrel(unsigned l, unsigned m, long double x);

  // \ref{sf.cmath.beta}, beta function
  @\placeholder{floating-point-type}@ beta(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
  float        betaf(float x, float y);
  long double  betal(long double x, long double y);

  // \ref{sf.cmath.comp.ellint.1}, complete elliptic integral of the first kind
  @\placeholder{floating-point-type}@ comp_ellint_1(@\placeholder{floating-point-type}@ k);
  float        comp_ellint_1f(float k);
  long double  comp_ellint_1l(long double k);

  // \ref{sf.cmath.comp.ellint.2}, complete elliptic integral of the second kind
  @\placeholder{floating-point-type}@ comp_ellint_2(@\placeholder{floating-point-type}@ k);
  float        comp_ellint_2f(float k);
  long double  comp_ellint_2l(long double k);

  // \ref{sf.cmath.comp.ellint.3}, complete elliptic integral of the third kind
  @\placeholder{floating-point-type}@ comp_ellint_3(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ nu);
  float        comp_ellint_3f(float k, float nu);
  long double  comp_ellint_3l(long double k, long double nu);

  // \ref{sf.cmath.cyl.bessel.i}, regular modified cylindrical Bessel functions
  @\placeholder{floating-point-type}@ cyl_bessel_i(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
  float        cyl_bessel_if(float nu, float x);
  long double  cyl_bessel_il(long double nu, long double x);

  // \ref{sf.cmath.cyl.bessel.j}, cylindrical Bessel functions of the first kind
  @\placeholder{floating-point-type}@ cyl_bessel_j(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
  float        cyl_bessel_jf(float nu, float x);
  long double  cyl_bessel_jl(long double nu, long double x);

  // \ref{sf.cmath.cyl.bessel.k}, irregular modified cylindrical Bessel functions
  @\placeholder{floating-point-type}@ cyl_bessel_k(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
  float        cyl_bessel_kf(float nu, float x);
  long double  cyl_bessel_kl(long double nu, long double x);

  // \ref{sf.cmath.cyl.neumann}, cylindrical Neumann functions
  // cylindrical Bessel functions of the second kind
  @\placeholder{floating-point-type}@       cyl_neumann(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
  float        cyl_neumannf(float nu, float x);
  long double  cyl_neumannl(long double nu, long double x);

  // \ref{sf.cmath.ellint.1}, incomplete elliptic integral of the first kind
  @\placeholder{floating-point-type}@ ellint_1(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ phi);
  float        ellint_1f(float k, float phi);
  long double  ellint_1l(long double k, long double phi);

  // \ref{sf.cmath.ellint.2}, incomplete elliptic integral of the second kind
  @\placeholder{floating-point-type}@ ellint_2(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ phi);
  float        ellint_2f(float k, float phi);
  long double  ellint_2l(long double k, long double phi);

  // \ref{sf.cmath.ellint.3}, incomplete elliptic integral of the third kind
  @\placeholder{floating-point-type}@ ellint_3(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ nu,
                                 @\placeholder{floating-point-type}@ phi);
  float        ellint_3f(float k, float nu, float phi);
  long double  ellint_3l(long double k, long double nu, long double phi);

  // \ref{sf.cmath.expint}, exponential integral
  @\placeholder{floating-point-type}@ expint(@\placeholder{floating-point-type}@ x);
  float        expintf(float x);
  long double  expintl(long double x);

  // \ref{sf.cmath.hermite}, Hermite polynomials
  @\placeholder{floating-point-type}@ hermite(unsigned n, @\placeholder{floating-point-type}@ x);
  float        hermitef(unsigned n, float x);
  long double  hermitel(unsigned n, long double x);

  // \ref{sf.cmath.laguerre}, Laguerre polynomials
  @\placeholder{floating-point-type}@ laguerre(unsigned n, @\placeholder{floating-point-type}@ x);
  float        laguerref(unsigned n, float x);
  long double  laguerrel(unsigned n, long double x);

  // \ref{sf.cmath.legendre}, Legendre polynomials
  @\placeholder{floating-point-type}@ legendre(unsigned l, @\placeholder{floating-point-type}@ x);
  float        legendref(unsigned l, float x);
  long double  legendrel(unsigned l, long double x);

  // \ref{sf.cmath.riemann.zeta}, Riemann zeta function
  @\placeholder{floating-point-type}@ riemann_zeta(@\placeholder{floating-point-type}@ x);
  float        riemann_zetaf(float x);
  long double  riemann_zetal(long double x);

  // \ref{sf.cmath.sph.bessel}, spherical Bessel functions of the first kind
  @\placeholder{floating-point-type}@ sph_bessel(unsigned n, @\placeholder{floating-point-type}@ x);
  float        sph_besself(unsigned n, float x);
  long double  sph_bessell(unsigned n, long double x);

  // \ref{sf.cmath.sph.legendre}, spherical associated Legendre functions
  @\placeholder{floating-point-type}@ sph_legendre(unsigned l, unsigned m, @\placeholder{floating-point-type}@ theta);
  float        sph_legendref(unsigned l, unsigned m, float theta);
  long double  sph_legendrel(unsigned l, unsigned m, long double theta);

  // \ref{sf.cmath.sph.neumann}, spherical Neumann functions;
  // spherical Bessel functions of the second kind
  @\placeholder{floating-point-type}@ sph_neumann(unsigned n, @\placeholder{floating-point-type}@ x);
  float        sph_neumannf(unsigned n, float x);
  long double  sph_neumannl(unsigned n, long double x);
}
\end{codeblock}

\pnum
The contents and meaning of the header \libheader{cmath}
are the same as the C standard library header \libheader{math.h},
with the addition of
a three-dimensional hypotenuse function\iref{c.math.hypot3},
a linear interpolation function\iref{c.math.lerp}, and
the mathematical special functions described in \ref{sf.cmath}.
\begin{note}
Several functions have additional overloads in this document,
but they have the same behavior as in the C standard library\iref{library.c}.
\end{note}

\pnum
For each function
with at least one parameter of type \placeholder{floating-point-type},
the implementation provides
an overload for each cv-unqualified floating-point type\iref{basic.fundamental}
where all uses of \placeholder{floating-point-type} in the function signature
are replaced with that floating-point type.

\pnum
For each function
with at least one parameter of type \placeholder{floating-point-type}
other than \tcode{abs},
the implementation also provides additional overloads sufficient to ensure that,
if every argument corresponding to
a \placeholder{floating-point-type} parameter has arithmetic type,
then every such argument is effectively cast to the floating-point type
with the greatest floating-point conversion rank and
greatest floating-point conversion subrank
among the types of all such arguments,
where arguments of integer type are considered to have
the same floating-point conversion rank as \tcode{double}.
If no such floating-point type with the greatest rank and subrank exists,
then overload resolution does not result in
a usable candidate\iref{over.match.general}
from the overloads provided by the implementation.

\pnum
An invocation of \tcode{nexttoward} is ill-formed if
the argument corresponding to the \placeholder{floating-point-type} parameter
has extended floating-point type.

\xrefc{7.12}

\rSec2[c.math.abs]{Absolute values}

\pnum
\begin{note}
The headers \libheaderref{cstdlib} and
\libheaderref{cmath}
declare the functions described in this subclause.
\end{note}

\indexlibraryglobal{abs}%
\begin{itemdecl}
constexpr int abs(int j);
constexpr long int abs(long int j);
constexpr long long int abs(long long int j);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These
functions have the semantics specified in the C standard library
for the functions \tcode{abs}, \tcode{labs}, and \tcode{llabs}, respectively.

\pnum
\remarks
If \tcode{abs} is called with an argument of type \tcode{X}
for which \tcode{is_unsigned_v<X>} is \tcode{true} and
if \tcode{X} cannot be converted to \tcode{int}
by integral promotion\iref{conv.prom}, the program is ill-formed.
\begin{note}
Arguments that can be promoted to \tcode{int} are permitted for compatibility with C.
\end{note}
\end{itemdescr}

\begin{itemdecl}
constexpr @\placeholder{floating-point-type}@ abs(@\placeholder{floating-point-type}@ x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The absolute value of \tcode{x}.
\end{itemdescr}

\xrefc{7.12.7.2, 7.22.6.1}

\rSec2[c.math.hypot3]{Three-dimensional hypotenuse}

\indexlibrary{\idxcode{hypot}!3-argument form}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ hypot(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y, @\placeholder{floating-point-type}@ z);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
$\sqrt{x^2+y^2+z^2}$.
\end{itemdescr}

\rSec2[c.math.lerp]{Linear interpolation}

\indexlibraryglobal{lerp}%
\begin{itemdecl}
constexpr @\placeholder{floating-point-type}@ lerp(@\placeholder{floating-point-type}@ a, @\placeholder{floating-point-type}@ b,
                                   @\placeholder{floating-point-type}@ t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
$a+t(b-a)$.

\pnum
\remarks
Let \tcode{r} be the value returned.
If \tcode{isfinite(a) \&\& isfinite(b)}, then:
\begin{itemize}
\item If \tcode{t == 0}, then \tcode{r == a}.
\item If \tcode{t == 1}, then \tcode{r == b}.
\item If \tcode{t >= 0 \&\& t <= 1}, then \tcode{isfinite(r)}.
\item If \tcode{isfinite(t) \&\& a == b}, then \tcode{r == a}.
\item If \tcode{isfinite(t) || !isnan(t) \&\& b-a != 0}, then \tcode{!isnan(r)}.
\end{itemize}
Let \tcode{\placeholder{CMP}(x,y)} be \tcode{1} if \tcode{x > y},
\tcode{-1} if \tcode{x < y}, and \tcode{0} otherwise.
For any \tcode{t1} and \tcode{t2}, the product of
\tcode{\placeholder{CMP}(lerp(a, b, t2), lerp(a, b, t1))},
\tcode{\placeholder{CMP}(t2, t1)}, and
\tcode{\placeholder{CMP}(b, a)}
is non-negative.
\end{itemdescr}

\rSec2[c.math.fpclass]{Classification / comparison functions}

\pnum
The classification / comparison functions behave the same as the C macros with the
corresponding names defined in the C standard library.

\xrefc{7.12.3, 7.12.4}

\rSec2[sf.cmath]{Mathematical special functions}%

\rSec3[sf.cmath.general]{General}%
\indextext{mathematical special functions|(}%

\pnum
\indextext{NaN}\indextext{domain error}%
If any argument value
to any of the functions specified in \ref{sf.cmath}
is a NaN (Not a Number),
the function shall return a NaN
but it shall not report a domain error.
Otherwise,
the function shall report a domain error
for just those argument values
for which:
\begin{itemize}
  \item
  the function description's \returns element
  explicitly specifies a domain
  and those argument values fall
  outside the specified domain,
  or

  \item
  the corresponding mathematical function value
  has a nonzero imaginary component,
  or

  \item
  the corresponding mathematical function
  is not mathematically defined.
\begin{footnote}
    A mathematical function
    is mathematically defined
    for a given set of argument values
    (a)
      if it is explicitly defined
      for that set of argument values,
      or
    (b)
      if its limiting value exists
      and does not depend
      on the direction of approach.
\end{footnote}
\end{itemize}

\pnum
Unless otherwise specified,
each function is defined
for all finite values,
for negative infinity,
and for positive infinity.

\rSec3[sf.cmath.assoc.laguerre]{Associated Laguerre polynomials}%
\indexlibraryglobal{assoc_laguerre}%
\indexlibraryglobal{assoc_laguerref}%
\indexlibraryglobal{assoc_laguerrel}%
\indextext{Laguerre polynomials!$\mathsf{L}_n^m$}%
\indextext{L nm@$\mathsf{L}_n^m$ (associated Laguerre polynomials)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ assoc_laguerre(unsigned n, unsigned m, @\placeholder{floating-point-type}@ x);
float        assoc_laguerref(unsigned n, unsigned m, float x);
long double  assoc_laguerrel(unsigned n, unsigned m, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the associated Laguerre polynomials
of their respective arguments
\tcode{n}, \tcode{m}, and \tcode{x}.

\pnum
\returns
\[ \mathsf{L}_n^m(x) =
   (-1)^m \frac{\mathsf{d} ^ m}{\mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)
   \text{ ,\quad for $x \ge 0$,} \]
where
$n$ is \tcode{n},
$m$ is \tcode{m}, and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling associated Laguerre polynomials with \tcode{n >= 128} or \tcode{m >= 128}}
if \tcode{n >= 128} or if \tcode{m >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.assoc.legendre]{Associated Legendre functions}%
\indexlibraryglobal{assoc_legendre}%
\indexlibraryglobal{assoc_legendref}%
\indexlibraryglobal{assoc_legendrel}%
\indextext{Legendre polynomials!$\mathsf{P}_\ell^m$}%
\indextext{P lm@$\mathsf{P}_\ell^m$ (associated Legendre polynomials)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ assoc_legendre(unsigned l, unsigned m, @\placeholder{floating-point-type}@ x);
float        assoc_legendref(unsigned l, unsigned m, float x);
long double  assoc_legendrel(unsigned l, unsigned m, long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute
the associated Legendre functions
of their respective arguments
\tcode{l}, \tcode{m}, and \tcode{x}.

\pnum
\returns
\[ \mathsf{P}_\ell^m(x) = (1 - x^2) ^ {m/2} \:
   \frac{\mathsf{d} ^ m}{\mathsf{d}x ^ m} \, \mathsf{P}_\ell(x)
   \text{ ,\quad for $|x| \le 1$,} \]
where
$l$ is \tcode{l},
$m$ is \tcode{m}, and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling associated Legendre polynomials with \tcode{l >= 128}}
if \tcode{l >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.beta]{Beta function}%
\indexlibraryglobal{beta}%
\indexlibraryglobal{betaf}%
\indexlibraryglobal{betal}%
\indextext{Eulerian integral of the first kind|see{beta functions $\mathsf{B}$}}%
\indextext{beta functions $\mathsf{B}$}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ beta(@\placeholder{floating-point-type}@ x, @\placeholder{floating-point-type}@ y);
float        betaf(float x, float y);
long double  betal(long double x, long double y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the beta function
of their respective arguments
\tcode{x} and \tcode{y}.

\pnum
\returns
\[ \mathsf{B}(x, y) = \frac{\Gamma(x) \, \Gamma(y)}{\Gamma(x + y)}
   \text{ ,\quad for $x > 0$,\, $y > 0$,} \]
where
$x$ is \tcode{x} and
$y$ is \tcode{y}.
\end{itemdescr}

\rSec3[sf.cmath.comp.ellint.1]{Complete elliptic integral of the first kind}%
\indexlibraryglobal{comp_ellint_1}%
\indexlibraryglobal{comp_ellint_1f}%
\indexlibraryglobal{comp_ellint_1l}%
\indextext{elliptic integrals!complete $\mathsf{K}$}%
\indextext{K complete@$\mathsf{K}$ (complete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ comp_ellint_1(@\placeholder{floating-point-type}@ k);
float        comp_ellint_1f(float k);
long double  comp_ellint_1l(long double k);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the complete elliptic integral of the first kind
of their respective arguments
\tcode{k}.

\pnum
\returns
\[ \mathsf{K}(k) = \mathsf{F}(k, \pi / 2) \text{ ,\quad for $|k| \le 1$,} \]
where
$k$ is \tcode{k}.

\pnum
See also \ref{sf.cmath.ellint.1}.
\end{itemdescr}

\rSec3[sf.cmath.comp.ellint.2]{Complete elliptic integral of the second kind}%
\indexlibraryglobal{comp_ellint_2}%
\indexlibraryglobal{comp_ellint_2f}%
\indexlibraryglobal{comp_ellint_2l}%
\indextext{elliptic integrals!complete $\mathsf{E}$}%
\indextext{E complete@$\mathsf{E}$ (complete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ comp_ellint_2(@\placeholder{floating-point-type}@ k);
float        comp_ellint_2f(float k);
long double  comp_ellint_2l(long double k);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the complete elliptic integral of the second kind
of their respective arguments
\tcode{k}.

\pnum
\returns
\[ \mathsf{E}(k) = \mathsf{E}(k, \pi / 2) \text{ ,\quad for $|k| \le 1$,} \]
where
$k$ is \tcode{k}.

\pnum
See also \ref{sf.cmath.ellint.2}.
\end{itemdescr}

\rSec3[sf.cmath.comp.ellint.3]{Complete elliptic integral of the third kind}%
\indexlibraryglobal{comp_ellint_3}%
\indexlibraryglobal{comp_ellint_3f}%
\indexlibraryglobal{comp_ellint_3l}%
\indextext{elliptic integrals!complete $\mathsf{\Pi}$}%
\indextext{Pi complete@$\mathsf{\Pi}$ (complete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ comp_ellint_3(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ nu);
float        comp_ellint_3f(float k, float nu);
long double  comp_ellint_3l(long double k, long double nu);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the complete elliptic integral of the third kind
of their respective arguments
\tcode{k} and \tcode{nu}.

\pnum
\returns
\[ \mathsf{\Pi}(\nu, k) = \mathsf{\Pi}(\nu, k, \pi / 2) \text{ ,\quad for $|k| \le 1$,} \]
where
$k$ is \tcode{k} and
$\nu$ is \tcode{nu}.

\pnum
See also \ref{sf.cmath.ellint.3}.
\end{itemdescr}

\rSec3[sf.cmath.cyl.bessel.i]{Regular modified cylindrical Bessel functions}%
\indexlibraryglobal{cyl_bessel_i}%
\indexlibraryglobal{cyl_bessel_if}%
\indexlibraryglobal{cyl_bessel_il}%
\indextext{Bessel functions!$\mathsf{I}_\nu$}%
\indextext{I nu@$\mathsf{I}_\nu$ (Bessell functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ cyl_bessel_i(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
float        cyl_bessel_if(float nu, float x);
long double  cyl_bessel_il(long double nu, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the regular modified cylindrical Bessel functions
of their respective arguments
\tcode{nu} and \tcode{x}.

\pnum
\returns
\[ \mathsf{I}_\nu(x) =
     \mathrm{i}^{-\nu} \mathsf{J}_\nu(\mathrm{i}x) =
     \sum_{k=0}^\infty \frac{(x/2)^{\nu+2k}}{k! \: \Gamma(\nu+k+1)}
     \text{ ,\quad for $x \ge 0$,} \]
where
$\nu$ is \tcode{nu} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling regular modified cylindrical Bessel functions with \tcode{nu >= 128}}
if \tcode{nu >= 128}.

\pnum
See also \ref{sf.cmath.cyl.bessel.j}.
\end{itemdescr}

\rSec3[sf.cmath.cyl.bessel.j]{Cylindrical Bessel functions of the first kind}%
\indexlibraryglobal{cyl_bessel_j}%
\indexlibraryglobal{cyl_bessel_jf}%
\indexlibraryglobal{cyl_bessel_jl}%
\indextext{Bessel functions!$\mathsf{J}_\nu$}%
\indextext{J nu@$\mathsf{J}_\nu$ (Bessell functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ cyl_bessel_j(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
float        cyl_bessel_jf(float nu, float x);
long double  cyl_bessel_jl(long double nu, long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute
the cylindrical Bessel functions of the first kind
of their respective arguments
\tcode{nu} and \tcode{x}.

\pnum
\returns
\[ \mathsf{J}_\nu(x) =
   \sum_{k=0}^\infty \frac{(-1)^k (x/2)^{\nu+2k}}{k! \: \Gamma(\nu+k+1)}
   \text{ ,\quad for $x \ge 0$,} \]
where
$\nu$ is \tcode{nu} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling cylindrical Bessel functions of the first kind with \tcode{nu >= 128}}
if \tcode{nu >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.cyl.bessel.k]{Irregular modified cylindrical Bessel functions}%
\indexlibraryglobal{cyl_bessel_k}%
\indexlibraryglobal{cyl_bessel_kf}%
\indexlibraryglobal{cyl_bessel_kl}%
\indextext{Bessel functions!$\mathsf{K}_\nu$}%
\indextext{K nu@$\mathsf{K}_\nu$ (Bessell functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ cyl_bessel_k(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
float        cyl_bessel_kf(float nu, float x);
long double  cyl_bessel_kl(long double nu, long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute
the irregular modified cylindrical Bessel functions
of their respective arguments
\tcode{nu} and \tcode{x}.

\pnum
\returns
\[%
  \mathsf{K}_\nu(x) =
  (\pi/2)\mathrm{i}^{\nu+1} (            \mathsf{J}_\nu(\mathrm{i}x)
			    + \mathrm{i} \mathsf{N}_\nu(\mathrm{i}x)
			    )
  =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\pi}{2}
  \frac{\mathsf{I}_{-\nu}(x) - \mathsf{I}_{\nu}(x)}
       {\sin \nu\pi },
  & \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \frac{\pi}{2}
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{I}_{-\mu}(x) - \mathsf{I}_{\mu}(x)}
                                  {\sin \mu\pi },
  & \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]
where
$\nu$ is \tcode{nu} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling irregular modified cylindrical Bessel functions with \tcode{nu >= 128}}
if \tcode{nu >= 128}.

\pnum
See also \ref{sf.cmath.cyl.bessel.i}, \ref{sf.cmath.cyl.bessel.j}, \ref{sf.cmath.cyl.neumann}.
\end{itemdescr}

\rSec3[sf.cmath.cyl.neumann]{Cylindrical Neumann functions}%
\indexlibraryglobal{cyl_neumann}%
\indexlibraryglobal{cyl_neumannf}%
\indexlibraryglobal{cyl_neumannl}%
\indextext{Bessel functions!$\mathsf{N}_\nu$}%
\indextext{Neumann functions!$\mathsf{N}_\nu$}%
\indextext{N nu@$\mathsf{N}_\nu$ (Neumann functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ cyl_neumann(@\placeholder{floating-point-type}@ nu, @\placeholder{floating-point-type}@ x);
float        cyl_neumannf(float nu, float x);
long double  cyl_neumannl(long double nu, long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute the cylindrical Neumann functions,
also known as the cylindrical Bessel functions of the second kind,
of their respective arguments
\tcode{nu} and \tcode{x}.

\pnum
\returns
\[%
  \mathsf{N}_\nu(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \frac{\mathsf{J}_\nu(x) \cos \nu\pi - \mathsf{J}_{-\nu}(x)}
       {\sin \nu\pi },
  & \mbox{for $x \ge 0$ and non-integral $\nu$}
  \\
  \\
  \displaystyle
  \lim_{\mu \rightarrow \nu} \frac{\mathsf{J}_\mu(x) \cos \mu\pi - \mathsf{J}_{-\mu}(x)}
                                {\sin \mu\pi },
  & \mbox{for $x \ge 0$ and integral $\nu$}
  \end{array}
  \right.
\]
where
$\nu$ is \tcode{nu} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling cylindrical Neumann functions with \tcode{nu >= 128}}
if \tcode{nu >= 128}.

\pnum
See also \ref{sf.cmath.cyl.bessel.j}.
\end{itemdescr}

\rSec3[sf.cmath.ellint.1]{Incomplete elliptic integral of the first kind}%
\indexlibraryglobal{ellint_1}%
\indexlibraryglobal{ellint_1f}%
\indexlibraryglobal{ellint_1l}%
\indextext{elliptic integrals!incomplete $\mathsf{F}$}%
\indextext{F incomplete@$\mathsf{F}$ (incomplete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ ellint_1(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ phi);
float        ellint_1f(float k, float phi);
long double  ellint_1l(long double k, long double phi);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the incomplete elliptic integral of the first kind
of their respective arguments
\tcode{k} and \tcode{phi} (\tcode{phi} measured in radians).

\pnum
\returns
\[ \mathsf{F}(k, \phi) =
     \int_0^\phi \! \frac{\mathsf{d}\theta}{\sqrt{1 - k^2 \sin^2 \theta}}
     \text{ ,\quad for $|k| \le 1$,} \]
where
$k$ is \tcode{k} and
$\phi$ is \tcode{phi}.
\end{itemdescr}

\rSec3[sf.cmath.ellint.2]{Incomplete elliptic integral of the second kind}%
\indexlibraryglobal{ellint_2}%
\indexlibraryglobal{ellint_2f}%
\indexlibraryglobal{ellint_2l}%
\indextext{elliptic integrals!incomplete $\mathsf{E}$}%
\indextext{E incomplete@$\mathsf{E}$ (incomplete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ ellint_2(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ phi);
float        ellint_2f(float k, float phi);
long double  ellint_2l(long double k, long double phi);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the incomplete elliptic integral of the second kind
of their respective arguments
\tcode{k} and \tcode{phi} (\tcode{phi} measured in radians).

\pnum
\returns
\[ \mathsf{E}(k, \phi) = \int_0^\phi \! \sqrt{1 - k^2 \sin^2 \theta} \, \mathsf{d}\theta
   \text{ ,\quad for $|k| \le 1$,} \]
where
$k$ is \tcode{k} and
$\phi$ is \tcode{phi}.
\end{itemdescr}

\rSec3[sf.cmath.ellint.3]{Incomplete elliptic integral of the third kind}%
\indexlibraryglobal{ellint_3}%
\indexlibraryglobal{ellint_3f}%
\indexlibraryglobal{ellint_3l}%
\indextext{elliptic integrals!incomplete $\mathsf{\Pi}$}%
\indextext{Pi incomplete@$\mathsf{\Pi}$ (incomplete elliptic integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ ellint_3(@\placeholder{floating-point-type}@ k, @\placeholder{floating-point-type}@ nu,
                             @\placeholder{floating-point-type}@ phi);
float        ellint_3f(float k, float nu, float phi);
long double  ellint_3l(long double k, long double nu, long double phi);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute
the incomplete elliptic integral of the third kind
of their respective arguments
\tcode{k}, \tcode{nu}, and \tcode{phi} (\tcode{phi} measured in radians).

\pnum
\returns
\[ \mathsf{\Pi}(\nu, k, \phi) = \int_0^\phi \!
   \frac{ \mathsf{d}\theta }{ (1 - \nu \, \sin^2 \theta) \sqrt{1 - k^2 \sin^2 \theta} } \text{ ,\quad for $|k| \le 1$,} \]
where
$\nu$ is \tcode{nu},
$k$ is \tcode{k}, and
$\phi$ is \tcode{phi}.
\end{itemdescr}

\rSec3[sf.cmath.expint]{Exponential integral}%
\indexlibraryglobal{expint}%
\indexlibraryglobal{expintf}%
\indexlibraryglobal{expintl}%
\indextext{exponential integrals $\mathsf{Ei}$}%
\indextext{Ei@$\mathsf{Ei}$ (exponential integrals)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ expint(@\placeholder{floating-point-type}@ x);
float        expintf(float x);
long double  expintl(long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute the exponential integral
of their respective arguments
\tcode{x}.

\pnum
\returns
\[%
  \mathsf{Ei}(x) =
  - \int_{-x}^\infty \frac{e^{-t}}
                          {t     } \, \mathsf{d}t
\;
\]
where
$x$ is \tcode{x}.

\end{itemdescr}

\rSec3[sf.cmath.hermite]{Hermite polynomials}%
\indexlibraryglobal{hermite}%
\indexlibraryglobal{hermitef}%
\indexlibraryglobal{hermitel}%
\indextext{Hermite polynomials $\mathsf{H}_n$}%
\indextext{H n@$\mathsf{H}_n$ (Hermite polynomials)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ hermite(unsigned n, @\placeholder{floating-point-type}@ x);
float        hermitef(unsigned n, float x);
long double  hermitel(unsigned n, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute the Hermite polynomials
of their respective arguments
\tcode{n} and \tcode{x}.

\pnum
\returns
\[%
  \mathsf{H}_n(x) =
  (-1)^n e^{x^2} \frac{ \mathsf{d} ^n}
		      { \mathsf{d}x^n} \, e^{-x^2}
\;
\]
where
$n$ is \tcode{n} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling Hermite polynomials with \tcode{n >= 128}}
if \tcode{n >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.laguerre]{Laguerre polynomials}%
\indexlibraryglobal{laguerre}%
\indexlibraryglobal{laguerref}%
\indexlibraryglobal{laguerrel}%
\indextext{Laguerre polynomials!$\mathsf{L}_n$}%
\indextext{L n@$\mathsf{L}_n$ (Laguerre polynomials)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ laguerre(unsigned n, @\placeholder{floating-point-type}@ x);
float        laguerref(unsigned n, float x);
long double  laguerrel(unsigned n, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute the Laguerre polynomials
of their respective arguments
\tcode{n} and \tcode{x}.

\pnum
\returns
\[ \mathsf{L}_n(x) =
     \frac{e^x}{n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} \, (x^n e^{-x})
     \text{ ,\quad for $x \ge 0$,} \]
where
$n$ is \tcode{n} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling Laguerre polynomials with \tcode{n >= 128}}
if \tcode{n >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.legendre]{Legendre polynomials}%
\indexlibraryglobal{legendre}%
\indexlibraryglobal{legendref}%
\indexlibraryglobal{legendrel}%
\indextext{Legendre polynomials!$\mathsf{P}_\ell$}%
\indextext{P l@$\mathsf{P}_\ell$ (Legendre polynomials)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ legendre(unsigned l, @\placeholder{floating-point-type}@ x);
float        legendref(unsigned l, float x);
long double  legendrel(unsigned l, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute the Legendre polynomials of their
respective arguments
\tcode{l} and \tcode{x}.

\pnum
\returns
\[ \mathsf{P}_\ell(x) =
     \frac{1}{2^\ell \, \ell!}
     \frac{\mathsf{d}^\ell}{\mathsf{d}x^\ell} \, (x^2 - 1) ^ \ell
     \text{ ,\quad for $|x| \le 1$,} \]
where
$l$ is \tcode{l} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling Legendre polynomials with \tcode{l >= 128}}
if \tcode{l >= 128}.
\end{itemdescr}

\rSec3[sf.cmath.riemann.zeta]{Riemann zeta function}%
\indexlibraryglobal{riemann_zeta}%
\indexlibraryglobal{riemann_zetaf}%
\indexlibraryglobal{riemann_zetal}%
\indextext{zeta functions $\zeta$}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ riemann_zeta(@\placeholder{floating-point-type}@ x);
float        riemann_zetaf(float x);
long double  riemann_zetal(long double x);
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
These functions compute the Riemann zeta function
of their respective arguments
\tcode{x}.

\pnum
\returns
\[%
  \mathsf{\zeta}(x) =
  \left\{
  \begin{array}{cl}
  \displaystyle
  \sum_{k=1}^\infty k^{-x},
  & \mbox{for $x > 1$}
  \\
  \\
  \displaystyle
  \frac{1}
	{1 - 2^{1-x}}
  \sum_{k=1}^\infty (-1)^{k-1} k^{-x},
  & \mbox{for $0 \le x \le 1$}
  \\
  \\
  \displaystyle
  2^x \pi^{x-1} \sin(\frac{\pi x}{2}) \, \Gamma(1-x) \, \zeta(1-x),
  & \mbox{for $x < 0$}
  \end{array}
  \right.
\;
\]
where
$x$ is \tcode{x}.
\end{itemdescr}

\rSec3[sf.cmath.sph.bessel]{Spherical Bessel functions of the first kind}%
\indexlibraryglobal{sph_bessel}%
\indexlibraryglobal{sph_besself}%
\indexlibraryglobal{sph_bessell}%
\indextext{Bessel functions!$\mathsf{j}_n$}%
\indextext{j n@$\mathsf{j}_n$ (spherical Bessel functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ sph_bessel(unsigned n, @\placeholder{floating-point-type}@ x);
float        sph_besself(unsigned n, float x);
long double  sph_bessell(unsigned n, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute
the spherical Bessel functions of the first kind
of their respective arguments
\tcode{n} and \tcode{x}.

\pnum
\returns
\[ \mathsf{j}_n(x) = (\pi/2x)^{1\!/\!2} \mathsf{J}_{n + 1\!/\!2}(x) \text{ ,\quad for $x \ge 0$,} \]
where
$n$ is \tcode{n} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling spherical Bessel functions with \tcode{n >= 128}}
if \tcode{n >= 128}.

\pnum
See also \ref{sf.cmath.cyl.bessel.j}.
\end{itemdescr}

\rSec3[sf.cmath.sph.legendre]{Spherical associated Legendre functions}%
\indexlibraryglobal{sph_legendre}%
\indexlibraryglobal{sph_legendref}%
\indexlibraryglobal{sph_legendrel}%
\indextext{spherical harmonics $\mathsf{Y}_\ell^m$}%
\indextext{Legendre functions $\mathsf{Y}_\ell^m$}%
\indextext{Y lm@$\mathsf{Y}_\ell^m$ (spherical associated Legendre functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ sph_legendre(unsigned l, unsigned m, @\placeholder{floating-point-type}@ theta);
float        sph_legendref(unsigned l, unsigned m, float theta);
long double  sph_legendrel(unsigned l, unsigned m, long double theta);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute the spherical associated Legendre functions
of their respective arguments
\tcode{l}, \tcode{m}, and \tcode{theta} (\tcode{theta} measured in radians).

\pnum
\returns
\[ \mathsf{Y}_\ell^m(\theta, 0) \]
where
\[ \mathsf{Y}_\ell^m(\theta, \phi) =
     (-1)^m \left[\frac{(2 \ell + 1)}{4 \pi} \frac{(\ell - m)!}{(\ell + m)!}\right]^{1/2}
     \mathsf{P}_\ell^m (\cos\theta) e^{i m \phi}
     \text{ ,\quad for $|m| \le \ell$,}
\]
and
$l$ is \tcode{l},
$m$ is \tcode{m}, and
$\theta$ is \tcode{theta}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling spherical associated Legendre functions with \tcode{l >= 128}}
if \tcode{l >= 128}.

\pnum
See also \ref{sf.cmath.assoc.legendre}.
\end{itemdescr}

\rSec3[sf.cmath.sph.neumann]{Spherical Neumann functions}%
\indexlibraryglobal{sph_neumann}%
\indexlibraryglobal{sph_neumannf}%
\indexlibraryglobal{sph_neumannl}%
\indextext{Bessel functions!$\mathsf{n}_n$}%
\indextext{Neumann functions!$\mathsf{n}_n$}%
\indextext{n n spherical@$\mathsf{n}_n$ (spherical Neumann functions)}%
\begin{itemdecl}
@\placeholder{floating-point-type}@ sph_neumann(unsigned n, @\placeholder{floating-point-type}@ x);
float        sph_neumannf(unsigned n, float x);
long double  sph_neumannl(unsigned n, long double x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions compute the spherical Neumann functions,
also known as the spherical Bessel functions of the second kind,
of their respective arguments
\tcode{n} and \tcode{x}.

\pnum
\returns
\[ \mathsf{n}_n(x) = (\pi/2x)^{1\!/\!2} \mathsf{N}_{n + 1\!/\!2}(x)
   \text{ ,\quad for $x \ge 0$,} \]
where
$n$ is \tcode{n} and
$x$ is \tcode{x}.

\pnum
\remarks
The effect of calling each of these functions
is \impldef{effect of calling spherical Neumann functions with \tcode{n >= 128}}
if \tcode{n >= 128}.

\pnum
See also \ref{sf.cmath.cyl.neumann}.
\end{itemdescr}

\indextext{mathematical special functions|)}

\rSec1[numbers]{Numbers}

\rSec2[numbers.syn]{Header \tcode{<numbers>} synopsis}

\indexheader{numbers}%
\begin{codeblock}
namespace std::numbers {
  template<class T> constexpr T e_v          = @\unspec@;
  template<class T> constexpr T log2e_v      = @\unspec@;
  template<class T> constexpr T log10e_v     = @\unspec@;
  template<class T> constexpr T pi_v         = @\unspec@;
  template<class T> constexpr T inv_pi_v     = @\unspec@;
  template<class T> constexpr T inv_sqrtpi_v = @\unspec@;
  template<class T> constexpr T ln2_v        = @\unspec@;
  template<class T> constexpr T ln10_v       = @\unspec@;
  template<class T> constexpr T sqrt2_v      = @\unspec@;
  template<class T> constexpr T sqrt3_v      = @\unspec@;
  template<class T> constexpr T inv_sqrt3_v  = @\unspec@;
  template<class T> constexpr T egamma_v     = @\unspec@;
  template<class T> constexpr T phi_v        = @\unspec@;

  template<@\libconcept{floating_point}@ T> constexpr T e_v<T>          = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T log2e_v<T>      = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T log10e_v<T>     = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T pi_v<T>         = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T inv_pi_v<T>     = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T inv_sqrtpi_v<T> = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T ln2_v<T>        = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T ln10_v<T>       = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T sqrt2_v<T>      = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T sqrt3_v<T>      = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T inv_sqrt3_v<T>  = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T egamma_v<T>     = @\seebelow@;
  template<@\libconcept{floating_point}@ T> constexpr T phi_v<T>        = @\seebelow@;

  inline constexpr double e          = e_v<double>;
  inline constexpr double log2e      = log2e_v<double>;
  inline constexpr double log10e     = log10e_v<double>;
  inline constexpr double pi         = pi_v<double>;
  inline constexpr double inv_pi     = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2        = ln2_v<double>;
  inline constexpr double ln10       = ln10_v<double>;
  inline constexpr double sqrt2      = sqrt2_v<double>;
  inline constexpr double sqrt3      = sqrt3_v<double>;
  inline constexpr double inv_sqrt3  = inv_sqrt3_v<double>;
  inline constexpr double egamma     = egamma_v<double>;
  inline constexpr double phi        = phi_v<double>;
}
\end{codeblock}

\rSec2[math.constants]{Mathematical constants}

\pnum
The library-defined partial specializations
of mathematical constant variable templates
are initialized with the nearest representable values of
$\mathrm{e}$,
$\log_{2} \mathrm{e}$,
$\log_{10} \mathrm{e}$,
$\pi$,
$\frac{1}{\pi}$,
$\frac{1}{\sqrt{\pi}}$,
$\ln 2$,
$\ln 10$,
$\sqrt{2}$,
$\sqrt{3}$,
$\frac{1}{\sqrt{3}}$,
the Euler-Mascheroni $\gamma$ constant, and
the golden ratio $\phi$ constant $\frac{1+\sqrt{5}}{2}$,
respectively.

\pnum
Pursuant to \ref{namespace.std},
a program may partially or explicitly specialize
a mathematical constant variable template
provided that the specialization depends on a program-defined type.

\pnum
A program that instantiates a primary template
of a mathematical constant variable template is ill-formed.
