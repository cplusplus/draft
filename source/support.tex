\rSec0[language.support]{Language support library}

\rSec1[support.general]{General}

\pnum
This Clause describes the function signatures that are called
implicitly, and the types of objects generated implicitly, during the execution
of some \Cpp programs.
It also describes the headers that declare these function
signatures and define any related types.

\pnum
The following subclauses describe
common type definitions used throughout the library,
characteristics of the predefined types,
functions supporting start and termination of a \Cpp program,
support for dynamic memory management,
support for dynamic type identification,
support for exception processing, support for initializer lists,
and other runtime support,
as summarized in Table~\ref{tab:lang.sup.lib.summary}.

\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
\ref{support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
                          &                           &   \tcode{<limits>}    \\
\ref{support.limits}      & Implementation properties &   \tcode{<climits>}   \\
                          &                           &   \tcode{<cfloat>}    \\ \rowsep
\ref{cstdint}             & Integer types             & \tcode{<cstdint>}     \\ \rowsep
\ref{support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
\ref{support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
\ref{support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
\ref{support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
\ref{support.initlist}    & Initializer lists & \tcode{<initializer_list>}    \\ \rowsep
                          &                           &   \tcode{<csignal>}   \\
                          &                           &   \tcode{<csetjmp>}   \\
                          &                           &   \tcode{<cstdalign>} \\
\ref{support.runtime}     & Other runtime support     &   \tcode{<cstdarg>}   \\
                          &                           &   \tcode{<cstdbool>}  \\
                          &                           &   \tcode{<cstdlib>}   \\
                          &                           &   \tcode{<ctime>}     \\
\end{libsumtab}

\rSec1[support.types]{Types}

\pnum
Table~\ref{tab:support.hdr.cstddef} describes the header
\tcode{<cstddef>}.

\indexlibrary{\idxcode{NULL}}%
\indexlibrary{\idxcode{offsetof}}%
\indexlibrary{\idxcode{ptrdiff_t}}%
\indexlibrary{\idxcode{size_t}}%
\indexlibrary{\idxcode{max_align_t}}%
\indexlibrary{\idxcode{nullptr_t}}%
\begin{libsyntab3}{cstddef}{tab:support.hdr.cstddef}
\macros &   \tcode{NULL}        &   \tcode{offsetof}        \\ \rowsep
\types  &   \tcode{ptrdiff_t}   &   \tcode{size_t}          \\
        &   \tcode{max_align_t} &  \tcode{nullptr_t}        \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<stddef.h>},
with the following changes:

\pnum
The macro
\indexlibrary{\idxcode{NULL}}%
\tcode{NULL}
is an implementation-defined \Cpp null pointer constant in
\indextext{implementation-defined}%
this International Standard (\ref{conv.ptr}).\footnote{Possible definitions include
\tcode{0}
and
\tcode{0L},
but not
\tcode{(void*)0}.}

\pnum
The macro
\indexlibrary{\idxcode{offsetof}}%
\tcode{offsetof}(\textit{type},
\grammarterm{member-designator}) accepts a restricted set of \textit{type}
arguments in this International Standard. If \textit{type} is not a
standard-layout class
(Clause~\ref{class}), the results are undefined.\footnote{Note that \tcode{offsetof}
is required to work as specified even if unary
\tcode{operator\&}
is overloaded for any of the types involved.}
The expression \tcode{offsetof}(\textit{type}, \grammarterm{member-designator})
is never type-dependent~(\ref{temp.dep.expr}) and it is
value-dependent~(\ref{temp.dep.constexpr}) if and only if \textit{type} is
dependent. The result of applying the \tcode{offsetof} macro to a field that
is a static data member or a function member is undefined.
No operation invoked by the \tcode{offsetof} macro shall throw an exception and
\tcode{noexcept(offsetof(type, member-designator))} shall be \tcode{true}.

\pnum
The type \tcode{ptrdiff_t} is an
\impldef{type of \tcode{ptrdiff_t}}
signed integer type that can
hold the difference of two subscripts in an array object, as described in~\ref{expr.add}.

\pnum
The type \tcode{size_t} is an
\impldef{type of \tcode{size_t}}
unsigned integer type that is large enough
to contain the size in bytes of any object.

\pnum
\enternote
It is recommended that implementations choose types for \tcode{ptrdiff_t} and \tcode{size_t}
whose integer conversion ranks~(\ref{conv.rank}) are no greater than that of
\tcode{signed long int} unless a larger size is necessary to contain all the possible values.
\exitnote

\pnum
The type
\indexlibrary{\idxcode{max_align_t}}%
\tcode{max_align_t} is a POD type whose alignment requirement
is at least as great as that of every scalar type, and whose alignment
requirement is supported in every context.

\pnum
\indexlibrary{\idxcode{nullptr_t}}%
\tcode{nullptr_t} is defined as follows:

\begin{codeblock}
namespace std {
  typedef decltype(nullptr) nullptr_t;
}
\end{codeblock}

The type for which \tcode{nullptr_t} is a synonym has the characteristics
described in~\ref{basic.fundamental} and~\ref{conv.ptr}. \enternote Although
\tcode{nullptr}'s address cannot be taken, the address of another
\tcode{nullptr_t} object that is an lvalue can be taken. \exitnote

\xref Alignment~(\ref{basic.align}), Sizeof~(\ref{expr.sizeof}), Additive
operators~(\ref{expr.add}), Free store~(\ref{class.free}), and ISO C~7.1.6.

\rSec1[support.limits]{Implementation properties}

\rSec2[support.limits.general]{In general}

\pnum
The headers
\tcode{<limits>}~(\ref{limits}),
\tcode{<climits>}, and
\tcode{<cfloat>}~(\ref{c.limits})
supply characteristics of implementation-dependent
arithmetic types~(\ref{basic.fundamental}).

\rSec2[limits]{Numeric limits}

\rSec3[limits.numeric]{Class template \tcode{numeric_limits}}

\pnum
The
\indexlibrary{\idxcode{numeric_limits}}%
\tcode{numeric_limits}
class template provides a \Cpp program with information about various properties of
the implementation's representation of the
arithmetic types.

\pnum
Specializations shall be provided for each
arithmetic type,
both floating point and integer, including
\tcode{bool}.
The member
\tcode{is_specialized}
shall be
\tcode{true}
for all such specializations of
\tcode{numeric_limits}.

\pnum
For all members declared
\tcode{static} \tcode{constexpr}
in the
\tcode{numeric_limits}
template, specializations shall define these values in such a way
that they are usable as
constant expressions.

\pnum
Non-arithmetic standard types, such as
\tcode{complex<T>}~(\ref{complex}), shall not have specializations.

\indextext{\idxhdr{limits}}%
\indexlibrary{\idxhdr{limits}}%
\indextext{\idxcode{numeric_limits}}%
\indexlibrary{\idxcode{numeric_limits}}%
\indexlibrary{\idxcode{float_round_style}}%
\indexlibrary{\idxcode{float_denorm_style}}%
\rSec3[limits.syn]{Header \tcode{<limits>} synopsis}

\begin{codeblock}
namespace std {
  template<class T> class numeric_limits;
  enum float_round_style;
  enum float_denorm_style;

  template<> class numeric_limits<bool>;

  template<> class numeric_limits<char>;
  template<> class numeric_limits<signed char>;
  template<> class numeric_limits<unsigned char>;
  template<> class numeric_limits<char16_t>;
  template<> class numeric_limits<char32_t>;
  template<> class numeric_limits<wchar_t>;

  template<> class numeric_limits<short>;
  template<> class numeric_limits<int>;
  template<> class numeric_limits<long>;
  template<> class numeric_limits<long long>;
  template<> class numeric_limits<unsigned short>;
  template<> class numeric_limits<unsigned int>;
  template<> class numeric_limits<unsigned long>;
  template<> class numeric_limits<unsigned long long>;

  template<> class numeric_limits<float>;
  template<> class numeric_limits<double>;
  template<> class numeric_limits<long double>;
}
\end{codeblock}

\rSec3[numeric.limits]{Class template \tcode{numeric_limits}}

\indexlibrary{\idxcode{numeric\_limits}}%
\begin{codeblock}
namespace std {
  template<class T> class numeric_limits {
  public:
    static constexpr bool is_specialized = false;
    static constexpr T min() noexcept { return T(); }
    static constexpr T max() noexcept { return T(); }
    static constexpr T lowest() noexcept { return T(); }

    static constexpr int  digits = 0;
    static constexpr int  digits10 = 0;
    static constexpr int  max_digits10 = 0;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int  radix = 0;
    static constexpr T epsilon() noexcept { return T(); }
    static constexpr T round_error() noexcept { return T(); }

    static constexpr int  min_exponent = 0;
    static constexpr int  min_exponent10 = 0;
    static constexpr int  max_exponent = 0;
    static constexpr int  max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr T infinity() noexcept { return T(); }
    static constexpr T quiet_NaN() noexcept { return T(); }
    static constexpr T signaling_NaN() noexcept { return T(); }
    static constexpr T denorm_min() noexcept { return T(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template<class T> class numeric_limits<const T>;
  template<class T> class numeric_limits<volatile T>;
  template<class T> class numeric_limits<const volatile T>;
}
\end{codeblock}

\pnum
The default
\tcode{numeric_limits<T>}
template shall have all members, but with 0 or
\tcode{false}
values.

\pnum
The value of each member of a specialization of
\tcode{numeric_limits} on a \term{cv}-qualified type
\tcode{cv T} shall be equal to the value of the corresponding member of
the specialization on the unqualified type \tcode{T}.

\rSec3[numeric.limits.members]{\tcode{numeric_limits} members}

\indexlibrary{\idxcode{min}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min}}
\begin{itemdecl}
static constexpr T min() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum finite value.\footnote{Equivalent to \tcode{CHAR_MIN}, \tcode{SHRT_MIN},
\tcode{FLT_MIN}, \tcode{DBL_MIN}, etc.}

\pnum
For floating types with denormalization, returns the minimum positive
normalized value.

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false},
or
\tcode{is_bounded == false \&\& is_signed == false}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max}}
\begin{itemdecl}
static constexpr T max() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum finite value.\footnote{Equivalent to \tcode{CHAR_MAX}, \tcode{SHRT_MAX},
\tcode{FLT_MAX}, \tcode{DBL_MAX}, etc.}

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false}.
\end{itemdescr}

\indexlibrary{\idxcode{lowest}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{lowest}}
\begin{itemdecl}
static constexpr T lowest() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
A finite value \tcode{x} such that there is no other finite
value \tcode{y} where \tcode{y < x}.\footnote{\tcode{lowest()} is necessary because not all
floating-point representations have a smallest (most negative) value that is
the negative of the largest (most positive) finite value.}

\pnum
Meaningful for all specializations in which \tcode{is_bounded != false}.
\end{itemdescr}

\indexlibrary{\idxcode{digits}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{digits}}
\begin{itemdecl}
static constexpr int digits;
\end{itemdecl}

\begin{itemdescr}
\pnum
Number of
\tcode{radix}
digits that can be represented without change.

\pnum
For integer types, the number of non-sign bits in the representation.

\pnum For floating point types, the number of \tcode{radix} digits in the
mantissa.\footnote{Equivalent to \tcode{FLT_MANT_DIG}, \tcode{DBL_MANT_DIG},
\tcode{LDBL_MANT_DIG}.} \end{itemdescr}

\indexlibrary{\idxcode{digits10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{digits10}}
\begin{itemdecl}
static constexpr int digits10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Number of base 10 digits that can be represented without
change.\footnote{Equivalent to \tcode{FLT_DIG}, \tcode{DBL_DIG},
\tcode{LDBL_DIG}.}

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false}.
\end{itemdescr}

\indexlibrary{\idxcode{max_digits10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max_digits10}}
\begin{itemdecl}
static constexpr int max_digits10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Number of base 10 digits required to ensure that values which
differ are always differentiated.

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{is_signed}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_signed}}
\begin{itemdecl}
static constexpr bool is_signed;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is signed.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_integer}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_integer}}
\begin{itemdecl}
static constexpr bool is_integer;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is integer.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_exact}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_exact}}
\begin{itemdecl}
static constexpr bool is_exact;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type uses an exact representation.
All integer types are exact, but not all exact types are integer.
For example, rational and fixed-exponent representations are exact but not integer.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{radix}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{radix}}
\begin{itemdecl}
static constexpr int radix;
\end{itemdecl}

\begin{itemdescr}
\pnum
For floating types, specifies the base or radix of the exponent representation
(often 2).\footnote{Equivalent to \tcode{FLT_RADIX}.}

\pnum
For integer types, specifies the base of the
representation.\footnote{Distinguishes types with bases other than 2 (e.g.
BCD).}

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{epsilon}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{epsilon}}
\begin{itemdecl}
static constexpr T epsilon() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Machine epsilon:  the difference between 1 and the least value greater than 1
that is representable.\footnote{Equivalent to \tcode{FLT_EPSILON}, \tcode{DBL_EPSILON}, \tcode{LDBL_EPSILON}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{round_error}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{round_error}}
\begin{itemdecl}
static constexpr T round_error() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Measure of the maximum rounding error.\footnote{Rounding error is described in
ISO/IEC 10967-1 Language independent arithmetic - Part 1
Section 5.2.8 and
Annex A Rationale Section A.5.2.8 - Rounding constants.}
\end{itemdescr}

\indexlibrary{\idxcode{min_exponent}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min_exponent}}
\begin{itemdecl}
static constexpr int  min_exponent;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum negative integer such that
\tcode{radix}
raised to the power of one less than that integer is a normalized floating
point number.\footnote{Equivalent to \tcode{FLT_MIN_EXP}, \tcode{DBL_MIN_EXP},
\tcode{LDBL_MIN_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{min_exponent10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min_exponent10}}
\begin{itemdecl}
static constexpr int  min_exponent10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum negative integer such that 10 raised to that power is in the range
of normalized floating point numbers.\footnote{Equivalent to
\tcode{FLT_MIN_10_EXP}, \tcode{DBL_MIN_10_EXP}, \tcode{LDBL_MIN_10_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{max_exponent}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max_exponent}}
\begin{itemdecl}
static constexpr int  max_exponent;
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum positive integer such that
\tcode{radix}
raised to the power one less than that integer is a representable finite
floating point number.\footnote{Equivalent to \tcode{FLT_MAX_EXP},
\tcode{DBL_MAX_EXP}, \tcode{LDBL_MAX_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{max_exponent10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max_exponent10}}
\begin{itemdecl}
static constexpr int  max_exponent10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum positive integer such that 10 raised to that power is in the
range of representable finite floating point numbers.\footnote{Equivalent to
\tcode{FLT_MAX_10_EXP}, \tcode{DBL_MAX_10_EXP}, \tcode{LDBL_MAX_10_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{has_infinity}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_infinity}}
\begin{itemdecl}
static constexpr bool has_infinity;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for positive infinity.

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{has_quiet_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_quiet_NaN}}
\begin{itemdecl}
static constexpr bool has_quiet_NaN;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for a quiet (non-signaling) ``Not a
Number.''\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{has_signaling_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_signaling_NaN}}
\begin{itemdecl}
static constexpr bool has_signaling_NaN;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for a signaling ``Not a Number.''\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{float_denorm_style}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{float_denorm_style}}
\begin{itemdecl}
static constexpr float_denorm_style has_denorm;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{denorm_present}
if the type allows denormalized values
(variable number of exponent bits)\footnote{Required by LIA-1.},
\tcode{denorm_absent}
if the type does not allow denormalized values,
and
\tcode{denorm_indeterminate}
if it is indeterminate at compile time whether the type allows
denormalized values.

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{has_denorm_loss}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_denorm_loss}}
\begin{itemdecl}
static constexpr bool has_denorm_loss;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if loss of accuracy is detected as a
denormalization loss, rather than as an inexact result.\footnote{See IEC 559.}
\end{itemdescr}

\indexlibrary{\idxcode{infinity}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{infinity}}
\begin{itemdecl}
static constexpr T infinity() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of positive infinity, if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_infinity != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{quiet_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{quiet_NaN}}
\begin{itemdecl}
static constexpr T quiet_NaN() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of a quiet ``Not a Number,'' if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_quiet_NaN != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{signaling_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{signaling_NaN}}
\begin{itemdecl}
static constexpr T signaling_NaN() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of a signaling ``Not a Number,'' if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_signaling_NaN != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{denorm_min}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{denorm_min}}
\begin{itemdecl}
static constexpr T denorm_min() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum positive denormalized value.\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
In specializations for which
\tcode{has_denorm == false},
returns the minimum positive normalized value.
\end{itemdescr}

\indexlibrary{\idxcode{is_iec559}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_iec559}}
\begin{itemdecl}
static constexpr bool is_iec559;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if and only if the type adheres to IEC 559 standard.\footnote{International
Electrotechnical Commission standard 559 is the same as
IEEE 754.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{is_bounded}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_bounded}}
\begin{itemdecl}
static constexpr bool is_bounded;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the set of values representable by the type is finite.\footnote{Required by LIA-1.}
\enternote All fundamental types~(\ref{basic.fundamental}) are bounded. This member would be false for arbitrary
precision types.\exitnote

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_modulo}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_modulo}}
\begin{itemdecl}
static constexpr bool is_modulo;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is modulo.\footnote{Required by LIA-1.}
A type is modulo if, for any operation involving \tcode{+}, \tcode{-}, or
\tcode{*} on values of that type whose result would fall outside the range
\crange{min()}{max()}, the value returned differs from the true value by an
integer multiple of \tcode{max() - min() + 1}.

\pnum
On most machines, this is
\tcode{false}
for floating types,
\tcode{true}
for unsigned integers, and
\tcode{true}
for signed integers.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{traps}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{traps}}
\begin{itemdecl}
static constexpr bool traps;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{true}
if, at program startup, there exists a value of the type that would cause
an arithmetic operation using that value to trap.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{tinyness_before}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{tinyness_before}}
\begin{itemdecl}
static constexpr bool tinyness_before;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{true}
if tinyness is detected before rounding.\footnote{Refer to IEC 559.
Required by LIA-1.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{round_style}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{round_style}}
\begin{itemdecl}
static constexpr float_round_style round_style;
\end{itemdecl}

\begin{itemdescr}
\pnum
The rounding style for the type.\footnote{Equivalent to \tcode{FLT_ROUNDS}.
Required by LIA-1.}

\pnum
Meaningful for all floating point types.
Specializations for integer types shall return
\tcode{round_toward_zero}.
\end{itemdescr}

\rSec3[round.style]{Type \tcode{float_round_style}}

\indexlibrary{\idxcode{float_round_style}}%
\begin{codeblock}
namespace std {
  enum float_round_style {
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
  };
}
\end{codeblock}

\pnum
The rounding mode for floating point arithmetic is characterized by the
values:

\begin{itemize}
\item
\indexlibrary{\idxcode{round_indeterminate}}%
\tcode{round_indeterminate}
if the rounding style is indeterminable
\item
\indexlibrary{\idxcode{round_toward_zero}}%
\tcode{round_toward_zero}
if the rounding style is toward zero
\item
\indexlibrary{\idxcode{round_to_nearest}}%
\tcode{round_to_nearest}
if the rounding style is to the nearest representable value
\item
\indexlibrary{\idxcode{round_toward_infinity}}%
\tcode{round_toward_infinity}
if the rounding style is toward infinity
\item
\indexlibrary{\idxcode{round_toward_neg_infinity}}%
\tcode{round_toward_neg_infinity}
if the rounding style is toward negative infinity
\end{itemize}

\rSec3[denorm.style]{Type \tcode{float_denorm_style}}

\indexlibrary{\idxcode{float_denorm_style}}%
\begin{codeblock}
namespace std {
  enum float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };
}
\end{codeblock}

\pnum
The presence or absence of denormalization (variable number of exponent bits)
is characterized by the values:

\begin{itemize}
\item
\indexlibrary{\idxcode{denorm_indeterminate}}%
\tcode{denorm_indeterminate}
if it cannot be determined whether or not the type allows denormalized values
\item
\indexlibrary{\idxcode{denorm_absent}}%
\tcode{denorm_absent}
if the type does not allow denormalized values
\item
\indexlibrary{\idxcode{denorm_present}}%
\tcode{denorm_present}
if the type does allow denormalized values
\end{itemize}

\rSec3[numeric.special]{\tcode{numeric_limits} specializations}

\pnum
All members shall be provided for all specializations.
However, many values are only required to be meaningful under certain
conditions
(for example,
\tcode{epsilon()}
is only meaningful if
\tcode{is_integer}
is
\tcode{false}).
Any value that is not ``meaningful'' shall be set to 0 or
\tcode{false}.

\pnum
\enterexample
\begin{codeblock}
namespace std {
  template<> class numeric_limits<float> {
  public:
    static constexpr bool is_specialized = true;

    inline static constexpr float min() noexcept { return 1.17549435E-38F; }
    inline static constexpr float max() noexcept { return 3.40282347E+38F; }
    inline static constexpr float lowest() noexcept { return -3.40282347E+38F; }

    static constexpr int digits   = 24;
    static constexpr int digits10 =  6;
    static constexpr int max_digits10 =  9;

    static constexpr bool is_signed  = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact   = false;

    static constexpr int radix = 2;
    inline static constexpr float epsilon() noexcept     { return 1.19209290E-07F; }
    inline static constexpr float round_error() noexcept { return 0.5F; }

    static constexpr int min_exponent   = -125;
    static constexpr int min_exponent10 = - 37;
    static constexpr int max_exponent   = +128;
    static constexpr int max_exponent10 = + 38;

    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;

    inline static constexpr float infinity()      noexcept { return @\textit{value}@; }
    inline static constexpr float quiet_NaN()     noexcept { return @\textit{value}@; }
    inline static constexpr float signaling_NaN() noexcept { return @\textit{value}@; }
    inline static constexpr float denorm_min()    noexcept { return min(); }

    static constexpr bool is_iec559  = true;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo  = false;
    static constexpr bool traps      = true;
    static constexpr bool tinyness_before = true;

    static constexpr float_round_style round_style = round_to_nearest;
  };
}
\end{codeblock}
\exitexample

\pnum
The specialization for
\tcode{bool}
shall be provided as follows:
\indexlibrary{\idxcode{numeric_limits<bool>}}%
\begin{codeblock}
namespace std {
   template<> class numeric_limits<bool> {
   public:
     static constexpr bool is_specialized = true;
     static constexpr bool min() noexcept { return false; }
     static constexpr bool max() noexcept { return true; }
     static constexpr bool lowest() noexcept { return false; }

     static constexpr int  digits = 1;
     static constexpr int  digits10 = 0;
     static constexpr int  max_digits10 = 0;

     static constexpr bool is_signed = false;
     static constexpr bool is_integer = true;
     static constexpr bool is_exact = true;
     static constexpr int  radix = 2;
     static constexpr bool epsilon() noexcept { return 0; }
     static constexpr bool round_error() noexcept { return 0; }

     static constexpr int  min_exponent = 0;
     static constexpr int  min_exponent10 = 0;
     static constexpr int  max_exponent = 0;
     static constexpr int  max_exponent10 = 0;

     static constexpr bool has_infinity = false;
     static constexpr bool has_quiet_NaN = false;
     static constexpr bool has_signaling_NaN = false;
     static constexpr float_denorm_style has_denorm = denorm_absent;
     static constexpr bool has_denorm_loss = false;
     static constexpr bool infinity() noexcept { return 0; }
     static constexpr bool quiet_NaN() noexcept { return 0; }
     static constexpr bool signaling_NaN() noexcept { return 0; }
     static constexpr bool denorm_min() noexcept { return 0; }

     static constexpr bool is_iec559 = false;
     static constexpr bool is_bounded = true;
     static constexpr bool is_modulo = false;

     static constexpr bool traps = false;
     static constexpr bool tinyness_before = false;
     static constexpr float_round_style round_style = round_toward_zero;
   };
}
\end{codeblock}

\rSec2[c.limits]{C library}

\pnum
Table~\ref{tab:support.hdr.climits} describes the header
\tcode{<climits>}.

\indexlibrary{\idxcode{CHAR_BIT}}%
\indexlibrary{\idxcode{INT_MAX}}%
\indexlibrary{\idxcode{LONG_MAX}}%
\indexlibrary{\idxcode{SCHAR_MIN}}%
\indexlibrary{\idxcode{SHRT_MIN}}%
\indexlibrary{\idxcode{ULLONG_MAX}}%
\indexlibrary{\idxcode{CHAR_MAX}}%
\indexlibrary{\idxcode{LLONG_MAX}}%
\indexlibrary{\idxcode{LONG_MAX}}%
\indexlibrary{\idxcode{SCHAR_MAX}}%
\indexlibrary{\idxcode{UCHAR_MAX}}%
\indexlibrary{\idxcode{ULLONG_MAX}}%
\indexlibrary{\idxcode{CHAR_MAX}}%
\indexlibrary{\idxcode{LLONG_MIN}}%
\indexlibrary{\idxcode{MB_LEN_MAX}}%
\indexlibrary{\idxcode{SHRT_MAX}}%
\indexlibrary{\idxcode{UINT_MAX}}%
\indexlibrary{\idxcode{USHRT_MAX}}%
\indexlibrary{\idxcode{INT_MIN}}%
\begin{libsyntab6}{climits}{tab:support.hdr.climits}
\cspan{\values}     \\

\tcode{CHAR_BIT}    &
\tcode{INT_MAX}     &
\tcode{LONG_MAX}    &
\tcode{SCHAR_MIN}   &
\tcode{SHRT_MIN}    &
\tcode{ULLONG_MAX}  \\

\tcode{CHAR_MAX}    &
\tcode{LLONG_MAX}   &
\tcode{LONG_MIN}    &
\tcode{SCHAR_MAX}   &
\tcode{UCHAR_MAX}   &
\tcode{ULONG_MAX}   \\

\tcode{CHAR_MIN}    &
\tcode{LLONG_MIN}   &
\tcode{MB_LEN_MAX}  &
\tcode{SHRT_MAX}    &
\tcode{UINT_MAX}    &
\tcode{USHRT_MAX}   \\

\tcode{INT_MIN} &&&&&\\

\end{libsyntab6}

\pnum
The contents are the same as the Standard C library header
\tcode{<limits.h>}. \enternote The types of the
constants defined by macros in \tcode{<climits>} are not
required to match the types to which the macros refer.\exitnote

\pnum
Table~\ref{tab:support.hdr.cfloat} describes the header
\tcode{<cfloat>}.

\indexlibrary{\idxcode{DBL_DIG}}%
\indexlibrary{\idxcode{DBL_MIN_EXP}}%
\indexlibrary{\idxcode{FLT_MAX_EXP}}%
\indexlibrary{\idxcode{LDBL_MANT_DIG}}%
\indexlibrary{\idxcode{DBL_EPSILON}}%
\indexlibrary{\idxcode{DECIMAL_DIG}}%
\indexlibrary{\idxcode{FLT_MIN}}%
\indexlibrary{\idxcode{LDBL_MAX_10_EXP}}%
\indexlibrary{\idxcode{DBL_MANT_DIG}}%
\indexlibrary{\idxcode{FLT_DIG}}%
\indexlibrary{\idxcode{FLT_MIN_10_EXP}}%
\indexlibrary{\idxcode{LDBL_MAX_EXP}}%
\indexlibrary{\idxcode{DBL_MAX}}%
\indexlibrary{\idxcode{FLT_EPSILON}}%
\indexlibrary{\idxcode{FLT_MIN_EXP}}%
\indexlibrary{\idxcode{LDBL_MAX}}%
\indexlibrary{\idxcode{DBL_MAX_10_EXP}}%
\indexlibrary{\idxcode{FLT_EVAL_METHOD}}%
\indexlibrary{\idxcode{FLT_RADIX}}%
\indexlibrary{\idxcode{LDBL_MIN}}%
\indexlibrary{\idxcode{DBL_MAX_EXP}}%
\indexlibrary{\idxcode{FLT_MANT_DIG}}%
\indexlibrary{\idxcode{FLT_ROUNDS}}%
\indexlibrary{\idxcode{LDBL_MIN_10_EXP}}%
\indexlibrary{\idxcode{DBL_MIN}}%
\indexlibrary{\idxcode{FLT_MAX}}%
\indexlibrary{\idxcode{LDBL_DIG}}%
\indexlibrary{\idxcode{LDBL_MIN_EXP}}%
\indexlibrary{\idxcode{DBL_MIN_10_EXP}}%
\indexlibrary{\idxcode{FLT_MAX_10_EXP}}%
\indexlibrary{\idxcode{LDBL_EPSILON}}%
\begin{libsyntab4}{cfloat}{tab:support.hdr.cfloat}
\cspan{\values}         \\

\tcode{DBL_DIG}         &
\tcode{DBL_MIN_EXP} &
\tcode{FLT_MAX_EXP} &
\tcode{LDBL_MANT_DIG}   \\

\tcode{DBL_EPSILON}     &
\tcode{DECIMAL_DIG}     &
\tcode{FLT_MIN}     &
\tcode{LDBL_MAX_10_EXP}\\

\tcode{DBL_MANT_DIG}    &
\tcode{FLT_DIG}     &
\tcode{FLT_MIN_10_EXP}  &
\tcode{LDBL_MAX_EXP}    \\

\tcode{DBL_MAX} &
\tcode{FLT_EPSILON} &
\tcode{FLT_MIN_EXP} &
\tcode{LDBL_MAX}        \\

\tcode{DBL_MAX_10_EXP}  &
\tcode{FLT_EVAL_METHOD} &
\tcode{FLT_RADIX}       &
\tcode{LDBL_MIN}        \\

\tcode{DBL_MAX_EXP} &
\tcode{FLT_MANT_DIG}    &
\tcode{FLT_ROUNDS}      &
\tcode{LDBL_MIN_10_EXP}\\

\tcode{DBL_MIN}         &
\tcode{FLT_MAX}     &
\tcode{LDBL_DIG}        &
\tcode{LDBL_MIN_EXP}    \\

\tcode{DBL_MIN_10_EXP}  &
\tcode{FLT_MAX_10_EXP}  &
\tcode{LDBL_EPSILON}    &   \\

\end{libsyntab4}

\pnum
The contents are the same as the Standard C library header
\tcode{<float.h>}.

\xref ISO C~7.1.5, 5.2.4.2.2, 5.2.4.2.1.

\rSec1[cstdint]{Integer types}
\rSec2[cstdint.syn]{Header \tcode{<cstdint>} synopsis}
\indextext{\idxhdr{cstdint}}%
\indexlibrary{\idxhdr{cstdint}}%
\indexlibrary{\idxcode{int8_t}}%
\indexlibrary{\idxcode{int16_t}}%
\indexlibrary{\idxcode{int32_t}}%
\indexlibrary{\idxcode{int64_t}}%
\indexlibrary{\idxcode{int_fast8_t}}%
\indexlibrary{\idxcode{int_fast16_t}}%
\indexlibrary{\idxcode{int_fast32_t}}%
\indexlibrary{\idxcode{int_fast64_t}}%
\indexlibrary{\idxcode{int_least8_t}}%
\indexlibrary{\idxcode{int_least16_t}}%
\indexlibrary{\idxcode{int_least32_t}}%
\indexlibrary{\idxcode{int_least64_t}}%
\indexlibrary{\idxcode{intmax_t}}%
\indexlibrary{\idxcode{intptr_t}}%
\indexlibrary{\idxcode{uint8_t}}%
\indexlibrary{\idxcode{uint16_t}}%
\indexlibrary{\idxcode{uint32_t}}%
\indexlibrary{\idxcode{uint64_t}}%
\indexlibrary{\idxcode{uint_fast8_t}}%
\indexlibrary{\idxcode{uint_fast16_t}}%
\indexlibrary{\idxcode{uint_fast32_t}}%
\indexlibrary{\idxcode{uint_fast64_t}}%
\indexlibrary{\idxcode{uint_least8_t}}%
\indexlibrary{\idxcode{uint_least16_t}}%
\indexlibrary{\idxcode{uint_least32_t}}%
\indexlibrary{\idxcode{uint_least64_t}}%
\indexlibrary{\idxcode{uintmax_t}}%
\indexlibrary{\idxcode{uintptr_t}}%
\begin{codeblock}
namespace std {
  typedef @\textit{signed integer type}@ int8_t;   // optional
  typedef @\textit{signed integer type}@ int16_t;  // optional
  typedef @\textit{signed integer type}@ int32_t;  // optional
  typedef @\textit{signed integer type}@ int64_t;  // optional

  typedef @\textit{signed integer type}@ int_fast8_t;
  typedef @\textit{signed integer type}@ int_fast16_t;
  typedef @\textit{signed integer type}@ int_fast32_t;
  typedef @\textit{signed integer type}@ int_fast64_t;

  typedef @\textit{signed integer type}@ int_least8_t;
  typedef @\textit{signed integer type}@ int_least16_t;
  typedef @\textit{signed integer type}@ int_least32_t;
  typedef @\textit{signed integer type}@ int_least64_t;

  typedef @\textit{signed integer type}@ intmax_t;
  typedef @\textit{signed integer type}@ intptr_t;         // optional

  typedef @\textit{unsigned integer type}@ uint8_t;        // optional
  typedef @\textit{unsigned integer type}@ uint16_t;       // optional
  typedef @\textit{unsigned integer type}@ uint32_t;       // optional
  typedef @\textit{unsigned integer type}@ uint64_t;       // optional

  typedef @\textit{unsigned integer type}@ uint_fast8_t;
  typedef @\textit{unsigned integer type}@ uint_fast16_t;
  typedef @\textit{unsigned integer type}@ uint_fast32_t;
  typedef @\textit{unsigned integer type}@ uint_fast64_t;

  typedef @\textit{unsigned integer type}@ uint_least8_t;
  typedef @\textit{unsigned integer type}@ uint_least16_t;
  typedef @\textit{unsigned integer type}@ uint_least32_t;
  typedef @\textit{unsigned integer type}@ uint_least64_t;

  typedef @\textit{unsigned integer type}@ uintmax_t;
  typedef @\textit{unsigned integer type}@ uintptr_t;      // optional
} // namespace std
\end{codeblock}

\pnum
The header also defines numerous macros of the form:

\begin{codeblock}
  INT_[FAST LEAST]{8 16 32 64}_MIN
  [U]INT_[FAST LEAST]{8 16 32 64}_MAX
  INT{MAX PTR}_MIN
  [U]INT{MAX PTR}_MAX
  {PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
  SIZE_MAX
\end{codeblock}

plus function macros of the form:

\begin{codeblock}
  [U]INT{8 16 32 64 MAX}_C
\end{codeblock}

\pnum
The header defines all functions, types, and macros the same as
7.18 in the C standard. \enternote The macros defined
by \tcode{<cstdint>} are provided unconditionally. In
particular, the symbols
\tcode{__STDC_LIMIT_MACROS}
and
\tcode{__STDC_CONSTANT_MACROS}
(mentioned in footnotes
219, 220, and 222 in the C standard) play no role in \Cpp. \exitnote

\rSec1[support.start.term]{Start and termination}

\pnum
Table~\ref{tab:support.hdr.cstdlib} describes some of the contents of the header \tcode{<cstdlib>}.

\indexlibrary{\idxcode{EXIT_FAILURE}}%
\indexlibrary{\idxcode{EXIT_SUCCESS}}%
\indexlibrary{\idxcode{_Exit}}%
\indexlibrary{\idxcode{abort}}%
\indexlibrary{\idxcode{atexit}}%
\indexlibrary{\idxcode{at_quick_exit}}%
\indexlibrary{\idxcode{exit}}%
\indexlibrary{\idxcode{quick_exit}}%
\begin{libsyntab4}{cstdlib}{tab:support.hdr.cstdlib}
\macros     &   \tcode{EXIT_FAILURE}    &   \tcode{EXIT_SUCCESS}    &             \\ \rowsep
\functions
&   \tcode{_Exit}
&   \tcode{abort}
&   \tcode{atexit}  \\
&   \tcode{at_quick_exit}
&   \tcode{exit}
&   \tcode{quick_exit}  \\
\end{libsyntab4}

\pnum
The contents are the same as the Standard C library header
\tcode{<stdlib.h>},
with the following changes:

\indexlibrary{\idxcode{_Exit}}%
\begin{itemdecl}
[[noreturn]] void _Exit(int status) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The function \tcode{_Exit(int status)} has additional behavior in this
International Standard:

\begin{itemize}
\item
The program is terminated without executing destructors for objects of automatic,
thread, or static storage duration and without calling functions passed to
\tcode{atexit()}~(\ref{basic.start.term}).
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{abort}}%
\begin{itemdecl}
[[noreturn]] void abort(void) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The function
\tcode{abort()}
has additional behavior in this International Standard:

\begin{itemize}
\item
The program is terminated without executing destructors for objects of
automatic, thread, or static storage
duration and without calling functions passed to
\tcode{atexit()}~(\ref{basic.start.term}).
%
\indexlibrary{\idxcode{atexit}}%
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{atexit}}
\begin{itemdecl}
extern "C" int atexit(void (*f)(void)) noexcept;
extern "C++" int atexit(void (*f)(void)) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\tcode{atexit()}
functions register the function pointed to by \tcode{f}
to be called without arguments at normal program termination.
It is unspecified whether a call to \tcode{atexit()} that does not
happen before~(\ref{intro.multithread}) a call to \tcode{exit()} will succeed.
\enternote The \tcode{atexit()} functions do not introduce a data
race~(\ref{res.on.data.races}). \exitnote

\pnum
\implimits
The implementation shall support the registration of at least 32 functions.

\pnum
\returns
The
\tcode{atexit()}
function returns zero if the registration succeeds,
non-zero if it fails.
\end{itemdescr}

\indexlibrary{\idxcode{exit}}%
\begin{itemdecl}
[[noreturn]] void exit(int status)
\end{itemdecl}

\begin{itemdescr}
\pnum
The function
\tcode{exit()}
has additional behavior in this International Standard:

\begin{itemize}
\item
First, objects with thread storage duration and associated with the current thread
are destroyed. Next, objects with static storage duration are destroyed
and functions registered by calling
\tcode{atexit}
are called.\footnote{A function is called for every time it is registered.}
See~\ref{basic.start.term} for the order of destructions and calls.
(Automatic objects are not destroyed as a result of calling
\tcode{exit()}.)\footnote{Objects with automatic storage duration are all destroyed in a program whose
function
\tcode{main()}
contains no automatic objects and executes the call to
\tcode{exit()}.
Control can be transferred directly to such a
\tcode{main()}
by throwing an exception that is caught in
\tcode{main()}.}

If control leaves a registered function called by \tcode{exit} because the function does
not provide a handler for a thrown exception, \tcode{std::terminate()} shall be called~(\ref{except.terminate}).%
\indexlibrary{\idxcode{terminate}}

\item
Next, all open C streams (as mediated by the function
signatures declared in
\tcode{<cstdio>})
with unwritten buffered data are flushed, all open C
streams are closed, and all files created by calling
\tcode{tmpfile()}
are removed.

\item
Finally, control is returned to the host environment.
If \tcode{status} is zero or
\tcode{EXIT_SUCCESS},
an \impldef{exit status}
form of the status
\term{successful termination}
is returned.
\indextext{implementation-defined}%
If \tcode{status} is
\tcode{EXIT_FAILURE},
an \impldef{exit status} form of the status
\term{unsuccessful termination}
is returned.
\indextext{implementation-defined}%
Otherwise the status returned is \impldef{exit status}.%
\indextext{implementation-defined}\footnote{The macros
\tcode{EXIT_FAILURE}
and
\tcode{EXIT_SUCCESS}
are defined in
\tcode{<cstdlib>}.}
\end{itemize}

\end{itemdescr}

\indexlibrary{\idxcode{at_quick_exit}}
\begin{itemdecl}
extern "C" int at_quick_exit(void (*f)(void)) noexcept;
extern "C++" int at_quick_exit(void (*f)(void)) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The \tcode{at_quick_exit()} functions register the function pointed to by \tcode{f}
to be called without arguments when \tcode{quick_exit} is called.
It is unspecified whether a call to \tcode{at_quick_exit()} that does not
happen before~(\ref{intro.multithread}) all calls to \tcode{quick_exit} will succeed. \enternote The
\tcode{at_quick_exit()} functions do not introduce a
data race~(\ref{res.on.data.races}). \exitnote
\enternote
The order of registration may be indeterminate if \tcode{at_quick_exit} was called from more
than one thread.
\exitnote
\enternote The
\tcode{at_quick_exit} registrations are distinct from the \tcode{atexit} registrations,
and applications may need to call both registration functions with the same argument.
\exitnote

\pnum
\implimits
The implementation shall support the registration of at least 32 functions.

\pnum
\returns Zero if the registration succeeds, non-zero if it fails.
\end{itemdescr}

\indexlibrary{\idxcode{quick_exit}}
\begin{itemdecl}
[[noreturn]] void quick_exit(int status) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Functions registered by calls to \tcode{at_quick_exit} are called in the
reverse order of their registration, except that a function shall be called after any
previously registered functions that had already been called at the time it was
registered. Objects shall not be destroyed as a result of calling \tcode{quick_exit}.
If control leaves a registered function called by \tcode{quick_exit} because the
function does not provide a handler for a thrown exception, \tcode{std::terminate()} shall
be called.%
\indexlibrary{\idxcode{terminate}}
\enternote \tcode{at_quick_exit} may call a registered function from a different thread
than the one that registered it, so registered functions should not rely on the identity
of objects with thread storage duration. \exitnote
After calling registered functions, \tcode{quick_exit} shall call \tcode{_Exit(status)}.
\enternote The standard file buffers are not flushed. \xsee ISO C~7.20.4.4. \exitnote

\end{itemdescr}

\xref~\ref{basic.start}, \ref{basic.start.term},
ISO C~7.10.4.

\rSec1[support.dynamic]{Dynamic memory management}

\pnum
The header
\tcode{<new>}
defines several
functions that manage the allocation of dynamic storage in a program.
It also defines components for reporting storage management errors.

\synopsis{Header \tcode{<new>} synopsis}
\indextext{\idxhdr{new}}%
\indexlibrary{\idxhdr{new}}%

\begin{codeblock}
namespace std {
  class bad_alloc;
  class bad_array_new_length;
  struct nothrow_t {};
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler get_new_handler() noexcept;
  new_handler set_new_handler(new_handler new_p) noexcept;
}

void* operator new(std::size_t size);
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
void  operator delete(void* ptr) noexcept;
void  operator delete(void* ptr, const std::nothrow_t&) noexcept;
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
void  operator delete[](void* ptr) noexcept;
void  operator delete[](void* ptr, const std::nothrow_t&) noexcept;

void* operator new  (std::size_t size, void* ptr) noexcept;
void* operator new[](std::size_t size, void* ptr) noexcept;
void  operator delete  (void* ptr, void*) noexcept;
void  operator delete[](void* ptr, void*) noexcept;
\end{codeblock}

\xref~\ref{intro.memory}, \ref{basic.stc.dynamic},
\ref{expr.new}, \ref{expr.delete}, \ref{class.free},
\ref{memory}.

\rSec2[new.delete]{Storage allocation and deallocation}

\pnum
Except where otherwise specified, the provisions of~(\ref{basic.stc.dynamic})
apply to the library versions of \tcode{operator new} and \tcode{op\-er\-a\-tor
delete}.

\rSec3[new.delete.single]{Single-object forms}

\indexlibrary{\idxcode{new}!\tcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{allocation function}~(\ref{basic.stc.dynamic.allocation})
called by a
\grammarterm{new-expression}~(\ref{expr.new})
to allocate
\tcode{size} bytes of storage suitably aligned to represent any object
of that size.

\pnum
\replaceable
a \Cpp program may define a function with this function signature
that displaces the default version defined by the
\Cpp standard library.

\pnum
\required 
Return a non-null pointer to suitably aligned storage~(\ref{basic.stc.dynamic}),
or else throw a
\tcode{bad_alloc}
\indexlibrary{\idxcode{bad_alloc}}%
exception.
This requirement is binding on a replacement version of this function.

\pnum
\default

\begin{itemize}
\item
Executes a loop:
Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the Standard C library function
\tcode{malloc}
is unspecified.
\indextext{unspecified}%
\item
Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the
current \tcode{new_handler}~(\ref{get.new.handler}) is
a null pointer value, throws
\tcode{bad_alloc}.
\item
Otherwise, the function calls the current
\tcode{new_handler} function~(\ref{new.handler}).
If the called function returns, the loop repeats.
\item
The loop terminates when an attempt to allocate the requested storage is
successful or when a called
\tcode{new_handler}
function does not return.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Same as above, except that it is called by a placement version of a
\grammarterm{new-expression}
when a \Cpp program prefers a null pointer result as an error indication,
instead of a
\tcode{bad_alloc}
exception.

\pnum
\replaceable
a \Cpp program may define a function with this function signature
that displaces the default version defined by the
\Cpp standard library.

\pnum
\required
Return a non-null pointer to suitably aligned storage~(\ref{basic.stc.dynamic}),
or else return a null pointer.
This nothrow version of
\tcode{operator new}
returns a pointer obtained as if acquired from the (possibly replaced)
ordinary version.
This requirement is binding on a replacement version of this function.

\pnum
\default
Calls \tcode{operator new(size)}. If the call returns normally,
returns the result of that call. Otherwise, returns a null pointer.

\pnum
\enterexample
\begin{codeblock}
T* p1 = new T;                  // throws \tcode{bad_alloc} if it fails
T* p2 = new(nothrow) T;         // returns \tcode{0} if it fails
\end{codeblock}
\exitexample
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete(void* ptr) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by a
\grammarterm{delete-expression}
to render the value of \tcode{ptr} invalid.

\pnum
\replaceable
a \Cpp program may define a function with this
function signature that displaces the default version defined by the
\Cpp standard library.

\pnum
\requires
\textit{ptr} shall be a null pointer or
its value shall be a value returned by an
earlier call to the (possibly replaced)
\tcode{operator new(std\colcol{}size_t)}
or
\tcode{operator new(std::size_t,const std::nothrow_t\&)}
which has not been invalidated by an intervening call to
\tcode{operator delete(void*)}.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\default
If \tcode{ptr} is null, does nothing. Otherwise, reclaims the
storage allocated by the earlier call to \tcode{operator new}.

\pnum
\notes
It is unspecified under what conditions part or all of such
\indextext{unspecified}%
reclaimed storage will be allocated by subsequent
calls to
\tcode{operator new}
or any of
\tcode{calloc},
\tcode{malloc},
or
\tcode{realloc},
declared in
\tcode{<cstdlib>}.
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by the implementation
to render the value of \tcode{ptr} invalid
when the constructor invoked from a nothrow
placement version of the \grammarterm{new-expression} throws an exception.

\pnum
\replaceable
a \Cpp program may define a function with this
function signature that displaces the default version defined by the
\Cpp standard library.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\default
calls \tcode{operator delete(ptr)}.
\end{itemdescr}

\rSec3[new.delete.array]{Array forms}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{allocation function}~(\ref{basic.stc.dynamic.allocation})
called by the array form of a
\grammarterm{new-expression}~(\ref{expr.new})
to allocate \tcode{size} bytes of storage suitably aligned to represent any array
object of that size or smaller.\footnote{It is not the direct responsibility of
\tcode{operator new[](std::size_t)}
or
\tcode{operator delete[](void*)}
to note the repetition count or element size of the array.
Those operations are performed elsewhere in the array
\tcode{new}
and
\tcode{delete}
expressions.
The array
\tcode{new}
expression, may, however, increase the \tcode{size} argument to
\tcode{operator new[](std::size_t)}
to obtain space to store supplemental information.}

\pnum
\replaceable
a \Cpp program can define a
function with this function signature that displaces the default version
defined by the \Cpp standard library.

\pnum
\required
Same as for
\tcode{operator new(std::size_t)}.
This requirement is binding on a replacement version of this function.

\pnum
\default
Returns
\tcode{operator new(size)}.
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Same as above, except that it is called by a placement version of a
\grammarterm{new-expression}
when a \Cpp program prefers a null pointer result as an error indication,
instead of a
\tcode{bad_alloc}
exception.

\pnum
\replaceable
a \Cpp program can define a
function with this function signature that displaces the default version
defined by the \Cpp standard library.

\pnum
\required
Return a non-null pointer to suitably aligned storage~(\ref{basic.stc.dynamic}),
or return a null pointer.
This requirement is binding on a replacement version of this function.

\pnum
\default
Calls \tcode{operator new[](size)}. If the call returns normally,
returns the result of that call. Otherwise, returns a null pointer.
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete[](void* ptr) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by the array form of a
\grammarterm{delete-expression}
to render the value of \tcode{ptr} invalid.

\pnum
\replaceable
a \Cpp program can define a function with this
function signature that displaces the default version defined by the
\Cpp standard library.

\pnum
\requires
\textit{ptr} shall be a null pointer or its value shall be
the value returned by an earlier call to
\tcode{operator new[](\brk{}std::size_t)}
or
\tcode{operator new[](std::size_t,const std::nothrow_t\&)}
which has not been invalidated by an intervening call to
\tcode{operator delete[](void*)}.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\default
Calls
\tcode{operator delete(ptr)}.
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by the implementation
to render the value of \tcode{ptr} invalid
when the constructor invoked from a nothrow
placement version of the array \grammarterm{new-expression} throws an exception.

\pnum
\replaceable
a \Cpp program may define a function with this
function signature that displaces the default version defined by the
\Cpp standard library.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\default
calls \tcode{operator delete[](ptr)}.
\end{itemdescr}

\rSec3[new.delete.placement]{Placement forms}

\pnum
These functions are reserved, a \Cpp program may not define functions that displace
the versions in the Standard \Cpp library~(\ref{constraints}).
The provisions of~(\ref{basic.stc.dynamic}) do not apply to these reserved
placement forms of \tcode{operator new} and \tcode{operator delete}.

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size, void* ptr) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ptr}.

\pnum
\notes
Intentionally performs no other action.

\pnum
\enterexample
This can be useful for constructing an object at a known address:

\begin{codeblock}
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
\end{codeblock}
\exitexample
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size, void* ptr) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ptr}.

\pnum
\notes
Intentionally performs no other action.
\end{itemdescr}

\indexlibrary{\idxcode{new}!\tcode{operator}}%
\begin{itemdecl}
void operator delete(void* ptr, void*) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Intentionally performs no action.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\notes
Default function called when any part of the initialization in a
placement new expression that invokes the library's
non-array placement operator new
terminates by throwing an exception~(\ref{expr.new}).
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete[](void* ptr, void*) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Intentionally performs no action.

\pnum
\requires
If an implementation has strict pointer safety~(\ref{basic.stc.dynamic.safety})
then \tcode{ptr} shall be a safely-derived pointer.

\pnum
\notes
Default function called when any part of the initialization in a
placement new expression that invokes the library's
array placement operator new
terminates by throwing an exception~(\ref{expr.new}).
\end{itemdescr}

\rSec3[new.delete.dataraces]{Data races}

\pnum
For purposes of determining the existence of data races, the library versions
of \tcode{operator new}, user replacement versions of global \tcode{operator new},
and the C standard library functions \tcode{calloc} and \tcode{malloc} shall
behave as though they accessed and modified only the storage referenced by the
return value. The library versions of \tcode{operator delete}, user replacement
versions of \tcode{operator delete}, and the C standard library function
\tcode{free} shall behave as though they accessed and modified only the
storage referenced by their first argument. The C standard library function
\tcode{realloc} shall behave as though it accessed and modified only the
storage referenced by its first argument and by its return value.
Calls to these functions that allocate or deallocate a particular unit
of storage shall occur in a single total order, and each such deallocation call
shall happen before the next allocation (if any) in this order.

\rSec2[alloc.errors]{Storage allocation errors}

\indexlibrary{\idxcode{bad_alloc}}%
\rSec3[bad.alloc]{Class \tcode{bad_alloc}}

\begin{codeblock}
namespace std {
  class bad_alloc : public exception {
  public:
    bad_alloc() noexcept;
    bad_alloc(const bad_alloc&) noexcept;
    bad_alloc& operator=(const bad_alloc&) noexcept;
    virtual const char* what() const noexcept;
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_alloc}
defines the type of objects thrown as
exceptions by the implementation to report a failure to allocate storage.

\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc}}%
\begin{itemdecl}
bad_alloc() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_alloc}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.
\end{itemdescr}

\indextext{implementation-defined}%
\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_alloc}}%
\begin{itemdecl}
    bad_alloc(const bad_alloc&) noexcept;
    bad_alloc& operator=(const bad_alloc&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_alloc}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_alloc}}%
\begin{itemdecl}
virtual const char* what() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc::what}!implementation-defined}%
An \impldef{return value of \tcode{bad_alloc::what}} \ntbs.
\end{itemdescr}

\indexlibrary{\idxcode{bad_array_new_length}}%
\rSec3[new.badlength]{Class \tcode{bad_array_new_length}}

\begin{codeblock}
namespace std {
  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() noexcept;
  };
}
\end{codeblock}

\pnum
The class \tcode{bad_array_new_length} defines the type of objects thrown as
exceptions by the implementation to report an attempt to allocate an array of size
less than zero or
greater than an implementation-defined limit~(\ref{expr.new}).

\indexlibrary{\idxcode{bad_array_new_length}!\idxcode{bad_array_new_length}}%
\begin{itemdecl}
bad_array_new_length() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects constructs an object of class \tcode{bad_array_new_length}.

\pnum
\remarks the result of calling \tcode{what()} on the newly constructed object is
implementation-defined.
\end{itemdescr}

\rSec3[new.handler]{Type \tcode{new_handler}}

\indexlibrary{\idxcode{new_handler}}%
\begin{itemdecl}
typedef void (*new_handler)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{operator new()}
or
\tcode{operator new[]()}~(\ref{new.delete}) when they cannot satisfy a request for additional storage.

\pnum
\required
A \tcode{new_handler} shall perform one of the following:

\begin{itemize}
\item
make more storage available for allocation and then return;
\item
throw an exception of type
\tcode{bad_alloc}
or a class derived from
\indexlibrary{\idxcode{bad_alloc}}%
\tcode{bad_alloc};
\item
terminate execution of the program without returning to the caller;
\indexlibrary{\idxcode{abort}}%
\indexlibrary{\idxcode{exit}}%
\end{itemize}
\end{itemdescr}

\rSec3[set.new.handler]{\tcode{set_new_handler}}

\indexlibrary{\idxcode{set_new_handler}}%
\begin{itemdecl}
new_handler set_new_handler(new_handler new_p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{new_p} as the current
\tcode{new_handler}.

\pnum
\returns
The previous \tcode{new_handler}.

\pnum
\remarks
The initial \tcode{new_handler} is a null pointer.
\end{itemdescr}

\rSec3[get.new.handler]{\tcode{get_new_handler}}

\begin{itemdecl}
new_handler get_new_handler() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The current \tcode{new_handler}.
\enternote This may be a null pointer value. \exitnote
\end{itemdescr}

\rSec1[support.rtti]{Type identification}

\pnum
The header
\tcode{<typeinfo>}
defines a
type associated with type information generated by the implementation.
It also defines two types for reporting dynamic type identification errors.

\indextext{\idxhdr{typeinfo}}%
\indexlibrary{\idxhdr{typeinfo}}%
\synopsis{Header \tcode{<typeinfo>} synopsis}

\indexlibrary{\idxcode{type_info}}%
\indexlibrary{\idxcode{bad_cast}}%
\indexlibrary{\idxcode{bad_typeid}}%
\begin{codeblock}
namespace std {
  class type_info;
  class bad_cast;
  class bad_typeid;
}
\end{codeblock}

\xref~\ref{expr.dynamic.cast}, \ref{expr.typeid}.

\rSec2[type.info]{Class \tcode{type_info}}

\indexlibrary{\idxcode{type_info}}%
\begin{codeblock}
namespace std {
  class type_info {
  public:
    virtual ~type_info();
    bool operator==(const type_info& rhs) const noexcept;
    bool operator!=(const type_info& rhs) const noexcept;
    bool before(const type_info& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

    type_info(const type_info& rhs) = delete;            // cannot be copied
    type_info& operator=(const type_info& rhs) = delete; // cannot be copied
  };
}
\end{codeblock}

\pnum
The class
\tcode{type_info}
describes type information generated by the implementation.
Objects of this class effectively store a pointer to a name for the type, and
an encoded value suitable for comparing two types for equality or collating order.
The names, encoding rule, and collating sequence for types are all unspecified
\indextext{unspecified}%
and may differ between programs.

\indexlibrary{\idxcode{operator==}!\tcode{type_info}}%
\begin{itemdecl}
bool operator==(const type_info& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares the current object with \tcode{rhs}.

\pnum
\returns
\tcode{true}
if the two values describe the same type.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\tcode{type_info}}%
\begin{itemdecl}
bool operator!=(const type_info& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(*this == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{before}!\tcode{type_info}}%
\begin{itemdecl}
bool before(const type_info& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares the current object with \tcode{rhs}.

\pnum
\returns
\tcode{true}
if
\tcode{*this}
precedes \tcode{rhs} in the implementation's collation order.
\end{itemdescr}

\indexlibrary{\idxcode{hash_code}!\tcode{type_info}}%
\begin{itemdecl}
size_t hash_code() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An unspecified value, except that within a single execution of the
program, it shall return the same value for any two \tcode{type_info}
objects which compare equal.

\pnum
\remark an implementation should return different values for two
\tcode{type_info} objects which do not compare equal.
\end{itemdescr}


\indexlibrary{\idxcode{name}!\tcode{type_info}}%
\begin{itemdecl}
const char* name() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{type_info::name()}} \ntbs.
\indexlibrary{\idxcode{type_info::name}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{string.classes}, \ref{locale.codecvt})
\end{itemdescr}

\rSec2[bad.cast]{Class \tcode{bad_cast}}

\indexlibrary{\idxcode{bad_cast}}%
\begin{codeblock}
namespace std {
  class bad_cast : public exception {
  public:
    bad_cast() noexcept;
    bad_cast(const bad_cast&) noexcept;
    bad_cast& operator=(const bad_cast&) noexcept;
    virtual const char* what() const noexcept;
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_cast}
defines the type of objects thrown
as exceptions by the implementation to report the execution of an invalid
\grammarterm{dynamic-cast}
expression~(\ref{expr.dynamic.cast}).

\indextext{cast!dynamic}%
\indexlibrary{\idxcode{bad_cast}!\tcode{bad_cast}}%
\begin{itemdecl}
bad_cast() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_cast}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_cast}!\tcode{bad_cast}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_cast}}%
\begin{itemdecl}
    bad_cast(const bad_cast&) noexcept;
    bad_cast& operator=(const bad_cast&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_cast}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_cast}}%
\begin{itemdecl}
virtual const char* what() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_cast::what}} \ntbs.%
\indexlibrary{\idxcode{bad_cast::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{string.classes}, \ref{locale.codecvt})
\end{itemdescr}

\rSec2[bad.typeid]{Class \tcode{bad_typeid}}

\indexlibrary{\idxcode{bad_typeid}}%
\begin{codeblock}
namespace std {
  class bad_typeid : public exception {
  public:
    bad_typeid() noexcept;
    bad_typeid(const bad_typeid&) noexcept;
    bad_typeid& operator=(const bad_typeid&) noexcept;
    virtual const char* what() const noexcept;
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_typeid}
defines the type of objects
thrown as exceptions by the implementation to report a null pointer
in a
\grammarterm{typeid}
expression~(\ref{expr.typeid}).

\indexlibrary{\idxcode{bad_typeid}!\tcode{bad_typeid}}%
\begin{itemdecl}
bad_typeid() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_typeid}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_typeid}!\tcode{bad_typeid}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_typeid}}%
\begin{itemdecl}
    bad_typeid(const bad_typeid&) noexcept;
    bad_typeid& operator=(const bad_typeid&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_typeid}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_typeid}}%
\begin{itemdecl}
virtual const char* what() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_typeid::what}} \ntbs.%
\indextext{\idxcode{bad_typeid::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{string.classes}, \ref{locale.codecvt})
\end{itemdescr}

\rSec1[support.exception]{Exception handling}

\pnum
The header
\tcode{<exception>}
defines several types and functions related to the handling of exceptions in a \Cpp program.

\synopsis{Header \tcode{<exception>} synopsis}

\indextext{\idxhdr{exception}}%
\indexlibrary{\idxhdr{exception}}%
\begin{codeblock}
namespace std {
  class exception;
  class bad_exception;
  class nested_exception;

  typedef void (*unexpected_handler)();
  unexpected_handler get_unexpected() noexcept;
  unexpected_handler set_unexpected(unexpected_handler f) noexcept;
  [[noreturn]] void unexpected();

  typedef void (*terminate_handler)();
  terminate_handler get_terminate() noexcept;
  terminate_handler set_terminate(terminate_handler f) noexcept;
  [[noreturn]] void terminate() noexcept;

  bool uncaught_exception() noexcept;

  typedef @\unspec@ exception_ptr;

  exception_ptr current_exception() noexcept;
  [[noreturn]] void rethrow_exception(exception_ptr p);
  template<class E> exception_ptr make_exception_ptr(E e) noexcept;

  [[noreturn]] template <class T> void throw_with_nested(T&& t);
  template <class E> void rethrow_if_nested(const E& e);
}
\end{codeblock}

\xref~\ref{except.special}.

\rSec2[exception]{Class \tcode{exception}}

\indexlibrary{\idxcode{exception}}%
\begin{codeblock}
namespace std {
  class exception {
  public:
    exception() noexcept;
    exception(const exception&) noexcept;
    exception& operator=(const exception&) noexcept;
    virtual ~exception();
    virtual const char* what() const noexcept;
  };
}
\end{codeblock}

\pnum
The class
\tcode{exception}
defines the base
class for the types of objects thrown as exceptions by
\Cpp standard library components, and certain
expressions, to report errors detected during program execution.

\pnum
Each standard library class \tcode{T} that derives from class \tcode{exception} shall have a
publicly accessible copy constructor and a publicly accessible copy assignment
operator that do not exit with an exception. These member functions shall meet
the following postcondition: If two objects \tcode{lhs} and \tcode{rhs} both have
dynamic type \tcode{T} and \tcode{lhs} is a copy of \tcode{rhs}, then
\tcode{strcmp(lhs.what(), rhs.what())} shall equal 0.

\indexlibrary{\idxcode{exception}!constructor}%
\begin{itemdecl}
exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{exception}.

\pnum
\notes
Does not throw any exceptions.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{exception}}%
\begin{itemdecl}
exception(const exception& rhs) noexcept;
exception& operator=(const exception& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an
\tcode{exception}
object.

\pnum
\postcondition If \tcode{*this} and \tcode{rhs} both have dynamic type \tcode{exception}
then \tcode{strcmp(what(), rhs.what())} shall equal 0.
\end{itemdescr}

\indextext{implementation-defined}%
\indexlibrary{\idxcode{exception}!destructor}%
\begin{itemdecl}
virtual ~exception();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{exception}.

\pnum
\notes
Does not throw any exceptions.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{exception}}%
\begin{itemdecl}
virtual const char* what() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\indextext{exception::what~message@\tcode{exception::what}~message!implementation-defined}%
An \impldef{result of \tcode{exception::what}} \ntbs.

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{string.classes}, \ref{locale.codecvt}).
The return value remains valid until the exception object from which
it is obtained is destroyed or a non-\tcode{const}
member function of the exception object is called.
\end{itemdescr}

\rSec2[bad.exception]{Class \tcode{bad_exception}}

\indexlibrary{\idxcode{bad_exception}}%
\begin{codeblock}
namespace std {
  class bad_exception : public exception {
  public:
    bad_exception() noexcept;
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
    virtual const char* what() const noexcept;
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_exception}
defines the type of objects thrown as
described in~(\ref{except.unexpected}).

\indexlibrary{\idxcode{bad_exception}!\tcode{bad_exception}}%
\begin{itemdecl}
bad_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_exception}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_exception}!\tcode{bad_exception}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_exception}}%
\begin{itemdecl}
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_exception}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_exception}}%
\begin{itemdecl}
virtual const char* what() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_exception::what}} \ntbs.%
\indexlibrary{\idxcode{bad_exception::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{string.classes}, \ref{locale.codecvt}).
\end{itemdescr}

\rSec2[exception.terminate]{Abnormal termination}

\rSec3[terminate.handler]{Type \tcode{terminate_handler}}

\indexlibrary{\idxcode{terminate_handler}}%
\begin{itemdecl}
typedef void (*terminate_handler)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{std::terminate()}
\indexlibrary{\idxcode{terminate}}%
when terminating exception processing.

\pnum
\required
A \tcode{terminate_handler} shall
terminate execution of the program without returning to the caller.

\pnum
\default
The implementation's default \tcode{terminate_handler} calls
\tcode{abort()}.%
\indexlibrary{\idxcode{abort}}
\end{itemdescr}

\rSec3[set.terminate]{\tcode{set_terminate}}

\indexlibrary{\idxcode{set_terminate}}%
\begin{itemdecl}
terminate_handler set_terminate(terminate_handler f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{f} as the current
handler function for terminating exception processing.

\pnum
\remarks It is unspecified whether a null pointer value designates the default
\tcode{terminate_handler}.

\pnum
\returns
The previous \tcode{terminate_handler}.
\end{itemdescr}

\rSec3[get.terminate]{\tcode{get_terminate}}

\begin{itemdecl}
terminate_handler get_terminate() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The current \tcode{terminate_handler}.
\enternote This may be a null pointer value. \exitnote
\end{itemdescr}

\rSec3[terminate]{\tcode{terminate}}

\indexlibrary{\idxcode{terminate}}%
\begin{itemdecl}
[[noreturn]] void terminate() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Called by the implementation when exception
handling must be abandoned for any of several reasons~(\ref{except.terminate}),
in effect immediately after throwing the exception.
May also be called directly by the program.

\pnum
\effects
Calls the current \tcode{terminate_handler} function. \enternote A
default \tcode{terminate_handler} is always considered a callable handler in
this context. \exitnote
\end{itemdescr}

\rSec2[uncaught]{\tcode{uncaught_exception}}

\indexlibrary{\idxcode{uncaught_exception}}%
\begin{itemdecl}
bool uncaught_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
after
the current thread has initialized
an exception object~(\ref{except.throw})
until a handler for the exception (including \tcode{std::unexpected()}
or \tcode{std::terminate()}) is activated~(\ref{except.handle}).
\enternote
This includes stack unwinding~(\ref{except.ctor}).
\exitnote

\pnum
\notes
When
\tcode{uncaught_exception()}
returns
\tcode{true},
throwing an exception can result in a call of
\tcode{std::terminate()}~(\ref{except.terminate}).
\end{itemdescr}

\rSec2[propagation]{Exception propagation}

\indexlibrary{\idxcode{exception_ptr}}
\begin{itemdecl}
typedef @\unspec@ exception_ptr;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type exception_ptr can be used to refer to an exception object.

\pnum
\tcode{exception_ptr} shall satisfy the requirements of
\tcode{NullablePointer}~(\ref{nullablepointer.requirements}).

\pnum
Two non-null values of type \tcode{exception_ptr} are equivalent and compare equal if and
only if they refer to the same exception.

\pnum
The default constructor of \tcode{exception_ptr} produces the null value of the
type.

\pnum
\tcode{exception_ptr} shall not be implicitly convertible to any arithmetic,
enumeration, or pointer type.

\pnum
\enternote An implementation might use a reference-counted smart
pointer as \tcode{exception_ptr}. \exitnote

\pnum
For purposes of determining the presence of a data race, operations on
\tcode{exception_ptr} objects shall access and modify only the
\tcode{exception_ptr} objects themselves and not the exceptions they refer to.
Use of \tcode{rethrow_exception} on \tcode{exception_ptr} objects that refer to
the same exception object shall not introduce a data race. \enternote if
\tcode{rethrow_exception} rethrows the same exception object (rather than a copy),
concurrent access to that rethrown exception object may introduce a data race.
Changes in the number of \tcode{exception_ptr} objects that refer to a
particular exception do not introduce a data race. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{current_exception}}
\begin{itemdecl}
exception_ptr current_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An \tcode{exception_ptr} object that refers to
the currently handled exception~(\ref{except.handle}) or a copy of the currently
handled exception, or a null \tcode{exception_ptr} object if no exception is being
handled. The referenced object shall remain valid at least as long as there is an
\tcode{exception_ptr} object that refers to it.
If the function needs to allocate memory and the attempt fails, it returns an
\tcode{exception_ptr} object that refers to an instance of \tcode{bad_alloc}.
It is unspecified whether the return values of two successive calls to
\tcode{current_exception} refer to the same exception object.
\enternote That is, it is unspecified whether \tcode{current_exception}
creates a new copy each time it is called. \exitnote
If the attempt to copy the current exception object throws an exception, the function
returns an \tcode{exception_ptr} object that refers to the thrown exception or,
if this is not possible, to an instance of \tcode{bad_exception}. \enternote The
copy constructor of the thrown exception may also fail, so the implementation is allowed
to substitute a \tcode{bad_exception} object to avoid infinite
recursion.\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{rethrow_exception}}
\begin{itemdecl}
[[noreturn]] void rethrow_exception(exception_ptr p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be a null pointer.

\pnum
\throws the exception object to which \tcode{p} refers.
\end{itemdescr}

\indexlibrary{\idxcode{make_exception_ptr}}
\begin{itemdecl}
template<class E> exception_ptr make_exception_ptr(E e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Creates an \tcode{exception_ptr} object that refers to a copy of \tcode{e}, as if
\begin{codeblock}
try {
  throw e;
} catch(...) {
  return current_exception();
}
\end{codeblock}

\pnum
\enternote This function is provided for convenience and
efficiency reasons. \exitnote
\end{itemdescr}

\rSec2[except.nested]{\tcode{nested_exception}}

\indexlibrary{\idxcode{nested_exception}}%
\begin{codeblock}
namespace std {
  class nested_exception {
  public:
    nested_exception() noexcept;
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    exception_ptr nested_ptr() const noexcept;
  };

  [[noreturn]] template<class T> void throw_with_nested(T&& t);
  template <class E> void rethrow_if_nested(const E& e);
}
\end{codeblock}

\pnum
The class \tcode{nested_exception} is designed for use as a mixin through
multiple inheritance. It captures the currently handled exception and stores it
for later use.

\pnum
\enternote \tcode{nested_exception} has a virtual destructor to make it a
polymorphic class. Its presence can be tested for with \tcode{dynamic_cast}.
\exitnote

\indexlibrary{\idxcode{nested_exception}!\idxcode{nested_exception}}
\indexlibrary{\idxcode{nested_exception}!\idxcode{nested_exception}}
\begin{itemdecl}
nested_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The constructor calls \tcode{current_exception()} and stores the returned value.
\end{itemdescr}

\indexlibrary{\idxcode{rethrow_nested}!\idxcode{nested_exception}}
\indexlibrary{\idxcode{nested_exception}!\idxcode{rethrow_nested}}
\begin{itemdecl}
[[noreturn]] void rethrow_nested() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{nested_ptr()} returns a null pointer, the function calls \tcode{std::terminate()}.
Otherwise, it throws the stored exception captured by \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{nested_ptr}!\idxcode{nested_exception}}
\indexlibrary{\idxcode{nested_exception}!\idxcode{nested_ptr}}
\begin{itemdecl}
exception_ptr nested_ptr() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored exception captured by this \tcode{nested_exception} object.
\end{itemdescr}

\indexlibrary{\idxcode{throw_with_nested}!\idxcode{nested_exception}}
\indexlibrary{\idxcode{nested_exception}!\idxcode{throw_with_nested}}
\begin{itemdecl}
[[noreturn]] template <class T> void throw_with_nested(T&& t);
\end{itemdecl}

\begin{itemdescr}
Let \tcode{U} be \tcode{remove_reference<T>::type}.

\pnum
\requires \tcode{U} shall be \tcode{CopyConstructible}.

\pnum
\throws
if \tcode{U} is a non-union class type not derived from
\tcode{nested_exception}, an exception of unspecified type that is publicly derived from both
\tcode{U} and \tcode{nested_exception}
and constructed from \tcode{std::forward<T>(t)}, otherwise
\tcode{std::forward<T>(t)}.
\end{itemdescr}

\indexlibrary{\idxcode{rethrow_if_nested}!\idxcode{nested_exception}}
\indexlibrary{\idxcode{nested_exception}!\idxcode{rethrow_if_nested}}
\begin{itemdecl}
template <class E> void rethrow_if_nested(const E& e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the dynamic type of \tcode{e} is publicly and unambiguously derived from
\tcode{nested_exception}, calls
\tcode{dynamic_cast<const} \tcode{nested_exception\&>(e).rethrow_nested()}.
\end{itemdescr}


\rSec1[support.initlist]{Initializer lists}

\indextext{\idxhdr{initializer\_list}}%
\indexlibrary{\idxhdr{initializer_list}}%
\pnum
The header \tcode{<initializer_list>} defines one type.

\synopsis{Header \tcode{<initializer_list>} synopsis}

\indexlibrary{\idxcode{initializer_list}}%
\indexlibrary{\idxcode{begin}}%
\indexlibrary{\idxcode{end}}%
\begin{codeblock}
namespace std {
  template<class E> class initializer_list {
  public:
    typedef E value_type;
    typedef const E& reference;
    typedef const E& const_reference;
    typedef size_t size_type;

    typedef const E* iterator;
    typedef const E* const_iterator;

    constexpr initializer_list() noexcept;

    constexpr size_t size() const noexcept;      // number of elements
    constexpr const E* begin() const noexcept;   // first element
    constexpr const E* end() const noexcept;     // one past the last element
  };

  // \ref{support.initlist.range} initializer list range access
  template<class E> constexpr const E* begin(initializer_list<E> il) noexcept;
  template<class E> constexpr const E* end(initializer_list<E> il) noexcept;
}
\end{codeblock}

\pnum
An object of type \tcode{initializer_list<E>} provides access to an array of
objects of type \tcode{const E}. \enternote A pair of pointers or a pointer plus
a length would be obvious representations for \tcode{initializer_list}.
\tcode{initializer_list} is used to implement initializer lists as specified
in~\ref{dcl.init.list}. Copying an initializer list does not copy the underlying
elements. \exitnote

\rSec2[support.initlist.cons]{Initializer list constructors}

\indexlibrary{\idxcode{initializer_list}!\idxcode{initializer_list}}
\indexlibrary{\idxcode{initializer_list}!\idxcode{initializer_list}}
\begin{itemdecl}
constexpr initializer_list() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects constructs an empty \tcode{initializer_list} object.

\pnum
\postcondition \tcode{size() == 0}
\end{itemdescr}

\rSec2[support.initlist.access]{Initializer list access}

\indexlibrary{\idxcode{begin}!\idxcode{initializer_list}}
\indexlibrary{\idxcode{initializer_list}!\idxcode{begin}}
\begin{itemdecl}
constexpr const E* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A pointer to the beginning of the array. If \tcode{size() == 0} the
values of \tcode{begin()} and \tcode{end()} are unspecified but they shall be
identical.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{initializer_list}}
\indexlibrary{\idxcode{initializer_list}!\idxcode{end}}
\begin{itemdecl}
constexpr const E* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{begin() + size()}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{initializer_list}}
\indexlibrary{\idxcode{initializer_list}!\idxcode{size}}
\begin{itemdecl}
constexpr size_t size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The number of elements in the array.

\pnum
\complexity constant time.
\end{itemdescr}

\rSec2[support.initlist.range]{Initializer list range access}

\indexlibrary{\idxcode{begin(initializer_list<E>)}}
\begin{itemdecl}
template<class E> constexpr const E* begin(initializer_list<E> il) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{il.begin()}.
\end{itemdescr}

\indexlibrary{\idxcode{end(initializer_list<E>)}}
\begin{itemdecl}
template<class E> constexpr const E* end(initializer_list<E> il) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{il.end()}.
\end{itemdescr}

\rSec1[support.runtime]{Other runtime support}

\pnum
\indexlibrary{\idxhdr{cstdarg}}%
\indexlibrary{\idxhdr{csetjmp}}%
\indexlibrary{\idxhdr{ctime}}%
\indexlibrary{\idxhdr{csignal}}%
\indexlibrary{\idxhdr{cstdlib}}%
\indexlibrary{\idxhdr{cstdbool}}%
\indexlibrary{\idxcode{clock}}%
\indexlibrary{\idxcode{time}}%
\indexlibrary{\idxcode{getenv}}%
\indexlibrary{\idxcode{system}}%
\indexlibrary{\idxcode{__bool_true_false_are_defined}}%
Headers
\tcode{<csetjmp>} (nonlocal jumps),
\tcode{<csignal>} (signal handling),
\tcode{<cstdalign> (alignment),}
\tcode{<cstdarg>} (variable arguments),
\tcode{<cstdbool>} (\tcode{\xname{bool_true_false_are_defined}}).
\tcode{<cstdlib>} (runtime environment \tcode{getenv(), system()}),
and
\tcode{<ctime>} (system clock \tcode{clock(), time()})
provide further compatibility with C code.

\pnum
\indexlibrary{\idxhdr{stdarg.h}}%
\indexlibrary{\idxhdr{setjmp.h}}%
\indexlibrary{\idxhdr{time.h}}%
\indexlibrary{\idxhdr{signal.h}}%
\indexlibrary{\idxhdr{stdlib.h}}%
The contents of these headers are the same as the Standard C library headers
\tcode{<setjmp.h>},
\tcode{<signal.h>},
\tcode{<stdalign.h>},
\tcode{<stdarg.h>},
\tcode{<stdbool.h>},
\tcode{<stdlib.h>},
and
\tcode{<time.h>},
respectively, with the following changes:

\pnum
The restrictions that ISO C places on the second parameter to the
\indexlibrary{\idxcode{va_start}}%
\tcode{va_start()}
macro in header
\indexlibrary{\idxhdr{staarg.h}}%
\tcode{<stdarg.h>}
are different in this International Standard.
The parameter
\tcode{parmN}
is the identifier of the rightmost parameter in the variable parameter list
of the function definition (the one just before the
\tcode{...}).\footnote{Note that
\tcode{va_start}
is required to work as specified even if unary
\tcode{operator\&}
is overloaded for the type of
\tcode{parmN}.}
If the parameter
\tcode{parmN}
is of a reference type, or of a type that is not compatible with the
type that results when passing an argument for which there is no
parameter, the behavior is undefined.

\xref ISO C~4.8.1.1.

\pnum
The function signature
\indexlibrary{\idxcode{longjmp}}%
\tcode{longjmp(jmp_buf jbuf, int val)}
has more restricted behavior in this International Standard.
A \tcode{setjmp}/\tcode{longjmp} call pair has undefined
behavior if replacing the \tcode{setjmp} and \tcode{longjmp}
by \tcode{catch} and \tcode{throw} would invoke any non-trivial destructors for any automatic
objects.

\xref ISO C~7.10.4, 7.8, 7.6, 7.12.

\pnum
Calls to the function
\indexlibrary{\idxcode{getenv}}%
\tcode{getenv} shall not introduce a data
race~(\ref{res.on.data.races}) provided that nothing modifies the environment.
\enternote Calls to the POSIX functions
\indexlibrary{\idxcode{setenv}}%
\tcode{setenv} and
\indexlibrary{\idxcode{putenv}}%
\tcode{putenv} modify the
environment. \exitnote

\pnum
A call to the \tcode{setlocale} function may introduce a data race with other
calls to the \tcode{setlocale} function or with calls to functions that are
affected by the current C locale. The implementation shall behave as if no
library function other than \tcode{locale::global()} calls the \tcode{setlocale}
function.

\pnum
\indexlibrary{\idxhdr{cstdalign}}%
\indexlibrary{\idxhdr{stdalign.h}}%
The header \tcode{<cstdalign>} and the header \tcode{<stdalign.h>} shall not
define a macro named \tcode{alignas}.

\pnum
\indexlibrary{\idxhdr{cstdbool}}%
\indexlibrary{\idxhdr{stdbool.h}}%
The header \tcode{<cstdbool>} and the header \tcode{<stdbool.h>} shall not
define macros named \tcode{bool}, \tcode{true}, or \tcode{false}.

\pnum
The common subset of the C and \Cpp languages consists of all declarations,
definitions, and expressions that may appear in a well formed \Cpp program
and also in a conforming C program.
A
\indextext{POF}%
\indextext{function!plain old}%
POF (``plain old function'') is a function that uses only features from
this common subset, and that does not directly or indirectly use any
function that is not a POF, except that it may use functions defined
in Clause~\ref{atomics} that are not member functions.
All signal handlers shall have C linkage.
A POF that could be used as a signal handler in a conforming C program
does not produce undefined behavior when used as a signal handler in a
\Cpp program.
The behavior of any other function used as a signal handler in a
\Cpp program is \impldef{use of non-POF function as signal handler}.\footnote{In
particular, a signal handler using exception handling is very likely to
have problems. Also, invoking \tcode{std::exit} may cause destruction of objects,
including those of the standard library implementation, which, in general, yields
undefined behavior in a signal handler (see~\ref{intro.execution}).}

\indexlibrary{\idxhdr{csetjmp}}%
\indexlibrary{\idxcode{setjmp}}%
\indexlibrary{\idxcode{jmp_buf}}%
\indexlibrary{\idxcode{longjmp}}%
\begin{libsyntabf2}{csetjmp}{tab:support.hdr.csetjmp}
\macro      &   \tcode{setjmp}  \\ \rowsep
\type       &   \tcode{jmp_buf} \\ \rowsep
\function   &   \tcode{longjmp} \\
\end{libsyntabf2}

\indexlibrary{\idxhdr{csignal}}%
\indexlibrary{\idxcode{SIG_IGN}}%
\indexlibrary{\idxcode{SIGABRT}}%
\indexlibrary{\idxcode{SIGFPE}}%
\indexlibrary{\idxcode{sig_atomic_t}}%
\indexlibrary{\idxcode{raise}}%
\indexlibrary{\idxcode{SIGILL}}%
\indexlibrary{\idxcode{SIGINT}}%
\indexlibrary{\idxcode{signal}}%
\indexlibrary{\idxcode{SIGSEGV}}%
\indexlibrary{\idxcode{SIGTERM}}%
\indexlibrary{\idxcode{SIG_DFL}}%
\indexlibrary{\idxcode{SIG_ERR}}%
\begin{libsyntabf5}{csignal}{tab:support.hdr.csignal}
\macros             &   \tcode{SIGABRT} &   \tcode{SIGILL}  &   \tcode{SIGSEGV} &   \tcode{SIG_DFL} \\
\tcode{SIG_IGN}     &   \tcode{SIGFPE}  &   \tcode{SIGINT}  &   \tcode{SIGTERM} &   \tcode{SIG_ERR} \\ \rowsep
\type               &   \tcode{sig_atomic_t}    &           &                   &                   \\ \rowsep
\functions          &   \tcode{raise}   &   \tcode{signal}  &                   &                   \\
\end{libsyntabf5}

\indexlibrary{\idxhdr{cstdalign}}%
\indexlibrary{\idxcode{__alignas_is_defined}}%
\begin{libsyntabf2}{cstdalign}{tab:support.hdr.cstdalign}
\macro  & \tcode{__alignas_is_defined} \\
\end{libsyntabf2}

\indexlibrary{\idxhdr{cstdarg}}%
\indexlibrary{\idxcode{va_arg}}%
\indexlibrary{\idxcode{va_end}}%
\indexlibrary{\idxcode{va_start}}%
\indexlibrary{\idxcode{va_copy}}%
\indexlibrary{\idxcode{va_list}}%
\begin{libsyntabf4}{cstdarg}{tab:support.hdr.cstdarg}
\macros &   \tcode{va_arg}      &   \tcode{va_end}  &   \tcode{va_start}    \\
\tcode{va_copy} &            &                   &                       \\
\rowsep
\type   &   \tcode{va_list}       &                     &                       \\
\end{libsyntabf4}

\indexlibrary{\idxhdr{cstdbool}}%
\indexlibrary{\idxcode{__bool_true_false_are_defined}}%
\begin{libsyntabf2}{cstdbool}{tab:support.hdr.cstdbool}
\macro  & \tcode{__bool_true_false_are_defined} \\
\end{libsyntabf2}

\indexlibrary{\idxhdr{cstdlib}}%
\indexlibrary{\idxcode{getenv}}%
\indexlibrary{\idxcode{system}}%
\begin{libsyntabf3}{cstdlib}{tab:support.hdr.cstdlib1}
\functions  &   \tcode{getenv}  &   \tcode{system}  \\
\end{libsyntabf3}

\indexlibrary{\idxhdr{ctime}}%
\indexlibrary{\idxcode{CLOCKS_PER_SEC}}%
\indexlibrary{\idxcode{clock_t}}%
\indexlibrary{\idxcode{clock}}%
\begin{libsyntabf2}{ctime}{tab:support.hdr.ctime}
\macro      &   \tcode{CLOCKS_PER_SEC}  \\ \rowsep
\type       &   \tcode{clock_t}         \\ \rowsep
\function   &   \tcode{clock}           \\
\end{libsyntabf2}
\vfill\pagebreak
