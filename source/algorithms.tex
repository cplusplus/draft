%!TEX root = std.tex
\rSec0[algorithms]{Algorithms library}

\rSec1[algorithms.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to perform
algorithmic operations on containers\iref{containers} and other sequences.

\pnum
The following subclauses describe components for
non-modifying sequence operations,
mutating sequence operations,
sorting and related operations,
and algorithms from the C library,
as summarized in \tref{algorithms.summary}.

\begin{libsumtab}{Algorithms library summary}{algorithms.summary}
\ref{algorithms.requirements}  & Algorithms requirements           & \\
\ref{algorithms.parallel}      & Parallel algorithms               & \tcode{<execution>}    \\ \rowsep
\ref{algorithms.results}       & Algorithm result types            & \tcode{<algorithm>}    \\
\ref{alg.nonmodifying}         & Non-modifying sequence operations & \\
\ref{alg.modifying.operations} & Mutating sequence operations      & \\
\ref{alg.sorting}              & Sorting and related operations    & \\ \rowsep
\ref{numeric.ops}              & Generalized numeric operations    & \tcode{<numeric>}      \\ \rowsep
\ref{specialized.algorithms}   & Specialized \tcode{<memory>} algorithms & \tcode{<memory>} \\ \rowsep
\ref{alg.rand}                 & Specialized \tcode{<random>} algorithms & \tcode{<random>} \\ \rowsep
\ref{alg.c.library}            & C library algorithms              & \tcode{<cstdlib>}      \\
\end{libsumtab}

\rSec1[algorithms.requirements]{Algorithms requirements}
\pnum
All of the algorithms
are separated from the particular implementations of data structures and
are parameterized by iterator types.
Because of this, they can work with program-defined data structures,
as long as these data structures have iterator types
satisfying the assumptions on the algorithms.

\pnum
The entities defined in the \tcode{std::ranges} namespace in this Clause and
specified as function templates are
algorithm function objects\iref{alg.func.obj}.

\pnum
For purposes of determining the existence of data races,
algorithms shall not modify objects referenced through an iterator argument
unless the specification requires such modification.

\pnum
Throughout this Clause, where the template parameters are not constrained,
the names of template parameters are used to express type requirements.
\begin{itemize}
\item
  If an algorithm's \Fundescx{Effects} element specifies
  that a value pointed to by any iterator passed as an argument is modified,
  then the type of that argument shall meet
  the requirements of a mutable iterator\iref{iterator.requirements}.
\item
  If an algorithm's template parameter is named
  \tcode{InputIterator},
  \tcode{InputIterator1}, or
  \tcode{Input\-Iterator2},
  the template argument shall meet the
  \oldconcept{InputIterator} requirements\iref{input.iterators}.
\item
  If an algorithm's template parameter is named
  \tcode{OutputIterator},
  \tcode{OutputIterator1}, or
  \tcode{Output\-Iterator2},
  the template argument shall meet the
  \oldconcept{OutputIterator} requirements\iref{output.iterators}.
\item
  If an algorithm's template parameter is named
  \tcode{ForwardIterator},
  \tcode{ForwardIterator1},
  \tcode{ForwardItera\-tor2}, or
  \tcode{NoThrowForwardIterator},
  the template argument shall meet the
  \oldconcept{ForwardIterator} requirements\iref{forward.iterators}
  if it is required to be a mutable iterator, or
  model \libconcept{forward_iterator}\iref{iterator.concept.forward} otherwise.
\item
  If an algorithm's template parameter is named
  \tcode{NoThrowForwardIterator},
  the template argument
  is also required to have the property that no exceptions are thrown
  from increment, assignment, or comparison of, or
  indirection through, valid iterators.
\item
  If an algorithm's template parameter is named
  \tcode{BidirectionalIterator},
  \tcode{Bidirectional\-Iterator1}, or
  \tcode{BidirectionalIterator2},
  the template argument shall meet the
  \oldconcept{BidirectionalIterator} requirements\iref{bidirectional.iterators}
  if it is required to be a mutable iterator, or model
  \libconcept{bidirectional_iterator}\iref{iterator.concept.bidir} otherwise.
\item
  If an algorithm's template parameter is named
  \tcode{RandomAccessIterator},
  \tcode{Random\-AccessIterator1}, or
  \tcode{RandomAccessIterator2},
  the template argument shall meet the
  \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}
  if it is required to be a mutable iterator, or model
  \libconcept{random_access_iterator}\iref{iterator.concept.random.access} otherwise.
\end{itemize}
\begin{note}
These requirements do not affect iterator arguments that are constrained,
for which iterator category and mutability requirements
are expressed explicitly.
\end{note}

\pnum
Both in-place and copying versions are provided for certain algorithms.
\begin{footnote}
The decision whether to include a copying version was
usually based on complexity considerations.
When the cost of doing the operation dominates the cost of copy,
the copying version is not included.
For example, \tcode{sort_copy} is not included
because the cost of sorting is much more significant,
and users can invoke \tcode{copy} followed by \tcode{sort}.
\end{footnote}
When such a version is provided for \textit{algorithm} it is called
\textit{algorithm\tcode{_copy}}.
Algorithms that take predicates end with the suffix \tcode{_if}
(which follows the suffix \tcode{_copy}).

\pnum
When not otherwise constrained, the \tcode{Predicate} parameter is used
whenever an algorithm expects a function object\iref{function.objects} that,
when applied to the result of dereferencing the corresponding iterator,
returns a value testable as \tcode{true}.
If an algorithm takes \tcode{Predicate pred} as its argument and
\tcode{first} as its iterator argument with value type \tcode{T},
the expression \tcode{pred(*first)} shall be well-formed and
the type \tcode{decltype(pred(*first))} shall model
\exposconcept{boolean-testable}\iref{concept.booleantestable}.
The function object \tcode{pred} shall not apply any non-constant function
through its argument.
Given a glvalue \tcode{u} of type (possibly const) \tcode{T}
that designates the same object as \tcode{*first},
\tcode{pred(u)} shall be a valid expression
that is equal to \tcode{pred(*first)}.

\pnum
When not otherwise constrained, the \tcode{BinaryPredicate} parameter is used
whenever an algorithm expects a function object that, when applied
to the result of dereferencing two corresponding iterators or
to dereferencing an iterator and type \tcode{T}
when \tcode{T} is part of the signature,
returns a value testable as \tcode{true}.
If an algorithm takes \tcode{BinaryPredicate binary_pred} as its argument and
\tcode{first1} and \tcode{first2} as its iterator arguments
with respective value types \tcode{T1} and \tcode{T2},
the expression \tcode{binary_pred(*first1, *first2)} shall be well-formed and
the type \tcode{decltype(binary_pred(*first1, *first2))} shall model
\exposconcept{boolean-testable}.
Unless otherwise specified,
\tcode{BinaryPredicate} always takes the first iterator's \tcode{value_type}
as its first argument, that is, in those cases when \tcode{T value}
is part of the signature,
the expression \tcode{binary_pred(*first1, value)} shall be well-formed and
the type \tcode{decltype(binary_pred(*first1, value))} shall model
\exposconcept{boolean-testable}.
\tcode{binary_pred} shall not apply any non-constant function
through any of its arguments.
Given a glvalue \tcode{u} of type (possibly const) \tcode{T1}
that designates the same object as \tcode{*first1}, and
a glvalue \tcode{v} of type (possibly const) \tcode{T2}
that designates the same object as \tcode{*first2},
\tcode{binary_pred(u, *first2)},
\tcode{binary_pred(*first1, v)}, and
\tcode{binary_pred(u, v)}
shall each be a valid expression that is equal to
\tcode{binary_pred(*first1, *first2)}, and
\tcode{binary_pred(u, value)}
shall be a valid expression that is equal to
\tcode{binary_pred(*first1, value)}.

\pnum
The parameters
\tcode{UnaryOperation},
\tcode{BinaryOperation},
\tcode{BinaryOperation1},
and \tcode{BinaryOperation2}
are used
whenever an algorithm expects a function object\iref{function.objects}.

\pnum
\begin{note}
Unless otherwise specified, algorithms that take function objects as arguments
can copy those function objects freely.
If object identity is important,
a wrapper class that points to a non-copied implementation object
such as \tcode{reference_wrapper<T>}\iref{refwrap}, or some equivalent solution,
can be used.
\end{note}

\pnum
When the description of an algorithm gives an expression such as
\tcode{*first == value} for a condition, the expression
shall evaluate to either \tcode{true} or \tcode{false} in boolean contexts.

\pnum
In the description of the algorithms, operator \tcode{+}
is used for some of the iterator categories
for which it does not have to be defined.
In these cases the semantics of \tcode{a + n} are the same as those of
\begin{codeblock}
auto tmp = a;
for (; n < 0; ++n) --tmp;
for (; n > 0; --n) ++tmp;
return tmp;
\end{codeblock}
Similarly, operator \tcode{-} is used
for some combinations of iterators and sentinel types
for which it does not have to be defined.
If \range{a}{b} denotes a range,
the semantics of \tcode{b - a} in these cases are the same as those of
\begin{codeblock}
iter_difference_t<decltype(a)> n = 0;
for (auto tmp = a; tmp != b; ++tmp) ++n;
return n;
\end{codeblock}
and if \range{b}{a} denotes a range, the same as those of
\begin{codeblock}
iter_difference_t<decltype(b)> n = 0;
for (auto tmp = b; tmp != a; ++tmp) --n;
return n;
\end{codeblock}

\pnum
In the description of the algorithms,
given an iterator \tcode{a} whose difference type is \tcode{D}, and
an expression \tcode{n} of integer-like type other than \cv{} \tcode{D},
the semantics of \tcode{a + n} and \tcode{a - n} are, respectively,
those of \tcode{a + D(n)} and \tcode{a - D(n)}.

\pnum
In the description of algorithm return values,
a sentinel value \tcode{s} denoting the end of a range \range{i}{s}
is sometimes returned where an iterator is expected.
In these cases,
the semantics are as if the sentinel is converted into an iterator using
\tcode{ranges::next(i, s)}.

\pnum
Overloads of algorithms that take \libconcept{range} arguments\iref{range.range}
behave as if they are implemented by calling \tcode{ranges::begin} and
\tcode{ranges::end} on the \libconcept{range}(s) and
dispatching to the overload in namespace \tcode{ranges}
that takes separate iterator and sentinel arguments.

\pnum
The well-formedness and behavior of a call to an algorithm with
an explicitly-specified template argument list
is unspecified, except where explicitly stated otherwise.
\begin{note}
Consequently, an implementation can declare an algorithm with
different template parameters than those presented.
\end{note}

\rSec1[algorithms.parallel]{Parallel algorithms}

\rSec2[algorithms.parallel.defns]{Preamble}
\pnum
Subclause \ref{algorithms.parallel} describes components that \Cpp{} programs may use
to perform operations on containers and other sequences in parallel.

\pnum
A \defn{parallel algorithm} is a function template listed in this document
with a template parameter named \tcode{ExecutionPolicy}.

\pnum
Parallel algorithms access objects indirectly accessible via their arguments
by invoking the following functions:
\begin{itemize}
\item
  All operations of the categories of the iterators or \tcode{mdspan} types
  that the algorithm is instantiated with.
\item
  Operations on those sequence elements that are required by its specification.
\item
  User-provided function objects
  to be applied during the execution of the algorithm,
  if required by the specification.
\item
  Operations on those function objects required by the specification.
\begin{note}
See~\ref{algorithms.requirements}.
\end{note}
\end{itemize}
These functions are herein called \defn{element access functions}.

\pnum
\begin{example}
The \tcode{sort} function may invoke the following element access functions:
\begin{itemize}
\item
  Operations of the random-access iterator of the actual template argument
  (as per \ref{random.access.iterators}),
  as implied by the name of the template parameter \tcode{RandomAccessIterator}.
\item
  The \tcode{swap} function on the elements of the sequence
  (as per the preconditions specified in \ref{sort}).
\item
  The user-provided \tcode{Compare} function object.
\end{itemize}
\end{example}

\pnum
A standard library function is \defn{vectorization-unsafe}
if it is specified to synchronize with another function invocation, or
another function invocation is specified to synchronize with it,
and if it is not a memory allocation or deallocation function.
\begin{note}
Implementations must ensure that internal synchronization
inside standard library functions does not prevent forward progress
when those functions are executed by threads of execution
with weakly parallel forward progress guarantees.
\end{note}
\begin{example}
\begin{codeblock}
int x = 0;
std::mutex m;
void f() {
  int a[] = {1,2};
  std::for_each(std::execution::par_unseq, std::begin(a), std::end(a), [&](int) {
    std::lock_guard<mutex> guard(m);            // incorrect: \tcode{lock_guard} constructor calls \tcode{m.lock()}
    ++x;
  });
}
\end{codeblock}
The above program may result in two consecutive calls to \tcode{m.lock()}
on the same thread of execution (which may deadlock),
because the applications of the function object are not guaranteed
to run on different threads of execution.
\end{example}

\rSec2[algorithms.parallel.user]{Requirements on user-provided function objects}

\pnum
Unless otherwise specified,
function objects passed into parallel algorithms as objects of type
\tcode{Predicate},
\tcode{BinaryPredicate},
\tcode{Compare},
\tcode{UnaryOperation},
\tcode{BinaryOperation},
\tcode{BinaryOperation1},
\tcode{BinaryOperation2},
\tcode{BinaryDivideOp}, and
the operators used by the analogous overloads to these parallel algorithms
that are formed by an invocation
with the specified default predicate or operation (where applicable)
shall not directly or indirectly modify objects via their arguments,
nor shall they rely on the identity of the provided objects.

\rSec2[algorithms.parallel.exec]{Effect of execution policies on algorithm execution}

\pnum
Parallel algorithms have
template parameters named \tcode{ExecutionPolicy}\iref{execpol}
which describe the manner in which the execution of these algorithms may be
parallelized and the manner in which they apply the element access functions.

\pnum
If an object is modified by an element access function,
the algorithm will perform no other unsynchronized accesses to that object.
The modifying element access functions are those
which are specified as modifying the object.
\begin{note}
For example,
\tcode{swap},
\tcode{++},
\tcode{--},
\tcode{@=}, and
assignments
modify the object.
For the assignment and \tcode{@=} operators, only the left argument is modified.
\end{note}

\pnum
Unless otherwise stated, implementations may make arbitrary copies of elements
(with type \tcode{T}) from sequences
where \tcode{is_trivially_copy_constructible_v<T>}
and \tcode{is_trivially_destructible_v<T>} are \tcode{true}.
\begin{note}
This implies that user-supplied function objects cannot rely on
object identity of arguments for such input sequences.
If object identity of the arguments to these function objects
is important, a wrapping iterator
that returns a non-copied implementation object
such as \tcode{reference_wrapper<T>}\iref{refwrap},
or some equivalent solution, can be used.
\end{note}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::sequenced_policy} all occur
in the calling thread of execution.
\begin{note}
The invocations are not interleaved; see~\ref{intro.execution}.
\end{note}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::unsequenced_policy}
are permitted to execute in an unordered fashion
in the calling thread of execution,
unsequenced with respect to one another in the calling thread of execution.
\begin{note}
This means that multiple function object invocations
can be interleaved on a single thread of execution,
which overrides the usual guarantee from \ref{intro.execution}
that function executions do not overlap with one another.
\end{note}
The behavior of a program is undefined if
it invokes a vectorization-unsafe standard library function
from user code
called from an \tcode{execution::unsequenced_policy} algorithm.
\begin{note}
Because \tcode{execution::unsequenced_policy} allows
the execution of element access functions
to be interleaved on a single thread of execution,
blocking synchronization, including the use of mutexes, risks deadlock.
\end{note}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::parallel_policy}
are permitted to execute either
in the invoking thread of execution or
in a thread of execution implicitly created by the library
to support parallel algorithm execution.
If the threads of execution created by \tcode{thread}\iref{thread.thread.class}
or \tcode{jthread}\iref{thread.jthread.class}
provide concurrent forward progress guarantees\iref{intro.progress},
then a thread of execution implicitly created by the library will provide
parallel forward progress guarantees;
otherwise, the provided forward progress guarantee is
\impldef{forward progress guarantees for
implicit threads of parallel algorithms (if not defined for \tcode{thread})}.
Any such invocations executing in the same thread of execution
are indeterminately sequenced with respect to each other.
\begin{note}
It is the caller's responsibility to ensure
that the invocation does not introduce data races or deadlocks.
\end{note}
\begin{example}
\begin{codeblock}
int a[] = {0,1};
std::vector<int> v;
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int i) {
  v.push_back(i*2+1);                   // incorrect: data race
});
\end{codeblock}
The program above has a data race because of the unsynchronized access to the
container \tcode{v}.
\end{example}
\begin{example}
\begin{codeblock}
std::atomic<int> x{0};
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
  x.fetch_add(1, std::memory_order::relaxed);
  // spin wait for another iteration to change the value of \tcode{x}
  while (x.load(std::memory_order::relaxed) == 1) { }           // incorrect: assumes execution order
});
\end{codeblock}
The above example depends on the order of execution of the iterations, and
will not terminate if both iterations are executed sequentially
on the same thread of execution.
\end{example}
\begin{example}
\begin{codeblock}
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
  std::lock_guard<mutex> guard(m);
  ++x;
});
\end{codeblock}
The above example synchronizes access to object \tcode{x}
ensuring that it is incremented correctly.
\end{example}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::parallel_unsequenced_policy} are
permitted to execute
in an unordered fashion in unspecified threads of execution, and
unsequenced with respect to one another within each thread of execution.
These threads of execution are
either the invoking thread of execution
or threads of execution implicitly created by the library;
the latter will provide weakly parallel forward progress guarantees.
\begin{note}
This means that multiple function object invocations can be interleaved
on a single thread of execution,
which overrides the usual guarantee from \ref{intro.execution}
that function executions do not overlap with one another.
\end{note}
The behavior of a program is undefined if
it invokes a vectorization-unsafe standard library function
from user code
called from an \tcode{execution::parallel_unsequenced_policy} algorithm.
\begin{note}
Because \tcode{execution::parallel_unsequenced_policy} allows
the execution of element access functions
to be interleaved on a single thread of execution,
blocking synchronization, including the use of mutexes, risks deadlock.
\end{note}

\pnum
\begin{note}
The semantics of invocation with
\tcode{execution::unsequenced_policy},
\tcode{execution::parallel_policy}, or
\tcode{execution::parallel_unsequenced_policy}
allow the implementation to fall back to sequential execution
if the system cannot parallelize an algorithm invocation,
e.g., due to lack of resources.
\end{note}

\pnum
If an invocation of a parallel algorithm uses threads of execution
implicitly created by the library,
then the invoking thread of execution will either
\begin{itemize}
\item
  temporarily block
  with forward progress guarantee delegation\iref{intro.progress}
  on the completion of these library-managed threads of execution, or
\item
  eventually execute an element access function;
\end{itemize}
the thread of execution will continue to do so until the algorithm is finished.
\begin{note}
In blocking with forward progress guarantee delegation in this context,
a thread of execution created by the library
is considered to have finished execution
as soon as it has finished the execution
of the particular element access function
that the invoking thread of execution logically depends on.
\end{note}

\pnum
The semantics of parallel algorithms invoked with an execution policy object of
\impldef{additional execution policies supported by parallel algorithms} type
are \impldef{semantics of parallel algorithms invoked with
imple\-men\-tation-defined execution policies}.

\rSec2[algorithms.parallel.exceptions]{Parallel algorithm exceptions}

\pnum
During the execution of a parallel algorithm,
if temporary memory resources are required for parallelization
and none are available, the algorithm throws a \tcode{bad_alloc} exception.

\pnum
During the execution of a parallel algorithm,
if the invocation of an element access function exits via an uncaught exception,
the behavior is determined by the \tcode{ExecutionPolicy}.

\rSec2[algorithms.parallel.overloads]{\tcode{ExecutionPolicy} algorithm overloads}

\pnum
Parallel algorithms are algorithm overloads.
Each parallel algorithm overload
has an additional template type parameter named \tcode{ExecutionPolicy},
which is the first template parameter.
Additionally, each parallel algorithm overload
has an additional function parameter of type \tcode{ExecutionPolicy\&\&},
which is the first function parameter.
\begin{note}
Not all algorithms have parallel algorithm overloads.
\end{note}

\pnum
Unless otherwise specified,
the semantics of \tcode{ExecutionPolicy} algorithm overloads
are identical to their overloads without.

\pnum
Unless otherwise specified,
the complexity requirements of \tcode{ExecutionPolicy} algorithm overloads
are relaxed from the complexity requirements of the overloads without
as follows:
when the guarantee says ``at most \placeholder{expr}'' or
``exactly \placeholder{expr}''
and does not specify the number of assignments or swaps, and
\placeholder{expr} is not already expressed with \bigoh{} notation,
the complexity of the algorithm shall be \bigoh{\placeholder{expr}}.

\pnum
Parallel algorithms shall not participate in overload resolution unless
\tcode{is_execution_policy_v<remove_cvref_t<ExecutionPolicy>>} is \tcode{true}.

\rSec2[execpol]{Execution policies}

\rSec3[execpol.general]{General}

\pnum
Subclause~\ref{execpol} describes classes that are \defn{execution policy} types. An
object of an execution policy type indicates the kinds of parallelism allowed
in the execution of an algorithm and expresses the consequent requirements on
the element access functions.
Execution policy types are declared in header \libheaderref{execution}.
\begin{example}
\begin{codeblock}
using namespace std;
vector<int> v = @\commentellip@;

// standard sequential sort
sort(v.begin(), v.end());

// explicitly sequential sort
sort(execution::seq, v.begin(), v.end());

// permitting parallel execution
sort(execution::par, v.begin(), v.end());

// permitting vectorization as well
sort(execution::par_unseq, v.begin(), v.end());
\end{codeblock}
\end{example}
\begin{note}
Implementations can provide additional execution policies
to those described in this document as extensions
to address parallel architectures that require idiosyncratic
parameters for efficient execution.
\end{note}

\rSec3[execpol.type]{Execution policy type trait}

\indexlibraryglobal{is_execution_policy}%
\begin{itemdecl}
template<class T> struct is_execution_policy { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{is_execution_policy} can be used to detect execution policies for the
purpose of excluding function signatures from otherwise ambiguous overload
resolution participation.

\pnum
\tcode{is_execution_policy<T>} is a \oldconcept{UnaryTypeTrait} with a
base characteristic of \tcode{true_type} if \tcode{T} is the type of a standard
or \impldef{additional execution policies supported by parallel algorithms}
execution policy, otherwise \tcode{false_type}.

\begin{note}
This provision reserves the privilege of creating non-standard execution
policies to the library implementation.
\end{note}

\pnum
The behavior of a program that adds specializations for
\tcode{is_execution_policy} is undefined.
\end{itemdescr}

\rSec3[execpol.seq]{Sequenced execution policy}

\indexlibraryglobal{execution::sequenced_policy}%
\begin{itemdecl}
class execution::sequenced_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::sequenced_policy} is an execution policy type used
as a unique type to disambiguate parallel algorithm overloading and require
that a parallel algorithm's execution may not be parallelized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::sequenced_policy} policy,
if the invocation of an element access function exits via an exception,
\tcode{terminate} is invoked\iref{except.terminate}.
\end{itemdescr}

\rSec3[execpol.par]{Parallel execution policy}

\indexlibraryglobal{execution::parallel_policy}%
\begin{itemdecl}
class execution::parallel_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::parallel_policy} is an execution policy type used as
a unique type to disambiguate parallel algorithm overloading and indicate that
a parallel algorithm's execution may be parallelized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::parallel_policy} policy,
if the invocation of an element access function exits via an exception,
\tcode{terminate} is invoked\iref{except.terminate}.
\end{itemdescr}

\rSec3[execpol.parunseq]{Parallel and unsequenced execution policy}

\indexlibraryglobal{execution::parallel_unsequenced_policy}%
\begin{itemdecl}
class execution::parallel_unsequenced_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::parallel_unsequenced_policy} is an execution policy type
used as a unique type to disambiguate parallel algorithm overloading and
indicate that a parallel algorithm's execution may be parallelized and
vectorized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::parallel_unsequenced_policy} policy,
if the invocation of an element access function exits via an exception,
\tcode{terminate} is invoked\iref{except.terminate}.
\end{itemdescr}

\rSec3[execpol.unseq]{Unsequenced execution policy}

\indexlibraryglobal{execution::unsequenced_policy}%
\begin{itemdecl}
class execution::unsequenced_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{unsequenced_policy} is an execution policy type
used as a unique type to disambiguate parallel algorithm overloading and
indicate that a parallel algorithm's execution may be vectorized,
e.g., executed on a single thread using instructions
that operate on multiple data items.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::unsequenced_policy} policy,
if the invocation of an element access function exits via an exception,
\tcode{terminate} is invoked\iref{except.terminate}.
\end{itemdescr}

\rSec3[execpol.objects]{Execution policy objects}

\indexlibraryglobal{seq}%
\indexlibraryglobal{par}%
\indexlibraryglobal{par_unseq}%
\indexlibrarymember{execution}{seq}%
\indexlibrarymember{execution}{par}%
\indexlibrarymember{execution}{par_unseq}%
\begin{itemdecl}
inline constexpr execution::sequenced_policy            execution::seq{ @\unspec@ };
inline constexpr execution::parallel_policy             execution::par{ @\unspec@ };
inline constexpr execution::parallel_unsequenced_policy execution::par_unseq{ @\unspec@ };
inline constexpr execution::unsequenced_policy          execution::unseq{ @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The header \libheaderref{execution} declares global objects associated with each type of execution policy.
\end{itemdescr}

\rSec1[algorithm.syn]{Header \tcode{<algorithm>} synopsis}
\indexheader{algorithm}%

\begin{codeblock}
// mostly freestanding
#include <initializer_list>     // see \ref{initializer.list.syn}

namespace std {
  namespace ranges {
    // \ref{algorithms.results}, algorithm result types
    template<class I, class F>
      struct in_fun_result;

    template<class I1, class I2>
      struct in_in_result;

    template<class I, class O>
      struct in_out_result;

    template<class I1, class I2, class O>
      struct in_in_out_result;

    template<class I, class O1, class O2>
      struct in_out_out_result;

    template<class T>
      struct min_max_result;

    template<class I>
      struct in_found_result;

    template<class I, class T>
      struct in_value_result;

    template<class O, class T>
      struct out_value_result;
  }

  // \ref{alg.nonmodifying}, non-modifying sequence operations
  // \ref{alg.all.of}, all of
  template<class InputIterator, class Predicate>
    constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool all_of(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool all_of(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.any.of}, any of
  template<class InputIterator, class Predicate>
    constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool any_of(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool any_of(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.none.of}, none of
  template<class InputIterator, class Predicate>
    constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool none_of(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool none_of(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.contains}, contains
  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr bool contains(I first, S last, const T& value, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>>
      requires
        @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
      constexpr bool contains(R&& r, const T& value, Proj proj = {});

    template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1,
             @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                       Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool contains_subrange(R1&& r1, R2&& r2,
                                       Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.foreach}, for each
  template<class InputIterator, class Function>
    constexpr Function for_each(InputIterator first, InputIterator last, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Function>
    void for_each(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last, Function f);

  namespace ranges {
    template<class I, class F>
      using for_each_result = in_fun_result<I, F>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirectly_unary_invocable}@<projected<I, Proj>> Fun>
      constexpr for_each_result<I, Fun>
        for_each(I first, S last, Fun f, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirectly_unary_invocable}@<projected<iterator_t<R>, Proj>> Fun>
      constexpr for_each_result<borrowed_iterator_t<R>, Fun>
        for_each(R&& r, Fun f, Proj proj = {});
  }

  template<class InputIterator, class Size, class Function>
    constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
    ForwardIterator for_each_n(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Function f);

  namespace ranges {
    template<class I, class F>
      using for_each_n_result = in_fun_result<I, F>;

    template<@\libconcept{input_iterator}@ I, class Proj = identity,
             @\libconcept{indirectly_unary_invocable}@<projected<I, Proj>> Fun>
      constexpr for_each_n_result<I, Fun>
        for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
  }

  // \ref{alg.find}, find
  template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
    constexpr InputIterator find(InputIterator first, InputIterator last,
                                 const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class T = iterator_traits<ForwardIterator>::value_type>
    ForwardIterator find(ExecutionPolicy&& exec,                // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                         ForwardIterator first, ForwardIterator last,
                         const T& value);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                    Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if(ExecutionPolicy&& exec,             // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if_not(ExecutionPolicy&& exec,         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr I find(I first, S last, const T& value, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr borrowed_iterator_t<R>
        find(R&& r, const T& value, Proj proj = {});
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        find_if(R&& r, Pred pred, Proj proj = {});
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        find_if_not(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.find.last}, find last
  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T, class Proj = identity>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class T, class Proj = identity>
      requires
        @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
      constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr subrange<I> find_last_if(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_subrange_t<R> find_last_if(R&& r, Pred pred, Proj proj = {});
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr subrange<I> find_last_if_not(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_subrange_t<R> find_last_if_not(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.find.end}, find end
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_subrange_t<R1>
        find_end(R1&& r1, R2&& r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.find.first.of}, find first
  template<class InputIterator, class ForwardIterator>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template<class InputIterator, class ForwardIterator, class BinaryPredicate>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2,
                    BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{forward_range}@ R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_iterator_t<R1>
        find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.adjacent.find}, adjacent find
  template<class ForwardIterator>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_binary_predicate}@<projected<I, Proj>,
                                       projected<I, Proj>> Pred = ranges::equal_to>
      constexpr I adjacent_find(I first, S last, Pred pred = {},
                                Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_binary_predicate}@<projected<iterator_t<R>, Proj>,
                                       projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
      constexpr borrowed_iterator_t<R>
        adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
  }

  // \ref{alg.count}, count
  template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count(InputIterator first, InputIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class T = iterator_traits<InputIterator>::value_type>
    typename iterator_traits<ForwardIterator>::difference_type
      count(ExecutionPolicy&& exec,                             // freestanding-deleted, see \ref{algorithms.parallel.overloads}
            ForwardIterator first, ForwardIterator last, const T& value);
  template<class InputIterator, class Predicate>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    typename iterator_traits<ForwardIterator>::difference_type
      count_if(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr iter_difference_t<I>
        count(I first, S last, const T& value, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr range_difference_t<R>
        count(R&& r, const T& value, Proj proj = {});
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr iter_difference_t<I>
        count_if(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr range_difference_t<R>
        count_if(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.mismatch}, mismatch
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<class I1, class I2>
      using mismatch_result = in_in_result<I1, I2>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr mismatch_result<I1, I2>
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        mismatch(R1&& r1, R2&& r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.equal}, equal
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.is.permutation}, is permutation
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, BinaryPredicate pred);
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2,
                                  BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2,
             @\libconcept{sentinel_for}@<I2> S2, class Proj1 = identity, class Proj2 = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<I1, Proj1>,
                                           projected<I2, Proj2>> Pred = ranges::equal_to>
      constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
             class Proj1 = identity, class Proj2 = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R1>, Proj1>,
                                           projected<iterator_t<R2>, Proj2>>
                                           Pred = ranges::equal_to>
      constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.search}, search
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      search(ExecutionPolicy&& exec,                            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1
      search(ExecutionPolicy&& exec,                            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2,
             @\libconcept{sentinel_for}@<I2> S2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_subrange_t<R1>
        search(R1&& r1, R2&& r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class ForwardIterator, class Size,
           class T = iterator_traits<ForwardIterator>::value_type>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ForwardIterator, class Size,
           class T = iterator_traits<ForwardIterator>::value_type, class BinaryPredicate>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Size,
           class T = iterator_traits<ForwardIterator>::value_type>
    ForwardIterator
      search_n(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class Size,
           class T = iterator_traits<ForwardIterator>::value_type, class BinaryPredicate>
    ForwardIterator
      search_n(ExecutionPolicy&& exec,                          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             class Pred = ranges::equal_to, class Proj = identity,
             class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirectly_comparable}@<I, const T*, Pred, Proj>
      constexpr subrange<I>
        search_n(I first, S last, iter_difference_t<I> count,
                 const T& value, Pred pred = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Pred = ranges::equal_to,
             class Proj = identity, class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R>, const T*, Pred, Proj>
      constexpr borrowed_subrange_t<R>
        search_n(R&& r, range_difference_t<R> count,
                 const T& value, Pred pred = {}, Proj proj = {});
  }

  template<class ForwardIterator, class Searcher>
    constexpr ForwardIterator
      search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);

  namespace ranges {
    // \ref{alg.starts.with}, starts with
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});

    // \ref{alg.ends.with}, ends with
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires (@\libconcept{forward_iterator}@<I1> || @\libconcept{sized_sentinel_for}@<S1, I1>) &&
               (@\libconcept{forward_iterator}@<I2> || @\libconcept{sized_sentinel_for}@<S2, I2>) &&
               @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
      constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires (@\libconcept{forward_range}@<R1> || @\libconcept{sized_range}@<R1>) &&
               (@\libconcept{forward_range}@<R2> || @\libconcept{sized_range}@<R2>) &&
               @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});

    // \ref{alg.fold}, fold
    template<class F>
    class @\exposid{flipped}@ {     // \expos
      F @\exposid{f}@;              // \expos

    public:
      template<class T, class U> requires @\libconcept{invocable}@<F&, U, T>
      invoke_result_t<F&, U, T> operator()(T&&, U&&);
    };

    template<class F, class T, class I, class U>
      concept @\defexposconcept{indirectly-binary-left-foldable-impl}@ =  // \expos
        @\libconcept{movable}@<T> && @\libconcept{movable}@<U> &&
        @\libconcept{convertible_to}@<T, U> && @\libconcept{invocable}@<F&, U, iter_reference_t<I>> &&
        @\libconcept{assignable_from}@<U&, invoke_result_t<F&, U, iter_reference_t<I>>>;

    template<class F, class T, class I>
      concept @\defexposconcept{indirectly-binary-left-foldable}@ =      // \expos
        @\libconcept{copy_constructible}@<F> && @\libconcept{indirectly_readable}@<I> &&
        @\libconcept{invocable}@<F&, T, iter_reference_t<I>> &&
        @\libconcept{convertible_to}@<invoke_result_t<F&, T, iter_reference_t<I>>,
               decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>> &&
        @\exposconcept{indirectly-binary-left-foldable-impl}@<F, T, I,
                        decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>>;

    template<class F, class T, class I>
      concept @\defexposconcept{indirectly-binary-right-foldable}@ =    // \expos
        @\exposconcept{indirectly-binary-left-foldable}@<@\exposid{flipped}@<F>, T, I>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
             @\exposconcept{indirectly-binary-left-foldable}@<T, I> F>
      constexpr auto fold_left(I first, S last, T init, F f);

    template<@\libconcept{input_range}@ R, class T = range_value_t<R>,
             @\exposconcept{indirectly-binary-left-foldable}@<T, iterator_t<R>> F>
      constexpr auto fold_left(R&& r, T init, F f);

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             @\exposconcept{indirectly-binary-left-foldable}@<iter_value_t<I>, I> F>
      requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
      constexpr auto fold_left_first(I first, S last, F f);

    template<@\libconcept{input_range}@ R, @\exposconcept{indirectly-binary-left-foldable}@<range_value_t<R>, iterator_t<R>> F>
      requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
      constexpr auto fold_left_first(R&& r, F f);

    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
             @\exposconcept{indirectly-binary-right-foldable}@<T, I> F>
      constexpr auto fold_right(I first, S last, T init, F f);

    template<@\libconcept{bidirectional_range}@ R, class T = range_value_t<R>,
             @\exposconcept{indirectly-binary-right-foldable}@<T, iterator_t<R>> F>
      constexpr auto fold_right(R&& r, T init, F f);

    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             @\exposconcept{indirectly-binary-right-foldable}@<iter_value_t<I>, I> F>
      requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
      constexpr auto fold_right_last(I first, S last, F f);

    template<@\libconcept{bidirectional_range}@ R,
             @\exposconcept{indirectly-binary-right-foldable}@<range_value_t<R>, iterator_t<R>> F>
      requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
      constexpr auto fold_right_last(R&& r, F f);

    template<class I, class T>
      using fold_left_with_iter_result = in_value_result<I, T>;
    template<class I, class T>
      using fold_left_first_with_iter_result = in_value_result<I, T>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
             @\exposconcept{indirectly-binary-left-foldable}@<T, I> F>
      constexpr @\seebelow@ fold_left_with_iter(I first, S last, T init, F f);

    template<@\libconcept{input_range}@ R, class T = range_value_t<R>,
             @\exposconcept{indirectly-binary-left-foldable}@<T, iterator_t<R>> F>
      constexpr @\seebelow@ fold_left_with_iter(R&& r, T init, F f);

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             @\exposconcept{indirectly-binary-left-foldable}@<iter_value_t<I>, I> F>
      requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
      constexpr @\seebelow@ fold_left_first_with_iter(I first, S last, F f);

    template<@\libconcept{input_range}@ R,
             @\exposconcept{indirectly-binary-left-foldable}@<range_value_t<R>, iterator_t<R>> F>
      requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
      constexpr @\seebelow@ fold_left_first_with_iter(R&& r, F f);
  }

  // \ref{alg.modifying.operations}, mutating sequence operations
  // \ref{alg.copy}, copy
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 copy(ExecutionPolicy&& exec,               // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using copy_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr copy_result<I, O>
        copy(I first, S last, O result);
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
      constexpr copy_result<borrowed_iterator_t<R>, O>
        copy(R&& r, O result);
  }

  template<class InputIterator, class Size, class OutputIterator>
    constexpr OutputIterator copy_n(InputIterator first, Size n,
                                    OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class Size,
           class ForwardIterator2>
    ForwardIterator2 copy_n(ExecutionPolicy&& exec,             // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                            ForwardIterator1 first, Size n,
                            ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using copy_n_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr copy_n_result<I, O>
        copy_n(I first, iter_difference_t<I> n, O result);
  }

  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2 copy_if(ExecutionPolicy&& exec,            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, Predicate pred);

  namespace ranges {
    template<class I, class O>
      using copy_if_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr copy_if_result<I, O>
        copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
      constexpr copy_if_result<borrowed_iterator_t<R>, O>
        copy_if(R&& r, O result, Pred pred, Proj proj = {});
  }

  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  namespace ranges {
    template<class I1, class I2>
      using copy_backward_result = in_out_result<I1, I2>;

    template<@\libconcept{bidirectional_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{bidirectional_iterator}@ I2>
      requires @\libconcept{indirectly_copyable}@<I1, I2>
      constexpr copy_backward_result<I1, I2>
        copy_backward(I1 first, S1 last, I2 result);
    template<@\libconcept{bidirectional_range}@ R, @\libconcept{bidirectional_iterator}@ I>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, I>
      constexpr copy_backward_result<borrowed_iterator_t<R>, I>
        copy_backward(R&& r, I result);
  }

  // \ref{alg.move}, move
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator move(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2>
    ForwardIterator2 move(ExecutionPolicy&& exec,               // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using move_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_movable}@<I, O>
      constexpr move_result<I, O>
        move(I first, S last, O result);
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_movable}@<iterator_t<R>, O>
      constexpr move_result<borrowed_iterator_t<R>, O>
        move(R&& r, O result);
  }

  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  namespace ranges {
    template<class I1, class I2>
      using move_backward_result = in_out_result<I1, I2>;

    template<@\libconcept{bidirectional_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{bidirectional_iterator}@ I2>
      requires @\libconcept{indirectly_movable}@<I1, I2>
      constexpr move_backward_result<I1, I2>
        move_backward(I1 first, S1 last, I2 result);
    template<@\libconcept{bidirectional_range}@ R, @\libconcept{bidirectional_iterator}@ I>
      requires @\libconcept{indirectly_movable}@<iterator_t<R>, I>
      constexpr move_backward_result<borrowed_iterator_t<R>, I>
        move_backward(R&& r, I result);
  }

  // \ref{alg.swap}, swap
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                           ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 swap_ranges(ExecutionPolicy&& exec,        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);

  namespace ranges {
    template<class I1, class I2>
      using swap_ranges_result = in_in_result<I1, I2>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2>
      requires @\libconcept{indirectly_swappable}@<I1, I2>
      constexpr swap_ranges_result<I1, I2>
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2>
      requires @\libconcept{indirectly_swappable}@<iterator_t<R1>, iterator_t<R2>>
      constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        swap_ranges(R1&& r1, R2&& r2);
  }

  template<class ForwardIterator1, class ForwardIterator2>
    constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  // \ref{alg.transform}, transform
  template<class InputIterator, class OutputIterator, class UnaryOperation>
    constexpr OutputIterator
      transform(InputIterator first1, InputIterator last1,
                OutputIterator result, UnaryOperation op);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation>
    constexpr OutputIterator
      transform(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class UnaryOperation>
    ForwardIterator2
      transform(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 result, UnaryOperation op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class BinaryOperation>
    ForwardIterator
      transform(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator result,
                BinaryOperation binary_op);

  namespace ranges {
    template<class I, class O>
      using unary_transform_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
             @\libconcept{copy_constructible}@ F, class Proj = identity>
      requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<I, Proj>>>
      constexpr unary_transform_result<I, O>
        transform(I first1, S last1, O result, F op, Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, @\libconcept{copy_constructible}@ F,
             class Proj = identity>
      requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
      constexpr unary_transform_result<borrowed_iterator_t<R>, O>
        transform(R&& r, O result, F op, Proj proj = {});

    template<class I1, class I2, class O>
      using binary_transform_result = in_in_out_result<I1, I2, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, @\libconcept{copy_constructible}@ F, class Proj1 = identity,
             class Proj2 = identity>
      requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<I1, Proj1>,
                                   projected<I2, Proj2>>>
      constexpr binary_transform_result<I1, I2, O>
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
             @\libconcept{copy_constructible}@ F, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                   projected<iterator_t<R2>, Proj2>>>
      constexpr binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        transform(R1&& r1, R2&& r2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.replace}, replace
  template<class ForwardIterator, class T>
    constexpr void replace(ForwardIterator first, ForwardIterator last,
                           const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator,
           class T = iterator_traits<ForwardIterator>::value_type>
    void replace(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value);
  template<class ForwardIterator, class Predicate,
           class T = iterator_traits<ForwardIterator>::value_type>
    constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate,
           class T = iterator_traits<ForwardIterator>::value_type>
    void replace_if(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T& new_value);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T1 = projected_value_t<I, Proj>, class T2 = T1>
      requires @\libconcept{indirectly_writable}@<I, const T2&> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T1*>
      constexpr I
        replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
      requires @\libconcept{indirectly_writable}@<iterator_t<R>, const T2&> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T1*>
      constexpr borrowed_iterator_t<R>
        replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{indirectly_writable}@<I, const T&>
      constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity, class T = projected_value_t<I, Proj>,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{indirectly_writable}@<iterator_t<R>, const T&>
      constexpr borrowed_iterator_t<R>
        replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
                                          OutputIterator result,
                                          const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
    ForwardIterator2 replace_copy(ExecutionPolicy&& exec,       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                  ForwardIterator1 first, ForwardIterator1 last,
                                  ForwardIterator2 result,
                                  const T& old_value, const T& new_value);
  template<class InputIterator, class OutputIterator, class Predicate,
           class T = iterator_traits<OutputIterator>::value_type>
    constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                             OutputIterator result,
                                             Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate, class T = iterator_traits<ForwardIterator2>::value_type>
    ForwardIterator2 replace_copy_if(ExecutionPolicy&& exec,    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                     ForwardIterator1 first, ForwardIterator1 last,
                                     ForwardIterator2 result,
                                     Predicate pred, const T& new_value);

  namespace ranges {
    template<class I, class O>
      using replace_copy_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class O,
             class Proj = identity,
             class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
      requires @\libconcept{indirectly_copyable}@<I, O> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T1*> &&
               @\libconcept{output_iterator}@<O, const T2&>
      constexpr replace_copy_result<I, O>
        replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                     Proj proj = {});
    template<@\libconcept{input_range}@ R, class O, class Proj = identity,
             class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T1*> &&
               @\libconcept{output_iterator}@<O, const T2&>
      constexpr replace_copy_result<borrowed_iterator_t<R>, O>
        replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                     Proj proj = {});

    template<class I, class O>
      using replace_copy_if_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class O, class T = iter_value_t<O>
             class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<I, O> && @\libconcept{output_iterator}@<O, const T&>
      constexpr replace_copy_if_result<I, O>
        replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                        Proj proj = {});
    template<@\libconcept{input_range}@ R, class O, class T = iter_value_t<O>, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> && @\libconcept{output_iterator}@<O, const T&>
      constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
        replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                        Proj proj = {});
  }

  // \ref{alg.fill}, fill
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class T = iterator_traits<ForwardIterator>::value_type>
    void fill(ExecutionPolicy&& exec,                           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
              ForwardIterator first, ForwardIterator last, const T& value);
  template<class OutputIterator, class Size,
           class T = iterator_traits<OutputIterator>::value_type>
    constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value)
  template<class ExecutionPolicy, class ForwardIterator,
           class Size, class T = iterator_traits<ForwardIterator>::value_type>
    ForwardIterator fill_n(ExecutionPolicy&& exec,              // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, Size n, const T& value);

  namespace ranges {
    template<class O, @\libconcept{sentinel_for}@<O> S, class T = iter_value_t<O>>
      requires @\libconcept{output_iterator}@<O, const T&>
      constexpr O fill(O first, S last, const T& value);
    template<class R, class T = range_value_t<R>>
      requires @\libconcept{output_range}@<R, const T&>
      constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
    template<class O, class T = iter_value_t<O>>
      requires @\libconcept{output_iterator}@<O, const T&>
      constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
  }

  // \ref{alg.generate}, generate
  template<class ForwardIterator, class Generator>
    constexpr void generate(ForwardIterator first, ForwardIterator last,
                            Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Generator>
    void generate(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template<class OutputIterator, class Size, class Generator>
    constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
    ForwardIterator generate_n(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Generator gen);

  namespace ranges {
    template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{sentinel_for}@<O> S, @\libconcept{copy_constructible}@ F>
      requires @\libconcept{invocable}@<F&> && @\libconcept{indirectly_writable}@<O, invoke_result_t<F&>>
      constexpr O generate(O first, S last, F gen);
    template<class R, @\libconcept{copy_constructible}@ F>
      requires @\libconcept{invocable}@<F&> && @\libconcept{output_range}@<R, invoke_result_t<F&>>
      constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
    template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{copy_constructible}@ F>
      requires @\libconcept{invocable}@<F&> && @\libconcept{indirectly_writable}@<O, invoke_result_t<F&>>
      constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
  }

  // \ref{alg.remove}, remove
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                     const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class T = iterator_traits<ForwardIterator>::value_type>
    ForwardIterator remove(ExecutionPolicy&& exec,              // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           const T& value);
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator remove_if(ExecutionPolicy&& exec,           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>>
      requires @\libconcept{permutable}@<iterator_t<R>> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr borrowed_subrange_t<R>
        remove(R&& r, const T& value, Proj proj = {});
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        remove_if(R&& r, Pred pred, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator,
           class T = iterator_traits<InputIterator>::value_type>
    constexpr OutputIterator
      remove_copy(InputIterator first, InputIterator last,
                  OutputIterator result, const T& value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class T = iterator_traits<ForwardIterator1>::value_type>
    ForwardIterator2
      remove_copy(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, const T& value);
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator
      remove_copy_if(InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2
      remove_copy_if(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, Predicate pred);

  namespace ranges {
    template<class I, class O>
      using remove_copy_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
             class Proj = identity, class T = projected_value_t<I, Proj>>
      requires @\libconcept{indirectly_copyable}@<I, O> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr remove_copy_result<I, O>
        remove_copy(I first, S last, O result, const T& value, Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
               @\libconcept{indirect_binary_predicate}@<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr remove_copy_result<borrowed_iterator_t<R>, O>
        remove_copy(R&& r, O result, const T& value, Proj proj = {});

    template<class I, class O>
      using remove_copy_if_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
             class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr remove_copy_if_result<I, O>
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
      constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
        remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
  }

  // \ref{alg.unique}, unique
  template<class ForwardIterator>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                     BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator unique(ExecutionPolicy&& exec,              // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator unique(ExecutionPolicy&& exec,              // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<I, Proj>> C = ranges::equal_to>
      constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        unique(R&& r, C comp = {}, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryPredicate>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, BinaryPredicate pred);

  namespace ranges {
    template<class I, class O>
      using unique_copy_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<I, Proj>> C = ranges::equal_to>
      requires @\libconcept{indirectly_copyable}@<I, O> &&
               (@\libconcept{forward_iterator}@<I> ||
                (@\libconcept{input_iterator}@<O> && @\libconcept{same_as}@<iter_value_t<I>, iter_value_t<O>>) ||
                @\libconcept{indirectly_copyable_storable}@<I, O>)
      constexpr unique_copy_result<I, O>
        unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
             @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
               (@\libconcept{forward_iterator}@<iterator_t<R>> ||
                (@\libconcept{input_iterator}@<O> && @\libconcept{same_as}@<range_value_t<R>, iter_value_t<O>>) ||
                @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, O>)
      constexpr unique_copy_result<borrowed_iterator_t<R>, O>
        unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
  }

  // \ref{alg.reverse}, reverse
  template<class BidirectionalIterator>
    constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void reverse(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 BidirectionalIterator first, BidirectionalIterator last);

  namespace ranges {
    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S>
      requires @\libconcept{permutable}@<I>
      constexpr I reverse(I first, S last);
    template<@\libconcept{bidirectional_range}@ R>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_iterator_t<R> reverse(R&& r);
  }

  template<class BidirectionalIterator, class OutputIterator>
    constexpr OutputIterator
      reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                   OutputIterator result);
  template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
    ForwardIterator
      reverse_copy(ExecutionPolicy&& exec,                      // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                   BidirectionalIterator first, BidirectionalIterator last,
                   ForwardIterator result);

  namespace ranges {
    template<class I, class O>
      using reverse_copy_result = in_out_result<I, O>;

    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr reverse_copy_result<I, O>
        reverse_copy(I first, S last, O result);
    template<@\libconcept{bidirectional_range}@ R, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
      constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
        reverse_copy(R&& r, O result);
  }

  // \ref{alg.rotate}, rotate
  template<class ForwardIterator>
    constexpr ForwardIterator rotate(ForwardIterator first,
                                     ForwardIterator middle,
                                     ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator rotate(ExecutionPolicy&& exec,              // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
      constexpr subrange<I> rotate(I first, I middle, S last);
    template<@\libconcept{forward_range}@ R>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
  }

  template<class ForwardIterator, class OutputIterator>
    constexpr OutputIterator
      rotate_copy(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      rotate_copy(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 middle,
                  ForwardIterator1 last, ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using rotate_copy_result = in_out_result<I, O>;

    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<I, O>
      constexpr rotate_copy_result<I, O>
        rotate_copy(I first, I middle, S last, O result);
    template<@\libconcept{forward_range}@ R, @\libconcept{weakly_incrementable}@ O>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
      constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
        rotate_copy(R&& r, iterator_t<R> middle, O result);
  }

  // \ref{alg.random.sample}, sample
  template<class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator>
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&& g);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             @\libconcept{weakly_incrementable}@ O, class Gen>
      requires (@\libconcept{forward_iterator}@<I> || @\libconcept{random_access_iterator}@<O>) &&
               @\libconcept{indirectly_copyable}@<I, O> &&
               @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
      O sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Gen>
      requires (@\libconcept{forward_range}@<R> || @\libconcept{random_access_iterator}@<O>) &&
               @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
               @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
      O sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
  }

  // \ref{alg.random.shuffle}, shuffle
  template<class RandomAccessIterator, class UniformRandomBitGenerator>
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&& g);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Gen>
      requires @\libconcept{permutable}@<I> &&
               @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
      I shuffle(I first, S last, Gen&& g);
    template<@\libconcept{random_access_range}@ R, class Gen>
      requires @\libconcept{permutable}@<iterator_t<R>> &&
               @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
      borrowed_iterator_t<R> shuffle(R&& r, Gen&& g);
  }

  // \ref{alg.shift}, shift
  template<class ForwardIterator>
    constexpr ForwardIterator
      shift_left(ForwardIterator first, ForwardIterator last,
                 typename iterator_traits<ForwardIterator>::difference_type n);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      shift_left(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last,
                 typename iterator_traits<ForwardIterator>::difference_type n);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
      constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);
    template<@\libconcept{forward_range}@ R>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);
  }

  template<class ForwardIterator>
    constexpr ForwardIterator
      shift_right(ForwardIterator first, ForwardIterator last,
                  typename iterator_traits<ForwardIterator>::difference_type n);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      shift_right(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last,
                  typename iterator_traits<ForwardIterator>::difference_type n);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
      constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);
    template<@\libconcept{forward_range}@ R>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);
  }

  // \ref{alg.sorting}, sorting and related operations
  // \ref{alg.sort}, sorting
  template<class RandomAccessIterator>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
                        Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void sort(ExecutionPolicy&& exec,                           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void sort(ExecutionPolicy&& exec,                           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        sort(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        sort(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last);  // hosted
  template<class RandomAccessIterator, class Compare>
    constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last,   // hosted
                               Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void stable_sort(ExecutionPolicy&& exec,                    // hosted, see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void stable_sort(ExecutionPolicy&& exec,                    // hosted, see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});         // hosted
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        stable_sort(R&& r, Comp comp = {}, Proj proj = {});                             // hosted
  }

  template<class RandomAccessIterator>
    constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
                                RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
                                RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void partial_sort(ExecutionPolicy&& exec,                   // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                      RandomAccessIterator first, RandomAccessIterator middle,
                      RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void partial_sort(ExecutionPolicy&& exec,                   // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                      RandomAccessIterator first, RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        partial_sort(R&& r, iterator_t<R> middle, Comp comp = {},
                     Proj proj = {});
  }

  template<class InputIterator, class RandomAccessIterator>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class InputIterator, class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,                 // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
           class Compare>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,                 // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);

  namespace ranges {
    template<class I, class O>
      using partial_sort_copy_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1,
             @\libconcept{random_access_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_copyable}@<I1, I2> && @\libconcept{sortable}@<I2, Comp, Proj2> &&
               @\libconcept{indirect_strict_weak_order}@<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
      constexpr partial_sort_copy_result<I1, I2>
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{random_access_range}@ R2, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R1>, iterator_t<R2>> &&
               @\libconcept{sortable}@<iterator_t<R2>, Comp, Proj2> &&
               @\libconcept{indirect_strict_weak_order}@<Comp, projected<iterator_t<R1>, Proj1>,
                                          projected<iterator_t<R2>, Proj2>>
      constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class ForwardIterator>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                             Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    bool is_sorted(ExecutionPolicy&& exec,                      // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    bool is_sorted(ExecutionPolicy&& exec,                      // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last,
                   Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last,
                      Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec,                   // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec,                   // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last,
                      Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
  }

  // \ref{alg.nth.element}, Nth element
  template<class RandomAccessIterator>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void nth_element(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void nth_element(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
  }

  // \ref{alg.binary.search}, binary search
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
           class Compare>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr I lower_bound(I first, S last, const T& value, Comp comp = {},
                              Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_iterator_t<R>
        lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
           class Compare>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr I upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_iterator_t<R>
        upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
           class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr subrange<I>
        equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_subrange_t<R>
        equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value);
  template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
           class Compare>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value, Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             class T = projected_value_t<I, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr bool binary_search(I first, S last, const T& value, Comp comp = {},
                                   Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             class T = projected_value_t<iterator_t<R>, Proj>,
             @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr bool binary_search(R&& r, const T& value, Comp comp = {},
                                   Proj proj = {});
  }

  // \ref{alg.partitions}, partitions
  template<class InputIterator, class Predicate>
    constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool is_partitioned(ExecutionPolicy&& exec,                 // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});
  }

  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator partition(ForwardIterator first,
                                        ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator partition(ExecutionPolicy&& exec,           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);

  namespace ranges {
    template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr subrange<I>
        partition(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        partition(R&& r, Pred pred, Proj proj = {});
  }

  template<class BidirectionalIterator, class Predicate>
    constexpr BidirectionalIterator stable_partition(BidirectionalIterator first,   // hosted
                                                     BidirectionalIterator last,
                                                     Predicate pred);
  template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(ExecutionPolicy&& exec,                  // hosted,
                                           BidirectionalIterator first,             // see \ref{algorithms.parallel.overloads}
                                           BidirectionalIterator last,
                                           Predicate pred);

  namespace ranges {
    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{permutable}@<I>
      constexpr subrange<I> stable_partition(I first, S last, Pred pred,            // hosted
                                             Proj proj = {});
    template<@\libconcept{bidirectional_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{permutable}@<iterator_t<R>>
      constexpr borrowed_subrange_t<R> stable_partition(R&& r, Pred pred,           // hosted
                                                        Proj proj = {});
  }

  template<class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate>
    constexpr pair<OutputIterator1, OutputIterator2>
      partition_copy(InputIterator first, InputIterator last,
                     OutputIterator1 out_true, OutputIterator2 out_false,
                     Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
           class ForwardIterator2, class Predicate>
    pair<ForwardIterator1, ForwardIterator2>
      partition_copy(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last,
                     ForwardIterator1 out_true, ForwardIterator2 out_false,
                     Predicate pred);

  namespace ranges {
    template<class I, class O1, class O2>
      using partition_copy_result = in_out_out_result<I, O1, O2>;

    template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
             @\libconcept{weakly_incrementable}@ O1, @\libconcept{weakly_incrementable}@ O2,
             class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<I, O1> && @\libconcept{indirectly_copyable}@<I, O2>
      constexpr partition_copy_result<I, O1, O2>
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = {});
    template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O1, @\libconcept{weakly_incrementable}@ O2,
             class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O1> &&
               @\libconcept{indirectly_copyable}@<iterator_t<R>, O2>
      constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
        partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
  }

  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator
      partition_point(ForwardIterator first, ForwardIterator last,
                      Predicate pred);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
      constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        partition_point(R&& r, Pred pred, Proj proj = {});
  }

  // \ref{alg.merge}, merge
  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      merge(ExecutionPolicy&& exec,                             // freestanding-deleted, see \ref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      merge(ExecutionPolicy&& exec,                             // freestanding-deleted, see \ref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using merge_result = in_in_out_result<I1, I2, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less, class Proj1 = identity,
             class Proj2 = identity>
      requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
      constexpr merge_result<I1, I2, O>
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        merge(R1&& r1, R2&& r2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class BidirectionalIterator>
    constexpr void inplace_merge(BidirectionalIterator first,   // hosted
                                 BidirectionalIterator middle,
                                 BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr void inplace_merge(BidirectionalIterator first,   // hosted
                                 BidirectionalIterator middle,
                                 BidirectionalIterator last, Compare comp);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void inplace_merge(ExecutionPolicy&& exec,                  // hosted, see \ref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
    void inplace_merge(ExecutionPolicy&& exec,                  // hosted, see \ref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});       // hosted
    template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});     // hosted
  }

  // \ref{alg.set.operations}, set operations
  template<class InputIterator1, class InputIterator2>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool includes(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool includes(ExecutionPolicy&& exec,                       // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  Compare comp);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Proj1 = identity, class Proj2 = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
               ranges::less>
      constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Proj1 = identity,
             class Proj2 = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
      constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_union(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_union(ExecutionPolicy&& exec,                         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_union_result = in_in_out_result<I1, I2, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_union_result<I1, I2, O>
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec,                  // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec,                  // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_intersection_result = in_in_out_result<I1, I2, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<I1, I2, O>
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        set_intersection(R1&& r1, R2&& r2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I, class O>
      using set_difference_result = in_out_result<I, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<I1, O>
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<borrowed_iterator_t<R1>, O>
        set_difference(R1&& r1, R2&& r2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;

    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<I1, I2, O>
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = {}, Proj1 proj1 = {},
                                 Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                borrowed_iterator_t<R2>, O>
        set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.heap.operations}, heap operations
  template<class RandomAccessIterator>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        push_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        push_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                            Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        pop_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        make_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        make_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr I
        sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        sort_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    bool is_heap(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    bool is_heap(ExecutionPolicy&& exec,                        // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec,                     // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);

  namespace ranges {
    template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{random_access_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
  }

  // \ref{alg.min.max}, minimum and maximum
  template<class T> constexpr const T& min(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& min(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T min(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T min(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<@\libconcept{copyable}@ T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
      constexpr range_value_t<R>
        min(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class T> constexpr const T& max(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& max(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T max(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T max(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<@\libconcept{copyable}@ T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
      constexpr range_value_t<R>
        max(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
  template<class T, class Compare>
    constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr pair<T, T> minmax(initializer_list<T> t);
  template<class T, class Compare>
    constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T>
      using minmax_result = min_max_result<T>;

    template<class T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr minmax_result<const T&>
        minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<@\libconcept{copyable}@ T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr minmax_result<T>
        minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<@\libconcept{input_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
      constexpr minmax_result<range_value_t<R>>
        minmax(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator min_element(ExecutionPolicy&& exec,         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator min_element(ExecutionPolicy&& exec,         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        min_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator max_element(ExecutionPolicy&& exec,         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator max_element(ExecutionPolicy&& exec,         // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

  namespace ranges {
    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        max_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using minmax_element_result = min_max_result<I>;

    template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
      constexpr minmax_element_result<I>
        minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{forward_range}@ R, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr minmax_element_result<borrowed_iterator_t<R>>
        minmax_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  // \ref{alg.clamp}, bounded value
  template<class T>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi);
  template<class T, class Compare>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T&
        clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
  }

  // \ref{alg.lex.comparison}, lexicographical comparison
  template<class InputIterator1, class InputIterator2>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool
      lexicographical_compare(ExecutionPolicy&& exec,           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool
      lexicographical_compare(ExecutionPolicy&& exec,           // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              Compare comp);

  namespace ranges {
    template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
             class Proj1 = identity, class Proj2 = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
               ranges::less>
      constexpr bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Proj1 = identity,
             class Proj2 = identity,
             @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
      constexpr bool
        lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // \ref{alg.three.way}, three-way comparison algorithms
  template<class InputIterator1, class InputIterator2, class Cmp>
    constexpr auto
      lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                        InputIterator2 b2, InputIterator2 e2,
                                        Cmp comp)
        -> decltype(comp(*b1, *b2));
  template<class InputIterator1, class InputIterator2>
    constexpr auto
      lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                        InputIterator2 b2, InputIterator2 e2);

  // \ref{alg.permutation.generators}, permutations
  template<class BidirectionalIterator>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using next_permutation_result = in_found_result<I>;

    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr next_permutation_result<I>
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr next_permutation_result<borrowed_iterator_t<R>>
        next_permutation(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class BidirectionalIterator>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using prev_permutation_result = in_found_result<I>;

    template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<I, Comp, Proj>
      constexpr prev_permutation_result<I>
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less,
             class Proj = identity>
      requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
      constexpr prev_permutation_result<borrowed_iterator_t<R>>
        prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
  }
}
\end{codeblock}

\rSec1[algorithms.results]{Algorithm result types}

\pnum
Each of the class templates specified in this subclause
has the template parameters, data members, and special members specified below,
and has no base classes or members other than those specified.

\begin{codeblock}
namespace std::ranges {
  template<class I, class F>
  struct in_fun_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] F fun;

    template<class I2, class F2>
      requires @\libconcept{convertible_to}@<const I&, I2> && @\libconcept{convertible_to}@<const F&, F2>
    constexpr operator in_fun_result<I2, F2>() const & {
      return {in, fun};
    }

    template<class I2, class F2>
      requires @\libconcept{convertible_to}@<I, I2> && @\libconcept{convertible_to}@<F, F2>
    constexpr operator in_fun_result<I2, F2>() && {
      return {std::move(in), std::move(fun)};
    }
  };

  template<class I1, class I2>
  struct in_in_result {
    [[no_unique_address]] I1 in1;
    [[no_unique_address]] I2 in2;

    template<class II1, class II2>
      requires @\libconcept{convertible_to}@<const I1&, II1> && @\libconcept{convertible_to}@<const I2&, II2>
    constexpr operator in_in_result<II1, II2>() const & {
      return {in1, in2};
    }

    template<class II1, class II2>
      requires @\libconcept{convertible_to}@<I1, II1> && @\libconcept{convertible_to}@<I2, II2>
    constexpr operator in_in_result<II1, II2>() && {
      return {std::move(in1), std::move(in2)};
    }
  };

  template<class I, class O>
  struct in_out_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] O out;

    template<class I2, class O2>
      requires @\libconcept{convertible_to}@<const I&, I2> && @\libconcept{convertible_to}@<const O&, O2>
    constexpr operator in_out_result<I2, O2>() const & {
      return {in, out};
    }

    template<class I2, class O2>
      requires @\libconcept{convertible_to}@<I, I2> && @\libconcept{convertible_to}@<O, O2>
    constexpr operator in_out_result<I2, O2>() && {
      return {std::move(in), std::move(out)};
    }
  };

  template<class I1, class I2, class O>
  struct in_in_out_result {
    [[no_unique_address]] I1 in1;
    [[no_unique_address]] I2 in2;
    [[no_unique_address]] O  out;

    template<class II1, class II2, class OO>
      requires @\libconcept{convertible_to}@<const I1&, II1> &&
               @\libconcept{convertible_to}@<const I2&, II2> &&
               @\libconcept{convertible_to}@<const O&, OO>
    constexpr operator in_in_out_result<II1, II2, OO>() const & {
      return {in1, in2, out};
    }

    template<class II1, class II2, class OO>
      requires @\libconcept{convertible_to}@<I1, II1> &&
               @\libconcept{convertible_to}@<I2, II2> &&
               @\libconcept{convertible_to}@<O, OO>
    constexpr operator in_in_out_result<II1, II2, OO>() && {
      return {std::move(in1), std::move(in2), std::move(out)};
    }
  };

  template<class I, class O1, class O2>
  struct in_out_out_result {
    [[no_unique_address]] I  in;
    [[no_unique_address]] O1 out1;
    [[no_unique_address]] O2 out2;

    template<class II, class OO1, class OO2>
      requires @\libconcept{convertible_to}@<const I&, II> &&
               @\libconcept{convertible_to}@<const O1&, OO1> &&
               @\libconcept{convertible_to}@<const O2&, OO2>
    constexpr operator in_out_out_result<II, OO1, OO2>() const & {
      return {in, out1, out2};
    }

    template<class II, class OO1, class OO2>
      requires @\libconcept{convertible_to}@<I, II> &&
               @\libconcept{convertible_to}@<O1, OO1> &&
               @\libconcept{convertible_to}@<O2, OO2>
    constexpr operator in_out_out_result<II, OO1, OO2>() && {
      return {std::move(in), std::move(out1), std::move(out2)};
    }
  };

  template<class T>
  struct min_max_result {
    [[no_unique_address]] T min;
    [[no_unique_address]] T max;

    template<class T2>
      requires @\libconcept{convertible_to}@<const T&, T2>
    constexpr operator min_max_result<T2>() const & {
      return {min, max};
    }

    template<class T2>
      requires @\libconcept{convertible_to}@<T, T2>
    constexpr operator min_max_result<T2>() && {
      return {std::move(min), std::move(max)};
    }
  };

  template<class I>
  struct in_found_result {
    [[no_unique_address]] I in;
    bool found;

    template<class I2>
      requires @\libconcept{convertible_to}@<const I&, I2>
    constexpr operator in_found_result<I2>() const & {
      return {in, found};
    }
    template<class I2>
      requires @\libconcept{convertible_to}@<I, I2>
    constexpr operator in_found_result<I2>() && {
      return {std::move(in), found};
    }
  };

  template<class I, class T>
  struct in_value_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] T value;

    template<class I2, class T2>
      requires @\libconcept{convertible_to}@<const I&, I2> && @\libconcept{convertible_to}@<const T&, T2>
    constexpr operator in_value_result<I2, T2>() const & {
      return {in, value};
    }

    template<class I2, class T2>
      requires @\libconcept{convertible_to}@<I, I2> && @\libconcept{convertible_to}@<T, T2>
    constexpr operator in_value_result<I2, T2>() && {
      return {std::move(in), std::move(value)};
    }
  };

  template<class O, class T>
  struct out_value_result {
    [[no_unique_address]] O out;
    [[no_unique_address]] T value;

    template<class O2, class T2>
      requires @\libconcept{convertible_to}@<const O&, O2> && @\libconcept{convertible_to}@<const T&, T2>
    constexpr operator out_value_result<O2, T2>() const & {
      return {out, value};
    }

    template<class O2, class T2>
      requires @\libconcept{convertible_to}@<O, O2> && @\libconcept{convertible_to}@<T, T2>
    constexpr operator out_value_result<O2, T2>() && {
      return {std::move(out), std::move(value)};
    }
  };
}
\end{codeblock}

\rSec1[alg.nonmodifying]{Non-modifying sequence operations}

\rSec2[alg.all.of]{All of}

\indexlibraryglobal{all_of}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool all_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr bool ranges::all_of(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::all_of(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
  \tcode{pred(*i)} for the overloads in namespace \tcode{std};
\item
  \tcode{invoke(pred, invoke(proj, *i))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\returns
\tcode{false} if $E$ is \tcode{false}
for some iterator \tcode{i} in the range \range{first}{last}, and
\tcode{true} otherwise.

\pnum
\complexity
At most \tcode{last - first} applications of the predicate and any projection.
\end{itemdescr}

\rSec2[alg.any.of]{Any of}

\indexlibraryglobal{any_of}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool any_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr bool ranges::any_of(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::any_of(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
  \tcode{pred(*i)} for the overloads in namespace \tcode{std};
\item
  \tcode{invoke(pred, invoke(proj, *i))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\returns
\tcode{true} if $E$ is \tcode{true} for some iterator \tcode{i}
in the range \range{first}{last}, and \tcode{false} otherwise.

\pnum
\complexity
At most \tcode{last - first} applications of the predicate
and any projection.
\end{itemdescr}

\rSec2[alg.none.of]{None of}

\indexlibraryglobal{none_of}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool none_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
               Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr bool ranges::none_of(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::none_of(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
  \tcode{pred(*i)} for the overloads in namespace \tcode{std};
\item
  \tcode{invoke(pred, invoke(proj, *i))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\returns
\tcode{false} if $E$ is \tcode{true}
for some iterator \tcode{i} in the range \range{first}{last}, and
\tcode{true} otherwise.

\pnum
\complexity
At most \tcode{last - first} applications of the predicate and any projection.
\end{itemdescr}

\rSec2[alg.contains]{Contains}

\indexlibraryglobal{contains}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr bool ranges::contains(I first, S last, const T& value, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr bool ranges::contains(R&& r, const T& value, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ranges::find(std::move(first), last, value, proj) != last}.
\end{itemdescr}

\indexlibraryglobal{contains_subrange}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1,
         @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                           Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::contains_subrange(R1&& r1, R2&& r2, Pred pred = {},
                                           Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty()}.
\end{itemdescr}

\rSec2[alg.foreach]{For each}

\indexlibraryglobal{for_each}%
\begin{itemdecl}
template<class InputIterator, class Function>
  constexpr Function for_each(InputIterator first, InputIterator last, Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Function} meets
the \oldconcept{MoveConstructible} requirements (\tref{cpp17.moveconstructible}).
\begin{note}
\tcode{Function} need not meet the requirements of
\oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible}).
\end{note}

\pnum
\effects
Applies \tcode{f} to the result of dereferencing
every iterator in the range \range{first}{last},
starting from \tcode{first} and proceeding to \tcode{last - 1}.
\begin{note}
If the type of \tcode{first} meets the requirements of a mutable iterator,
\tcode{f} can apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\returns
\tcode{f}.

\pnum
\complexity
Applies \tcode{f} exactly \tcode{last - first} times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
\end{itemdescr}

\indexlibraryglobal{for_each}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Function>
  void for_each(ExecutionPolicy&& exec,
                ForwardIterator first, ForwardIterator last,
                Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Function} meets the \oldconcept{CopyConstructible} requirements.

\pnum
\effects
Applies \tcode{f} to the result of dereferencing
every iterator in the range \range{first}{last}.
\begin{note}
If the type of \tcode{first} meets the requirements of a mutable iterator,
\tcode{f} can apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\complexity
Applies \tcode{f} exactly \tcode{last - first} times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
Implementations do not have
the freedom granted under \ref{algorithms.parallel.exec}
to make arbitrary copies of elements from the input sequence.

\pnum
\begin{note}
Does not return a copy of its \tcode{Function} parameter,
since parallelization often does not permit efficient state accumulation.
\end{note}
\end{itemdescr}

\indexlibraryglobal{for_each}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirectly_unary_invocable}@<projected<I, Proj>> Fun>
  constexpr ranges::for_each_result<I, Fun>
    ranges::for_each(I first, S last, Fun f, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirectly_unary_invocable}@<projected<iterator_t<R>, Proj>> Fun>
  constexpr ranges::for_each_result<borrowed_iterator_t<R>, Fun>
    ranges::for_each(R&& r, Fun f, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{invoke(f, invoke(proj, *i))}
for every iterator \tcode{i} in the range \range{first}{last},
starting from \tcode{first} and proceeding to \tcode{last - 1}.
\begin{note}
If the result of \tcode{invoke(proj, *i)} is a mutable reference,
\tcode{f} can apply non-constant functions.
\end{note}

\pnum
\returns
\tcode{\{last, std::move(f)\}}.

\pnum
\complexity
Applies \tcode{f} and \tcode{proj} exactly \tcode{last - first} times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.

\pnum
\begin{note}
The overloads in namespace \tcode{ranges} require
\tcode{Fun} to model \libconcept{copy_constructible}.
\end{note}
\end{itemdescr}

\indexlibraryglobal{for_each_n}%
\begin{itemdecl}
template<class InputIterator, class Size, class Function>
  constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The type \tcode{Size} is convertible
to an integral type\iref{conv.integral,class.conv}.

\pnum
\expects
\tcode{n >= 0} is \tcode{true}.
\tcode{Function} meets the \oldconcept{MoveConstructible} requirements.
\begin{note}
\tcode{Function} need not meet
the requirements of \oldconcept{CopyConstructible}.
\end{note}

\pnum
\effects
Applies \tcode{f} to the result of dereferencing
every iterator in the range \range{first}{first + n} in order.
\begin{note}
If the type of \tcode{first} meets the requirements of a mutable iterator,
\tcode{f} can apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\returns
\tcode{first + n}.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
\end{itemdescr}

\indexlibraryglobal{for_each_n}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
  ForwardIterator for_each_n(ExecutionPolicy&& exec, ForwardIterator first, Size n,
                             Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
The type \tcode{Size} is convertible
to an integral type\iref{conv.integral,class.conv}.

\pnum
\expects
\tcode{n >= 0} is \tcode{true}.
\tcode{Function} meets the \oldconcept{CopyConstructible} requirements.

\pnum
\effects
Applies \tcode{f} to the result of dereferencing
every iterator in the range \range{first}{first + n}.
\begin{note}
If the type of \tcode{first} meets the requirements of a mutable iterator,
\tcode{f} can apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\returns
\tcode{first + n}.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
Implementations do not have
the freedom granted under \ref{algorithms.parallel.exec}
to make arbitrary copies of elements from the input sequence.
\end{itemdescr}

\indexlibraryglobal{for_each_n}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, class Proj = identity,
         @\libconcept{indirectly_unary_invocable}@<projected<I, Proj>> Fun>
  constexpr ranges::for_each_n_result<I, Fun>
    ranges::for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n >= 0} is \tcode{true}.

\pnum
\effects
Calls \tcode{invoke(f, invoke(proj, *i))}
for every iterator \tcode{i} in the range
\range{first}{first + n} in order.
\begin{note}
If the result of \tcode{invoke(proj, *i)} is a mutable reference,
\tcode{f} can apply non-constant functions.
\end{note}

\pnum
\returns
\tcode{\{first + n, std::move(f)\}}.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.

\pnum
\begin{note}
The overload in namespace \tcode{ranges}
requires \tcode{Fun} to model \libconcept{copy_constructible}.
\end{note}
\end{itemdescr}

\rSec2[alg.find]{Find}

\indexlibraryglobal{find}%
\indexlibraryglobal{find_if}%
\indexlibraryglobal{find_if_not}%
\begin{itemdecl}
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
  constexpr InputIterator find(InputIterator first, InputIterator last,
                               const T& value);
template<class ExecutionPolicy, class ForwardIterator,
         class T = iterator_traits<ForwardIterator>::value_type>
  ForwardIterator find(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                       const T& value);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                  Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                          Predicate pred);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if_not(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr I ranges::find(I first, S last, const T& value, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_iterator_t<R>
    ranges::find(R&& r, const T& value, Proj proj = {});
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr I ranges::find_if(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if(R&& r, Pred pred, Proj proj = {});
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr I ranges::find_if_not(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::find_if_not(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == value} for \tcode{find};
\item \tcode{pred(*i) != false} for \tcode{find_if};
\item \tcode{pred(*i) == false} for \tcode{find_if_not};
\item \tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::find};
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::find_if};
\item \tcode{bool(!invoke(pred, invoke(proj, *i)))} for \tcode{ranges::find_if_not}.
\end{itemize}

\pnum
\returns
The first iterator \tcode{i} in the range \range{first}{last}
for which $E$ is \tcode{true}.
Returns \tcode{last} if no such iterator is found.

\pnum
\complexity
At most \tcode{last - first} applications
of the corresponding predicate and any projection.
\end{itemdescr}

\rSec2[alg.find.last]{Find last}

\indexlibraryglobal{find_last}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::find_last(I first, S last, const T& value, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R> ranges::find_last(R&& r, const T& value, Proj proj = {});
template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if(R&& r, Pred pred, Proj proj = {});
template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::find_last_if_not(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_subrange_t<R> ranges::find_last_if_not(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
\tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::find_last};
\item
\tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::find_last_if};
\item
\tcode{bool(!invoke(pred, invoke(proj, *i)))} for \tcode{ranges::find_last_if_not}.
\end{itemize}

\pnum
\returns
Let \tcode{i} be the last iterator in the range \range{first}{last}
for which $E$ is \tcode{true}.
Returns \tcode{\{i, last\}}, or
\tcode{\{last, last\}} if no such iterator is found.

\pnum
\complexity
At most \tcode{last - first} applications of
the corresponding predicate and projection.
\end{itemdescr}

\rSec2[alg.find.end]{Find end}

\indexlibraryglobal{find_end}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);

template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::find_end(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let:
\begin{itemize}
\item
  \tcode{pred} be \tcode{equal_to\{\}}
  for the overloads with no parameter \tcode{pred};
\item
  $E$ be:
  \begin{itemize}
  \item
    \tcode{pred(*(i + n), *(first2 + n))}
    for the overloads in namespace \tcode{std};
  \item
    \tcode{invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))}
    for the overloads in namespace \tcode{ranges};
  \end{itemize}
\item
  \tcode{i} be \tcode{last1} if \range{first2}{last2} is empty,
  or if \tcode{(last2 - first2) > (last1 - first1)} is \tcode{true},
  or if there is no iterator
  in the range \range{first1}{last1 - (last2 - first2)}
  such that for every non-negative integer
  \tcode{n < (last2 - first2)}, $E$ is \tcode{true}.
  Otherwise \tcode{i} is the last such iterator
  in \range{first1}{last1 - (last2 - first2)}.
\end{itemize}

\pnum
\returns
\begin{itemize}
\item \tcode{i} for the overloads in namespace \tcode{std}.
\item \tcode{\{i, i + (i == last1 ? 0 : last2 - first2)\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most
\tcode{(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)}
applications of the corresponding predicate and any projections.
\end{itemdescr}

\rSec2[alg.find.first.of]{Find first}

\indexlibraryglobal{find_first_of}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator, class ForwardIterator,
         class BinaryPredicate>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  BinaryPredicate pred);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr I1 ranges::find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                     Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{forward_range}@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_iterator_t<R1>
    ranges::find_first_of(R1&& r1, R2&& r2,
                          Pred pred = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == *j} for the overloads with no parameter \tcode{pred};
\item \tcode{pred(*i, *j) != false} for the overloads with a parameter \tcode{pred} and no parameter \tcode{proj1};
\item \tcode{bool(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))} for the overloads with parameters \tcode{pred} and \tcode{proj1}.
\end{itemize}

\pnum
\effects
Finds an element that matches one of a set of values.

\pnum
\returns
The first iterator \tcode{i} in the range \range{first1}{last1}
such that for some iterator \tcode{j} in the range \range{first2}{last2}
$E$ holds.
Returns \tcode{last1}
if \range{first2}{last2} is empty or
if no such iterator is found.

\pnum
\complexity
At most \tcode{(last1 - first1) * (last2 - first2)} applications
of the corresponding predicate and any projections.
\end{itemdescr}

\rSec2[alg.adjacent.find]{Adjacent find}

\indexlibraryglobal{adjacent_find}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_binary_predicate}@<projected<I, Proj>,
                                   projected<I, Proj>> Pred = ranges::equal_to>
  constexpr I ranges::adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_binary_predicate}@<projected<iterator_t<R>, Proj>,
                                   projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
  constexpr borrowed_iterator_t<R> ranges::adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\setlength{\emergencystretch}{1em}
\item \tcode{*i == *(i + 1)} for the overloads with no parameter \tcode{pred};
\item \tcode{pred(*i, *(i + 1)) != false} for the overloads with a parameter \tcode{pred} and no parameter \tcode{proj};
\item \tcode{bool(invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))))} for the overloads with both parameters \tcode{pred} and \tcode{proj}.
\end{itemize}

\pnum
\returns
The first iterator \tcode{i}
such that both \tcode{i} and \tcode{i + 1} are in the range \range{first}{last}
for which $E$ holds.
Returns \tcode{last} if no such iterator is found.

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy},
exactly \[ \min(\tcode{(i - first) + 1}, \ \tcode{(last - first) - 1}) \]
applications of the corresponding predicate,
where \tcode{i} is \tcode{adjacent_find}'s return value.
For the overloads with an \tcode{ExecutionPolicy},
\bigoh{\tcode{last - first}} applications of the corresponding predicate,
and no more than twice as many applications of any projection.
\end{itemdescr}

\rSec2[alg.count]{Count}

\indexlibraryglobal{count}%
\indexlibraryglobal{count_if}%
\begin{itemdecl}
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
         class T = iterator_traits<ForwardIterator>::value_type>
  typename iterator_traits<ForwardIterator>::difference_type
    count(ExecutionPolicy&& exec,
          ForwardIterator first, ForwardIterator last, const T& value);

template<class InputIterator, class Predicate>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  typename iterator_traits<ForwardIterator>::difference_type
    count_if(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last, Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr iter_difference_t<I>
    ranges::count(I first, S last, const T& value, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr range_difference_t<R>
    ranges::count(R&& r, const T& value, Proj proj = {});
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr iter_difference_t<I>
    ranges::count_if(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr range_difference_t<R>
    ranges::count_if(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
  \tcode{*i == value} for the overloads
  with no parameter \tcode{pred} or \tcode{proj};
\item
  \tcode{pred(*i) != false} for the overloads
  with a parameter \tcode{pred} but no parameter \tcode{proj};
\item
  \tcode{invoke(proj, *i) == value} for the overloads
  with a parameter \tcode{proj} but no parameter \tcode{pred};
\item
  \tcode{bool(invoke(pred, invoke(proj, *i)))} for the overloads
  with both parameters \tcode{proj} and \tcode{pred}.
\end{itemize}

\pnum
\effects
Returns the number of iterators \tcode{i} in the range \range{first}{last}
for which $E$ holds.

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.
\end{itemdescr}

\rSec2[alg.mismatch]{Mismatch}

\indexlibraryglobal{mismatch}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<I1, I2>
    ranges::mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::mismatch(R1&& r1, R2&& r2, Pred pred = {},
                     Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{last2} be \tcode{first2 + (last1 - first1)}
for the overloads with no parameter \tcode{last2} or \tcode{r2}.

\pnum
Let $E$ be:
\begin{itemize}
\setlength{\emergencystretch}{1em}
\item
  \tcode{!(*(first1 + n) == *(first2 + n))}
  for the overloads with no parameter \tcode{pred};
\item
  \tcode{pred(*(first1 + n), *(first2 + n)) == false}
  for the overloads with a parameter \tcode{pred} and
  no parameter \tcode{proj1};
\item
  \tcode{!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))}
  for the overloads with both parameters \tcode{pred} and \tcode{proj1}.
\end{itemize}

\pnum
Let $N$ be $\min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$.

\pnum
\returns
\tcode{\{ first1 + n, first2 + n \}},
where \tcode{n} is the smallest integer in \range{0}{$N$} such that $E$ holds,
or $N$ if no such integer exists.

\pnum
\complexity
At most $N$ applications of the corresponding predicate and any projections.
\end{itemdescr}

\rSec2[alg.equal]{Equal}

\indexlibraryglobal{equal}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(I1 first1, S1 last1, I2 first2, S2 last2,
                               Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::equal(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let:
\begin{itemize}
\item
  \tcode{last2} be \tcode{first2 + (last1 - first1)}
  for the overloads with no parameter \tcode{last2} or \tcode{r2};
\item
  \tcode{pred} be \tcode{equal_to\{\}}
  for the overloads with no parameter \tcode{pred};
\item
  $E$ be:
  \begin{itemize}
  \setlength{\emergencystretch}{1em}
  \item
    \tcode{pred(*i, *(first2 + (i - first1)))}
    for the overloads with no parameter \tcode{proj1};
  \item
    \tcode{invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1))))}
    for the overloads with parameter \tcode{proj1}.
  \end{itemize}
\end{itemize}

\pnum
\returns
If \tcode{last1 - first1 != last2 - first2}, return \tcode{false}.
Otherwise return \tcode{true}
if $E$ holds for every iterator \tcode{i} in the range \range{first1}{last1}.
Otherwise, returns \tcode{false}.

\pnum
\complexity
If
\begin{itemize}
\item
  the types of \tcode{first1}, \tcode{last1}, \tcode{first2}, and \tcode{last2}
  meet the
  \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}
  and \tcode{last1 - first1 != last2 - first2}
  for the overloads in namespace \tcode{std};
\item
 the types of \tcode{first1}, \tcode{last1}, \tcode{first2}, and \tcode{last2}
 pairwise model \libconcept{sized_sentinel_for}\iref{iterator.concept.sizedsentinel}
  and \tcode{last1 - first1 != last2 - first2}
  for the first overload in namespace \tcode{ranges},
\item
   \tcode{R1} and \tcode{R2} each model \libconcept{sized_range} and
   \tcode{ranges::distance(r1) != ranges::distance(r2)}
   for the second overload in namespace \tcode{ranges},
\end{itemize}
then no applications of the corresponding predicate and each projection;
otherwise,
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy},
  at most $\min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$
  applications of the corresponding predicate and any projections.
\item
  For the overloads with an \tcode{ExecutionPolicy},
  \bigoh{\min(\tcode{last1 - first1}, \ \tcode{last2 - first2})}
  applications of the corresponding predicate.
\end{itemize}
\end{itemdescr}

\rSec2[alg.is.permutation]{Is permutation}

\indexlibraryglobal{is_permutation}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2);
template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, BinaryPredicate pred);
template<class ForwardIterator1, class ForwardIterator2>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, ForwardIterator2 last2,
                                BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{last2} be \tcode{first2 + (last1 - first1)}
for the overloads with no parameter named \tcode{last2},
and let \tcode{pred} be \tcode{equal_to\{\}}
for the overloads with no parameter \tcode{pred}.

\pnum
\mandates
\tcode{ForwardIterator1} and \tcode{ForwardIterator2} have the same value type.

\pnum
\expects
The comparison function is an equivalence relation.

\pnum
\returns
If \tcode{last1 - first1 != last2 - first2}, return \tcode{false}.
Otherwise return \tcode{true}
if there exists a permutation of the elements
in the range \range{first2}{last2},
beginning with \tcode{ForwardIterator2 begin},
such that \tcode{equal(first1, last1, begin, pred)} returns \tcode{true};
otherwise, returns \tcode{false}.

\pnum
\complexity
No applications of the corresponding predicate
if \tcode{ForwardIterator1} and \tcode{Forward\-Iter\-ator2}
meet the requirements of random access iterators and
\tcode{last1 - first1 != last2 - first2}.
Otherwise, exactly \tcode{last1 - first1} applications
of the corresponding predicate
if \tcode{equal(first1, last1, first2, last2, pred)} would return \tcode{true};
otherwise, at worst \bigoh{N^2}, where $N$ has the value \tcode{last1 - first1}.
\end{itemdescr}

\indexlibraryglobal{is_permutation}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2,
         @\libconcept{sentinel_for}@<I2> S2, class Proj1 = identity, class Proj2 = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<I1, Proj1>,
                                       projected<I2, Proj2>> Pred = ranges::equal_to>
  constexpr bool ranges::is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                        Pred pred = {},
                                        Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2,
         class Proj1 = identity, class Proj2 = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R1>, Proj1>,
                                       projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to>
  constexpr bool ranges::is_permutation(R1&& r1, R2&& r2, Pred pred = {},
                                        Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{last1 - first1 != last2 - first2}, return \tcode{false}.
Otherwise return \tcode{true} if there exists a permutation of the elements
in the range \range{first2}{last2}, bounded by \range{pfirst}{plast},
such that
\tcode{ranges::equal(first1, last1, pfirst, plast, pred, proj1, proj2)}
returns \tcode{true};
otherwise, returns \tcode{false}.

\pnum
\complexity
No applications of the corresponding predicate and projections if
\begin{itemize}
\item
for the first overload,
\begin{itemize}
\item \tcode{S1} and \tcode{I1} model \tcode{\libconcept{sized_sentinel_for}<S1, I1>},
\item \tcode{S2} and \tcode{I2} model \tcode{\libconcept{sized_sentinel_for}<S2, I2>}, and
\item \tcode{last1 - first1 != last2 - first2};
\end{itemize}
\item
for the second overload,
\tcode{R1} and \tcode{R2} each model \libconcept{sized_range}, and
\tcode{ranges::distance(r1) != ranges::distance(r2)}.
\end{itemize}
Otherwise, exactly \tcode{last1 - first1} applications
of the corresponding predicate and projections
if \tcode{ranges::equal(\brk{}first1, last1, first2, last2, pred, proj1, proj2)}
would return \tcode{true};
otherwise, at worst \bigoh{N^2}, where $N$ has the value \tcode{last1 - first1}.
\end{itemdescr}

\rSec2[alg.search]{Search}

\indexlibraryglobal{search}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    search(ExecutionPolicy&& exec,
           ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    search(ExecutionPolicy&& exec,
           ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first iterator \tcode{i} in the range \crange{first1}{last1 - (last2 - first2)}
such that
for every non-negative integer \tcode{n} less than \tcode{last2 - first2}
the following corresponding conditions hold:
\tcode{*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false}.
Returns \tcode{first1} if \range{first2}{last2} is empty,
otherwise returns \tcode{last1} if no such iterator is found.

\pnum
\complexity
At most \tcode{(last1 - first1) * (last2 - first2)} applications
of the corresponding predicate.
\end{itemdescr}

\indexlibraryglobal{search}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{forward_iterator}@ I2,
         @\libconcept{sentinel_for}@<I2> S2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr subrange<I1>
    ranges::search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{forward_range}@ R1, @\libconcept{forward_range}@ R2, class Pred = ranges::equal_to,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr borrowed_subrange_t<R1>
    ranges::search(R1&& r1, R2&& r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{itemize}
\item
  \tcode{\{i, i + (last2 - first2)\}},
  where \tcode{i} is
  the first iterator in the range \crange{first1}{last1 - (last2 - first2)}
  such that
  for every non-negative integer \tcode{n} less than \tcode{last2 - first2}
  the condition
\begin{codeblock}
bool(invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))))
\end{codeblock}
  is \tcode{true}.
\item
  Returns \tcode{\{last1, last1\}} if no such iterator exists.
\end{itemize}

\pnum
\complexity
At most \tcode{(last1 - first1) * (last2 - first2)} applications
of the corresponding predicate and projections.
\end{itemdescr}

\indexlibraryglobal{search_n}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size,
         class T = iterator_traits<ForwardIterator>::value_type>
  ForwardIterator
    search_n(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last,
             Size count, const T& value);

template<class ForwardIterator, class Size, class T = iterator_traits<ForwardIterator>::value_type,
         class BinaryPredicate>
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Size,
         class T = iterator_traits<ForwardIterator>::value_type,
         class BinaryPredicate>
  ForwardIterator
    search_n(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last,
             Size count, const T& value,
             BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}

\pnum
\mandates
The type \tcode{Size}
is convertible to an integral type\iref{conv.integral,class.conv}.

\pnum
Let $E$ be \tcode{pred(*(i + n), value) != false}
for the overloads with a parameter \tcode{pred},
and \tcode{*(i + n) == value} otherwise.

\pnum
\returns
The first iterator \tcode{i} in the range \crange{first}{last - count}
such that for every non-negative integer \tcode{n} less than \tcode{count}
the condition $E$ is \tcode{true}.
Returns \tcode{last} if no such iterator is found.

\pnum
\complexity
At most \tcode{last - first} applications of the corresponding predicate.
\end{itemdescr}

\indexlibraryglobal{search_n}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
         class Pred = ranges::equal_to, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirectly_comparable}@<I, const T*, Pred, Proj>
  constexpr subrange<I>
    ranges::search_n(I first, S last, iter_difference_t<I> count,
                     const T& value, Pred pred = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Pred = ranges::equal_to,
         class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R>, const T*, Pred, Proj>
  constexpr borrowed_subrange_t<R>
    ranges::search_n(R&& r, range_difference_t<R> count,
                     const T& value, Pred pred = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\{i, i + count\}}
where \tcode{i} is the first iterator in the range \crange{first}{last - count}
such that for every non-negative integer \tcode{n} less than \tcode{count},
the following condition holds:
\tcode{invoke(pred, invoke(proj, *(i + n)), value)}.
Returns \tcode{\{last, last\}} if no such iterator is found.

\pnum
\complexity
At most \tcode{last - first} applications
of the corresponding predicate and projection.
\end{itemdescr}

\indexlibraryglobal{search}%
\begin{itemdecl}
template<class ForwardIterator, class Searcher>
  constexpr ForwardIterator
    search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return searcher(first, last).first;}

\pnum
\remarks
\tcode{Searcher} need not meet the \oldconcept{CopyConstructible} requirements.
\end{itemdescr}

\rSec2[alg.starts.with]{Starts with}

\indexlibraryglobal{starts_with}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
ranges::mismatch(std::move(first1), last1, std::move(first2), last2,
                 pred, proj1, proj2).in2 == last2
\end{codeblock}
\end{itemdescr}

\rSec2[alg.ends.with]{Ends with}

\indexlibraryglobal{ends_with}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
  requires (@\libconcept{forward_iterator}@<I1> || @\libconcept{sized_sentinel_for}@<S1, I1>) &&
           (@\libconcept{forward_iterator}@<I2> || @\libconcept{sized_sentinel_for}@<S2, I2>) &&
           @\libconcept{indirectly_comparable}@<I1, I2, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{N1} be \tcode{last1 - first1} and
\tcode{N2} be \tcode{last2 - first2}.

\pnum
\returns
\tcode{false} if $\tcode{N1} < \tcode{N2}$, otherwise
\begin{codeblock}
ranges::equal(std::move(first1) + (N1 - N2), last1, std::move(first2), last2,
              pred, proj1, proj2)
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Pred = ranges::equal_to, class Proj1 = identity,
         class Proj2 = identity>
  requires (@\libconcept{forward_range}@<R1> || @\libconcept{sized_range}@<R1>) &&
           (@\libconcept{forward_range}@<R2> || @\libconcept{sized_range}@<R2>) &&
           @\libconcept{indirectly_comparable}@<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
  constexpr bool ranges::ends_with(R1&& r1, R2&& r2, Pred pred = {},
                                   Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{N1} be \tcode{ranges::distance(r1)} and
\tcode{N2} be \tcode{ranges::distance(r2)}.

\pnum
\returns
\tcode{false} if $\tcode{N1} < \tcode{N2}$, otherwise
\begin{codeblock}
ranges::equal(views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)),
              r2, pred, proj1, proj2)
\end{codeblock}
\end{itemdescr}

\rSec2[alg.fold]{Fold}

\indexlibraryglobal{fold_left}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
         @\exposconcept{indirectly-binary-left-foldable}@<T, I> F>
  constexpr auto ranges::fold_left(I first, S last, T init, F f);
template<@\libconcept{input_range}@ R, class T = range_value_t<R>,
         @\exposconcept{indirectly-binary-left-foldable}@<T, iterator_t<R>> F>
  constexpr auto ranges::fold_left(R&& r, T init, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
ranges::fold_left_with_iter(std::move(first), last, std::move(init), f).value
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{fold_left_first}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
         @\exposconcept{indirectly-binary-left-foldable}@<iter_value_t<I>, I> F>
  requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
  constexpr auto ranges::fold_left_first(I first, S last, F f);
template<@\libconcept{input_range}@ R, @\exposconcept{indirectly-binary-left-foldable}@<range_value_t<R>, iterator_t<R>> F>
  requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
  constexpr auto ranges::fold_left_first(R&& r, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
ranges::fold_left_first_with_iter(std::move(first), last, f).value
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{fold_right}%
\begin{itemdecl}
template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
         @\exposconcept{indirectly-binary-right-foldable}@<T, I> F>
  constexpr auto ranges::fold_right(I first, S last, T init, F f);
template<@\libconcept{bidirectional_range}@ R, class T = range_value_t<R>,
         @\exposconcept{indirectly-binary-right-foldable}@<T, iterator_t<R>> F>
  constexpr auto ranges::fold_right(R&& r, T init, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
using U = decay_t<invoke_result_t<F&, iter_reference_t<I>, T>>;
if (first == last)
  return U(std::move(init));
I tail = ranges::next(first, last);
U accum = invoke(f, *--tail, std::move(init));
while (first != tail)
  accum = invoke(f, *--tail, std::move(accum));
return accum;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{fold_right_last}%
\begin{itemdecl}
template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
         @\exposconcept{indirectly-binary-right-foldable}@<iter_value_t<I>, I> F>
  requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
  constexpr auto ranges::fold_right_last(I first, S last, F f);
template<@\libconcept{bidirectional_range}@ R,
         @\exposconcept{indirectly-binary-right-foldable}@<range_value_t<R>, iterator_t<R>> F>
  requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
  constexpr auto ranges::fold_right_last(R&& r, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\tcode{decltype(ranges::fold_right(first, last, iter_value_t<I>(*first), f))}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (first == last)
  return optional<U>();
I tail = ranges::prev(ranges::next(first, std::move(last)));
return optional<U>(in_place,
  ranges::fold_right(std::move(first), tail, iter_value_t<I>(*tail), std::move(f)));
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{fold_left_with_iter}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class T = iter_value_t<I>,
         @\exposconcept{indirectly-binary-left-foldable}@<T, I> F>
  constexpr @\seebelow@ ranges::fold_left_with_iter(I first, S last, T init, F f);
template<@\libconcept{input_range}@ R, class T = range_value_t<R>,
         @\exposconcept{indirectly-binary-left-foldable}@<T, iterator_t<R>> F>
  constexpr @\seebelow@ ranges::fold_left_with_iter(R&& r, T init, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{decay_t<invoke_result_t<F\&, T, iter_reference_t<I>>>}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (first == last)
  return {std::move(first), U(std::move(init))};
U accum = invoke(f, std::move(init), *first);
for (++first; first != last; ++first)
  accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
\end{codeblock}

\pnum
\remarks
The return type is
\tcode{fold_left_with_iter_result<I, U>} for the first overload and
\tcode{fold_left_with_iter_result<borrowed_iterator_t<R>, U>}
for the second overload.
\end{itemdescr}

\indexlibraryglobal{fold_left_first_with_iter}%
\begin{itemdecl}
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,
         @\exposconcept{indirectly-binary-left-foldable}@<iter_value_t<I>, I> F>
  requires @\libconcept{constructible_from}@<iter_value_t<I>, iter_reference_t<I>>
  constexpr @\seebelow@ ranges::fold_left_first_with_iter(I first, S last, F f);
template<@\libconcept{input_range}@ R, @\exposconcept{indirectly-binary-left-foldable}@<range_value_t<R>, iterator_t<R>> F>
  requires @\libconcept{constructible_from}@<range_value_t<R>, range_reference_t<R>>
  constexpr @\seebelow@ ranges::fold_left_first_with_iter(R&& r, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\begin{codeblock}
decltype(ranges::fold_left(std::move(first), last, iter_value_t<I>(*first), f))
\end{codeblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (first == last)
  return {std::move(first), optional<U>()};
optional<U> init(in_place, *first);
for (++first; first != last; ++first)
  *init = invoke(f, std::move(*init), *first);
return {std::move(first), std::move(init)};
\end{codeblock}

\pnum
\remarks
The return type is
\tcode{fold_left_first_with_iter_result<I, optional<U>>}
for the first overload and
\tcode{fold_left_first_with_iter_result<borrowed_iterator_t<R>, optional<U>>}
for the second overload.
\end{itemdescr}

\rSec1[alg.modifying.operations]{Mutating sequence operations}

\rSec2[alg.copy]{Copy}

\indexlibraryglobal{copy}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                OutputIterator result);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<I, O>
  constexpr ranges::copy_result<I, O> ranges::copy(I first, S last, O result);
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
  constexpr ranges::copy_result<borrowed_iterator_t<R>, O> ranges::copy(R&& r, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{last - first}.

\pnum
\expects
\tcode{result} is not in the range \range{first}{last}.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the range \range{result}{result + $N$}
starting from \tcode{first} and proceeding to \tcode{last}.
For each non-negative integer $n < N$,
performs \tcode{*(result + $n$) = *(first + $n$)}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$} for the overload in namespace \tcode{std}.
\item
  \tcode{\{last, result + $N$\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\indexlibraryglobal{copy}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + (last - first)}
do not overlap.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the range \range{result}{result + (last - first)}.
For each non-negative integer \tcode{n < (last - first)},
performs \tcode{*(result + n) = *(first + n)}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibraryglobal{copy_n}%
\begin{itemdecl}
template<class InputIterator, class Size, class OutputIterator>
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2>
  ForwardIterator2 copy_n(ExecutionPolicy&& exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);

template<@\libconcept{input_iterator}@ I, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<I, O>
  constexpr ranges::copy_n_result<I, O>
    ranges::copy_n(I first, iter_difference_t<I> n, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be $\max(0, \tcode{n})$.

\pnum
\mandates
The type \tcode{Size} is convertible
to an integral type\iref{conv.integral,class.conv}.

\pnum
\effects
For each non-negative integer $i < N$,
performs \tcode{*(result + $i$) = *(first + $i$)}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{first + $N$, result + $N$\}}
  for the overload in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\indexlibraryglobal{copy_if}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2 copy_if(ExecutionPolicy&& exec,
                           ForwardIterator1 first, ForwardIterator1 last,
                           ForwardIterator2 result, Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<I, O>
  constexpr ranges::copy_if_result<I, O>
    ranges::copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
  constexpr ranges::copy_if_result<borrowed_iterator_t<R>, O>
    ranges::copy_if(R&& r, O result, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be:
\begin{itemize}
\item
  \tcode{bool(pred(*i))}
  for the overloads in namespace \tcode{std};
\item
  \tcode{bool(invoke(pred, invoke(proj, *i)))}
  for the overloads in namespace \tcode{ranges},
\end{itemize}
and $N$ be the number of iterators \tcode{i} in the range \range{first}{last}
for which the condition $E$ holds.

\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + (last - first)}
do not overlap.
\begin{note}
For the overload with an \tcode{ExecutionPolicy},
there might be a performance cost
if \tcode{iterator_traits<For\-ward\-It\-er\-ator1>::value_type}
is not \oldconcept{\-Move\-Constructible} (\tref{cpp17.moveconstructible}).
\end{note}

\pnum
\effects
Copies all of the elements referred to
by the iterator \tcode{i} in the range \range{first}{last}
for which $E$ is \tcode{true}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last, result + $N$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.
\end{itemdescr}

\indexlibraryglobal{copy_backward}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);

template<@\libconcept{bidirectional_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{bidirectional_iterator}@ I2>
  requires @\libconcept{indirectly_copyable}@<I1, I2>
  constexpr ranges::copy_backward_result<I1, I2>
    ranges::copy_backward(I1 first, S1 last, I2 result);
template<@\libconcept{bidirectional_range}@ R, @\libconcept{bidirectional_iterator}@ I>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, I>
  constexpr ranges::copy_backward_result<borrowed_iterator_t<R>, I>
    ranges::copy_backward(R&& r, I result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{last - first}.

\pnum
\expects
\tcode{result} is not in the range \brange{first}{last}.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the range \range{result - $N$}{result}
starting from \tcode{last - 1} and proceeding to \tcode{first}.
\begin{footnote}
\tcode{copy_backward} can be used instead of \tcode{copy}
when \tcode{last} is in the range \range{result - $N$}{result}.
\end{footnote}
For each positive integer $n \le N$,
performs \tcode{*(result - $n$) = *(last - $n$)}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result - $N$}
  for the overload in namespace \tcode{std}.
\item
  \tcode{\{last, result - $N$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\rSec2[alg.move]{Move}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator move(InputIterator first, InputIterator last,
                                OutputIterator result);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_movable}@<I, O>
  constexpr ranges::move_result<I, O>
    ranges::move(I first, S last, O result);
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_movable}@<iterator_t<R>, O>
  constexpr ranges::move_result<borrowed_iterator_t<R>, O>
    ranges::move(R&& r, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be
\begin{itemize}
\item
  \tcode{std::move(*(first + $n$))}
  for the overload in namespace \tcode{std};
\item
  \tcode{ranges::iter_move(first + $n$)}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
Let $N$ be \tcode{last - first}.

\pnum
\expects
\tcode{result} is not in the range \range{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the range \range{result}{result + $N$}
starting from \tcode{first} and proceeding to \tcode{last}.
For each non-negative integer $n < N$, performs \tcode{*(result + $n$) = $E$}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$}
  for the overload in namespace \tcode{std}.
\item
  \tcode{\{last, result + $N$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 move(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{last - first}.

\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + $N$}
do not overlap.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the range \range{result}{result + $N$}.
For each non-negative integer $n < N$,
performs \tcode{*(result + $n$) = std::\brk{}move(*(first + $n$))}.

\pnum
\returns
\tcode{result + $N$}.

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\indexlibraryglobal{move_backward}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                  BidirectionalIterator2 result);

template<@\libconcept{bidirectional_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{bidirectional_iterator}@ I2>
  requires @\libconcept{indirectly_movable}@<I1, I2>
  constexpr ranges::move_backward_result<I1, I2>
    ranges::move_backward(I1 first, S1 last, I2 result);
template<@\libconcept{bidirectional_range}@ R, @\libconcept{bidirectional_iterator}@ I>
  requires @\libconcept{indirectly_movable}@<iterator_t<R>, I>
  constexpr ranges::move_backward_result<borrowed_iterator_t<R>, I>
    ranges::move_backward(R&& r, I result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be
\begin{itemize}
\item
  \tcode{std::move(*(last - $n$))}
  for the overload in namespace \tcode{std};
\item
  \tcode{ranges::iter_move(last - $n$)}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
Let $N$ be \tcode{last - first}.

\pnum
\expects
\tcode{result} is not in the range \brange{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the range \range{result - $N$}{result}
starting from \tcode{last - 1} and proceeding to \tcode{first}.
\begin{footnote}
\tcode{move_backward} can be used instead of \tcode{move}
when \tcode{last} is in the range \range{result - $N$}{result}.
\end{footnote}
For each positive integer $n \le N$,
performs \tcode{*(result - $n$) = $E$}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result - $N$}
  for the overload in namespace \tcode{std}.
\item
  \tcode{\{last, result - $N$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\rSec2[alg.swap]{Swap}

\indexlibraryglobal{swap_ranges}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator2
    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    swap_ranges(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2>
  requires @\libconcept{indirectly_swappable}@<I1, I2>
  constexpr ranges::swap_ranges_result<I1, I2>
    ranges::swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2>
  requires @\libconcept{indirectly_swappable}@<iterator_t<R1>, iterator_t<R2>>
  constexpr ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::swap_ranges(R1&& r1, R2&& r2);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let:
\begin{itemize}
\item
  \tcode{last2} be \tcode{first2 + (last1 - first1)}
  for the overloads with no parameter named \tcode{last2};
\item $M$ be $\min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$.
\end{itemize}

\pnum
\expects
The two ranges \range{first1}{last1} and \range{first2}{last2}
do not overlap.
For the overloads in namespace \tcode{std},
\tcode{*(first1 + $n$)} is swappable with\iref{swappable.requirements}
\tcode{*(first2 + $n$)}.

\pnum
\effects
For each non-negative integer $n < M$ performs:
\begin{itemize}
\item
  \tcode{swap(*(first1 + $n$), *(first2 + $n$))}
  for the overloads in namespace \tcode{std};
\item
  \tcode{ranges::iter_swap(first1 + $n$, first2 + $n$)}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\returns
\begin{itemize}
\item
  \tcode{last2}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{first1 + $M$, first2 + $M$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $M$ swaps.
\end{itemdescr}

\indexlibraryglobal{iter_swap}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{a} and \tcode{b} are dereferenceable. \tcode{*a} is
swappable with\iref{swappable.requirements} \tcode{*b}.

\pnum
\effects
As if by \tcode{swap(*a, *b)}.
\end{itemdescr}

\rSec2[alg.transform]{Transform}

\indexlibraryglobal{transform}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator,
         class UnaryOperation>
  constexpr OutputIterator
    transform(InputIterator first1, InputIterator last1,
              OutputIterator result, UnaryOperation op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class UnaryOperation>
  ForwardIterator2
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 result, UnaryOperation op);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    transform(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, OutputIterator result,
              BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class BinaryOperation>
  ForwardIterator
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator result,
              BinaryOperation binary_op);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
         @\libconcept{copy_constructible}@ F, class Proj = identity>
  requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<I, Proj>>>
  constexpr ranges::unary_transform_result<I, O>
    ranges::transform(I first1, S last1, O result, F op, Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, @\libconcept{copy_constructible}@ F,
         class Proj = identity>
  requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
  constexpr ranges::unary_transform_result<borrowed_iterator_t<R>, O>
    ranges::transform(R&& r, O result, F op, Proj proj = {});
template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, @\libconcept{copy_constructible}@ F, class Proj1 = identity,
         class Proj2 = identity>
  requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<I1, Proj1>,
                               projected<I2, Proj2>>>
  constexpr ranges::binary_transform_result<I1, I2, O>
    ranges::transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
         @\libconcept{copy_constructible}@ F, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_writable}@<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                               projected<iterator_t<R2>, Proj2>>>
  constexpr ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::transform(R1&& r1, R2&& r2, O result,
                      F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let:
\begin{itemize}
\setlength{\emergencystretch}{1em}
\item
  \tcode{last2} be \tcode{first2 + (last1 - first1)}
  for the overloads with parameter \tcode{first2}
  but no parameter \tcode{last2};
\item
  $N$ be \tcode{last1 - first1} for unary transforms, or
  $\min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$ for binary transforms;
\item
  $E$ be
  \begin{itemize}
  \item
    \tcode{op(*(first1 + (i - result)))}
    for unary transforms defined in namespace \tcode{std};
  \item
    \tcode{binary_op(*(first1 + (i - result)), *(first2 + (i - result)))}
    for binary transforms defined in namespace \tcode{std};
  \item
    \tcode{invoke(op, invoke(proj, *(first1 + (i - result))))}
    for unary transforms defined in namespace \tcode{ranges};
  \item
    \tcode{invoke(binary_op, invoke(proj1, *(first1 + (i - result))), invoke(proj2,\linebreak *(first2 + (i - result))))}
    for binary transforms defined in namespace \tcode{ranges}.
  \end{itemize}
\end{itemize}

\pnum
\expects
\tcode{op} and \tcode{binary_op} do not invalidate iterators or subranges, nor
modify elements in the ranges
\begin{itemize}
\item \crange{first1}{first1 + $N$},
\item \crange{first2}{first2 + $N$}, and
\item \crange{result}{result + $N$}.
\begin{footnote}
The use of fully closed ranges is intentional.
\end{footnote}
\end{itemize}

\pnum
\effects
Assigns through every iterator \tcode{i}
in the range \range{result}{result + $N$}
a new corresponding value equal to $E$.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$}
  for the overloads defined in namespace \tcode{std}.
\item
  \tcode{\{first1 + $N$, result + $N$\}}
  for unary transforms defined in namespace \tcode{ranges}.
\item
  \tcode{\{first1 + $N$, first2 + $N$, result + $N$\}}
  for binary transforms defined in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ applications of \tcode{op} or \tcode{binary_op}, and
any projections.
This requirement also applies to the overload with an \tcode{ExecutionPolicy}.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first1} or \tcode{first2}.
\end{itemdescr}

\rSec2[alg.replace]{Replace}

\indexlibraryglobal{replace}%
\indexlibraryglobal{replace_if}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr void replace(ForwardIterator first, ForwardIterator last,
                         const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator,
         class T = iterator_traits<ForwardIterator>::value_type>
  void replace(ExecutionPolicy&& exec,
               ForwardIterator first, ForwardIterator last,
               const T& old_value, const T& new_value);

template<class ForwardIterator, class Predicate,
         class T = iterator_traits<ForwardIterator>::value_type>
  constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                            Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class Predicate,
         class T = iterator_traits<ForwardIterator>::value_type>
  void replace_if(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  Predicate pred, const T& new_value);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T1 = projected_value_t<I, Proj>, class T2 = T1>
  requires @\libconcept{indirectly_writable}@<I, const T2&> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T1*>
  constexpr I
    ranges::replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = T1>
  requires @\libconcept{indirectly_writable}@<iterator_t<R>, const T2&> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
  constexpr borrowed_iterator_t<R>
    ranges::replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{indirectly_writable}@<I, const T&>
  constexpr I ranges::replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{indirectly_writable}@<iterator_t<R>, const T&>
  constexpr borrowed_iterator_t<R>
    ranges::replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == old_value)} for \tcode{replace};
\item \tcode{bool(pred(*i))} for \tcode{replace_if};
\item \tcode{bool(invoke(proj, *i) == old_value)} for \tcode{ranges::replace};
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::replace_if}.
\end{itemize}


\pnum
\mandates
\tcode{new_value} is writable\iref{iterator.requirements.general} to \tcode{first}.

\pnum
\effects
Substitutes elements referred by the iterator \tcode{i}
in the range \range{first}{last} with \tcode{new_value},
when $E$ is \tcode{true}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.
\end{itemdescr}

\indexlibraryglobal{replace_copy}%
\indexlibraryglobal{replace_copy_if}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    replace_copy(InputIterator first, InputIterator last,
                 OutputIterator result,
                 const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
  ForwardIterator2
    replace_copy(ExecutionPolicy&& exec,
                 ForwardIterator1 first, ForwardIterator1 last,
                 ForwardIterator2 result,
                 const T& old_value, const T& new_value);

template<class InputIterator, class OutputIterator, class Predicate, class T>
  constexpr OutputIterator
    replace_copy_if(InputIterator first, InputIterator last,
                    OutputIterator result,
                    Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate, class T>
  ForwardIterator2
    replace_copy_if(ExecutionPolicy&& exec,
                    ForwardIterator1 first, ForwardIterator1 last,
                    ForwardIterator2 result,
                    Predicate pred, const T& new_value);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class O,
         class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
  requires @\libconcept{indirectly_copyable}@<I, O> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T1*> &&
           @\libconcept{output_iterator}@<O, const T2&>
  constexpr ranges::replace_copy_result<I, O>
    ranges::replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});
template<@\libconcept{input_range}@ R, class O, class Proj = identity,
         class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
           && @\libconcept{output_iterator}@<O, const T2&>
  constexpr ranges::replace_copy_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                         Proj proj = {});

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S,class O, class T = iter_value_t<O>,
         class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<I, O> && @\libconcept{output_iterator}@<O, const T&>
  constexpr ranges::replace_copy_if_result<I, O>
    ranges::replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                            Proj proj = {});
template<@\libconcept{input_range}@ R, class O, class T = iter_value_t<O>, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> && @\libconcept{output_iterator}@<O, const T&>
  constexpr ranges::replace_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                            Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\setlength{\emergencystretch}{1.5em}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*(first + (i - result)) == old_value)}
  for \tcode{replace_copy};
\item \tcode{bool(pred(*(first + (i - result))))}
  for \tcode{replace_copy_if};
\item \tcode{bool(invoke(proj, *(first + (i - result))) == old_value)}
  for \tcode{ranges::replace_copy};
\item \tcode{bool(invoke(pred, invoke(proj, *(first + (i - result)))))}
  for \tcode{ranges::replace_\-copy_if}.
\end{itemize}

\pnum
\mandates
The results of the expressions \tcode{*first} and \tcode{new_value}
are writable\iref{iterator.requirements.general} to \tcode{result}.

\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + (last - first)}
do not overlap.

\pnum
\effects
Assigns through every iterator \tcode{i}
in the range \range{result}{result + (last - first)}
a new corresponding value
\begin{itemize}
\item \tcode{new_value} if $E$ is \tcode{true} or
\item \tcode{*(first + (i - result))} otherwise.
\end{itemize}

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + (last - first)}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last, result + (last - first)\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.
\end{itemdescr}

\rSec2[alg.fill]{Fill}

\indexlibraryglobal{fill}%
\indexlibraryglobal{fill_n}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
         class T = iterator_traits<ForwardIterator>::value_type>
  void fill(ExecutionPolicy&& exec,
            ForwardIterator first, ForwardIterator last, const T& value);

template<class OutputIterator, class Size, class T = iterator_traits<OutputIterator>::value_type>
  constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size,
         class T = iterator_traits<ForwardIterator>::value_type>
  ForwardIterator fill_n(ExecutionPolicy&& exec,
                         ForwardIterator first, Size n, const T& value);

template<class O, @\libconcept{sentinel_for}@<O> S, class T = iter_value_t<O>>
  requires @\libconcept{output_iterator}@<O, const T&>
  constexpr O ranges::fill(O first, S last, const T& value);
template<class R, class T = range_value_t<R>>
  requires @\libconcept{output_range}@<R, const T&>
  constexpr borrowed_iterator_t<R> ranges::fill(R&& r, const T& value);
template<class O, class T = iter_value_t<O>>
  requires @\libconcept{output_iterator}@<O, const T&>
  constexpr O ranges::fill_n(O first, iter_difference_t<O> n, const T& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be $\max(0, \tcode{n})$ for the \tcode{fill_n} algorithms, and
\tcode{last - first} for the \tcode{fill} algorithms.

\pnum
\mandates
The expression \tcode{value}
is writable\iref{iterator.requirements.general} to the output iterator.
The type \tcode{Size} is convertible
to an integral type\iref{conv.integral,class.conv}.

\pnum
\effects
Assigns \tcode{value}
through all the iterators in the range \range{first}{first + $N$}.

\pnum
\returns
\tcode{first + $N$}.

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\rSec2[alg.generate]{Generate}

\indexlibraryglobal{generate}%
\indexlibraryglobal{generate_n}%
\begin{itemdecl}
template<class ForwardIterator, class Generator>
  constexpr void generate(ForwardIterator first, ForwardIterator last,
                          Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Generator>
  void generate(ExecutionPolicy&& exec,
                ForwardIterator first, ForwardIterator last,
                Generator gen);

template<class OutputIterator, class Size, class Generator>
  constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
  ForwardIterator generate_n(ExecutionPolicy&& exec,
                             ForwardIterator first, Size n, Generator gen);

template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{sentinel_for}@<O> S, @\libconcept{copy_constructible}@ F>
  requires @\libconcept{invocable}@<F&> && @\libconcept{indirectly_writable}@<O, invoke_result_t<F&>>
  constexpr O ranges::generate(O first, S last, F gen);
template<class R, @\libconcept{copy_constructible}@ F>
  requires @\libconcept{invocable}@<F&> && @\libconcept{output_range}@<R, invoke_result_t<F&>>
  constexpr borrowed_iterator_t<R> ranges::generate(R&& r, F gen);
template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{copy_constructible}@ F>
  requires @\libconcept{invocable}@<F&> && @\libconcept{indirectly_writable}@<O, invoke_result_t<F&>>
  constexpr O ranges::generate_n(O first, iter_difference_t<O> n, F gen);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be $\max(0, \tcode{n})$ for the \tcode{generate_n} algorithms, and
\tcode{last - first} for the \tcode{generate} algorithms.

\pnum
\mandates
\tcode{Size} is convertible
to an integral type\iref{conv.integral,class.conv}.

\pnum
\effects
Assigns the result of successive evaluations of \tcode{gen()}
through each iterator in the range \range{first}{first + $N$}.

\pnum
\returns
\tcode{first + $N$}.

\pnum
\complexity
Exactly $N$ evaluations of \tcode{gen()} and assignments.
\end{itemdescr}

\rSec2[alg.remove]{Remove}

\indexlibraryglobal{remove}%
\indexlibraryglobal{remove_if}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                   const T& value);
template<class ExecutionPolicy, class ForwardIterator,
         class T = iterator_traits<ForwardIterator>::value_type>
  ForwardIterator remove(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         const T& value);

template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator remove_if(ExecutionPolicy&& exec,
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr subrange<I> ranges::remove(I first, S last, const T& value, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{permutable}@<iterator_t<R>> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr borrowed_subrange_t<R>
    ranges::remove(R&& r, const T& value, Proj proj = {});
template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr subrange<I> ranges::remove_if(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::remove_if(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == value)} for \tcode{remove};
\item \tcode{bool(pred(*i))} for \tcode{remove_if};
\item \tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::remove};
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::remove_if}.
\end{itemize}

\pnum
\expects
For the algorithms in namespace \tcode{std},
the type of \tcode{*first}
meets the \oldconcept{MoveAssignable} requirements (\tref{cpp17.moveassignable}).

\pnum
\effects
Eliminates all the elements referred to by iterator \tcode{i}
in the range \range{first}{last} for which $E$ holds.

\pnum
\returns
Let $j$ be the end of the resulting range. Returns:
\begin{itemize}
\item $j$ for the overloads in namespace \tcode{std}.
\item \tcode{\{$j$, last\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.

\pnum
\begin{note}
Each element in the range \range{ret}{last},
where \tcode{ret} is the returned value,
has a valid but unspecified state,
because the algorithms can eliminate elements
by moving from elements that were originally in that range.
\end{note}
\end{itemdescr}

\indexlibraryglobal{remove_copy}%
\indexlibraryglobal{remove_copy_if}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator,
         class T = iterator_traits<InputIterator>::value_type>
  constexpr OutputIterator
    remove_copy(InputIterator first, InputIterator last,
                OutputIterator result, const T& value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class T = iterator_traits<ForwardIterator1>::value_type>
  ForwardIterator2
    remove_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, const T& value);

template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator
    remove_copy_if(InputIterator first, InputIterator last,
                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2
    remove_copy_if(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
         class Proj = identity, class T = projected_value_t<I, Proj>>
  requires @\libconcept{indirectly_copyable}@<I, O> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<I, Proj>, const T*>
  constexpr ranges::remove_copy_result<I, O>
    ranges::remove_copy(I first, S last, O result, const T& value, Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
           @\libconcept{indirect_binary_predicate}@<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
  constexpr ranges::remove_copy_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy(R&& r, O result, const T& value, Proj proj = {});
template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O,
         class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<I, O>
  constexpr ranges::remove_copy_if_result<I, O>
    ranges::remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
  constexpr ranges::remove_copy_if_result<borrowed_iterator_t<R>, O>
    ranges::remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == value)} for \tcode{remove_copy};
\item \tcode{bool(pred(*i))} for \tcode{remove_copy_if};
\item \tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::remove_copy};
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::remove_copy_if}.
\end{itemize}

\pnum
Let $N$ be the number of elements in \range{first}{last}
for which $E$ is \tcode{false}.

\pnum
\mandates
\tcode{*first} is writable\iref{iterator.requirements.general} to \tcode{result}.

\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + (last - first)}
do not overlap.
\begin{note}
For the overloads with an \tcode{ExecutionPolicy},
there might be a performance cost
if \tcode{iterator_traits<ForwardIterator1>::value_type} does not meet
the \oldconcept{\-Move\-Constructible} (\tref{cpp17.moveconstructible}) requirements.
\end{note}

\pnum
\effects
Copies all the elements referred to by the iterator \tcode{i}
in the range \range{first}{last} for which $E$ is \tcode{false}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + $N$}, for the algorithms in namespace \tcode{std}.
\item \tcode{\{last, result + $N$\}}, for the algorithms in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications
of the corresponding predicate and any projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.
\end{itemdescr}

\rSec2[alg.unique]{Unique}

\indexlibraryglobal{unique}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                   BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         BinaryPredicate pred);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<I, Proj>> C = ranges::equal_to>
  constexpr subrange<I> ranges::unique(I first, S last, C comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::unique(R&& r, C comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{pred} be \tcode{equal_to\{\}}
for the overloads with no parameter \tcode{pred}, and
let $E$ be
\begin{itemize}
\setlength{\emergencystretch}{1em}
\item
  \tcode{bool(pred(*(i - 1), *i))}
  for the overloads in namespace \tcode{std};
\item
  \tcode{bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{pred} is an equivalence relation and
the type of \tcode{*first} meets
the \oldconcept{MoveAssignable} requirements (\tref{cpp17.moveassignable}).

\pnum
\effects
For a nonempty range, eliminates all but the first element
from every consecutive group of equivalent elements referred to
by the iterator \tcode{i} in the range \range{first + 1}{last}
for which $E$ is \tcode{true}.

\pnum
\returns
Let $j$ be the end of the resulting range. Returns:
\begin{itemize}
\item $j$ for the overloads in namespace \tcode{std}.
\item \tcode{\{$j$, last\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
For nonempty ranges, exactly \tcode{(last - first) - 1} applications
of the corresponding predicate and
no more than twice as many applications of any projection.
\end{itemdescr}

\indexlibraryglobal{unique_copy}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result);

template<class InputIterator, class OutputIterator,
         class BinaryPredicate>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, BinaryPredicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<I, Proj>> C = ranges::equal_to>
  requires @\libconcept{indirectly_copyable}@<I, O> &&
           (@\libconcept{forward_iterator}@<I> ||
            (@\libconcept{input_iterator}@<O> && @\libconcept{same_as}@<iter_value_t<I>, iter_value_t<O>>) ||
            @\libconcept{indirectly_copyable_storable}@<I, O>)
  constexpr ranges::unique_copy_result<I, O>
    ranges::unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Proj = identity,
         @\libconcept{indirect_equivalence_relation}@<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
           (@\libconcept{forward_iterator}@<iterator_t<R>> ||
            (@\libconcept{input_iterator}@<O> && @\libconcept{same_as}@<range_value_t<R>, iter_value_t<O>>) ||
            @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, O>)
  constexpr ranges::unique_copy_result<borrowed_iterator_t<R>, O>
    ranges::unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{pred} be \tcode{equal_to\{\}} for the overloads
in namespace \tcode{std} with no parameter \tcode{pred}, and
let $E$ be
\begin{itemize}
\setlength{\emergencystretch}{1em}
\item
  \tcode{bool(pred(*i, *(i - 1)))}
  for the overloads in namespace \tcode{std};
\item
  \tcode{bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\mandates
\tcode{*first} is writable\iref{iterator.requirements.general} to \tcode{result}.

\pnum
\expects
\begin{itemize}
\item
  The ranges \range{first}{last} and \range{result}{result + (last - first)}
  do not overlap.
\item
  For the overloads in namespace \tcode{std}:
  \begin{itemize}
  \item
    The comparison function is an equivalence relation.
  \item
    For the overloads with no \tcode{ExecutionPolicy},
    let \tcode{T} be the value type of \tcode{InputIterator}.
    If \tcode{InputIterator} models
    \libconcept{forward_iterator}\iref{iterator.concept.forward},
    then there are no additional requirements for \tcode{T}.
    Otherwise, if \tcode{OutputIterator} meets
    the \oldconcept{ForwardIterator} requirements and
    its value type is the same as \tcode{T},
    then \tcode{T} meets
    the \oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}) requirements.
    Otherwise, \tcode{T} meets both
    the \oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible}) and
    \oldconcept{CopyAssignable} requirements.
    \begin{note}
    For the overloads with an \tcode{ExecutionPolicy},
    there might be a performance cost
    if the value type of \tcode{ForwardIterator1} does not meet both the
    \oldconcept{CopyConstructible} and \oldconcept{CopyAssignable} requirements.
    \end{note}
  \end{itemize}
\end{itemize}

\pnum
\effects
Copies only the first element from every consecutive group of equal elements
referred to by the iterator \tcode{i} in the range \range{first}{last}
for which $E$ holds.

\pnum
\returns
\begin{itemize}
\item \tcode{result + $N$} for the overloads in namespace \tcode{std}.
\item \tcode{\{last, result + $N$\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first - 1} applications
of the corresponding predicate
and no more than twice as many applications of any projection.
\end{itemdescr}

\rSec2[alg.reverse]{Reverse}

\indexlibraryglobal{reverse}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void reverse(ExecutionPolicy&& exec,
               BidirectionalIterator first, BidirectionalIterator last);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S>
  requires @\libconcept{permutable}@<I>
  constexpr I ranges::reverse(I first, S last);
template<@\libconcept{bidirectional_range}@ R>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_iterator_t<R> ranges::reverse(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{BidirectionalIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements}.

\pnum
\effects
For each non-negative integer \tcode{i < (last - first) / 2},
applies \tcode{std::iter_swap}, or
\tcode{ranges::\brk{}iter_swap} for the overloads in namespace \tcode{ranges},
to all pairs of iterators \tcode{first + i, (last - i) - 1}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
Exactly \tcode{(last - first)/2} swaps.
\end{itemdescr}

\indexlibraryglobal{reverse_copy}%
\begin{itemdecl}
template<class BidirectionalIterator, class OutputIterator>
  constexpr OutputIterator
    reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                 OutputIterator result);
template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
  ForwardIterator
    reverse_copy(ExecutionPolicy&& exec,
                 BidirectionalIterator first, BidirectionalIterator last,
                 ForwardIterator result);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<I, O>
  constexpr ranges::reverse_copy_result<I, O>
    ranges::reverse_copy(I first, S last, O result);
template<@\libconcept{bidirectional_range}@ R, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
  constexpr ranges::reverse_copy_result<borrowed_iterator_t<R>, O>
    ranges::reverse_copy(R&& r, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{last - first}.

\pnum
\expects
The ranges \range{first}{last} and \range{result}{result + $N$}
do not overlap.

\pnum
\effects
Copies the range \range{first}{last} to the range \range{result}{result + $N$}
such that for every non-negative integer \tcode{i < $N$}
the following assignment takes place:
\tcode{*(result + $N$ - 1 - i) = *(first + i)}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$} for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last, result + $N$\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\rSec2[alg.rotate]{Rotate}

\indexlibraryglobal{rotate}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    rotate(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator middle, ForwardIterator last);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
  constexpr subrange<I> ranges::rotate(I first, I middle, S last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{first}{middle} and \range{middle}{last} are valid ranges.
For the overloads in namespace \tcode{std},
\tcode{ForwardIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements}, and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
For each non-negative integer \tcode{i < (last - first)},
places the element from the position \tcode{first + i}
into position \tcode{first + (i + (last - middle)) \% (last - first)}.
\begin{note}
This is a left rotate.
\end{note}

\pnum
\returns
\begin{itemize}
\item
  \tcode{first + (last - middle)}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{first + (last - middle), last\}}
  for the overload in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{last - first} swaps.
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{forward_range}@ R>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::rotate(R&& r, iterator_t<R> middle);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return ranges::rotate(ranges::begin(r), middle, ranges::end(r));}
\end{itemdescr}

\indexlibraryglobal{rotate_copy}%
\begin{itemdecl}
template<class ForwardIterator, class OutputIterator>
  constexpr OutputIterator
    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    rotate_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 middle, ForwardIterator1 last,
                ForwardIterator2 result);

  template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O>
    requires @\libconcept{indirectly_copyable}@<I, O>
    constexpr ranges::rotate_copy_result<I, O>
      ranges::rotate_copy(I first, I middle, S last, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{last - first}.

\pnum
\expects
\range{first}{middle} and \range{middle}{last} are valid ranges.
The ranges \range{first}{last} and \range{result}{result + $N$}
do not overlap.

\pnum
\effects
Copies the range \range{first}{last} to the range \range{result}{result + $N$}
such that for each non-negative integer $i < N$
the following assignment takes place:
\tcode{*(result + $i$) =  *(first + ($i$ + (middle - first)) \% $N$)}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result + $N$} for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last, result + $N$\}} for the overload in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly $N$ assignments.
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{forward_range}@ R, @\libconcept{weakly_incrementable}@ O>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O>
  constexpr ranges::rotate_copy_result<borrowed_iterator_t<R>, O>
    ranges::rotate_copy(R&& r, iterator_t<R> middle, O result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return ranges::rotate_copy(ranges::begin(r), middle, ranges::end(r), std::move(result));
\end{codeblock}
\end{itemdescr}

\rSec2[alg.random.sample]{Sample}

\indexlibraryglobal{sample}%
\begin{itemdecl}
template<class PopulationIterator, class SampleIterator,
         class Distance, class UniformRandomBitGenerator>
  SampleIterator sample(PopulationIterator first, PopulationIterator last,
                        SampleIterator out, Distance n,
                        UniformRandomBitGenerator&& g);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O, class Gen>
  requires (@\libconcept{forward_iterator}@<I> || @\libconcept{random_access_iterator}@<O>) &&
           @\libconcept{indirectly_copyable}@<I, O> &&
           @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
  O ranges::sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O, class Gen>
  requires (@\libconcept{forward_range}@<R> || @\libconcept{random_access_iterator}@<O>) &&
           @\libconcept{indirectly_copyable}@<iterator_t<R>, O> &&
           @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
  O ranges::sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
For the overload in namespace \tcode{std},
\tcode{Distance} is an integer type and
\tcode{*first} is writable\iref{iterator.requirements.general} to \tcode{out}.

\pnum
\expects
\tcode{out} is not in the range \range{first}{last}.
For the overload in namespace \tcode{std}:
\begin{itemize}
\item
  \tcode{PopulationIterator} meets
  the \oldconcept{InputIterator} requirements\iref{input.iterators}.
\item
  \tcode{SampleIterator} meets
  the \oldconcept{OutputIterator} requirements\iref{output.iterators}.
\item
  \tcode{SampleIterator} meets
  the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}
  unless \tcode{Pop\-ulat\-ion\-Iter\-ator}
  models \libconcept{forward_iterator}\iref{iterator.concept.forward}.
\item
  \tcode{remove_reference_t<UniformRandomBitGenerator>} meets
  the requirements of a uniform random bit generator type\iref{rand.req.urng}.
\end{itemize}

\pnum
\effects
Copies $\min(\tcode{last - first}, \ \tcode{n})$ elements (the \defn{sample})
from \range{first}{last} (the \defn{population}) to \tcode{out}
such that each possible sample has equal probability of appearance.
\begin{note}
Algorithms that obtain such effects include \term{selection sampling}
and \term{reservoir sampling}.
\end{note}

\pnum
\returns
The end of the resulting sample range.

\pnum
\complexity
\bigoh{\tcode{last - first}}.

\pnum
\remarks
\begin{itemize}
\item
  For the overload in namespace \tcode{std},
  stable if and only if \tcode{PopulationIterator}
  models \libconcept{forward_iterator}.
  For the first overload in namespace \tcode{ranges},
  stable if and only if \tcode{I} models \libconcept{forward_iterator}.
\item
  To the extent that the implementation of this function makes use
  of random numbers, the object \tcode{g} serves as
  the implementation's source of randomness.
\end{itemize}
\end{itemdescr}

\rSec2[alg.random.shuffle]{Shuffle}

\indexlibraryglobal{shuffle}%
\begin{itemdecl}
template<class RandomAccessIterator, class UniformRandomBitGenerator>
  void shuffle(RandomAccessIterator first,
               RandomAccessIterator last,
               UniformRandomBitGenerator&& g);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Gen>
  requires @\libconcept{permutable}@<I> &&
           @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
  I ranges::shuffle(I first, S last, Gen&& g);
template<@\libconcept{random_access_range}@ R, class Gen>
  requires @\libconcept{permutable}@<iterator_t<R>> &&
           @\libconcept{uniform_random_bit_generator}@<remove_reference_t<Gen>>
  borrowed_iterator_t<R> ranges::shuffle(R&& r, Gen&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
For the overload in namespace \tcode{std}:
\begin{itemize}
\item
  \tcode{RandomAccessIterator} meets
  the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements}.
\item
  The type \tcode{remove_reference_t<UniformRandomBitGenerator>} meets
  the uniform random bit generator\iref{rand.req.urng} requirements.
\end{itemize}

\pnum
\effects
Permutes the elements in the range \range{first}{last}
such that each possible permutation of those elements
has equal probability of appearance.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
Exactly \tcode{(last - first) - 1} swaps.

\pnum
\remarks
To the extent that the implementation of this function makes use
of random numbers, the object referenced by \tcode{g} shall serve as
the implementation's source of randomness.
\end{itemdescr}

\rSec2[alg.shift]{Shift}

\indexlibraryglobal{shift_left}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    shift_left(ForwardIterator first, ForwardIterator last,
               typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    shift_left(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
               typename iterator_traits<ForwardIterator>::difference_type n);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
  constexpr subrange<I> ranges::shift_left(I first, S last, iter_difference_t<I> n);
template<@\libconcept{forward_range}@ R>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_left(R&& r, range_difference_t<R> n)
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n >= 0} is \tcode{true}.
For the overloads in namespace \tcode{std},
the type of \tcode{*first} meets the \oldconcept{MoveAssignable} requirements.

\pnum
\effects
If \tcode{n == 0} or \tcode{n >= last - first}, does nothing.
Otherwise, moves the element
from position \tcode{first + n + i}
into position \tcode{first + i}
for each non-negative integer \tcode{i < (last - first) - n}.
For the overloads without an \tcode{ExecutionPolicy} template parameter,
does so in order starting
from \tcode{i = 0} and proceeding to \tcode{i = (last - first) - n - 1}.

\pnum
\returns
Let \exposid{NEW_LAST} be \tcode{first + (last - first - n)}
if \tcode{n < last - first},
otherwise \tcode{first}.
\begin{itemize}
\item
\exposid{NEW_LAST} for the overloads in namespace \tcode{std}.
\item
\tcode{\{first, \exposid{NEW_LAST}\}}
for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{(last - first) - n} assignments.
\end{itemdescr}

\indexlibraryglobal{shift_right}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    shift_right(ForwardIterator first, ForwardIterator last,
                typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    shift_right(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                typename iterator_traits<ForwardIterator>::difference_type n);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S>
  constexpr subrange<I> ranges::shift_right(I first, S last, iter_difference_t<I> n);
template<@\libconcept{forward_range}@ R>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::shift_right(R&& r, range_difference_t<R> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{n >= 0} is \tcode{true}.
For the overloads in namespace \tcode{std},
the type of \tcode{*first} meets the \oldconcept{MoveAssignable} requirements,
and \tcode{ForwardIterator} meets
the \oldconcept{BidirectionalIterator} requirements\iref{bidirectional.iterators} or
the \oldconcept{ValueSwap\-pable} requirements.

\pnum
\effects
If \tcode{n == 0} or \tcode{n >= last - first}, does nothing.
Otherwise, moves the element
from position \tcode{first + i} into position \tcode{first + n + i}
for each non-negative integer \tcode{i < (last - first) - n}.
Does so in order starting
from \tcode{i = (last - first) - n - 1} and proceeding to \tcode{i = 0} if
\begin{itemize}
\item
for the overload in namespace \tcode{std}
without an \tcode{ExecutionPolicy} template parameter,
\tcode{Forward\-Iterator} meets the \oldconcept{BidirectionalIterator} requirements,
\item
for the overloads in namespace \tcode{ranges},
\tcode{I} models \libconcept{bidirectional_iterator}.
\end{itemize}

\pnum
\returns
Let \exposid{NEW_FIRST} be \tcode{first + n} if \tcode{n < last - first},
otherwise \tcode{last}.
\begin{itemize}
\item
\exposid{NEW_FIRST} for the overloads in namespace \tcode{std}.
\item
\tcode{\{\exposid{NEW_FIRST}, last\}}
for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{(last - first) - n} assignments or swaps.
\end{itemdescr}

\rSec1[alg.sorting]{Sorting and related operations}

\rSec2[alg.sorting.general]{General}

\pnum
The operations in~\ref{alg.sorting} defined directly in namespace \tcode{std}
have two versions:
one that takes a function object of type \tcode{Compare} and
one that uses an \tcode{operator<}.

\pnum
\tcode{Compare} is a function object type\iref{function.objects}
that meets the requirements for a template parameter
named \tcode{BinaryPredicate}~\iref{algorithms.requirements}.
The return value of the function call operation
applied to an object of type \tcode{Compare},
when converted to \tcode{bool},
yields \tcode{true}
if the first argument of the call is less than the second, and
\tcode{false} otherwise.
\tcode{Compare comp} is used throughout
for algorithms assuming an ordering relation.

\pnum
For all algorithms that take \tcode{Compare},
there is a version that uses \tcode{operator<} instead.
That is, \tcode{comp(*i, *j) != false} defaults to \tcode{*i < *j != false}.
For algorithms other than those described in~\ref{alg.binary.search},
\tcode{comp} shall induce a strict weak ordering on the values.

\pnum
The term \term{strict} refers to the requirement
of an irreflexive relation (\tcode{!comp(x, x)} for all \tcode{x}),
and the term \term{weak} to requirements
that are not as strong as those for a total ordering,
but stronger than those for a partial ordering.
If we define \tcode{equiv(a, b)} as \tcode{!comp(a, b) \&\& !comp(b, a)},
then the requirements are that \tcode{comp} and \tcode{equiv}
both be transitive relations:

\begin{itemize}
\item \tcode{comp(a, b) \&\& comp(b, c)} implies \tcode{comp(a, c)}
\item \tcode{equiv(a, b) \&\& equiv(b, c)} implies \tcode{equiv(a, c)}
\end{itemize}
\begin{note}
Under these conditions, it can be shown that
\begin{itemize}
\item
  \tcode{equiv} is an equivalence relation,
\item
  \tcode{comp} induces a well-defined relation
  on the equivalence classes determined by \tcode{equiv}, and
\item
  the induced relation is a strict total ordering.
\end{itemize}
\end{note}

\pnum
\indexdefn{sequence!sorted!with respect to a comparator and projection}%
A sequence is \term{sorted with respect to a \tcode{comp} and \tcode{proj}}
for a comparator and projection \tcode{comp} and \tcode{proj}
if for every iterator \tcode{i} pointing to the sequence and
every non-negative integer \tcode{n}
such that \tcode{i + n} is a valid iterator
pointing to an element of the sequence,
\begin{codeblock}
bool(invoke(comp, invoke(proj, *(i + n)), invoke(proj, *i)))
\end{codeblock}
is \tcode{false}.

\pnum
\indexdefn{sequence!sorted!with respect to a comparator}%
A sequence is \term{sorted with respect to a comparator \tcode{comp}}
for a comparator \tcode{comp}
if it is sorted with respect to
\tcode{comp} and \tcode{identity\{\}} (the identity projection).

\pnum
A sequence \range{start}{finish} is
\term{partitioned with respect to an expression} \tcode{f(e)}
if there exists an integer \tcode{n}
such that for all \tcode{0 <= i < (finish - start)},
\tcode{f(*(start + i))} is \tcode{true} if and only if \tcode{i < n}.

\pnum
In the descriptions of the functions that deal with ordering relationships
we frequently use a notion of equivalence to describe concepts
such as stability.
The equivalence to which we refer is not necessarily an \tcode{operator==},
but an equivalence relation induced by the strict weak ordering.
That is, two elements \tcode{a} and \tcode{b} are considered equivalent
if and only if \tcode{!(a < b) \&\& !(b < a)}.

\rSec2[alg.sort]{Sorting}

\rSec3[sort]{\tcode{sort}}

\indexlibraryglobal{sort}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
                      Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last,
            Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::sort(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::sort(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Sorts the elements in the range \range{first}{last}
with respect to \tcode{comp} and \tcode{proj}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
Let $N$ be \tcode{last - first}.
\bigoh{N \log N} comparisons and projections.
\end{itemdescr}

\rSec3[stable.sort]{\tcode{stable_sort}}

\indexlibraryglobal{stable_sort}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I ranges::stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::stable_sort(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Sorts the elements in the range \range{first}{last}
with respect to \tcode{comp} and \tcode{proj}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
Let $N$ be \tcode{last - first}.
If enough extra memory is available, $N \log(N)$ comparisons.
Otherwise, at most $N \log^2(N)$ comparisons.
In either case, twice as many projections as the number of comparisons.

\pnum
\remarks
Stable\iref{algorithm.stable}.
\end{itemdescr}

\rSec3[partial.sort]{\tcode{partial_sort}}

\indexlibraryglobal{partial_sort}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void partial_sort(RandomAccessIterator first,
                              RandomAccessIterator middle,
                              RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void partial_sort(RandomAccessIterator first,
                              RandomAccessIterator middle,
                              RandomAccessIterator last,
                              Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last,
                    Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
\range{first}{middle} and \range{middle}{last} are valid ranges.
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Places the first \tcode{middle - first} elements
from the range \range{first}{last}
as sorted with respect to \tcode{comp} and \tcode{proj}
into the range \range{first}{middle}.
The rest of the elements in the range \range{middle}{last}
are placed in an unspecified order.
\indextext{unspecified}%

\pnum
\returns
\tcode{last} for the overload in namespace \tcode{ranges}.

\pnum
\complexity
Approximately \tcode{(last - first) * log(middle - first)} comparisons, and
twice as many projections.
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::partial_sort(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return ranges::partial_sort(ranges::begin(r), middle, ranges::end(r), comp, proj);
\end{codeblock}
\end{itemdescr}

\rSec3[partial.sort.copy]{\tcode{partial_sort_copy}}

\indexlibraryglobal{partial_sort_copy}%
\begin{itemdecl}
template<class InputIterator, class RandomAccessIterator>
  constexpr RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);

template<class InputIterator, class RandomAccessIterator,
         class Compare>
  constexpr RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
         class Compare>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{random_access_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_copyable}@<I1, I2> && @\libconcept{sortable}@<I2, Comp, Proj2> &&
           @\libconcept{indirect_strict_weak_order}@<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
  constexpr ranges::partial_sort_copy_result<I1, I2>
    ranges::partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{random_access_range}@ R2, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R1>, iterator_t<R2>> &&
           @\libconcept{sortable}@<iterator_t<R2>, Comp, Proj2> &&
           @\libconcept{indirect_strict_weak_order}@<Comp, projected<iterator_t<R1>, Proj1>,
                                      projected<iterator_t<R2>, Proj2>>
  constexpr ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
    ranges::partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be $\min(\tcode{last - first}, \ \tcode{result_last - result_first})$.
Let \tcode{comp} be \tcode{less\{\}}, and
\tcode{proj1} and \tcode{proj2} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\mandates
For the overloads in namespace \tcode{std},
the expression \tcode{*first}
is writable\iref{iterator.requirements.general} to \tcode{result_first}.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements},
the type of \tcode{*result_first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{\-Move\-Assignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
For iterators \tcode{a1} and \tcode{b1} in \range{first}{last}, and
iterators \tcode{x2} and \tcode{y2} in \range{result_first}{result_last},
after evaluating the assignment \tcode{*y2 = *b1}, let $E$ be the value of
\begin{codeblock}
bool(invoke(comp, invoke(proj1, *a1), invoke(proj2, *y2))).
\end{codeblock}
Then, after evaluating the assignment \tcode{*x2 = *a1}, $E$ is equal to
\begin{codeblock}
bool(invoke(comp, invoke(proj2, *x2), invoke(proj2, *y2))).
\end{codeblock}
\begin{note}
Writing a value from the input range into the output range does not affect
how it is ordered by \tcode{comp} and \tcode{proj1} or \tcode{proj2}.
\end{note}

\pnum
\effects
Places the first $N$ elements
as sorted with respect to \tcode{comp} and \tcode{proj2}
into the range \range{result_first}{result_first + $N$}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result_first + $N$} for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last, result_first + $N$\}} for
  the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Approximately \tcode{(last - first) * log $N$} comparisons,
and twice as many projections.
\end{itemdescr}

\rSec3[is.sorted]{\tcode{is_sorted}}

\indexlibraryglobal{is_sorted}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return is_sorted_until(first, last) == last;}
\end{itemdescr}

\indexlibraryglobal{is_sorted}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last) == last;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{is_sorted}%
\begin{itemdecl}
template<class ForwardIterator, class Compare>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                           Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return is_sorted_until(first, last, comp) == last;}
\end{itemdescr}


\indexlibraryglobal{is_sorted}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{is_sorted}%
\begin{itemdecl}
template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_sorted(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return ranges::is_sorted_until(first, last, comp, proj) == last;}
\end{itemdescr}

\indexlibraryglobal{is_sorted_until}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last,
                    Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last,
                    Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\returns
The last iterator \tcode{i} in \crange{first}{last}
for which the range \range{first}{i}
is sorted with respect to \tcode{comp} and \tcode{proj}.

\pnum
\complexity
Linear.
\end{itemdescr}

\rSec2[alg.nth.element]{Nth element}

\indexlibraryglobal{nth_element}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last,  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
\range{first}{nth} and \range{nth}{last} are valid ranges.
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements}, and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
After \tcode{nth_element} the element in the position pointed to by \tcode{nth}
is the element that would be in that position
if the whole range were sorted with respect to \tcode{comp} and \tcode{proj},
unless \tcode{nth == last}.
Also for every iterator \tcode{i} in the range \range{first}{nth}
and every iterator \tcode{j} in the range \range{nth}{last}
it holds that:
\tcode{bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))} is \tcode{false}.

\pnum
\returns
\tcode{last} for the overload in namespace \tcode{ranges}.

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy}, linear on average.
For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N} applications of
the predicate, and \bigoh{N \log N} swaps, where $N = \tcode{last - first}$.
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return ranges::nth_element(ranges::begin(r), nth, ranges::end(r), comp, proj);
\end{codeblock}
\end{itemdescr}

\rSec2[alg.binary.search]{Binary search}

\rSec3[alg.binary.search.general]{General}

\pnum
All of the algorithms in \ref{alg.binary.search} are versions of binary search and
assume that the sequence being searched
is partitioned with respect to an expression
formed by binding the search key to an argument of the comparison function.
They work on non-random access iterators minimizing the number of comparisons,
which will be logarithmic for all types of iterators.
They are especially appropriate for random access iterators,
because these algorithms do a logarithmic number of steps
through the data structure.
For non-random access iterators they execute a linear number of steps.

\rSec3[lower.bound]{\tcode{lower_bound}}

\indexlibraryglobal{lower_bound}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
         class Compare>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::lower_bound(I first, S last, const T& value, Comp comp = {},
                                  Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
           ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}} and
\tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
The elements \tcode{e} of \range{first}{last}
are partitioned with respect to the expression\\
\tcode{bool(invoke(comp, invoke(proj, e), value))}.

\pnum
\returns
The furthermost iterator \tcode{i} in the range \crange{first}{last}
such that for every iterator \tcode{j} in the range \range{first}{i},
\tcode{bool(invoke(comp, invoke(proj, *j), value))} is \tcode{true}.

\pnum
\complexity
At most $\log_2(\tcode{last - first}) + \bigoh{1}$ comparisons and projections.
\end{itemdescr}

\rSec3[upper.bound]{\tcode{upper_bound}}

\indexlibraryglobal{upper_bound}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
         class Compare>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
           ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}} and
\tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
The elements \tcode{e} of \range{first}{last}
are partitioned with respect to the expression\\
\tcode{!bool(invoke(comp, value, invoke(proj, e)))}.

\pnum
\returns
The furthermost iterator \tcode{i} in the range \crange{first}{last}
such that for every iterator \tcode{j} in the range \range{first}{i},
\tcode{!bool(invoke(comp, value, invoke(proj, *j)))} is \tcode{true}.

\pnum
\complexity
At most $\log_2(\tcode{last - first}) + \bigoh{1}$ comparisons and projections.
\end{itemdescr}

\rSec3[equal.range]{\tcode{equal_range}}

\indexlibraryglobal{equal_range}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value);

template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
         class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value,
                Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
  constexpr subrange<I>
    ranges::equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
           ranges::less>
  constexpr borrowed_subrange_t<R>
    ranges::equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}} and
\tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
The elements \tcode{e} of \range{first}{last}
are partitioned with respect to the expressions
\tcode{bool(invoke(comp, invoke(proj, e), value))} and
\tcode{!bool(invoke(comp, value, invoke(proj, e)))}.
Also, for all elements \tcode{e} of \range{first}{last},
\tcode{bool(comp(e, value))} implies \tcode{!bool(comp(\brk{}value, e))}
for the overloads in namespace \tcode{std}.

\pnum
\returns
\begin{itemize}
\item
For the overloads in namespace \tcode{std}:
\begin{codeblock}
{lower_bound(first, last, value, comp),
 upper_bound(first, last, value, comp)}
\end{codeblock}
\item
For the overloads in namespace \tcode{ranges}:
\begin{codeblock}
{ranges::lower_bound(first, last, value, comp, proj),
 ranges::upper_bound(first, last, value, comp, proj)}
\end{codeblock}
\end{itemize}

\pnum
\complexity
At most
$2 * \log_2(\tcode{last - first}) + \bigoh{1}$ comparisons and projections.
\end{itemdescr}

\rSec3[binary.search]{\tcode{binary_search}}

\indexlibraryglobal{binary_search}%
\begin{itemdecl}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value);

template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
         class Compare>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         class T = projected_value_t<I, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::binary_search(I first, S last, const T& value, Comp comp = {},
                                       Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         class T = projected_value_t<iterator_t<R>, Proj>,
         @\libconcept{indirect_strict_weak_order}@<const T*, projected<iterator_t<R>, Proj>> Comp =
           ranges::less>
  constexpr bool ranges::binary_search(R&& r, const T& value, Comp comp = {},
                                       Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}} and
\tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
The elements \tcode{e} of \range{first}{last}
are partitioned with respect to the expressions
\tcode{bool(invoke(comp, invoke(proj, e), value))} and
\tcode{!bool(invoke(comp, value, invoke(proj, e)))}.
Also, for all elements \tcode{e} of \range{first}{last},
\tcode{bool(comp(e, value))} implies \tcode{!bool(comp(\brk{}value, e))}
for the overloads in namespace \tcode{std}.

\pnum
\returns
\tcode{true} if and only if
for some iterator \tcode{i} in the range \range{first}{last},
\tcode{!bool(invoke(comp, invoke(proj, *i), value)) \&\&
!bool(invoke(comp, value, invoke(proj, *i)))}
is \tcode{true}.

\pnum
\complexity
At most $\log_2(\tcode{last - first}) + \bigoh{1}$ comparisons and projections.
\end{itemdescr}

\rSec2[alg.partitions]{Partitions}

\indexlibraryglobal{is_partitioned}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool is_partitioned(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last, Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr bool ranges::is_partitioned(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr bool ranges::is_partitioned(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter named \tcode{proj}.

\pnum
\returns
\tcode{true} if and only if the elements \tcode{e} of \range{first}{last}
are partitioned with respect to the expression
\tcode{bool(invoke(pred, invoke(proj, e)))}.

\pnum
\complexity
Linear.
At most \tcode{last - first} applications of \tcode{pred} and \tcode{proj}.
\end{itemdescr}

\indexlibraryglobal{partition}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator
    partition(ForwardIterator first, ForwardIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator
    partition(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last, Predicate pred);

template<@\libconcept{permutable}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr subrange<I>
    ranges::partition(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R>
    ranges::partition(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter named \tcode{proj}
and let $E(x)$ be \tcode{bool(invoke(\brk{}pred, invoke(proj, $x$)))}.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{ForwardIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements}.

\pnum
\effects
Places all the elements \tcode{e} in \range{first}{last}
that satisfy $E(\tcode{e})$ before all the elements that do not.

\pnum
\returns
Let \tcode{i} be an iterator such that $E(\tcode{*j})$ is
\tcode{true} for every iterator \tcode{j} in \range{first}{i} and
\tcode{false} for every iterator \tcode{j} in \range{i}{last}.
Returns:
\begin{itemize}
\item \tcode{i} for the overloads in namespace \tcode{std}.
\item \tcode{\{i, last\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}


\pnum
\complexity
Let $N = \tcode{last - first}$:
\begin{itemize}
\item
  For the overload with no \tcode{ExecutionPolicy},
  exactly $N$ applications of the predicate and projection.
  At most $N / 2$ swaps if the type of \tcode{first} meets
  the \oldconcept{BidirectionalIterator} requirements
  for the overloads in namespace \tcode{std} or
  models \libconcept{bidirectional_iterator}
  for the overloads in namespace \tcode{ranges},
  and at most $N$ swaps otherwise.
\item
  For the overload with an \tcode{ExecutionPolicy},
  \bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}

\end{itemdescr}

\indexlibraryglobal{stable_partition}%
\begin{itemdecl}
template<class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    constexpr stable_partition(BidirectionalIterator first, BidirectionalIterator last,
                               Predicate pred);
template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    stable_partition(ExecutionPolicy&& exec,
                     BidirectionalIterator first, BidirectionalIterator last, Predicate pred);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{permutable}@<I>
  constexpr subrange<I> ranges::stable_partition(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{bidirectional_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{permutable}@<iterator_t<R>>
  constexpr borrowed_subrange_t<R> ranges::stable_partition(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter named \tcode{proj}
and let $E(x)$ be \tcode{bool(invoke(\brk{}pred, invoke(proj, $x$)))}.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{BidirectionalIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Places all the elements \tcode{e} in \range{first}{last}
that satisfy $E(\tcode{e})$ before all the elements that do not.
The relative order of the elements in both groups is preserved.

\pnum
\returns
Let \tcode{i} be an iterator
such that for every iterator \tcode{j} in \range{first}{i},
$E(\tcode{*j})$ is \tcode{true},
and for every iterator \tcode{j} in the range \range{i}{last},
$E(\tcode{*j})$ is \tcode{false}.
Returns:
\begin{itemize}
\item \tcode{i} for the overloads in namespace \tcode{std}.
\item \tcode{\{i, last\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Let $N$ = \tcode{last - first}:
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy}, at most $N \log_2 N$ swaps,
  but only \bigoh{N} swaps if there is enough extra memory.
  Exactly $N$ applications of the predicate and projection.
\item
  For the overload with an \tcode{ExecutionPolicy},
  \bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}
\end{itemdescr}

\indexlibraryglobal{partition_copy}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator1, class OutputIterator2, class Predicate>
  constexpr pair<OutputIterator1, OutputIterator2>
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
         class ForwardIterator2, class Predicate>
  pair<ForwardIterator1, ForwardIterator2>
    partition_copy(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last,
                   ForwardIterator1 out_true, ForwardIterator2 out_false, Predicate pred);

template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S, @\libconcept{weakly_incrementable}@ O1, @\libconcept{weakly_incrementable}@ O2,
         class Proj = identity, @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<I, O1> && @\libconcept{indirectly_copyable}@<I, O2>
  constexpr ranges::partition_copy_result<I, O1, O2>
    ranges::partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                           Proj proj = {});
template<@\libconcept{input_range}@ R, @\libconcept{weakly_incrementable}@ O1, @\libconcept{weakly_incrementable}@ O2,
         class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  requires @\libconcept{indirectly_copyable}@<iterator_t<R>, O1> &&
           @\libconcept{indirectly_copyable}@<iterator_t<R>, O2>
  constexpr ranges::partition_copy_result<borrowed_iterator_t<R>, O1, O2>
    ranges::partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter named \tcode{proj} and
let $E(x)$ be \tcode{bool(invoke(\brk{}pred, invoke(proj, $x$)))}.

\pnum
\mandates
For the overloads in namespace \tcode{std},
the expression \tcode{*first}
is writable\iref{iterator.requirements.general}
to \tcode{out_true} and \tcode{out_false}.

\pnum
\expects
The input range and output ranges do not overlap.

\begin{note}
For the overload with an \tcode{ExecutionPolicy},
there might be a performance cost if \tcode{first}'s value type
does not meet the \oldconcept{CopyConstructible} requirements.
\end{note}

\pnum
\effects
For each iterator \tcode{i} in \range{first}{last},
copies \tcode{*i} to the output range beginning with \tcode{out_true}
if \tcode{$E(\tcode{*i})$} is \tcode{true}, or
to the output range beginning with \tcode{out_false} otherwise.

\pnum
\returns
Let \tcode{o1} be the end of the output range beginning at \tcode{out_true},
and \tcode{o2} the end of the output range beginning at \tcode{out_false}.
Returns
\begin{itemize}
\item \tcode{\{o1, o2\}} for the overloads in namespace \tcode{std}.
\item \tcode{\{last, o1, o2\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications of \tcode{pred} and \tcode{proj}.
\end{itemdescr}

\indexlibraryglobal{partition_point}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator
    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<I, Proj>> Pred>
  constexpr I ranges::partition_point(I first, S last, Pred pred, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_unary_predicate}@<projected<iterator_t<R>, Proj>> Pred>
  constexpr borrowed_iterator_t<R>
    ranges::partition_point(R&& r, Pred pred, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter named \tcode{proj}
and let $E(x)$ be \tcode{bool(invoke(\brk{}pred, invoke(proj, $x$)))}.

\pnum
\expects
The elements \tcode{e} of \range{first}{last}
are partitioned with respect to $E(\tcode{e})$.

\pnum
\returns
An iterator \tcode{mid}
such that $E(\tcode{*i})$ is \tcode{true}
for all iterators \tcode{i} in \range{first}{mid}, and
\tcode{false} for all iterators \tcode{i} in \range{mid}{last}.

\pnum
\complexity
\bigoh{\log(\tcode{last - first})} applications
of \tcode{pred} and \tcode{proj}.
\end{itemdescr}

\rSec2[alg.merge]{Merge}

\indexlibraryglobal{merge}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result, Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less, class Proj1 = identity,
         class Proj2 = identity>
  requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<I1, I2, O>
    ranges::merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::merge(R1&& r1, R2&& r2, O result,
                  Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be \tcode{(last1 - first1) + (last2 - first2)}.
Let \tcode{comp} be \tcode{less\{\}},
\tcode{proj1} be \tcode{identity\{\}}, and
\tcode{proj2} be \tcode{identity\{\}},
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2}
are sorted with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2},
respectively.
The resulting range does not overlap with either of the original ranges.

\pnum
\effects
Copies all the elements of the two ranges \range{first1}{last1} and
\range{first2}{last2} into the range \range{result}{result_last},
where \tcode{result_last} is \tcode{result + $N$}.
If an element \tcode{a} precedes \tcode{b} in an input range,
\tcode{a} is copied into the output range before \tcode{b}.
If \tcode{e1} is an element of \range{first1}{last1} and
\tcode{e2} of \range{first2}{last2},
\tcode{e2} is copied into the output range before \tcode{e1} if and only if
\tcode{bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))}
is \tcode{true}.

\pnum
\returns
\begin{itemize}
\item
  \tcode{result_last}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last1, last2, result_last\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy},
  at most $N - 1$ comparisons and applications of each projection.
\item
  For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N} comparisons.
\end{itemize}

\pnum
\remarks
Stable\iref{algorithm.stable}.
\end{itemdescr}

\indexlibraryglobal{inplace_merge}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr void inplace_merge(BidirectionalIterator first,
                               BidirectionalIterator middle,
                               BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  constexpr void inplace_merge(BidirectionalIterator first,
                               BidirectionalIterator middle,
                               BidirectionalIterator last, Compare comp);
template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I ranges::inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
\range{first}{middle} and \range{middle}{last} are valid ranges
sorted with respect to \tcode{comp} and \tcode{proj}.
For the overloads in namespace \tcode{std},
\tcode{BidirectionalIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Merges two sorted consecutive ranges
\range{first}{middle} and \range{middle}{last},
putting the result of the merge into the range \range{first}{last}.
The resulting range is sorted with respect to \tcode{comp} and \tcode{proj}.

\pnum
\returns
\tcode{last} for the overload in namespace \tcode{ranges}.

\pnum
\complexity
Let $N = \tcode{last - first}$:
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy}, and
  if enough additional memory is available, at most $N - 1$ comparisons.
\item
  Otherwise, \bigoh{N \log N} comparisons.
\end{itemize}
In either case, twice as many projections as comparisons.

\pnum
\remarks
Stable\iref{algorithm.stable}.
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return ranges::inplace_merge(ranges::begin(r), middle, ranges::end(r), comp, proj);
\end{codeblock}
\end{itemdescr}

\rSec2[alg.set.operations]{Set operations on sorted structures}

\rSec3[alg.set.operations.general]{General}

\pnum
Subclause \ref{alg.set.operations} defines all the basic set operations on sorted structures.
They also work with \tcode{multiset}s\iref{multiset}
containing multiple copies of equivalent elements.
The semantics of the set operations are generalized to \tcode{multiset}s
in a standard way by defining \tcode{set_union}
to contain the maximum number of occurrences of every element,
\tcode{set_intersection} to contain the minimum, and so on.

\rSec3[includes]{\tcode{includes}}

\indexlibraryglobal{includes}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2,
                          Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class Compare>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Proj1 = identity,
         class Proj2 = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool ranges::includes(R1&& r1, R2&& r2, Comp comp = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}},
\tcode{proj1} be \tcode{identity\{\}}, and
\tcode{proj2} be \tcode{identity\{\}},
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2} are sorted
with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2}, respectively.

\pnum
\returns
\tcode{true}
if and only if \range{first2}{last2} is a subsequence of \range{first1}{last1}.
\begin{note}
A sequence $S$ is a subsequence of another sequence $T$ if $S$ can be obtained
from $T$ by removing some, all, or none of $T$'s elements and keeping the
remaining elements in the same order.
\end{note}

\pnum
\complexity
At most \tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons and applications of each projection.
\end{itemdescr}

\rSec3[set.union]{\tcode{set_union}}

\indexlibraryglobal{set_union}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class OutputIterator>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result);

template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result, Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<I1, I2, O>
    ranges::set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}},
and \tcode{proj1} and \tcode{proj2} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2} are sorted
with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2}, respectively.
The resulting range does not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted union of the elements from the two ranges;
that is, the set of elements that are present in one or both of the ranges.

\pnum
\returns
Let \tcode{result_last} be the end of the constructed range.
Returns
\begin{itemize}
\item
  \tcode{result_last}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last1, last2, result_last\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons and applications of each projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.
If \range{first1}{last1} contains $m$ elements
that are equivalent to each other and
\range{first2}{last2} contains $n$ elements
that are equivalent to them,
then all $m$ elements from the first range
are copied to the output range, in order, and
then the final $\max(n - m, 0)$ elements from the second range
are copied to the output range, in order.
\end{itemdescr}

\rSec3[set.intersection]{\tcode{set_intersection}}

\indexlibraryglobal{set_intersection}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<I1, I2, O>
    ranges::set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_intersection(R1&& r1, R2&& r2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}},
and \tcode{proj1} and \tcode{proj2} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2} are sorted
with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2}, respectively.
The resulting range does not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted intersection of the elements from the two ranges;
that is, the set of elements that are present in both of the ranges.

\pnum
\returns
Let \tcode{result_last} be the end of the constructed range.
Returns
\begin{itemize}
\item
  \tcode{result_last}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last1, last2, result_last\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons and applications of each projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.
If \range{first1}{last1} contains $m$ elements
that are equivalent to each other and
\range{first2}{last2} contains $n$ elements
that are equivalent to them,
the first $\min(m, n)$ elements
are copied from the first range to the output range, in order.
\end{itemdescr}

\rSec3[set.difference]{\tcode{set_difference}}

\indexlibraryglobal{set_difference}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result, Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<I1, O>
    ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<borrowed_iterator_t<R1>, O>
    ranges::set_difference(R1&& r1, R2&& r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}},
and \tcode{proj1} and \tcode{proj2} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2} are sorted
with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2}, respectively.
The resulting range does not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range \range{first1}{last1}
which are not present in the range \range{first2}{last2}
to the range beginning at \tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
Let \tcode{result_last} be the end of the constructed range.
Returns
\begin{itemize}
\item
  \tcode{result_last}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last1, result_last\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons and applications of each projection.

\pnum
\remarks
If \range{first1}{last1} contains $m$ elements
that are equivalent to each other and
\range{first2}{last2} contains $n$ elements
that are equivalent to them,
the last $\max(m - n, 0)$ elements from \range{first1}{last1}
are copied to the output range, in order.
\end{itemdescr}

\rSec3[set.symmetric.difference]{\tcode{set_symmetric_difference}}

\indexlibraryglobal{set_symmetric_difference}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result, Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         @\libconcept{weakly_incrementable}@ O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<I1, I2, O>
    ranges::set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                     Comp comp = {}, Proj1 proj1 = {},
                                     Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, @\libconcept{weakly_incrementable}@ O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires @\libconcept{mergeable}@<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                    borrowed_iterator_t<R2>, O>
    ranges::set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                     Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}},
and \tcode{proj1} and \tcode{proj2} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The ranges \range{first1}{last1} and \range{first2}{last2} are sorted
with respect to \tcode{comp} and \tcode{proj1} or \tcode{proj2}, respectively.
The resulting range does not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range \range{first1}{last1}
that are not present in the range \range{first2}{last2},
and the elements of the range \range{first2}{last2}
that are not present in the range \range{first1}{last1}
to the range beginning at \tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
Let \tcode{result_last} be the end of the constructed range.
Returns
\begin{itemize}
\item
  \tcode{result_last}
  for the overloads in namespace \tcode{std}.
\item
  \tcode{\{last1, last2, result_last\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons and applications of each projection.

\pnum
\remarks
Stable\iref{algorithm.stable}.
If \range{first1}{last1} contains $m$ elements
that are equivalent to each other and
\range{first2}{last2} contains $n$ elements
that are equivalent to them,
then $|m - n|$ of those elements shall be copied to the output range:
the last $m - n$ of these elements from \range{first1}{last1} if $m > n$, and
the last $n - m$ of these elements from \range{first2}{last2} if $m < n$.
In either case, the elements are copied in order.
\end{itemdescr}

\rSec2[alg.heap.operations]{Heap operations}

\rSec3[alg.heap.operations.general]{General}

\pnum
A random access range \range{a}{b} is a
\defnx{heap with respect to \tcode{comp} and \tcode{proj}}
{heap with respect to comp and proj@heap with respect to \tcode{comp} and \tcode{proj}}
for a comparator and projection \tcode{comp} and \tcode{proj}
if its elements are organized such that:

\begin{itemize}
\item
  With \tcode{$N$ = b - a}, for all $i$, $0 < i < N$,
  \tcode{bool(invoke(comp, invoke(proj, a[$\left \lfloor{\frac{i - 1}{2}}\right \rfloor$]), invoke(\brk{}proj, a[$i$])))}
  is \tcode{false}.
\item
  \tcode{*a} may be removed by \tcode{pop_heap}, or
  a new element added by \tcode{push_heap},
  in \bigoh{\log N} time.
\end{itemize}

\pnum
These properties make heaps useful as priority queues.

\pnum
\tcode{make_heap} converts a range into a heap and
\tcode{sort_heap} turns a heap into a sorted sequence.

\rSec3[push.heap]{\tcode{push_heap}}

\indexlibraryglobal{push_heap}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::push_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::push_heap(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The range \range{first}{last - 1}
is a valid heap with respect to \tcode{comp} and \tcode{proj}.
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} requirements (\tref{cpp17.moveconstructible}) and
the \oldconcept{MoveAssignable} requirements (\tref{cpp17.moveassignable}).

\pnum
\effects
Places the value in the location \tcode{last - 1}
into the resulting heap \range{first}{last}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
At most $\log(\tcode{last - first})$ comparisons and twice as many projections.
\end{itemdescr}

\rSec3[pop.heap]{\tcode{pop_heap}}

\indexlibraryglobal{pop_heap}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                          Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::pop_heap(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The range \range{first}{last}
is a valid non-empty heap with respect to \tcode{comp} and \tcode{proj}.
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Swaps the value in the location \tcode{first}
with the value in the location
\tcode{last - 1}
and makes
\range{first}{last - 1}
into a heap with respect to \tcode{comp} and \tcode{proj}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
At most $2 \log(\tcode{last - first})$ comparisons and
twice as many projections.
\end{itemdescr}

\rSec3[make.heap]{\tcode{make_heap}}

\indexlibraryglobal{make_heap}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::make_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::make_heap(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwap\-pable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) and
\oldconcept{MoveAssignable} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Constructs a heap with respect to \tcode{comp} and \tcode{proj}
out of the range \range{first}{last}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
At most $3(\tcode{last - first})$ comparisons and twice as many projections.
\end{itemdescr}

\rSec3[sort.heap]{\tcode{sort_heap}}

\indexlibraryglobal{sort_heap}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr I
    ranges::sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Comp = ranges::less, class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr borrowed_iterator_t<R>
    ranges::sort_heap(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\expects
The range \range{first}{last} is
a valid heap with respect to \tcode{comp} and \tcode{proj}.
For the overloads in namespace \tcode{std},
\tcode{RandomAccessIterator} meets
the \oldconcept{ValueSwappable} requirements\iref{swappable.requirements} and
the type of \tcode{*first} meets
the \oldconcept{MoveConst\-ruct\-ible} (\tref{cpp17.moveconstructible}) and
\oldconcept{Move\-Assign\-able} (\tref{cpp17.moveassignable}) requirements.

\pnum
\effects
Sorts elements in the heap \range{first}{last}
with respect to \tcode{comp} and \tcode{proj}.

\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.

\pnum
\complexity
At most $2N \log N$ comparisons, where $N = \tcode{last - first}$, and
twice as many projections.
\end{itemdescr}

\rSec3[is.heap]{\tcode{is_heap}}

\indexlibraryglobal{is_heap}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return is_heap_until(first, last) == last;}
\end{itemdescr}

\indexlibraryglobal{is_heap}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return is_heap_until(std::forward<ExecutionPolicy>(exec), first, last) == last;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{is_heap}%
\begin{itemdecl}
template<class RandomAccessIterator, class Compare>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                         Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return is_heap_until(first, last, comp) == last;}
\end{itemdescr}

\indexlibraryglobal{is_heap}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last,
               Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return is_heap_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{is_heap}%
\begin{itemdecl}
template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr bool ranges::is_heap(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{return ranges::is_heap_until(first, last, comp, proj) == last;}
\end{itemdescr}

\indexlibraryglobal{is_heap_until}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);

template<@\libconcept{random_access_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{random_access_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\returns
The last iterator \tcode{i} in \crange{first}{last}
for which the range \range{first}{i}
is a heap with respect to \tcode{comp} and \tcode{proj}.

\pnum
\complexity
Linear.
\end{itemdescr}


\rSec2[alg.min.max]{Minimum and maximum}

\indexlibraryglobal{min}%
\begin{itemdecl}
template<class T>
  constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& min(const T& a, const T& b, Compare comp);

template<class T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr const T& ranges::min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
For the first form, \tcode{T} meets the
\oldconcept{LessThanComparable} requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
The smaller value.
Returns the first argument when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison and two applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{min}%
\begin{itemdecl}
template<class T>
  constexpr T min(initializer_list<T> r);
template<class T, class Compare>
  constexpr T min(initializer_list<T> r, Compare comp);

template<@\libconcept{copyable}@ T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr T ranges::min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::min(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ranges::distance(r) > 0}.
For the overloads in namespace \tcode{std},
\tcode{T} meets the \oldconcept{\-Copy\-Constructible} requirements.
For the first form, \tcode{T} meets the \oldconcept{LessThanComparable}
requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
The smallest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the smallest.

\pnum
\complexity
Exactly \tcode{ranges::distance(r) - 1} comparisons
and twice as many applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{max}%
\begin{itemdecl}
template<class T>
  constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& max(const T& a, const T& b, Compare comp);

template<class T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr const T& ranges::max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
For the first form, \tcode{T} meets the
\oldconcept{LessThanComparable} requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
The larger value.
Returns the first argument when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison and two applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{max}%
\begin{itemdecl}
template<class T>
  constexpr T max(initializer_list<T> r);
template<class T, class Compare>
  constexpr T max(initializer_list<T> r, Compare comp);

template<@\libconcept{copyable}@ T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr T ranges::max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
  constexpr range_value_t<R>
    ranges::max(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ranges::distance(r) > 0}.
For the overloads in namespace \tcode{std},
\tcode{T} meets the \oldconcept{\-Copy\-Constructible} requirements.
For the first form, \tcode{T} meets the \oldconcept{LessThanComparable}
requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
The largest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the largest.

\pnum
\complexity
Exactly \tcode{ranges::distance(r) - 1} comparisons
and twice as many applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{minmax}%
\begin{itemdecl}
template<class T>
  constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>
  constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);

template<class T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_result<const T&>
    ranges::minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
\end{itemdecl}


\begin{itemdescr}
\pnum
\expects
For the first form, \tcode{T} meets the
\oldconcept{LessThanComparable} requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
\tcode{\{b, a\}} if \tcode{b} is smaller than \tcode{a}, and
\tcode{\{a, b\}} otherwise.

\pnum
\complexity
Exactly one comparison and two applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{minmax}%
\begin{itemdecl}
template<class T>
  constexpr pair<T, T> minmax(initializer_list<T> t);
template<class T, class Compare>
  constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

template<@\libconcept{copyable}@ T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_result<T>
    ranges::minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<@\libconcept{input_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  requires @\libconcept{indirectly_copyable_storable}@<iterator_t<R>, range_value_t<R>*>
  constexpr ranges::minmax_result<range_value_t<R>>
    ranges::minmax(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ranges::distance(r) > 0}.
For the overloads in namespace \tcode{std},
\tcode{T} meets the \oldconcept{\-Copy\-Constructible} requirements.
For the first form, type \tcode{T} meets the \oldconcept{LessThanComparable}
requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
Let \tcode{X} be the return type.
Returns \tcode{X\{x, y\}},
where \tcode{x} is a copy of the leftmost element with the smallest value and
\tcode{y} a copy of the rightmost element with the largest value
in the input range.

\pnum
\complexity
At most $(3/2)\tcode{ranges::distance(r)}$ applications
of the corresponding predicate
and twice as many applications of the projection, if any.

\pnum
\remarks
An invocation may explicitly specify
an argument for the template parameter \tcode{T}
of the overloads in namespace \tcode{std}.
\end{itemdescr}

\indexlibraryglobal{min_element}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last, Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::min_element(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::min_element(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\returns
The first iterator \tcode{i} in the range \range{first}{last}
such that for every iterator \tcode{j} in the range \range{first}{last},
\begin{codeblock}
bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))
\end{codeblock}
is \tcode{false}.
Returns \tcode{last} if \tcode{first == last}.

\pnum
\complexity
Exactly $\max(\tcode{last - first - 1}, 0)$ comparisons and
twice as many projections.
\end{itemdescr}

\indexlibraryglobal{max_element}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr I ranges::max_element(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr borrowed_iterator_t<R>
    ranges::max_element(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameters by those names.

\pnum
\returns
The first iterator \tcode{i} in the range \range{first}{last}
such that for every iterator \tcode{j} in the range \range{first}{last},
\begin{codeblock}
bool(invoke(comp, invoke(proj, *i), invoke(proj, *j)))
\end{codeblock}
is \tcode{false}.
Returns \tcode{last} if \tcode{first == last}.

\pnum
\complexity
Exactly $\max(\tcode{last - first - 1}, 0)$ comparisons and
twice as many projections.
\end{itemdescr}

\indexlibraryglobal{minmax_element}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last, Compare comp);

template<@\libconcept{forward_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<I>
    ranges::minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{forward_range}@ R, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R>, Proj>> Comp = ranges::less>
  constexpr ranges::minmax_element_result<borrowed_iterator_t<R>>
    ranges::minmax_element(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}


\begin{itemdescr}
\pnum
\returns
\tcode{\{first, first\}} if \range{first}{last} is empty, otherwise
\tcode{\{m, M\}}, where \tcode{m} is
the first iterator in \range{first}{last} such that no iterator in the range refers
to a smaller element, and where \tcode{M} is the last iterator
\begin{footnote}
This behavior
intentionally differs from \tcode{max_element}.
\end{footnote}
in \range{first}{last} such that no iterator in the range refers to a larger element.

\pnum
\complexity
Let $N$ be \tcode{last - first}.
At most $\max(\bigl\lfloor{\frac{3}{2}} (N-1)\bigr\rfloor, 0)$ comparisons and
twice as many applications of the projection, if any.
\end{itemdescr}

\rSec2[alg.clamp]{Bounded value}

\indexlibraryglobal{clamp}%
\begin{itemdecl}
template<class T>
  constexpr const T& clamp(const T& v, const T& lo, const T& hi);
template<class T, class Compare>
  constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);
template<class T, class Proj = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<const T*, Proj>> Comp = ranges::less>
  constexpr const T&
    ranges::clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
for the overloads with no parameter \tcode{comp},
and let \tcode{proj} be \tcode{identity\{\}}
for the overloads with no parameter \tcode{proj}.

\pnum
\expects
\tcode{bool(invoke(comp, invoke(proj, hi), invoke(proj, lo)))} is \tcode{false}.
For the first form, type \tcode{T}
meets the \oldconcept{LessThan\-Comparable}
requirements (\tref{cpp17.lessthancomparable}).

\pnum
\returns
\tcode{lo} if \tcode{bool(invoke(comp, invoke(proj, v), invoke(proj, lo)))} is \tcode{true},
\tcode{hi} if \tcode{bool(\brk{}invoke(comp, invoke(proj, hi), invoke(proj, v)))} is \tcode{true},
otherwise \tcode{v}.

\pnum
\begin{note}
If NaN is avoided, \tcode{T} can be a floating-point type.
\end{note}

\pnum
\complexity
At most two comparisons and three applications of the projection.
\end{itemdescr}

\rSec2[alg.lex.comparison]{Lexicographical comparison}

\indexlibraryglobal{lexicographical_compare}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Compare>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2,
                            Compare comp);

template<@\libconcept{input_iterator}@ I1, @\libconcept{sentinel_for}@<I1> S1, @\libconcept{input_iterator}@ I2, @\libconcept{sentinel_for}@<I2> S2,
         class Proj1 = identity, class Proj2 = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<I1, Proj1>,
                                    projected<I2, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<@\libconcept{input_range}@ R1, @\libconcept{input_range}@ R2, class Proj1 = identity,
         class Proj2 = identity,
         @\libconcept{indirect_strict_weak_order}@<projected<iterator_t<R1>, Proj1>,
                                    projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
  constexpr bool
    ranges::lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if and only if
the sequence of elements defined by the range \range{first1}{last1}
is lexicographically less than
the sequence of elements defined by the range \range{first2}{last2}.

\pnum
\complexity
At most $2 \min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$ applications
of the corresponding comparison and each projection, if any.

\pnum
\remarks
If two sequences have the same number of elements and
their corresponding elements (if any) are equivalent,
then neither sequence is lexicographically less than the other.
If one sequence is a proper prefix of the other,
then the shorter sequence is lexicographically less than the longer sequence.
Otherwise, the lexicographical comparison of the sequences yields
the same result as the comparison
of the first corresponding pair of elements that are not equivalent.

\pnum
\begin{example}
\tcode{ranges::lexicographical_compare(I1, S1, I2, S2, Comp, Proj1, Proj2)}
can be implemented as:
\begin{codeblock}
for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
  if (invoke(comp, invoke(proj1, *first1), invoke(proj2, *first2))) return true;
  if (invoke(comp, invoke(proj2, *first2), invoke(proj1, *first1))) return false;
}
return first1 == last1 && first2 != last2;
\end{codeblock}
\end{example}

\pnum
\begin{note}
An empty sequence is lexicographically less than any non-empty sequence,
but not less than any empty sequence.
\end{note}
\end{itemdescr}

\rSec2[alg.three.way]{Three-way comparison algorithms}

\indexlibraryglobal{lexicographical_compare_three_way}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class Cmp>
  constexpr auto
    lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                      InputIterator2 b2, InputIterator2 e2,
                                      Cmp comp)
      -> decltype(comp(*b1, *b2));
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $N$ be $\min(\tcode{e1 - b1}, \tcode{e2 - b2})$.
Let $E(n)$ be \tcode{comp(*(b1 + $n$), *(b2 + $n$))}.

\pnum
\mandates
\tcode{decltype(comp(*b1, *b2))} is a comparison category type.

\pnum
\returns
$E(i)$, where $i$ is the smallest integer in \range{0}{$N$}
such that \tcode{$E(i)$ != 0} is \tcode{true}, or
\tcode{(e1 - b1) <=> (e2 - b2)} if no such integer exists.

\pnum
\complexity
At most $N$ applications of \tcode{comp}.
\end{itemdescr}

\indexlibraryglobal{lexicographical_compare_three_way}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr auto
    lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                      InputIterator2 b2, InputIterator2 e2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return lexicographical_compare_three_way(b1, e1, b2, e2, compare_three_way());
\end{codeblock}
\end{itemdescr}

\rSec2[alg.permutation.generators]{Permutation generators}

\indexlibraryglobal{next_permutation}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr ranges::next_permutation_result<I>
    ranges::next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr ranges::next_permutation_result<borrowed_iterator_t<R>>
    ranges::next_permutation(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{BidirectionalIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range \range{first}{last}
and transforms it into the next permutation.
The next permutation is found by assuming that the set of all permutations
is lexicographically sorted with respect to \tcode{comp} and \tcode{proj}.
If no such permutation exists,
transforms the sequence into the first permutation;
that is, the ascendingly-sorted one.

\pnum
\returns
Let \tcode{B} be \tcode{true} if a next permutation was found and
otherwise \tcode{false}.
Returns:
\begin{itemize}
\item \tcode{B} for the overloads in namespace \tcode{std}.
\item \tcode{\{ last, B \}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{(last - first) / 2} swaps.
\end{itemdescr}

\indexlibraryglobal{prev_permutation}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

template<@\libconcept{bidirectional_iterator}@ I, @\libconcept{sentinel_for}@<I> S, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<I, Comp, Proj>
  constexpr ranges::prev_permutation_result<I>
    ranges::prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
template<@\libconcept{bidirectional_range}@ R, class Comp = ranges::less,
         class Proj = identity>
  requires @\libconcept{sortable}@<iterator_t<R>, Comp, Proj>
  constexpr ranges::prev_permutation_result<borrowed_iterator_t<R>>
    ranges::prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be \tcode{less\{\}}
and \tcode{proj} be \tcode{identity\{\}}
for overloads with no parameters by those names.

\pnum
\expects
For the overloads in namespace \tcode{std},
\tcode{BidirectionalIterator} meets
the \oldconcept{Value\-Swappable} requirements\iref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range \range{first}{last}
and transforms it into the previous permutation.
The previous permutation is found by assuming that the set of all permutations
is lexicographically sorted with respect to \tcode{comp} and \tcode{proj}.
If no such permutation exists,
transforms the sequence into the last permutation;
that is, the descendingly-sorted one.

\pnum
\returns
Let \tcode{B} be \tcode{true} if a previous permutation was found and
otherwise \tcode{false}.
Returns:
\begin{itemize}
\item \tcode{B} for the overloads in namespace \tcode{std}.
\item \tcode{\{ last, B \}} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\complexity
At most \tcode{(last - first) / 2} swaps.
\end{itemdescr}

\rSec1[numeric.ops.overview]{Header \tcode{<numeric>} synopsis}

\indexheader{numeric}%
\begin{codeblock}
// mostly freestanding
namespace std {
  // \ref{accumulate}, accumulate
  template<class InputIterator, class T>
    constexpr T accumulate(InputIterator first, InputIterator last, T init);
  template<class InputIterator, class T, class BinaryOperation>
    constexpr T accumulate(InputIterator first, InputIterator last, T init,
                           BinaryOperation binary_op);

  // \ref{reduce}, reduce
  template<class InputIterator>
    constexpr typename iterator_traits<InputIterator>::value_type
      reduce(InputIterator first, InputIterator last);
  template<class InputIterator, class T>
    constexpr T reduce(InputIterator first, InputIterator last, T init);
  template<class InputIterator, class T, class BinaryOperation>
    constexpr T reduce(InputIterator first, InputIterator last, T init,
                       BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator>
    typename iterator_traits<ForwardIterator>::value_type
      reduce(ExecutionPolicy&& exec,                            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
             ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    T reduce(ExecutionPolicy&& exec,                            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
             ForwardIterator first, ForwardIterator last, T init);
  template<class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation>
    T reduce(ExecutionPolicy&& exec,                            // freestanding-deleted, see \ref{algorithms.parallel.overloads}
             ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);

  // \ref{inner.product}, inner product
  template<class InputIterator1, class InputIterator2, class T>
    constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, T init);
  template<class InputIterator1, class InputIterator2, class T,
           class BinaryOperation1, class BinaryOperation2>
    constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, T init,
                              BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);

  // \ref{transform.reduce}, transform reduce
  template<class InputIterator1, class InputIterator2, class T>
    constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, T init);
  template<class InputIterator1, class InputIterator2, class T,
           class BinaryOperation1, class BinaryOperation2>
    constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, T init,
                                 BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
  template<class InputIterator, class T,
           class BinaryOperation, class UnaryOperation>
    constexpr T transform_reduce(InputIterator first, InputIterator last, T init,
                                 BinaryOperation binary_op, UnaryOperation unary_op);
  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2, class T>
    T transform_reduce(ExecutionPolicy&& exec,                  // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, T init);
  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation1, class BinaryOperation2>
    T transform_reduce(ExecutionPolicy&& exec,                  // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, T init,
                       BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
  template<class ExecutionPolicy, class ForwardIterator, class T,
           class BinaryOperation, class UnaryOperation>
    T transform_reduce(ExecutionPolicy&& exec,                  // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                       ForwardIterator first, ForwardIterator last, T init,
                       BinaryOperation binary_op, UnaryOperation unary_op);

  // \ref{partial.sum}, partial sum
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      partial_sum(InputIterator first, InputIterator last,
                  OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator
      partial_sum(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryOperation binary_op);

  // \ref{exclusive.scan}, exclusive scan
  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator
      exclusive_scan(InputIterator first, InputIterator last,
                     OutputIterator result, T init);
  template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
    constexpr OutputIterator
      exclusive_scan(InputIterator first, InputIterator last,
                     OutputIterator result, T init, BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
    ForwardIterator2
      exclusive_scan(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, T init);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation>
    ForwardIterator2
      exclusive_scan(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, T init, BinaryOperation binary_op);

  // \ref{inclusive.scan}, inclusive scan
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      inclusive_scan(InputIterator first, InputIterator last,
                     OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator
      inclusive_scan(InputIterator first, InputIterator last,
                     OutputIterator result, BinaryOperation binary_op);
  template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
    constexpr OutputIterator
      inclusive_scan(InputIterator first, InputIterator last,
                     OutputIterator result, BinaryOperation binary_op, T init);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      inclusive_scan(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation>
    ForwardIterator2
      inclusive_scan(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class T>
    ForwardIterator2
      inclusive_scan(ExecutionPolicy&& exec,                    // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, BinaryOperation binary_op, T init);

  // \ref{transform.exclusive.scan}, transform exclusive scan
  template<class InputIterator, class OutputIterator, class T,
           class BinaryOperation, class UnaryOperation>
    constexpr OutputIterator
      transform_exclusive_scan(InputIterator first, InputIterator last,
                               OutputIterator result, T init,
                               BinaryOperation binary_op, UnaryOperation unary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,
           class BinaryOperation, class UnaryOperation>
    ForwardIterator2
      transform_exclusive_scan(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first, ForwardIterator1 last,
                               ForwardIterator2 result, T init,
                               BinaryOperation binary_op, UnaryOperation unary_op);

  // \ref{transform.inclusive.scan}, transform inclusive scan
  template<class InputIterator, class OutputIterator,
           class BinaryOperation, class UnaryOperation>
    constexpr OutputIterator
      transform_inclusive_scan(InputIterator first, InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op, UnaryOperation unary_op);
  template<class InputIterator, class OutputIterator,
           class BinaryOperation, class UnaryOperation, class T>
    constexpr OutputIterator
      transform_inclusive_scan(InputIterator first, InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op, UnaryOperation unary_op, T init);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class UnaryOperation>
    ForwardIterator2
      transform_inclusive_scan(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first, ForwardIterator1 last,
                               ForwardIterator2 result, BinaryOperation binary_op,
                               UnaryOperation unary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation, class UnaryOperation, class T>
    ForwardIterator2
      transform_inclusive_scan(ExecutionPolicy&& exec,          // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first, ForwardIterator1 last,
                               ForwardIterator2 result,
                               BinaryOperation binary_op, UnaryOperation unary_op, T init);

  // \ref{adjacent.difference}, adjacent difference
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      adjacent_difference(InputIterator first, InputIterator last,
                          OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator
      adjacent_difference(InputIterator first, InputIterator last,
                          OutputIterator result, BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      adjacent_difference(ExecutionPolicy&& exec,               // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryOperation>
    ForwardIterator2
      adjacent_difference(ExecutionPolicy&& exec,               // freestanding-deleted, see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result, BinaryOperation binary_op);

  // \ref{numeric.iota}, iota
  template<class ForwardIterator, class T>
    constexpr void iota(ForwardIterator first, ForwardIterator last, T value);

  namespace ranges {
    template<class O, class T>
      using iota_result = out_value_result<O, T>;

    template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{sentinel_for}@<O> S, @\libconcept{weakly_incrementable}@ T>
      requires @\libconcept{indirectly_writable}@<O, const T&>
      constexpr iota_result<O, T> iota(O first, S last, T value);

    template<@\libconcept{weakly_incrementable}@ T, @\libconcept{output_range}@<const T&> R>
      constexpr iota_result<borrowed_iterator_t<R>, T> iota(R&& r, T value);
  }

  // \ref{numeric.ops.gcd}, greatest common divisor
  template<class M, class N>
    constexpr common_type_t<M, N> gcd(M m, N n);

  // \ref{numeric.ops.lcm}, least common multiple
  template<class M, class N>
    constexpr common_type_t<M, N> lcm(M m, N n);

  // \ref{numeric.ops.midpoint}, midpoint
  template<class T>
    constexpr T midpoint(T a, T b) noexcept;
  template<class T>
    constexpr T* midpoint(T* a, T* b);

  // \ref{numeric.sat}, saturation arithmetic
  template<class T>
    constexpr T add_sat(T x, T y) noexcept;
  template<class T>
    constexpr T sub_sat(T x, T y) noexcept;
  template<class T>
    constexpr T mul_sat(T x, T y) noexcept;
  template<class T>
    constexpr T div_sat(T x, T y) noexcept;
  template<class T, class U>
    constexpr T saturate_cast(U x) noexcept;
}
\end{codeblock}

\rSec1[numeric.ops]{Generalized numeric operations}

\rSec2[numeric.ops.general]{General}

\pnum
\begin{note}
The use of closed ranges as well as semi-open ranges
to specify requirements throughout \ref{numeric.ops} is intentional.
\end{note}

\rSec2[numerics.defns]{Definitions}

\indexlibrary{generalized_noncommutative_sum@\tcode{\placeholder{GENERALIZED_NONCOMMUTATIVE_SUM}}}%
\pnum
Define \tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(op, a1, ..., aN)}
as follows:
\begin{itemize}
\item
\tcode{a1} when \tcode{N} is \tcode{1}, otherwise

\item
\tcode{op(\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(op, a1, ..., aK),} \\
\tcode{\phantom{op(}\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(op, aM, ..., aN))}
for any \tcode{K} where $1 < \mathtt{K}+1 = \mathtt{M} \leq \mathtt{N}$.
\end{itemize}

\indexlibrary{generalized_sum@\tcode{\placeholder{GENERALIZED_SUM}}}%
\pnum
Define \tcode{\placeholdernc{GENERALIZED_SUM}(op, a1, ..., aN)} as
\tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(op, b1, ..., bN)},
where
\tcode{b1, ..., bN} may be any permutation of \tcode{a1, ..., aN}.

\rSec2[accumulate]{Accumulate}

\indexlibraryglobal{accumulate}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr T accumulate(InputIterator first, InputIterator last, T init);
template<class InputIterator, class T, class BinaryOperation>
  constexpr T accumulate(InputIterator first, InputIterator last, T init,
                         BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{T} meets
the \oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible})
and \oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}) requirements.
In the range \crange{first}{last},
\tcode{binary_op} neither modifies elements
nor invalidates iterators or subranges.
\begin{footnote}
The use of fully closed ranges is intentional.
\end{footnote}

\pnum
\effects
Computes its result by
initializing the accumulator \tcode{acc} with the initial value \tcode{init}
and then modifies it with
\tcode{acc = std::move(acc) + *i} or
\tcode{acc = binary_op(std::move(acc), *i)}
for every iterator \tcode{i} in the range \range{first}{last} in order.
\begin{footnote}
\tcode{accumulate} is similar
to the APL reduction operator and Common Lisp reduce function,
but it avoids the difficulty of defining the result of reduction
on an empty sequence by always requiring an initial value.
\end{footnote}
\end{itemdescr}

\rSec2[reduce]{Reduce}

\indexlibraryglobal{reduce}%
\begin{itemdecl}
template<class InputIterator>
  constexpr typename iterator_traits<InputIterator>::value_type
    reduce(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return reduce(first, last,
              typename iterator_traits<InputIterator>::value_type{});
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{reduce}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator>
  typename iterator_traits<ForwardIterator>::value_type
    reduce(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return reduce(std::forward<ExecutionPolicy>(exec), first, last,
              typename iterator_traits<ForwardIterator>::value_type{});
\end{codeblock}
\end{itemdescr}


\indexlibraryglobal{reduce}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr T reduce(InputIterator first, InputIterator last, T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return reduce(first, last, init, plus<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{reduce}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class T>
  T reduce(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator last, T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return reduce(std::forward<ExecutionPolicy>(exec), first, last, init, plus<>());
\end{codeblock}
\end{itemdescr}


\indexlibraryglobal{reduce}%
\begin{itemdecl}
template<class InputIterator, class T, class BinaryOperation>
  constexpr T reduce(InputIterator first, InputIterator last, T init,
                     BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation>
  T reduce(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator last, T init,
           BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}

\pnum
\mandates
All of
\begin{itemize}
\item \tcode{binary_op(init, *first)},
\item \tcode{binary_op(*first, init)},
\item \tcode{binary_op(init, init)}, and
\item \tcode{binary_op(*first, *first)}
\end{itemize}
are convertible to \tcode{T}.

\pnum
\expects
\begin{itemize}
\item
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements.
\item
  \tcode{binary_op} neither invalidates iterators or subranges,
  nor modifies elements in the range \crange{first}{last}.
\end{itemize}

\pnum
\returns
\tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, init, *i, ...)}
for every \tcode{i} in \range{first}{last}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications of \tcode{binary_op}.

\pnum
\begin{note}
The difference between \tcode{reduce} and \tcode{accumulate} is that
\tcode{reduce} applies \tcode{binary_op} in an unspecified order,
which yields a nondeterministic result
for non-associative or non-commutative \tcode{binary_op}
such as floating-point addition.
\end{note}
\end{itemdescr}

\rSec2[inner.product]{Inner product}

\indexlibraryglobal{inner_product}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class T>
  constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, T init);
template<class InputIterator1, class InputIterator2, class T,
         class BinaryOperation1, class BinaryOperation2>
  constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, T init,
                            BinaryOperation1 binary_op1,
                            BinaryOperation2 binary_op2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{T} meets
the \oldconcept{CopyConstructible} (\tref{cpp17.copyconstructible})
and \oldconcept{CopyAssignable} (\tref{cpp17.copyassignable}) requirements.
In the ranges \crange{first1}{last1} and
\crange{first2}{first2 + (last1 - first1)}
\tcode{binary_op1} and \tcode{binary_op2}
neither modifies elements nor invalidates iterators or subranges.
\begin{footnote}
The use of fully closed ranges is intentional.
\end{footnote}

\pnum
\effects
Computes its result by
initializing the accumulator \tcode{acc} with the initial value \tcode{init}
and then modifying it with
\tcode{acc = std::move(acc) + (*i1) * (*i2)} or
\tcode{acc = binary_op1(std::move(acc), binary_op2(*i1, *i2))}
for every iterator \tcode{i1} in the range \range{first1}{last1}
and iterator \tcode{i2} in the range \range{first2}{first2 + (last1 - first1)}
in order.
\end{itemdescr}

\rSec2[transform.reduce]{Transform reduce}
\indexlibraryglobal{transform_reduce}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class T>
  constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2,
                               T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return transform_reduce(first1, last1, first2, init, plus<>(), multiplies<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{transform_reduce}%
\begin{itemdecl}
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2, class T>
  T transform_reduce(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2,
                     T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return transform_reduce(std::forward<ExecutionPolicy>(exec),
                        first1, last1, first2, init, plus<>(), multiplies<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{transform_reduce}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class T,
         class BinaryOperation1, class BinaryOperation2>
  constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2,
                               T init,
                               BinaryOperation1 binary_op1,
                               BinaryOperation2 binary_op2);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2, class T,
         class BinaryOperation1, class BinaryOperation2>
  T transform_reduce(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2,
                     T init,
                     BinaryOperation1 binary_op1,
                     BinaryOperation2 binary_op2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
All of
  \begin{itemize}
  \item \tcode{binary_op1(init, init)},
  \item \tcode{binary_op1(init, binary_op2(*first1, *first2))},
  \item \tcode{binary_op1(binary_op2(*first1, *first2), init)}, and
  \item \tcode{binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))}
  \end{itemize}
  are convertible to \tcode{T}.

\pnum
\expects
\begin{itemize}
\item
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements.
\item
  Neither \tcode{binary_op1} nor \tcode{binary_op2}
  invalidates subranges, nor modifies elements in the ranges
  \crange{first1}{last1} and \crange{first2}{first2 + (last1 - first1)}.
\end{itemize}

\pnum
\returns
\begin{codeblock}
@\placeholdernc{GENERALIZED_SUM}@(binary_op1, init, binary_op2(*i, *(first2 + (i - first1))), ...)
\end{codeblock}
for every iterator \tcode{i} in \range{first1}{last1}.

\pnum
\complexity
\bigoh{\tcode{last1 - first1}} applications each
of \tcode{binary_op1} and \tcode{binary_op2}.
\end{itemdescr}

\indexlibraryglobal{transform_reduce}%
\begin{itemdecl}
template<class InputIterator, class T,
         class BinaryOperation, class UnaryOperation>
  constexpr T transform_reduce(InputIterator first, InputIterator last, T init,
                               BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
         class ForwardIterator, class T,
         class BinaryOperation, class UnaryOperation>
  T transform_reduce(ExecutionPolicy&& exec,
                     ForwardIterator first, ForwardIterator last,
                     T init, BinaryOperation binary_op, UnaryOperation unary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  All of
  \begin{itemize}
  \item \tcode{binary_op(init, init)},
  \item \tcode{binary_op(init, unary_op(*first))},
  \item \tcode{binary_op(unary_op(*first), init)}, and
  \item \tcode{binary_op(unary_op(*first), unary_op(*first))}
  \end{itemize}
  are convertible to \tcode{T}.

\pnum
\expects
\begin{itemize}
\item
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements.
\item
  Neither \tcode{unary_op} nor \tcode{binary_op} invalidates subranges,
  nor modifies elements in the range \crange{first}{last}.
\end{itemize}

\pnum
\returns
\begin{codeblock}
@\placeholdernc{GENERALIZED_SUM}@(binary_op, init, unary_op(*i), ...)
\end{codeblock}
for every iterator \tcode{i} in \range{first}{last}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications each of \tcode{unary_op} and
\tcode{binary_op}.

\pnum
\begin{note}
\tcode{transform_reduce} does not apply \tcode{unary_op} to \tcode{init}.
\end{note}
\end{itemdescr}

\rSec2[partial.sum]{Partial sum}

\indexlibraryglobal{partial_sum}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    partial_sum(InputIterator first, InputIterator last,
                OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    partial_sum(InputIterator first, InputIterator last,
                OutputIterator result, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{InputIterator}'s value type is constructible from \tcode{*first}.
The result of the
expression \tcode{std::move(acc) + *i} or \tcode{binary_op(std::move(acc), *i)}
is implicitly convertible to \tcode{InputIt\-er\-a\-tor}'s value type.
\tcode{acc} is writable\iref{iterator.requirements.general} to \tcode{result}.

\pnum
\expects
In the ranges \crange{first}{last} and \crange{result}{result + (last - first)}
\tcode{binary_op} neither modifies elements
nor invalidates iterators or subranges.
\begin{footnote}
The use of fully closed ranges is intentional.
\end{footnote}

\pnum
\effects
For a non-empty range,
the function creates an accumulator \tcode{acc}
whose type is \tcode{InputIterator}'s value type,
initializes it with \tcode{*first},
and assigns the result to \tcode{*result}.
For every iterator \tcode{i} in \range{first + 1}{last} in order,
\tcode{acc} is then modified by
\tcode{acc = std::move(acc) + *i} or \tcode{acc = binary_op(std::move(acc), *i)}
and the result is assigned to \tcode{*(result + (i - first))}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly \tcode{(last - first) - 1} applications of the binary operation.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}.
\end{itemdescr}

\rSec2[exclusive.scan]{Exclusive scan}

\indexlibraryglobal{exclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return exclusive_scan(first, last, result, init, plus<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{exclusive_scan}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
  ForwardIterator2
    exclusive_scan(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return exclusive_scan(std::forward<ExecutionPolicy>(exec),
                      first, last, result, init, plus<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{exclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
  constexpr OutputIterator
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init, BinaryOperation binary_op);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2, class T, class BinaryOperation>
  ForwardIterator2
    exclusive_scan(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, T init, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  All of
  \begin{itemize}
  \item \tcode{binary_op(init, init)},
  \item \tcode{binary_op(init, *first)}, and
  \item \tcode{binary_op(*first, *first)}
  \end{itemize}
  are convertible to \tcode{T}.


\pnum
\expects
\begin{itemize}
\item
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements.
\item
  \tcode{binary_op} neither invalidates iterators or subranges,
  nor modifies elements in
  the ranges \crange{first}{last} or \crange{result}{result + (last - first)}.
\end{itemize}

\pnum
\effects
For each integer \tcode{K} in \range{0}{last - first}
assigns through \tcode{result + K} the value of:
\begin{codeblock}
@\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}@(
    binary_op, init, *(first + 0), *(first + 1), ..., *(first + K - 1))
\end{codeblock}

\pnum
\returns
The end of the resulting range beginning at \tcode{result}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications of \tcode{binary_op}.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}.

\pnum
\begin{note}
The difference between \tcode{exclusive_scan} and \tcode{inclusive_scan} is
that \tcode{exclusive_scan} excludes the $i^\text{th}$ input element
from the $i^\text{th}$ sum.
If \tcode{binary_op} is not mathematically associative,
the behavior of \tcode{exclusive_scan} can be nondeterministic.
\end{note}
\end{itemdescr}

\rSec2[inclusive.scan]{Inclusive scan}

\indexlibraryglobal{inclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return inclusive_scan(first, last, result, plus<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{inclusive_scan}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    inclusive_scan(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return inclusive_scan(std::forward<ExecutionPolicy>(exec), first, last, result, plus<>());
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{inclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation>
  ForwardIterator2
    inclusive_scan(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, BinaryOperation binary_op);

template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
  constexpr OutputIterator
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op, T init);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2, class BinaryOperation, class T>
  ForwardIterator2
    inclusive_scan(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, BinaryOperation binary_op, T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be the value type of \tcode{decltype(first)}.

\pnum
\mandates
If \tcode{init} is provided, all of
\begin{itemize}
\item \tcode{binary_op(init, init)},
\item \tcode{binary_op(init, *first)}, and
\item \tcode{binary_op(*first, *first)}
\end{itemize}
are convertible to \tcode{T};
otherwise, \tcode{binary_op(*first, *first)}
is convertible to \tcode{U}.

\pnum
\expects
\begin{itemize}
\item
  If \tcode{init} is provided,
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements;
  otherwise, \tcode{U}
  meets the \oldconcept{MoveConstructible} requirements.
\item
  \tcode{binary_op} neither invalidates iterators or subranges,
  nor modifies elements in
  the ranges \crange{first}{last} or \crange{result}{result + (last - first)}.
\end{itemize}

\pnum
\effects
For each integer \tcode{K} in \range{0}{last - first}
assigns through \tcode{result + K} the value of
\begin{itemize}
\item
  \tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(\\\phantom{\tcode{\ \ \ \ }}binary_op,
  init, *(first + 0), *(first + 1), ..., *(first + K))}\\if \tcode{init} is provided, or
\item
  \tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(\\\phantom{\tcode{\ \ \ \ }}binary_op,
  *(first + 0), *(first + 1), ..., *(first + K))}\\otherwise.
\end{itemize}

\pnum
\returns
The end of the resulting range beginning at \tcode{result}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications of \tcode{binary_op}.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}.

\pnum
\begin{note}
The difference between \tcode{exclusive_scan} and \tcode{inclusive_scan} is
that \tcode{inclusive_scan} includes the $i^\text{th}$ input element
in the $i^\text{th}$ sum.
If \tcode{binary_op} is not mathematically associative,
the behavior of \tcode{inclusive_scan} can be nondeterministic.
\end{note}
\end{itemdescr}

\rSec2[transform.exclusive.scan]{Transform exclusive scan}

\indexlibraryglobal{transform_exclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T,
         class BinaryOperation, class UnaryOperation>
  constexpr OutputIterator
    transform_exclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result, T init,
                             BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2, class T,
         class BinaryOperation, class UnaryOperation>
  ForwardIterator2
    transform_exclusive_scan(ExecutionPolicy&& exec,
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, T init,
                             BinaryOperation binary_op, UnaryOperation unary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
  All of
  \begin{itemize}
  \item \tcode{binary_op(init, init)},
  \item \tcode{binary_op(init, unary_op(*first))}, and
  \item \tcode{binary_op(unary_op(*first), unary_op(*first))}
  \end{itemize}
  are convertible to \tcode{T}.

\pnum
\expects
\begin{itemize}
\item
  \tcode{T} meets the \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements.
\item
  Neither \tcode{unary_op} nor \tcode{binary_op}
  invalidates iterators or subranges, nor modifies elements in
  the ranges \crange{first}{last} or \crange{result}{result + (last - first)}.
\end{itemize}

\pnum
\effects
For each integer \tcode{K} in \range{0}{last - first}
assigns through \tcode{result + K} the value of:
\begin{codeblock}
@\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}@(
    binary_op, init,
    unary_op(*(first + 0)), unary_op(*(first + 1)), ..., unary_op(*(first + K - 1)))
\end{codeblock}

\pnum
\returns
The end of the resulting range beginning at \tcode{result}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications each
of \tcode{unary_op} and \tcode{binary_op}.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}.

\pnum
\begin{note}
The difference between \tcode{transform_exclusive_scan} and
\tcode{transform_inclusive_scan} is that \tcode{trans\-form\-_\-exclusive_scan}
excludes the $i^\text{th}$ input element from the $i^\text{th}$ sum.
If \tcode{binary_op} is not mathematically associative,
the behavior of \tcode{transform_exclusive_scan} can be nondeterministic.
\tcode{transform_exclusive_scan}
does not apply \tcode{unary_op} to \tcode{init}.
\end{note}
\end{itemdescr}

\rSec2[transform.inclusive.scan]{Transform inclusive scan}

\indexlibraryglobal{transform_inclusive_scan}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation>
  constexpr OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation, class UnaryOperation>
  ForwardIterator2
    transform_inclusive_scan(ExecutionPolicy&& exec,
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result,
                             BinaryOperation binary_op, UnaryOperation unary_op);
template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation, class T>
  constexpr OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);
template<class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation, class UnaryOperation, class T>
  ForwardIterator2
    transform_inclusive_scan(ExecutionPolicy&& exec,
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be the value type of \tcode{decltype(first)}.

\pnum
\mandates
If \tcode{init} is provided, all of
\begin{itemize}
\item \tcode{binary_op(init, init)},
\item \tcode{binary_op(init, unary_op(*first))}, and
\item \tcode{binary_op(unary_op(*first), unary_op(*first))}
\end{itemize}
are convertible to \tcode{T};
otherwise, \tcode{binary_op(unary_op(*first), unary_op(*first))}
is convertible to \tcode{U}.

\pnum
\expects
\begin{itemize}
\item
  If \tcode{init} is provided, \tcode{T} meets the
  \oldconcept{MoveConstructible} (\tref{cpp17.moveconstructible}) requirements;
  otherwise, \tcode{U} meets the
  \oldconcept{MoveConstructible} requirements.
\item
  Neither \tcode{unary_op} nor \tcode{binary_op} invalidates
  iterators or subranges, nor modifies elements in
  the ranges \crange{first}{last} or \crange{result}{result + (last - first)}.
\end{itemize}

\pnum
\effects
For each integer \tcode{K} in \range{0}{last - first}
assigns through \tcode{result + K} the value of
\begin{itemize}
\item
  \tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(\\\phantom{\tcode{\ \ \ \ }}binary_op, init,\\\phantom{\tcode{\ \ \ \ }}unary_op(*(first + 0)), unary_op(*(first + 1)), ..., unary_op(*(first + K)))}\\
  if \tcode{init} is provided, or
\item
  \tcode{\placeholdernc{GENERALIZED_NONCOMMUTATIVE_SUM}(\\\phantom{\tcode{\ \ \ \ }}binary_op,\\\phantom{\tcode{\ \ \ \ }}unary_op(*(first + 0)), unary_op(*(first + 1)), ..., unary_op(*(first + K)))}\\
  otherwise.
\end{itemize}

\pnum
\returns
The end of the resulting range beginning at \tcode{result}.

\pnum
\complexity
\bigoh{\tcode{last - first}} applications each
of \tcode{unary_op} and \tcode{binary_op}.

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}.

\pnum
\begin{note}
The difference between \tcode{transform_exclusive_scan} and
\tcode{transform_inclusive_scan} is that \tcode{trans\-form\-_\-inclusive_scan}
includes the $i^\text{th}$ input element in the $i^\text{th}$ sum.
If \tcode{binary_op} is not mathematically associative,
the behavior of \tcode{transform_inclusive_scan} can be nondeterministic.
\tcode{transform_inclusive_scan} does not
apply \tcode{unary_op} to \tcode{init}.
\end{note}
\end{itemdescr}

\rSec2[adjacent.difference]{Adjacent difference}

\indexlibraryglobal{adjacent_difference}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    adjacent_difference(InputIterator first, InputIterator last,
                        OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    adjacent_difference(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result);

template<class InputIterator, class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    adjacent_difference(InputIterator first, InputIterator last,
                        OutputIterator result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation>
  ForwardIterator2
    adjacent_difference(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be the value type of \tcode{decltype(first)}.
For the overloads that do not take an argument \tcode{binary_op},
let \tcode{binary_op} be an lvalue
that denotes an object of type \tcode{minus<>}.

\pnum
\mandates
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy},
  \tcode{T} is constructible from \tcode{*first}.
  \tcode{acc} (defined below) is
  writable\iref{iterator.requirements.general}
  to the \tcode{result} output iterator.
  The result of the expression \tcode{binary_op(val, std::move(acc))}
  is writable to \tcode{result}.
\item
  For the overloads with an \tcode{ExecutionPolicy},
  the result of the expressions \tcode{binary_op(*first, *first)} and
  \tcode{*first} are writable to \tcode{result}.
\end{itemize}

\pnum
\expects
\begin{itemize}
\item
  For the overloads with no \tcode{ExecutionPolicy},
  \tcode{T} meets the \oldconcept{MoveAssignable} (\tref{cpp17.moveassignable})
  requirements.
\item
  For all overloads, in the ranges \crange{first}{last}
  and \crange{result}{result + (last - first)},
  \tcode{binary_op} neither modifies elements
  nor invalidates iterators or subranges.
\begin{footnote}
The use of fully closed ranges is intentional.
\end{footnote}
\end{itemize}

\pnum
\effects
For the overloads with no \tcode{ExecutionPolicy} and a non-empty range,
the function creates an accumulator \tcode{acc} of type \tcode{T},
initializes it with \tcode{*first},
and assigns the result to \tcode{*result}.
For every iterator \tcode{i} in \range{first + 1}{last} in order,
creates an object \tcode{val} whose type is \tcode{T},
initializes it with \tcode{*i},
computes \tcode{binary_op(val, std::move(acc))},
assigns the result to \tcode{*(result + (i - first))}, and
move assigns from \tcode{val} to \tcode{acc}.

\pnum
For the overloads with an \tcode{ExecutionPolicy} and a non-empty range,
performs \tcode{*result = *first}.
Then, for every \tcode{d} in \crange{1}{last - first - 1},
performs \tcode{*(result + d) = binary_op(*(first + d), *(first + (d - 1)))}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly \tcode{(last - first) - 1} applications of the binary operation.

\pnum
\remarks
For the overloads with no \tcode{ExecutionPolicy},
\tcode{result} may be equal to \tcode{first}.
For the overloads with an \tcode{ExecutionPolicy},
the ranges \range{first}{last} and \range{result}{result + (last - first)}
shall not overlap.
\end{itemdescr}

\rSec2[numeric.iota]{Iota}

\indexlibraryglobal{iota}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr void iota(ForwardIterator first, ForwardIterator last, T value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{T} is convertible to \tcode{ForwardIterator}'s value type.
The expression \tcode{++val}, where \tcode{val} has type \tcode{T},
is well-formed.

\pnum
\effects
For each element referred to by the iterator \tcode{i}
in the range \range{first}{last},
assigns \tcode{*i = value} and increments \tcode{value}
as if by \tcode{++value}.

\pnum
\complexity
Exactly \tcode{last - first} increments and assignments.
\end{itemdescr}

\indexlibraryglobal{iota}%
\begin{itemdecl}
template<@\libconcept{input_or_output_iterator}@ O, @\libconcept{sentinel_for}@<O> S, @\libconcept{weakly_incrementable}@ T>
  requires @\libconcept{indirectly_writable}@<O, const T&>
  constexpr ranges::iota_result<O, T> ranges::iota(O first, S last, T value);
template<@\libconcept{weakly_incrementable}@ T, @\libconcept{output_range}@<const T&> R>
  constexpr ranges::iota_result<borrowed_iterator_t<R>, T> ranges::iota(R&& r, T value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
while (first != last) {
  *first = as_const(value);
  ++first;
  ++value;
}
return {std::move(first), std::move(value)};
\end{codeblock}
\end{itemdescr}

\rSec2[numeric.ops.gcd]{Greatest common divisor}

\indexlibraryglobal{gcd}%
\begin{itemdecl}
template<class M, class N>
  constexpr common_type_t<M, N> gcd(M m, N n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{M} and \tcode{N} both are integer types other than
\cv{}~\tcode{bool}.

\pnum
\expects
$|\tcode{m}|$ and $|\tcode{n}|$
are representable as a value of \tcode{common_type_t<M, N>}.
\begin{note}
These requirements ensure, for example,
that $\tcode{gcd(m, m)} = |\tcode{m}|$
is representable as a value of type \tcode{M}.
\end{note}


\pnum
\returns
Zero when \tcode{m} and \tcode{n} are both zero. Otherwise,
returns the greatest common divisor of $|\tcode{m}|$ and $|\tcode{n}|$.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec2[numeric.ops.lcm]{Least common multiple}

\indexlibraryglobal{lcm}%
\begin{itemdecl}
template<class M, class N>
  constexpr common_type_t<M, N> lcm(M m, N n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{M} and \tcode{N} both are integer types other than
\cv{}~\tcode{bool}.

\pnum
\expects
$|\tcode{m}|$ and $|\tcode{n}|$
are representable as a value of \tcode{common_type_t<M, N>}.
The least common multiple of $|\tcode{m}|$ and $|\tcode{n}|$
is representable as a value of type \tcode{common_type_t<M, N>}.

\pnum
\returns
Zero when either \tcode{m} or \tcode{n} is zero.
Otherwise, returns the least common multiple of $|\tcode{m}|$ and $|\tcode{n}|$.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec2[numeric.ops.midpoint]{Midpoint}

\indexlibraryglobal{midpoint}%
\begin{itemdecl}
template<class T>
  constexpr T midpoint(T a, T b) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\constraints
\tcode{T} is an arithmetic type other than \tcode{bool}.

\pnum
\returns
Half the sum of \tcode{a} and \tcode{b}.
If \tcode{T} is an integer type and the sum is odd,
the result is rounded towards \tcode{a}.

\pnum
\remarks
No overflow occurs.
If \tcode{T} is a floating-point type, at most one inexact operation occurs.
\end{itemdescr}

\indexlibraryglobal{midpoint}%
\begin{itemdecl}
template<class T>
  constexpr T* midpoint(T* a, T* b);
\end{itemdecl}
\begin{itemdescr}
\pnum
\constraints
\tcode{T} is an object type.

\pnum
\mandates
\tcode{T} is a complete type.

\pnum
\expects
\tcode{a} and \tcode{b} point to, respectively,
elements $i$ and $j$ of the same array object \tcode{x}.
\begin{note}
As specified in \ref{basic.compound},
an object that is not an array element
is considered to belong to a single-element array for this purpose and
a pointer past the last element of an array of $n$ elements
is considered to be equivalent to a pointer
to a hypothetical array element $n$ for this purpose.
\end{note}

\pnum
\returns
A pointer to array element $i+\frac{j-i}{2}$ of \tcode{x},
where the result of the division is truncated towards zero.
\end{itemdescr}

\rSec2[numeric.sat]{Saturation arithmetic}

\rSec3[numeric.sat.func]{Arithmetic functions}

\pnum
In the following descriptions, an arithmetic operation
is performed as a mathematical operation with infinite range and then
it is determined whether the mathematical result fits into the result type.

\indexlibraryglobal{add_sat}%
\begin{itemdecl}
template<class T>
  constexpr T add_sat(T x, T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
If $\tcode{x} + \tcode{y}$ is representable as a value of type \tcode{T}, $\tcode{x} + \tcode{y}$;
otherwise, either the largest or smallest representable value of type \tcode{T},
whichever is closer to the value of $\tcode{x} + \tcode{y}$.
\end{itemdescr}

\indexlibraryglobal{sub_sat}%
\begin{itemdecl}
template<class T>
  constexpr T sub_sat(T x, T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
If $\tcode{x} - \tcode{y}$ is representable as a value of type \tcode{T}, $\tcode{x} - \tcode{y}$;
otherwise, either the largest or smallest representable value of type \tcode{T},
whichever is closer to the value of $\tcode{x} - \tcode{y}$.
\end{itemdescr}

\indexlibraryglobal{mul_sat}%
\begin{itemdecl}
template<class T>
  constexpr T mul_sat(T x, T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\returns
If $\tcode{x} \times \tcode{y}$ is representable as a value of type \tcode{T}, $\tcode{x} \times \tcode{y}$;
otherwise, either the largest or smallest representable value of type \tcode{T},
whichever is closer to the value of $\tcode{x} \times \tcode{y}$.
\end{itemdescr}

\indexlibraryglobal{div_sat}%
\begin{itemdecl}
template<class T>
  constexpr T div_sat(T x, T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.

\pnum
\expects
\tcode{y != 0} is \tcode{true}.

\pnum
\returns
If \tcode{T} is a signed integer type
and \tcode{x == numeric_limits<T>::min() \&\& y == -1} is \tcode{true},
\tcode{numeric_limits<T>::max()}, otherwise, \tcode{x / y}.

\pnum
\remarks
A function call expression
that violates the precondition in the \Fundescx{Preconditions} element
is not a core constant expression\iref{expr.const}.
\end{itemdescr}

\rSec3[numeric.sat.cast]{Casting}

\indexlibraryglobal{saturate_cast}%
\begin{itemdecl}
template<class R, class T>
  constexpr R saturate_cast(T x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{R} and \tcode{T} are signed or unsigned integer types\iref{basic.fundamental}.

\pnum
\returns
If \tcode{x} is representable as a value of type \tcode{R}, \tcode{x};
otherwise, either the largest or smallest representable value of type \tcode{R},
whichever is closer to the value of \tcode{x}.
\end{itemdescr}

\rSec1[specialized.algorithms]{Specialized \tcode{<memory>} algorithms}

\rSec2[specialized.algorithms.general]{General}

\pnum
The contents specified in \ref{specialized.algorithms}
are declared in the header \libheaderref{memory}.

\pnum
Unless otherwise specified,
if an exception is thrown in the following algorithms,
objects constructed by a placement \grammarterm{new-expression}\iref{expr.new}
are destroyed in an unspecified order
before allowing the exception to propagate.

\pnum
\begin{note}
When new objects are created by
the algorithms specified in \ref{specialized.algorithms},
the lifetime ends for any existing objects
(including potentially-overlapping subobjects \ref{intro.object})
in storage that is reused \ref{basic.life}.
\end{note}

\pnum
Some algorithms specified in \ref{specialized.algorithms}
make use of the following exposition-only function templates:
\begin{codeblock}
template<class T>
  constexpr void* @\placeholdernc{voidify}@(T& obj) noexcept {
    return addressof(obj);
  }

template<class I>
  decltype(auto) @\exposid{deref-move}@(I& it) {
    if constexpr (is_lvalue_reference_v<decltype(*it)>)
      return std::move(*it);
    else
      return *it;
  }
\end{codeblock}

\rSec2[special.mem.concepts]{Special memory concepts}

\pnum
Some algorithms in this subclause are constrained with the following
exposition-only concepts:

\begin{itemdecl}
template<class I>
concept @\defexposconcept{nothrow-input-iterator}@ = // \expos
  @\libconcept{input_iterator}@<I> &&
  is_lvalue_reference_v<iter_reference_t<I>> &&
  @\libconcept{same_as}@<remove_cvref_t<iter_reference_t<I>>, iter_value_t<I>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
A type \tcode{I} models \exposconcept{nothrow-input-iterator} only if
no exceptions are thrown from increment,
copy construction, move construction,
copy assignment, move assignment,
or indirection through valid iterators.

\pnum
\begin{note}
This concept allows some \libconcept{input_iterator}\iref{iterator.concept.input}
operations to throw exceptions.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class S, class I>
concept @\defexposconcept{nothrow-sentinel-for}@ = @\libconcept{sentinel_for}@<S, I>; // \expos
\end{itemdecl}

\begin{itemdescr}
\pnum
Types \tcode{S} and \tcode{I} model \exposconcept{nothrow-sentinel-for}
only if no exceptions are thrown from copy construction, move construction,
copy assignment, move assignment, or comparisons between
valid values of type \tcode{I} and \tcode{S}.

\pnum
\begin{note}
This concept allows some \libconcept{sentinel_for}\iref{iterator.concept.sentinel}
operations to throw exceptions.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class R>
concept @\defexposconcept{nothrow-input-range}@ = // \expos
  @\libconcept{range}@<R> &&
  @\exposconcept{nothrow-input-iterator}@<iterator_t<R>> &&
  @\exposconcept{nothrow-sentinel-for}@<sentinel_t<R>, iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
A type \tcode{R} models \exposconcept{nothrow-input-range} only if
no exceptions are thrown from calls to \tcode{ranges::begin} and
\tcode{ranges::end} on an object of type \tcode{R}.
\end{itemdescr}

\begin{itemdecl}
template<class I>
concept @\defexposconcept{nothrow-forward-iterator}@ = // \expos
  @\exposconcept{nothrow-input-iterator}@<I> &&
  @\libconcept{forward_iterator}@<I> &&
  @\exposconcept{nothrow-sentinel-for}@<I, I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note}
This concept allows some \libconcept{forward_iterator}\iref{iterator.concept.forward}
operations to throw exceptions.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class R>
concept @\defexposconcept{nothrow-forward-range}@ = // \expos
  @\exposconcept{nothrow-input-range}@<R> &&
  @\exposconcept{nothrow-forward-iterator}@<iterator_t<R>>;
\end{itemdecl}

\rSec2[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}

\indexlibraryglobal{uninitialized_default_construct}%
\begin{itemdecl}
template<class NoThrowForwardIterator>
  constexpr void uninitialized_default_construct(NoThrowForwardIterator first,
                                                 NoThrowForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_default_construct}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I, @\exposconcept{nothrow-sentinel-for}@<I> S>
    requires @\libconcept{default_initializable}@<iter_value_t<I>>
    constexpr I uninitialized_default_construct(I first, S last);
  template<@\exposconcept{nothrow-forward-range}@ R>
    requires @\libconcept{default_initializable}@<range_value_t<R>>
    constexpr borrowed_iterator_t<R> uninitialized_default_construct(R&& r);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>;
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_default_construct_n}%
\begin{itemdecl}
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator
    uninitialized_default_construct_n(NoThrowForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type;
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_default_construct_n}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I>
    requires @\libconcept{default_initializable}@<iter_value_t<I>>
    constexpr I uninitialized_default_construct_n(I first, iter_difference_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return uninitialized_default_construct(counted_iterator(first, n),
                                       default_sentinel).base();
\end{codeblock}
\end{itemdescr}

\rSec2[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}

\indexlibraryglobal{uninitialized_value_construct}%
\begin{itemdecl}
template<class NoThrowForwardIterator>
  constexpr void uninitialized_value_construct(NoThrowForwardIterator first,
                                               NoThrowForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type();
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_value_construct}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I, @\exposconcept{nothrow-sentinel-for}@<I> S>
    requires @\libconcept{default_initializable}@<iter_value_t<I>>
    constexpr I uninitialized_value_construct(I first, S last);
  template<@\exposconcept{nothrow-forward-range}@ R>
    requires @\libconcept{default_initializable}@<range_value_t<R>>
    constexpr borrowed_iterator_t<R> uninitialized_value_construct(R&& r);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>();
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_value_construct_n}%
\begin{itemdecl}
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator
    uninitialized_value_construct_n(NoThrowForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type();
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_value_construct_n}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I>
    requires @\libconcept{default_initializable}@<iter_value_t<I>>
    constexpr I uninitialized_value_construct_n(I first, iter_difference_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return uninitialized_value_construct(counted_iterator(first, n),
                                     default_sentinel).base();
\end{codeblock}
\end{itemdescr}

\rSec2[uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibraryglobal{uninitialized_copy}%
\begin{itemdecl}
template<class InputIterator, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                                      NoThrowForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\countedrange{result}{(last - first)} does not overlap with \range{first}{last}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++result, (void)++first)
  ::new (@\placeholdernc{voidify}@(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\indexlibraryglobal{uninitialized_copy}%
\begin{itemdecl}
namespace ranges {
  template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S1,
           @\exposconcept{nothrow-forward-iterator}@ O, @\exposconcept{nothrow-sentinel-for}@<O> S2>
    requires @\libconcept{constructible_from}@<iter_value_t<O>, iter_reference_t<I>>
    constexpr uninitialized_copy_result<I, O>
      uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<@\libconcept{input_range}@ IR, @\exposconcept{nothrow-forward-range}@ OR>
    requires @\libconcept{constructible_from}@<range_value_t<OR>, range_reference_t<IR>>
    constexpr uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_copy(IR&& in_range, OR&& out_range);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} does not overlap with \range{ifirst}{ilast}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
  ::new (@\placeholdernc{voidify}@(*ofirst)) remove_reference_t<iter_reference_t<O>>(*ifirst);
return {std::move(ifirst), ofirst};
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_copy_n}%
\begin{itemdecl}
template<class InputIterator, class Size, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                                        NoThrowForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\countedrange{result}{n} does not overlap with \countedrange{first}{n}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; ++result, (void)++first, --n)
  ::new (@\placeholdernc{voidify}@(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\indexlibraryglobal{uninitialized_copy_n}%
\begin{itemdecl}
namespace ranges {
  template<@\libconcept{input_iterator}@ I, @\exposconcept{nothrow-forward-iterator}@ O, @\exposconcept{nothrow-sentinel-for}@<O> S>
    requires @\libconcept{constructible_from}@<iter_value_t<O>, iter_reference_t<I>>
    constexpr uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} does not overlap with
\countedrange{ifirst}{n}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
auto t = uninitialized_copy(counted_iterator(std::move(ifirst), n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
\end{codeblock}
\end{itemdescr}

\rSec2[uninitialized.move]{\tcode{uninitialized_move}}

\indexlibraryglobal{uninitialized_move}%
\begin{itemdecl}
template<class InputIterator, class NoThrowForwardIterator>
  constexpr NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                                      NoThrowForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\countedrange{result}{(last - first)} does not overlap with \range{first}{last}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; (void)++result, ++first)
  ::new (@\placeholdernc{voidify}@(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(@\exposid{deref-move}@(first));
return result;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_move}%
\begin{itemdecl}
namespace ranges {
  template<@\libconcept{input_iterator}@ I, @\libconcept{sentinel_for}@<I> S1,
           @\exposconcept{nothrow-forward-iterator}@ O, @\exposconcept{nothrow-sentinel-for}@<O> S2>
    requires @\libconcept{constructible_from}@<iter_value_t<O>, iter_rvalue_reference_t<I>>
    constexpr uninitialized_move_result<I, O>
      uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<@\libconcept{input_range}@ IR, @\exposconcept{nothrow-forward-range}@ OR>
    requires @\libconcept{constructible_from}@<range_value_t<OR>, range_rvalue_reference_t<IR>>
    constexpr uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
      uninitialized_move(IR&& in_range, OR&& out_range);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} does not overlap with \range{ifirst}{ilast}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
  ::new (@\placeholder{voidify}@(*ofirst))
    remove_reference_t<iter_reference_t<O>>(ranges::iter_move(ifirst));
return {std::move(ifirst), ofirst};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range \range{ifirst}{ilast} are
left in a valid, but unspecified state.
\end{note}
\end{itemdescr}

\indexlibraryglobal{uninitialized_move_n}%
\begin{itemdecl}
template<class InputIterator, class Size, class NoThrowForwardIterator>
  constexpr pair<InputIterator, NoThrowForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\countedrange{result}{n} does not overlap with \countedrange{first}{n}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; ++result, (void)++first, --n)
  ::new (@\placeholdernc{voidify}@(*result))
    typename iterator_traits<NoThrowForwardIterator>::value_type(@\exposid{deref-move}@(first));
return {first, result};
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_move_n}%
\begin{itemdecl}
namespace ranges {
  template<@\libconcept{input_iterator}@ I, @\exposconcept{nothrow-forward-iterator}@ O, @\exposconcept{nothrow-sentinel-for}@<O> S>
    requires @\libconcept{constructible_from}@<iter_value_t<O>, iter_rvalue_reference_t<I>>
    constexpr uninitialized_move_n_result<I, O>
      uninitialized_move_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} does not overlap with \countedrange{ifirst}{n}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
auto t = uninitialized_move(counted_iterator(std::move(ifirst), n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range
\countedrange{ifirst}{n}
are left in a valid but unspecified state.
\end{note}
\end{itemdescr}

\rSec2[uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibraryglobal{uninitialized_fill}%
\begin{itemdecl}
template<class NoThrowForwardIterator, class T>
  constexpr void uninitialized_fill(NoThrowForwardIterator first,
                                    NoThrowForwardIterator last, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_fill}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I, @\exposconcept{nothrow-sentinel-for}@<I> S, class T>
    requires @\libconcept{constructible_from}@<iter_value_t<I>, const T&>
    constexpr I uninitialized_fill(I first, S last, const T& x);
  template<@\exposconcept{nothrow-forward-range}@ R, class T>
    requires @\libconcept{constructible_from}@<range_value_t<R>, const T&>
    constexpr borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>(x);
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_fill_n}%
\begin{itemdecl}
template<class NoThrowForwardIterator, class Size, class T>
  constexpr NoThrowForwardIterator
    uninitialized_fill_n(NoThrowForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n--; ++first)
  ::new (@\placeholdernc{voidify}@(*first))
    typename iterator_traits<NoThrowForwardIterator>::value_type(x);
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{uninitialized_fill_n}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-forward-iterator}@ I, class T>
    requires @\libconcept{constructible_from}@<iter_value_t<I>, const T&>
    constexpr I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base();
\end{codeblock}
\end{itemdescr}

\rSec2[specialized.construct]{\tcode{construct_at}}

\indexlibraryglobal{construct_at}
\begin{itemdecl}
template<class T, class... Args>
  constexpr T* construct_at(T* location, Args&&... args);

namespace ranges {
  template<class T, class... Args>
    constexpr T* construct_at(T* location, Args&&... args);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_unbounded_array_v<T>} is \tcode{false}.
The expression \tcode{::new (declval<void*>()) T(\linebreak{}declval<Args>()...)}
is well-formed when treated as an unevaluated operand\iref{term.unevaluated.operand}.

\pnum
\mandates
If \tcode{is_array_v<T>} is \tcode{true}, \tcode{sizeof...(Args)} is zero.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (is_array_v<T>)
  return ::new (@\placeholdernc{voidify}@(*location)) T[1]();
else
  return ::new (@\placeholdernc{voidify}@(*location)) T(std::forward<Args>(args)...);
\end{codeblock}
\end{itemdescr}

\rSec2[specialized.destroy]{\tcode{destroy}}

\indexlibraryglobal{destroy_at}%
\begin{itemdecl}
template<class T>
  constexpr void destroy_at(T* location);
namespace ranges {
  template<@\libconcept{destructible}@ T>
    constexpr void destroy_at(T* location) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item If \tcode{T} is an array type, equivalent to
  \tcode{destroy(begin(*location), end(*location))}.
\item Otherwise, equivalent to
  \tcode{location->\~T()}.
\end{itemize}
\end{itemdescr}

\indexlibraryglobal{destroy}%
\begin{itemdecl}
template<class NoThrowForwardIterator>
  constexpr void destroy(NoThrowForwardIterator first, NoThrowForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  destroy_at(addressof(*first));
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{destroy}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-input-iterator}@ I, @\exposconcept{nothrow-sentinel-for}@<I> S>
    requires @\libconcept{destructible}@<iter_value_t<I>>
    constexpr I destroy(I first, S last) noexcept;
  template<@\exposconcept{nothrow-input-range}@ R>
    requires @\libconcept{destructible}@<range_value_t<R>>
    constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{destroy_n}%
\begin{itemdecl}
template<class NoThrowForwardIterator, class Size>
  constexpr NoThrowForwardIterator destroy_n(NoThrowForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{destroy_n}%
\begin{itemdecl}
namespace ranges {
  template<@\exposconcept{nothrow-input-iterator}@ I>
    requires @\libconcept{destructible}@<iter_value_t<I>>
    constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return destroy(counted_iterator(std::move(first), n), default_sentinel).base();
\end{codeblock}
\end{itemdescr}

\rSec1[alg.rand]{Specialized \tcode{<random>} algorithms}

\rSec2[alg.rand.general]{General}

\pnum
The contents specified in \ref{alg.rand}
are declared in the header \libheaderrefx{random}{rand.synopsis}.

\rSec2[alg.rand.generate]{\tcode{generate_random}}

\indexlibraryglobal{generate_random}%
\begin{itemdecl}
template<class R, class G>
  requires @\libconcept{output_range}@<R, invoke_result_t<G&>> && @\libconcept{uniform_random_bit_generator}@<remove_cvref_t<G>>
constexpr borrowed_iterator_t<R> ranges::generate_random(R&& r, G&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item
Calls \tcode{g.generate_random(std::forward<R>(r))}
if this expression is well-formed.
\item
Otherwise, if \tcode{R} models \libconcept{sized_range},
fills \tcode{r} with \tcode{ranges::size(r)} values of
type \tcode{invoke_result_t<G\&>} by performing
an unspecified number of invocations of
the form \tcode{g()} or \tcode{g.generate_random(s)},
if such an expression is well-formed for a value \tcode{N} and
an object \tcode{s} of type \tcode{span<invoke_result_t<G\&>, N>}.
\begin{note}
Values of \tcode{N} can differ between invocations.
\end{note}
\item
Otherwise, calls \tcode{ranges::generate(std::forward<R>(r), ref(g))}.
\end{itemize}

\pnum
\returns
\tcode{ranges::end(r)}.

\pnum
\remarks
The effects of \tcode{generate_random(r, g)} shall be equivalent to
\tcode{ranges::generate(std::for\-ward<R>(r), ref(g))}.
\begin{note}
This implies that \tcode{g.generate_random(a)} fills \tcode{a}
with the same values as produced by invocation of \tcode{g()}.
\end{note}
\end{itemdescr}

\indexlibraryglobal{generate_random}%
\begin{itemdecl}
template<class G, @\libconcept{output_iterator}@<invoke_result_t<G&>> O, @\libconcept{sentinel_for}@<O> S>
  requires @\libconcept{uniform_random_bit_generator}@<remove_cvref_t<G>>
constexpr O ranges::generate_random(O first, S last, G&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return generate_random(subrange<O, S>(std::move(first), last), g);
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{generate_random}%
\begin{itemdecl}
template<class R, class G, class D>
  requires @\libconcept{output_range}@<R, invoke_result_t<D&, G&>> && @\libconcept{invocable}@<D&, G&> &&
           @\libconcept{uniform_random_bit_generator}@<remove_cvref_t<G>> &&
           is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr borrowed_iterator_t<R> ranges::generate_random(R&& r, G&& g, D&& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item
Calls \tcode{d.generate_random(std::forward<R>(r), g)}
if this expression is well-formed.
\item
Otherwise, if \tcode{R} models \libconcept{sized_range},
fills \tcode{r} with \tcode{ranges::size(r)} values of
type \tcode{invoke_result_t<D\&, G\&>}
by performing an unspecified number of invocations of
the form \tcode{invoke(d, g)} or \tcode{d.generate_random(s, g)},
if such an expression is well-formed
for a value \tcode{N} and
an object \tcode{s} of type \tcode{span<invoke_result_t<D\&, G\&>, N>}.
\begin{note}
Values of N can differ between invocations.
\end{note}
\item
Otherwise, calls
\begin{codeblock}
ranges::generate(std::forward<R>(r), [&d, &g] { return invoke(d, g); });
\end{codeblock}
\end{itemize}

\pnum
\returns
\tcode{ranges::end(r)}.

\pnum
\remarks
The effects of \tcode{generate_random(r, g, d)} shall be equivalent to
\begin{codeblock}
ranges::generate(std::forward<R>(r), [&d, &g] { return invoke(d, g); })
\end{codeblock}
\begin{note}
This implies that \tcode{d.generate_random(a, g)}
fills \tcode{a} with the values with the same random distribution
as produced by invocation of \tcode{invoke(d, g)}.
\end{note}
\end{itemdescr}

\indexlibraryglobal{generate_random}%
\begin{itemdecl}
template<class G, class D, @\libconcept{output_iterator}@<invoke_result_t<D&, G&>> O, @\libconcept{sentinel_for}@<O> S>
  requires @\libconcept{invocable}@<D&, G&> && @\libconcept{uniform_random_bit_generator}@<remove_cvref_t<G>> &&
           is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr O ranges::generate_random(O first, S last, G&& g, D&& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return generate_random(subrange<O, S>(std::move(first), last), g, d);
\end{codeblock}
\end{itemdescr}

\rSec1[alg.c.library]{C library algorithms}

\pnum
\begin{note}
The header \libheaderref{cstdlib}
declares the functions described in this subclause.
\end{note}

\indexlibraryglobal{bsearch}%
\indexlibraryglobal{qsort}%
\begin{itemdecl}
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              @\placeholder{c-compare-pred}@* compar);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              @\placeholder{compare-pred}@* compar);
void qsort(void* base, size_t nmemb, size_t size, @\placeholder{c-compare-pred}@* compar);
void qsort(void* base, size_t nmemb, size_t size, @\placeholder{compare-pred}@* compar);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
For \tcode{qsort}, the objects in the array pointed to by \tcode{base}
are of trivially copyable type.

\pnum
\effects
These functions have the semantics specified in the C standard library.

\pnum
\throws
Any exception thrown by \tcode{compar}\iref{res.on.exception.handling}.
\end{itemdescr}

\xrefc{7.22.5}
