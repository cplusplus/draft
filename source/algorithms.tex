%!TEX root = std.tex
\rSec0[algorithms]{Algorithms library}

\rSec1[algorithms.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to perform
algorithmic operations on containers\iref{containers} and other sequences.

\pnum
The following subclauses describe components for
non-modifying sequence operations,
mutating sequence operations,
sorting and related operations,
and algorithms from the ISO C library,
as summarized in Table~\ref{tab:algorithms.summary}.

\begin{libsumtab}{Algorithms library summary}{tab:algorithms.summary}
\ref{alg.nonmodifying} & Non-modifying sequence operations  &           \\
\ref{alg.modifying.operations} & Mutating sequence operations & \tcode{<algorithm>} \\
\ref{alg.sorting} & Sorting and related operations      &           \\ \hline
\ref{alg.c.library} & C library algorithms          & \tcode{<cstdlib>} \\ \hline
\end{libsumtab}

\rSec1[algorithm.syn]{Header \tcode{<algorithm>} synopsis}
\indexhdr{algorithm}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{alg.nonmodifying}, non-modifying sequence operations
  // \ref{alg.all_of}, all of
  template<class InputIterator, class Predicate>
    constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool all_of(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);

  // \ref{alg.any_of}, any of
  template<class InputIterator, class Predicate>
    constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool any_of(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);

  // \ref{alg.none_of}, none of
  template<class InputIterator, class Predicate>
    constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool none_of(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last, Predicate pred);

  // \ref{alg.foreach}, for each
  template<class InputIterator, class Function>
    constexpr Function for_each(InputIterator first, InputIterator last, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Function>
    void for_each(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last, Function f);
  template<class InputIterator, class Size, class Function>
    constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
    ForwardIterator for_each_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Function f);

  // \ref{alg.find}, find
  template<class InputIterator, class T>
    constexpr InputIterator find(InputIterator first, InputIterator last,
                                 const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator find(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                         ForwardIterator first, ForwardIterator last,
                         const T& value);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                    Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if_not(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Predicate pred);

  // \ref{alg.find.end}, find end
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  // \ref{alg.find.first.of}, find first
  template<class InputIterator, class ForwardIterator>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template<class InputIterator, class ForwardIterator, class BinaryPredicate>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2,
                    BinaryPredicate pred);

  // \ref{alg.adjacent.find}, adjacent find
  template<class ForwardIterator>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);

  // \ref{alg.count}, count
  template<class InputIterator, class T>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count(InputIterator first, InputIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    typename iterator_traits<ForwardIterator>::difference_type
      count(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
            ForwardIterator first, ForwardIterator last, const T& value);
  template<class InputIterator, class Predicate>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    typename iterator_traits<ForwardIterator>::difference_type
      count_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last, Predicate pred);

  // \ref{mismatch}, mismatch
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  // \ref{alg.equal}, equal
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  // \ref{alg.is_permutation}, is permutation
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, BinaryPredicate pred);
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2,
                                  BinaryPredicate pred);

  // \ref{alg.search}, search
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      search(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1
      search(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template<class ForwardIterator, class Size, class T>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ForwardIterator, class Size, class T, class BinaryPredicate>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator
      search_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate>
    ForwardIterator
      search_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);

  template<class ForwardIterator, class Searcher>
    constexpr ForwardIterator
      search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);

  // \ref{alg.modifying.operations}, mutating sequence operations
  // \ref{alg.copy}, copy
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template<class InputIterator, class Size, class OutputIterator>
    constexpr OutputIterator copy_n(InputIterator first, Size n,
                                    OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class Size,
           class ForwardIterator2>
    ForwardIterator2 copy_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                            ForwardIterator1 first, Size n,
                            ForwardIterator2 result);
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2 copy_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, Predicate pred);
  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  // \ref{alg.move}, move
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator move(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2>
    ForwardIterator2 move(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  // \ref{alg.swap}, swap
  template<class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 swap_ranges(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template<class ForwardIterator1, class ForwardIterator2>
    void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  // \ref{alg.transform}, transform
  template<class InputIterator, class OutputIterator, class UnaryOperation>
    constexpr OutputIterator
      transform(InputIterator first, InputIterator last,
                OutputIterator result, UnaryOperation op);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation>
    constexpr OutputIterator
      transform(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class UnaryOperation>
    ForwardIterator2
      transform(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, UnaryOperation op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class BinaryOperation>
    ForwardIterator
      transform(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator result,
                BinaryOperation binary_op);

  // \ref{alg.replace}, replace
  template<class ForwardIterator, class T>
    constexpr void replace(ForwardIterator first, ForwardIterator last,
                           const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void replace(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value);
  template<class ForwardIterator, class Predicate, class T>
    constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
    void replace_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T& new_value);
  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
                                          OutputIterator result,
                                          const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
    ForwardIterator2 replace_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                  ForwardIterator1 first, ForwardIterator1 last,
                                  ForwardIterator2 result,
                                  const T& old_value, const T& new_value);
  template<class InputIterator, class OutputIterator, class Predicate, class T>
    constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                             OutputIterator result,
                                             Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate, class T>
    ForwardIterator2 replace_copy_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                     ForwardIterator1 first, ForwardIterator1 last,
                                     ForwardIterator2 result,
                                     Predicate pred, const T& new_value);

  // \ref{alg.fill}, fill
  template<class ForwardIterator, class T>
    constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void fill(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
              ForwardIterator first, ForwardIterator last, const T& value);
  template<class OutputIterator, class Size, class T>
    constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class Size, class T>
    ForwardIterator fill_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, Size n, const T& value);

  // \ref{alg.generate}, generate
  template<class ForwardIterator, class Generator>
    constexpr void generate(ForwardIterator first, ForwardIterator last,
                            Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Generator>
    void generate(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template<class OutputIterator, class Size, class Generator>
    constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
    ForwardIterator generate_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Generator gen);

  // \ref{alg.remove}, remove
  template<class ForwardIterator, class T>
    constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                     const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator remove(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           const T& value);
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator remove_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator
      remove_copy(InputIterator first, InputIterator last,
                  OutputIterator result, const T& value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class T>
    ForwardIterator2
      remove_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, const T& value);
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator
      remove_copy_if(InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2
      remove_copy_if(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, Predicate pred);

  // \ref{alg.unique}, unique
  template<class ForwardIterator>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                     BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator unique(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator unique(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryPredicate>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, BinaryPredicate pred);

  // \ref{alg.reverse}, reverse
  template<class BidirectionalIterator>
    void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void reverse(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 BidirectionalIterator first, BidirectionalIterator last);
  template<class BidirectionalIterator, class OutputIterator>
    constexpr OutputIterator
      reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                   OutputIterator result);
  template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
    ForwardIterator
      reverse_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                   BidirectionalIterator first, BidirectionalIterator last,
                   ForwardIterator result);

  // \ref{alg.rotate}, rotate
  template<class ForwardIterator>
    ForwardIterator rotate(ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator rotate(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template<class ForwardIterator, class OutputIterator>
    constexpr OutputIterator
      rotate_copy(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      rotate_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 middle,
                  ForwardIterator1 last, ForwardIterator2 result);

  // \ref{alg.random.sample}, sample
  template<class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator>
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&& g);

  // \ref{alg.random.shuffle}, shuffle
  template<class RandomAccessIterator, class UniformRandomBitGenerator>
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&& g);

  // \ref{alg.partitions}, partitions
  template<class InputIterator, class Predicate>
    constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool is_partitioned(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last, Predicate pred);

  template<class ForwardIterator, class Predicate>
    ForwardIterator partition(ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator partition(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template<class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template<class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate>
    constexpr pair<OutputIterator1, OutputIterator2>
      partition_copy(InputIterator first, InputIterator last,
                     OutputIterator1 out_true, OutputIterator2 out_false,
                     Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
           class ForwardIterator2, class Predicate>
    pair<ForwardIterator1, ForwardIterator2>
      partition_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last,
                     ForwardIterator1 out_true, ForwardIterator2 out_false,
                     Predicate pred);
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator
      partition_point(ForwardIterator first, ForwardIterator last,
                      Predicate pred);

  // \ref{alg.sorting}, sorting and related operations
  // \ref{alg.sort}, sorting
  template<class RandomAccessIterator>
    void sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void sort(RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);

  template<class RandomAccessIterator>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void stable_sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void stable_sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  template<class RandomAccessIterator>
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void partial_sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void partial_sort(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template<class InputIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class InputIterator, class RandomAccessIterator, class Compare>
    RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,  // see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
           class Compare>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,  // see \ref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template<class ForwardIterator>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                             Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    bool is_sorted(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    bool is_sorted(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template<class ForwardIterator>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last,
                      Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last,
                      Compare comp);

  // \ref{alg.nth.element}, Nth element
  template<class RandomAccessIterator>
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void nth_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void nth_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  // \ref{alg.binary.search}, binary search
  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  template<class ForwardIterator, class T>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  template<class ForwardIterator, class T>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value, Compare comp);

  // \ref{alg.merge}, merge
  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      merge(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      merge(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result, Compare comp);

  template<class BidirectionalIterator>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void inplace_merge(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
    void inplace_merge(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  // \ref{alg.set.operations}, set operations
  template<class InputIterator1, class InputIterator2>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool includes(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool includes(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  Compare comp);

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
                set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_union(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_union(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result, Compare comp);

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result, Compare comp);

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result, Compare comp);

  // \ref{alg.heap.operations}, heap operations
  template<class RandomAccessIterator>
    void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template<class RandomAccessIterator>
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);

  template<class RandomAccessIterator>
    void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template<class RandomAccessIterator>
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template<class RandomAccessIterator>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    bool is_heap(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    bool is_heap(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
  template<class RandomAccessIterator>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);

  // \ref{alg.min.max}, minimum and maximum
  template<class T> constexpr const T& min(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& min(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T min(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T min(initializer_list<T> t, Compare comp);

  template<class T> constexpr const T& max(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& max(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T max(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T max(initializer_list<T> t, Compare comp);

  template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
  template<class T, class Compare>
    constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr pair<T, T> minmax(initializer_list<T> t);
  template<class T, class Compare>
    constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

  template<class ForwardIterator>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator min_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator min_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template<class ForwardIterator>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator max_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator max_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template<class ForwardIterator>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last, Compare comp);

  // \ref{alg.clamp}, bounded value
  template<class T>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi);
  template<class T, class Compare>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);

  // \ref{alg.lex.comparison}, lexicographical comparison
  template<class InputIterator1, class InputIterator2>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool
      lexicographical_compare(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool
      lexicographical_compare(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              Compare comp);

  // \ref{alg.3way}, three-way comparison algorithms
  template<class T, class U>
    constexpr auto compare_3way(const T& a, const U& b);
  template<class InputIterator1, class InputIterator2, class Cmp>
    constexpr auto
      lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                   InputIterator2 b2, InputIterator2 e2,
                                   Cmp comp)
        -> common_comparison_category_t<decltype(comp(*b1, *b2)), strong_ordering>;
  template<class InputIterator1, class InputIterator2>
    constexpr auto
      lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                   InputIterator2 b2, InputIterator2 e2);

  // \ref{alg.permutation.generators}, permutations
  template<class BidirectionalIterator>
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
  template<class BidirectionalIterator>
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
}
\end{codeblock}

\rSec1[algorithms.requirements]{Algorithms requirements}
\pnum
All of the algorithms are separated from the particular implementations of data structures and are
parameterized by iterator types.
Because of this, they can work with program-defined data structures, as long
as these data structures have iterator types satisfying the assumptions on the algorithms.

\pnum
For purposes of determining the existence of data races, algorithms shall
not modify objects referenced through an iterator argument unless the
specification requires such modification.

\pnum
Throughout this Clause, the names of template parameters
are used to express type requirements.
\begin{itemize}
\item
If an algorithm's template parameter is named
\tcode{InputIterator},
\tcode{InputIterator1},
or
\tcode{Input\-Iterator2},
the template argument shall satisfy the
requirements of an input iterator\iref{input.iterators}.
\item
If an algorithm's template parameter is named
\tcode{OutputIterator},
\tcode{OutputIterator1},
or
\tcode{Output\-Iterator2},
the template argument shall satisfy the requirements
of an output iterator\iref{output.iterators}.
\item
If an algorithm's template parameter is named
\tcode{ForwardIterator},
\tcode{ForwardIterator1},
or
\tcode{Forward\-Iterator2},
the template argument shall satisfy the requirements
of a forward iterator\iref{forward.iterators}.
\item
If an algorithm's template parameter is named
\tcode{BidirectionalIterator},
\tcode{Bidirectional\-Iterator1},
or
\tcode{BidirectionalIterator2},
the template argument shall satisfy the requirements
of a bidirectional iterator\iref{bidirectional.iterators}.
\item
If an algorithm's template parameter is named
\tcode{RandomAccessIterator},
\tcode{Random\-AccessIterator1},
or
\tcode{RandomAccessIterator2},
the template argument shall satisfy the requirements
of a random-access iterator\iref{random.access.iterators}.
\end{itemize}

\pnum
If an algorithm's
\effects
element specifies that a value pointed to by any iterator passed
as an argument is modified, then that algorithm has an additional
type requirement:
The type of that argument shall satisfy the requirements
of a mutable iterator\iref{iterator.requirements}.
\begin{note}
This requirement does not affect arguments that are named
\tcode{OutputIterator},
\tcode{OutputIterator1},
or
\tcode{OutputIterator2},
because output iterators must always be mutable.
\end{note}

\pnum
Both in-place and copying versions are provided for certain
algorithms.\footnote{The decision whether to include a copying version was
usually based on complexity considerations. When the cost of doing the operation
dominates the cost of copy, the copying version is not included. For example,
\tcode{sort_copy} is not included because the cost of sorting is much more
significant, and users might as well do \tcode{copy} followed by \tcode{sort}.}
When such a version is provided for \textit{algorithm} it is called
\textit{algorithm\tcode{_copy}}. Algorithms that take predicates end with the
suffix \tcode{_if} (which follows the suffix \tcode{_copy}).

\pnum
The
\tcode{Predicate}
parameter is used whenever an algorithm expects a function object\iref{function.objects}
that, when applied to the result
of dereferencing the corresponding iterator, returns a value testable as
\tcode{true}.
In other words, if an algorithm
takes
\tcode{Predicate pred}
as its argument and \tcode{first}
as its iterator argument, it should work correctly in the
construct
\tcode{pred(*first)} contextually converted to \tcode{bool}\iref{conv}.
The function object
\tcode{pred}
shall not apply any non-constant
function through the dereferenced iterator.

\pnum
The
\tcode{BinaryPredicate}
parameter is used whenever an algorithm expects a function object that when applied to
the result of dereferencing two corresponding iterators or to dereferencing an
iterator and type
\tcode{T}
when
\tcode{T}
is part of the signature returns a value testable as
\tcode{true}.
In other words, if an algorithm takes
\tcode{BinaryPredicate binary_pred}
as its argument and \tcode{first1} and \tcode{first2} as
its iterator arguments, it should work correctly in
the construct
\tcode{binary_pred(*first1, *first2)} contextually converted to \tcode{bool}\iref{conv}.
\tcode{BinaryPredicate}
always takes the first
iterator's \tcode{value_type}
as its first argument, that is, in those cases when
\tcode{T value}
is part of the signature, it should work
correctly in the
construct \tcode{binary_pred(*first1, value)} contextually converted to \tcode{bool}\iref{conv}.
\tcode{binary_pred} shall not
apply any non-constant function through the dereferenced iterators.

\pnum
\begin{note}
Unless otherwise specified, algorithms that take function objects as arguments
are permitted to copy those function objects freely. Programmers for whom object
identity is important should consider using a wrapper class that points to a
noncopied implementation object such as \tcode{reference_wrapper<T>}\iref{refwrap}, or some equivalent solution.
\end{note}

\pnum
When the description of an algorithm gives an expression such as
\tcode{*first == value}
for a condition, the expression shall evaluate to
either \tcode{true} or \tcode{false} in boolean contexts.

\pnum
In the description of the algorithms operators
\tcode{+}
and
\tcode{-}
are used for some of the iterator categories for which
they do not have to be defined.
In these cases the semantics of
\tcode{a+n}
is the same as that of

\begin{codeblock}
X tmp = a;
advance(tmp, n);
return tmp;
\end{codeblock}

and that of
\tcode{b-a}
is the same as of

\begin{codeblock}
return distance(a, b);
\end{codeblock}

\rSec1[algorithms.parallel]{Parallel algorithms}

\pnum
This subclause describes components that \Cpp{} programs may use to perform
operations on containers and other sequences in parallel.

\rSec2[algorithms.parallel.defns]{Terms and definitions}
\pnum
A \defn{parallel algorithm} is a function template listed in this document with
a template parameter named \tcode{ExecutionPolicy}.

\pnum
Parallel algorithms access objects indirectly accessible via their arguments by
invoking the following functions:

\begin{itemize}
\item
All operations of the categories of the iterators that the algorithm is
instantiated with.

\item
Operations on those sequence elements that are required by its specification.

\item
User-provided function objects to be applied during the execution of the
algorithm, if required by the specification.

\item
Operations on those function objects required by the specification.
\begin{note} See~\ref{algorithms.general}.\end{note}
\end{itemize}

These functions are herein called \defn{element access functions}.
\begin{example}
The \tcode{sort} function may invoke the following element access functions:

\begin{itemize}
\item
Operations of the random-access iterator of the actual template argument
(as per \ref{random.access.iterators}),
as implied by the name of the template parameter \tcode{RandomAccessIterator}.

\item
The \tcode{swap} function on the elements of the sequence (as per the
preconditions specified in \ref{sort}).

\item
The user-provided \tcode{Compare} function object.
\end{itemize}
\end{example}

\rSec2[algorithms.parallel.user]{Requirements on user-provided function objects}

\pnum
Unless otherwise specified, function objects passed into parallel algorithms as
objects of type \tcode{Predicate}, \tcode{BinaryPredicate}, \tcode{Compare},
\tcode{UnaryOperation}, \tcode{BinaryOperation}, \tcode{BinaryOperation1},
\tcode{BinaryOperation2}, and the operators used by the analogous overloads to
these parallel algorithms that could be formed by the invocation with the
specified default predicate or operation (where applicable) shall not directly
or indirectly modify objects via their arguments, nor shall they rely on the
identity of the provided objects.

\rSec2[algorithms.parallel.exec]{Effect of execution policies on algorithm execution}

\pnum
Parallel algorithms have template parameters
named \tcode{ExecutionPolicy}\iref{execpol}
which describe the manner in which the execution of these algorithms may be
parallelized and the manner in which they apply the element access functions.

\pnum
If an object is modified by an element access function,
the algorithm will perform no other unsynchronized accesses to that object.
The modifying element access functions are those
which are specified as modifying the object in the relevant concept.
\begin{note}
For example,
\tcode{swap()}, \tcode{++}, \tcode{--}, \tcode{@=}, and assignments
modify the object.
For the assignment and \tcode{@=} operators,
only the left argument is modified.
\end{note}

\pnum
Unless otherwise stated, implementations may make arbitrary copies of elements
(with type \tcode{T}) from sequences where \tcode{is_trivially_copy_constructible_v<T>}
and \tcode{is_trivially_destructible_v<T>} are \tcode{true}.
\begin{note}
This implies that user-supplied function objects should not rely on object
identity of arguments for such input sequences. Users for whom the object
identity of the arguments to these function objects is important should
consider using a wrapping iterator that returns a non-copied implementation
object such as \tcode{reference_wrapper<T>}\iref{refwrap} or some equivalent
solution.
\end{note}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::sequenced_policy} all occur
in the calling thread of execution.
\begin{note}
The invocations are not interleaved; see~\ref{intro.execution}.
\end{note}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type \tcode{execution::parallel_policy} are
permitted to execute in either the invoking thread of execution or in a
thread of execution implicitly
created by the library to support parallel algorithm execution.
If the threads of execution created by \tcode{thread}\iref{thread.thread.class} provide concurrent
forward progress guarantees\iref{intro.progress}, then a thread of execution
implicitly created by the library will provide parallel forward progress guarantees;
otherwise, the provided forward progress guarantee is
\impldef{forward progress guarantees for implicit threads of parallel algorithms (if not defined for \tcode{thread})}.
Any such
invocations executing in the same thread of execution are indeterminately sequenced with
respect to each other.
\begin{note}
It is the caller's responsibility to ensure that the
invocation does not introduce data races or deadlocks.
\end{note}
\begin{example}
\begin{codeblock}
int a[] = {0,1};
std::vector<int> v;
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int i) {
  v.push_back(i*2+1); // incorrect: data race
});
\end{codeblock}
The program above has a data race because of the unsynchronized access to the
container \tcode{v}.
\end{example}
\begin{example}
\begin{codeblock}
std::atomic<int> x{0};
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
  x.fetch_add(1, std::memory_order::relaxed);
  // spin wait for another iteration to change the value of \tcode{x}
  while (x.load(std::memory_order::relaxed) == 1) { } // incorrect: assumes execution order
});
\end{codeblock}
The above example depends on the order of execution of the iterations, and
will not terminate if both iterations are executed sequentially on the same
thread of execution.
\end{example}
\begin{example}
\begin{codeblock}
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
  std::lock_guard<mutex> guard(m);
  ++x;
});
\end{codeblock}
The above example synchronizes access to object \tcode{x} ensuring that it is
incremented correctly.
\end{example}

\pnum
The invocations of element access functions in parallel algorithms invoked with
an execution policy of type \tcode{execution::parallel_unsequenced_policy} are
permitted to execute in an unordered fashion in unspecified threads of execution, and
unsequenced with respect to one another within each thread of execution.
These threads of execution are either the invoking thread of execution or threads of
execution implicitly created by the library; the latter will provide weakly parallel
forward progress guarantees.
\begin{note}
This means that multiple function object invocations may be interleaved on a
single thread of execution, which overrides the usual guarantee from \ref{intro.execution}
that function executions do not interleave with one another.
\end{note}
Since \tcode{execution::parallel_unsequenced_policy} allows the execution of element
access functions to be interleaved on a single thread of execution, blocking synchronization,
including the use of mutexes, risks deadlock. Thus, the synchronization with
\tcode{execution::parallel_unsequenced_policy} is restricted as
follows:
A standard library function is \defn{vectorization-unsafe} if it is specified
to synchronize with another function invocation, or another function invocation
is specified to synchronize with it, and if it is not a memory allocation or
deallocation function. Vectorization-unsafe standard library functions may not
be invoked by user code called from \tcode{execution::parallel_unsequenced_policy}
algorithms.
\begin{note}
Implementations must ensure that internal synchronization inside standard
library functions does not prevent forward progress when those functions are
executed by threads of execution with weakly parallel forward progress guarantees.
\end{note}
\begin{example}
\begin{codeblock}
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par_unseq, std::begin(a), std::end(a), [&](int) {
  std::lock_guard<mutex> guard(m); // incorrect: \tcode{lock_guard} constructor calls \tcode{m.lock()}
  ++x;
});
\end{codeblock}
The above program may result in two consecutive calls to \tcode{m.lock()} on
the same thread of execution (which may deadlock), because the applications of the function
object are not guaranteed to run on different threads of execution.
\end{example}
\begin{note}
The semantics of the \tcode{execution::parallel_policy} or the
\tcode{execution::parallel_unsequenced_policy} invocation allow the implementation to
fall back to sequential execution if the system cannot parallelize an algorithm
invocation due to lack of resources.
\end{note}

\pnum
If an invocation of a parallel algorithm uses threads of execution implicitly
created by the library, then the invoking thread of execution will either

\begin{itemize}
\item temporarily block with forward progress guarantee delegation\iref{intro.progress}
      on the completion of these library-managed threads of execution, or
\item eventually execute an element access function;
\end{itemize}

the thread of execution will continue to do so until the algorithm is finished.
\begin{note}
In blocking with forward progress guarantee delegation in this context,
a thread of execution created by the library is considered to have
finished execution as soon as it has finished the execution of the
particular element access function that the invoking thread of execution
logically depends on.
\end{note}

\pnum
The semantics of parallel algorithms invoked with an execution policy object of
\impldef{additional execution policies supported by parallel algorithms} type are
\impldef{semantics of parallel algorithms invoked with
imple\-men\-tation-defined execution policies}.

\rSec2[algorithms.parallel.exceptions]{Parallel algorithm exceptions}

\pnum
During the execution of a parallel algorithm, if temporary memory resources are
required for parallelization and none are available, the algorithm throws a
\tcode{bad_alloc} exception.

\pnum
During the execution of a parallel algorithm, if the invocation of an element
access function exits via an uncaught exception,
the behavior is determined by the \tcode{ExecutionPolicy}.

\rSec2[algorithms.parallel.overloads]{\tcode{ExecutionPolicy} algorithm overloads}

\pnum
Parallel algorithms are algorithm overloads. Each parallel algorithm overload
has an additional template type parameter named \tcode{ExecutionPolicy}, which
is the first template parameter.
Additionally, each parallel algorithm overload has an additional function
parameter of type \tcode{ExecutionPolicy\&\&}, which is the first
function parameter.
\begin{note} Not all algorithms have parallel algorithm overloads.\end{note}

\pnum
Unless otherwise specified, the semantics of \tcode{ExecutionPolicy} algorithm
overloads are identical to their overloads without.

\pnum
Unless otherwise specified, the complexity requirements of \tcode{ExecutionPolicy}
algorithm overloads are relaxed from the complexity requirements of the overloads
without as follows:
when the guarantee says ``at most \placeholder{expr}'' or ``exactly \placeholder{expr}''
and does not specify the number of assignments or swaps, and \placeholder{expr}
is not already expressed with  \bigoh{} notation, the complexity of the algorithm
shall be \bigoh{\placeholder{expr}}.

\pnum
Parallel algorithms shall not participate in overload resolution unless
\tcode{is_execution_policy_v<decay_t<ExecutionPolicy>>} is \tcode{true}.

\rSec1[alg.nonmodifying]{Non-modifying sequence operations}

\rSec2[alg.all_of]{All of}

\indexlibrary{\idxcode{all_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool all_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if
\range{first}{last} is empty or if
\tcode{pred(*i)} is \tcode{true} for every iterator \tcode{i} in the range \range{first}{last}, and \tcode{false} otherwise.

\pnum
\complexity At most \tcode{last - first} applications of the predicate.
\end{itemdescr}

\rSec2[alg.any_of]{Any of}

\indexlibrary{\idxcode{any_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool any_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false} if \range{first}{last} is empty or
if there is no iterator \tcode{i} in the range
\range{first}{last} such that \tcode{pred(*i)} is \tcode{true}, and \tcode{true} otherwise.

\pnum
\complexity At most \tcode{last - first} applications of the predicate.
\end{itemdescr}

\rSec2[alg.none_of]{None of}

\indexlibrary{\idxcode{none_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool none_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
               Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if
\range{first}{last} is empty or if
\tcode{pred(*i)} is \tcode{false} for every iterator \tcode{i} in the range \range{first}{last}, and \tcode{false} otherwise.

\pnum
\complexity At most \tcode{last - first} applications of the predicate.
\end{itemdescr}

\rSec2[alg.foreach]{For each}

\indexlibrary{\idxcode{for_each}}%
\begin{itemdecl}
template<class InputIterator, class Function>
  constexpr Function for_each(InputIterator first, InputIterator last, Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{Function} shall meet the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}).
\begin{note} \tcode{Function} need not meet the requirements of
\tcode{CopyConstructible} (Table~\ref{tab:copyconstructible}). \end{note}

\pnum
\effects
Applies
\tcode{f} to the result of dereferencing every iterator in the range
\range{first}{last},
starting from
\tcode{first}
and proceeding to
\tcode{last - 1}.
\begin{note} If the type of \tcode{first} satisfies the
requirements of a mutable iterator, \tcode{f} may apply non-constant
functions through the dereferenced iterator.\end{note}

\pnum
\returns
\tcode{f}.

\pnum
\complexity
Applies \tcode{f}
exactly
\tcode{last - first}
times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
\end{itemdescr}

\indexlibrary{\idxcode{for_each}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Function>
  void for_each(ExecutionPolicy&& exec,
                ForwardIterator first, ForwardIterator last,
                Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Function} shall meet the requirements of \tcode{CopyConstructible}.

\pnum
\effects
Applies \tcode{f} to the result of dereferencing every iterator in the range
\range{first}{last}.
\begin{note}
If the type of \tcode{first} satisfies the requirements of a mutable iterator,
\tcode{f} may apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\complexity
Applies \tcode{f} exactly \tcode{last - first} times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
Implementations do not
have the freedom granted under \ref{algorithms.parallel.exec} to make arbitrary
copies of elements from the input sequence.

\pnum
\begin{note}
Does not return a copy of its \tcode{Function} parameter, since
parallelization may not permit efficient state accumulation.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{for_each_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class Function>
  constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Function} shall meet the requirements of \tcode{MoveConstructible}
\begin{note} \tcode{Function} need not meet the requirements of
\tcode{CopyConstructible}. \end{note}

\pnum
\requires
\tcode{n >= 0}.

\pnum
\effects
Applies \tcode{f} to the result of dereferencing every iterator in the range
\range{first}{first + n} in order.
\begin{note}
If the type of \tcode{first} satisfies the requirements of a mutable iterator,
\tcode{f} may apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\returns
\tcode{first + n}.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.
\end{itemdescr}

\indexlibrary{\idxcode{for_each_n}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
  ForwardIterator for_each_n(ExecutionPolicy&& exec, ForwardIterator first, Size n,
                             Function f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Function} shall meet the requirements of \tcode{CopyConstructible}.

\pnum
\requires
\tcode{n >= 0}.

\pnum
\effects
Applies \tcode{f} to the result of dereferencing every iterator in the range
\range{first}{first + n}.
\begin{note}
If the type of \tcode{first} satisfies the requirements of a mutable iterator,
\tcode{f} may apply non-constant functions through the dereferenced iterator.
\end{note}

\pnum
\returns
\tcode{first + n}.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.  Implementations do not
have the freedom granted under \ref{algorithms.parallel.exec} to make arbitrary
copies of elements from the input sequence.
\end{itemdescr}


\rSec2[alg.find]{Find}

\indexlibrary{\idxcode{find}}%
\indexlibrary{\idxcode{find_if}}%
\indexlibrary{\idxcode{find_if_not}}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr InputIterator find(InputIterator first, InputIterator last,
                               const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  ForwardIterator find(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                       const T& value);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                  Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                          Predicate pred);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if_not(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                              Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
for which the following corresponding
conditions hold:
\tcode{*i == value}, \tcode{pred(*i) != false}, \tcode{pred(*i) == false}.
Returns \tcode{last} if no such iterator is found.

\pnum
\complexity
At most
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.find.end]{Find end}

\indexlibrary{\idxcode{find_end}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
The last iterator
\tcode{i}
in the range \range{first1}{last1 - (last2 - first2)}
such that for every non-negative integer
\tcode{n < (last2 - first2)},
the following corresponding conditions hold:
\tcode{*(i + n) == *(\brk{}first2 + n), pred(*(i + n), *(first2 + n)) != false}.
Returns \tcode{last1}
if
\range{first2}{last2} is empty or if
no such iterator is found.

\pnum
\complexity
At most
\tcode{(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.find.first.of]{Find first}

\indexlibrary{\idxcode{find_first_of}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator, class ForwardIterator,
         class BinaryPredicate>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Finds an element that matches one of a set of values.

\pnum
\returns
The first iterator
\tcode{i}
in the range \range{first1}{last1}
such that for some
iterator
\tcode{j}
in the range \range{first2}{last2}
the following conditions hold:
\tcode{*i == *j, pred(*i,*j) != false}.
Returns \tcode{last1}
if \range{first2}{last2} is empty or
if no such iterator is found.

\pnum
\complexity
At most
\tcode{(last1-first1) * (last2-first2)}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.adjacent.find]{Adjacent find}

\indexlibrary{\idxcode{adjacent_find}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first iterator
\tcode{i}
such that both
\tcode{i}
and
\tcode{i + 1}
are in
the range
\range{first}{last}
for which
the following corresponding conditions hold:
\tcode{*i == *(i + 1), pred(*i, *(i + 1)) != false}.
Returns \tcode{last}
if no such iterator is found.

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy}, exactly
\tcode{min((i - first) + 1, (last - first) - 1)}
applications of the corresponding predicate, where \tcode{i} is
\tcode{adjacent_find}'s
return value.  For the overloads with an \tcode{ExecutionPolicy},
\bigoh{\tcode{last - first}} applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.count]{Count}

\indexlibrary{\idxcode{count}}%
\indexlibrary{\idxcode{count_if}}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  typename iterator_traits<ForwardIterator>::difference_type
    count(ExecutionPolicy&& exec,
          ForwardIterator first, ForwardIterator last, const T& value);

template<class InputIterator, class Predicate>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  typename iterator_traits<ForwardIterator>::difference_type
    count_if(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns the number of iterators
\tcode{i}
in the range \range{first}{last}
for which the following corresponding
conditions hold:
\tcode{*i == value, pred(*i) != false}.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[mismatch]{Mismatch}

\indexlibrary{\idxcode{mismatch}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks If \tcode{last2} was not given in the argument list, it denotes
\tcode{first2 + (last1 - first1)} below.

\pnum
\returns
A pair of iterators \tcode{first1 + n} and
\tcode{first2 + n}, where \tcode{n} is the smallest integer
such that, respectively,
\begin{itemize}
\item \tcode{!(*(first1 + n) == *(first2 + n))} or
\item \tcode{pred(*(first1 + n), *(first2 + n)) == false},
\end{itemize}
or \tcode{min(last1 - first1, last2 - first2)} if no such integer exists.

\pnum
\complexity
At most
\tcode{min(last1 - first1, last2 - first2)}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.equal]{Equal}

\indexlibrary{\idxcode{equal}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks If \tcode{last2} was not given in the argument list, it denotes
\tcode{first2 + (last1 - first1)} below.

\pnum
\returns
If
\tcode{last1 - first1 != last2 - first2},
return
\tcode{false}.
Otherwise return
\tcode{true}
if for every iterator
\tcode{i}
in the range \range{first1}{last1}
the following corresponding conditions hold:
\tcode{*i == *(first2 + (i - first1)), pred(*i, *(first2 + (i - first1))) != false}.
Otherwise, returns
\tcode{false}.

\pnum
\complexity
\begin{itemize}
\item
For the overloads with no \tcode{ExecutionPolicy},
\begin{itemize}
\item
if
\tcode{InputIterator1}
and
\tcode{InputIterator2}
meet the requirements of random access iterators\iref{random.access.iterators}
and
\tcode{last1 - first1 != last2 - first2},
then
no applications of the corresponding predicate; otherwise,

\item
at most
$\min(\tcode{last1 - first1}, \tcode{last2 - first2})$
applications of the corresponding predicate.
\end{itemize}

\item
For the overloads with an \tcode{ExecutionPolicy},
\begin{itemize}
\item
if
\tcode{ForwardIterator1}
and
\tcode{ForwardIterator2}
meet the requirements of random access iterators and
\tcode{last1 - first1 != last2 - first2}, then
no applications of the corresponding predicate; otherwise,

\item
\bigoh{\min(\tcode{last1 - first1}, \tcode{last2 - first2})} applications
of the corresponding predicate.
\end{itemize}
\end{itemize}
\end{itemdescr}

\rSec2[alg.is_permutation]{Is permutation}

\indexlibrary{\idxcode{is_permutation}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2);
template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, BinaryPredicate pred);
template<class ForwardIterator1, class ForwardIterator2>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2, ForwardIterator2 last2,
                                BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{ForwardIterator1} and \tcode{ForwardIterator2} shall have the same
value type. The comparison function shall be an equivalence relation.

\pnum
\remarks If \tcode{last2} was not given in the argument list, it denotes
\tcode{first2 + (last1 - first1)} below.

\pnum
\returns If \tcode{last1 - first1 != last2 - first2}, return \tcode{false}.
Otherwise return \tcode{true} if there exists a permutation of the elements in the
range \range{first2}{first2 + (last1 - first1)}, beginning with \tcode{ForwardIterator2
begin}, such that \tcode{equal(first1, last1, begin)} returns \tcode{true} or
\tcode{equal(first1, last1, begin, pred)} returns \tcode{true}; otherwise, returns
\tcode{false}.

\pnum
\complexity No applications of the corresponding predicate if \tcode{ForwardIterator1}
and \tcode{Forward\-Iter\-ator2} meet the requirements of random access iterators and
\tcode{last1 - first1 != last2 - first2}.
Otherwise, exactly \tcode{last1 - first1} applications of the
corresponding predicate if \tcode{equal(\brk{}first1, last1, first2, last2)}
would return \tcode{true} if \tcode{pred} was not given in the argument list
or \tcode{equal(first1, last1, first2, last2, pred)} would return \tcode{true} if pred was given in the argument list; otherwise, at
worst \bigoh{N^2}, where $N$ has the value \tcode{last1 - first1}.
\end{itemdescr}

\rSec2[alg.search]{Search}

\indexlibrary{\idxcode{search}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    search(ExecutionPolicy&& exec,
           ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    search(ExecutionPolicy&& exec,
           ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
The first iterator
\tcode{i}
in the range \range{first1}{last1 - (last2-first2)}
such that for every non-negative integer
\tcode{n}
less than
\tcode{last2 - first2}
the following corresponding conditions hold:
\tcode{*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false}.
Returns \tcode{first1}
if \range{first2}{last2} is empty,
otherwise returns \tcode{last1}
if no such iterator is found.

\pnum
\complexity
At most
\tcode{(last1 - first1) * (last2 - first2)}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{search_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T>
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
  ForwardIterator
    search_n(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last,
             Size count, const T& value);

template<class ForwardIterator, class Size, class T,
         class BinaryPredicate>
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Size, class T,
         class BinaryPredicate>
  ForwardIterator
    search_n(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last,
             Size count, const T& value,
             BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The type
\tcode{Size}
shall be convertible to integral type~(\ref{conv.integral}, \ref{class.conv}).

\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
The first iterator
\tcode{i}
in the range \range{first}{last-count}
such that for every non-negative integer
\tcode{n}
less than
\tcode{count}
the following corresponding conditions hold:
\tcode{*(i + n) == value, pred(*(i + n),value) != false}.
Returns \tcode{last}
if no such iterator is found.

\pnum
\complexity
At most
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{search}}%
\begin{itemdecl}
template<class ForwardIterator, class Searcher>
  constexpr ForwardIterator
    search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return searcher(first, last).first;}

\pnum
\remarks
\tcode{Searcher} need not meet the \tcode{CopyConstructible} requirements.
\end{itemdescr}


\rSec1[alg.modifying.operations]{Mutating sequence operations}

\rSec2[alg.copy]{Copy}

\indexlibrary{\idxcode{copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                OutputIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{result} shall not be in the range \range{first}{last}.

\pnum
\effects Copies elements in the range \range{first}{last} into the range \range{result}{result + (last - first)} starting from \tcode{first} and proceeding to \tcode{last}. For each non-negative integer \tcode{n < (last - first)}, performs \tcode{*(result + n) = *(first + n)}.

\pnum
\returns \tcode{result + (last - first)}.

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first}{last} and
\range{result}{result + (last - first)} shall not overlap.

\pnum
\effects Copies elements in the range \range{first}{last} into
the range \range{result}{result + (last - first)}.
For each non-negative integer \tcode{n < (last - first)},
performs \tcode{*(result + n) = *(first + n)}.

\pnum
\returns \tcode{result + (last - first)}.

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class OutputIterator>
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2>
  ForwardIterator2 copy_n(ExecutionPolicy&& exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects For each non-negative integer
$i < n$, performs \tcode{*(result + i) = *(first + i)}.

\pnum
\returns \tcode{result + n}.

\pnum
\complexity Exactly \tcode{n} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2 copy_if(ExecutionPolicy&& exec,
                           ForwardIterator1 first, ForwardIterator1 last,
                           ForwardIterator2 result, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first}{last} and \range{result}{result + (last - first)} shall not overlap.
\begin{note}
For the overload with an \tcode{ExecutionPolicy}, there may be a performance
cost if \tcode{iterator_traits<ForwardIterator1>::value_type} is not
\tcode{Move\-Constructible} (Table~\ref{tab:moveconstructible}).
\end{note}

\pnum
\effects Copies all of the elements referred to by the iterator \tcode{i} in the range \range{first}{last}
for which \tcode{pred(*i)} is \tcode{true}.

\pnum
\returns The end of the resulting range.

\pnum
\complexity Exactly \tcode{last - first} applications of the corresponding predicate.

\pnum
\remarks Stable\iref{algorithm.stable}.
\end{itemdescr}

\indexlibrary{\idxcode{copy_backward}}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{result}
shall not be in the range
\brange{first}{last}.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the
range \range{result - (last-first)}{result}
starting from
\tcode{last - 1}
and proceeding to \tcode{first}.\footnote{\tcode{copy_backward}
should be used instead of copy when \tcode{last}
is in
the range
\range{result - (last - first)}{result}.}
For each positive integer
\tcode{n <= (last - first)},
performs
\tcode{*(result - n) = *(last - n)}.

\pnum
\returns
\tcode{result - (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}

\rSec2[alg.move]{Move}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator move(InputIterator first, InputIterator last,
                                OutputIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{result}
shall not be in the range
\range{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the range \range{result}{result + (last - first)}
starting from first and proceeding to last.
For each non-negative integer
\tcode{n < (last-first)},
performs
\tcode{*(result + n)} \tcode{= std::move(*(first + n))}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
move assignments.
\end{itemdescr}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 move(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first}{last} and
\range{result}{result + (last - first)} shall not overlap.

\pnum
\effects Moves elements in the range \range{first}{last} into
the range \range{result}{result + (last - first)}.
For each non-negative integer \tcode{n < (last - first)},
performs \tcode{*(result + n) = std::\brk{}move(*(first + n))}.

\pnum
\returns \tcode{result + (last - first)}.

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{move_backward}}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{result}
shall not be in the range
\brange{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the
range \range{result - (last-first)}{result}
starting from
\tcode{last - 1}
and proceeding to first.\footnote{\tcode{move_backward}
should be used instead of move when last
is in
the range
\range{result - (last - first)}{result}.}
For each positive integer
\tcode{n <= (last - first)},
performs
\tcode{*(result - n) = std::move(*(last - n))}.

\pnum
\returns
\tcode{result - (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}

\rSec2[alg.swap]{Swap}

\indexlibrary{\idxcode{swap_ranges}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    swap_ranges(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The two ranges \range{first1}{last1}
and
\range{first2}{first2 + (last1 - first1)}
shall not overlap.
\tcode{*(first1 + n)} shall be swappable with\iref{swappable.requirements}
\tcode{*(first2 + n)}.

\pnum
\effects
For each non-negative integer
\tcode{n < (last1 - first1)}
performs:
\tcode{swap(*(first1 + n), \brk{}*(first2 + n))}.

\pnum
\returns
\tcode{first2 + (last1 - first1)}.

\pnum
\complexity
Exactly
\tcode{last1 - first1}
swaps.
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{a} and \tcode{b} shall be dereferenceable. \tcode{*a} shall be
swappable with\iref{swappable.requirements} \tcode{*b}.

\pnum
\effects
As if by \tcode{swap(*a, *b)}.
\end{itemdescr}

\rSec2[alg.transform]{Transform}

\indexlibrary{\idxcode{transform}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator,
         class UnaryOperation>
  constexpr OutputIterator
    transform(InputIterator first, InputIterator last,
              OutputIterator result, UnaryOperation op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class UnaryOperation>
  ForwardIterator2
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 result, UnaryOperation op);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    transform(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, OutputIterator result,
              BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class BinaryOperation>
  ForwardIterator
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator result,
              BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{op} and \tcode{binary_op}
shall not invalidate iterators or subranges, or modify elements in the ranges
\begin{itemize}
\item \crange{first1}{last1},
\item \crange{first2}{first2 + (last1 - first1)}, and
\item \crange{result}{result + (last1 - first1)}.\footnote{The use of fully
closed ranges is intentional.}
\end{itemize}

\pnum
\effects
Assigns through every iterator
\tcode{i}
in the range
\range{result}{result + (last1 - first1)}
a new
corresponding value equal to
\tcode{op(*(first1 + (i - result)))}
or
\tcode{binary_op(*(first1 + (i - result)), *(first2 + (i - result)))}.

\pnum
\returns
\tcode{result + (last1 - first1)}.

\pnum
\complexity
Exactly
\tcode{last1 - first1}
applications of
\tcode{op} or \tcode{binary_op}.  This requirement also applies to the overload
with an \tcode{ExecutionPolicy} .

\pnum
\remarks
\tcode{result} may be equal to \tcode{first}
in case of unary transform,
or to \tcode{first1} or \tcode{first2}
in case of binary transform.
\end{itemdescr}

\rSec2[alg.replace]{Replace}

\indexlibrary{\idxcode{replace}}%
\indexlibrary{\idxcode{replace_if}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr void replace(ForwardIterator first, ForwardIterator last,
                         const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  void replace(ExecutionPolicy&& exec,
               ForwardIterator first, ForwardIterator last,
               const T& old_value, const T& new_value);

template<class ForwardIterator, class Predicate, class T>
  constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                            Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
  void replace_if(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  Predicate pred, const T& new_value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression
\tcode{*first = new_value}
shall be valid.

\pnum
\effects
Substitutes elements referred by the iterator
\tcode{i}
in the range \range{first}{last}
with \tcode{new_value},
when the following corresponding conditions hold:
\tcode{*i == old_value}, \tcode{pred(*i) != false}.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{replace_copy}}%
\indexlibrary{\idxcode{replace_copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    replace_copy(InputIterator first, InputIterator last,
                 OutputIterator result,
                 const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
  ForwardIterator2
    replace_copy(ExecutionPolicy&& exec,
                 ForwardIterator1 first, ForwardIterator1 last,
                 ForwardIterator2 result,
                 const T& old_value, const T& new_value);

template<class InputIterator, class OutputIterator, class Predicate, class T>
  constexpr OutputIterator
    replace_copy_if(InputIterator first, InputIterator last,
                    OutputIterator result,
                    Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate, class T>
  ForwardIterator2
    replace_copy_if(ExecutionPolicy&& exec,
                    ForwardIterator1 first, ForwardIterator1 last,
                    ForwardIterator2 result,
                    Predicate pred, const T& new_value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The results of the expressions
\tcode{*first}
and
\tcode{new_value}
shall be writable\iref{iterator.requirements.general} to the
\tcode{result}
output iterator.
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Assigns to every iterator
\tcode{i}
in the
range
\range{result}{result + (last - first)}
either
\tcode{new_value}
or
\tcode{*\brk(first + (i - result))}
depending on whether the following corresponding conditions hold:

\begin{codeblock}
*(first + (i - result)) == old_value
pred(*(first + (i - result))) != false
\end{codeblock}

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.fill]{Fill}

\indexlibrary{\idxcode{fill}}%
\indexlibrary{\idxcode{fill_n}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  void fill(ExecutionPolicy&& exec,
            ForwardIterator first, ForwardIterator last, const T& value);

template<class OutputIterator, class Size, class T>
  constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
  ForwardIterator fill_n(ExecutionPolicy&& exec,
                         ForwardIterator first, Size n, const T& value);

\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression
\tcode{value}
shall be writable\iref{iterator.requirements.general} to the output iterator. The type
\tcode{Size}
shall be convertible to an integral type~(\ref{conv.integral}, \ref{class.conv}).

\pnum
\effects
The \tcode{fill} algorithms assign \tcode{value} through all the iterators in the range
\range{first}{last}. The \tcode{fill_n} algorithms assign \tcode{value}
through all the iterators in the range \range{first}{first + n}
if \tcode{n} is positive, otherwise they do nothing.

\pnum
\returns \tcode{fill_n} returns \tcode{first + n} for non-negative values of \tcode{n}
and \tcode{first} for negative values.

\pnum
\complexity
Exactly
\tcode{last - first},
\tcode{n}, or 0 assignments, respectively.
\end{itemdescr}

\rSec2[alg.generate]{Generate}

\indexlibrary{\idxcode{generate}}%
\indexlibrary{\idxcode{generate_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Generator>
  constexpr void generate(ForwardIterator first, ForwardIterator last,
                          Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Generator>
  void generate(ExecutionPolicy&& exec,
                ForwardIterator first, ForwardIterator last,
                Generator gen);

template<class OutputIterator, class Size, class Generator>
  constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
  ForwardIterator generate_n(ExecutionPolicy&& exec,
                             ForwardIterator first, Size n, Generator gen);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{gen} takes no arguments,
\tcode{Size}
shall be convertible to an integral type~(\ref{conv.integral}, \ref{class.conv}).

\pnum
\effects
The \tcode{generate} algorithms invoke the function object \tcode{gen} and assign the return
value of \tcode{gen} through all the iterators in the range
\range{first}{last}. The \tcode{generate_n} algorithms invoke the function object
\tcode{gen} and assign the return value of \tcode{gen} through all the iterators in
the range \range{first}{first + n} if \tcode{n} is positive,
otherwise they do nothing.

\pnum
\returns \tcode{generate_n} returns \tcode{first + n} for non-negative values of \tcode{n}
and \tcode{first} for negative values.

\pnum
\complexity
Exactly
\tcode{last - first},
\tcode{n}, or 0
invocations of \tcode{gen} and assignments, respectively.
\end{itemdescr}

\rSec2[alg.remove]{Remove}

\indexlibrary{\idxcode{remove}}%
\indexlibrary{\idxcode{remove_if}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                   const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  ForwardIterator remove(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         const T& value);

template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator remove_if(ExecutionPolicy&& exec,
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The type of
\tcode{*first}
shall satisfy the \tcode{MoveAssignable}
requirements (Table~\ref{tab:moveassignable}).

\pnum
\effects
Eliminates all the elements referred to by iterator
\tcode{i}
in the range \range{first}{last}
for which the following corresponding conditions hold:
\tcode{*i == value, pred(*i) != false}.

\pnum
\returns
The end of the resulting range.

\pnum
\remarks Stable\iref{algorithm.stable}.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate.

\pnum
\begin{note}
Each element in the range \range{ret}{last}, where \tcode{ret} is
the returned value, has a valid but unspecified state, because the algorithms
can eliminate elements by moving from elements that were originally
in that range.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{remove_copy}}%
\indexlibrary{\idxcode{remove_copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    remove_copy(InputIterator first, InputIterator last,
                OutputIterator result, const T& value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class T>
  ForwardIterator2
    remove_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, const T& value);

template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator
    remove_copy_if(InputIterator first, InputIterator last,
                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2
    remove_copy_if(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap. The expression \tcode{*result = *first} shall be valid.
\begin{note}
For the overloads with an \tcode{ExecutionPolicy}, there may be a performance
cost if \tcode{iterator_traits<ForwardIterator1>::value_type} is not
\tcode{Move\-Constructible} (Table~\ref{tab:moveconstructible}).
\end{note}

\pnum
\effects
Copies all the elements referred to by the iterator
\tcode{i}
in the range
\range{first}{last}
for which the following corresponding conditions do not hold:
\tcode{*i == value, pred(*i) != false}.

\pnum
\returns
The end of the resulting range.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate.

\pnum
\remarks Stable\iref{algorithm.stable}.
\end{itemdescr}

\rSec2[alg.unique]{Unique}

\indexlibrary{\idxcode{unique}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                   BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The comparison function shall be an equivalence relation.
The type of \tcode{*first} shall satisfy the
\tcode{MoveAssignable} requirements (Table~\ref{tab:moveassignable}).

\pnum
\effects
For a nonempty range, eliminates all but the first element from every
consecutive group of equivalent elements referred to by the iterator
\tcode{i}
in the range
\range{first + 1}{last}
for which the following conditions hold:
\tcode{*(i - 1) == *i}
or
\tcode{pred(*(i - 1), *i) != false}.

\pnum
\returns
The end of the resulting range.

\pnum
\complexity
For nonempty ranges, exactly
\tcode{(last - first) - 1}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{unique_copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result);

template<class InputIterator, class OutputIterator,
         class BinaryPredicate>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, BinaryPredicate pred);
\end{itemdecl}


\begin{itemdescr}
\pnum
\requires
\begin{itemize}
\item
The comparison function shall be an equivalence relation.

\item
The ranges
\range{first}{last}
and
\range{result}{result+(last-first)}
shall not overlap.

\item
The expression
\tcode{*result = *first}
shall be valid.

\item
For the overloads with no \tcode{ExecutionPolicy},
let \tcode{T} be the value type of \tcode{InputIterator}.
If \tcode{InputIterator} meets the forward iterator requirements,
then there are no additional requirements for \tcode{T}.
Otherwise, if \tcode{OutputIterator} meets the forward iterator
requirements and its value type is the same as \tcode{T},
then \tcode{T} shall be \tcode{CopyAssignable} (Table~\ref{tab:copyassignable}).
Otherwise, \tcode{T} shall be both
\tcode{CopyConstructible} (Table~\ref{tab:copyconstructible}) and \tcode{CopyAssignable}.
\begin{note}
For the overloads with an \tcode{ExecutionPolicy}, there may be a performance
cost if the value type of \tcode{ForwardIterator1} is not both
\tcode{CopyConstructible} and \tcode{CopyAssignable}.
\end{note}
\end{itemize}

\pnum
\effects
Copies only the first element from every consecutive group of equal elements referred to by
the iterator
\tcode{i}
in the range
\range{first}{last}
for which the following corresponding conditions hold:
\tcode{*i == *(i - 1)}
or
\tcode{pred(*i, *(i - 1)) != false}.

\pnum
\returns
The end of the resulting range.

\pnum
\complexity
For nonempty ranges, exactly
\tcode{last - first - 1}
applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.reverse]{Reverse}

\indexlibrary{\idxcode{reverse}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  void reverse(BidirectionalIterator first, BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void reverse(ExecutionPolicy&& exec,
               BidirectionalIterator first, BidirectionalIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{BidirectionalIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}.

\pnum
\effects
For each non-negative integer
\tcode{i < (last - first) / 2},
applies
\tcode{iter_swap}
to all pairs of iterators
\tcode{first + i, (last - i) - 1}.

\pnum
\complexity
Exactly
\tcode{(last - first)/2}
swaps.
\end{itemdescr}

\indexlibrary{\idxcode{reverse_copy}}%
\begin{itemdecl}
template<class BidirectionalIterator, class OutputIterator>
  constexpr OutputIterator
    reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                 OutputIterator result);
template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
  ForwardIterator
    reverse_copy(ExecutionPolicy&& exec,
                 BidirectionalIterator first, BidirectionalIterator last,
                 ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Copies the range
\range{first}{last}
to the range
\range{result}{result + (last - first)}
such that
for every non-negative integer
\tcode{i < (last - first)}
the following assignment takes place:
\tcode{*(result + (last - first) - 1 - i) = *(first + i)}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}

\rSec2[alg.rotate]{Rotate}

\indexlibrary{\idxcode{rotate}}%
\begin{itemdecl}
template<class ForwardIterator>
  ForwardIterator
    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    rotate(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator middle, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\range{first}{middle}
and
\range{middle}{last}
shall be valid ranges.
\tcode{ForwardIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type of \tcode{*first} shall satisfy
the requirements of \tcode{MoveConstructible}
(Table~\ref{tab:moveconstructible}) and the
requirements of
\tcode{MoveAssignable}
(Table~\ref{tab:moveassignable}).

\pnum
\effects
For each non-negative integer
\tcode{i < (last - first)},
places the element from the position
\tcode{first + i}
into position
\tcode{first + (i + (last - middle)) \% (last - first)}.

\pnum
\returns \tcode{first + (last - middle)}.

\pnum
\remarks
This is a left rotate.

\pnum
\complexity
At most
\tcode{last - first}
swaps.
\end{itemdescr}

\indexlibrary{\idxcode{rotate_copy}}%
\begin{itemdecl}
template<class ForwardIterator, class OutputIterator>
  constexpr OutputIterator
    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    rotate_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 middle, ForwardIterator1 last,
                ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Copies the range
\range{first}{last}
to the range
\range{result}{result + (last - first)}
such that for each non-negative integer
\tcode{i < (last - first)}
the following assignment takes place:
\tcode{*(result + i) =  *(first +
(i + (middle - first)) \% (last - first))}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}

\rSec2[alg.random.sample]{Sample}

\indexlibrary{\idxcode{sample}}%
\begin{itemdecl}
template<class PopulationIterator, class SampleIterator,
         class Distance, class UniformRandomBitGenerator>
  SampleIterator sample(PopulationIterator first, PopulationIterator last,
                        SampleIterator out, Distance n,
                        UniformRandomBitGenerator&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\begin{itemize}
\item
\tcode{PopulationIterator} shall satisfy the requirements of an input iterator\iref{input.iterators}.
\item
\tcode{SampleIterator} shall satisfy the requirements of an output iterator\iref{output.iterators}.
\item
\tcode{SampleIterator} shall satisfy the additional requirements of a random access iterator\iref{random.access.iterators}
unless \tcode{PopulationIterator} satisfies the additional requirements of a forward iterator\iref{forward.iterators}.
\item
\tcode{PopulationIterator}'s value type shall be writable\iref{iterator.requirements.general} to \tcode{out}.
\item
\tcode{Distance} shall be an integer type.
\item
\tcode{remove_reference_t<UniformRandomBitGenerator>}
shall meet the requirements of a uniform random bit generator type\iref{rand.req.urng}
whose return type is convertible to \tcode{Distance}.
\item
\tcode{out} shall not be in the range \range{first}{last}.
\end{itemize}

\pnum
\effects
Copies \tcode{min(last - first, n)} elements (the \defn{sample})
from \range{first}{last} (the \defn{population}) to \tcode{out}
such that each possible sample has equal probability of appearance.
\begin{note}
Algorithms that obtain such effects include \term{selection sampling}
and \term{reservoir sampling}.
\end{note}

\pnum
\returns
The end of the resulting sample range.

\pnum
\complexity
\bigoh{\tcode{last - first}}.

\pnum
\remarks
\begin{itemize}
\item
Stable if and only if \tcode{PopulationIterator} satisfies the
requirements of a forward iterator.
\item
To the extent that the implementation of this function makes use of
random numbers, the object \tcode{g} shall serve as the
implementation's source of randomness.
\end{itemize}
\end{itemdescr}

\rSec2[alg.random.shuffle]{Shuffle}

\indexlibrary{\idxcode{shuffle}}%
\begin{itemdecl}
template<class RandomAccessIterator, class UniformRandomBitGenerator>
  void shuffle(RandomAccessIterator first,
               RandomAccessIterator last,
               UniformRandomBitGenerator&& g);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}.
The type
\tcode{remove_reference_t<UniformRandomBitGenerator>}
shall meet the requirements of a
uniform random bit generator\iref{rand.req.urng} type whose return type is
convertible to
\tcode{iterator_traits<Random\-Access\-Itera\-tor>::difference_type}.

\pnum
\effects
Permutes the elements in the range
\range{first}{last}
such that each possible permutation of those elements has equal probability of appearance.

\pnum
\complexity
Exactly
\tcode{(last - first) - 1}
swaps.

\pnum
\remarks
To the extent that the implementation of this function makes use of random
numbers, the object \tcode{g} shall serve as the implementation's source of
randomness.

\end{itemdescr}

\rSec1[alg.sorting]{Sorting and related operations}

\pnum
All the operations in~\ref{alg.sorting} have two versions: one that takes a function object of type
\tcode{Compare}
and one that uses an
\tcode{operator<}.

\pnum
\tcode{Compare}
is a function object
type\iref{function.objects}. The return value of the function call operation applied to
an object of type \tcode{Compare}, when contextually converted to
\tcode{bool}\iref{conv},
yields \tcode{true} if the first argument of the call
is less than the second, and
\tcode{false}
otherwise.
\tcode{Compare comp}
is used throughout for algorithms assuming an ordering relation.
It is assumed that
\tcode{comp}
will not apply any non-constant function through the dereferenced iterator.

\pnum
For all algorithms that take
\tcode{Compare},
there is a version that uses
\tcode{operator<}
instead.
That is,
\tcode{comp(*i, *j) != false}
defaults to
\tcode{*i < *j != false}.
For algorithms other than those described in~\ref{alg.binary.search},
\tcode{comp} shall induce a strict weak ordering on the values.

\pnum
The term
\techterm{strict}
refers to the
requirement of an irreflexive relation (\tcode{!comp(x, x)} for all \tcode{x}),
and the term
\techterm{weak}
to requirements that are not as strong as
those for a total ordering,
but stronger than those for a partial
ordering.
If we define
\tcode{equiv(a, b)}
as
\tcode{!comp(a, b) \&\& !comp(b, a)},
then the requirements are that
\tcode{comp}
and
\tcode{equiv}
both be transitive  relations:

\begin{itemize}
\item
\tcode{comp(a, b) \&\& comp(b, c)}
implies
\tcode{comp(a, c)}
\item
\tcode{equiv(a, b) \&\& equiv(b, c)}
implies
\tcode{equiv(a, c)}
\end{itemize}
\begin{note}
Under these conditions, it can be shown that
\begin{itemize}
\item
\tcode{equiv}
is an equivalence relation
\item
\tcode{comp}
induces a well-defined relation on the equivalence
classes determined by
\tcode{equiv}
\item
The induced relation is a strict total ordering.
\end{itemize}
\end{note}

\pnum
A sequence is
\techterm{sorted with respect to a comparator}
\tcode{comp} if for every iterator
\tcode{i}
pointing to the sequence and every non-negative integer
\tcode{n}
such that
\tcode{i + n}
is a valid iterator pointing to an element of the sequence,
\tcode{comp(*(i + n), *i) == false}.

\pnum
A sequence
\range{start}{finish}
is
\techterm{partitioned with respect to an expression}
\tcode{f(e)}
if there exists an integer
\tcode{n}
such that for all
\tcode{0 <= i < (finish - start)},
\tcode{f(*(start + i))}
is \tcode{true} if and only if
\tcode{i < n}.

\pnum
In the descriptions of the functions that deal with ordering relationships we frequently use a notion of
equivalence to describe concepts such as stability.
The equivalence to which we refer is not necessarily an
\tcode{operator==},
but an equivalence relation induced by the strict weak ordering.
That is, two elements
\tcode{a}
and
\tcode{b}
are considered equivalent if and only if
\tcode{!(a < b) \&\& !(b < a)}.

\rSec2[alg.sort]{Sorting}

\rSec3[sort]{\tcode{sort}}

\indexlibrary{\idxcode{sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void sort(RandomAccessIterator first, RandomAccessIterator last,
            Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last,
            Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Sorts the elements in the range
\range{first}{last}.

\pnum
\complexity
\bigoh{N \log N} comparisons, where $N = \tcode{last - first}$.
\end{itemdescr}

\rSec3[stable.sort]{\tcode{stable_sort}}

\indexlibrary{\idxcode{stable_sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Sorts the elements in the range \range{first}{last}.

\pnum
\complexity
At most $N \log^2(N)$
comparisons, where
$N = \tcode{last - first}$, but only $N \log N$ comparisons if there is enough extra memory.

\pnum
\remarks Stable\iref{algorithm.stable}.
\end{itemdescr}

\rSec3[partial.sort]{\tcode{partial_sort}}

\indexlibrary{\idxcode{partial_sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void partial_sort(RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void partial_sort(RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last,
                    Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last,
                    Compare comp);

\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Places the first
\tcode{middle - first}
sorted elements from the range
\range{first}{last}
into the range
\range{first}{middle}.
The rest of the elements in the range
\range{middle}{last}
are placed in an unspecified order.
\indextext{unspecified}%

\pnum
\complexity
Approximately
\tcode{(last - first) * log(middle - first)}
comparisons.
\end{itemdescr}

\rSec3[partial.sort.copy]{\tcode{partial_sort_copy}}

\indexlibrary{\idxcode{partial_sort_copy}}%
\begin{itemdecl}
template<class InputIterator, class RandomAccessIterator>
  RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);

template<class InputIterator, class RandomAccessIterator,
         class Compare>
  RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
         class Compare>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*result_first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{Move\-Assignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Places the first
\tcode{min(last - first, result_last - result_first)}
sorted elements into the range
\range{result_first}{result_first + min(last - first, result_last - result_first)}.

\pnum
\returns
The smaller of:
\tcode{result_last} or
\tcode{result_first + (last - first)}.

\pnum
\complexity
Approximately
\tcode{(last - first) * log(min(last - first, result_last - result_first))}
comparisons.
\end{itemdescr}

\rSec3[is.sorted]{\tcode{is_sorted}}

\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_sorted_until(first, last) == last}
\end{itemdescr}

\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last) == last}
\end{itemdescr}


\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ForwardIterator, class Compare>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                           Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_sorted_until(first, last, comp) == last}
\end{itemdescr}


\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{is_sorted_until}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last,
                    Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last,
                    Compare comp);
\end{itemdecl}


\begin{itemdescr}
\pnum
\returns If \tcode{(last - first) < 2}, returns
\tcode{last}. Otherwise, returns
the last iterator \tcode{i} in \crange{first}{last} for which the
range \range{first}{i} is sorted.

\pnum
\complexity Linear.
\end{itemdescr}

\rSec2[alg.nth.element]{Nth element}

\indexlibrary{\idxcode{nth_element}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last,  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
After
\tcode{nth_element}
the element in the position pointed to by \tcode{nth}
is the element that would be
in that position if the whole range were sorted, unless \tcode{nth == last}.
Also for every iterator
\tcode{i}
in the range
\range{first}{nth}
and every iterator
\tcode{j}
in the range
\range{nth}{last}
it holds that:
\tcode{!(*j < *i)}
or
\tcode{comp(*j, *i) == false}.

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy}, linear on average.
For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N} applications of
the predicate, and \bigoh{N \log N} swaps, where $N = \tcode{last - first}$.
\end{itemdescr}

\rSec2[alg.binary.search]{Binary search}

\pnum
All of the algorithms in this subclause are versions of binary search
and assume that the sequence being searched is partitioned with respect to
an expression formed by binding the search key to an argument of the
implied or explicit comparison function.
They work on non-random access iterators minimizing the number of comparisons,
which will be logarithmic for all types of iterators.
They are especially appropriate for random access iterators,
because these algorithms do a logarithmic number of steps
through the data structure.
For non-random access iterators they execute a linear number of steps.

\rSec3[lower.bound]{\tcode{lower_bound}}

\indexlibrary{\idxcode{lower_bound}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expression
\tcode{e < value}
or
\tcode{comp(e, value)}.

\pnum
\returns
The furthermost iterator
\tcode{i}
in the range
\crange{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{i}
the following corresponding conditions hold:
\tcode{*j < value}
or
\tcode{comp(*j, value) != false}.

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons.
\end{itemdescr}

\rSec3[upper.bound]{\tcode{upper_bound}}

\indexlibrary{\idxcode{upper_bound}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expression
\tcode{!(value < e)}
or
\tcode{!comp(\brk{}value, e)}.

\pnum
\returns
The furthermost iterator
\tcode{i}
in the range
\crange{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{i}
the following corresponding conditions hold:
\tcode{!(value < *j)}
or
\tcode{comp(value, *j) == false}.

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons.
\end{itemdescr}

\rSec3[equal.range]{\tcode{equal_range}}

\indexlibrary{\idxcode{equal_range}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value,
                Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expressions
\tcode{e < value}
and
\tcode{!(value < e)}
or
\tcode{comp(e, value)}
and
\tcode{!comp(value, e)}.
Also, for all elements
\tcode{e}
of
\tcode{[first, last)},
\tcode{e < value}
shall imply
\tcode{!(value < e)}
or
\tcode{comp(e, value)}
shall imply
\tcode{!comp(value, e)}.

\pnum
\returns
\begin{codeblock}
make_pair(lower_bound(first, last, value),
          upper_bound(first, last, value))
\end{codeblock}
or
\begin{codeblock}
make_pair(lower_bound(first, last, value, comp),
          upper_bound(first, last, value, comp))
\end{codeblock}

\pnum
\complexity
At most
$2 * \log_2(\tcode{last - first}) + \bigoh{1}$
comparisons.
\end{itemdescr}

\rSec3[binary.search]{\tcode{binary_search}}

\indexlibrary{\idxcode{binary_search}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expressions
\tcode{e < value}
and
\tcode{!(value < e)}
or
\tcode{comp(e, value)}
and
\tcode{!comp(value, e)}.
Also, for all elements
\tcode{e}
of
\tcode{[first, last)},
\tcode{e < value}
shall imply
\tcode{!(value < e)}
or
\tcode{comp(e, value)}
shall imply
\tcode{!comp(value, e)}.

\pnum
\returns
\tcode{true}
if there is an iterator
\tcode{i}
in the range
\range{first}{last}
that satisfies the corresponding conditions:
\tcode{!(*i < value) \&\& !(value < *i)}
or
\tcode{comp(*i, value) == false \&\& comp(value, *i) == false}.

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons.
\end{itemdescr}

\rSec2[alg.partitions]{Partitions}

\indexlibrary{\idxcode{is_partitioned}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool is_partitioned(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires For the overload with no \tcode{ExecutionPolicy},
\tcode{InputIterator}'s value type shall be convertible to \tcode{Predicate}'s
argument type.  For the overload with an \tcode{ExecutionPolicy},
\tcode{ForwardIterator}'s value type shall be convertible to \tcode{Predicate}'s
argument type.

\pnum
\returns \tcode{true} if
\range{first}{last} is empty or if
the elements \tcode{e} of
\range{first}{last} are partitioned with respect to the expression
\tcode{pred(e)}.

\pnum
\complexity Linear. At most \tcode{last - first} applications of \tcode{pred}.
\end{itemdescr}

\indexlibrary{\idxcode{partition}}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  ForwardIterator
    partition(ForwardIterator first, ForwardIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator
    partition(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{ForwardIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}.

\pnum
\effects Places all the elements in the range \range{first}{last} that satisfy \tcode{pred} before all the elements that do not satisfy it.

\pnum
\returns An iterator \tcode{i} such that for every iterator \tcode{j} in the range
\range{first}{i} \tcode{pred(*j) != false}, and for every iterator \tcode{k} in the
range \range{i}{last}, \tcode{pred(*k) == false}.

\pnum
\complexity Let $N = \tcode{last - first}$:
\begin{itemize}
\item For the overload with no \tcode{ExecutionPolicy}, exactly $N$ applications
of the predicate.  At most $N / 2$ swaps if \tcode{ForwardIterator} meets the
\tcode{BidirectionalIterator} requirements and at most $N$ swaps otherwise.
\item For the overload with an \tcode{ExecutionPolicy},
\bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}

\end{itemdescr}

\indexlibrary{\idxcode{stable_partition}}%
\begin{itemdecl}
template<class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    stable_partition(ExecutionPolicy&& exec,
                     BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{BidirectionalIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Places all the elements in the range
\range{first}{last}
that satisfy \tcode{pred} before all the
elements that do not satisfy it.

\pnum
\returns
An iterator
\tcode{i}
such that for every iterator
\tcode{j}
in the range
\range{first}{i},
\tcode{pred(*j) != false},
and for every iterator
\tcode{k}
in the range
\range{i}{last},
\tcode{pred(*k) == false}.
The relative order of the elements in both groups is preserved.

\pnum
\complexity
Let $N$ = \tcode{last - first}:
\begin{itemize}
\item For the overload with no \tcode{ExecutionPolicy}, at most $N \log N$ swaps,
but only \bigoh{N} swaps if there is enough extra memory.  Exactly $N$
applications of the predicate.
\item For the overload with an \tcode{ExecutionPolicy},
\bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}

\end{itemdescr}

\indexlibrary{\idxcode{partition_copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator1,
         class OutputIterator2, class Predicate>
  constexpr pair<OutputIterator1, OutputIterator2>
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
         class ForwardIterator2, class Predicate>
  pair<ForwardIterator1, ForwardIterator2>
    partition_copy(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last,
                   ForwardIterator1 out_true, ForwardIterator2 out_false, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\begin{itemize}
\item
For the overload with no \tcode{ExecutionPolicy}, \tcode{InputIterator}'s
value type shall be \tcode{CopyAssignable} (Table~\ref{tab:copyassignable}),
and shall be writable\iref{iterator.requirements.general} to the \tcode{out_true}
and \tcode{out_false} \tcode{OutputIterator}s, and shall be convertible to
\tcode{Predicate}'s argument type.

\item
For the overload with an \tcode{ExecutionPolicy}, \tcode{ForwardIterator}'s
value type shall be \tcode{Copy\-Assign\-able}, and shall be writable to the
\tcode{out_true} and \tcode{out_false} \tcode{ForwardIterator}s, and shall be
convertible to \tcode{Predicate}'s argument type.
\begin{note}
There may be a performance cost if \tcode{ForwardIterator}'s value type is not
\tcode{CopyConstructible}.
\end{note}

\item
For both overloads, the input range shall not overlap with either of the output ranges.
\end{itemize}

\pnum
\effects For each iterator \tcode{i} in \range{first}{last}, copies \tcode{*i} to the output range beginning with \tcode{out_true} if \tcode{pred(*i)} is \tcode{true}, or to the output range beginning with \tcode{out_false} otherwise.

\pnum
\returns A pair \tcode{p} such that \tcode{p.first} is the end of the output range beginning at \tcode{out_true} and \tcode{p.second} is the end of the output range beginning at \tcode{out_false}.

\pnum
\complexity Exactly \tcode{last - first} applications of \tcode{pred}.
\end{itemdescr}

\indexlibrary{\idxcode{partition_point}}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator
    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{ForwardIterator}'s value type shall be convertible to
\tcode{Predicate}'s argument type. The elements \tcode{e} of \range{first}{last}
shall be partitioned with respect to the expression \tcode{pred(e)}.

\pnum
\returns An iterator \tcode{mid} such that \tcode{all_of(first, mid, pred)} and \tcode{none_of(mid, last, pred)} are both \tcode{true}.

\pnum
\complexity \bigoh{\log(\tcode{last - first})} applications of \tcode{pred}.
\end{itemdescr}

\rSec2[alg.merge]{Merge}

\indexlibrary{\idxcode{merge}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{oper\-ator<} or \tcode{comp}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects Copies all the elements of the two ranges \range{first1}{last1} and
\range{first2}{last2} into the range \range{result}{result_last}, where \tcode{result_last}
is \tcode{result + (last1 - first1) + (last2 - first2)}, such that the resulting range satisfies
\tcode{is_sorted(result, result_last)} or \tcode{is_sorted(re\-sult, result_last, comp)}, respectively.

\pnum
\returns
\tcode{result + (last1 - first1) + (last2 - first2)}.

\pnum
\complexity Let $N = \tcode{(last1 - first1) + (last2 - first2)}$:
\begin{itemize}
\item For the overloads with no \tcode{ExecutionPolicy}, at most $N - 1$ comparisons.
\item For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N} comparisons.
\end{itemize}

\pnum
\remarks Stable\iref{algorithm.stable}.
\end{itemdescr}

\indexlibrary{\idxcode{inplace_merge}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  void inplace_merge(BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  void inplace_merge(BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);
template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The ranges \range{first}{middle} and \range{middle}{last} shall be
sorted with respect to \tcode{operator<} or \tcode{comp}.
\tcode{BidirectionalIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Merges two sorted consecutive ranges
\range{first}{middle}
and
\range{middle}{last},
putting the result of the merge into the range
\range{first}{last}.
The resulting range will be in non-decreasing order;
that is, for every iterator
\tcode{i}
in
\range{first}{last}
other than
\tcode{first},
the condition
\tcode{*i < *(i - 1)}
or, respectively,
\tcode{comp(*i, *(i - 1))}
will be \tcode{false}.

\pnum
\complexity Let $N = \tcode{last - first}$:
\begin{itemize}
\item For the overloads with no \tcode{ExecutionPolicy}, if enough additional
memory is available, exactly $N - 1$ comparisons.
\item For the overloads with no \tcode{ExecutionPolicy} if no additional
memory is available,  \bigoh{N \log N} comparisons.
\item For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N \log N} comparisons.
\end{itemize}


\pnum
\remarks Stable\iref{algorithm.stable}.
\end{itemdescr}

\rSec2[alg.set.operations]{Set operations on sorted structures}

\pnum
This subclause defines all the basic set operations on sorted structures.
They also work with
\tcode{multiset}s\iref{multiset}
containing multiple copies of equivalent elements.
The semantics of the set operations are generalized to
\tcode{multiset}s
in a standard way by defining
\tcode{set_union()}
to contain the maximum number of occurrences of every element,
\tcode{set_intersection()}
to contain the minimum, and so on.

\rSec3[includes]{\tcode{includes}}

\indexlibrary{\idxcode{includes}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2,
                          Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class Compare>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if \range{first2}{last2} is empty or
if every element in the range
\range{first2}{last2}
is contained in the range
\range{first1}{last1}.
Returns
\tcode{false}
otherwise.

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons.
\end{itemdescr}

\rSec3[set.union]{\tcode{set_union}}

\indexlibrary{\idxcode{set_union}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted union of the elements from the two ranges;
that is, the set of elements that are present in one or both of the ranges.

\pnum
\returns
The end of the constructed range.

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons.

\pnum
\remarks If \range{first1}{last1} contains $m$ elements that are equivalent to
each other and \range{first2}{last2} contains $n$ elements that are equivalent
to them, then all $m$ elements from the first range shall be copied to the output
range, in order, and then $\max(n - m, 0)$ elements from the second range shall
be copied to the output range, in order.
\end{itemdescr}

\rSec3[set.intersection]{\tcode{set_intersection}}

\indexlibrary{\idxcode{set_intersection}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted intersection of the elements from the two ranges;
that is, the set of elements that are present in both of the ranges.

\pnum
\returns
The end of the constructed range.

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons.

\pnum
\remarks If \range{first1}{last1} contains $m$ elements that are equivalent to
each other and \range{first2}{last2} contains $n$ elements that are equivalent
to them, the first $\min(m, n)$ elements shall be copied from the first range
to the output range, in order.
\end{itemdescr}

\rSec3[set.difference]{\tcode{set_difference}}

\indexlibrary{\idxcode{set_difference}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range
\range{first1}{last1}
which are not present in the range
\range{first2}{last2}
to the range beginning at
\tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
The end of the constructed range.

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons.

\pnum
\remarks
If
\range{first1}{last1}
contains $m$
elements that are equivalent to each other and
\range{first2}{last2}
contains $n$
elements that are equivalent to them, the last
$\max(m - n, 0)$
elements from
\range{first1}{last1}
shall be copied to the output range.
\end{itemdescr}

\rSec3[set.symmetric.difference]{\tcode{set_symmetric_difference}}

\indexlibrary{\idxcode{set_symmetric_difference}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range
\range{first1}{last1}
that are not present in the range
\range{first2}{last2},
and the elements of the range
\range{first2}{last2}
that are not present in the range
\range{first1}{last1}
to the range beginning at
\tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
The end of the constructed range.

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons.

\pnum
\remarks
If \range{first1}{last1} contains $m$ elements that are equivalent to each other and
\range{first2}{last2} contains $n$ elements that are equivalent to them, then
$|m - n|$ of those elements shall be copied to the output range: the last
$m - n$ of these elements from \range{first1}{last1} if $m > n$, and the last
$n - m$ of these elements from \range{first2}{last2} if $m < n$.
\end{itemdescr}

\rSec2[alg.heap.operations]{Heap operations}

\pnum
A
\techterm{heap}
is a particular organization of elements in a range between two random access iterators
\range{a}{b} such that:

\begin{itemize}
\item With \tcode{$N$ = b - a}, for all $i$, $0 < i < N$,
\tcode{comp(a[$\left \lfloor{\frac{i - 1}{2}}\right \rfloor$], a[$i$])}
is \tcode{false}.
\item \tcode{*a}
may be removed by
\tcode{pop_heap()},
or a new element added by
\tcode{push_heap()},
in
\bigoh{\log N}
time.
\end{itemize}

\pnum
These properties make heaps useful as priority queues.

\pnum
\tcode{make_heap()}
converts a range into a heap and
\tcode{sort_heap()}
turns a heap into a sorted sequence.

\rSec3[push.heap]{\tcode{push_heap}}

\indexlibrary{\idxcode{push_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void push_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The range
\range{first}{last - 1}
shall be a valid heap.
The type of \tcode{*first} shall satisfy
the \tcode{MoveConstructible} requirements
(Table~\ref{tab:moveconstructible}) and the
\tcode{MoveAssignable} requirements
(Table~\ref{tab:moveassignable}).

\pnum
\effects
Places the value in the location
\tcode{last - 1}
into the resulting heap
\range{first}{last}.

\pnum
\complexity
At most
$\log(\tcode{last - first})$
comparisons.
\end{itemdescr}

\rSec3[pop.heap]{\tcode{pop_heap}}

\indexlibrary{\idxcode{pop_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The range
\range{first}{last}
shall be a valid non-empty heap.
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).


\pnum
\effects
Swaps the value in the location \tcode{first}
with the value in the location
\tcode{last - 1}
and makes
\range{first}{last - 1}
into a heap.

\pnum
\complexity
At most
$2 \log(\tcode{last - first})$
comparisons.
\end{itemdescr}

\rSec3[make.heap]{\tcode{make_heap}}

\indexlibrary{\idxcode{make_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void make_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The type of \tcode{*first} shall satisfy
the \tcode{MoveConstructible} requirements
(Table~\ref{tab:moveconstructible}) and the
\tcode{MoveAssignable} requirements
(Table~\ref{tab:moveassignable}).

\pnum
\effects
Constructs a heap out of the range
\range{first}{last}.

\pnum
\complexity
At most
$3(\tcode{last - first})$
comparisons.
\end{itemdescr}

\rSec3[sort.heap]{\tcode{sort_heap}}

\indexlibrary{\idxcode{sort_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The range \range{first}{last} shall be a valid heap.
\tcode{RandomAccessIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}. The type
of \tcode{*first} shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{tab:moveconstructible}) and of
\tcode{MoveAssignable} (Table~\ref{tab:moveassignable}).

\pnum
\effects
Sorts elements in the heap
\range{first}{last}.

\pnum
\complexity
At most $2N \log N$
comparisons, where
$N = \tcode{last - first}$.
\end{itemdescr}

\rSec3[is.heap]{\tcode{is_heap}}

\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_heap_until(first, last) == last}
\end{itemdescr}


\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_heap_until(std::forward<ExecutionPolicy>(exec), first, last) == last}
\end{itemdescr}


\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator, class Compare>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                         Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{is_heap_until(first, last, comp) == last}
\end{itemdescr}


\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last,
               Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
is_heap_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{is_heap_until}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);
\end{itemdecl}


\begin{itemdescr}
\pnum
\returns If \tcode{(last - first) < 2}, returns
\tcode{last}. Otherwise, returns
the last iterator \tcode{i} in \crange{first}{last} for which the
range \range{first}{i} is a heap.

\pnum
\complexity Linear.
\end{itemdescr}


\rSec2[alg.min.max]{Minimum and maximum}

\indexlibrary{\idxcode{min}}%
\begin{itemdecl}
template<class T> constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& min(const T& a, const T& b, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
The smaller value.

\pnum
\remarks
Returns the first argument when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison.
\end{itemdescr}

\indexlibrary{\idxcode{min}}%
\begin{itemdecl}
template<class T>
  constexpr T min(initializer_list<T> t);
template<class T, class Compare>
  constexpr T min(initializer_list<T> t, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{CopyConstructible} and \tcode{t.size() > 0}.
For the first form, type \tcode{T} shall be \tcode{LessThanComparable}.

\pnum
\returns The smallest value in the initializer_list.

\pnum
\remarks Returns a copy of the leftmost argument when several arguments are equivalent to the smallest.\

\pnum
\complexity
Exactly \tcode{t.size() - 1} comparisons.
\end{itemdescr}

\indexlibrary{\idxcode{max}}%
\begin{itemdecl}
template<class T> constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& max(const T& a, const T& b, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
The larger value.

\pnum
\remarks
Returns the first argument when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison.
\end{itemdescr}

\indexlibrary{\idxcode{max}}%
\begin{itemdecl}
template<class T>
  constexpr T max(initializer_list<T> t);
template<class T, class Compare>
  constexpr T max(initializer_list<T> t, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{CopyConstructible} and \tcode{t.size() > 0}.
For the first form, type \tcode{T} shall be \tcode{LessThanComparable}.

\pnum
\returns The largest value in the initializer_list.

\pnum
\remarks Returns a copy of the leftmost argument when several arguments are equivalent to the largest.

\pnum
\complexity
Exactly \tcode{t.size() - 1} comparisons.
\end{itemdescr}

\indexlibrary{\idxcode{minmax}}%
\begin{itemdecl}
template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>
  constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
\end{itemdecl}


\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
\tcode{pair<const T\&, const T\&>(b, a)} if \tcode{b} is smaller
than \tcode{a}, and
\tcode{pair<const T\&, const T\&>(a, b)} otherwise.

\pnum
\remarks
Returns \tcode{pair<const T\&, const T\&>(a, b)} when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison.
\end{itemdescr}

\indexlibrary{\idxcode{minmax}}%
\begin{itemdecl}
template<class T>
  constexpr pair<T, T> minmax(initializer_list<T> t);
template<class T, class Compare>
  constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be \tcode{CopyConstructible} and \tcode{t.size() > 0}.
For the first form, type \tcode{T} shall be \tcode{LessThanComparable}.

\pnum
\returns \tcode{pair<T, T>(x, y)}, where \tcode{x} has the smallest and \tcode{y} has the
largest value in the initializer list.

\pnum
\remarks \tcode{x} is a copy of the leftmost argument when several arguments are equivalent to
the smallest. \tcode{y} is a copy of the rightmost argument when several arguments are
equivalent to the largest.

\pnum
\complexity At most $(3/2)\tcode{t.size()}$ applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{min_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{last}
the following corresponding conditions hold:
\tcode{!(*j < *i)}
or
\tcode{comp(*j, *i) == false}.
Returns
\tcode{last}
if
\tcode{first == last}.

\pnum
\complexity
Exactly
$\max(\tcode{last - first - 1}, 0)$
applications of the corresponding comparisons.
\end{itemdescr}

\indexlibrary{\idxcode{max_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{last}
the following corresponding conditions hold:
\tcode{!(*i < *j)}
or
\tcode{comp(*i, *j) == false}.
Returns
\tcode{last}
if
\tcode{first == last}.

\pnum
\complexity
Exactly
$\max(\tcode{last - first - 1}, 0)$
applications of the corresponding comparisons.
\end{itemdescr}

\indexlibrary{\idxcode{minmax_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last, Compare comp);
\end{itemdecl}


\begin{itemdescr}
\pnum
\returns
\tcode{make_pair(first, first)} if \range{first}{last} is empty, otherwise
\tcode{make_pair(m, M)}, where \tcode{m} is
the first iterator in \range{first}{last} such that no iterator in the range refers
to a smaller element, and where \tcode{M} is the last iterator\footnote{This behavior
intentionally differs from \tcode{max_element()}.}
in \range{first}{last} such that no iterator in the range refers to a larger element.

\pnum
\complexity
At most
$\max(\bigl\lfloor{\frac{3}{2}} (N-1)\bigr\rfloor, 0)$
applications of the corresponding predicate, where $N$ is \tcode{last - first}.
\end{itemdescr}

\rSec2[alg.clamp]{Bounded value}

\indexlibrary{\idxcode{clamp}}%
\begin{itemdecl}
template<class T>
  constexpr const T& clamp(const T& v, const T& lo, const T& hi);
template<class T, class Compare>
  constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The value of \tcode{lo} shall be no greater than \tcode{hi}.
For the first form, type \tcode{T}
shall be \tcode{LessThan\-Comparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
\tcode{lo} if \tcode{v} is less than \tcode{lo},
\tcode{hi} if \tcode{hi} is less than \tcode{v},
otherwise \tcode{v}.

\pnum
\begin{note}
If NaN is avoided, \tcode{T} can be a floating-point type.
\end{note}

\pnum
\complexity
At most two comparisons.
\end{itemdescr}

\rSec2[alg.lex.comparison]{Lexicographical comparison}

\indexlibrary{\idxcode{lexicographical_compare}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Compare>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2,
                            Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if the sequence of elements defined by the range
\range{first1}{last1}
is lexicographically less than the sequence of elements defined by the range
\range{first2}{last2} and
\tcode{false}
otherwise.

\pnum
\complexity
At most
$2 \min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$
applications of the corresponding comparison.

\pnum
\remarks
If two sequences have the same number of elements and their corresponding
elements (if any) are equivalent, then neither sequence is lexicographically
less than the other.
If one sequence is a prefix of the other, then the shorter sequence is
lexicographically less than the longer sequence.
Otherwise, the lexicographical comparison of the sequences yields the same
result as the comparison of the first corresponding pair of
elements that are not equivalent.

\pnum
\begin{example}
The following sample implementation satisfies these requirements:
\begin{codeblock}
for ( ; first1 != last1 && first2 != last2 ; ++first1, (void) ++first2) {
  if (*first1 < *first2) return true;
  if (*first2 < *first1) return false;
}
return first1 == last1 && first2 != last2;
\end{codeblock}
\end{example}

\pnum
\begin{note} An empty sequence is lexicographically less than any non-empty sequence, but
not less than any empty sequence.
\end{note}

\end{itemdescr}

\rSec2[alg.3way]{Three-way comparison algorithms}

\indexlibrary{\idxcode{compare_3way}}%
\begin{itemdecl}
template<class T, class U> constexpr auto compare_3way(const T& a, const U& b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares two values and produces a result of the strongest applicable
comparison category type:
\begin{itemize}
\item
Returns \tcode{a <=> b} if that expression is well-formed.
\item
Otherwise, if the expressions \tcode{a == b} and \tcode{a < b}
are each well-formed and convertible to \tcode{bool},
returns \tcode{strong_ordering::equal}
when \tcode{a == b} is \tcode{true},
otherwise returns \tcode{strong_ordering::less}
when \tcode{a < b} is \tcode{true},
and otherwise returns \tcode{strong_ordering::greater}.
\item
Otherwise, if the expression \tcode{a == b}
is well-formed and convertible to \tcode{bool},
returns \tcode{strong_equality::equal}
when \tcode{a == b} is \tcode{true},
and otherwise returns \tcode{strong_equality::nonequal}.
\item
Otherwise, the function is defined as deleted.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{lexicographical_compare_3way}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2, class Cmp>
  constexpr auto
    lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                 InputIterator2 b2, InputIterator2 e2,
                                 Cmp comp)
      -> common_comparison_category_t<decltype(comp(*b1, *b2)), strong_ordering>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Cmp} shall be a function object type
whose return type is a comparison category type.

\pnum
\effects
Lexicographically compares two ranges and
produces a result of the strongest applicable
comparison category type.
Equivalent to:
\begin{codeblock}
for ( ; b1 != e1 && b2 != e2; void(++b1), void(++b2) )
  if (auto cmp = comp(*b1,*b2); cmp != 0)
    return cmp;
return b1 != e1 ? strong_ordering::greater :
       b2 != e2 ? strong_ordering::less :
                  strong_ordering::equal;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{lexicographical_compare_3way}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr auto
    lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,
                                 InputIterator2 b2, InputIterator2 e2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return lexicographical_compare_3way(b1, e1, b2, e2,
                                    [](const auto& t, const auto& u) {
                                      return compare_3way(t, u);
                                    });
\end{codeblock}
\end{itemdescr}

\rSec2[alg.permutation.generators]{Permutation generators}

\indexlibrary{\idxcode{next_permutation}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  bool next_permutation(BidirectionalIterator first,
                        BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  bool next_permutation(BidirectionalIterator first,
                        BidirectionalIterator last, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{BidirectionalIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range
\range{first}{last}
and transforms it into the next permutation.
The next permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
\tcode{operator<}
or \tcode{comp}.

\pnum
\returns
\tcode{true}
if such a permutation exists.
Otherwise, it transforms the sequence into the smallest permutation,
that is, the ascendingly sorted one, and returns
\tcode{false}.

\pnum
\complexity
At most
\tcode{(last - first) / 2}
swaps.
\end{itemdescr}

\indexlibrary{\idxcode{prev_permutation}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  bool prev_permutation(BidirectionalIterator first,
                        BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  bool prev_permutation(BidirectionalIterator first,
                        BidirectionalIterator last, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{BidirectionalIterator} shall satisfy the requirements of
\tcode{ValueSwappable}\iref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range
\range{first}{last}
and transforms it into the previous permutation.
The previous permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
\tcode{operator<}
or \tcode{comp}.

\pnum
\returns
\tcode{true}
if such a permutation exists.
Otherwise, it transforms the sequence into the largest permutation,
that is, the descendingly sorted one, and returns
\tcode{false}.

\pnum
\complexity
At most
\tcode{(last - first) / 2}
swaps.
\end{itemdescr}

\rSec1[alg.c.library]{C library algorithms}

\pnum
\indexhdr{cstdlib}%
\begin{note}
The header \tcode{<cstdlib>}\iref{cstdlib.syn}
declares the functions described in this subclause.
\end{note}

\indexlibrary{\idxcode{bsearch}}%
\indexlibrary{\idxcode{qsort}}%
\begin{itemdecl}
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              @\placeholder{c-compare-pred}@* compar);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              @\placeholder{compare-pred}@* compar);
void qsort(void* base, size_t nmemb, size_t size, @\placeholder{c-compare-pred}@* compar);
void qsort(void* base, size_t nmemb, size_t size, @\placeholder{compare-pred}@* compar);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions have the semantics specified in the C standard library.

\pnum
\remarks
The behavior is undefined
unless the objects in the array pointed to by \tcode{base}
are of trivial type.

\pnum
\throws
Any exception thrown by \tcode{compar()}\iref{res.on.exception.handling}.
\end{itemdescr}

\xref
ISO C 7.22.5.
