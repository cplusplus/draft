%!TEX root = std.tex
\rSec0[utilities]{General utilities library}

\rSec1[utilities.general]{General}

\pnum
This Clause describes utilities that are generally useful in \Cpp programs; some
of these utilities are used by other elements of the \Cpp standard library.
These utilities are summarized in Table~\ref{tab:util.lib.summary}.

\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{utility}               & Utility components                & \tcode{<utility>}     \\ \rowsep
\ref{pairs}                 & Pairs                             & \tcode{<utility>}     \\ \rowsep
\ref{tuple}                 & Tuples                            & \tcode{<tuple>}       \\ \rowsep
\ref{intseq}                & Compile-time integer sequences    & \tcode{<utility>}     \\ \rowsep
\ref{template.bitset}       & Fixed-size sequences of bits      & \tcode{<bitset>}      \\ \rowsep
                            &                                   & \tcode{<memory>}      \\
\ref{memory}                & Memory                            & \tcode{<cstdlib>}     \\
                            &                                   & \tcode{<cstring>}     \\ \rowsep
\ref{smartptr}              & Smart pointers                    & \tcode{<memory>}      \\ \rowsep
\ref{function.objects}      & Function objects                  & \tcode{<functional>}  \\ \rowsep
\ref{meta}                  & Type traits                       & \tcode{<type_traits>} \\ \rowsep
\ref{ratio}                 & Compile-time rational arithmetic  & \tcode{<ratio>}       \\ \rowsep
\ref{time}                  & Time utilities                    & \tcode{<chrono>}      \\
                            &                                   & \tcode{<ctime>}       \\ \rowsep
\ref{allocator.adaptor}     & Scoped allocators                 & \tcode{<scoped_allocator>} \\ \rowsep
\ref{type.index}            & Type indexes                      & \tcode{<typeindex>}   \\
\end{libsumtab}

\rSec1[utility]{Utility components}

\pnum
This subclause contains some basic function and class templates that are used
throughout the rest of the library.

\indexlibrary{\idxhdr{utility}}%
\indexlibrary{\idxcode{rel_ops}}%
\synopsis{Header \tcode{<utility>} synopsis}

\pnum
The header \tcode{<utility>} defines several types and function templates
that are described in this Clause. It also defines the template \tcode{pair}
and various function templates that operate on \tcode{pair} objects.

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{operators}, operators:
  namespace rel_ops {
    template<class T> bool operator!=(const T&, const T&);
    template<class T> bool operator> (const T&, const T&);
    template<class T> bool operator<=(const T&, const T&);
    template<class T> bool operator>=(const T&, const T&);
  }

  // \ref{utility.swap}, swap:
  template<class T> void swap(T& a, T& b) noexcept(@\seebelow@);
  template <class T, size_t N> void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

  // \ref{utility.exchange}, exchange:
  template <class T, class U=T> T exchange(T& obj, U&& new_val);

  // \ref{forward}, forward/move:
  template <class T> 
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
  template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
  template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
  template <class T>
    constexpr conditional_t<
    !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
    const T&, T&&> move_if_noexcept(T& x) noexcept;

  // \ref{declval}, declval:
  template <class T>
    add_rvalue_reference_t<T> declval() noexcept;  // as unevaluated operand

  // \ref{pairs}, pairs:
  template <class T1, class T2> struct pair;

  // \ref{pairs.spec}, pair specialized algorithms:
  template <class T1, class T2>
    constexpr bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    constexpr bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    constexpr bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    constexpr bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    constexpr bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    constexpr bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    void swap(pair<T1,T2>& x, pair<T1,T2>& y) noexcept(noexcept(x.swap(y)));
  template <class T1, class T2>
    constexpr @\seebelow@ make_pair(T1&&, T2&&);

  // \ref{pair.astuple}, tuple-like access to pair:
  template <class T> class tuple_size;
  template <size_t I, class T> class tuple_element;

  template <class T1, class T2> struct tuple_size<pair<T1, T2> >;
  template <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;
  template <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;

  template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&
      get(pair<T1, T2>&) noexcept;
  template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&&
      get(pair<T1, T2>&&) noexcept;
  template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&
      get(const pair<T1, T2>&) noexcept;
  template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
  template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
  template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
  template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
  template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
  template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;

  // \ref{pair.piecewise}, pair piecewise construction
  struct piecewise_construct_t { };
  constexpr piecewise_construct_t piecewise_construct{};
  template <class... Types> class tuple;  // defined in \tcode{<tuple>}
@
\indexlibrary{\idxcode{index_sequence}}%
\indexlibrary{\idxcode{make_index_sequence}}%
\indexlibrary{\idxcode{index_sequence_for}}%
@
  // \ref{intseq}, Compile-time integer sequences
  template<class T, T...> struct integer_sequence;
  template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;

  template<class T, T N>
    using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
  template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;

  template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
}
\end{codeblock}

\rSec2[operators]{Operators}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\indexlibrary{\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{EqualityComparable} (Table~\ref{equalitycomparable}).

\pnum
\returns
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}}%
\begin{itemdecl}
template <class T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{lessthancomparable}).

\pnum
\returns
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}}%
\begin{itemdecl}
template <class T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{lessthancomparable}).

\pnum
\returns
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}}%
\begin{itemdecl}
template <class T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{lessthancomparable}).

\pnum
\returns
\tcode{!(x < y)}.
\end{itemdescr}

\pnum
In this library, whenever a declaration is provided for an \tcode{operator!=},
\tcode{operator>}, \tcode{operator>=}, or \tcode{operator<=},
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this Clause.

\rSec2[utility.swap]{swap}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template<class T> void swap(T& a, T& b) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_move_constructible<T>::value &&
is_nothrow_move_assignable<T>::value
\end{codeblock}

\pnum
\requires
Type
\tcode{T}
shall be
\tcode{MoveConstructible} (Table~\ref{moveconstructible})
and
\tcode{MoveAssignable} (Table~\ref{moveassignable}).

\pnum
\effects
Exchanges values stored in two locations.
\end{itemdescr}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template<class T, size_t N>
  void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{a[i]} shall be swappable with~(\ref{swappable.requirements}) \tcode{b[i]}
for all \tcode{i} in the range \range{0}{N}.

\pnum
\effects \tcode{swap_ranges(a, a + N, b)}
\end{itemdescr}

\rSec2[utility.exchange]{exchange}

\begin{itemdecl}
template <class T, class U=T> T exchange(T& obj, U&& new_val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:

\begin{codeblock}
T old_val = std::move(obj);
obj = std::forward<U>(new_val);
return old_val;
\end{codeblock}
\end{itemdescr}


\rSec2[forward]{forward/move helpers}

\pnum
The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.

\indexlibrary{\idxcode{forward}}%
\begin{itemdecl}
template <class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept;
template <class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<T\&\&>(t)}.

\pnum
\remark If the second form is instantiated with an lvalue reference type, the program is ill-formed.

\pnum
\enterexample
\begin{codeblock}
template <class T, class A1, class A2>
shared_ptr<T> factory(A1&& a1, A2&& a2) {
  return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2)));
}

struct A {
  A(int&, const double&);
};

void g() {
  shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to \tcode{int\&}
  int i = 2;
  shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK
}
\end{codeblock}

\pnum
In the first call to \tcode{factory},
\tcode{A1} is deduced as \tcode{int}, so 2 is forwarded
to \tcode{A}'s constructor as an rvalue.
In the second call to \tcode{factory},
\tcode{A1} is deduced as \tcode{int\&}, so \tcode{i} is forwarded
to \tcode{A}'s constructor as an lvalue. In
both cases, \tcode{A2} is deduced as \tcode{double}, so
1.414 is forwarded to \tcode{A}'s constructor as an rvalue.

\exitexample
\end{itemdescr}

\indexlibrary{\idxcode{move}}%
\begin{itemdecl}
template <class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{static_cast<remove_reference_t<T>\&\&>(t)}.

\pnum
\enterexample
\begin{codeblock}
template <class T, class A1>
shared_ptr<T> factory(A1&& a1) {
  return shared_ptr<T>(new T(std::forward<A1>(a1)));
}

struct A {
  A();
  A(const A&);  // copies from lvalues
  A(A&&);       // moves from rvalues
};

void g() {
  A a;
  shared_ptr<A> sp1 = factory<A>(a);              // ``\tcode{a}'' binds to \tcode{A(const A\&)}
  shared_ptr<A> sp1 = factory<A>(std::move(a));   // ``\tcode{a}'' binds to \tcode{A(A\&\&)}
}
\end{codeblock}

\pnum
In the first call to \tcode{factory},
\tcode{A1} is deduced as \tcode{A\&}, so \tcode{a} is forwarded
as a non-const lvalue. This binds to the constructor \tcode{A(const A\&)},
which copies the value from \tcode{a}.
In the second call to \tcode{factory}, because of the call
\tcode{std::move(a)},
\tcode{A1} is deduced as \tcode{A}, so \tcode{a} is forwarded
as an rvalue. This binds to the constructor \tcode{A(A\&\&)},
which moves the value from \tcode{a}.

\exitexample
\end{itemdescr}

\indexlibrary{\idxcode{move_if_noexcept}}%
\begin{itemdecl}
template <class T> constexpr conditional_t<
  !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
  const T&, T&&> move_if_noexcept(T& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{std::move(x)}
\end{itemdescr}

\rSec2[declval]{Function template \tcode{declval}}

\pnum
The library provides the function template \tcode{declval} to simplify the definition of
expressions which occur as unevaluated operands (Clause~\ref{expr}).

\indexlibrary{\idxcode{declval}}%
\begin{itemdecl}
template <class T>
  add_rvalue_reference_t<T> declval() noexcept;  // as unevaluated operand
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes If this function is odr-used~(\ref{basic.def.odr}), the program is ill-formed.

\pnum
\notes The template parameter \tcode{T} of \tcode{declval} may be an incomplete type.

\enterexample
\begin{codeblock}
template <class To, class From>
  decltype(static_cast<To>(declval<From>())) convert(From&&);
\end{codeblock}

declares a function template \tcode{convert} which only participates in overloading if the
type \tcode{From} can be explicitly converted to type \tcode{To}. For another example see class
template \tcode{common_type}~(\ref{meta.trans.other}).
\exitexample
\end{itemdescr}

\rSec1[pairs]{Pairs}

\rSec2[pairs.general]{In general}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\indexlibrary{\idxcode{pair}}%
\indextext{\idxcode{pair}!tuple interface to}%
\indextext{\idxcode{tuple}!and pair@and \tcode{pair}}%

\rSec2[pairs.pair]{Class template \tcode{pair}}

\indexlibrary{\idxcode{pair}}%
\begin{codeblock}
// defined in header \tcode{<utility>}

namespace std {
  template <class T1, class T2>
  struct pair {
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;
    pair(const pair&) = default;
    pair(pair&&) = default;
    constexpr pair();
    constexpr pair(const T1& x, const T2& y);
    template<class U, class V> constexpr pair(U&& x, V&& y);
    template<class U, class V> constexpr pair(const pair<U, V>& p);
    template<class U, class V> constexpr pair(pair<U, V>&& p);
    template <class... Args1, class... Args2>
      pair(piecewise_construct_t,
           tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p);
    template<class U, class V> pair& operator=(const pair<U, V>& p);
    pair& operator=(pair&& p) noexcept(@\seebelow@);
    template<class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(@\seebelow@);
  };
}
\end{codeblock}

\pnum
Constructors and member functions of \tcode{pair} shall not throw exceptions unless one of
the element-wise operations specified to be called for that operation
throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of pair shall
be a \tcode{constexpr} function if and only if all required element-wise
initializations for copy and move, respectively, would satisfy the
requirements for a \tcode{constexpr} function.

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
constexpr pair();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_default_constructible<first_type>::value} is \tcode{true}
and \tcode{is_default_construct-}\\\tcode{ible<second_type>::value} is \tcode{true}.

\pnum
\effects
Value-initializes \tcode{first} and \tcode{second}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
constexpr pair(const T1& x, const T2& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_constructible<first_type>::value} is \tcode{true}
and \tcode{is_copy_constructible<sec\-ond_type>::value} is \tcode{true}.

\pnum
\effects
The constructor initializes \tcode{first} with \tcode{x} and \tcode{second}
with \tcode{y}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
template<class U, class V> constexpr pair(U&& x, V&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_constructible<first_type, U\&\&>::value} is \tcode{true}
and \tcode{is_constructible<second_type, V\&\&>::value} is \tcode{true}.

\pnum
\effects
The constructor initializes \tcode{first} with
\tcode{std::forward<U>(x)} and \tcode{second}
with \tcode{std::forward<\brk{}V>(y)}.

\pnum
\notes
If \tcode{U} is not implicitly convertible to \tcode{first_type} or \tcode{V} is not
implicitly convertible to \tcode{second_type} this constructor shall not participate in
overload resolution.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
template<class U, class V> constexpr pair(const pair<U, V>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_constructible<first_type, const U\&>::value} is \tcode{true}
and \tcode{is_constructible<sec\-ond_type, const V\&>::value} is \tcode{true}.

\pnum
\effects
Initializes members from the corresponding members of the argument.

\pnum
\remark This constructor shall not participate in overload resolution unless
\tcode{const U\&} is implicitly convertible to \tcode{first_type} and
\tcode{const V\&} is implicitly convertible to \tcode{second_type}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
template<class U, class V> constexpr pair(pair<U, V>&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_constructible<first_type, U\&\&>::value} is \tcode{true}
and \tcode{is_constructible<second_type, V\&\&>::value} is \tcode{true}.

\pnum
\effects
The constructor initializes \tcode{first} with
\tcode{std::forward<U>(p.first)}
and \tcode{second} with
\tcode{std::\brk{}forward<V>(p.second)}.

\pnum
\remark This constructor shall not participate in overload resolution unless
\tcode{U} is implicitly convertible to \tcode{first_type} and
\tcode{V} is implicitly convertible to \tcode{second_type}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
template<class... Args1, class... Args2>
  pair(piecewise_construct_t,
       tuple<Args1...> first_args, tuple<Args2...> second_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_constructible<first_type, Args1\&\&...>::value} is \tcode{true}
and \tcode{is_con\-structible<second_type, Args2\&\&...>::value} is \tcode{true}.

\pnum
\effects The constructor initializes \tcode{first} with arguments of types
\tcode{Args1...} obtained by forwarding the elements of \tcode{first_args}
and initializes \tcode{second} with arguments of types \tcode{Args2...}
obtained by forwarding the elements of \tcode{second_args}. (Here, forwarding
an element \tcode{x} of type \tcode{U} within a \tcode{tuple} object means calling
\tcode{std::forward<U>(x)}.) This form of construction, whereby constructor
arguments for \tcode{first} and \tcode{second} are each provided in a separate
\tcode{tuple} object, is called \defn{piecewise construction}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{operator=}}
\begin{itemdecl}
pair& operator=(const pair& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_assignable<first_type>::value} is \tcode{true}
and \tcode{is_copy_assignable<second_type>::value} is \tcode{true}.

\pnum
\effects Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{operator=}}
\begin{itemdecl}
template<class U, class V> pair& operator=(const pair<U, V>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_assignable<first_type\&, const U\&>::value} is \tcode{true}
and \tcode{is_assignable<second_type\&, const V\&>::value} is \tcode{true}.

\pnum
\effects Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{operator=}}
\begin{itemdecl}
pair& operator=(pair&& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_move_assignable<T1>::value &&
is_nothrow_move_assignable<T2>::value
\end{codeblock}

\pnum
\requires \tcode{is_move_assignable<first_type>::value} is \tcode{true}
and \tcode{is_move_assignable<second_type>::value} is \tcode{true}.

\pnum
\effects
Assigns to \tcode{first} with \tcode{std::forward<first_type>(p.first)}
and to \tcode{second} with\\ \tcode{std::forward<second_type>(p.second)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{operator=}}
\begin{itemdecl}
template<class U, class V> pair& operator=(pair<U, V>&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_assignable<first_type\&, U\&\&>::value} is \tcode{true}
and \tcode{is_assignable<second_type\&, V\&\&>::value} is \tcode{true}.

\pnum
\effects
Assigns to \tcode{first} with \tcode{std::forward<U>(p.first)}
and to \tcode{second} with\\ \tcode{std::forward<V>(p.second)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{swap}}
\begin{itemdecl}
void swap(pair& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
noexcept(swap(first, p.first)) &&
noexcept(swap(second, p.second))
\end{codeblock}

\pnum
\requires
\tcode{first} shall be swappable with~(\ref{swappable.requirements})
\tcode{p.first} and \tcode{second} shall be swappable with \tcode{p.second}.

\pnum
\effects Swaps
\tcode{first} with \tcode{p.first} and
\tcode{second} with \tcode{p.second}.
\end{itemdescr}

\rSec2[pairs.spec]{Specialized algorithms}

\indexlibrary{\idxcode{operator==}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first == y.first \&\& x.second == y.second}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first < y.first || (!(y.first < x.first) \&\& x.second < y.second)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}
\end{itemdescr}


\indexlibrary{\idxcode{swap}!\tcode{pair}}%
\begin{itemdecl}
template<class T1, class T2> void swap(pair<T1, T2>& x, pair<T1, T2>& y)
  noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}
\end{itemdescr}

\indexlibrary{\idxcode{make_pair}}%
\begin{itemdecl}
template <class T1, class T2>
  constexpr pair<V1, V2> make_pair(T1&& x, T2&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y))};

where \tcode{V1} and \tcode{V2} are determined as follows: Let \tcode{Ui} be
\tcode{decay_t<Ti>} for each \tcode{Ti}. Then each \tcode{Vi} is \tcode{X\&}
if \tcode{Ui} equals \tcode{reference_wrapper<X>}, otherwise \tcode{Vi} is
\tcode{Ui}.

\pnum
\enterexample
In place of:

\begin{codeblock}
  return pair<int, double>(5, 3.1415926);   // explicit types
\end{codeblock}

a \Cpp program may contain:

\begin{codeblock}
  return make_pair(5, 3.1415926);           // types are deduced
\end{codeblock}
\exitexample
\end{itemdescr}

\rSec2[pair.astuple]{Tuple-like access to pair}

\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template <class T1, class T2>
struct tuple_size<pair<T1, T2>>
  : integral_constant<size_t, 2> { };
\end{itemdecl}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
tuple_element<0, pair<T1, T2> >::type
\end{itemdecl}
\begin{itemdescr}
\pnum\textit{Value:} the type \tcode{T1}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
tuple_element<1, pair<T1, T2> >::type
\end{itemdecl}
\begin{itemdescr}
\pnum\textit{Value:} the type T2.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template<size_t I, class T1, class T2>
  constexpr tuple_element_t<I, pair<T1, T2>>&
    get(pair<T1, T2>& p) noexcept;
template<size_t I, class T1, class T2>
  constexpr const tuple_element_t<I, pair<T1, T2>>&
    get(const pair<T1, T2>& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum\returns If \tcode{I == 0} returns \tcode{p.first};
if \tcode{I == 1} returns \tcode{p.second}; otherwise the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template<size_t I, class T1, class T2>
  constexpr tuple_element_t<I, pair<T1, T2>>&&
    get(pair<T1, T2>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\returns If \tcode{I == 0} returns \tcode{std::forward<T1\&\&>(p.first)};
if \tcode{I == 1} returns
\tcode{std::forward<T2\&\&>(\brk{}p.second)};
otherwise the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template <class T, class U>
  constexpr T& get(pair<T, U>& p) noexcept;
template <class T, class U>
  constexpr const T& get(const pair<T, U>& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\requires \tcode{T} and \tcode{U} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns \tcode{get<0>(p);}
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template <class T, class U>
  constexpr T&& get(pair<T, U>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires \tcode{T} and \tcode{U} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns \tcode{get<0>(std::move(p));}
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template <class T, class U>
  constexpr T& get(pair<U, T>& p) noexcept;
template <class T, class U>
  constexpr const T& get(const pair<U, T>& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\requires \tcode{T} and \tcode{U} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns \tcode{get<1>(p);}
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{pair}}%
\begin{itemdecl}
template <class T, class U>
  constexpr T&& get(pair<U, T>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\requires \tcode{T} and \tcode{U} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns \tcode{get<1>(std::move(p));}
\end{itemdescr}

\rSec2[pair.piecewise]{Piecewise construction}

\indexlibrary{\idxcode{piecewise_construct_t}}%
\indexlibrary{\idxcode{piecewise_construct}}%
\begin{itemdecl}
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
\end{itemdecl}

\pnum
The \tcode{struct} \tcode{piecewise_construct_t} is an empty structure type
used as a unique type to disambiguate constructor and function overloading. Specifically,
\tcode{pair} has a constructor with \tcode{piecewise_construct_t} as the
first argument, immediately followed by two \tcode{tuple}~(\ref{tuple}) arguments used
for piecewise construction of the elements of the \tcode{pair} object.

\rSec1[tuple]{Tuples}

\rSec2[tuple.general]{In general}

\pnum
\indexlibrary{\idxcode{tuple}}%
This subclause describes the tuple library that provides a tuple type as
the class template \tcode{tuple} that can be instantiated with any number
of arguments. Each template argument specifies
the type of an element in the \tcode{tuple}.  Consequently, tuples are
heterogeneous, fixed-size collections of values. An instantiation of \tcode{tuple} with
two arguments is similar to an instantiation of \tcode{pair} with the same two arguments.
See~\ref{pairs}.

\pnum
\synopsis{Header \tcode{<tuple>} synopsis}

\indexlibrary{\idxhdr{tuple}}%
\begin{codeblock}
namespace std {
  // \ref{tuple.tuple}, class template \tcode{tuple}:
  template <class... Types> class tuple;

  // \ref{tuple.creation}, tuple creation functions:
  const @\unspec@ ignore;

  template <class... Types>
    constexpr tuple<@\textit{VTypes}@...> make_tuple(Types&&...);
  template <class... Types>
    constexpr tuple<Types&&...> forward_as_tuple(Types&&...) noexcept;

  template<class... Types>
    constexpr tuple<Types&...> tie(Types&...) noexcept;

  template <class... Tuples>
    constexpr tuple<@\textit{Ctypes}@...> tuple_cat(Tuples&&...);

  // \ref{tuple.helper}, tuple helper classes:
  template <class T> class tuple_size;  // undefined
  template <class T> class tuple_size<const T>;
  template <class T> class tuple_size<volatile T>;
  template <class T> class tuple_size<const volatile T>;

  template <class... Types> class tuple_size<tuple<Types...> >;

  template <size_t I, class T> class tuple_element;    // undefined
  template <size_t I, class T> class tuple_element<I, const T>;
  template <size_t I, class T> class tuple_element<I, volatile T>;
  template <size_t I, class T> class tuple_element<I, const volatile T>;

  template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;

  template <size_t I, class T>
    using tuple_element_t = typename tuple_element<I, T>::type;

  // \ref{tuple.elem}, element access:
  template <size_t I, class... Types>
    constexpr tuple_element_t<I, tuple<Types...>>&
      get(tuple<Types...>&) noexcept;
  template <size_t I, class... Types>
    constexpr tuple_element_t<I, tuple<Types...>>&&
      get(tuple<Types...>&&) noexcept;
  template <size_t I, class... Types>
    constexpr const tuple_element_t<I, tuple<Types...>>&
      get(const tuple<Types...>&) noexcept;
  template <class T, class... Types>
    constexpr T& get(tuple<Types...>& t) noexcept;
  template <class T, class... Types>
    constexpr T&& get(tuple<Types...>&& t) noexcept;
  template <class T, class... Types>
    constexpr const T& get(const tuple<Types...>& t) noexcept;

  // \ref{tuple.rel}, relational operators:
  template<class... TTypes, class... UTypes>
    constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

  // \ref{tuple.traits}, allocator-related traits
  template <class... Types, class Alloc>
    struct uses_allocator<tuple<Types...>, Alloc>;

  // \ref{tuple.special}, specialized algorithms:
  template <class... Types>
    void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);
}
\end{codeblock}

\rSec2[tuple.tuple]{Class template \tcode{tuple}}

\indexlibrary{\idxcode{tuple}}%
\begin{codeblock}
namespace std {
  template <class... Types>
  class tuple  {
  public:

    // \ref{tuple.cnstr}, \tcode{tuple} construction
    constexpr tuple();
    constexpr explicit tuple(const Types&...);
    template <class... UTypes>
      constexpr explicit tuple(UTypes&&...);

    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template <class... UTypes>
      constexpr tuple(const tuple<UTypes...>&);
    template <class... UTypes>
      constexpr tuple(tuple<UTypes...>&&);

    template <class U1, class U2>
      constexpr tuple(const pair<U1, U2>&);       // only if \tcode{sizeof...(Types) == 2}
    template <class U1, class U2>
      constexpr tuple(pair<U1, U2>&&);            // only if \tcode{sizeof...(Types) == 2}

    // allocator-extended constructors
    template <class Alloc>
      tuple(allocator_arg_t, const Alloc& a);
    template <class Alloc>
      tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template <class Alloc, class... UTypes>
      tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template <class Alloc>
      tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template <class Alloc>
      tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template <class Alloc, class... UTypes>
      tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template <class Alloc, class... UTypes>
      tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template <class Alloc, class U1, class U2>
      tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template <class Alloc, class U1, class U2>
      tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

    // \ref{tuple.assign}, \tcode{tuple} assignment
    tuple& operator=(const tuple&);
    tuple& operator=(tuple&&) noexcept(@\seebelow@);

    template <class... UTypes>
      tuple& operator=(const tuple<UTypes...>&);
    template <class... UTypes>
      tuple& operator=(tuple<UTypes...>&&);

    template <class U1, class U2>
      tuple& operator=(const pair<U1, U2>&);    // only if \tcode{sizeof...(Types) == 2}
    template <class U1, class U2>
      tuple& operator=(pair<U1, U2>&&);         // only if \tcode{sizeof...(Types) == 2}

    // \ref{tuple.swap}, \tcode{tuple} swap
    void swap(tuple&) noexcept(@\seebelow@);
  };
}
\end{codeblock}

\rSec3[tuple.cnstr]{Construction}

\pnum
For each \tcode{tuple} constructor, an exception is thrown only if the construction of
one of the types in \tcode{Types} throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of
\tcode{tuple} shall be a \tcode{constexpr} function if and only if all
required element-wise initializations for copy and move, respectively,
would satisfy the requirements for a \tcode{constexpr} function. The
defaulted move and copy constructor of \tcode{tuple<>} shall be
\tcode{constexpr} functions.

\pnum
In the constructor descriptions that follow, let $i$ be in the range
\range{0}{sizeof...(Types)} in order, $T_i$ be the $i^{th}$ type in \tcode{Types}, and
$U_i$ be the $i^{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based.

\indexlibrary{\idxcode{tuple}!\idxcode{tuple}}%
\begin{itemdecl}
constexpr tuple();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_default_constructible<$T_i$>::value} is true for all $i$.

\pnum
\effects  Value initializes each element.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
constexpr explicit tuple(const Types&...);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_constructible<$T_i$>::value} is true for all $i$.

\pnum
\effects Initializes each element with the value of the
corresponding parameter.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template <class... UTypes>
  constexpr explicit tuple(UTypes&&... u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)}.
\tcode{is_constructible<$T_i$, $U_i$\&\&>::value} is \tcode{true} for all $i$.

\pnum
\effects Initializes the elements in the tuple with the
corresponding value in \tcode{std::forward<UTypes>(u)}.

\pnum
\remark This constructor shall not participate in overload resolution unless each type
in \tcode{UTypes} is implicitly convertible to its corresponding type in \tcode{Types}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
tuple(const tuple& u) = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_constructible<$T_i$>::value} is \tcode{true} for all $i$.

\pnum
\effects Initializes each element of \tcode{*this} with the
corresponding element of \tcode{u}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
tuple(tuple&& u) = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_move_constructible<$T_i$>::value} is \tcode{true} for all $i$.

\pnum
\effects For all $i$, initializes the $i^{th}$ element of \tcode{*this} with
\tcode{std::forward<$T_i$>(get<$i$>(u))}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template <class... UTypes> constexpr tuple(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)}.
\tcode{is_constructible<$T_i$, const $U_i$\&>::value} is \tcode{true} for all $i$.

\pnum
\effects  Constructs each element of \tcode{*this} with the corresponding
element of \tcode{u}.

\pnum
\remark This constructor shall not participate in overload resolution unless
\tcode{const $U_i$\&} is implicitly convertible to $T_i$ for all $i$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template <class... UTypes> constexpr tuple(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)}.
\tcode{is_constructible<$T_i$, $U_i$\&\&>::value} is \tcode{true} for all $i$.

\pnum
\effects For all $i$, initializes the $i^{th}$ element of \tcode{*this} with
\tcode{std::forward<$U_i$>(get<$i$>(u))}.

\pnum
\remark This constructor shall not participate in overload resolution unless
each type in \tcode{UTypes} is implicitly convertible to its corresponding type in
\tcode{Types}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template <class U1, class U2> constexpr tuple(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sizeof...(Types) == 2}.
\tcode{is_constructible<$T_0$, const U1\&>::value} is \tcode{true} for the first type
$T_0$ in \tcode{Types} and
\tcode{is_constructible<$T_1$, const U2\&>::value} is \tcode{true} for the second type
$T_1$ in \tcode{Types}.

\pnum
\effects  Constructs the first element with \tcode{u.first} and the
second element with \tcode{u.second}.

\pnum
\remark This constructor shall not participate in overload resolution unless
\tcode{const U1\&} is implicitly convertible to $T_0$ and \tcode{const U2\&}
is implicitly convertible to $T_1$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template <class U1, class U2> constexpr tuple(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sizeof...(Types) == 2}.
\tcode{is_constructible<$T_0$, U1\&\&>::value} is \tcode{true} for the first type
$T_0$ in \tcode{Types} and
\tcode{is_constructible<$T_1$, U2\&\&>::value} is \tcode{true} for the second type
$T_1$ in \tcode{Types}.


\pnum
\effects Initializes the first element with
\tcode{std::forward<U1>(u.first)} and the
second element with \tcode{std::forward<U2>(u.second)}.

\pnum
\remark This constructor shall not participate in overload resolution unless
\tcode{U1} is implicitly convertible to $T_0$ and \tcode{U2}
is implicitly convertible to $T_1$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template <class Alloc>
  tuple(allocator_arg_t, const Alloc& a);
template <class Alloc>
  tuple(allocator_arg_t, const Alloc& a, const Types&...);
template <class Alloc, class... UTypes>
  tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
template <class Alloc>
  tuple(allocator_arg_t, const Alloc& a, const tuple&);
template <class Alloc>
  tuple(allocator_arg_t, const Alloc& a, tuple&&);
template <class Alloc, class... UTypes>
  tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template <class Alloc, class... UTypes>
  tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template <class Alloc, class U1, class U2>
  tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template <class Alloc, class U1, class U2>
  tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{Alloc} shall meet the requirements for an
\tcode{Allocator}~(\ref{allocator.requirements}).

\pnum
\effects Equivalent to the preceding constructors except that each element is constructed with
uses-allocator construction~(\ref{allocator.uses.construction}).
\end{itemdescr}

\rSec3[tuple.assign]{Assignment}

\pnum
For each \tcode{tuple} assignment operator, an exception is thrown only if the
assignment of one of the types in \tcode{Types} throws an exception.
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...\brk{}(Types)}
in order, $T_i$ be the $i^{th}$ type in \tcode{Types}, and $U_i$ be the $i^{th}$ type in a
template parameter pack named \tcode{UTypes}, where indexing is zero-based.

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\begin{itemdecl}
tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_assignable<$T_i$>::value} is \tcode{true} for all $i$.

\pnum
\effects  Assigns each element of \tcode{u} to the corresponding
element of \tcode{*this}.

\pnum
\returns  \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\begin{itemdecl}
tuple& operator=(tuple&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark The expression inside \tcode{noexcept} is equivalent to the logical \textsc{and} of the
following expressions:

\begin{codeblock}
is_nothrow_move_assignable<@$T_i$@>::value
\end{codeblock}

where $T_i$ is the $i^{th}$ type in \tcode{Types}.

\pnum
\requires \tcode{is_move_assignable<$T_i$>::value} is \tcode{true} for all $i$.

\pnum
\effects For all $i$, assigns \tcode{std::forward<$T_i$>(get<$i$>(u))} to
\tcode{get<$i$>(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\begin{itemdecl}
template <class... UTypes>
  tuple& operator=(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{sizeof...(Types) == sizeof...(UTypes)} and
\tcode{is_assignable<$T_i$\&, const $U_i$\&>::value} is \tcode{true} for all $i$.

\pnum
\effects  Assigns each element of \tcode{u} to the corresponding element
of \tcode{*this}.

\pnum
\returns  \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\begin{itemdecl}
template <class... UTypes>
  tuple& operator=(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_assignable<Ti\&, Ui\&\&>::value == true} for all \tcode{i}.
\tcode{sizeof...(Types)} \tcode{==}\\\tcode{sizeof...(UTypes)}.

\pnum
\effects For all $i$, assigns \tcode{std::forward<$U_i$>(get<$i$)>(u))} to
\tcode{get<$i$>(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sizeof...(Types) == 2}.
\tcode{is_assignable<$T_0$\&, const U1\&>::value} is \tcode{true} for the first type $T_0$ in
\tcode{Types} and \tcode{is_assignable<$T_1$\&, const U2\&>::value} is \tcode{true} for the
second type $T_1$ in \tcode{Types}.

\pnum
\effects  Assigns \tcode{u.first} to the first element of \tcode{*this}
and \tcode{u.second} to the second element of \tcode{*this}.

\pnum
\returns  \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{tuple}}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template <class U1, class U2> tuple& operator=(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sizeof...(Types) == 2}.
\tcode{is_assignable<$T_0$\&, U1\&\&>::value} is \tcode{true} for the first type $T_0$ in
\tcode{Types} and \tcode{is_assignable<$T_1$\&, U2\&\&>::value} is \tcode{true} for the second
type $T_1$ in \tcode{Types}.

\pnum
\effects Assigns \tcode{std::forward<U1>(u.first)} to the first
element of \tcode{*this} and\\ \tcode{std::forward<U2>(u.second)} to the
second element of \tcode{*this}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec3[tuple.swap]{\tcode{swap}}

\indexlibrary{\idxcode{swap}!\idxcode{tuple}}
\indexlibrary{\idxcode{tuple}!\idxcode{swap}}
\begin{itemdecl}
void swap(tuple& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark The expression inside \tcode{noexcept} is equivalent to the logical
\textsc{and} of the following expressions:

\begin{codeblock}
noexcept(swap(declval<@$T_i$@&>>(), declval<@$T_i$@&>()))
\end{codeblock}

where $T_i$ is the $i^{th}$ type in \tcode{Types}.

\pnum
\requires
Each element in \tcode{*this} shall be swappable with~(\ref{swappable.requirements})
the corresponding element in \tcode{rhs}.

\pnum
\effects Calls \tcode{swap} for each element in \tcode{*this} and its
corresponding element in \tcode{rhs}.

\pnum
\throws Nothing unless one of the element-wise \tcode{swap} calls throws an exception.
\end{itemdescr}

\rSec3[tuple.creation]{Tuple creation functions}

\pnum
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...(TTypes)}
in order and let $T_i$ be the $i^{th}$ type in a template parameter pack named \tcode{TTypes};
let $j$ be in the range \range{0}{sizeof...(UTypes)} in order and $U_j$ be the $j^{th}$ type
in a template parameter pack named \tcode{UTypes}, where indexing is zero-based.

\indexlibrary{\idxcode{make_tuple}}%
\indexlibrary{\idxcode{tuple}!\idxcode{make_tuple}}%
\begin{itemdecl}
template<class... Types>
  constexpr tuple<@\textit{VTypes}@...> make_tuple(Types&&... t);
\end{itemdecl}

\begin{itemdescr} \pnum Let \tcode{$U_i$} be \tcode{decay_t<$T_i$>} for each
$T_i$ in \tcode{Types}. Then each $V_i$ in \tcode{VTypes} is
\tcode{X\&} if $U_i$ equals \tcode{reference_wrapper<X>}, otherwise
$V_i$ is $U_i$.

\pnum
\returns \tcode{tuple<VTypes...>(std::forward<Types>(t)...)}.

\pnum
\enterexample

\begin{codeblock}
int i; float j;
make_tuple(1, ref(i), cref(j))
\end{codeblock}

creates a tuple of type

\begin{codeblock}
tuple<int, int&, const float&>
\end{codeblock}

\exitexample

\end{itemdescr}

\indexlibrary{\idxcode{forward_as_tuple}}%
\indexlibrary{\idxcode{tuple}!\idxcode{forward_as_tuple}}%
\begin{itemdecl}
template<class... Types>
  constexpr tuple<Types&&...> forward_as_tuple(Types&&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a tuple of references to the arguments in \tcode{t} suitable
for forwarding as arguments to a function. Because the result may contain references
to temporary variables, a program shall ensure that the return value of this
function does not outlive any of its arguments. (e.g., the program should typically
not store the result in a named variable).

\pnum
\returns \tcode{tuple<Types\&\&...>(std::forward<Types>(t)...)}
\end{itemdescr}

\indexlibrary{\idxcode{tie}}%
\indexlibrary{\idxcode{ignore}}%
\indexlibrary{\idxcode{tuple}!\idxcode{tie}}%
\begin{itemdecl}
template<class... Types>
  constexpr tuple<Types&...> tie(Types&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  \tcode{tuple<Types\&...>(t...)}.  When an
argument in \tcode{t} is \tcode{ignore}, assigning
any value to the corresponding tuple element has no effect.

\pnum
\enterexample
\tcode{tie} functions allow one to create tuples that unpack
tuples into variables. \tcode{ignore} can be used for elements that
are not needed:
\begin{codeblock}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \tcode{i == 42}, \tcode{s == "C++"}
\end{codeblock}
\exitexample
\end{itemdescr}

\indexlibrary{\idxcode{tuple_cat}}
\begin{itemdecl}
template <class... Tuples>
  constexpr tuple<@\textit{CTypes}@...> tuple_cat(Tuples&&... tpls);
\end{itemdecl}

\begin{itemdescr}
\pnum
In the following paragraphs, let $T_i$ be the $i^{th}$ type in \tcode{Tuples},
$U_i$ be \tcode{remove_reference_t<Ti>}, and $tp_i$ be the $i^{th}$
parameter in the function parameter pack \tcode{tpls}, where all indexing is
zero-based.

\pnum
\requires For all $i$, $U_i$ shall be the type
$\cv_i$ \tcode{tuple<$Args_i...$>}, where $\cv_i$ is the (possibly empty) $i^{th}$
cv-qualifier-seq and $Args_i$ is the parameter pack representing the element
types in $U_i$. Let ${A_{ik}}$ be the ${k_i}^{th}$ type in $Args_i$. For all
$A_{ik}$ the following requirements shall be satisfied: If $T_i$ is
deduced as an lvalue reference type, then
\tcode{is_constructible<$A_{ik}$, $cv_i$ $A_{ik}$\&>::value == true}, otherwise
\tcode{is_constructible<$A_{ik}$, $cv_i A_{ik}$\&\&>::value == true}.

\pnum
\remarks The types in \tcode{\textit{Ctypes}} shall be equal to the ordered
sequence of the extended types
\tcode{$Args_0$..., $Args_1$...,} ... \tcode{$Args_{n-1}$...}, where $n$ is
equal to \tcode{sizeof...(Tuples)}. Let \tcode{$e_i$...} be the $i^{th}$
ordered sequence of tuple elements of the resulting \tcode{tuple} object
corresponding to the type sequence $Args_i$.

\pnum
\returns A \tcode{tuple} object constructed by initializing the ${k_i}^{th}$
type element $e_{ik}$ in \tcode{$e_i$...} with\\
\tcode{get<$k_i$>(std::forward<$T_i$>($tp_i$))} for each valid $k_i$ and
each group $e_i$ in order.

\pnum
\realnote An implementation may support additional types in the parameter
pack \tcode{Tuples} that support the \tcode{tuple}-like protocol, such as
\tcode{pair} and \tcode{array}.
\end{itemdescr}

\rSec3[tuple.helper]{Tuple helper classes}

\indexlibrary{\idxcode{tuple_size}!in~general}%
\begin{itemdecl}
template <class T> struct tuple_size;
\end{itemdecl}

\begin{itemdescr}
\remarks All specializations of \tcode{tuple_size<T>} shall meet the
\tcode{UnaryTypeTrait} requirements~(\ref{meta.rqmts}) with a
\tcode{BaseCharacteristic} of \tcode{integral_constant<size_t, N>}
for some \tcode{N}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template <class... Types>
class tuple_size<tuple<Types...> >
  : public integral_constant<size_t, sizeof...(Types)> { };
\end{itemdecl}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
template <size_t I, class... Types>
class tuple_element<I, tuple<Types...> > {
public:
  typedef TI type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\ctype \tcode{TI} is the
type of the \tcode{I}th element of \tcode{Types},
where indexing is zero-based.
\end{itemdescr}

\begin{itemdecl}
template <class T> class tuple_size<const T>;
template <class T> class tuple_size<volatile T>;
template <class T> class tuple_size<const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \term{TS} denote \tcode{tuple_size<T>} of the \cv-unqualified type \tcode{T}. Then each
of the three templates shall meet the \tcode{UnaryTypeTrait} requirements~(\ref{meta.rqmts})
with a \tcode{BaseCharacteristic} of
\begin{codeblock}
integral_constant<size_t, TS::value>
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <size_t I, class T> class tuple_element<I, const T>;
template <size_t I, class T> class tuple_element<I, volatile T>;
template <size_t I, class T> class tuple_element<I, const volatile T>;
\end{itemdecl}

\begin{itemdescr}
Let \term{TE} denote \tcode{tuple_element<I, T>} of the \cv-unqualified type \tcode{T}. Then
each of the three templates shall meet the \tcode{TransformationTrait}
requirements~(\ref{meta.rqmts}) with a member typedef \tcode{type} that names the following
type:

\begin{itemize}
\item
for the first specialization, \tcode{add_const_t<\term{TE}::type>},

\item
for the second specialization, \tcode{add_volatile_t<\term{TE}::type>}, and

\item
for the third specialization, \tcode{add_cv_t<\term{TE}::type>}.

\end{itemize}

\end{itemdescr}

\rSec3[tuple.elem]{Element access}

\indexlibrary{\idxcode{tuple}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{tuple}}%
\begin{itemdecl}
template <size_t I, class... Types>
  constexpr tuple_element_t<I, tuple<Types...> >& get(tuple<Types...>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\returns  A reference to the \tcode{I}th element of \tcode{t}, where
indexing is zero-based.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{tuple}}%
\begin{itemdecl}
template <size_t I, class... Types>
  constexpr tuple_element_t<I, tuple<Types...> >&& get(tuple<Types...>&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{return std::forward<typename tuple_element<I, tuple<Types...> >}\\
\tcode{::type\&\&>(get<I>(t));}

\pnum
\realnote if a \tcode{T} in \tcode{Types} is some reference type \tcode{X\&}, the return
type is \tcode{X\&}, not \tcode{X\&\&}. However, if the element type is a non-reference type
\tcode{T}, the return type is \tcode{T\&\&}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{tuple}}%
\begin{itemdecl}
template <size_t I, class... Types>
  constexpr tuple_element_t<I, tuple<Types...> > const& get(const tuple<Types...>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\returns  A const reference to the \tcode{I}th element of \tcode{t}, where
indexing is zero-based.

\pnum
\enternote Constness is shallow. If a \tcode{T}
in \tcode{Types} is some
reference type \tcode{X\&}, the return type is \tcode{X\&}, not \tcode{const X\&}.
However, if the element type is non-reference type \tcode{T}, the return
type is \tcode{const T\&}.
This is consistent with how constness is defined to work
for member variables of reference type. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{tuple}}%
\begin{itemdecl}
template <class T, class... Types>
  constexpr T& get(tuple<Types...>& t) noexcept;
template <class T, class... Types>
  constexpr T&& get(tuple<Types...>&& t) noexcept;
template <class T, class... Types>
  constexpr const T& get(const tuple<Types...>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The type \tcode{T} occurs exactly once in \tcode{Types...}.
Otherwise, the program is ill-formed.

\pnum
\returns A reference to the element of \tcode{t} corresponding to the type
\tcode{T} in \tcode{Types...}.

\pnum
\enterexample
\begin{codeblock}
  const tuple<int, const int, double, double> t(1, 2, 3.4, 5.6);
  const int &i1 = get<int>(t);        // OK. Not ambiguous. i1 == 1
  const int &i2 = get<const int>(t);  // OK. Not ambiguous. i2 == 2
  const double &d = get<double>(t);   // ERROR. ill-formed
\end{codeblock}
\exitexample
\end{itemdescr}

\pnum
\enternote The reason \tcode{get} is a
nonmember function is that if this functionality had been
provided as a member function, code where the type
depended on a template parameter would have required using
the \tcode{template} keyword. \exitnote

\rSec3[tuple.rel]{Relational operators}

\indexlibrary{\idxcode{tuple}!\idxcode{operator==}}%
\indexlibrary{\idxcode{operator==}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires  For all \tcode{i},
where \tcode{0 <= i} and
\tcode{i < sizeof...(TTypes)}, \tcode{get<i>(t) == get<i>(u)} is a valid expression
returning a type that is convertible to \tcode{bool}.
\tcode{sizeof...(TTypes)} \tcode{==}
\tcode{sizeof...(UTypes)}.

\pnum
\returns  \tcode{true} if \tcode{get<i>(t) == get<i>(u)} for all
\tcode{i}, otherwise \tcode{false}.
For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f} returns \tcode{true}.

\pnum
\effects  The elementary comparisons are performed in order from the
zeroth index upwards.  No comparisons or element accesses are
performed after the first equality comparison that evaluates to
\tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator<}}%
\indexlibrary{\idxcode{operator<}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator<(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires  For all \tcode{i},
where \tcode{0 <= i} and
\tcode{i < sizeof...(TTypes)}, \tcode{get<i>(t) < get<i>(u)}
and \tcode{get<i>(u) < get<i>(t)}
are valid expressions returning types that are
convertible to \tcode{bool}.
\tcode{sizeof...(TTypes)} \tcode{==}
\tcode{sizeof...(UTypes)}.

\pnum\returns  The result of a lexicographical comparison
between \tcode{t} and \tcode{u}. The result is defined
as: \tcode{(bool)(get<0>(t) < get<0>(u)) ||
(!(bool)(get<0>(u) < get<0>(t)) \&\& t$_{\mathrm{tail}}$ <
u$_{\mathrm{tail}}$)}, where \tcode{r$_{\mathrm{tail}}$} for some
tuple \tcode{r} is a tuple containing all but the first element
of \tcode{r}.  For any two zero-length tuples \tcode{e}
and \tcode{f}, \tcode{e < f} returns \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator"!=}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator!=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{!(t == u)}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator>}}%
\indexlibrary{\idxcode{operator>}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{u < t}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator<=}}%
\indexlibrary{\idxcode{operator<=}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator<=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{!(u < t)}
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!\idxcode{operator>=}}%
\indexlibrary{\idxcode{operator>=}!\idxcode{tuple}}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator>=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!(t < u)}
\end{itemdescr}

\pnum \enternote The above definitions for comparison operators
do not require \tcode{t$_{\mathrm{tail}}$}
(or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It may not
even be possible, as \tcode{t} and \tcode{u} are not required to be copy
constructible. Also, all comparison operators are short circuited;
they do not perform element accesses beyond what is required to determine the
result of the comparison. \exitnote

\rSec3[tuple.traits]{Tuple traits}

\indexlibrary{\idxcode{uses_allocator<tuple>}}
\begin{itemdecl}
template <class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc> : true_type { };
\end{itemdecl}

\begin{itemdescr}
\requires \tcode{Alloc} shall be an \tcode{Allocator}~(\ref{allocator.requirements}).

\pnum
\enternote Specialization of this trait informs other library components that
\tcode{tuple} can be constructed with an allocator, even though it does not have
a nested \tcode{allocator_type}. \exitnote
\end{itemdescr}

\rSec3[tuple.special]{Tuple specialized algorithms}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template <class... Types>
  void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
noexcept(x.swap(y))
\end{codeblock}

\pnum
\effects \tcode{x.swap(y)}
\end{itemdescr}

\rSec1[intseq]{Compile-time integer sequences}

\rSec2[intseq.general]{In general}

\pnum
The library provides a class template that can represent an integer sequence.
When used as an argument to a function template the parameter pack defining the
sequence can be deduced and used in a pack expansion.

\pnum
\enterexample

\begin{codeblock}
template<class F, class Tuple, std::size_t... I>
  decltype(auto) apply_impl(F&& f, Tuple&& t, index_sequence<I...>) {
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);
  }

template<class F, class Tuple>
  decltype(auto) apply(F&& f, Tuple&& t) {
    using Indices = make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>;
    return apply_impl(std::forward<F>(f), std::forward<Tuple>(t), Indices());
  }
\end{codeblock}

\exitexample
\enternote
The \tcode{index_sequence} alias template is provided for the common case of
an integer sequence of type \tcode{size_t}.
\exitnote

\rSec2[intseq.intseq]{Class template \tcode{integer_sequence}}

\indexlibrary{\idxcode{integer_sequence}}%
\begin{codeblock}
namespace std {
  template<class T, T... I>
  struct integer_sequence {
    typedef T value_type;
    static constexpr size_t size() noexcept { return sizeof...(I); }
  };
}
\end{codeblock}

\pnum
\tcode{T} shall be an integer type.

\rSec2[intseq.make]{Alias template \tcode{make_integer_sequence}}

\indexlibrary{\idxcode{make_integer_sequence}}%
\begin{itemdecl}
template<class T, T N>
  using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{N} is negative the program is ill-formed. The alias template
\tcode{make_integer_sequence} denotes a specialization of
\tcode{integer_sequence} with \tcode{N} template non-type arguments.
The type \tcode{make_integer_sequence<T, N>} denotes the type
\tcode{integer_sequence<T, 0, 1, ..., N-1>}.
\enternote \tcode{make_integer_sequence<int, 0>} denotes the type
\tcode{integer_sequence<int>} \exitnote
\end{itemdescr}

\rSec1[template.bitset]{Class template \tcode{bitset}}%
\indexlibrary{\idxcode{bitset}}

\synopsis{Header \tcode{<bitset>} synopsis}%
\indexlibrary{\idxhdr{bitset}}

\begin{codeblock}
#include <string>
#include <iosfwd>               // for \tcode{istream}, \tcode{ostream}
namespace std {
  template <size_t N> class bitset;

  // \ref{bitset.operators} bitset operators:
  template <size_t N>
    bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;
  template <size_t N>
    bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;
  template <size_t N>
    bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
  template <class charT, class traits, size_t N>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
  template <class charT, class traits, size_t N>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
}
\end{codeblock}

\pnum
The header
\tcode{<bitset>}
defines a
class template
and several related functions for representing
and manipulating fixed-size sequences of bits.

\begin{codeblock}
namespace std {
  template<size_t N> class bitset {
  public:
    // bit reference:
    class reference {
      friend class bitset;
      reference() noexcept;
    public:
     ~reference() noexcept;
      reference& operator=(bool x) noexcept;             // for \tcode{b[i] = x;}
      reference& operator=(const reference&) noexcept;   // for \tcode{b[i] = b[j];}
      bool operator~() const noexcept;                   // flips the bit
      operator bool() const noexcept;                    // for \tcode{x = b[i];}
      reference& flip() noexcept;                        // for \tcode{b[i].flip();}
    };

    // \ref{bitset.cons} constructors:
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template<class charT, class traits, class Allocator>
      explicit bitset(
        const basic_string<charT,traits,Allocator>& str,
        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
        typename basic_string<charT,traits,Allocator>::size_type n =
          basic_string<charT,traits,Allocator>::npos,
          charT zero = charT('0'), charT one = charT('1'));
    template <class charT>
      explicit bitset(
        const charT* str,
        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
        charT zero = charT('0'), charT one = charT('1'));

    // \ref{bitset.members} bitset operations:
    bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator<<=(size_t pos) noexcept;
    bitset<N>& operator>>=(size_t pos) noexcept;
    bitset<N>& set() noexcept;
    bitset<N>& set(size_t pos, bool val = true);
    bitset<N>& reset() noexcept;
    bitset<N>& reset(size_t pos);
    bitset<N>  operator~() const noexcept;
    bitset<N>& flip() noexcept;
    bitset<N>& flip(size_t pos);

    // element access:
    constexpr bool operator[](size_t pos) const;       // for \tcode{b[i];}
    reference operator[](size_t pos);                  // for \tcode{b[i];}

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class charT = char,
        class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
      basic_string<charT, traits, Allocator>
      to_string(charT zero = charT('0'), charT one = charT('1')) const;
    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset<N>& rhs) const noexcept;
    bool operator!=(const bitset<N>& rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset<N> operator<<(size_t pos) const noexcept;
    bitset<N> operator>>(size_t pos) const noexcept;
  };

  // \ref{bitset.hash} hash support
  template <class T> struct hash;
  template <size_t N> struct hash<bitset<N> >;
}
\end{codeblock}

\pnum
The class template
\tcode{bitset<N>}%
describes an object that can store a sequence consisting of a fixed number of
bits, \tcode{N}.

\pnum
Each bit represents either the value zero (reset) or one (set).
To
\term{toggle}
a bit is to change the value zero to one, or the value one to
zero.
Each bit has a non-negative position \tcode{pos}.
When converting
between an object of class
\tcode{bitset<N>}
and a value of some
integral type, bit position \tcode{pos} corresponds to the
\term{bit value}
\tcode{1 \shl pos}.
The integral value corresponding to two
or more bits is the sum of their bit values.

\pnum
The functions described in this subclause can report three kinds of
errors, each associated with a distinct exception:

\begin{itemize}
\item
an
\term{invalid-argument}
error is associated with exceptions of type
\tcode{invalid_argument}~(\ref{invalid.argument});
\indexlibrary{\idxcode{invalid_argument}}%
\item
an
\term{out-of-range}
error is associated with exceptions of type
\tcode{out_of_range}~(\ref{out.of.range});
\indexlibrary{\idxcode{out_of_range}}%
\item
an
\term{overflow}
error is associated with exceptions of type
\tcode{overflow_error}~(\ref{overflow.error}).
\indexlibrary{\idxcode{overflow_error}}%
\end{itemize}

\rSec2[bitset.cons]{\tcode{bitset} constructors}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}%
\begin{itemdecl}
constexpr bitset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing all bits to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\begin{itemdecl}
constexpr bitset(unsigned long long val) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit positions to the corresponding bit
values in \tcode{val}.
\tcode{M} is the smaller of \tcode{N} and the number of bits in the value
representation~(\ref{basic.types}) of \tcode{unsigned long long}.
If \tcode{M < N}, the remaining bit positions are initialized to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\begin{itemdecl}
template <class charT, class traits, class Allocator>
explicit
bitset(const basic_string<charT, traits, Allocator>& str,
       typename basic_string<charT, traits, Allocator>::size_type pos = 0,
       typename basic_string<charT, traits, Allocator>::size_type n =
         basic_string<charT, traits, Allocator>::npos,
         charT zero = charT('0'), charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= str.size()}.

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Determines the effective length
\tcode{rlen} of the initializing string as the smaller of
\tcode{n} and
\tcode{str.size() - pos}.

The function then throws%
\indexlibrary{\idxcode{invalid_argument}}
\tcode{invalid_argument}
if any of the \tcode{rlen}
characters in \tcode{str} beginning at position \tcode{pos} is
other than \tcode{zero} or \tcode{one}. The function uses \tcode{traits::eq()}
to compare the character values.

Otherwise, the function constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit
positions to values determined from the corresponding characters in the string
\tcode{str}.
\tcode{M} is the smaller of \tcode{N} and \tcode{rlen}.

\pnum
An element of the constructed object has value zero if the
corresponding character in \tcode{str}, beginning at position
\tcode{pos}, is
\tcode{zero}.
Otherwise, the element has the value one.
Character position \tcode{pos + M - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit positions.

\pnum
If \tcode{M < N}, remaining bit positions are initialized to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\begin{itemdecl}
template <class charT>
  explicit bitset(
    const charT* str,
    typename basic_string<charT>::size_type n = basic_string<charT>::npos,
    charT zero = charT('0'), charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{bitset<N>} as if by

\begin{codeblock}
bitset(
  n == basic_string<charT>::npos
    ? basic_string<charT>(str)
    : basic_string<charT>(str, n),
  0, n, zero, one)
\end{codeblock}

\end{itemdescr}


\rSec2[bitset.members]{\tcode{bitset} members}

\indexlibrary{\idxcode{operator\&=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Clears each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is clear, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"|=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\^{}=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{operator<<=@\tcode{operator\shl=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator<<=(size_t pos) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{I < pos}, the new value is zero;
\item
If \tcode{I >= pos}, the new value is the previous
value of the bit at position \tcode{I - pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{operator>>=@\tcode{operator\shr=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator>>=(size_t pos) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{pos >= N - I}, the new value is zero;
\item
If \tcode{pos < N - I}, the new value is the previous value of the bit at position \tcode{I + pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{set}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{set}}
\begin{itemdecl}
bitset<N>& set() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{set}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{set}}
\begin{itemdecl}
bitset<N>& set(size_t pos, bool val = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Stores a new value in the bit at position \tcode{pos} in
\tcode{*this}.
If \tcode{val} is nonzero, the stored value is one, otherwise it is zero.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{reset}}
\begin{itemdecl}
bitset<N>& reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Resets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{reset}}
\begin{itemdecl}
bitset<N>& reset(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.
\indexlibrary{\idxcode{out_of_range}}%

\pnum
\effects
Resets the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\~{}}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object \tcode{x} of class
\tcode{bitset<N>}
and initializes it with
\tcode{*this}.

\pnum
\returns
\tcode{x.flip()}.
\end{itemdescr}

\indexlibrary{\idxcode{flip}!\tcode{bitset}}%
\begin{itemdecl}
bitset<N>& flip() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{flip}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{flip}}
\begin{itemdecl}
bitset<N>& flip(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Toggles the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{to_ulong}!\idxcode{bitset}}%
\begin{itemdecl}
unsigned long to_ulong() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{overflow_error}%
\indexlibrary{\idxcode{overflow_error}}
if the integral value \tcode{x} corresponding to the bits in
\tcode{*this}
cannot be represented as type
\tcode{unsigned long}.

\pnum
\returns
\tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{to_ullong}!\idxcode{bitset}}%
\begin{itemdecl}
unsigned long long to_ullong() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\indexlibrary{\idxcode{overflow_error}}%
\throws
\tcode{overflow_error}
if the integral value \tcode{x} corresponding to the bits in
\tcode{*this}
cannot be represented as type
\tcode{unsigned long long}.

\pnum
\returns
\tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{to_string}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT = char,
    class traits = char_traits<charT>,
    class Allocator = allocator<charT> >
  basic_string<charT, traits, Allocator>
  to_string(charT zero = charT('0'), charT one = charT('1')) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a string object of the appropriate type
and initializes it to a string of length \tcode{N} characters.
Each character is determined by the value of its corresponding bit position in
\tcode{*this}.
Character position \tcode{N - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit
positions.
Bit value zero becomes the character \tcode{zero},
bit value one becomes the character
\tcode{one}.

\pnum
\returns
The created object.
\end{itemdescr}

\indexlibrary{\idxcode{count}!\idxcode{bitset}}%
\begin{itemdecl}
size_t count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A count of the number of bits set in
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{bitset}}%
\begin{itemdecl}
constexpr size_t size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{N}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{bitset}}%
\begin{itemdecl}
bool operator==(const bitset<N>& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if the value of each bit in
\tcode{*this}
equals the value of the corresponding bit in \tcode{rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{bitset}}%
\begin{itemdecl}
bool operator!=(const bitset<N>& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if
\tcode{!(*this == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{test}!\idxcode{bitset}}%
\begin{itemdecl}
bool test(size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\returns
\tcode{true}
if the bit at position \tcode{pos}
in
\tcode{*this}
has the value one.
\end{itemdescr}

\indexlibrary{\idxcode{all}!\idxcode{bitset}}%
\begin{itemdecl}
bool all() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() == size()}
\end{itemdescr}

\indexlibrary{\idxcode{any}!\idxcode{bitset}}%
\begin{itemdecl}
bool any() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() != 0}
\end{itemdescr}

\indexlibrary{\idxcode{none}!\idxcode{bitset}}%
\begin{itemdecl}
bool none() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() == 0}
\end{itemdescr}

\indexlibrary{operator<<@\tcode{operator\shl}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator<<(size_t pos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) \shl= pos}.
\end{itemdescr}

\indexlibrary{operator>>@\tcode{operator\shr}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator>>(size_t pos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) \shr= pos}.
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{operator[]}}
\begin{itemdecl}
constexpr bool operator[](size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} shall be valid.

\pnum
\returns
\tcode{true} if the bit at position \tcode{pos} in \tcode{*this} has the value
one, otherwise \tcode{false}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{operator[]}}
\begin{itemdecl}
bitset<N>::reference operator[](size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} shall be valid.

\pnum
\returns
An object of type
\tcode{bitset<N>::reference}
such that
\tcode{(*this)[pos] == this->test(pos)},
and such that
\tcode{(*this)[pos] = val}
is equivalent to
\tcode{this->set(pos, val)}.

\pnum
\throws Nothing.

\pnum
\remark For the purpose of determining the presence of a data
race~(\ref{intro.multithread}), any access or update through the resulting
reference potentially accesses or modifies, respectively, the entire
underlying bitset.
\end{itemdescr}

\rSec2[bitset.hash]{\tcode{bitset} hash support}

\indexlibrary{\idxcode{hash_code}}%
\begin{itemdecl}
template <size_t N> struct hash<bitset<N> >;
\end{itemdecl}

\begin{itemdescr}
\pnum The template specialization shall meet the requirements of class template
\tcode{hash}~(\ref{unord.hash}).
\end{itemdescr}


\rSec2[bitset.operators]{\tcode{bitset} operators}

\indexlibrary{\idxcode{operator\&}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \&= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"|}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) |= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\^{}}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \^{}= rhs}.
\end{itemdescr}

\indexlibrary{operator>>@\tcode{operator\shr}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT, class traits, size_t N>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
A formatted input function~(\ref{istream.formatted}).

\pnum
\effects
Extracts up to \tcode{N} characters from \tcode{is}.
Stores these characters in a temporary object \tcode{str} of type
\tcode{basic_string<charT, traits>},
then evaluates the expression
\tcode{x = bitset<N>(str)}.
Characters are extracted and stored until any of the following occurs:

\begin{itemize}
\item
\tcode{N} characters have been extracted and stored;
\item
end-of-file occurs on the input sequence;%
\indextext{end-of-file}
\item
the next input character is neither
\tcode{is.widen('0')}
nor
\tcode{is.widen('1')}
(in which case the input character is not extracted).
\end{itemize}

\pnum
If no characters are stored in \tcode{str}, calls
\tcode{is.setstate(ios_base::failbit)}
(which may throw
\tcode{ios_base::failure}~(\ref{iostate.flags})).

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrary{operator<<@\tcode{operator\shl}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT, class traits, size_t N>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
os @\shl@ x.template to_string<charT,traits,allocator<charT> >(
  use_facet<ctype<charT> >(os.getloc()).widen('0'),
  use_facet<ctype<charT> >(os.getloc()).widen('1'))
\end{codeblock}
(see~\ref{ostream.formatted}).
\end{itemdescr}

\rSec1[memory]{Memory}

\rSec2[memory.general]{In general}

\pnum
This subclause describes the contents of the header
\tcode{<memory>}~(\ref{memory.syn}) and some
of the contents of the C headers \tcode{<cstdlib>} and
\tcode{<cstring>}~(\ref{c.malloc}).

\rSec2[memory.syn]{Header \tcode{<memory>} synopsis}

\pnum
The header \tcode{<memory>} defines several types and function templates that
describe properties of pointers and pointer-like types, manage memory
for containers and other template types, and construct multiple objects in
uninitialized memory
buffers~(\ref{pointer.traits}--\ref{specialized.algorithms}).
The header also defines the templates
\tcode{unique_ptr}, \tcode{shared_ptr}, \tcode{weak_ptr}, and various function
templates that operate on objects of these types~(\ref{smartptr}).

\indexlibrary{\idxhdr{memory}}%
\begin{codeblock}
namespace std {
  // \ref{pointer.traits}, pointer traits
  template <class Ptr> struct pointer_traits;
  template <class T> struct pointer_traits<T*>;

  // \ref{util.dynamic.safety}, pointer safety
  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template <class T> T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;

  // \ref{ptr.align}, pointer alignment function
  void* align(std::size_t alignment, std::size_t size,
    void*& ptr, std::size_t& space);

  // \ref{allocator.tag}, allocator argument tag
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};

  // \ref{allocator.uses}, \tcode{uses_allocator}
  template <class T, class Alloc> struct uses_allocator;

  // \ref{allocator.traits}, allocator traits
  template <class Alloc> struct allocator_traits;

  // \ref{default.allocator}, the default allocator:
  template <class T> class allocator;
  template <> class allocator<void>;
  template <class T, class U>
    bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
  template <class T, class U>
    bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

  // \ref{storage.iterator}, raw storage iterator:
  template <class OutputIterator, class T> class raw_storage_iterator;

  // \ref{temporary.buffer}, temporary buffers:
  template <class T>
    pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
  template <class T>
    void return_temporary_buffer(T* p);

  // \ref{specialized.algorithms}, specialized algorithms:
  template <class T> T* addressof(T& r) noexcept;
  template <class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template <class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template <class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                            const T& x);
  template <class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

  // \ref{unique.ptr} class template unique_ptr:
  template <class T> struct default_delete;
  template <class T> struct default_delete<T[]>;
  template <class T, class D = default_delete<T>> class unique_ptr;
  template <class T, class D> class unique_ptr<T[], D>;

  template <class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
  template <class T> unique_ptr<T> make_unique(size_t n);
  template <class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;

  template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

  template <class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template <class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template <class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template <class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template <class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template <class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

  template <class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

  // \ref{util.smartptr.weakptr}, class bad_weak_ptr:
  class bad_weak_ptr;

  // \ref{util.smartptr.shared}, class template shared_ptr:
  template<class T> class shared_ptr;

  // \ref{util.smartptr.shared.create}, shared_ptr creation
  template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
  template<class T, class A, class... Args>
    shared_ptr<T> allocate_shared(const A& a, Args&&... args);

  // \ref{util.smartptr.shared.cmp}, shared_ptr comparisons:
  template<class T, class U>
    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
  template<class T, class U>
    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
  template<class T, class U>
    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
  template<class T, class U>
    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
  template<class T, class U>
    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
  template<class T, class U>
    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

  template <class T>
    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
  template <class T>
    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
  template <class T>
    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
  template <class T>
    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
  template <class T>
    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
  template <class T>
    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template <class T>
    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

  // \ref{util.smartptr.shared.spec}, shared_ptr specialized algorithms:
  template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

  // \ref{util.smartptr.shared.cast}, shared_ptr casts:
  template<class T, class U>
    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
  template<class T, class U>
    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
  template<class T, class U>
    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;

  // \ref{util.smartptr.getdeleter}, shared_ptr get_deleter:
  template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;

  // \ref{util.smartptr.shared.io}, shared_ptr I/O:
  template<class E, class T, class Y>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

  // \ref{util.smartptr.weak}, class template weak_ptr:
  template<class T> class weak_ptr;

  // \ref{util.smartptr.weak.spec}, weak_ptr specialized algorithms:
  template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

  // \ref{util.smartptr.ownerless}, class template owner_less:
  template<class T> class owner_less;

  // \ref{util.smartptr.enab}, class template enable_shared_from_this:
  template<class T> class enable_shared_from_this;

  // \ref{util.smartptr.shared.atomic}, shared_ptr atomic access:
  template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);

  template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
  template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

  template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,
                                           memory_order mo);

  template<class T>
    bool atomic_compare_exchange_weak(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_strong(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
  template<class T>
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);

  // \ref{util.smartptr.hash} hash support
  template <class T> struct hash;
  template <class T, class D> struct hash<unique_ptr<T, D> >;
  template <class T> struct hash<shared_ptr<T> >;

  // \ref{depr.auto.ptr}, auto_ptr (deprecated)
  template <class X> class auto_ptr;
}
\end{codeblock}

\rSec2[pointer.traits]{Pointer traits}

\pnum
The class template \tcode{pointer_traits} supplies a uniform interface to certain
attributes of pointer-like types.

\indexlibrary{\idxcode{pointer_traits}}%
\begin{codeblock}
namespace std {
  template <class Ptr> struct pointer_traits {
    typedef Ptr       pointer;
    typedef @\seebelow@ element_type;
    typedef @\seebelow@ difference_type;

    template <class U> using rebind = @\seebelow@;

    static pointer pointer_to(@\seebelow@ r);
  };

  template <class T> struct pointer_traits<T*> {
    typedef T*        pointer;
    typedef T         element_type;
    typedef ptrdiff_t difference_type;

    template <class U> using rebind = U*;

    static pointer pointer_to(@\seebelow@ r) noexcept;
  };
}
\end{codeblock}

\rSec3[pointer.traits.types]{Pointer traits member types}

\indexlibrary{\idxcode{pointer_traits}!\idxcode{element_type}}%
\indexlibrary{\idxcode{element_type}!\idxcode{pointer_traits}}%
\begin{itemdecl}
typedef @\seebelow@ element_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Ptr::element_type} if such a type exists; otherwise, \tcode{T} if
\tcode{Ptr} is a class template instantiation of the form \tcode{SomePointer<T, Args>},
where \tcode{Args} is zero or more type arguments; otherwise, the specialization is
ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{pointer_traits}!\idxcode{difference_type}}%
\indexlibrary{\idxcode{difference_type}!\idxcode{pointer_traits}}%
\begin{itemdecl}
typedef @\seebelow@ difference_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Ptr::difference_type} if such a type exists; otherwise,
\tcode{std::ptrdiff_t}.
\end{itemdescr}

\indexlibrary{\idxcode{pointer_traits}!\idxcode{rebind}}%
\indexlibrary{\idxcode{rebind}!\idxcode{pointer_traits}}%
\begin{itemdecl}
template <class U> using rebind = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\templalias \tcode{Ptr::rebind<U>} if such a type exists; otherwise,
\tcode{SomePointer<U, Args>} if
\tcode{Ptr} is a class template instantiation of the form \tcode{SomePointer<T, Args>},
where \tcode{Args} is zero or more type arguments; otherwise, the instantiation of
\tcode{rebind} is ill-formed.
\end{itemdescr}

\rSec3[pointer.traits.functions]{Pointer traits member functions}

\indexlibrary{\idxcode{pointer_traits}!\idxcode{pointer_to}}%
\indexlibrary{\idxcode{pointer_to}!\idxcode{pointer_traits}}%
\begin{itemdecl}
static pointer pointer_traits::pointer_to(@\seebelow@ r);
static pointer pointer_traits<T*>::pointer_to(@\seebelow@ r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark If \tcode{element_type} is (possibly cv-qualified) \tcode{void}, the type of
\tcode{r} is unspecified; otherwise, it is \tcode{element_type\&}.

\pnum
\returns The first member function returns a pointer to \tcode{r}
obtained by calling \tcode{Ptr::pointer_to(r)} through which
indirection is valid; an instantiation of this function is
ill-formed if \tcode{Ptr} does not have a matching \tcode{pointer_to} static member
function. The second member function returns \tcode{std::addressof(r)}.
\end{itemdescr}

\rSec2[util.dynamic.safety]{Pointer safety}

\pnum
A complete object is \techterm{declared reachable} while the number of calls to
\tcode{declare_reachable} with an argument referencing the object exceeds the
number of calls to \tcode{undeclare_reachable} with an argument referencing the
object.

\indexlibrary{\idxcode{declare_reachable}}%
\begin{itemdecl}
void declare_reachable(void* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall be a safely-derived
pointer~(\ref{basic.stc.dynamic.safety}) or a null pointer value.

\pnum
\effects If \tcode{p} is not null, the complete object referenced by \tcode{p}
is subsequently declared reachable~(\ref{basic.stc.dynamic.safety}).

\pnum
\throws May throw \tcode{std::bad_alloc} if the system cannot allocate
additional memory that may be required to track objects declared reachable.
\end{itemdescr}

\indexlibrary{\idxcode{undeclare_reachable}}%
\begin{itemdecl}
template <class T> T* undeclare_reachable(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{p} is not null, the complete object referenced by \tcode{p}
shall have been previously declared reachable, and shall be
live~(\ref{basic.life}) from the time of the call until the last
\tcode{undeclare_reachable(p)} call on the object.

\pnum
\returns A safely derived copy of \tcode{p} which shall compare equal to \tcode{p}.

\pnum
\throws Nothing.

\pnum \enternote It is expected that calls to \tcode{declare_reachable(p)} will consume
a small amount of memory in addition to that occupied by the referenced object until the
matching call to \tcode{undeclare_reachable(p)} is encountered. Long running programs
should arrange that calls are matched. \exitnote \end{itemdescr}

\indexlibrary{\idxcode{declare_no_pointers}}%
\begin{itemdecl}
void declare_no_pointers(char* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires No bytes in the specified range
are currently registered with
\tcode{declare_no_pointers()}. If the specified range is in an allocated object,
then it must be entirely within a single allocated object. The object must be
live until the corresponding \tcode{undeclare_no_pointers()} call. \enternote In
a garbage-collecting implementation, the fact that a region in an object is
registered with \tcode{declare_no_pointers()} should not prevent the object from
being collected. \exitnote

\pnum
\effects The \tcode{n} bytes starting at \tcode{p} no longer contain
traceable pointer locations, independent of their type. Hence
indirection through a pointer located there is undefined if the object
it points to was created by global \tcode{operator new} and not
previously declared reachable. \enternote This may be used to inform a
garbage collector or leak detector that this region of memory need not
be traced. \exitnote

\pnum
\throws Nothing.

\pnum
\enternote Under some conditions implementations may need to allocate memory.
However, the request can be ignored if memory allocation fails. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{undeclare_no_pointers}}%
\begin{itemdecl}
void undeclare_no_pointers(char* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The same range must previously have been passed to
\tcode{declare_no_pointers()}.

\pnum
\effects Unregisters a range registered with \tcode{declare_no_pointers()} for
destruction. It must be called before the lifetime of the object ends.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{get_pointer_safety}}%
\begin{itemdecl}
pointer_safety get_pointer_safety() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{pointer_safety::strict} if the implementation has strict pointer
safety~(\ref{basic.stc.dynamic.safety}). It is implementation defined%
\indeximpldef{whether \tcode{get_pointer_safety} returns
\tcode{pointer_safety::\brk{}relaxed} or
\tcode{pointer_safety::preferred} if the implementation has relaxed pointer safety}
whether
\tcode{get_pointer_safety} returns \tcode{pointer_safety::relaxed} or
\tcode{pointer_safety::preferred} if the implementation has relaxed pointer
safety.\footnote{\tcode{pointer_safety::preferred} might be returned to indicate
that a leak detector is running so that the program can avoid spurious leak
reports.}
\end{itemdescr}


\rSec2[ptr.align]{Align}

\indexlibrary{\idxcode{align}}%
\begin{itemdecl}
void* align(std::size_t alignment, std::size_t size,
    void*& ptr, std::size_t& space);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If it is possible to fit \tcode{size} bytes
of storage aligned by \tcode{alignment} into the buffer pointed to by
\tcode{ptr} with length \tcode{space}, the function updates
\tcode{ptr} to point to the first possible address of such storage
and decreases \tcode{space} by the number of bytes used for alignment.
Otherwise, the function does nothing.

\pnum
\requires

\begin{itemize}
\item \tcode{alignment} shall be a fundamental alignment value or an
extended alignment value supported by the implementation in this context

\item \tcode{ptr} shall point to contiguous storage of at least
\tcode{space} bytes
\end{itemize}

\pnum
\returns A null pointer if the requested aligned buffer
would not fit into the available space, otherwise the adjusted value
of \tcode{ptr}.

\pnum
\enternote The function updates its \tcode{ptr}
and \tcode{space} arguments so that it can be called repeatedly
with possibly different \tcode{alignment} and \tcode{size}
arguments for the same buffer.  \exitnote
\end{itemdescr}

\rSec2[allocator.tag]{Allocator argument tag}

\indexlibrary{\idxcode{allocator_arg_t}}
\indexlibrary{\idxcode{allocator_arg}}
\begin{itemdecl}
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
\end{itemdecl}

\pnum
The \tcode{allocator_arg_t} struct is an empty structure type used as a unique type to
disambiguate constructor and function overloading. Specifically, several types (see
\tcode{tuple}~\ref{tuple}) have constructors with \tcode{allocator_arg_t} as the first
argument, immediately followed by an argument of a type that satisfies the
\tcode{Allocator} requirements~(\ref{allocator.requirements}).

\rSec2[allocator.uses]{\tcode{uses_allocator}}

\rSec3[allocator.uses.trait]{\tcode{uses_allocator} trait}

\indexlibrary{\idxcode{uses_allocator}}%
\begin{itemdecl}
template <class T, class Alloc> struct uses_allocator;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark automatically detects whether \tcode{T} has a nested \tcode{allocator_type} that
is convertible from \tcode{Alloc}. Meets the BinaryTypeTrait
requirements~(\ref{meta.rqmts}). The implementation shall provide a definition that is
derived from \tcode{true_type} if a type \tcode{T::allocator_type} exists and
\tcode{is_convertible<Alloc, T::allocator_type>::value != false}, otherwise it shall be
derived from \tcode{false_type}. A program may specialize this template to derive from
\tcode{true_type} for a user-defined type \tcode{T} that does not have a nested
\tcode{allocator_type} but nonetheless can be constructed with an allocator where
either:

\begin{itemize}
\item the first argument of a constructor has type \tcode{allocator_arg_t} and the
second argument has type \tcode{Alloc} or

\item the last argument of a constructor has type \tcode{Alloc}.
\end{itemize}
\end{itemdescr}

\rSec3[allocator.uses.construction]{uses-allocator construction}

\pnum
\defn{Uses-allocator construction} with allocator \tcode{Alloc} refers to the
construction of an object \tcode{obj} of type \tcode{T}, using constructor arguments
\tcode{v1, v2, ..., vN} of types \tcode{V1, V2, ..., VN}, respectively, and an allocator
\tcode{alloc} of type \tcode{Alloc}, according to the following rules:

\begin{itemize}
\item if \tcode{uses_allocator<T, Alloc>::value} is \tcode{false} and
\tcode{is_constructible<T, V1, V2, ..., VN>::value} is \tcode{true}, then \tcode{obj} is
initialized as \tcode{obj(v1, v2, ..., vN)};

\item otherwise, if \tcode{uses_allocator<T, Alloc>::value} is \tcode{true} and
\tcode{is_constructible<T, allocator_arg_t, Alloc,} \tcode{V1, V2, ..., VN>::value} is
\tcode{true}, then \tcode{obj} is initialized as \tcode{obj(allocator_arg, alloc, v1,
v2, ..., vN)};

\item otherwise, if \tcode{uses_allocator<T, Alloc>::value} is \tcode{true} and
\tcode{is_constructible<T, V1, V2, ..., VN, Alloc>::value} is \tcode{true}, then
\tcode{obj} is initialized as \tcode{obj(v1, v2, ..., vN, alloc)};

\item otherwise, the request for uses-allocator construction is ill-formed. \enternote
An error will result if \tcode{uses_allocator<T, Alloc>::value} is \tcode{true} but the
specific constructor does not take an allocator. This definition prevents a silent
failure to pass the allocator to an element. \exitnote
\end{itemize}

\rSec2[allocator.traits]{Allocator traits}

\pnum
The class template \tcode{allocator_traits} supplies a uniform interface to all
allocator types.
An allocator cannot be a non-class type, however, even if \tcode{allocator_traits}
supplies the entire required interface. \enternote Thus, it is always possible to create
a derived class from an allocator. \exitnote

\indexlibrary{\idxcode{allocator_traits}}%
\begin{codeblock}
namespace std {
  template <class Alloc> struct allocator_traits {
    typedef Alloc allocator_type;

    typedef typename Alloc::value_type value_type;

    typedef @\seebelow@ pointer;
    typedef @\seebelow@ const_pointer;
    typedef @\seebelow@ void_pointer;
    typedef @\seebelow@ const_void_pointer;

    typedef @\seebelow@ difference_type;
    typedef @\seebelow@ size_type;

    typedef @\seebelow@ propagate_on_container_copy_assignment;
    typedef @\seebelow@ propagate_on_container_move_assignment;
    typedef @\seebelow@ propagate_on_container_swap;

    template <class T> using rebind_alloc = @\seebelow@;
    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T> >;

    static pointer allocate(Alloc& a, size_type n);
    static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);

    static void deallocate(Alloc& a, pointer p, size_type n);

    template <class T, class... Args>
      static void construct(Alloc& a, T* p, Args&&... args);

    template <class T>
      static void destroy(Alloc& a, T* p);

    static size_type max_size(const Alloc& a) noexcept;

    static Alloc select_on_container_copy_construction(const Alloc& rhs);
  };
}
\end{codeblock}

\rSec3[allocator.traits.types]{Allocator traits member types}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{pointer}}%
\indexlibrary{\idxcode{pointer}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ pointer;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::pointer} if such a type exists; otherwise, \tcode{value_type*}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{const_pointer}}%
\indexlibrary{\idxcode{const_pointer}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ const_pointer;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::const_pointer} if such a type exists; otherwise,
\tcode{pointer_traits<pointer>::rebind<\brk{}const value_type>}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{void_pointer}}%
\indexlibrary{\idxcode{void_pointer}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ void_pointer;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::void_pointer} if such a type exists; otherwise,
\tcode{pointer_traits<pointer>::rebind<\brk{}void>}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{const_void_pointer}}%
\indexlibrary{\idxcode{const_void_pointer}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ const_void_pointer;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::const_void_pointer} if such a type exists; otherwise,
\tcode{pointer_traits<pointer>::\brk{}rebind<const void>}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{difference_type}}%
\indexlibrary{\idxcode{difference_type}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ difference_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::difference_type} if such a type exists; otherwise,
\tcode{pointer_traits<pointer>::dif\-ference_type}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{size_type}}%
\indexlibrary{\idxcode{size_type}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ size_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::size_type} if such a type exists; otherwise,
\tcode{make_unsigned_t<difference_type>}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{propagate_on_container_copy_assignment}}%
\indexlibrary{\idxcode{propagate_on_container_copy_assignment}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_copy_assignment;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_copy_assignment} if such a type
exists, otherwise \tcode{false_type}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{propagate_on_container_move_assignment}}%
\indexlibrary{\idxcode{propagate_on_container_move_assignment}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_move_assignment;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_move_assignment} if such a type
exists, otherwise \tcode{false_type}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{propagate_on_container_swap}}%
\indexlibrary{\idxcode{propagate_on_container_swap}!\idxcode{allocator_traits}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_swap;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_swap} if such a type exists, otherwise \tcode{false_type}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{rebind_alloc}}%
\indexlibrary{\idxcode{rebind_alloc}!\idxcode{allocator_traits}}%
\begin{itemdecl}
template <class T> using rebind_alloc = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\templalias \tcode{Alloc::rebind<T>::other} if such a type exists; otherwise,
\tcode{Alloc<T, Args>} if \tcode{Alloc} is a class template instantiation
of the form \tcode{Alloc<U, Args>}, where \tcode{Args} is zero or more type arguments;
otherwise, the instantiation of \tcode{rebind_alloc} is ill-formed.
\end{itemdescr}

\rSec3[allocator.traits.members]{Allocator traits static member functions}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{allocate}}%
\indexlibrary{\idxcode{allocate}!\idxcode{allocator_traits}}%
\begin{itemdecl}
static pointer allocate(Alloc& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.allocate(n)}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{allocate}}%
\indexlibrary{\idxcode{allocate}!\idxcode{allocator_traits}}%
\begin{itemdecl}
static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.allocate(n, hint)} if that expression is well-formed; otherwise, \tcode{a.allocate(n)}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{deallocate}}%
\indexlibrary{\idxcode{deallocate}!\idxcode{allocator_traits}}%
\begin{itemdecl}
static void deallocate(Alloc& a, pointer p, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{a.deallocate(p, n)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!constructor}%
\begin{itemdecl}
template <class T, class... Args>
  static void construct(Alloc& a, T* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{a.construct(p, std::forward<Args>(args)...)}
if that call is well-formed;
otherwise, invokes \tcode{::new (static_cast<void*>(p)) T(std::forward<Args>(args)...)}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!destructor}%
\begin{itemdecl}
template <class T>
  static void destroy(Alloc& a, T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{a.destroy(p)} if that call is well-formed; otherwise, invokes
\tcode{p->\~{}T()}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{max_size}}%
\indexlibrary{\idxcode{max_size}!\idxcode{allocator_traits}}%
\begin{itemdecl}
static size_type max_size(const Alloc& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.max_size()} if that expression is well-formed; otherwise,
\tcode{numeric_limits<size_type>::\brk{}max()}.
\end{itemdescr}

\indexlibrary{\idxcode{allocator_traits}!\idxcode{select_on_container_copy_construction}}%
\indexlibrary{\idxcode{select_on_container_copy_construction}!\idxcode{allocator_traits}}%
\begin{itemdecl}
static Alloc select_on_container_copy_construction(const Alloc& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.select_on_container_copy_construction()} if that expression is
well-formed; otherwise, \tcode{rhs}.
\end{itemdescr}

\rSec2[default.allocator]{The default allocator}

\indexlibrary{\idxcode{allocator}}%
\begin{codeblock}
namespace std {
  template <class T> class allocator;

  // specialize for \tcode{void}:
  template <> class allocator<void> {
  public:
    typedef void*   pointer;
    typedef const void* const_pointer;
    // reference-to-\tcode{void} members are impossible.
    typedef void  value_type;
    template <class U> struct rebind { typedef allocator<U> other; };
  };

  template <class T> class allocator {
   public:
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;
    typedef T*        pointer;
    typedef const T*  const_pointer;
    typedef T&        reference;
    typedef const T&  const_reference;
    typedef T         value_type;
    template <class U> struct rebind { typedef allocator<U> other; };
    typedef true_type propagate_on_container_move_assignment;
    
    allocator() noexcept;
    allocator(const allocator&) noexcept;
    template <class U> allocator(const allocator<U>&) noexcept;
   ~allocator();

    pointer address(reference x) const noexcept;
    const_pointer address(const_reference x) const noexcept;

    pointer allocate(
      size_type, allocator<void>::const_pointer hint = 0);
    void deallocate(pointer p, size_type n);
    size_type max_size() const noexcept;

    template<class U, class... Args>
      void construct(U* p, Args&&... args);
    template <class U>
      void destroy(U* p);
  };
}
\end{codeblock}

\rSec3[allocator.members]{\tcode{allocator} members}

\pnum
Except for the destructor, member functions of the default allocator shall not introduce
data races~(\ref{intro.multithread}) as a result of concurrent calls to those member
functions from different threads. Calls to these functions that allocate or deallocate a
particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.

\indexlibrary{\idxcode{address}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{address}}
\begin{itemdecl}
pointer address(reference x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The actual address of the object referenced by \tcode{x}, even in the presence of an
overloaded operator\&.
\end{itemdescr}

\indexlibrary{\idxcode{address}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{address}}
\begin{itemdecl}
const_pointer address(const_reference x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The actual address of the object referenced by \tcode{x}, even in the presence of an
overloaded operator\&.
\end{itemdescr}

\indexlibrary{\idxcode{allocate}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{allocate}}
\begin{itemdecl}
pointer allocate(size_type n, allocator<void>::const_pointer hint = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote In a container member function, the address of an adjacent
element is often a good choice to pass for the \tcode{hint} argument. \exitnote

\pnum
\returns
A pointer to the initial element of an array of storage of size \tcode{n}
\tcode{* sizeof(T)}, aligned appropriately for objects of type \tcode{T}.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported~(\ref{basic.align}).

\pnum
\note
the storage is obtained by calling \tcode{::operator
new(std::size_t)}~(\ref{new.delete}), but it is unspecified when or how often this
function is called. The use of \tcode{hint} is unspecified, but intended as an aid to
locality if an implementation so desires.

\pnum
\throws
\tcode{bad_alloc} if the storage cannot be obtained.
\end{itemdescr}

\indexlibrary{\idxcode{deallocate}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{deallocate}}
\begin{itemdecl}
void deallocate(pointer p, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} shall be a pointer value obtained from \tcode{allocate()}.
\tcode{n} shall equal the value passed as the first argument
to the invocation of allocate which returned \tcode{p}.

\pnum
\effects
Deallocates the storage referenced by \tcode{p} .

\pnum
\notes
Uses
\tcode{::operator delete(void*, std::size_t)}~(\ref{new.delete}), but it is unspecified
when this function is called.
\end{itemdescr}

\indexlibrary{\idxcode{max_size}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{max_size}}
\begin{itemdecl}
size_type max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The largest value \textit{N} for which the call \tcode{allocate(N,0)}
might succeed.
\end{itemdescr}

\indexlibrary{\idxcode{allocator}!constructor}%
\begin{itemdecl}
template <class U, class... Args>
  void construct(U* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{::new((void *)p) U(std::forward<Args>(args)...)}
\end{itemdescr}

\indexlibrary{\idxcode{allocator}!destructor}%
\begin{itemdecl}
template <class U>
  void destroy(U* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{p->\~{}U()}
\end{itemdescr}

\rSec3[allocator.globals]{\tcode{allocator} globals}

\indexlibrary{\idxcode{operator==}!\idxcode{allocator}}%
\indexlibrary{\idxcode{allocator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator==(const allocator<T1>&, const allocator<T2>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{allocator}}%
\indexlibrary{\idxcode{allocator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator!=(const allocator<T1>&, const allocator<T2>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false}.
\end{itemdescr}

\rSec2[storage.iterator]{Raw storage iterator}

\pnum
\tcode{raw_storage_iterator} is provided to enable algorithms to store their
results into uninitialized memory. The template parameter
\tcode{OutputIterator} is required to have its \tcode{operator*} return an
object for which \tcode{operator\&} is defined and returns a pointer to
\tcode{T}, and is also required to satisfy the requirements of an output
iterator~(\ref{output.iterators}).

\begin{codeblock}
namespace std {
  template <class OutputIterator, class T>
  class raw_storage_iterator
    : public iterator<output_iterator_tag,void,void,void,void> {
  public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator& operator*();
    raw_storage_iterator& operator=(const T& element);
    raw_storage_iterator& operator++();
    raw_storage_iterator  operator++(int);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{raw_storage_iterator}!constructor}%
\begin{itemdecl}
explicit raw_storage_iterator(OutputIterator x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the iterator to point to the same value to which \tcode{x} points.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator*}}
\begin{itemdecl}
raw_storage_iterator& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator=}}
\begin{itemdecl}
raw_storage_iterator& operator=(const T& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a value from \tcode{element} at the location to which the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator++}}
\begin{itemdecl}
raw_storage_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Pre-increment:  advances the iterator and returns a reference to the updated iterator.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator++}}
\begin{itemdecl}
raw_storage_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Post-increment:  advances the iterator and returns the old value of the iterator.
\end{itemdescr}

\rSec2[temporary.buffer]{Temporary buffers}

\indexlibrary{\idxcode{get_temporary_buffer}}%
\begin{itemdecl}
template <class T>
  pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Obtains a pointer to storage sufficient to store up to \tcode{n}
adjacent \tcode{T} objects.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported~(\ref{basic.align}).

\pnum
\returns
A \tcode{pair} containing the buffer's address and capacity (in the units of
\tcode{sizeof(T)}), or a pair of 0 values if no storage can be obtained or
if \tcode{n <= 0}.
\end{itemdescr}

\indexlibrary{\idxcode{return_temporary_buffer}}%
\begin{itemdecl}
template <class T> void return_temporary_buffer(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Deallocates the buffer to which \tcode{p}
points.

\pnum
\requires
The buffer shall have been previously allocated by \tcode{get_temporary_buffer}.
\end{itemdescr}

\rSec2[specialized.algorithms]{Specialized algorithms}

\pnum
All the iterators that are used as template parameters in the following
algorithms are required to  have their \tcode{operator*} return an object
for which \tcode{operator\&} is defined and returns a pointer to \tcode{T}.
In the algorithm \tcode{uninitialized_copy}, the template parameter
\tcode{InputIterator} is required to satisfy the requirements of an input
iterator~(\ref{input.iterators}). In all of the following algorithms,
the template parameter \tcode{ForwardIterator} is required to satisfy the
requirements of a forward iterator~(\ref{forward.iterators}),
and is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
In the following algorithms, if an exception is thrown there are no effects.

\rSec3[specialized.addressof]{\tcode{addressof}}

\indexlibrary{\idxcode{addressof}}%
\begin{itemdecl}
template <class T> T* addressof(T& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The actual address of the object or function referenced by \tcode{r}, even in the
presence of an overloaded \tcode{operator\&}.
\end{itemdescr}


\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; first != last; ++result, ++first)
  ::new (static_cast<void*>(&*result))
    typename iterator_traits<ForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
template <class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for ( ; n > 0; ++result, ++first, --n) {
  ::new (static_cast<void*>(&*result))
    typename iterator_traits<ForwardIterator>::value_type(*first);
}
\end{codeblock}

\pnum
\returns \tcode{result}
\end{itemdescr}


\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(&*first))
    typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\rSec3[uninitialized.fill.n]{\tcode{uninitialized_fill_n}}

\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
template <class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; n--; ++first)
  ::new (static_cast<void*>(&*first))
    typename iterator_traits<ForwardIterator>::value_type(x);
return first;
\end{codeblock}
\end{itemdescr}

\rSec2[c.malloc]{C library}

\pnum
Table~\ref{tab:util.hdr.cstdlib} describes the header
\tcode{<cstdlib>}.

\begin{libsyntab3}{cstdlib}{tab:util.hdr.cstdlib}
\functions  &   \tcode{calloc}  &   \tcode{malloc}      \\
            &   \tcode{free}    &   \tcode{realloc}     \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<stdlib.h>,}
with the following changes:

\pnum
The functions \tcode{calloc()}\indexlibrary{\idxcode{calloc}},
\tcode{malloc()}\indexlibrary{\idxcode{malloc}}, and
\tcode{realloc()}\indexlibrary{\idxcode{realloc}} do not attempt to allocate
storage by calling \tcode{::operator new()}~(\ref{support.dynamic}).
\indexlibrary{\idxcode{new}!\idxcode{operator}}%

\pnum
The function \tcode{free()}\indexlibrary{\idxcode{free}} does not attempt to
deallocate storage by calling
\tcode{::operator delete()}\indexlibrary{\idxcode{delete}!\tcode{operator}}.

\xref
ISO C Clause 7.11.2.

\pnum
Storage allocated directly with \tcode{malloc()}, \tcode{calloc()}, or
\tcode{realloc()} is implicitly declared reachable
(see~\ref{basic.stc.dynamic.safety}) on allocation, ceases to be declared
reachable on deallocation, and need not cease to be declared reachable as the
result of an \tcode{undeclare_reachable()} call. \enternote This allows existing
C libraries to remain unaffected by restrictions on pointers that are not safely
derived, at the expense of providing far fewer garbage collection and leak
detection options for \tcode{malloc()}-allocated objects. It also allows
\tcode{malloc()} to be implemented with a separate allocation arena, bypassing
the normal \tcode{declare_reachable()} implementation. The above functions
should never intentionally be used as a replacement for
\tcode{declare_reachable()}, and newly written code is strongly encouraged to
treat memory allocated with these functions as though it were allocated with
\tcode{operator new}. \exitnote

\pnum
Table~\ref{tab:util.hdr.cstring} describes the header
\tcode{<cstring>}.

\begin{libsyntab3}{cstring}{tab:util.hdr.cstring}
\macro          &   \tcode{NULL}    &                   \\ \rowsep
\type           &   \tcode{size_t}  &                   \\ \rowsep
\functions      &   \tcode{memchr}  &   \tcode{memcmp}  \\
\tcode{memcpy}  &   \tcode{memmove} &   \tcode{memset}  \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<string.h>}, with the change to \tcode{memchr()} specified
in~\ref{c.strings}.

\xref
ISO C Clause 7.11.2.

\rSec1[smartptr]{Smart pointers}

\rSec2[unique.ptr]{Class template \tcode{unique_ptr}}

\pnum
A \defn{unique pointer} is an object that owns another object and
manages that other object through a pointer. More precisely, a unique pointer
is an object \textit{u} that stores a pointer to a second object \textit{p} and
will dispose of \textit{p} when \textit{u} is itself destroyed (e.g., when
leaving block scope~(\ref{stmt.dcl})). In this context, \textit{u} is said
to \defn{own} \tcode{p}.

\pnum
The mechanism by which \textit{u} disposes of \textit{p} is known as
\textit{p}'s associated \defn{deleter}, a function object whose correct
invocation results in \textit{p}'s appropriate disposition (typically its deletion).

\pnum
Let the notation \textit{u.p} denote the pointer stored by \textit{u}, and
let \textit{u.d} denote the associated deleter. Upon request, \textit{u} can
\defn{reset} (replace) \textit{u.p} and \textit{u.d} with another pointer and
deleter, but must properly dispose of its owned object via the associated
deleter before such replacement is considered completed.

\pnum
Additionally, \textit{u} can, upon request, \defn{transfer ownership} to another
unique pointer \textit{u2}. Upon completion of such a transfer, the following
postconditions hold:

\begin{itemize}
\item \textit{u2.p} is equal to the pre-transfer \textit{u.p},
\item \textit{u.p} is equal to \tcode{nullptr}, and
\item if the pre-transfer \textit{u.d} maintained state, such state has been
transferred to \textit{u2.d}.
\end{itemize}

As in the case of a reset, \textit{u2} must properly dispose of its pre-transfer
owned object via the pre-transfer associated deleter before the ownership
transfer is considered complete. \enternote A deleter's state need never be
copied, only moved or swapped as ownership is transferred. \exitnote

\pnum
Each object of a type \tcode{U} instantiated from the \tcode{unique_ptr} template
specified in this subclause has the strict ownership semantics, specified above,
of a unique pointer. In partial satisfaction of these semantics, each such \tcode{U}
is \tcode{MoveConstructible} and \tcode{MoveAssignable}, but is not
\tcode{CopyConstructible} nor \tcode{CopyAssignable}.
The template parameter \tcode{T} of \tcode{unique_ptr} may be an incomplete type.

\pnum
\enternote The uses
of \tcode{unique_ptr} include providing exception safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. \exitnote

\begin{codeblock}
namespace std {
  template<class T> struct default_delete;
  template<class T> struct default_delete<T[]>;

  template<class T, class D = default_delete<T>> class unique_ptr;
  template<class T, class D> class unique_ptr<T[], D>;

  template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
  template<class T> unique_ptr<T> make_unique(size_t n);
  template<class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;

  template<class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

  template<class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

  template <class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

}
\end{codeblock}

\rSec3[unique.ptr.dltr]{Default deleters}

\rSec4[unique.ptr.dltr.general]{In general}

\pnum
The class template \tcode{default_delete} serves as the default deleter (destruction policy)
for the class template \tcode{unique_ptr}.

\pnum
The template parameter \tcode{T} of \tcode{default_delete} may be
an incomplete type.

\rSec4[unique.ptr.dltr.dflt]{\tcode{default_delete}}

\begin{codeblock}
namespace std {
  template <class T> struct default_delete {
    constexpr default_delete() noexcept = default;
    template <class U> default_delete(const default_delete<U>&) noexcept;
    void operator()(T*) const;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{default_delete}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{default_delete}}
\begin{itemdecl}
template <class U> default_delete(const default_delete<U>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{default_delete} object
from another \tcode{default_delete<U>} object.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{U*} is implicitly convertible to \tcode{T*}.
\end{itemdescr}

\indexlibrary{\idxcode{operator()}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{operator()}}
\begin{itemdecl}
void operator()(T* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{delete} on \tcode{ptr}.

\pnum
\notes If \tcode{T} is an incomplete type, the program is ill-formed.
\end{itemdescr}

\rSec4[unique.ptr.dltr.dflt1]{\tcode{default_delete<T[]>}}

\begin{codeblock}
namespace std {
  template <class T> struct default_delete<T[]> {
    constexpr default_delete() noexcept = default;
    void operator()(T*) const;
    template <class U> void operator()(U*) const = delete;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{operator()}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{operator()}}
\begin{itemdecl}
void operator()(T* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
calls \tcode{delete[]} on \tcode{ptr}.

\pnum
\notes If T is an incomplete type, the program is ill-formed.
\end{itemdescr}

\rSec3[unique.ptr.single]{\tcode{unique_ptr} for single objects}

\begin{codeblock}
namespace std {
  template <class T, class D = default_delete<T>> class unique_ptr {
  public:
    typedef @\seebelow@ pointer;
    typedef T element_type;
    typedef D deleter_type;

    // \ref{unique.ptr.single.ctor}, constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, @\seebelow@ d1) noexcept;
    unique_ptr(pointer p, @\seebelow@ d2) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept
      : unique_ptr() { }
    template <class U, class E>
      unique_ptr(unique_ptr<U, E>&& u) noexcept;
    template <class U>
      unique_ptr(auto_ptr<U>&& u) noexcept;

    // \ref{unique.ptr.single.dtor}, destructor
    ~unique_ptr();

    // \ref{unique.ptr.single.asgn}, assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.single.observers}, observers
    add_lvalue_reference_t<T> operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.single.modifiers} modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
The default type for the template parameter \tcode{D} is
\tcode{default_delete}. A client-supplied template argument
\tcode{D} shall be a function
object type~(\ref{function.objects}), lvalue-reference to function, or
lvalue-reference to function object type
for which, given
a value \tcode{d} of type \tcode{D} and a value
\tcode{ptr} of type \tcode{unique_ptr<T, D>::pointer}, the expression
\tcode{d(ptr)} is valid and has the effect of disposing of the
pointer as appropriate for that deleter.

\pnum
If the deleter's type \tcode{D} is not a reference type, \tcode{D} shall satisfy
the requirements of \tcode{Destructible} (Table~\ref{destructible}).

\pnum
If the type \tcode{remove_reference_t<D>::pointer} exists, then \tcode{unique_ptr<T,
D>::pointer} shall be a synonym for \tcode{remove_reference_t<D>::pointer}. Otherwise
\tcode{unique_ptr<T, D>::pointer} shall be a synonym for \tcode{T*}. The type \tcode{unique_ptr<T,
D>::pointer} shall
satisfy the requirements of \tcode{NullablePointer} (\ref{nullablepointer.requirements}).

\pnum
\enterexample Given an allocator type \tcode{X}~(\ref{allocator.requirements}) and
letting \tcode{A} be a synonym for \tcode{allocator_traits<X>}, the types \tcode{A::pointer},
\tcode{A::const_pointer}, \tcode{A::void_pointer}, and \tcode{A::const_void_pointer}
may be used as \tcode{unique_ptr<T, D>::pointer}. \exitexample

\rSec4[unique.ptr.single.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
constexpr unique_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the requirements of \tcode{DefaultConstructible} (Table~\ref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} object that owns
nothing, value-initializing the stored pointer and the stored deleter.

\pnum
\postconditions \tcode{get() == nullptr}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\notes If this constructor is instantiated with a pointer type or reference type
for the template argument \tcode{D}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
explicit unique_ptr(pointer p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the requirements of \tcode{DefaultConstructible} (Table~\ref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} which owns
\tcode{p}, initializing the stored pointer with \tcode{p} and
value-initializing the stored deleter.

\pnum
\postconditions \tcode{get() == p}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\notes If this constructor is instantiated with a pointer type or reference type
for the template argument \tcode{D}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
unique_ptr(pointer p, @\seebelow@ d1) noexcept;
unique_ptr(pointer p, @\seebelow@ d2) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The signature of these constructors depends upon whether \tcode{D}
is a reference type. If \tcode{D} is non-reference type
\tcode{A}, then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, A&& d);
\end{codeblock}

\pnum
If \tcode{D} is an lvalue-reference type \tcode{A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, A& d);
unique_ptr(pointer p, A&& d);
\end{codeblock}

\pnum
If \tcode{D} is an lvalue-reference type \tcode{const A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, const A&& d);
\end{codeblock}

\pnum
\requires
\begin{itemize}
\item If \tcode{D} is not an lvalue-reference type then

\begin{itemize}
\item If \tcode{d} is an lvalue or \tcode{const} rvalue then
the first constructor of this pair will be selected. \tcode{D}
shall satisfy the requirements of
\tcode{CopyConstructible} (Table~\ref{copyconstructible}), and
the copy constructor of \tcode{D} shall
not throw an exception.
This \tcode{unique_ptr} will hold
a copy of \tcode{d}.

\item Otherwise, \tcode{d} is a non-const rvalue and the second
constructor of this pair will be selected. \tcode{D}
shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{moveconstructible}), and the
move constructor of \tcode{D} shall not throw an exception.
This \tcode{unique_ptr} will
hold a value move constructed from \tcode{d}.
\end{itemize}

\item Otherwise \tcode{D} is an lvalue-reference type. \tcode{d}
shall be reference-compatible with one of the constructors. If \tcode{d} is
an rvalue, it will bind to the second constructor of this pair and the program is
ill-formed. \enternote The diagnostic could
be implemented using a \tcode{static_assert} which assures that
\tcode{D} is not a reference type. \exitnote Else \tcode{d}
is an lvalue and will bind to the first constructor of this pair. The type
which \tcode{D} references need not be \tcode{CopyConstructible}
nor \tcode{MoveConstructible}. This \tcode{unique_ptr} will
hold a \tcode{D} which refers to the lvalue \tcode{d}.
\enternote \tcode{D} may not be an rvalue-reference type.
\exitnote
\end{itemize}

\pnum
\effects Constructs a \tcode{unique_ptr} object which owns \tcode{p}, initializing
the stored pointer with \tcode{p} and initializing the deleter as described above.

\pnum
\postconditions \tcode{get() == p}.
\tcode{get_deleter()} returns a reference to the stored
deleter. If \tcode{D} is a reference type then \tcode{get_deleter()}
returns a reference to the lvalue \tcode{d}.

\enterexample

\begin{codeblock}
D d;
unique_ptr<int, D> p1(new int, D());        // \tcode{D} must be \tcode{MoveConstructible}
unique_ptr<int, D> p2(new int, d);          // \tcode{D} must be \tcode{CopyConstructible}
unique_ptr<int, D&> p3(new int, d);         // \tcode{p3} holds a reference to \tcode{d}
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined
                                            // with reference deleter type
\end{codeblock}

\exitexample

\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
unique_ptr(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type,
\tcode{D} shall satisfy the requirements of \tcode{MoveConstructible}
(Table~\ref{moveconstructible}).
Construction
of the deleter from an rvalue of type \tcode{D} shall not
throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} by transferring ownership from
\tcode{u} to \tcode{*this}. If \tcode{D} is a reference type, this
deleter is copy constructed from \tcode{u}'s deleter; otherwise, this
deleter is move constructed from \tcode{u}'s deleter. \enternote The
deleter constructor can be implemented with \tcode{std::forward<D>}. \exitnote

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction. \tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}. If \tcode{D} is a reference type then
\tcode{get_deleter()} and \tcode{u.get_deleter()} both reference
the same lvalue deleter.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template <class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type,
construction of the deleter from an rvalue of type
\tcode{E} shall be well formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and construction of the deleter from an
lvalue of type \tcode{E} shall be well formed and shall not throw an exception.

\pnum
\remarks This constructor shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer},
\item \tcode{U} is not an array type, and
\item either \tcode{D} is a reference type and \tcode{E} is the same type as \tcode{D}, or
\tcode{D} is not a reference type and \tcode{E} is implicitly convertible to \tcode{D}.
\end{itemize}

\pnum
\effects Constructs a \tcode{unique_ptr} by transferring ownership from \tcode{u}
to \tcode{*this}. If \tcode{E} is a reference type, this deleter is copy constructed from
\tcode{u}'s deleter; otherwise, this deleter is move constructed from \tcode{u}'s
deleter. \enternote The deleter constructor can be implemented with
\tcode{std::forward<E>}. \exitnote

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction.
\tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template <class U>
  unique_ptr(auto_ptr<U>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{unique_ptr} object, initializing the
stored pointer with \tcode{u.release()} and value-initializing the stored deleter.

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()} yielded
before the construction.
\tcode{u.get() == nullptr}.
\tcode{get_deleter()} returns a reference to the stored deleter.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{U*} is implicitly convertible to \tcode{T*} and \tcode{D} is
the same type as \tcode{default_delete<T>}.
\end{itemdescr}

\rSec4[unique.ptr.single.dtor]{\tcode{unique_ptr} destructor}

\indexlibrary{\idxcode{unique_ptr}!destructor}
\begin{itemdecl}
~unique_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well formed,
shall have well-defined behavior, and shall not throw exceptions. \enternote The
use of \tcode{default_delete} requires \tcode{T} to be a complete type.
\exitnote

\pnum
\effects If \tcode{get() == nullptr} there are no effects.
Otherwise \tcode{get_deleter()(get())}.
\end{itemdescr}

\rSec4[unique.ptr.single.asgn]{\tcode{unique_ptr} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
unique_ptr& operator=(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type, \tcode{D} shall satisfy the
requirements of \tcode{MoveAssignable} (Table~\ref{moveassignable}) and assignment
of the deleter from an rvalue of type \tcode{D} shall not throw an exception.
Otherwise, \tcode{D} is a reference type;
\tcode{remove_reference_t<D>} shall satisfy the \tcode{CopyAssignable}
requirements and assignment of the deleter from an
lvalue of type \tcode{D} shall not throw an exception.

\pnum
\effects
Transfers ownership from \tcode{u} to \tcode{*this} as if by calling
\tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<D>(u.get_deleter())}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type, assignment of the deleter from
an rvalue of type \tcode{E} shall be well-formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and assignment of the deleter from an lvalue
of type \tcode{E} shall be well-formed and shall not throw an exception.

\pnum
\remarks This operator shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer} and
\item \tcode{U} is not an array type.
\end{itemize}

\pnum
\effects Transfers ownership from \tcode{u} to \tcode{*this} as if by calling
\tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<E>(u.get_deleter())}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
unique_ptr& operator=(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{reset()}.

\pnum
\postcondition \tcode{get() == nullptr}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[unique.ptr.single.observers]{\tcode{unique_ptr} observers}

\indexlibrary{\idxcode{operator*}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator*}}
\begin{itemdecl}
add_lvalue_reference_t<T> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{*get()}.

\end{itemdescr}

\indexlibrary{\idxcode{operator->}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator->}}
\begin{itemdecl}
pointer operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{get()}.

\pnum
\realnote use typically requires that \tcode{T} be a complete type.
\end{itemdescr}

\indexlibrary{\idxcode{get}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{get}}
\begin{itemdecl}
pointer get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored pointer.
\end{itemdescr}

\indexlibrary{\idxcode{get_deleter}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{get_deleter}}
\begin{itemdecl}
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A reference to the stored deleter.
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator bool}}
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get() != nullptr}.
\end{itemdescr}

\rSec4[unique.ptr.single.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrary{\idxcode{release}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{release}}
\begin{itemdecl}
pointer release() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postcondition \tcode{get() == nullptr}.

\pnum
\returns The value \tcode{get()} had at the start of
the call to \tcode{release}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{reset}}
\begin{itemdecl}
void reset(pointer p = pointer()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well formed, shall have
well-defined behavior, and shall not throw exceptions.

\pnum
\effects assigns \tcode{p} to the stored pointer, and then if the old value of the
stored pointer, \tcode{old_p}, was not equal to \tcode{nullptr}, calls
\tcode{get_deleter()(old_p)}. \enternote The order of these operations is significant
because the call to \tcode{get_deleter()} may destroy \tcode{*this}. \exitnote

\pnum
\postconditions \tcode{get() == p}.
\enternote The postcondition does not hold if the call to \tcode{get_deleter()}
destroys \tcode{*this} since \tcode{this->get()} is no longer a valid expression.
\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{swap}}
\begin{itemdecl}
void swap(unique_ptr& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get_deleter()} shall be
swappable~(\ref{swappable.requirements}) and shall
not throw an exception
under \tcode{swap}.

\pnum
\effects Invokes \tcode{swap} on the stored pointers and on the stored
deleters of \tcode{*this} and \tcode{u}.
\end{itemdescr}

\rSec3[unique.ptr.runtime]{\tcode{unique_ptr} for array objects with a runtime length}

\begin{codeblock}
namespace std {
  template <class T, class D> class unique_ptr<T[], D> {
  public:
    typedef @\seebelow@ pointer;
    typedef T element_type;
    typedef D deleter_type;

    // \ref{unique.ptr.runtime.ctor}, constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, @\seebelow@ d) noexcept;
    unique_ptr(pointer p, @\seebelow@ d) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.runtime.observers}, observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.runtime.modifiers} modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
    template <class U> void reset(U) = delete;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
A specialization for array types is provided with a slightly altered
interface.

\begin{itemize}
\item Conversions between different types of
\tcode{unique_ptr<T[], D>} or to or from the non-array forms of
\tcode{unique_ptr} produce an ill-formed program.

\item Pointers to types derived from \tcode{T} are
rejected by the constructors, and by \tcode{reset}.

\item The observers \tcode{operator*} and
\tcode{operator->} are not provided.

\item The indexing observer \tcode{operator[]} is provided.

\item The default deleter will call \tcode{delete[]}.
\end{itemize}

\pnum
Descriptions are provided below only for member functions that
have behavior different from the primary template.

\pnum
The template argument \tcode{T} shall be a complete type.

\rSec4[unique.ptr.runtime.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, @\seebelow@ d) noexcept;
unique_ptr(pointer p, @\seebelow@ d) noexcept;
\end{itemdecl}

\begin{itemdescr}
These constructors behave the same as in the primary template
except that they do not accept pointer types which are convertible
to \tcode{pointer}. \enternote One implementation technique
is to create private templated overloads of these members. \exitnote
\end{itemdescr}

\rSec4[unique.ptr.runtime.observers]{\tcode{unique_ptr} observers}

\indexlibrary{\idxcode{operator[]}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator[]}}
\begin{itemdecl}
T& operator[](size_t i) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{i <} the
number of elements in the array to which
the stored pointer points.

\pnum
\returns \tcode{get()[i]}.
\end{itemdescr}

\rSec4[unique.ptr.runtime.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrary{\idxcode{reset}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{reset}}
\begin{itemdecl}
void reset(nullptr_t p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{reset(pointer())}.
\end{itemdescr}

\rSec3[unique.ptr.create]{\tcode{unique_ptr} creation}

\indexlibrary{\idxcode{make_unique}}
\begin{itemdecl}
template <class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is not an array.

\pnum
\returns \tcode{unique_ptr<T>(new T(std::forward<Args>(args)...))}.

\end{itemdescr}

\begin{itemdecl}
template <class T> unique_ptr<T> make_unique(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of unknown bound.

\pnum
\returns \tcode{unique_ptr<T>(new remove_extent_t<T>[n]())}.

\end{itemdescr}

\begin{itemdecl}
template <class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of known bound.

\end{itemdescr}

\rSec3[unique.ptr.special]{\tcode{unique_ptr} specialized algorithms}

\indexlibrary{\idxcode{swap(unique_ptr\&, unique_ptr\&)}}
\begin{itemdecl}
template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{x.swap(y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() == y.get()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() != y.get()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires Let \tcode{CT} be \tcode{common_type<unique_ptr<T1, D1>::pointer,}
\tcode{unique_ptr<T2, D2>::poin\-ter>::type}. Then the specialization
\tcode{less<CT>} shall be a function object type~(\ref{function.objects}) that
induces a strict weak ordering~(\ref{alg.sorting}) on the pointer values.

\pnum
\returns \tcode{less<CT>()(x.get(), y.get()).}

\pnum
\remarks If \tcode{unique_ptr<T1, D1>::pointer} is not implicitly convertible
to \tcode{CT} or \tcode{unique_ptr<T2, D2>::pointer} is not implicitly
convertible to \tcode{CT}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T, class D>
  bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
  bool operator==(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
  bool operator!=(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(bool)x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<}}%
\begin{itemdecl}
template <class T, class D>
  bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator<(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The specialization \tcode{less<unique_ptr<T, D>::pointer>} shall be
a function object type~(\ref{function.objects}) that induces a strict weak
ordering~(\ref{alg.sorting}) on the pointer values.

\pnum
\returns
The first function template returns
\tcode{less<unique_ptr<T, D>::pointer>()(x.get(),\\nullptr)}.
The second function template returns
\tcode{less<unique_ptr<T, D>::pointer>()(nullptr, x.get())}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>}}%
\begin{itemdecl}
template <class T, class D>
  bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator>(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{nullptr < x}.
The second function template returns \tcode{x < nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator<=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(nullptr < x)}.
The second function template returns \tcode{!(x < nullptr)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator>=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(x < nullptr)}.
The second function template returns \tcode{!(nullptr < x)}.
\end{itemdescr}

\indextext{smart pointers|(}%
\rSec2[util.smartptr]{Shared-ownership pointers}

\rSec3[util.smartptr.weakptr]{Class \tcode{bad_weak_ptr}}
\indexlibrary{exception!\idxcode{bad_weak_ptr}}%
\indexlibrary{\idxcode{bad_weak_ptr}}%
\begin{codeblock}
namespace std {
  class bad_weak_ptr: public std::exception {
  public:
    bad_weak_ptr() noexcept;
  };
} // namespace std
\end{codeblock}

\pnum
An exception of type \tcode{bad_weak_ptr} is thrown by the \tcode{shared_ptr}
constructor taking a \tcode{weak_ptr}.

\indexlibrary{\idxcode{bad_weak_ptr}!\idxcode{bad_weak_ptr}}%
\indexlibrary{\idxcode{bad_weak_ptr}!\idxcode{what}}%
\indexlibrary{\idxcode{what}!\idxcode{bad_weak_ptr}}%
\begin{itemdecl}
bad_weak_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions  \tcode{what()} returns \tcode{"bad_weak_ptr"}.
\end{itemdescr}

\rSec3[util.smartptr.shared]{Class template \tcode{shared_ptr}}

\pnum
\indexlibrary{\idxcode{shared_ptr}}%
The \tcode{shared_ptr} class template stores a pointer, usually obtained
via \tcode{new}. \tcode{shared_ptr} implements semantics of shared ownership;
the last remaining owner of the pointer is responsible for destroying
the object, or otherwise releasing the resources associated with the stored pointer. A
\tcode{shared_ptr} object is \term{empty} if it does not own a pointer.

\begin{codeblock}
namespace std {
  template<class T> class shared_ptr {
  public:
    typedef T element_type;

    // \ref{util.smartptr.shared.const}, constructors:
    constexpr shared_ptr() noexcept;
    template<class Y> explicit shared_ptr(Y* p);
    template<class Y, class D> shared_ptr(Y* p, D d);
    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
    template <class D> shared_ptr(nullptr_t p, D d);
    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
    template<class Y> shared_ptr(const shared_ptr<Y>& r, T* p) noexcept;
    shared_ptr(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
    shared_ptr(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
    template<class Y> shared_ptr(auto_ptr<Y>&& r);
    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
    constexpr shared_ptr(nullptr_t) : shared_ptr() { }

    // \ref{util.smartptr.shared.dest}, destructor:
    ~shared_ptr();

    // \ref{util.smartptr.shared.assign}, assignment:
    shared_ptr& operator=(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
    shared_ptr& operator=(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);
    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);

    // \ref{util.smartptr.shared.mod}, modifiers:
    void swap(shared_ptr& r) noexcept;
    void reset() noexcept;
    template<class Y> void reset(Y* p);
    template<class Y, class D> void reset(Y* p, D d);
    template<class Y, class D, class A> void reset(Y* p, D d, A a);

    // \ref{util.smartptr.shared.obs}, observers:
    T* get() const noexcept;
    T& operator*() const noexcept;
    T* operator->() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const;
    template<class U> bool owner_before(weak_ptr<U> const& b) const;
  };

  // \ref{util.smartptr.shared.create}, shared_ptr creation
  template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
  template<class T, class A, class... Args>
    shared_ptr<T> allocate_shared(const A& a, Args&&... args);

  // \ref{util.smartptr.shared.cmp}, shared_ptr comparisons:
  template<class T, class U>
    bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator!=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator<=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator>=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

  template <class T>
    bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator==(nullptr_t, const shared_ptr<T>& b) noexcept;
  template <class T>
    bool operator!=(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator!=(nullptr_t, const shared_ptr<T>& b) noexcept;
  template <class T>
    bool operator<(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator<(nullptr_t, const shared_ptr<T>& b) noexcept;
  template <class T>
    bool operator<=(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator<=(nullptr_t, const shared_ptr<T>& b) noexcept;
  template <class T>
    bool operator>(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator>(nullptr_t, const shared_ptr<T>& b) noexcept;
  template <class T>
    bool operator>=(const shared_ptr<T>& a, nullptr_t) noexcept;
  template <class T>
    bool operator>=(nullptr_t, const shared_ptr<T>& b) noexcept;

  // \ref{util.smartptr.shared.spec}, shared_ptr specialized algorithms:
  template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

  // \ref{util.smartptr.shared.cast}, shared_ptr casts:
  template<class T, class U>
    shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
  template<class T, class U>
    shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
  template<class T, class U>
    shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;

  // \ref{util.smartptr.getdeleter}, shared_ptr get_deleter:
  template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;

  // \ref{util.smartptr.shared.io}, shared_ptr I/O:
  template<class E, class T, class Y>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, const shared_ptr<Y>& p);
} // namespace std
\end{codeblock}

\pnum
Specializations of \tcode{shared_ptr} shall be \tcode{CopyConstructible},
\tcode{CopyAssignable}, and \tcode{LessThanComparable}, allowing their use in standard
containers. Specializations of \tcode{shared_ptr} shall be convertible to \tcode{bool},
allowing their use in boolean expressions and declarations in conditions. The template
parameter \tcode{T} of \tcode{shared_ptr} may be an incomplete type.

\pnum
\enterexample
\begin{codeblock}
if(shared_ptr<X> px = dynamic_pointer_cast<X>(py)) {
  // do something with px
}
\end{codeblock}
\exitexample

\pnum
For purposes of determining the presence of a data race, member functions shall
access and modify only the \tcode{shared_ptr} and \tcode{weak_ptr} objects
themselves and not objects they refer to. Changes in \tcode{use_count()} do not
reflect modifications that can introduce data races.

\rSec4[util.smartptr.shared.const]{\tcode{shared_ptr} constructors}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{shared_ptr}}%
\begin{itemdecl}
constexpr shared_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs an \textit{empty} \tcode{shared_ptr} object.

\pnum\postconditions  \tcode{use_count() == 0 \&\& get() == nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y> explicit shared_ptr(Y* p);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{p} shall be convertible to \tcode{T*}.
\tcode{Y} shall be a complete type. The expression \tcode{delete p}
shall be well formed, shall have well defined behavior, and shall not
throw exceptions.

\pnum\effects Constructs a \tcode{shared_ptr} object that \textit{owns} the pointer
\tcode{p}.

\pnum\postconditions  \tcode{use_count() == 1 \&\& get() == p}.

\pnum\throws \tcode{bad_alloc}, or an \impldef{exception type when \tcode{shared_ptr}
constructor fails} exception when a resource other than memory could not be obtained.

\pnum\exceptionsafety  If an exception is thrown, \tcode{delete p} is
called.
\end{itemdescr}


\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template <class D> shared_ptr(nullptr_t p, D d);
template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{p} shall be convertible to \tcode{T*}. \tcode{D} shall be
\tcode{CopyConstructible}. The copy constructor and destructor of \tcode{ D}
shall not throw exceptions. The expression \tcode{d(p)} shall be
well formed, shall have well defined behavior, and shall not throw exceptions.
\tcode{A} shall be an allocator~(\ref{allocator.requirements}).
The copy constructor and destructor of \tcode{A} shall not throw exceptions.

\pnum\effects  Constructs a \tcode{shared_ptr} object that \textit{owns} the
object \tcode{p} and the deleter \tcode{d}.
The second and fourth constructors shall use a copy of \tcode{a} to
allocate memory for internal use.

\pnum\postconditions  \tcode{use_count() == 1 \&\& get() == p}.

\pnum\throws  \tcode{bad_alloc}, or an \impldef{exception type when \tcode{shared_ptr}
constructor fails} exception
when a resource other than memory could not be obtained.

\pnum\exceptionsafety  If an exception is thrown, \tcode{d(p)} is called.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y> shared_ptr(const shared_ptr<Y>& r, T* p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{shared_ptr} instance that
stores \tcode{p} and \textit{shares ownership} with \tcode{r}.

\pnum
\postconditions \tcode{get() == p \&\& use_count() == r.use_count()}

\pnum
\enternote To avoid the possibility of a dangling pointer, the
user of this constructor must ensure that \tcode{p} remains valid at
least until the ownership group of \tcode{r} is destroyed. \exitnote

\pnum
\enternote This constructor allows creation of an \textit{empty}
\tcode{shared_ptr} instance with a non-null stored pointer. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remark
The second constructor shall not participate in overload resolution unless
\tcode{Y*} is implicitly convertible to \tcode{T*}.

\pnum\effects  If \tcode{r} is \textit{empty}, constructs
an \textit{empty} \tcode{shared_ptr} object; otherwise, constructs
a \tcode{shared_ptr} object that \textit{shares ownership} with \tcode{r}.

\pnum\postconditions  \tcode{get() == r.get() \&\& use_count() == r.use_count()}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remark The second constructor shall not participate in overload resolution unless
\tcode{Y*} is convertible to \tcode{T*}.

\pnum
\effects Move-constructs a \tcode{shared_ptr} instance from
\tcode{r}.

\pnum
\postconditions \tcode{*this} shall contain the old value of
\tcode{r}. \tcode{r} shall be \textit{empty}. \tcode{r.get() == nullptr.}
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\indexlibrary{\idxcode{weak_ptr}}%
\begin{itemdecl}
template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires \tcode{Y*} shall be convertible to \tcode{T*}.

\pnum\effects  Constructs a \tcode{shared_ptr} object that \textit{shares ownership} with
\tcode{r} and stores a copy of the pointer stored in \tcode{r}.

\pnum\postconditions  \tcode{use_count() == r.use_count()}.

\pnum\throws  \tcode{bad_weak_ptr} when \tcode{r.expired()}.

\pnum\exceptionsafety  If an exception is thrown, the constructor has no
effect.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\indexlibrary{\idxcode{auto_ptr}}
\begin{itemdecl}
template<class Y> shared_ptr(auto_ptr<Y>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{r.release()} shall be convertible to \tcode{T*}.
\tcode{Y} shall be a complete type. The expression \tcode{delete
r.release()} shall be well formed, shall have well defined behavior,
and shall not throw exceptions.

\pnum\effects  Constructs a \tcode{shared_ptr} object that stores and \textit{owns}
\tcode{r.release()}.

\pnum\postconditions  \tcode{use_count() == 1} \tcode{\&\&} \tcode{r.get() == nullptr}.

\pnum\throws  \tcode{bad_alloc}, or an \impldef{exception type when \tcode{shared_ptr}
constructor fails} exception when a
resource other than memory could not be obtained.

\pnum\exceptionsafety  If an exception is thrown, the constructor has no
effect.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\indexlibrary{\idxcode{unique_ptr}}%
\begin{itemdecl}
template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{shared_ptr(r.release(), r.get_deleter())} when
\tcode{D} is not a reference type, otherwise \tcode{shared_ptr(r.release(),
ref(r.get_deleter()))}.

\pnum
\exceptionsafety If an exception is thrown, the constructor has no effect.
\end{itemdescr}

\rSec4[util.smartptr.shared.dest]{\tcode{shared_ptr} destructor}

\indexlibrary{\idxcode{shared_ptr}!destructor}%
\begin{itemdecl}
~shared_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects
\begin{itemize}
\item If \tcode{*this} is \textit{empty} or shares ownership with another
\tcode{shared_ptr} instance (\tcode{use_count() > 1}), there are no side effects.

\item
Otherwise, if \tcode{*this} \textit{owns} an object
\tcode{p} and a deleter \tcode{d}, \tcode{d(p)} is called.

\item Otherwise, \tcode{*this} \textit{owns} a pointer \tcode{p},
and \tcode{delete p} is called.
\end{itemize}
\end{itemdescr}

\pnum
\enternote Since the destruction of \tcode{*this}
decreases the number of instances that share ownership with \tcode{*this}
by one,
after \tcode{*this} has been destroyed
all \tcode{shared_ptr} instances that shared ownership with
\tcode{*this} will report a \tcode{use_count()} that is one less
than its previous value. \exitnote

\rSec4[util.smartptr.shared.assign]{\tcode{shared_ptr} assignment}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{shared_ptr}}%
\begin{itemdecl}
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(r).swap(*this)}.

\pnum\returns  \tcode{*this}.

\pnum \enternote
The use count updates caused by the temporary object
construction and destruction are not observable side
effects, so the implementation may meet the effects (and the
implied guarantees) via different means, without creating a
temporary. In particular, in the example:
\begin{codeblock}
shared_ptr<int> p(new int);
shared_ptr<void> q(p);
p = p;
q = p;
\end{codeblock}
both assignments may be no-ops. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator=}}%
\begin{itemdecl}
shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{shared_ptr(std::move(r)).swap(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator=}}%
\begin{itemdecl}
template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{shared_ptr(std::move(r)).swap(*this)}.

\pnum
\returns \tcode{*this}
\end{itemdescr}



\rSec4[util.smartptr.shared.mod]{\tcode{shared_ptr} modifiers}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{shared_ptr}}%
\begin{itemdecl}
void swap(shared_ptr& r) noexcept;
\end{itemdecl}

\begin{itemdescr}

\pnum\effects  Exchanges the contents of \tcode{*this} and \tcode{r}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{reset}}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr().swap(*this)}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{reset}}%
\begin{itemdecl}
template<class Y> void reset(Y* p);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(p).swap(*this)}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{reset}}%
\begin{itemdecl}
template<class Y, class D> void reset(Y* p, D d);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(p, d).swap(*this)}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{reset}}%
\begin{itemdecl}
template<class Y, class D, class A> void reset(Y* p, D d, A a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Equivalent to \tcode{shared_ptr(p, d, a).swap(*this)}.
\end{itemdescr}

\rSec4[util.smartptr.shared.obs]{\tcode{shared_ptr} observers}
\indexlibrary{\idxcode{shared_ptr}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{shared_ptr}}%
\begin{itemdecl}
T* get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  the stored pointer.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator*}}%
\indexlibrary{\idxcode{operator*}!\idxcode{shared_ptr}}%
\begin{itemdecl}
T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{get() != 0}.

\pnum\returns  \tcode{*get()}.

\pnum\notes When \tcode{T} is \tcode{void}, it is unspecified whether this
member function is declared. If it is declared, it is unspecified what its
return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator->}}%
\indexlibrary{\idxcode{operator->}!\idxcode{shared_ptr}}%
\begin{itemdecl}
T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{get() != 0}.

\pnum\returns  \tcode{get()}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{use_count}}%
\indexlibrary{\idxcode{use_count}!\idxcode{shared_ptr}}%
\begin{itemdecl}
long use_count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  the number of \tcode{shared_ptr} objects, \tcode{*this} included,
that \textit{share ownership} with \tcode{*this}, or \tcode{0} when \tcode{*this} is
\textit{empty}.

\pnum \enternote \tcode{use_count()} is not necessarily
efficient.\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{unique}}%
\indexlibrary{\idxcode{unique}!\idxcode{shared_ptr}}%
\begin{itemdecl}
bool unique() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{use_count() == 1}.

\pnum \enternote \tcode{unique()} may be faster than \tcode{use_count()}.  If you are
using \tcode{unique()} to implement copy on write, do not rely on a
specific value when \tcode{get() == nullptr}. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator bool}}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{get() != 0}.
\end{itemdescr}

\indexlibrary{\idxcode{owner_before}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{owner_before}}%
\begin{itemdecl}
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An unspecified value such that

\begin{itemize}
\item \tcode{x.owner_before(y)} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{owner_before},
\tcode{!a.owner_before(b) \&\& !b.owner_before(a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or
are both empty.
\end{itemize}

\end{itemdescr}


\rSec4[util.smartptr.shared.create]{\tcode{shared_ptr} creation}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>
  shared_ptr<T> allocate_shared(const A& a, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{::new (pv) T(std::forward<Args>(args)...)},
where \tcode{pv} has type \tcode{void*} and points to storage suitable
to hold an object of type \tcode{T}, shall be well formed. \tcode{A} shall
be an \textit{allocator}~(\ref{allocator.requirements}). The copy constructor
and destructor of \tcode{A} shall not throw exceptions.

\pnum
\effects Allocates memory suitable for an object of type \tcode{T}
and constructs an object in that memory via the placement new expression
\tcode{::new (pv) T(std::forward<Args>(args)...)}.
The template \tcode{allocate_shared} uses a copy of \tcode{a} to
allocate memory. If an exception is thrown, the functions have no effect.

\pnum
\returns A \tcode{shared_ptr} instance that stores and owns
the address of the newly constructed object of type \tcode{T}.

\pnum
\postconditions \tcode{get() != 0 \&\& use_count() == 1}

\pnum
\throws \tcode{bad_alloc}, or an exception thrown from
\tcode{A::allocate} or from the constructor of \tcode{T}.

\pnum
\notes Implementations should
perform no more than one memory allocation. \enternote This provides
efficiency equivalent to an intrusive smart pointer. \exitnote

\pnum
\enternote These functions will typically allocate more memory
than \tcode{sizeof(T)} to allow for internal bookkeeping structures such
as the reference counts. \exitnote
\end{itemdescr}

\rSec4[util.smartptr.shared.cmp]{\tcode{shared_ptr} comparison}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator==}}%
\indexlibrary{\idxcode{operator==}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T, class U> bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{a.get() == b.get()}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<}}%
\indexlibrary{\idxcode{operator<}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T, class U> bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{less<V>()(a.get(), b.get())},
where \tcode{V} is the composite pointer type (Clause~\ref{expr}) of \tcode{T*} and \tcode{U*}.

\pnum \enternote
Defining a comparison operator allows \tcode{shared_ptr} objects to be
used as keys in associative containers.
\exitnote

\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T>
  bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator==(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!a}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T>
  bool operator!=(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator!=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(bool)a}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<}}%
\begin{itemdecl}
template <class T>
  bool operator<(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator<(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns
\tcode{less<T*>()(a.get(), nullptr)}.
The second function template returns
\tcode{less<T*>()(nullptr, a.get())}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator>}}%
\begin{itemdecl}
template <class T>
  bool operator>(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator>(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{nullptr < a}.
The second function template returns \tcode{a < nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class T>
  bool operator<=(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator<=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(nullptr < a)}.
The second function template returns \tcode{!(a < nullptr)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class T>
  bool operator>=(const shared_ptr<T>& a, nullptr_t) noexcept;
template <class T>
  bool operator>=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(a < nullptr)}.
The second function template returns \tcode{!(nullptr < a)}.
\end{itemdescr}

\rSec4[util.smartptr.shared.spec]{\tcode{shared_ptr} specialized algorithms}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{a.swap(b)}.
\end{itemdescr}

\rSec4[util.smartptr.shared.cast]{\tcode{shared_ptr} casts}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{static_pointer_cast}}%
\indexlibrary{\idxcode{static_pointer_cast}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T, class U> shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  The expression \tcode{static_cast<T*>(r.get())} shall
be well formed.

\pnum\returns  If \tcode{r} is \textit{empty}, an \textit{empty}
\tcode{shared_ptr<T>}; otherwise, a \tcode{shared_ptr<T>} object that
stores \tcode{static_cast<T*>(r.get())} and \textit{shares ownership}
with \tcode{r}.

\pnum
\postconditions \tcode{w.get() == static_cast<T*>(r.get())} and
\tcode{w.use_count() == r.use_count()}, where \tcode{w} is the return value.

\pnum
\enternote The seemingly equivalent expression
\tcode{shared_ptr<T>(static_cast<T*>(r.get()))}
will eventually result in undefined behavior, attempting to delete the
same object twice. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{dynamic_pointer_cast}}%
\indexlibrary{\idxcode{dynamic_pointer_cast}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T, class U> shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  The expression \tcode{dynamic_cast<T*>(r.get())}
shall be well formed and shall have well defined behavior.

\pnum\returns
\begin{itemize}
\item When \tcode{dynamic_cast<T*>(r.get())} returns a nonzero value, a
  \tcode{shared_ptr<T>} object that stores a copy of it and \textit{shares
  ownership} with \tcode{r};

\item Otherwise, an \textit{empty} \tcode{shared_ptr<T>} object.
\end{itemize}

\pnum
\postcondition \tcode{w.get() == dynamic_cast<T*>(r.get())}, where \tcode{w} is the return value.

\pnum \enternote  The seemingly equivalent expression
\tcode{shared_ptr<T>(dynamic_cast<T*>(r.get()))} will eventually result in
undefined behavior, attempting to delete the same object twice. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{const_pointer_cast}}%
\indexlibrary{\idxcode{const_pointer_cast}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T, class U> shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  The expression \tcode{const_cast<T*>(r.get())} shall
be well formed.

\pnum\returns  If \tcode{r} is empty, an empty \tcode{shared_ptr<T>}; otherwise, a
\tcode{shared_ptr<T>} object that stores \tcode{const_cast<T*>(r.get())} and shares
ownership with \tcode{r}.

\pnum
\postconditions \tcode{w.get() == const_cast<T*>(r.get())} and
\tcode{w.use_count() == r.use_count()}, where \tcode{w} is the return value.

\pnum \enternote The seemingly equivalent expression
\tcode{shared_ptr<T>(const_cast<T*>(r.get()))} will eventually result in
undefined behavior, attempting to delete the same object twice. \exitnote
\end{itemdescr}

\rSec4[util.smartptr.getdeleter]{get_deleter}

\indexlibrary{\idxcode{shared_ptr}!\idxcode{get_deleter}}%
\indexlibrary{\idxcode{get_deleter}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  If \tcode{p} \textit{owns} a deleter \tcode{d} of type cv-unqualified
\tcode{D}, returns \tcode{\&d}; otherwise returns \tcode{nullptr}. The returned
pointer remains valid as long as there exists a \tcode{shared_ptr} instance
that owns \tcode{d}. \enternote It is unspecified whether the pointer
remains valid longer than that. This can happen if the implementation doesn't destroy
the deleter until all \tcode{weak_ptr} instances that share ownership with
\tcode{p} have been destroyed. \exitnote
\end{itemdescr}

\rSec4[util.smartptr.shared.io]{\tcode{shared_ptr} I/O}

\indexlibrary{\idxcode{operator<<}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<<}}%
\begin{itemdecl}
template<class E, class T, class Y>
  basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  \tcode{os <{}< p.get();}.

\pnum\returns  \tcode{os}.
\end{itemdescr}

\rSec3[util.smartptr.weak]{Class template \tcode{weak_ptr}}

\pnum
\indexlibrary{\idxcode{weak_ptr}}%
The \tcode{weak_ptr} class template stores a weak reference to an object
that is already managed by a \tcode{shared_ptr}. To access the object, a
\tcode{weak_ptr} can be converted to a \tcode{shared_ptr} using the member
function \tcode{lock}.

\begin{codeblock}
namespace std {
  template<class T> class weak_ptr {
  public:
    typedef T element_type;

    // \ref{util.smartptr.weak.const}, constructors
    constexpr weak_ptr() noexcept;
    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr&& r) noexcept;
    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept;

    // \ref{util.smartptr.weak.dest}, destructor
    ~weak_ptr();

    // \ref{util.smartptr.weak.assign}, assignment
    weak_ptr& operator=(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
    weak_ptr& operator=(weak_ptr&& r) noexcept;
    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;    

    // \ref{util.smartptr.weak.mod}, modifiers
    void swap(weak_ptr& r) noexcept;
    void reset() noexcept;

    // \ref{util.smartptr.weak.obs}, observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr<T> lock() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const;
    template<class U> bool owner_before(weak_ptr<U> const& b) const;
  };

  // \ref{util.smartptr.weak.spec}, specialized algorithms
  template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
} // namespace std
\end{codeblock}

\pnum
Specializations of \tcode{weak_ptr} shall be \tcode{CopyConstructible} and
\tcode{CopyAssignable}, allowing their use in standard
containers.  The template parameter \tcode{T} of \tcode{weak_ptr} may be an
incomplete type.

\rSec4[util.smartptr.weak.const]{\tcode{weak_ptr} constructors}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
constexpr weak_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs an \textit{empty} \tcode{weak_ptr} object.

\pnum\postconditions  \tcode{use_count() == 0}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
weak_ptr(const weak_ptr& r) noexcept;
template<class Y> weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remark The second and third constructors shall not participate in
overload resolution unless \tcode{Y*} is implicitly convertible to \tcode{T*}.

\pnum\effects  If \tcode{r} is \textit{empty}, constructs
an \textit{empty} \tcode{weak_ptr} object; otherwise, constructs
a \tcode{weak_ptr} object that \textit{shares ownership}
with \tcode{r} and stores a copy of the pointer stored in \tcode{r}.

\pnum\postconditions  \tcode{use_count() == r.use_count()}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
weak_ptr(weak_ptr&& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remark The second constructor shall not participate in overload resolution unless
\tcode{Y*} is implicitly convertible to \tcode{T*}.

\pnum\effects Move-constructs a \tcode{weak_ptr} instance from \tcode{r}.

\pnum\postconditions \tcode{*this} shall contain the old value of \tcode{r}.
\tcode{r} shall be \textit{empty}. \tcode{r.use_count() == 0}.
\end{itemdescr}

\rSec4[util.smartptr.weak.dest]{\tcode{weak_ptr} destructor}

\indexlibrary{\idxcode{weak_ptr}!destructor}%
\begin{itemdecl}
~weak_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Destroys this \tcode{weak_ptr} object but has no
effect on the object its stored pointer points to.
\end{itemdescr}

\rSec4[util.smartptr.weak.assign]{\tcode{weak_ptr} assignment}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{weak_ptr}}%
\begin{itemdecl}
weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr(r).swap(*this)}.

\pnum\notes  The implementation may meet the effects (and the
implied guarantees) via different means, without creating a temporary.

\pnum\returns  \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{weak_ptr}}%
\begin{itemdecl}
weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr(std::move(r)).swap(*this)}.

\pnum\returns  \tcode{*this}.
\end{itemdescr}

\rSec4[util.smartptr.weak.mod]{\tcode{weak_ptr} modifiers}
\indexlibrary{\idxcode{weak_ptr}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{weak_ptr}}%
\begin{itemdecl}
void swap(weak_ptr& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Exchanges the contents of \tcode{*this} and \tcode{r}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{reset}}%
\indexlibrary{\idxcode{reset}!\idxcode{weak_ptr}}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr().swap(*this)}.
\end{itemdescr}

\rSec4[util.smartptr.weak.obs]{\tcode{weak_ptr} observers}
\indexlibrary{\idxcode{weak_ptr}!\idxcode{use_count}}%
\indexlibrary{\idxcode{use_count}!\idxcode{weak_ptr}}%
\begin{itemdecl}
long use_count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{0} if \tcode{*this} is \textit{empty};
otherwise, the number of \tcode{shared_ptr} instances
that \textit{share ownership} with \tcode{*this}.

\pnum \enternote \tcode{use_count()} is not necessarily
efficient.\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{expired}}%
\indexlibrary{\idxcode{expired}!\idxcode{weak_ptr}}%
\begin{itemdecl}
bool expired() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{use_count() == 0}.

\pnum \enternote  \tcode{expired()} may be faster
than \tcode{use_count()}. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{lock}}%
\indexlibrary{\idxcode{lock}!\idxcode{weak_ptr}}%
\begin{itemdecl}
shared_ptr<T> lock() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{expired() ? shared_ptr<T>() : shared_ptr<T>(*this)}, executed atomically.
\end{itemdescr}

\indexlibrary{\idxcode{owner_before}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{owner_before}}%
\begin{itemdecl}
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An unspecified value such that

\begin{itemize}
\item \tcode{x.owner_before(y)} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{owner_before},
\tcode{!a.owner_before(b) \&\& !b.owner_before(a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or are
both empty.
\end{itemize}
\end{itemdescr}


\rSec4[util.smartptr.weak.spec]{\tcode{weak_ptr} specialized algorithms}

\indexlibrary{\idxcode{weak_ptr}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{weak_ptr}}%
\begin{itemdecl}
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{a.swap(b)}.
\end{itemdescr}

\rSec3[util.smartptr.ownerless]{Class template \tcode{owner_less}}

\pnum
The class template \tcode{owner_less} allows ownership-based mixed comparisons of shared
and weak pointers.

\begin{codeblock}
namespace std {
  template<class T> struct owner_less;

  template<class T> struct owner_less<shared_ptr<T> > {
    typedef bool result_type;
    typedef shared_ptr<T> first_argument_type;
    typedef shared_ptr<T> second_argument_type;
    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
  };

  template<class T> struct owner_less<weak_ptr<T> > {
    typedef bool result_type;
    typedef weak_ptr<T> first_argument_type;
    typedef weak_ptr<T> second_argument_type;
    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
  };
}
\end{codeblock}

\pnum \tcode{operator()(x,y)} shall return \tcode{x.owner_before(y)}. \enternote
Note that

\begin{itemize}
\item \tcode{operator()} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{operator()},
\tcode{!operator()(a, b) \&\& !operator()(b, a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or are
both empty.
\end{itemize} \exitnote

\rSec3[util.smartptr.enab]{Class template \tcode{enable_shared_from_this}}

\pnum
\indexlibrary{\idxcode{enable_shared_from_this}}%
A class \tcode{T} can inherit from \tcode{enable_shared_from_this<T>}
to inherit the \tcode{shared_from_this} member functions that obtain
a \textit{shared_ptr} instance pointing to \tcode{*this}.

\pnum
\enterexample

\begin{codeblock}
struct X: public enable_shared_from_this<X> {
};

int main() {
  shared_ptr<X> p(new X);
  shared_ptr<X> q = p->shared_from_this();
  assert(p == q);
  assert(!(p < q ) && !(q < p)); // p and q share ownership
}
\end{codeblock}
\exitexample

\begin{codeblock}
namespace std {
  template<class T> class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(enable_shared_from_this const&) noexcept;
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
    ~enable_shared_from_this();
  public:
    shared_ptr<T> shared_from_this();
    shared_ptr<T const> shared_from_this() const;
  };
} // namespace std
\end{codeblock}

\pnum
The template parameter \tcode{T} of \tcode{enable_shared_from_this}
may be an incomplete type.

\indexlibrary{\idxcode{enable_shared_from_this}!constructor}%
\begin{itemdecl}
constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs an \tcode{enable_shared_from_this<T>} object.
\end{itemdescr}

\indexlibrary{\idxcode{enable_shared_from_this}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{enable_shared_from_this}}%
\begin{itemdecl}
enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{enable_shared_from_this}!destructor}
\begin{itemdecl}
~enable_shared_from_this();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Destroys \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{enable_shared_from_this}!\idxcode{shared_from_this}}%
\indexlibrary{\idxcode{shared_from_this}!\idxcode{enable_shared_from_this}}%
\begin{itemdecl}
shared_ptr<T>       shared_from_this();
shared_ptr<T const> shared_from_this() const;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{enable_shared_from_this<T>} shall be an accessible base
class of \tcode{T}. \tcode{*this} shall be a subobject of an object \tcode{t} of
type \tcode{T}. There shall be at least one \tcode{shared_ptr} instance \tcode{p}
that \textit{owns} \tcode{\&t}.

\pnum\returns  A \tcode{shared_ptr<T>} object \tcode{r}
that \textit{shares ownership with} \tcode{p}.

\pnum\postconditions  \tcode{r.get() == this}.
\end{itemdescr}

\pnum
\enternote A possible implementation is shown below:
\begin{codeblock}
template<class T> class enable_shared_from_this {
private:
  weak_ptr<T> __weak_this;
protected:
  constexpr enable_shared_from_this() : __weak_this() { }
  enable_shared_from_this(enable_shared_from_this const &) { }
  enable_shared_from_this& operator=(enable_shared_from_this const &) { return *this; }
  ~enable_shared_from_this() { }
public:
  shared_ptr<T> shared_from_this() { return shared_ptr<T>(__weak_this); }
  shared_ptr<T const> shared_from_this() const { return shared_ptr<T const>(__weak_this); }
};
\end{codeblock}

\pnum
The \tcode{shared_ptr} constructors that create unique pointers
can detect the presence of an \tcode{enable_shared_from_this} base and
assign the newly created \tcode{shared_ptr} to its \tcode{__weak_this}
member. \exitnote

\rSec3[util.smartptr.shared.atomic]{\tcode{shared_ptr} atomic access}

\pnum
Concurrent access to a \tcode{shared_ptr} object from multiple threads does not
introduce a data race if the access is done exclusively via the functions in
this section and the instance is passed as their first argument.

\pnum
The meaning of the arguments of type \tcode{memory_order} is explained in~\ref{atomics.order}.

\indexlibrary{\idxcode{atomic_is_lock_free}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_is_lock_free}}%
\begin{itemdecl}
template<class T>
  bool atomic_is_lock_free(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{true} if atomic access to \tcode{*p} is lock-free, \tcode{false} otherwise.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_load}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_load}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_load(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_load_explicit(p, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_load_explicit}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_load_explicit}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_release} or \tcode{memory_order_acq_rel}.

\pnum
\returns \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_store}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_store}}%
\begin{itemdecl}
template<class T>
  void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects \tcode{atomic_store_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_store_explicit}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_store_explicit}}%
\begin{itemdecl}
template<class T>
  void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_acquire} or \tcode{memory_order_acq_rel}.

\pnum
\effects \tcode{p->swap(r)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_exchange}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_exchange}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_exchange_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_exchange_explicit}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_exchange_explicit}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,
                                         memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects \tcode{p->swap(r)}.

\pnum
\returns The previous value of \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_compare_exchange_weak}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_compare_exchange_weak}}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.

\pnum
\returns \tcode{atomic_compare_exchange_weak_explicit(p, v, w,
memory_order_seq_cst, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_compare_exchange_strong}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{atomic_compare_exchange_strong}}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_strong(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{atomic_compare_exchange_strong_explicit(p, v, w,}
\tcode{memory_order_seq_cst, memory_order_seq_cst)}.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_compare_exchange_weak_explicit}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!atomic_compare_exchange_weak_explicit@\tcode{atomic_compare_exchange_weak_-\\explicit}}%
\indexlibrary{\idxcode{atomic_compare_exchange_strong_explicit}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!atomic_compare_exchange_strong_explicit@\tcode{atomic_compare_exchange_strong_-\\explicit}}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
template<class T>
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.

\pnum
\requires \tcode{failure} shall not be \tcode{memory_order_release},
\tcode{memory_order_acq_rel}, or stronger than \tcode{success}.

\pnum
\effects If \tcode{*p} is equivalent to \tcode{*v}, assigns \tcode{w} to
\tcode{*p} and has synchronization semantics corresponding to the value of
\tcode{success}, otherwise assigns \tcode{*p} to \tcode{*v} and has
synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns \tcode{true} if \tcode{*p} was equivalent to \tcode{*v}, \tcode{false} otherwise.

\pnum
\throws Nothing.

\pnum
\remarks two \tcode{shared_ptr} objects are equivalent if they store the same
pointer value and share ownership.

\pnum
\remarks the weak forms may fail spuriously. See~\ref{atomics.types.operations}.
\end{itemdescr}

\rSec3[util.smartptr.hash]{Smart pointer hash support}

\indexlibrary{\idxcode{hash}}%
\begin{itemdecl}
template <class T, class D> struct hash<unique_ptr<T, D> >;
\end{itemdecl}

\begin{itemdescr}
\pnum The template specialization shall meet the requirements of class
template \tcode{hash}~(\ref{unord.hash}). For an object \tcode{p} of type \tcode{UP},
where \tcode{UP} is \tcode{unique_ptr<T, D>}, \tcode{hash<UP>()(p)} shall evaluate to
the same value as \tcode{hash<typename UP::pointer>()(p.get())}.

\pnum
\requires The specialization \tcode{hash<typename UP::pointer>} shall be
well-formed and well-defined, and shall meet the requirements of class
template \tcode{hash}~(\ref{unord.hash}).
\end{itemdescr}

\indexlibrary{\idxcode{hash}}%
\begin{itemdecl}
template <class T> struct hash<shared_ptr<T> >;
\end{itemdecl}

\begin{itemdescr}
\pnum
The template specialization shall meet the requirements of class
template \tcode{hash}~(\ref{unord.hash}). For an object \tcode{p} of type \tcode{shared_ptr<T>},
\tcode{hash<shared_ptr<T> >()(p)} shall evaluate to
the same value as \tcode{hash<T*>()(p.get())}.
\end{itemdescr}%
\indextext{smart pointers|)}

\rSec1[function.objects]{Function objects}

\pnum
A \indexdefn{function object!type}\term{function object type} is an object
type~(\ref{basic.types}) that can be the type of the
\grammarterm{postfix-expression} in a function call
(\ref{expr.call},~\ref{over.match.call}).\footnote{Such a type is a function
pointer or a class type which has a member \tcode{operator()} or a class type
which has a conversion to a pointer to function.} A \defn{function object} is an
object of a function object type. In the places where one would expect to pass a
pointer to a function to an algorithmic template (Clause~\ref{algorithms}), the
interface is specified to accept a function object. This not only makes
algorithmic templates work with pointers to functions, but also enables them to
work with arbitrary function objects.

\pnum
\synopsis{Header \tcode{<functional>} synopsis}

\indexlibrary{\idxhdr{functional}}%
\begin{codeblock}
namespace std {
  // \ref{depr.base}, base (deprecated):
  template <class Arg, class Result> struct unary_function;
  template <class Arg1, class Arg2, class Result> struct binary_function;

  // \ref{refwrap}, reference_wrapper:
  template <class T> class reference_wrapper;

  template <class T> reference_wrapper<T> ref(T&) noexcept;
  template <class T> reference_wrapper<const T> cref(const T&) noexcept;
  template <class T> void ref(const T&&) = delete;
  template <class T> void cref(const T&&) = delete;

  template <class T> reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
  template <class T> reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;

  // \ref{arithmetic.operations}, arithmetic operations:
  template <class T = void> struct plus;
  template <class T = void> struct minus;
  template <class T = void> struct multiplies;
  template <class T = void> struct divides;
  template <class T = void> struct modulus;
  template <class T = void> struct negate;
  template <> struct plus<void>;
  template <> struct minus<void>;
  template <> struct multiplies<void>;
  template <> struct divides<void>;
  template <> struct modulus<void>;
  template <> struct negate<void>;

  // \ref{comparisons}, comparisons:
  template <class T = void> struct equal_to;
  template <class T = void> struct not_equal_to;
  template <class T = void> struct greater;
  template <class T = void> struct less;
  template <class T = void> struct greater_equal;
  template <class T = void> struct less_equal;
  template <> struct equal_to<void>;
  template <> struct not_equal_to<void>;
  template <> struct greater<void>;
  template <> struct less<void>;
  template <> struct greater_equal<void>;
  template <> struct less_equal<void>;

  // \ref{logical.operations}, logical operations:
  template <class T = void> struct logical_and;
  template <class T = void> struct logical_or;
  template <class T = void> struct logical_not;
  template <> struct logical_and<void>;
  template <> struct logical_or<void>;
  template <> struct logical_not<void>;

  // \ref{bitwise.operations}, bitwise operations:
  template <class T = void> struct bit_and;
  template <class T = void> struct bit_or;
  template <class T = void> struct bit_xor;
  template <class T = void> struct bit_not;
  template <> struct bit_and<void>;
  template <> struct bit_or<void>;
  template <> struct bit_xor<void>;
  template <> struct bit_not<void>;

  // \ref{negators}, negators:
  template <class Predicate> class unary_negate;
  template <class Predicate>
    constexpr unary_negate<Predicate> not1(const Predicate&);
  template <class Predicate> class binary_negate;
  template <class Predicate>
    constexpr binary_negate<Predicate> not2(const Predicate&);

  // \ref{func.bind}, bind:
  template<class T> struct is_bind_expression;
  template<class T> struct is_placeholder;

  template<class F, class... BoundArgs>
    @\unspec@ bind(F&&, BoundArgs&&...);
  template<class R, class F, class... BoundArgs>
    @\unspec@ bind(F&&, BoundArgs&&...);

  namespace placeholders {
    // M is the implementation-defined number of placeholders
    extern @\unspec@ _1;
    extern @\unspec@ _2;
                .
                .
                .
    extern @\unspec@ _M;
  }

  // \ref{depr.lib.binders}, binders (deprecated):
  template <class Fn> class binder1st;
  template <class Fn, class T>
    binder1st<Fn> bind1st(const Fn&, const T&);
  template <class Fn> class binder2nd;
  template <class Fn, class T>
    binder2nd<Fn> bind2nd(const Fn&, const T&);

  // \ref{depr.function.pointer.adaptors}, adaptors (deprecated):
  template <class Arg, class Result> class pointer_to_unary_function;
  template <class Arg, class Result>
    pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
  template <class Arg1, class Arg2, class Result>
    class pointer_to_binary_function;
  template <class Arg1, class Arg2, class Result>
    pointer_to_binary_function<Arg1,Arg2,Result>
      ptr_fun(Result (*)(Arg1,Arg2));

  // \ref{depr.member.pointer.adaptors}, adaptors (deprecated):
  template<class S, class T> class mem_fun_t;
  template<class S, class T, class A> class mem_fun1_t;
  template<class S, class T>
      mem_fun_t<S,T> mem_fun(S (T::*f)());
  template<class S, class T, class A>
      mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
  template<class S, class T> class mem_fun_ref_t;
  template<class S, class T, class A> class mem_fun1_ref_t;
  template<class S, class T>
      mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
  template<class S, class T, class A>
      mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

  template <class S, class T> class const_mem_fun_t;
  template <class S, class T, class A> class const_mem_fun1_t;
  template <class S, class T>
    const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
  template <class S, class T, class A>
    const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
  template <class S, class T> class const_mem_fun_ref_t;
  template <class S, class T, class A> class const_mem_fun1_ref_t;
  template <class S, class T>
    const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
  template <class S, class T, class A>
    const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);

  // \ref{func.memfn}, member function adaptors:
  template<class R, class T> @\unspec@ mem_fn(R T::*);

  // \ref{func.wrap} polymorphic function wrappers:
  class bad_function_call;

  template<class> class function; // undefined
  template<class R, class... ArgTypes> class function<R(ArgTypes...)>;

  template<class R, class... ArgTypes>
    void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);

  template<class R, class... ArgTypes>
    bool operator==(const function<R(ArgTypes...)>&, nullptr_t);
  template<class R, class... ArgTypes>
    bool operator==(nullptr_t, const function<R(ArgTypes...)>&);
  template<class R, class... ArgTypes>
    bool operator!=(const function<R(ArgTypes...)>&, nullptr_t);
  template<class R, class... ArgTypes>
    bool operator!=(nullptr_t, const function<R(ArgTypes...)>&);

  // \ref{unord.hash}, hash function primary template:
  template <class T> struct hash;

  // Hash function specializations
  template <> struct hash<bool>;
  template <> struct hash<char>;
  template <> struct hash<signed char>;
  template <> struct hash<unsigned char>;
  template <> struct hash<char16_t>;
  template <> struct hash<char32_t>;
  template <> struct hash<wchar_t>;
  template <> struct hash<short>;
  template <> struct hash<unsigned short>;
  template <> struct hash<int>;
  template <> struct hash<unsigned int>;
  template <> struct hash<long>;
  template <> struct hash<long long>;
  template <> struct hash<unsigned long>;
  template <> struct hash<unsigned long long>;

  template <> struct hash<float>;
  template <> struct hash<double>;
  template <> struct hash<long double>;

  template<class T> struct hash<T*>;
}
\end{codeblock}

\pnum
\enterexample
If a \Cpp program wants to have a by-element addition of two vectors \tcode{a}
and \tcode{b} containing \tcode{double} and put the result into \tcode{a},
it can do:

\begin{codeblock}
transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
\end{codeblock}
\exitexample

\pnum
\enterexample
To negate every element of \tcode{a}:

\begin{codeblock}
transform(a.begin(), a.end(), a.begin(), negate<double>());
\end{codeblock}

\exitexample

\pnum
\enternote
To enable adaptors and other components to manipulate function objects that
take one or two arguments many of the function objects in this clause
correspondingly provide typedefs
\tcode{argument_type}
and
\tcode{result_type}
for function objects that take one argument and \tcode{first_argument_type},
\tcode{second_argument_type}, and \tcode{result_type} for function objects
that take two arguments.
\exitnote

\rSec2[func.def]{Definitions}

\pnum
The following definitions apply to this Clause:

\pnum
\indexdefn{call signature}%
A \term{call signature} is the name of a return type followed by a
parenthesized comma-separated list of zero or more argument types.

\pnum
\indexdefn{callable type}%
A \term{callable type} is a function object type~(\ref{function.objects}) or a pointer to member.

\pnum
\indexdefn{callable object}%
A \term{callable object} is an object of a callable type.

\pnum
\indexdefn{call wrapper!type}%
A \term{call wrapper type} is a type that holds a callable object
and supports a call operation that forwards to that object.

\pnum
\indexdefn{call wrapper}%
A \term{call wrapper} is an object of a call wrapper type.

\pnum
\indexdefn{target object}%
A \term{target object} is the callable object held by a call wrapper.

\rSec2[func.require]{Requirements}

\pnum
\indexlibrary{invoke@\tcode{\textit{INVOKE}}}%
Define \tcode{\textit{INVOKE}(f, t1, t2, ..., tN)} as follows:

\begin{itemize}
\item \tcode{(t1.*f)(t2, ..., tN)} when \tcode{f} is a pointer to a
member function of a class \tcode{T} and \tcode{t1} is an object of
type \tcode{T} or a reference to an object of type \tcode{T} or a
reference to an object of a type derived from \tcode{T};

\item \tcode{((*t1).*f)(t2, ..., tN)} when \tcode{f} is a pointer to a
member function of a class \tcode{T} and \tcode{t1} is not one of the
types described in the previous item;

\item \tcode{t1.*f} when \tcode{N == 1} and
\tcode{f} is a pointer to member data of a
class \tcode{T} and \tcode{t1} is an object of type \tcode{T} or a
reference to an object of type \tcode{T} or a reference to an object
of a type derived from \tcode{T};

\item \tcode{(*t1).*f} when \tcode{N == 1} and
\tcode{f} is a pointer to member data of a
class \tcode{T} and \tcode{t1} is not one of the types described in
the previous item;

\item \tcode{f(t1, t2, ..., tN)} in all other cases.
\end{itemize}

\pnum
\indexlibrary{invoke@\tcode{\textit{INVOKE}}}%
Define \tcode{\textit{INVOKE}(f, t1, t2, ..., tN, R)} as
\tcode{\textit{INVOKE}(f, t1, t2, ..., tN)} implicitly converted
to \tcode{R}.

\pnum
\indextext{weak result type}%
\indextext{call wrapper}%
\indextext{target object}%
If a call wrapper~(\ref{func.def}) has a \textit{weak result type}
the type of its member type \tcode{result_type} is based on the
type \tcode{T} of the wrapper's target object~(\ref{func.def}):
\begin{itemize}
\item
if \tcode{T} is a pointer to
function type, \tcode{result_type} shall be a synonym for the return
type of \tcode{T};

\item
if \tcode{T} is a pointer to member function, \tcode{result_type}
shall be a synonym for the return type of \tcode{T};

\item
if \tcode{T} is a class type with a member type \tcode{result_type},
then \tcode{result_type} shall be a synonym for \tcode{T::result_type};

\item
otherwise \tcode{result_type} shall not be defined.
\end{itemize}

\pnum
\indextext{call wrapper}%
\indextext{call wrapper!simple}%
\indextext{call wrapper!forwarding}%
\indextext{simple call wrapper}%
\indextext{forwarding call wrapper}%
Every call wrapper~(\ref{func.def}) shall be
\tcode{MoveConstructible}. A \term{simple call wrapper} is a call wrapper
that is \tcode{CopyConstructible} and \tcode{CopyAssignable} and whose copy
constructor, move constructor, and assignment operator
do not throw exceptions. A \term{forwarding call wrapper} is a
call wrapper that can be called with an arbitrary argument list
and delivers the arguments to the wrapped callable object as references.
This forwarding step shall ensure that rvalue arguments are delivered as rvalue-references
and lvalue arguments are delivered as lvalue-references.
\enternote In a typical implementation
forwarding call wrappers have an overloaded function call
operator of
the form

\begin{codeblock}
template<class... UnBoundArgs>
R operator()(UnBoundArgs&&... unbound_args) @\textit{cv-qual}@;
\end{codeblock}
\exitnote

\rSec2[refwrap]{Class template \tcode{reference_wrapper}}

\indexlibrary{\idxcode{reference_wrapper}}%
\indextext{function object!\idxcode{reference_wrapper}}%
\indextext{unary function}%
\indextext{binary function}%
\begin{codeblock}
namespace std {
  template <class T> class reference_wrapper {
  public :
    // types
    typedef T type;
    typedef @\seebelow@ result_type;               // not always defined
    typedef @\seebelow@ argument_type;             // not always defined
    typedef @\seebelow@ first_argument_type;       // not always defined
    typedef @\seebelow@ second_argument_type;      // not always defined

    // construct/copy/destroy
    reference_wrapper(T&) noexcept;
    reference_wrapper(T&&) = delete;     // do not bind to temporary objects
    reference_wrapper(const reference_wrapper& x) noexcept;

    // assignment
    reference_wrapper& operator=(const reference_wrapper& x) noexcept;

    // access
    operator T& () const noexcept;
    T& get() const noexcept;

    // invocation
    template <class... ArgTypes>
    result_of_t<T&(ArgTypes&&...)>
    operator() (ArgTypes&&...) const;
  };
}
\end{codeblock}

\pnum
\tcode{reference_wrapper<T>} is a \tcode{CopyConstructible} and \tcode{CopyAssignable} wrapper
around a reference to an object or function of type \tcode{T}.

\pnum
\tcode{reference_wrapper<T>} has a weak result type~(\ref{func.require}).
If \tcode{T} is a function type, \tcode{result_type} shall be a synonym for the
return type of \tcode{T}.

\pnum\indexlibrary{\idxcode{unary_function}}%
The template specialization \tcode{reference_wrapper<T>} shall
define a nested type named \tcode{argument_type} as a synonym for \tcode{T1}
only if the type \tcode{T} is any of the
following:

\begin{itemize}
\item
a function type or a pointer to function type taking one argument of type \tcode{T1}

\item
a pointer to member function \tcode{R T0::f} \textit{cv} (where \textit{cv} represents the
member function's cv-qualifiers); the type \tcode{T1} is \textit{cv} \tcode{T0*}

\item
a class type with a member type \tcode{argument_type}; the type \tcode{T1} is
\tcode{T::argument_type}.
\end{itemize}

\indexlibrary{\idxcode{binary_function}}%
\pnum
The template instantiation \tcode{reference_wrapper<T>} shall
define two nested types named \tcode{first_argument_type} and \tcode{second_argument_type}
as synonyms for \tcode{T1} and \tcode{T2}, respectively,
only if the type
\tcode{T} is any of the following:

\begin{itemize}
\item
a function type or a pointer to function type taking two arguments of types \tcode{T1} and
\tcode{T2}

\item
a pointer to member function \tcode{R T0::f(T2)} \textit{cv} (where \textit{cv} represents the
member function's cv-qualifiers); the type \tcode{T1} is \textit{cv} \tcode{T0*}

\item
a class type with member types \tcode{first_argument_type} and
\tcode{second_argument_type};
the type \tcode{T1} is \tcode{T::first_argument_type}
and the type \tcode{T2} is \tcode{T::second_argument_type}.

\end{itemize}

\rSec3[refwrap.const]{\tcode{reference_wrapper} construct/copy/destroy}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
reference_wrapper(T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{reference_wrapper} object that stores a
reference to \tcode{t}.
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
reference_wrapper(const reference_wrapper& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Constructs a \tcode{reference_wrapper} object that
stores a reference to \tcode{x.get()}.
\end{itemdescr}

\rSec3[refwrap.assign]{\tcode{reference_wrapper} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{reference_wrapper}}
\indexlibrary{\idxcode{reference_wrapper}!\idxcode{operator=}}
\begin{itemdecl}
reference_wrapper& operator=(const reference_wrapper& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions \tcode{*this} stores a reference to  \tcode{x.get()}.
\end{itemdescr}

\rSec3[refwrap.access]{\tcode{reference_wrapper} access}

\indexlibrary{\idxcode{operator T\&}!\idxcode{reference_wrapper}}
\indexlibrary{\idxcode{reference_wrapper}!\idxcode{operator T\&}}
\begin{itemdecl}
operator T& () const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns The stored reference.
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{get}}%
\indexlibrary{\idxcode{get}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
T& get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns The stored reference.
\end{itemdescr}


\rSec3[refwrap.invoke]{reference_wrapper invocation}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{operator()}}%
\indexlibrary{\idxcode{operator()}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
template <class... ArgTypes>
  result_of_t<T&(ArgTypes&&... )>
    operator()(ArgTypes&&... args) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{\textit{INVOKE}(get(), std::forward<ArgTypes>(args)...)}.~(\ref{func.require})

\pnum\note \tcode{operator()} is described for exposition only.
Implementations are not required to provide an actual
\tcode{reference_wrapper::operator()}.  Implementations are
permitted to support \tcode{reference_wrapper} function invocation
through multiple overloaded operators or through other means.

\end{itemdescr}


\rSec3[refwrap.helpers]{reference_wrapper helper functions}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{ref}}%
\indexlibrary{\idxcode{ref}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
template <class T> reference_wrapper<T> ref(T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{reference_wrapper<T>(t)}
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{ref}}%
\indexlibrary{\idxcode{ref}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
template <class T> reference_wrapper<T> ref(reference_wrapper<T> t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{ref(t.get())}
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{cref}}%
\indexlibrary{\idxcode{cref}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{reference_wrapper <const T>(t)}
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!\idxcode{cref}}%
\indexlibrary{\idxcode{cref}!\idxcode{reference_wrapper}}%
\begin{itemdecl}
template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{cref(t.get());}
\end{itemdescr}

\rSec2[arithmetic.operations]{Arithmetic operations}

\pnum
The library provides basic function object classes for all of the arithmetic
operators in the language~(\ref{expr.mul}, \ref{expr.add}).

\indexlibrary{\idxcode{plus}}%
\begin{itemdecl}
template <class T = void> struct plus {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x + y}.
\end{itemdescr}

\indexlibrary{\idxcode{minus}}%
\begin{itemdecl}
template <class T = void> struct minus {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x - y}.
\end{itemdescr}

\indexlibrary{\idxcode{multiplies}}%
\begin{itemdecl}
template <class T = void> struct multiplies {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x * y}.
\end{itemdescr}

\indexlibrary{\idxcode{divides}}%
\begin{itemdecl}
template <class T = void> struct divides {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x / y}.
\end{itemdescr}

\indexlibrary{\idxcode{modulus}}%
\begin{itemdecl}
template <class T = void> struct modulus {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \% y}.
\end{itemdescr}

\indexlibrary{\idxcode{negate}}%
\begin{itemdecl}
template <class T = void> struct negate {
  constexpr T operator()(const T& x) const;
  typedef T argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{-x}.
\end{itemdescr}

\indexlibrary{\idxcode{plus<>}}%
\begin{itemdecl}
template <> struct plus<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) + std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) + std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{minus<>}}%
\begin{itemdecl}
template <> struct minus<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) - std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) - std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{multiplies<>}}%
\begin{itemdecl}
template <> struct multiplies<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) * std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) * std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{divides<>}}%
\begin{itemdecl}
template <> struct divides<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) / std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) / std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{modulus<>}}%
\begin{itemdecl}
template <> struct modulus<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) % std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) \% std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{negate<>}}%
\begin{itemdecl}
template <> struct negate<void> {
  template <class T> constexpr auto operator()(T&& t) const
    -> decltype(-std::forward<T>(t));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{-std::forward<T>(t)}.
\end{itemdescr}


\rSec2[comparisons]{Comparisons}

\pnum
The library provides basic function object classes for all of the comparison
operators in the language~(\ref{expr.rel}, \ref{expr.eq}).

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template <class T = void> struct equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x == y}.
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template <class T = void> struct not_equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x != y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template <class T = void> struct greater {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x > y}.
\end{itemdescr}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template <class T = void> struct less {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x < y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template <class T = void> struct greater_equal {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x >= y}.
\end{itemdescr}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template <class T = void> struct less_equal {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x <= y}.
\end{itemdescr}

\indexlibrary{\idxcode{equal_to<>}}%
\begin{itemdecl}
template <> struct equal_to<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) == std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) == std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to<>}}%
\begin{itemdecl}
template <> struct not_equal_to<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) != std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) != std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{greater<>}}%
\begin{itemdecl}
template <> struct greater<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) > std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) > std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{less<>}}%
\begin{itemdecl}
template <> struct less<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) < std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) < std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal<>}}%
\begin{itemdecl}
template <> struct greater_equal<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) >= std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) >= std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{less_equal<>}}%
\begin{itemdecl}
template <> struct less_equal<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) <= std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) <= std::forward<U>(u)}.
\end{itemdescr}

\pnum
For templates \tcode{greater}, \tcode{less}, \tcode{greater_equal}, and
\tcode{less_equal}, the specializations for any pointer type yield a total order,
even if the built-in operators \tcode{<}, \tcode{>}, \tcode{<=}, \tcode{>=}
do not.

\rSec2[logical.operations]{Logical operations}

\pnum
The library provides basic function object classes for all of the logical
operators in the language~(\ref{expr.log.and}, \ref{expr.log.or}, \ref{expr.unary.op}).

\indexlibrary{\idxcode{logical_and}}%
\begin{itemdecl}
template <class T = void> struct logical_and {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \&\& y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_or}}%
\begin{itemdecl}
template <class T = void> struct logical_or {
  constexpr bool operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x || y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_not}}%
\begin{itemdecl}
template <class T = void> struct logical_not {
  constexpr bool operator()(const T& x) const;
  typedef T argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!x}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_and<>}}%
\begin{itemdecl}
template <> struct logical_and<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) && std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) \&\& std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_or<>}}%
\begin{itemdecl}
template <> struct logical_or<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) || std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) || std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_not<>}}%
\begin{itemdecl}
template <> struct logical_not<void> {
  template <class T> constexpr auto operator()(T&& t) const
    -> decltype(!std::forward<T>(t));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!std::forward<T>(t)}.
\end{itemdescr}


\rSec2[bitwise.operations]{Bitwise operations}

\pnum
The library provides basic function object classes for all of the bitwise
operators in the language~(\ref{expr.bit.and}, \ref{expr.or},
\ref{expr.xor}, \ref{expr.unary.op}).

\indexlibrary{\idxcode{bit_and}}%
\begin{itemdecl}
template <class T = void> struct bit_and {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \& y}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_or}}%
\begin{itemdecl}
template <class T = void> struct bit_or {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x | y}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_xor}}%
\begin{itemdecl}
template <class T = void> struct bit_xor {
  constexpr T operator()(const T& x, const T& y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \^{} y}.
\end{itemdescr}

\begin{itemdecl}
template <class T = void> struct bit_not {
  constexpr T operator()(const T& x) const;
  typedef T argument_type;
  typedef T result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\~{}x}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_and<>}}%
\begin{itemdecl}
template <> struct bit_and<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) & std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) \& std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_or<>}}%
\begin{itemdecl}
template <> struct bit_or<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) | std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) | std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_xor<>}}%
\begin{itemdecl}
template <> struct bit_xor<void> {
  template <class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) ^ std::forward<U>(u));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{std::forward<T>(t) \^{} std::forward<U>(u)}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_not<>}}%
\begin{itemdecl}
template <> struct bit_not<void> {
  template <class T> constexpr auto operator()(T&& t) const
    -> decltype(~std::forward<T>(t));

  typedef @\unspec@ is_transparent;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\~{}std::forward<T>(t)}.
\end{itemdescr}

\rSec2[negators]{Negators}

\pnum
Negators \tcode{not1} and \tcode{not2} take a unary and a binary predicate,
respectively, and return their complements~(\ref{expr.unary.op}).

\indexlibrary{\idxcode{unary_negate}}%
\begin{itemdecl}
template <class Predicate>
  class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::argument_type& x) const;
  typedef typename Predicate::argument_type argument_type;
  typedef bool result_type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!pred(x)}.
\end{itemdescr}

\indexlibrary{\idxcode{not1}}%
\begin{itemdecl}
template <class Predicate>
  constexpr unary_negate<Predicate> not1(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{unary_negate<Predicate>(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{binary_negate}}%
\begin{itemdecl}
template <class Predicate>
  class binary_negate {
  public:
    constexpr explicit binary_negate(const Predicate& pred);
    constexpr bool operator()(const typename Predicate::first_argument_type& x,
        const typename Predicate::second_argument_type& y) const;
  typedef typename Predicate::first_argument_type first_argument_type;
  typedef typename Predicate::second_argument_type second_argument_type;
  typedef bool result_type;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!pred(x,y)}.
\end{itemdescr}

\indexlibrary{\idxcode{not2}}%
\begin{itemdecl}
template <class Predicate>
  constexpr binary_negate<Predicate> not2(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{binary_negate<Predicate>(pred)}.
\end{itemdescr}

\rSec2[func.bind]{Function object binders}%
\indextext{function object!binders|(}

\pnum
This subclause describes a uniform mechanism for binding
arguments of callable objects.

\rSec3[func.bind.isbind]{Class template \tcode{is_bind_expression}}

\indexlibrary{\idxcode{is_bind_expression}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_bind_expression; // see below
}
\end{codeblock}

\pnum
\tcode{is_bind_expression} can be used to detect function objects
generated by \tcode{bind}. \tcode{bind}
uses \tcode{is_bind_expression} to detect subexpressions.

\pnum
Instantiations of the \tcode{is_bind_expression} template shall meet
the UnaryTypeTrait requirements~(\ref{meta.rqmts}). The implementation
shall provide a definition that has a BaseCharacteristic of
\tcode{true_type} if \tcode{T} is a type returned from \tcode{bind},
otherwise it shall have a BaseCharacteristic of \tcode{false_type}.
A program may specialize this template for a user-defined type \tcode{T}
to have a BaseCharacteristic of \tcode{true_type} to indicate that
\tcode{T} should be treated as a subexpression in a \tcode{bind} call.

\rSec3[func.bind.isplace]{Class template \tcode{is_placeholder}}

\indexlibrary{\idxcode{is_placeholder}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_placeholder; // see below
}
\end{codeblock}

\pnum
\tcode{is_placeholder} can be used to detect the standard placeholders
\tcode{_1}, \tcode{_2}, and so on. \tcode{bind} uses
\tcode{is_placeholder} to detect placeholders.

\pnum
Instantiations of the \tcode{is_placeholder} template shall meet
the UnaryTypeTrait requirements~(\ref{meta.rqmts}). The implementation
shall provide a definition that has the BaseCharacteristic of
\tcode{integral_constant<int, J>} if \tcode{T} is the type of
\tcode{std::placeholders::_J}, otherwise it shall have a
BaseCharacteristic of \tcode{integral_constant<int, 0>}. A program
may specialize this template for a user-defined type \tcode{T} to
have a BaseCharacteristic of \tcode{integral_constant<int, \textit{N}>}
with \tcode{\textit{N} > 0} to indicate that \tcode{T} should be
treated as a placeholder type.

\rSec3[func.bind.bind]{Function template \tcode{bind}}
\indexlibrary{\idxcode{bind}|(}

\pnum
In the text that follows, the following names have the following meanings:

\begin{itemize}
\item \tcode{FD} is the type \tcode{decay_t<F>},
\item \tcode{fd} is an lvalue of type \tcode{FD} constructed from \tcode{std::forward<F>(f)},
\item \tcode{Ti} is the $i^{th}$ type in the template parameter pack \tcode{BoundArgs},
\item \tcode{TiD} is the type \tcode{decay_t<Ti>},
\item \tcode{ti} is the $i^{th}$ argument in the function parameter pack \tcode{bound_args},
\item \tcode{tid} is an lvalue of type \tcode{TiD} constructed from \tcode{std::forward<Ti>(ti)},
\item \tcode{Uj} is the $j^{th}$ deduced type of the \tcode{UnBoundArgs\&\&...} parameter
  of the forwarding call wrapper, and
\item \tcode{uj} is the $j^{th}$ argument associated with \tcode{Uj}.
\end{itemize}

\indexlibrary{\idxcode{bind}}
\begin{itemdecl}
template<class F, class... BoundArgs>
  @\unspec@ bind(F&& f, BoundArgs&&... bound_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_constructible<FD, F>::value} shall be \tcode{true}. For each \tcode{Ti}
in \tcode{BoundArgs}, \tcode{is_cons\-tructible<TiD, Ti>::value} shall be \tcode{true}.
\tcode{\textit{INVOKE} (fd, w1, w2, ...,
wN)}~(\ref{func.require}) shall be a valid expression for some
values \textit{w1, w2, ..., wN}, where
\tcode{N == sizeof...(bound_args)}.

\pnum\returns A forwarding call wrapper \tcode{g} with a weak result
type~(\ref{func.require}). The effect of \tcode{g(u1, u2, ..., uM)} shall
be \tcode{\textit{INVOKE}(fd, std::forward<V1>(v1), std::forward<V2>(v2), ..., std::forward<VN>(vN), result_of_t<FD \textit{cv} \&
(V1, V2, ..., VN)>)}, where \tcode{\textit{cv}} represents the
\textit{cv}-qualifiers of \tcode{g} and the values and types of the bound
arguments \tcode{v1, v2, ..., vN} are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of \tcode{FD} or of any of the types
\tcode{TiD} throws an exception.

\pnum
\throws Nothing unless the construction of
\tcode{fd} or of one of the values \tcode{tid} throws an exception.

\pnum
\notes The return type shall satisfy the requirements of \tcode{MoveConstructible}. If all
of \tcode{FD} and \tcode{TiD} satisfy the requirements of \tcode{CopyConstructible}, then the
return type shall satisfy the requirements of \tcode{CopyConstructible}. \enternote This implies
that all of \tcode{FD} and \tcode{TiD} are \tcode{MoveConstructible}. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{bind}}
\begin{itemdecl}
template<class R, class F, class... BoundArgs>
  @\unspec@ bind(F&& f, BoundArgs&&... bound_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_constructible<FD, F>::value} shall be \tcode{true}. For each \tcode{Ti}
in \tcode{BoundArgs}, \tcode{is_con\-structible<TiD, Ti>::value} shall be \tcode{true}.
\tcode{\textit{INVOKE}(fd, w1, w2, ..., wN)} shall be  a valid
expression for some
values \textit{w1, w2, ..., wN}, where
\tcode{N == sizeof...(bound_args)}.

\pnum
\returns A forwarding call wrapper \tcode{g} with a nested  type
\tcode{result_type} defined as a synonym for \tcode{R}.  The effect of
\tcode{g(u1, u2, ..., uM)} shall be \tcode{\textit{INVOKE}(fd,
std::forward<V1>(v1), std::forward<V2>(v2), ...,
std::forward<VN>(vN), R)}, where the values and types of the bound
arguments \tcode{v1, v2, ..., vN} are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of \tcode{FD} or of any of the types
\tcode{TiD} throws an exception.

\pnum
\throws Nothing unless the construction of
\tcode{fd} or of one of the values \tcode{tid} throws an exception.

\pnum
\notes The return type shall satisfy the requirements of \tcode{MoveConstructible}. If all
of \tcode{FD} and \tcode{TiD} satisfy the requirements of \tcode{CopyConstructible}, then the
return type shall satisfy the requirements of \tcode{CopyConstructible}. \enternote This implies
that all of \tcode{FD} and \tcode{TiD} are \tcode{MoveConstructible}. \exitnote
\end{itemdescr}

\pnum
\indextext{bound arguments}%
The values of the \techterm{bound arguments} \tcode{v1, v2, ..., vN} and their
corresponding types \tcode{V1, V2, ..., VN} depend on the
types \tcode{TiD} derived from
the call to \tcode{bind} and the
\textit{cv}-qualifiers \textit{cv} of the call wrapper \tcode{g} as follows:

\begin{itemize}
\item if \tcode{TiD} is \tcode{reference_wrapper<T>}, the
argument is \tcode{tid.get()} and its type \tcode{Vi} is \tcode{T\&};

\item if the value of \tcode{is_bind_expression<TiD>::value}
is \tcode{true}, the argument is \tcode{tid(std::forward<Uj>(\brk{}uj)...)}  and its
type \tcode{Vi} is
\tcode{result_of_t<TiD \textit{cv} \& (Uj\&\&...)>\&\&};

\item if the value \tcode{j} of \tcode{is_placeholder<TiD>::value}
is not zero, the  argument is \tcode{std::forward<Uj>(uj)}
and its type \tcode{Vi}
is \tcode{Uj\&\&};

\item otherwise, the value is \tcode{tid} and its type \tcode{Vi}
is \tcode{TiD \textit{cv} \&}.
\end{itemize}

\rSec3[func.bind.place]{Placeholders}

\indexlibrary{\idxcode{placeholders}}%
\indexlibrary{1@\tcode{_1}}%
\begin{codeblock}
namespace std {
  namespace placeholders {
    // M is the implementation-defined number of placeholders
    extern @\unspec@ _1;
    extern @\unspec@ _2;
                .
                .
                .
    extern @\textit{unspecified}@ _M;
  }
}
\end{codeblock}

\pnum
All placeholder types shall be \tcode{DefaultConstructible} and
\tcode{CopyConstructible}, and their default constructors and copy/move
constructors shall not throw exceptions. It is \impldef{assignability of placeholder
objects} whether
placeholder types are \tcode{CopyAssignable}. \tcode{CopyAssignable} placeholders' copy
assignment operators shall not throw exceptions.%
\indexlibrary{\idxcode{bind}|)}%
\indextext{function object!binders|)}

\rSec2[func.memfn]{Function template \tcode{mem_fn}}%
\indextext{function object!\idxcode{mem_fn}|(}

\indexlibrary{\idxcode{mem_fn}}%
\begin{itemdecl}
template<class R, class T> @\unspec@ mem_fn(R T::* pm);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A simple call wrapper~(\ref{func.def}) \tcode{fn}
such that the expression \tcode{fn(t, a2, ..., aN)} is equivalent
to \tcode{\textit{INVOKE}(pm, t, a2, ..., aN)}~(\ref{func.require}).
\tcode{fn} shall have a nested type \tcode{result_type} that is a synonym
for the return type of \tcode{pm} when \tcode{pm} is a pointer to
member function.

\pnum
The simple call wrapper shall
define two nested types named \tcode{argument_type} and \tcode{result_type} as synonyms
for \tcode{\cv{} T*} and \tcode{Ret}, respectively,
when \tcode{pm} is
a pointer to member function with cv-qualifier \textit{cv} and taking no
arguments, where \textit{Ret} is \tcode{pm}'s return type.

\pnum
The simple call wrapper shall
define three nested types named \tcode{first_argument_type},
\tcode{second_argument_type}, and \tcode{result_type} as synonyms
for \tcode{\cv{} T*}, \tcode{T1}, and \tcode{Ret}, respectively,
when \tcode{pm} is
a pointer to member function with cv-qualifier \textit{cv} and taking
one argument of type \tcode{T1}, where \textit{Ret} is \tcode{pm}'s return type.

\pnum
\throws Nothing.
\end{itemdescr}
\indextext{function object!\idxcode{mem_fn}|)}

\rSec2[func.wrap]{Polymorphic function wrappers}%
\indextext{function object!wrapper|(}

\pnum
This subclause describes a polymorphic wrapper class that
encapsulates arbitrary callable objects.

\rSec3[func.wrap.badcall]{Class \tcode{bad_function_call}}%
\indexlibrary{\idxcode{bad_function_call}}%
\indexlibrary{exception!\idxcode{bad_function_call}}

\pnum
An exception of type \tcode{bad_function_call} is thrown by
\tcode{function::operator()}~(\ref{func.wrap.func.inv})
when the function wrapper object has no target.

\begin{codeblock}
namespace std {
  class bad_function_call : public std::exception {
  public:
    // \ref{func.wrap.badcall.const}, constructor:
    bad_function_call() noexcept;
  };
} // namespace std
\end{codeblock}

\rSec4[func.wrap.badcall.const]{\tcode{bad_function_call} constructor}

\indexlibrary{\idxcode{bad_function_call}!\idxcode{bad_function_call}}%
\begin{itemdecl}
bad_function_call() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects constructs a \tcode{bad_function_call} object.
\end{itemdescr}

\rSec3[func.wrap.func]{Class template \tcode{function}}
\indexlibrary{\idxcode{function}}

\begin{codeblock}
namespace std {
  template<class> class function; // undefined

  template<class R, class... ArgTypes>
  class function<R(ArgTypes...)> {
  public:
    typedef R result_type;
    typedef T1 argument_type;           // only if \tcode{sizeof...(ArgTypes) == 1} and
                                        // the type in \tcode{ArgTypes} is \tcode{T1}
    typedef T1 first_argument_type;     // only if \tcode{sizeof...(ArgTypes) == 2} and
                                        // \tcode{ArgTypes} contains \tcode{T1} and \tcode{T2}
    typedef T2 second_argument_type;    // only if \tcode{sizeof...(ArgTypes) == 2} and
                                        // \tcode{ArgTypes} contains \tcode{T1} and \tcode{T2}

    // \ref{func.wrap.func.con}, construct/copy/destroy:
    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&);
    function(function&&);
    template<class F> function(F);
    template<class A> function(allocator_arg_t, const A&) noexcept;
    template<class A> function(allocator_arg_t, const A&,
      nullptr_t) noexcept;
    template<class A> function(allocator_arg_t, const A&,
      const function&);
    template<class A> function(allocator_arg_t, const A&,
      function&&);
    template<class F, class A> function(allocator_arg_t, const A&, F);

    function& operator=(const function&);
    function& operator=(function&&);
    function& operator=(nullptr_t);
    template<class F> function& operator=(F&&);
    template<class F> function& operator=(reference_wrapper<F>) noexcept;

    ~function();

    // \ref{func.wrap.func.mod}, function modifiers:
    void swap(function&) noexcept;
    template<class F, class A> void assign(F&&, const A&);

    // \ref{func.wrap.func.cap}, function capacity:
    explicit operator bool() const noexcept;

    // \ref{func.wrap.func.inv}, function invocation:
    R operator()(ArgTypes...) const;

    // \ref{func.wrap.func.targ}, function target access:
    const std::type_info& target_type() const noexcept;
    template<class T>       T* target() noexcept;
    template<class T> const T* target() const noexcept;

  };

  // \ref{func.wrap.func.nullptr}, Null pointer comparisons:
  template <class R, class... ArgTypes>
    bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

  template <class R, class... ArgTypes>
    bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

  template <class R, class... ArgTypes>
    bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

  template <class R, class... ArgTypes>
    bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

  // \ref{func.wrap.func.alg}, specialized algorithms:
  template <class R, class... ArgTypes>
    void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);

  template<class R, class... ArgTypes, class Alloc>
    struct uses_allocator<function<R(ArgTypes...)>, Alloc>
      : true_type { };
}
\end{codeblock}

\pnum
The \tcode{function} class template provides polymorphic wrappers that
generalize the notion of a function pointer. Wrappers can store, copy,
and call arbitrary callable objects~(\ref{func.def}), given a call
signature~(\ref{func.def}), allowing functions to be first-class objects.

\pnum
\indextext{callable object}%
A callable object \tcode{f} of type \tcode{F}
is \defn{Callable} for argument
types \tcode{ArgTypes}
and return type \tcode{R}
if the expression
\tcode{\textit{INVOKE}(f, declval<ArgTypes>()..., R)},
considered as an unevaluated operand (Clause~\ref{expr}), is
well formed~(\ref{func.require}).

\pnum
The \tcode{function} class template is a call
wrapper~(\ref{func.def}) whose call signature~(\ref{func.def})
is \tcode{R(ArgTypes...)}.

\rSec4[func.wrap.func.con]{\tcode{function} construct/copy/destroy}

\pnum
When any \tcode{function} constructor that takes a first argument of type
\tcode{allocator_arg_t} is invoked, the second argument shall have a type that conforms
to the requirements for Allocator (Table~\ref{allocator.requirements}). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data
structures of the constructed \tcode{function} object.

\indexlibrary{\idxcode{function}!\idxcode{function}}
\begin{itemdecl}
function() noexcept;
template <class A> function(allocator_arg_t, const A& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions \tcode{!*this}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{function}}
\indexlibrary{\idxcode{function}!\idxcode{function}}
\begin{itemdecl}
function(nullptr_t) noexcept;
template <class A> function(allocator_arg_t, const A& a, nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{!*this}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{function}}
\indexlibrary{\idxcode{function}!\idxcode{function}}
\begin{itemdecl}
function(const function& f);
template <class A> function(allocator_arg_t, const A& a, const function& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{!*this} if \tcode{!f}; otherwise,
\tcode{*this} targets a copy of \tcode{f.target()}.

\pnum
\throws shall not throw exceptions if \tcode{f}'s target is
a callable object passed via \tcode{reference_wrapper} or
a function pointer. Otherwise, may throw \tcode{bad_alloc}
or any exception thrown by the copy constructor of the stored callable object.
\enternote Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example, where
\tcode{f}'s target is an object holding only a pointer or reference
to an object and a member function pointer. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{function}}
\indexlibrary{\idxcode{function}!\idxcode{function}}
\begin{itemdecl}
function(function&& f);
template <class A> function(allocator_arg_t, const A& a, function&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{!f}, \tcode{*this} has
no target; otherwise, move-constructs the target of \tcode{f}
into the target of \tcode{*this}, leaving \tcode{f} in
a valid state with an unspecified value.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{function}}
\indexlibrary{\idxcode{function}!\idxcode{function}}
\begin{itemdecl}
template<class F> function(F f);
template <class F, class A> function(allocator_arg_t, const A& a, F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{F} shall be \tcode{CopyConstructible}.

\pnum
\remarks These constructors shall not participate in overload resolution unless
\tcode{f} is Callable~(\ref{func.wrap.func}) for argument types
\tcode{ArgTypes...} and return type \tcode{R}.

\pnum
\postconditions \tcode{!*this} if any of the following hold:
\begin{itemize}
\item \tcode{f} is a null function pointer value.
\item \tcode{f} is a null member pointer value.
\item \tcode{F} is an instance of the \tcode{function} class template, and
  \tcode{!f}.
\end{itemize}

\pnum
Otherwise, \tcode{*this} targets a copy of \tcode{f}
initialized with \tcode{std::move(f)}.
\enternote Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example,
where \tcode{f}'s target is an object holding only a pointer or
reference to an object and a member function pointer. \exitnote

\pnum
\throws shall not throw exceptions when \tcode{f} is a function pointer
or a \tcode{reference_wrapper<T>} for some \tcode{T}. Otherwise,
may throw \tcode{bad_alloc} or any exception thrown by \tcode{F}'s copy
or move constructor.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{function}}%
\begin{itemdecl}
function& operator=(const function& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{function(f).swap(*this);}

\pnum
\returns \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{function}}%
\begin{itemdecl}
function& operator=(function&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Replaces the target of \tcode{*this}
with the target of \tcode{f}.

\pnum
\returns \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{function}}%
\begin{itemdecl}
function& operator=(nullptr_t);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If \tcode{*this != nullptr}, destroys the target of \tcode{this}.

\pnum\postconditions \tcode{!(*this)}.

\pnum\returns \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{function}}%
\begin{itemdecl}
template<class F> function& operator=(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects \tcode{function(std::forward<F>(f)).swap(*this);}

\pnum\returns \tcode{*this}

\pnum\remarks This assignment operator shall not participate in overload
resolution unless \tcode{declval<typename decay<F>::type\&>()} is
Callable~(\ref{func.wrap.func}) for argument types \tcode{ArgTypes...} and
return type \tcode{R}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{function}}%
\begin{itemdecl}
template<class F> function& operator=(reference_wrapper<F> f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects \tcode{function(f).swap(*this);}

\pnum
\returns \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{function}!destructor}%
\begin{itemdecl}
~function();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If \tcode{*this != nullptr}, destroys the target of \tcode{this}.
\end{itemdescr}

\rSec4[func.wrap.func.mod]{\tcode{function} modifiers}

\indexlibrary{\idxcode{function}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{function}}%
\begin{itemdecl}
void swap(function& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects interchanges the targets of \tcode{*this} and \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{assign}}%
\indexlibrary{\idxcode{assign}!\idxcode{function}}%
\begin{itemdecl}
template<class F, class A>
  void assign(F&& f, const A& a);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects \tcode{function(allocator_arg, a, std::forward<F>(f)).swap(*this)}
\end{itemdescr}

\rSec4[func.wrap.func.cap]{\tcode{function} capacity}

\indexlibrary{\idxcode{function}!bool conversion}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if \tcode{*this} has a target, otherwise \tcode{false}.
\end{itemdescr}

\rSec4[func.wrap.func.inv]{\tcode{function} invocation}

\indexlibrary{\idxcode{function}!invocation}%
\indexlibrary{\idxcode{function}!\idxcode{operator()}}%
\indexlibrary{\idxcode{operator()}!\idxcode{function}}%
\begin{itemdecl}
R operator()(ArgTypes... args) const
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{\textit{INVOKE}(f, std::forward<ArgTypes>(args)..., R)}~(\ref{func.require}),
where \tcode{f} is the target object~(\ref{func.def}) of \tcode{*this}.

\pnum\returns Nothing if \tcode{R} is \tcode{void}, otherwise the
return value of
\tcode{\textit{INVOKE}(f, std::forward<ArgTypes>(\brk{}args)..., R)}.

\pnum\throws
\tcode{bad_function_call} if \tcode{!*this}; otherwise, any
exception thrown by the wrapped callable object.
\end{itemdescr}

\rSec4[func.wrap.func.targ]{function target access}

\indexlibrary{\idxcode{function}!\idxcode{target_type}}%
\indexlibrary{\idxcode{target_type}!\idxcode{function}}%
\begin{itemdecl}
const std::type_info& target_type() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns If \tcode{*this} has a target of type \tcode{T},
  \tcode{typeid(T)}; otherwise, \tcode{typeid(void)}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!\idxcode{target}}%
\indexlibrary{\idxcode{target}!\idxcode{function}}%
\begin{itemdecl}
template<class T>       T* target() noexcept;
template<class T> const T* target() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} shall be a type that is
Callable~(\ref{func.wrap.func}) for parameter types
\tcode{ArgTypes}
and return type \tcode{R}.

\pnum\returns If \tcode{target_type() == typeid(T)}
a pointer to the stored function target; otherwise a null pointer.
\end{itemdescr}

\rSec4[func.wrap.func.nullptr]{null pointer comparison operators}

\indexlibrary{\idxcode{operator==}!\idxcode{function}}%
\indexlibrary{\idxcode{function}!\idxcode{operator==}}%
\begin{itemdecl}
template <class R, class... ArgTypes>
  bool operator==(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template <class R, class... ArgTypes>
  bool operator==(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!f}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{function}}%
\indexlibrary{\idxcode{function}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class R, class... ArgTypes>
  bool operator!=(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template <class R, class... ArgTypes>
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{ (bool) f}.
\end{itemdescr}

\rSec4[func.wrap.func.alg]{specialized algorithms}

\indexlibrary{\idxcode{function}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{function}}%
\begin{itemdecl}
template<class R, class... ArgTypes>
  void swap(function<R(ArgTypes...)>& f1, function<R(ArgTypes...)>& f2);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects \tcode{f1.swap(f2);}
\end{itemdescr}%
\indextext{function object!wrapper|)}

\rSec2[unord.hash]{Class template \tcode{hash}}

\pnum
\indexlibrary{\idxcode{hash}}%
\indextext{\idxcode{hash}!instantiation restrictions}%
The unordered associative containers defined in \ref{unord} use
specializations of the class template \tcode{hash} as the default hash function.
For all object types \tcode{Key} for which there exists a specialization \tcode{hash<Key>},
and for all enumeration types~(\ref{dcl.enum}) \tcode{Key},
the instantiation \tcode{hash<Key>} shall:

\begin{itemize}
\item satisfy the \tcode{Hash} requirements~(\ref{hash.requirements}),
with \tcode{Key} as the function
call argument type, the \tcode{Default\-Constructible} requirements (Table~\ref{defaultconstructible}),
the \tcode{CopyAssignable} requirements (Table~\ref{copyassignable}),
\item be swappable~(\ref{swappable.requirements}) for lvalues,
\item provide two nested types \tcode{result_type} and \tcode{argument_type} which shall be
synonyms for \tcode{size_t} and \tcode{Key}, respectively,
\item satisfy the requirement that if \tcode{k1 == k2} is true, \tcode{h(k1) == h(k2)} is
also true, where \tcode{h} is an object of type \tcode{hash<Key>} and \tcode{k1} and \tcode{k2}
are objects of type \tcode{Key};
\item satisfy the requirement that the expression \tcode{h(k)}, where \tcode{h}
is an object of type \tcode{hash<Key>} and \tcode{k} is an object of type
\tcode{Key}, shall not throw an exception unless \tcode{hash<Key>} is a
user-defined specialization that depends on at least one user-defined type.
\end{itemize}

\indexlibrary{\idxcode{hash}}%
\begin{itemdecl}
template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<unsigned long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long long>;
template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;
template <class T> struct hash<T*>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The template specializations shall meet the requirements of class template
\tcode{hash}~(\ref{unord.hash}).
\end{itemdescr}


\rSec1[meta]{Metaprogramming and type traits}

\pnum
This subclause describes components used by \Cpp programs, particularly in
templates, to support the widest possible range of types, optimise
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible \Cpp types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.

\rSec2[meta.rqmts]{Requirements}

\pnum
A \defn{UnaryTypeTrait} describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be \tcode{DefaultConstructible},
\tcode{CopyConstructible},
and publicly and unambiguously derived, directly or indirectly, from
its \defn{BaseCharacteristic}, which is
a specialization of the template
\tcode{integral_constant}~(\ref{meta.help}), with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular property being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the UnaryTypeTrait.

\pnum
A \defn{BinaryTypeTrait} describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be \tcode{DefaultConstructible}, \tcode{CopyConstructible},
and publicly and unambiguously derived, directly or
indirectly, from
its \term{BaseCharacteristic}, which is a specialization
of the template
\tcode{integral_constant}~(\ref{meta.help}), with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular relationship being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the BinaryTypeTrait.

\pnum
A \defn{TransformationTrait}
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named \tcode{type}, which shall be a synonym for the modified type.

\rSec2[meta.type.synop]{Header \tcode{<type_traits>} synopsis}
\begin{codeblock}
namespace std {
  // \ref{meta.help}, helper class:
  template <class T, T v> struct integral_constant;
  typedef integral_constant<bool, true>  true_type;
  typedef integral_constant<bool, false> false_type;

  // \ref{meta.unary.cat}, primary type categories:
  template <class T> struct is_void;
  template <class T> struct is_null_pointer;
  template <class T> struct is_integral;
  template <class T> struct is_floating_point;
  template <class T> struct is_array;
  template <class T> struct is_pointer;
  template <class T> struct is_lvalue_reference;
  template <class T> struct is_rvalue_reference;
  template <class T> struct is_member_object_pointer;
  template <class T> struct is_member_function_pointer;
  template <class T> struct is_enum;
  template <class T> struct is_union;
  template <class T> struct is_class;
  template <class T> struct is_function;

  // \ref{meta.unary.comp}, composite type categories:
  template <class T> struct is_reference;
  template <class T> struct is_arithmetic;
  template <class T> struct is_fundamental;
  template <class T> struct is_object;
  template <class T> struct is_scalar;
  template <class T> struct is_compound;
  template <class T> struct is_member_pointer;

  // \ref{meta.unary.prop}, type properties:
  template <class T> struct is_const;
  template <class T> struct is_volatile;
  template <class T> struct is_trivial;
  template <class T> struct is_trivially_copyable;
  template <class T> struct is_standard_layout;
  template <class T> struct is_pod;
  template <class T> struct is_literal_type;
  template <class T> struct is_empty;
  template <class T> struct is_polymorphic;
  template <class T> struct is_abstract;
  template <class T> struct is_final;

  template <class T> struct is_signed;
  template <class T> struct is_unsigned;

  template <class T, class... Args> struct is_constructible;
  template <class T> struct is_default_constructible;
  template <class T> struct is_copy_constructible;
  template <class T> struct is_move_constructible;

  template <class T, class U> struct is_assignable;
  template <class T> struct is_copy_assignable;
  template <class T> struct is_move_assignable;

  template <class T> struct is_destructible;

  template <class T, class... Args> struct is_trivially_constructible;
  template <class T> struct is_trivially_default_constructible;
  template <class T> struct is_trivially_copy_constructible;
  template <class T> struct is_trivially_move_constructible;

  template <class T, class U> struct is_trivially_assignable;
  template <class T> struct is_trivially_copy_assignable;
  template <class T> struct is_trivially_move_assignable;
  template <class T> struct is_trivially_destructible;

  template <class T, class... Args> struct is_nothrow_constructible;
  template <class T> struct is_nothrow_default_constructible;
  template <class T> struct is_nothrow_copy_constructible;
  template <class T> struct is_nothrow_move_constructible;

  template <class T, class U> struct is_nothrow_assignable;
  template <class T> struct  is_nothrow_copy_assignable;
  template <class T> struct is_nothrow_move_assignable;

  template <class T> struct is_nothrow_destructible;
  template <class T> struct has_virtual_destructor;

  // \ref{meta.unary.prop.query}, type property queries:
  template <class T> struct alignment_of;
  template <class T> struct rank;
  template <class T, unsigned I = 0> struct extent;

  // \ref{meta.rel}, type relations:
  template <class T, class U> struct is_same;
  template <class Base, class Derived> struct is_base_of;
  template <class From, class To> struct is_convertible;

  // \ref{meta.trans.cv}, const-volatile modifications:
  template <class T> struct remove_const;
  template <class T> struct remove_volatile;
  template <class T> struct remove_cv;
  template <class T> struct add_const;
  template <class T> struct add_volatile;
  template <class T> struct add_cv;

  template <class T>
    using remove_const_t    = typename remove_const<T>::type;
  template <class T>
    using remove_volatile_t = typename remove_volatile<T>::type;
  template <class T>
    using remove_cv_t       = typename remove_cv<T>::type;
  template <class T>
    using add_const_t       = typename add_const<T>::type;
  template <class T>
    using add_volatile_t    = typename add_volatile<T>::type;
  template <class T>
    using add_cv_t          = typename add_cv<T>::type;

  // \ref{meta.trans.ref}, reference modifications:
  template <class T> struct remove_reference;
  template <class T> struct add_lvalue_reference;
  template <class T> struct add_rvalue_reference;

  template <class T>
    using remove_reference_t     = typename remove_reference<T>::type;
  template <class T>
    using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
  template <class T>
    using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

  // \ref{meta.trans.sign}, sign modifications:
  template <class T> struct make_signed;
  template <class T> struct make_unsigned;

  template <class T>
    using make_signed_t   = typename make_signed<T>::type;
  template <class T>
    using make_unsigned_t = typename make_unsigned<T>::type;

  // \ref{meta.trans.arr}, array modifications:
  template <class T> struct remove_extent;
  template <class T> struct remove_all_extents;

  template <class T>
    using remove_extent_t      = typename remove_extent<T>::type;
  template <class T>
    using remove_all_extents_t = typename remove_all_extents<T>::type;

  // \ref{meta.trans.ptr}, pointer modifications:
  template <class T> struct remove_pointer;
  template <class T> struct add_pointer;

  template <class T>
    using remove_pointer_t = typename remove_pointer<T>::type;
  template <class T>
    using add_pointer_t    = typename add_pointer<T>::type;

  // \ref{meta.trans.other}, other transformations:
  template <std::size_t Len,
            std::size_t Align = default-alignment>   // see \ref{meta.trans.other}
    struct aligned_storage;      
  template <std::size_t Len, class... Types> struct aligned_union;
  template <class T> struct decay;
  template <bool, class T = void> struct enable_if;
  template <bool, class T, class F> struct conditional;
  template <class... T> struct common_type;
  template <class T> struct underlying_type;
  template <class> class result_of;   // not defined
  template <class F, class... ArgTypes> class result_of<F(ArgTypes...)>;

  template <std::size_t Len,
            std::size_t Align = default-alignment > // see \ref{meta.trans.other}
    using aligned_storage_t = typename aligned_storage<Len,Align>::type;
  template <std::size_t Len, class... Types>
    using aligned_union_t   = typename aligned_union<Len,Types...>::type;
  template <class T>
    using decay_t           = typename decay<T>::type;
  template <bool b, class T = void>
    using enable_if_t       = typename enable_if<b,T>::type;
  template <bool b, class T, class F>
    using conditional_t     = typename conditional<b,T,F>::type;
  template <class... T>
    using common_type_t     = typename common_type<T...>::type;
  template <class T>
    using underlying_type_t = typename underlying_type<T>::type;
  template <class T>
    using result_of_t       = typename result_of<T>::type;  
} // namespace std
\end{codeblock}

\pnum
The behavior of a program that adds specializations for any of
the class templates defined in this subclause is undefined unless otherwise specified.

\rSec2[meta.help]{Helper classes}

\begin{codeblock}
namespace std {
  template <class T, T v>
  struct integral_constant {
    static constexpr T value = v;
    typedef T value_type;
    typedef integral_constant<T,v> type;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
  typedef integral_constant<bool, true> true_type;
  typedef integral_constant<bool, false> false_type;
}
\end{codeblock}

\pnum
The class template \tcode{integral_constant} and its associated typedefs
\tcode{true_type} and \tcode{false_type} are used as base classes to define
the interface for various type traits.

\rSec2[meta.unary]{Unary type traits}

\pnum
This sub-clause contains templates that may be used to query the
properties of a type at compile time.

\pnum
Each of these templates shall be a
UnaryTypeTrait~(\ref{meta.rqmts})
with a BaseCharacteristic of
\tcode{true_type} if the corresponding condition is true, otherwise
\tcode{false_type}.

\rSec3[meta.unary.cat]{Primary type categories}

\pnum
The primary type categories correspond to the descriptions given in
section~\ref{basic.types} of the \Cpp standard.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T} and to \textit{cv-qualified} \tcode{T} shall yield the same result.

\pnum
\enternote
For any given type \tcode{T}, exactly one of the primary type categories
has a \tcode{value} member that evaluates to \tcode{true}.
\exitnote

\begin{libreqtab3e}{Primary type category predicates}{tab:type-traits.primary}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\\capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>}\br
 \tcode{struct is_void;}                &
\tcode{T} is \tcode{void}       &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_null_pointer;}                &
\tcode{T} is \tcode{std::nullptr_t}~(\ref{basic.fundamental})       &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_integral;}        &
\tcode{T} is an integral type~(\ref{basic.fundamental})                 &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_floating_point;}  &
\tcode{T} is a floating point type~(\ref{basic.fundamental})            &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_array;}           &
\tcode{T} is an array type~(\ref{basic.compound}) of known or unknown extent    &
Class template \tcode{array}~(\ref{array})
is not an array type.                   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_pointer;}         &
\tcode{T} is a pointer type~(\ref{basic.compound})                      &
Includes pointers to functions
but not pointers to non-static members.                        \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_lvalue_reference;}    &
 \tcode{T} is an lvalue reference type~(\ref{dcl.ref})   &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_rvalue_reference;}    &
 \tcode{T} is an rvalue reference type~(\ref{dcl.ref})   &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_member_object_pointer;}&
 \tcode{T} is a pointer to non-static data member                              &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_member_function_pointer;}&
\tcode{T} is a pointer to non-static member function                           &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_enum;}            &
\tcode{T} is an enumeration type~(\ref{basic.compound})                 &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_union;}           &
\tcode{T} is a union type~(\ref{basic.compound})                        &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_class;}           &
\tcode{T} is a class type but not a union type~(\ref{basic.compound}) & \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_function;}        &
\tcode{T} is a function type~(\ref{basic.compound})                     &   \\
\end{libreqtab3e}

\rSec3[meta.unary.comp]{Composite type traits}

\pnum
These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section~\ref{basic.types}.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T}, and to \textit{cv-qualified} \tcode{T} shall yield the same result.

\begin{libreqtab3b}{Composite type category predicates}{tab:type-traits.composite}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>}\br
 \tcode{struct is_reference;}   &
 \tcode{T} is an lvalue reference or an rvalue reference &  \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_arithmetic;}          &
 \tcode{T} is an arithmetic type~(\ref{basic.fundamental})              &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_fundamental;}         &
 \tcode{T} is a fundamental type~(\ref{basic.fundamental})              &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_object;}              &
 \tcode{T} is an object type~(\ref{basic.types})                            &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_scalar;}              &
 \tcode{T} is a scalar type~(\ref{basic.types})                         &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_compound;}            &
 \tcode{T} is a compound type~(\ref{basic.compound})                        &   \\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct is_member_pointer;}      &
 \tcode{T} is a pointer to non-static data member
 or non-static member function             &   \\
\end{libreqtab3b}

\rSec3[meta.unary.prop]{Type properties}

\pnum
These templates provide access to some of the more important
properties of types.

\pnum
It is unspecified whether the library defines any full or partial
specializations of any of these templates.

\pnum
For all of the class templates \tcode{X} declared in this Clause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of \tcode{X} require that
the argument must be a complete type.

\begin{libreqtab3b}{Type property predicates}{tab:type-traits.properties}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endhead

\tcode{template <class T>}\br
 \tcode{struct is_const;}               &
 \tcode{T} is const-qualified~(\ref{basic.type.qualifier})                  &   \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_volatile;}            &
 \tcode{T} is volatile-qualified~(\ref{basic.type.qualifier})                   &   \\ \rowsep


\tcode{template <class T>}\br
 \tcode{struct is_trivial;}                 &
 \tcode{T} is a trivial type~(\ref{basic.types})     &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or (possibly cv-qualified) void.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_copyable;}      &
 \tcode{T} is a trivially copyable type~(\ref{basic.types}) &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 (possibly cv-qualified) \tcode{void}.                               \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_standard_layout;}                 &
 \tcode{T} is a standard-layout type~(\ref{basic.types})   &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or (possibly cv-qualified) void.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_pod;}                 &
 \tcode{T} is a POD type~(\ref{basic.types})                                &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or (possibly cv-qualified) void.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_literal_type;}        &
 \tcode{T} is a literal type~(\ref{basic.types})  &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 (possibly cv-qualified) \tcode{void}.                               \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_empty;}               &
 \tcode{T} is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class \tcode{B} for
 which \tcode{is_empty<B>::value} is false. &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                               \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_polymorphic;}         &
 \tcode{T} is a polymorphic class~(\ref{class.virtual})                             &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_abstract;}            &
 \tcode{T} is an abstract class~(\ref{class.abstract})                              &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_final;}               &
 \tcode{T} is a class type marked with the \grammarterm{class-virt-specifier}
 \tcode{final} (Clause~\ref{class}). \enternote A union is a class type that
 can be marked with \tcode{final}. \exitnote                                        &
 If \tcode{T} is a class type, \tcode{T} shall be a complete type.                          \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_signed;}              &
  If \tcode{is_arithmetic<T>::value} is \tcode{true}, the same result as
  \tcode{integral_constant<bool, T(-1) < T(0)>::value};
  otherwise, \tcode{false}   &   \\  \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_unsigned;}            &
  If \tcode{is_arithmetic<T>::value} is \tcode{true}, the same result as
  \tcode{integral_constant<bool, T(0) < T(-1)>::value};
  otherwise, \tcode{false}   &   \\  \rowsep

\tcode{template <class T, class... Args>}\br
 \tcode{struct is_constructible;}   &
 \seebelow                          &
 \tcode{T} and all types in the parameter pack \tcode{Args}
 shall be complete types, (possibly cv-qualified) \tcode{void},
 or arrays of unknown bound.  \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_default_constructible;} &
  \tcode{is_constructible<T>::value} is \tcode{true}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_copy_constructible;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_constructible<T, const T\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_move_constructible;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_constructible<T, T\&\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T, class U>}\br
  \tcode{struct is_assignable;} &
  The expression \tcode{declval<T>() =} \tcode{declval<U>()} is well-formed
  when treated as an unevaluated
  operand (Clause~\ref{expr}). Access checking is performed as if in a context
  unrelated to \tcode{T} and \tcode{U}. Only the validity of the immediate context
  of the assignment expression is considered. \enternote The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the ``immediate
  context'' and can result in the program being ill-formed. \exitnote &
  \tcode{T} and \tcode{U} shall be complete types, (possibly cv-qualified) \tcode{void},
  or arrays of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable<T\&, const T\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable<T\&, T\&\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_destructible;} &
  For reference types, \tcode{is_destructible<T>::value} is \tcode{true}. \br
  For incomplete types and function types, \tcode{is_destructible<T>::value} is
  \tcode{false}. \br
  For object types and given \tcode{U} equal to \tcode{remove_all_extents_t<T>},
  if the expression \tcode{std::declval<U\&>().\~{}U()} is well-formed
  when treated as an unevaluated operand (Clause~\ref{expr}), \br then
  \tcode{is_destructible<T>::value} is \tcode{true},
  otherwise it is \tcode{false}. &
  \tcode{T} shall be a complete type, (possibly \cv-qualified) \tcode{void},
  or an array of unknown bound. \\ \rowsep

\tcode{template <class T, class... Args>}\br
  \tcode{struct}\br
  \tcode{is_trivially_constructible;} &
  \tcode{is_constructible<T,}\br
  \tcode{Args...>::value} is \tcode{true} and the variable
  definition for \tcode{is_constructible}, as defined below, is known to call
  no operation that is not trivial (~\ref{basic.types},~\ref{special}). &
  \tcode{T} and all types in the parameter pack \tcode{Args} shall be complete types,
  (possibly cv-qualified) \tcode{void}, or arrays of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_default_constructible;} &
 \tcode{is_trivially_constructible<T>::value} is \tcode{true}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible<T, const T\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible<T, T\&\&>::value}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T, class U>}\br
  \tcode{struct is_trivially_assignable;} &
  \tcode{is_assignable<T, U>::value} is \tcode{true} and the assignment, as defined by
  \tcode{is_assignable}, is known to call no operation that is not trivial
  (\ref{basic.types},~\ref{special}). &
  \tcode{T} and \tcode{U} shall be complete types, (possibly cv-qualified) \tcode{void},
  or arrays of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable<T\&, const T\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable<T\&, T\&\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_trivially_destructible;} &
 \tcode{is_destructible<T>::value} is \tcode{true} and the indicated destructor is known
 to be trivial. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T, class... Args>}\br
 \tcode{struct is_nothrow_constructible;}   &
 \tcode{is_constructible<T,} \tcode{ Args...>::value} is \tcode{true}
 and the
 variable definition for \tcode{is_constructible}, as defined below, is known not to
 throw any exceptions~(\ref{expr.unary.noexcept}).
 &
 \tcode{T} and all types in the parameter pack \tcode{Args}
 shall be complete types, (possibly cv-qualified) \tcode{void},
 or arrays of unknown bound.  \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_nothrow_default_constructible;} &
 \tcode{is_nothrow_constructible<T>::value} is \tcode{true}.  &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_nothrow_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible<T, const T\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_nothrow_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible<T, T\&\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                \\ \rowsep

\tcode{template <class T, class U>}\br
  \tcode{struct is_nothrow_assignable;} &
  \tcode{is_assignable<T, U>::value} is \tcode{true} and the assignment is known not to
  throw any exceptions~(\ref{expr.unary.noexcept}). &
  \tcode{T} and \tcode{U} shall be complete types, (possibly cv-qualified) \tcode{void},
  or arrays of unknown bound. \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct is_nothrow_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_assignable<T\&, const T\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_nothrow_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_nothrow_assignable<T\&, T\&\&>::value}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                \\ \rowsep

\tcode{template <class T>}\br
  \tcode{struct is_nothrow_destructible;} &
  \tcode{is_destructible<T>::value} is \tcode{true} and the indicated destructor is known
  not to throw any exceptions~(\ref{expr.unary.noexcept}). &
  \tcode{T} shall be a complete type,
  (possibly cv-qualified) void, or an array of unknown
  bound.                \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct has_virtual_destructor;} &
 \tcode{T} has a virtual destructor~(\ref{class.dtor}) &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\end{libreqtab3b}

\pnum
\enterexample
\begin{codeblock}
is_const<const volatile int>::value     // true
is_const<const int*>::value             // false
is_const<const int&>::value             // false
is_const<int[3]>::value                 // false
is_const<const int[3]>::value           // true
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
remove_const_t<const volatile int>  // \tcode{volatile int}
remove_const_t<const int* const>    // \tcode{const int*}
remove_const_t<const int&>          // \tcode{const int\&}
remove_const_t<const int[3]>        // \tcode{int[3]}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// Given:
struct P final { };
union U1 { };
union U2 final { };

// the following assertions hold:
static_assert(!is_final<int>::value, "Error!");
static_assert( is_final<P>::value, "Error!");
static_assert(!is_final<U1>::value, "Error!");
static_assert( is_final<U2>::value, "Error!");
\end{codeblock}
\exitexample

\pnum
Given the following function prototype:
\begin{codeblock}
template <class T>
  add_rvalue_reference_t<T> create() noexcept;
\end{codeblock}

the predicate condition for a template specialization
\tcode{is_constructible<T, Args...>} shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable \tcode{t}:

\begin{codeblock}
T t(create<Args>()...);
\end{codeblock}

\enternote These tokens are never interpreted as a function declaration.
\exitnote Access checking is performed as if in a context unrelated to \tcode{T}
and any of the \tcode{Args}. Only the validity of the immediate context of the
variable initialization is considered. \enternote The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
``immediate context'' and can result in the program being ill-formed. \exitnote

\rSec2[meta.unary.prop.query]{Type property queries}

\pnum
This sub-clause contains templates that may be used to query
properties of types at compile time.

\begin{libreqtab2a}{Type property queries}{tab:type-traits.properties.queries}
\\ \topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endhead

\tcode{template <class T>\br
 struct alignment_of;}      &
 \tcode{alignof(T)}.\br
 \precondition
 \tcode{alignof(T)} shall be a valid expression~(\ref{expr.alignof})  \\  \rowsep

\tcode{template <class T>\br
 struct rank;}      &
 If \tcode{T} names an array type, an integer value representing
 the number of dimensions of \tcode{T}; otherwise, 0. \\    \rowsep

\tcode{template <class T,\br
 unsigned I = 0>\br
 struct extent;}        &
 If \tcode{T} is not an array type, or if it has rank less
 than or equal to \tcode{I}, or if \tcode{I} is 0 and \tcode{T}
 has type ``array of unknown bound of \tcode{U}'', then
 0; otherwise, the bound~(\ref{dcl.array}) of the \tcode{I}'th dimension of
\tcode{T}, where indexing of \tcode{I} is zero-based \\
\end{libreqtab2a}

\pnum
Each of these templates shall be a \tcode{UnaryTypeTrait}~(\ref{meta.rqmts}) with a
\tcode{BaseCharacteristic} of \tcode{integral_constant<size_t, Value>}.

\pnum
\enterexample
\begin{codeblock}
// the following assertions hold:
assert(rank<int>::value == 0);
assert(rank<int[2]>::value == 1);
assert(rank<int[][4]>::value == 2);
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
 // the following assertions hold:
assert(extent<int>::value == 0);
assert(extent<int[2]>::value == 2);
assert(extent<int[2][4]>::value == 2);
assert(extent<int[][4]>::value == 0);
assert((extent<int, 1>::value) == 0);
assert((extent<int[2], 1>::value) == 0);
assert((extent<int[2][4], 1>::value) == 4);
assert((extent<int[][4], 1>::value) == 4);
\end{codeblock}
\exitexample

\rSec2[meta.rel]{Relationships between types}

\pnum
This sub-clause contains templates that may be used to query
relationships between types at compile time.

\pnum
Each of these templates shall be a
BinaryTypeTrait~(\ref{meta.rqmts})
with a BaseCharacteristic of
\tcode{true_type} if the corresponding condition is true, otherwise
\tcode{false_type}.

\begin{libreqtab3f}{Type relationship predicates}{tab:type-traits.relationship}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T, class U>}\br
 \tcode{struct is_same;}                    &
 \tcode{T} and \tcode{U} name the same type with the same cv-qualifications                            &   \\ \rowsep

\tcode{template <class Base, class Derived>}\br
 \tcode{struct is_base_of;}                 &
 \tcode{Base} is a base class of \tcode{Derived} (Clause~\ref{class.derived})
 without regard to cv-qualifiers
 or \tcode{Base} and \tcode{Derived} are not unions and
 name the same class type
 without regard to cv-qualifiers&
 If \tcode{Base} and
 \tcode{Derived} are non-union class types and are different types (ignoring
 possible cv-qualifiers) then
 \tcode{Derived} shall be a complete
 type.
 \enternote Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes. \exitnote \\ \rowsep

\tcode{template <class From, class To>}\br
 \tcode{struct is_convertible;}             &
 \seebelow
  &
 \tcode{From} and \tcode{To} shall be complete
 types, arrays of unknown
 bound, or (possibly cv-qualified) \tcode{void} types.                      \\
\end{libreqtab3f}

\pnum
\enterexample
\begin{codeblock}
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of<B, D>::value         // true
is_base_of<const B, D>::value   // true
is_base_of<B, const D>::value   // true
is_base_of<B, const B>::value   // true
is_base_of<D, B>::value         // false
is_base_of<B&, D&>::value       // false
is_base_of<B[3], D[3]>::value   // false
is_base_of<int, int>::value     // false
\end{codeblock}
\exitexample

\pnum
Given the following function prototype:

\begin{codeblock}
template <class T>
  add_rvalue_reference_t<T> create() noexcept;
\end{codeblock}

the predicate condition for a template specialization \tcode{is_convertible<From, To>}
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:

\begin{codeblock}
To test() {
  return create<From>();
}
\end{codeblock}

\enternote This requirement gives well defined results for reference types, void
types, array types, and function types.\exitnote Access checking is performed as
if in a context unrelated to \tcode{To} and \tcode{From}. Only the validity of
the immediate context of the expression of the \grammarterm{return-statement}
(including conversions to the return type) is considered. \enternote The
evaluation of the conversion can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the ``immediate context'' and can result in the program
being ill-formed. \exitnote

\rSec2[meta.trans]{Transformations between types}
\pnum
This sub-clause contains templates that may be used to transform one
type to another following some predefined rule.

\pnum
Each of the templates in this subclause shall be a
\term{TransformationTrait}~(\ref{meta.rqmts}).

\rSec3[meta.trans.cv]{Const-volatile modifications}

\begin{libreqtab2a}{Const-volatile modifications}{tab:type-traits.const-volatile}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>\br
 struct remove_const;}                  &
 The member typedef \tcode{type} shall name
 the same type as \tcode{T}
 except that any top-level const-qualifier has been removed.
 \enterexample \tcode{remove_const_t<const volatile int>} evaluates
 to \tcode{volatile int}, whereas \tcode{remove_const_t<const int*>} evaluates to
 \tcode{const int*}. \exitexample                          \\  \rowsep
\tcode{template <class T>\br
 struct remove_volatile;}               &
 The member typedef \tcode{type} shall name
 the same type as \tcode{T}
 except that any top-level volatile-qualifier has been removed.
 \enterexample \tcode{remove_volatile_t<const volatile int>}
 evaluates to \tcode{const int},
 whereas \tcode{remove_volatile_t<volatile int*>} evaluates to \tcode{volatile int*}.
 \exitexample                                              \\  \rowsep
\tcode{template <class T>\br
 struct remove_cv;}                 &
 The member typedef \tcode{type} shall be the same as \tcode{T}
 except that any top-level cv-qualifier has been removed.
 \enterexample \tcode{remove_cv_t<const volatile int>}
 evaluates to \tcode{int}, whereas \tcode{remove_cv_t<const volatile int*>}
 evaluates to \tcode{const volatile int*}. \exitexample  \\  \rowsep
\tcode{template <class T>\br
 struct add_const;}                 &
 If \tcode{T} is a reference, function, or top-level const-qualified
 type, then \tcode{type} shall name
 the same type as \tcode{T}, otherwise
 \tcode{T const}.                                                           \\  \rowsep
\tcode{template <class T>\br
 struct add_volatile;}                  &
 If \tcode{T} is a reference, function, or top-level volatile-qualified
 type, then \tcode{type} shall name
 the same type as \tcode{T}, otherwise
 \tcode{T volatile}.                                                            \\  \rowsep
\tcode{template <class T>\br
 struct add_cv;}                    &
 The member typedef \tcode{type} shall name
 the same type as
 \tcode{add_const_t<add_volatile_t<T>{>}}.                               \\
\end{libreqtab2a}

\rSec3[meta.trans.ref]{Reference modifications}

\begin{libreqtab2a}{Reference modifications}{tab:type-traits.reference}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\tcode{template <class T>\br
 struct remove_reference;}                  &
 If \tcode{T} has type ``reference to \tcode{T1}'' then the
 member typedef \tcode{type} shall name \tcode{T1};
 otherwise, \tcode{type} shall name \tcode{T}.\\ \rowsep

\tcode{template <class T>\br
 struct add_lvalue_reference;}                     &
 If \tcode{T} names an object or function type then
 the member typedef \tcode{type} shall name \tcode{T\&};
 otherwise, if \tcode{T} names a
  type ``rvalue reference to \tcode{T1}'' then
 the member typedef \tcode{type} shall name \tcode{T1\&};
 otherwise, \tcode{type} shall
 name \tcode{T}. \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct add_rvalue_reference;}    &
 If \tcode{T} names an object or function type then
 the member typedef \tcode{type} shall name \tcode{T\&\&};
 otherwise, \tcode{type} shall name \tcode{T}.
 \enternote This rule reflects the semantics of reference collapsing~(\ref{dcl.ref}).
 For example, when a type \tcode{T} names a type \tcode{T1\&}, the type
 \tcode{add_rvalue_reference_t<T>} is not an rvalue reference.
 \exitnote \\
\end{libreqtab2a}

\rSec3[meta.trans.sign]{Sign modifications}
\begin{libreqtab2a}{Sign modifications}{tab:type-traits.sign}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>}\br
 \tcode{struct make_signed;} &
 If \tcode{T} names a (possibly cv-qualified) signed integer
 type~(\ref{basic.fundamental}) then the member typedef
 \tcode{type} shall name the type \tcode{T}; otherwise,
 if \tcode{T} names a (possibly cv-qualified) unsigned integer
 type then \tcode{type} shall name the corresponding
 signed integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} shall name the signed integer type with smallest
 rank~(\ref{conv.rank}) for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \requires \tcode{T} shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a \tcode{bool} type.\\ \rowsep
\tcode{template <class T>}\br
 \tcode{struct make_unsigned;} &
 If \tcode{T} names a (possibly cv-qualified) unsigned integer
 type~(\ref{basic.fundamental}) then the member typedef
 \tcode{type} shall name the type \tcode{T}; otherwise,
 if \tcode{T} names a (possibly cv-qualified) signed integer
 type then \tcode{type} shall name the corresponding
 unsigned integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} shall name the unsigned integer type with smallest
 rank~(\ref{conv.rank}) for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \requires \tcode{T} shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a \tcode{bool} type.\\
\end{libreqtab2a}
\clearpage

\rSec3[meta.trans.arr]{Array modifications}
\begin{libreqtab2a}{Array modifications}{tab:type-traits.array}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>\br
 struct remove_extent;}                 &
 If \tcode{T} names a type ``array of \tcode{U}'',
 the member typedef \tcode{type} shall
 be \tcode{U}, otherwise \tcode{T}.
 \enternote For multidimensional arrays, only the first array dimension is
 removed. For a type ``array of \tcode{const U}'', the resulting type is
 \tcode{const U}. \exitnote                                 \\  \rowsep
\tcode{template <class T>\br
 struct remove_all_extents;}                &
 If \tcode{T} is ``multi-dimensional array of \tcode{U}'', the resulting member
 typedef \tcode{type} is \tcode{U}, otherwise \tcode{T}.                                       \\
\end{libreqtab2a}

\pnum
[\textit{Example}
\begin{codeblock}
// the following assertions hold:
assert((is_same<remove_extent_t<int>, int>::value));
assert((is_same<remove_extent_t<int[2]>, int>::value));
assert((is_same<remove_extent_t<int[2][3]>, int[3]>::value));
assert((is_same<remove_extent_t<int[][3]>, int[3]>::value));
\end{codeblock}
\exitexample

\pnum
[\textit{Example}
\begin{codeblock}
// the following assertions hold:
assert((is_same<remove_all_extents_t<int>, int>::value));
assert((is_same<remove_all_extents_t<int[2]>, int>::value));
assert((is_same<remove_all_extents_t<int[2][3]>, int>::value));
assert((is_same<remove_all_extents_t<int[][3]>, int>::value));
\end{codeblock}
\exitexample

\rSec3[meta.trans.ptr]{Pointer modifications}
\begin{libreqtab2a}{Pointer modifications}{tab:type-traits.pointer}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template <class T>\br
 struct remove_pointer;}                    &
 If \tcode{T} has type ``(possibly cv-qualified) pointer
 to \tcode{T1}'' then the member typedef \tcode{type}
 shall name \tcode{T1}; otherwise, it shall name \tcode{T}.\\ \rowsep
\tcode{template <class T>\br
 struct add_pointer;}                       &
 The member typedef \tcode{type} shall name the same type as
 \tcode{remove_reference_t<T>*}.                         \\
\end{libreqtab2a}
\clearpage

\rSec3[meta.trans.other]{Other transformations}

\begin{libreqtab3d}{Other transformations}{tab:type-traits.other}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead

\tcode{template <std::size_t Len,\br
 std::size_t Align\br
 = \textit{default-alignment}>\br
 struct aligned_storage;}
 &
 \tcode{Len} shall not be zero.
 \tcode{Align} shall be equal
 to \tcode{alignof(T)} for some type \tcode{T}
 or to \textit{default-alignment}.
 &
 The value of \textit{default-alignment} shall be the most
 stringent alignment requirement for any \Cpp object type whose size
 is no greater than \tcode{Len}~(\ref{basic.types}).
 The member typedef \tcode{type} shall be a POD type
 suitable for use as uninitialized storage for any object whose size
 is at most \textit{Len} and whose alignment is a divisor of \textit{Align}. \\ \rowsep

\tcode{template <std::size_t Len,\br
  class... Types>\br
  struct aligned_union;}
  &
  At least one type is provided.
  &
  The member typedef \tcode{type} shall be a POD type suitable for use as
  uninitialized storage for any object whose type is listed in \tcode{Types};
  its size shall be at least \tcode{Len}. The static member \tcode{alignment_value}
  shall be an integral constant of type \tcode{std::size_t} whose value is the
  strictest alignment of all types listed in \tcode{Types}.
  \\ \rowsep

\tcode{template <class T> struct} \tcode{decay;} &   &
 Let \tcode{U} be \tcode{remove_reference_t<T>}. If \tcode{is_array<U>::value}
 is \tcode{true}, the member typedef \tcode{type} shall equal
 \tcode{remove_extent_t<U>*}. If \tcode{is_function<U>::value} is \tcode{true},
 the member typedef \tcode{type} shall equal \tcode{add_pointer_t<U>}. Otherwise
 the member typedef \tcode{type} equals \tcode{remove_cv_t<U>}.
 \enternote This behavior is similar to the lvalue-to-rvalue~(\ref{conv.lval}),
 array-to-pointer~(\ref{conv.array}), and function-to-pointer~(\ref{conv.func})
 conversions applied when an lvalue expression is used as an rvalue, but also
 strips \cv-qualifiers from class types in order to more closely model by-value
 argument passing. \exitnote
 \\ \rowsep

\tcode{template <bool B, class T = void>} \tcode{struct enable_if;} & &
 If \tcode{B} is \tcode{true}, the member typedef \tcode{type}
 shall equal \tcode{T}; otherwise, there shall be no member
 \tcode{type}. \\ \rowsep

\tcode{template <bool B, class T,} \tcode{class F> struct conditional}; & &
 If \tcode{B} is \tcode{true}, the member typedef \tcode{type}
 shall equal \tcode{T}.
 If \tcode{B} is \tcode{false}, the member typedef \tcode{type}
 shall equal \tcode{F}. \\ \rowsep

 \tcode{template <class... T>} \tcode{struct common_type;} & &
 The member typedef \tcode{type} shall be defined as set out below. All types in
the parameter pack \tcode{T} shall be complete or (possibly \cv) \tcode{void}. A
program may specialize this trait if at least one template parameter in the
specialization is a user-defined type. \enternote Such specializations are
needed when only explicit conversions are desired among the template arguments.
\exitnote \\ \rowsep

\tcode{template <class T>}\br
 \tcode{struct underlying_type;}  &
 \tcode{T} shall be an enumeration type~(\ref{dcl.enum}) &
 The member typedef \tcode{type} shall name the underlying type
 of \tcode{T}. \\ \rowsep

\tcode{template <class Fn,}\br
 \tcode{class... ArgTypes> struct}
 \tcode{result_of<Fn(ArgTypes...)>;}  &
 \tcode{Fn} and all types in the parameter pack \tcode{ArgTypes} shall
 be complete types, (possibly cv-qualified) \tcode{void}, or arrays of
 unknown bound. &
 If the expression \tcode{INVOKE(declval<Fn>(), declval<ArgTypes>()...)}
 is well formed when treated as an unevaluated operand (Clause~\ref{expr}),
 the member typedef \tcode{type} shall name the type
 \tcode{decltype(INVOKE(declval<Fn>(),} \tcode{declval<ArgTypes>()...))};
 otherwise, there shall be no member \tcode{type}. Access checking is
 performed as if in a context unrelated to \tcode{Fn} and
 \tcode{ArgTypes}. Only the validity of the immediate context of the
 expression is considered.
 \enternote
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the ``immediate
 context'' and can result in the program being ill-formed.
 \exitnote \\
 \end{libreqtab3d}

\pnum
\enternote A typical implementation would define \tcode{aligned_storage} as:

\begin{codeblock}
template <std::size_t Len, std::size_t Alignment>
struct aligned_storage {
  typedef struct {
    alignas(Alignment) unsigned char __data[Len];
  } type;
};
\end{codeblock}
\exitnote

\pnum
It is \impldef{support for extended alignment} whether any extended alignment is
supported~(\ref{basic.align}).

\pnum
The nested typedef \tcode{common_type::type} shall be defined as follows:

\begin{codeblock}
template <class ...T> struct common_type;

template <class T>
struct common_type<T> {
  typedef decay_t<T> type;
};

template <class T, class U>
struct common_type<T, U> {
  typedef decay_t<decltype(true ? declval<T>() : declval<U>())> type;
};

template <class T, class U, class... V>
struct common_type<T, U, V...> {
  typedef common_type_t<common_type_t<T, U>, V...> type;
};
\end{codeblock}

\pnum
\enterexample
Given these definitions:
\begin{codeblock}
typedef bool (&PF1)();
typedef short (*PF2)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&);
  void fn(long) const;
  char data;
};

typedef void (S::*PMF)(long) const;
typedef char S::*PMD;
\end{codeblock}

the following assertions will hold:

\begin{codeblock}
static_assert(is_same<result_of_t<S(int)>, short>::value, "Error!");
static_assert(is_same<result_of_t<S&(unsigned char, int&)>, double>::value, "Error!");
static_assert(is_same<result_of_t<PF1()>, bool>::value, "Error!");
static_assert(is_same<result_of_t<PMF(unique_ptr<S>, int)>, void>::value, "Error!");
static_assert(is_same<result_of_t<PMD(S)>, char&&>::value, "Error!");
static_assert(is_same<result_of_t<PMD(const S*)>, const char&>::value, "Error!");
\end{codeblock}
\exitexample

\rSec1[ratio]{Compile-time rational arithmetic}

\rSec2[ratio.general]{In general}

\pnum
\indexlibrary{\idxcode{ratio}}%
This subclause describes the ratio library. It provides a class template
\tcode{ratio} which exactly represents any finite rational number with a
numerator and denominator representable by compile-time constants of type
\tcode{intmax_t}.

\pnum
Throughout this subclause, the names of template parameters are used to express
type requirements. If a template parameter is named \tcode{R1} or \tcode{R2},
and the template argument is not a specialization of the \tcode{ratio} template,
the program is ill-formed.

\rSec2[ratio.syn]{Header \tcode{<ratio>} synopsis}

\begin{codeblockdigitsep}
namespace std {
  // \ref{ratio.ratio}, class template \tcode{ratio}
  template <intmax_t N, intmax_t D = 1> class ratio;

  // \ref{ratio.arithmetic}, ratio arithmetic
  template <class R1, class R2> using ratio_add = @\seebelow@;
  template <class R1, class R2> using ratio_subtract = @\seebelow@;
  template <class R1, class R2> using ratio_multiply = @\seebelow@;
  template <class R1, class R2> using ratio_divide = @\seebelow@;

  // \ref{ratio.comparison}, ratio comparison
  template <class R1, class R2> struct ratio_equal;
  template <class R1, class R2> struct ratio_not_equal;
  template <class R1, class R2> struct ratio_less;
  template <class R1, class R2> struct ratio_less_equal;
  template <class R1, class R2> struct ratio_greater;
  template <class R1, class R2> struct ratio_greater_equal;

  // \ref{ratio.si}, convenience SI typedefs
  typedef ratio<1, 1'000'000'000'000'000'000'000'000> yocto;  // \seebelow
  typedef ratio<1,     1'000'000'000'000'000'000'000> zepto;  // \seebelow
  typedef ratio<1,         1'000'000'000'000'000'000> atto;
  typedef ratio<1,             1'000'000'000'000'000> femto;
  typedef ratio<1,                 1'000'000'000'000> pico;
  typedef ratio<1,                     1'000'000'000> nano;
  typedef ratio<1,                         1'000'000> micro;
  typedef ratio<1,                             1'000> milli;
  typedef ratio<1,                               100> centi;
  typedef ratio<1,                                10> deci;
  typedef ratio<                               10, 1> deca;
  typedef ratio<                              100, 1> hecto;
  typedef ratio<                            1'000, 1> kilo;
  typedef ratio<                        1'000'000, 1> mega;
  typedef ratio<                    1'000'000'000, 1> giga;
  typedef ratio<                1'000'000'000'000, 1> tera;
  typedef ratio<            1'000'000'000'000'000, 1> peta;
  typedef ratio<        1'000'000'000'000'000'000, 1> exa;
  typedef ratio<    1'000'000'000'000'000'000'000, 1> zetta;  // \seebelow
  typedef ratio<1'000'000'000'000'000'000'000'000, 1> yotta;  // \seebelow
}
\end{codeblockdigitsep}

\rSec2[ratio.ratio]{Class template \tcode{ratio}}

\begin{codeblock}
namespace std {
  template <intmax_t N, intmax_t D = 1>
  class ratio {
  public:
    static constexpr intmax_t num;
    static constexpr intmax_t den;
    typedef ratio<num, den> type;
  };
}
\end{codeblock}

\pnum
If the template argument \tcode{D} is zero or the absolute values of either of the
template arguments \tcode{N} and \tcode{D} is not representable by type
\tcode{intmax_t}, the program is ill-formed. \enternote These rules ensure that infinite
ratios are avoided and that for any negative input, there exists a representable value
of its absolute value which is positive. In a two's complement representation, this
excludes the most negative value. \exitnote

\pnum
The static data members \tcode{num} and \tcode{den} shall have the following values,
where \tcode{gcd} represents the greatest common divisor of the absolute values of
\tcode{N} and \tcode{D}:

\begin{itemize}
\item \tcode{num} shall have the value \tcode{sign(N) * sign(D) * abs(N) / gcd}.
\item \tcode{den} shall have the value \tcode{abs(D) / gcd}.
\end{itemize}

\rSec2[ratio.arithmetic]{Arithmetic on \tcode{ratio}{s}}

\pnum
Each of the alias templates \tcode{ratio_add}, \tcode{ratio_subtract}, \tcode{ratio_multiply},
and \tcode{ratio_divide} denotes the result of an arithmetic computation on two
\tcode{ratio}{s} \tcode{R1} and \tcode{R2}. With \tcode{X} and \tcode{Y} computed (in the
absence of arithmetic overflow) as specified by Table~\ref{tab:ratio.arithmetic}, each alias
denotes a \tcode{ratio<U, V>} such that \tcode{U} is the same as \tcode{ratio<X, Y>::num} and
\tcode{V} is the same as \tcode{ratio<X, Y>::den}.

\pnum
If it is not possible to represent \tcode{U} or \tcode{V} with \tcode{intmax_t}, the program is
ill-formed. Otherwise, an implementation should yield correct values of \tcode{U} and
\tcode{V}. If it is not possible to represent \tcode{X} or \tcode{Y} with \tcode{intmax_t}, the
program is ill-formed unless the implementation yields correct values of \tcode{U} and
\tcode{V}.

\begin{floattable}{Expressions used to perform ratio arithmetic}{tab:ratio.arithmetic}
{lll}
\topline
\lhdr{Type}                     &
  \chdr{Value of \tcode{X}}     &
  \rhdr{Value of \tcode{Y}}     \\ \rowsep

\tcode{ratio_add<R1, R2>}       &
  \tcode{R1::num * R2::den +}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_subtract<R1, R2>}  &
  \tcode{R1::num * R2::den -}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_multiply<R1, R2>}  &
  \tcode{R1::num * R2::num}     &
  \tcode{R1::den * R2::den}     \\ \rowsep

\tcode{ratio_divide<R1, R2>}    &
  \tcode{R1::num * R2::den}     &
  \tcode{R1::den * R2::num}     \\
\end{floattable}

\pnum
\enterexample

\begin{codeblock}
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::den == 2, "1/3*3/2 == 1/2");

  // The following cases may cause the program to be ill-formed under some implementations
static_assert(ratio_add<ratio<1,INT_MAX>, ratio<1,INT_MAX>>::num == 2,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add<ratio<1,INT_MAX>, ratio<1,INT_MAX>>::den == INT_MAX,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply<ratio<1,INT_MAX>, ratio<INT_MAX,2>>::num == 1,
  "1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply<ratio<1,INT_MAX>, ratio<INT_MAX,2>>::den == 2,
  "1/MAX * MAX/2 == 1/2");
\end{codeblock}

\exitexample

\rSec2[ratio.comparison]{Comparison of \tcode{ratio}{s}}

\indexlibrary{\idxcode{ratio_equal}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_equal
  : integral_constant<bool, @\seebelow@> { };
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{R1::num == R2::num} and \tcode{R1::den == R2::den}, \tcode{ratio_equal<R1,
R2>} shall be derived from\\ \tcode{integral_constant<bool, true>}; otherwise it shall
be derived from \tcode{integral_constant<bool, false>}.
\end{itemdescr}

\indexlibrary{\idxcode{ratio_not_equal}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_not_equal
  : integral_constant<bool, !ratio_equal<R1, R2>::value> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_less}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_less
  : integral_constant<bool, @\seebelow@> { };
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{R1::num * R2::den < R2::num * R1::den}, \tcode{ratio_less<R1, R2>} shall be
derived from \tcode{integral_constant<bool, true>}; otherwise it shall be derived from
\tcode{integral_constant<bool, false>}. Implementations may use other algorithms to
compute this relationship to avoid overflow. If overflow occurs, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{ratio_less_equal}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_less_equal
  : integral_constant<bool, !ratio_less<R2, R1>::value> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_greater}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_greater
  : integral_constant<bool, ratio_less<R2, R1>::value> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_greater_equal}}
\begin{itemdecl}
template <class R1, class R2> struct ratio_greater_equal
  : integral_constant<bool, !ratio_less<R1, R2>::value> { };
\end{itemdecl}

\rSec2[ratio.si]{SI types for \tcode{ratio}}

\pnum
For each of the typedefs \tcode{yocto}, \tcode{zepto}, \tcode{zetta}, and \tcode{yotta},
if both of the constants used in its specification are representable by
\tcode{intmax_t}, the typedef shall be defined; if either of the constants is not
representable by \tcode{intmax_t}, the typedef shall not be defined.

\rSec1[time]{Time utilities}

\rSec2[time.general]{In general}

\pnum
\indexlibrary{\idxcode{chrono}}%
This subclause describes the chrono library~(\ref{time.syn}) and various C
functions~(\ref{date.time}) that provide generally useful time
utilities.

\rSec2[time.syn]{Header \tcode{<chrono>} synopsis}

\begin{codeblock}
namespace std {
namespace chrono {

// \ref{time.duration}, class template \tcode{duration}
template <class Rep, class Period = ratio<1> > class duration;

// \ref{time.point}, class template \tcode{time_point}
template <class Clock, class Duration = typename Clock::duration> class time_point;

}  // namespace chrono

// \ref{time.traits.specializations} \tcode{common_type} specializations
template <class Rep1, class Period1, class Rep2, class Period2>
  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {

// \ref{time.traits}, customization traits
template <class Rep> struct treat_as_floating_point;
template <class Rep> struct duration_values;

// \ref{time.duration.nonmember}, duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>
  common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  constexpr operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  constexpr operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
  duration<common_type_t<Rep1, Rep2>, Period>
  constexpr operator*(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Rep2, class Period>
  duration<common_type_t<Rep1, Rep2>, Period>
  constexpr operator*(const Rep1& s, const duration<Rep2, Period>& d);
template <class Rep1, class Period, class Rep2>
  duration<common_type_t<Rep1, Rep2>, Period>
  constexpr operator/(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
  common_type_t<Rep1, Rep2>
  constexpr operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
  duration<common_type_t<Rep1, Rep2>, Period>
  constexpr operator%(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
  common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  constexpr operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// \ref{time.duration.comparisons}, duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator==(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator!=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator< (const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator> (const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);

// \ref{time.duration.cast}, duration_cast
template <class ToDuration, class Rep, class Period>
  constexpr ToDuration duration_cast(const duration<Rep, Period>& d);

// convenience typedefs
typedef duration<@\term{signed integer type of at least 64 bits},@        nano> nanoseconds;
typedef duration<@\term{signed integer type of at least 55 bits},@       micro> microseconds;
typedef duration<@\term{signed integer type of at least 45 bits},@       milli> milliseconds;
typedef duration<@\term{signed integer type of at least 35 bits}@             > seconds;
typedef duration<@\term{signed integer type of at least 29 bits},@ ratio<  60>> minutes;
typedef duration<@\term{signed integer type of at least 23 bits},@ ratio<3600>> hours;

// \ref{time.point.nonmember}, time_point arithmetic
template <class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Clock, class Duration2>
  constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Clock, class Duration1, class Duration2>
  constexpr common_type_t<Duration1, Duration2>
  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// \ref{time.point.comparisons} time_point comparisons
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator!=(const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator< (const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator> (const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
                             const time_point<Clock, Duration2>& rhs);

// \ref{time.point.cast}, time_point_cast
template <class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration>
  time_point_cast(const time_point<Clock, Duration>& t);

// \ref{time.clock}, clocks
class system_clock;
class steady_clock;
class high_resolution_clock;

}  // namespace chrono

inline namespace literals {
inline namespace chrono_literals {

// ~\ref{time.duration.literals}, suffixes for duration literals
constexpr chrono::hours                                 operator "" h(unsigned long long);
constexpr chrono::duration<@\unspec@, ratio<3600,1>> operator "" h(long double);
constexpr chrono::minutes                               operator "" min(unsigned long long);
constexpr chrono::duration<@\unspec@, ratio<60,1>>   operator "" min(long double);
constexpr chrono::seconds                               operator "" s(unsigned long long);
constexpr chrono::duration<@\unspec@>                operator "" s(long double);
constexpr chrono::milliseconds                          operator "" ms(unsigned long long);
constexpr chrono::duration<@\unspec@, milli>         operator "" ms(long double);
constexpr chrono::microseconds                          operator "" us(unsigned long long);
constexpr chrono::duration<@\unspec@, micro>         operator "" us(long double);
constexpr chrono::nanoseconds                           operator "" ns(unsigned long long);
constexpr chrono::duration<@\unspec@, nano>          operator "" ns(long double);

}  // namespace chrono_literals
}  // namespace literals

namespace chrono {

using namespace literals::chrono_literals;

} // namespace chrono

}  // namespace std
\end{codeblock}

\rSec2[time.clock.req]{Clock requirements}

\pnum
A clock is a bundle consisting of a \tcode{duration}, a
\tcode{time_point}, and a function \tcode{now()} to get the current \tcode{time_point}.
The origin of the clock's \tcode{time_point} is referred to as the clock's \defn{epoch}.
 A clock shall meet the requirements in Table~\ref{tab:time.clock}.

\pnum
In Table~\ref{tab:time.clock} \tcode{C1} and \tcode{C2} denote clock types. \tcode{t1} and
\tcode{t2} are values returned by \tcode{C1::now()} where the call returning \tcode{t1} happens
before~(\ref{intro.multithread}) the call returning \tcode{t2} and both of these calls
occur
before \tcode{C1::time_point::max()}.
\enternote this means \tcode{C1} did not wrap around between \tcode{t1} and
\tcode{t2}. \exitnote

\begin{libreqtab3a}
{Clock requirements}
{tab:time.clock}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Operational semantics} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Operational semantics}       \\ \capsep
\endhead

\tcode{C1::rep} &
  An arithmetic type or a class emulating an arithmetic type &
  The representation type of \tcode{C1::duration}.  \\ \rowsep

\tcode{C1::period}  &
  a specialization of \tcode{ratio}     &
  The tick period of the clock in seconds.  \\ \rowsep

\tcode{C1::duration}  &
  \tcode{chrono::duration<C1::rep, C1::period>} &
  The \tcode{duration} type of the clock. \\ \rowsep

\tcode{C1::time_point}  &
  \tcode{chrono::time_point<C1>} or \tcode{chrono::time_point<C2, C1::duration>}  &
  The \tcode{time_point} type of the clock. \tcode{C1} and \tcode{C2} shall
  refer to the same epoch. \\ \rowsep

\tcode{C1::is_steady}  &
  \tcode{const bool}      &
  \tcode{true} if \tcode{t1 <= t2} is always \tcode{true} and the time between clock
  ticks is constant, otherwise \tcode{false}.  \\ \rowsep

\tcode{C1::now()} &
  \tcode{C1::time_point}  &
  Returns a \tcode{time_point} object representing the current point in time. \\

\end{libreqtab3a}

\pnum
\enternote The relative difference in durations between those reported by a given clock and the
SI definition is a measure of the quality of implementation. \exitnote

\pnum
A type \tcode{TC} meets the \tcode{TrivialClock} requirements if:

\begin{itemize}
\item \tcode{TC} satisfies the \tcode{Clock} requirements~(\ref{time.clock.req}),

\item the types \tcode{TC::rep}, \tcode{TC::duration}, and \tcode{TC::time_point}
satisfy the requirements of \tcode{EqualityCom\-parable} (Table \ref{equalitycomparable}),
\tcode{LessThanComparable} (Table \ref{lessthancomparable}),
\tcode{DefaultConstructible} (Table \ref{defaultconstructible}),
\tcode{CopyCon\-structible} (Table \ref{copyconstructible}),
\tcode{CopyAssignable} (Table \ref{copyassignable}),
\tcode{Destructible} (Table \ref{destructible}), and the requirements of
numeric types~(\ref{numeric.requirements}). \enternote this means, in particular,
that operations on these types will not throw exceptions. \exitnote

\item lvalues of the types \tcode{TC::rep}, \tcode{TC::duration}, and
\tcode{TC::time_point} are swappable~(\ref{swappable.requirements}),

\item the function \tcode{TC::now()} does not throw exceptions, and

\item the type \tcode{TC::time_point::clock} meets the \tcode{TrivialClock}
requirements, recursively.
\end{itemize}

\rSec2[time.traits]{Time-related traits}

\rSec3[time.traits.is_fp]{\tcode{treat_as_floating_point}}

\indexlibrary{\idxcode{treat_as_floating_point}}%
\begin{itemdecl}
template <class Rep> struct treat_as_floating_point
  : is_floating_point<Rep> { };
\end{itemdecl}

\pnum
The \tcode{duration} template uses the \tcode{treat_as_floating_point} trait to
help determine if a \tcode{duration} object can be converted to another
\tcode{duration} with a different tick \tcode{period}. If
\tcode{treat_as_floating_point<Rep>::value} is true, then implicit conversions
are allowed among \tcode{duration}s. Otherwise, the implicit convertibility
depends on the tick \tcode{period}s of the \tcode{duration}s.
\enternote
The intention of this trait is to indicate whether a given class behaves like a floating-point
type, and thus allows division of one value by another with acceptable loss of precision. If
\tcode{treat_as_floating_point<Rep>::value} is \tcode{false}, \tcode{Rep} will be treated as
if it behaved like an integral type for the purpose of these conversions.
\exitnote

\rSec3[time.traits.duration_values]{\tcode{duration_values}}

\indexlibrary{\idxcode{duration_values}}%
\begin{itemdecl}
template <class Rep>
struct duration_values {
public:
  static constexpr Rep zero();
  static constexpr Rep min();
  static constexpr Rep max();
};
\end{itemdecl}

\pnum
The \tcode{duration} template uses the \tcode{duration_values} trait to
construct special values of the durations representation (\tcode{Rep}). This is
done because the representation might be a class type with behavior which
requires some other implementation to return these special values. In that case,
the author of that class type should specialize \tcode{duration_values} to
return the indicated values.

\indexlibrary{\idxcode{zero}!\idxcode{duration_values}}%
\indexlibrary{\idxcode{duration_values}!\idxcode{zero}}%
\begin{itemdecl}
static constexpr Rep zero();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{Rep(0)}. \enternote \tcode{Rep(0)} is specified instead of
\tcode{Rep()} because \tcode{Rep()} may have some other meaning, such as an
uninitialized value. \exitnote

\pnum
\remark The value returned shall be the additive identity.
\end{itemdescr}

\indexlibrary{\idxcode{min}!\idxcode{duration_values}}%
\indexlibrary{\idxcode{duration_values}!\idxcode{min}}%
\begin{itemdecl}
static constexpr Rep min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{numeric_limits<Rep>::lowest()}.

\pnum
\remark The value returned shall compare less than or equal to \tcode{zero()}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{duration_values}}%
\indexlibrary{\idxcode{duration_values}!\idxcode{max}}%
\begin{itemdecl}
static constexpr Rep max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{numeric_limits<Rep>::max()}.

\pnum
\remark The value returned shall compare greater than \tcode{zero()}.
\end{itemdescr}

\rSec3[time.traits.specializations]{Specializations of \tcode{common_type}}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>> {
  typedef chrono::duration<common_type_t<Rep1, Rep2>, @\seebelow@> type;
};
\end{itemdecl}

\pnum
The \tcode{period} of the \tcode{duration} indicated by this specialization of
\tcode{common_type} shall be the greatest common divisor of \tcode{Period1} and
\tcode{Period2}. \enternote This can be computed by forming a ratio of the
greatest common divisor of \tcode{Period1::num} and \tcode{Period2::num} and the
least common multiple of \tcode{Period1::den} and \tcode{Period2::den}.
\exitnote

\pnum
\enternote The \tcode{typedef} name \tcode{type} is a synonym for the
\tcode{duration} with the largest tick \tcode{period} possible where both
\tcode{duration} arguments will convert to it without requiring a division
operation. The representation of this type is intended to be able to hold any
value resulting from this conversion with no truncation error, although
floating-point durations may have round-off errors. \exitnote

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>> {
  typedef chrono::time_point<Clock, common_type_t<Duration1, Duration2>> type;
};
\end{itemdecl}

\pnum
The common type of two \tcode{time_point} types is a \tcode{time_point} with the same
clock as the two types and the common type of their two \tcode{duration}s.

\rSec2[time.duration]{Class template \tcode{duration}}

\pnum
A \tcode{duration} type measures time between two points in time (\tcode{time_point}s).
A \tcode{duration} has a representation which holds a count of ticks and a tick period.
The tick period is the amount of time which occurs from one tick to the next, in units
of seconds. It is expressed as a rational constant using the template \tcode{ratio}.

\begin{codeblock}
template <class Rep, class Period = ratio<1>>
class duration {
public:
  typedef Rep    rep;
  typedef Period period;
private:
  rep rep_;  // \expos
public:
  // \ref{time.duration.cons}, construct/copy/destroy:
  constexpr duration() = default;
  template <class Rep2>
      constexpr explicit duration(const Rep2& r);
  template <class Rep2, class Period2>
     constexpr duration(const duration<Rep2, Period2>& d);
  ~duration() = default;
  duration(const duration&) = default;
  duration& operator=(const duration&) = default;

  // \ref{time.duration.observer}, observer:
  constexpr rep count() const;

  // \ref{time.duration.arithmetic}, arithmetic:
  constexpr duration  operator+() const;
  constexpr duration  operator-() const;
  duration& operator++();
  duration  operator++(int);
  duration& operator--();
  duration  operator--(int);

  duration& operator+=(const duration& d);
  duration& operator-=(const duration& d);

  duration& operator*=(const rep& rhs);
  duration& operator/=(const rep& rhs);
  duration& operator%=(const rep& rhs);
  duration& operator%=(const duration& rhs);

  // \ref{time.duration.special}, special values:
  static constexpr duration zero();
  static constexpr duration min();
  static constexpr duration max();
};
\end{codeblock}

\begin{itemdescr}
\pnum
\requires \tcode{Rep} shall be an arithmetic type or a class emulating an arithmetic type.

\pnum
\notes If \tcode{duration} is instantiated with a \tcode{duration} type for the template
argument \tcode{Rep}, the program is ill-formed.

\pnum
\notes If \tcode{Period} is not a specialization of \tcode{ratio}, the program is ill-formed.

\pnum
\notes If \tcode{Period::num} is not positive, the program is ill-formed.

\pnum
\requires Members of \tcode{duration} shall not throw exceptions other than
those thrown by the indicated operations on their representations.

\pnum
\remarks The defaulted copy constructor of duration shall be a
\tcode{constexpr} function if and only if the required initialization
of the member \tcode{rep_} for copy and move, respectively, would
satisfy the requirements for a \tcode{constexpr} function.
\end{itemdescr}

\enterexample
\begin{codeblock}
duration<long, ratio<60>> d0;       // holds a count of minutes using a \tcode{long}
duration<long long, milli> d1;      // holds a count of milliseconds using a \tcode{long long}
duration<double, ratio<1, 30>>  d2; // holds a count with a tick period of $\frac{1}{30}$ of a second
                                    // (30 Hz) using a \tcode{double}
\end{codeblock}
\exitexample

\rSec3[time.duration.cons]{\tcode{duration} constructors}

\indexlibrary{\idxcode{duration}!constructor}%
\begin{itemdecl}
template <class Rep2>
  constexpr explicit duration(const Rep2& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload
resolution unless
\tcode{Rep2} is implicitly convertible to \tcode{rep} and
\begin{itemize}
\item \tcode{treat_as_floating_point<rep>::value} is \tcode{true} or
\item \tcode{treat_as_floating_point<Rep2>::value} is \tcode{false}.
\end{itemize}
\enterexample
\begin{codeblock}
duration<int, milli> d(3);          // OK
duration<int, milli> d(3.5);        // error
\end{codeblock}
\exitexample

\pnum
\effects Constructs an object of type \tcode{duration}.

\pnum
\postcondition \tcode{count() == static_cast<rep>(r)}.
\end{itemdescr}

\indexlibrary{\idxcode{duration}!constructor}%
\begin{itemdecl}
template <class Rep2, class Period2>
  constexpr duration(const duration<Rep2, Period2>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload resolution unless
no overflow is induced in the conversion and
\tcode{treat_as_floating_point<rep>::value} is \tcode{true} or both
\tcode{ratio_divide<Period2, period>::den} is \tcode{1} and
\tcode{treat_as_floating_point<Rep2>::value} is \tcode{false}. \enternote This
requirement prevents implicit truncation error when converting between
integral-based \tcode{duration} types. Such a construction could easily lead to
confusion about the value of the \tcode{duration}. \exitnote
\enterexample
\begin{codeblock}
duration<int, milli> ms(3);
duration<int, micro> us = ms;       // OK
duration<int, milli> ms2 = us;      // error
\end{codeblock}
\exitexample

\pnum
\effects Constructs an object of type \tcode{duration}, constructing \tcode{rep_} from\\
\tcode{duration_cast<duration>(d).count()}.
\end{itemdescr}

\rSec3[time.duration.observer]{\tcode{duration} observer}

\indexlibrary{\idxcode{count}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{count}}%
\begin{itemdecl}
constexpr rep count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rep_}.
\end{itemdescr}

\rSec3[time.duration.arithmetic]{\tcode{duration} arithmetic}

\indexlibrary{\idxcode{operator+}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator+}}%
\begin{itemdecl}
constexpr duration operator+() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator-}}%
\begin{itemdecl}
constexpr duration operator-() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(-rep_);}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator++}}%
\begin{itemdecl}
duration& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++rep_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator++}}%
\begin{itemdecl}
duration operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(rep_++);}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\dcr}}%
\begin{itemdecl}
duration& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{-{-}rep_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\dcr}}%
\begin{itemdecl}
duration operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(rep_-{}-);}.
\end{itemdescr}

\indexlibrary{\idxcode{operator+=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator+=}}%
\begin{itemdecl}
duration& operator+=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ += d.count()}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator-=}}%
\begin{itemdecl}
duration& operator-=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ -= d.count()}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator*=}}%
\begin{itemdecl}
duration& operator*=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ *= rhs}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator/=}}%
\begin{itemdecl}
duration& operator/=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ /= rhs}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\%=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\%=}}%
\begin{itemdecl}
duration& operator%=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ \%= rhs}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\%=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\%=}}%
\begin{itemdecl}
duration& operator%=(const duration& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{rep_ \%= rhs.count()}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}


\rSec3[time.duration.special]{\tcode{duration} special values}

\indexlibrary{\idxcode{zero}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{zero}}%
\begin{itemdecl}
static constexpr duration zero();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::zero())}.
\end{itemdescr}

\indexlibrary{\idxcode{min}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{min}}%
\begin{itemdecl}
static constexpr duration min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::min())}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{max}}%
\begin{itemdecl}
static constexpr duration max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::max())}.
\end{itemdescr}

\rSec3[time.duration.nonmember]{\tcode{duration} non-member arithmetic}

\pnum
In the function descriptions that follow, \tcode{CD} represents the return type
of the function. \tcode{CR(A,B)} represents \tcode{common_type_t<A, B>}.

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns CD(CD(lhs).count() + CD(rhs).count()).
\end{itemdescr}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns CD(CD(lhs).count() - CD(rhs).count()).
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator*}}%
\begin{itemdecl}
template <class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
  operator*(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{CR(Rep1, Rep2)}.

\pnum
\returns CD(CD(d).count() * s).
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator*}}%
\begin{itemdecl}
template <class Rep1, class Rep2, class Period>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
  operator*(const Rep1& s, const duration<Rep2, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep1} is implicitly convertible to \tcode{CR(Rep1, Rep2)}.

\pnum
\returns \tcode{d * s}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator/}}%
\begin{itemdecl}
template <class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
  operator/(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{CR(Rep1, Rep2)}
and \tcode{Rep2} is not an instantiation of \tcode{duration}.

\pnum
\returns CD(CD(d).count() / s).
\end{itemdescr}

\indexlibrary{\idxcode{operator/}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator/}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<Rep1, Rep2>
  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CD(lhs).count() / CD(rhs).count()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\%}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\%}}%
\begin{itemdecl}
template <class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
  operator%(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{CR(Rep1, Rep2)} and
\tcode{Rep2} is not an instantiation of \tcode{duration}.

\pnum
\returns CD(CD(d).count() \% s).
\end{itemdescr}

\indexlibrary{\idxcode{operator\%}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator\%}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns CD(CD(lhs).count() \% CD(rhs).count()).
\end{itemdescr}


\rSec3[time.duration.comparisons]{\tcode{duration} comparisons}

\pnum
In the function descriptions that follow, \tcode{CT} represents
\tcode{common_type_t<A, B>}, where \tcode{A} and \tcode{B} are the types of
the two arguments to the function.

\indexlibrary{\idxcode{operator==}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator==}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs).count() == CT(rhs).count()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator<}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator<(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs).count() < CT(rhs).count()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{idxl}}%
\indexlibrary{\idxcode{idxl}!\idxcode{operator>}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator>(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

\rSec3[time.duration.cast]{\tcode{duration_cast}}

\indexlibrary{\idxcode{duration_cast}}%
\begin{itemdecl}
template <class ToDuration, class Rep, class Period>
  constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload
resolution unless \tcode{ToDuration} is an instantiation of \tcode{duration}.

\pnum
\returns Let \tcode{CF} be \tcode{ratio_divide<Period, typename
ToDuration::period>}, and \tcode{CR} be \tcode{common_type<} \tcode{typename
ToDuration::rep, Rep, intmax_t>::type.}
\begin{itemize}
\item If \tcode{CF::num == 1} and \tcode{CF::den == 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(d.count()))
\end{codeblock}

\item otherwise, if \tcode{CF::num != 1} and \tcode{CF::den == 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) * static_cast<CR>(CF::num)))
\end{codeblock}

\item otherwise, if \tcode{CF::num == 1} and \tcode{CF::den != 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) / static_cast<CR>(CF::den)))
\end{codeblock}

\item otherwise, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) * static_cast<CR>(CF::num) / static_cast<CR>(CF::den)))
\end{codeblock}
\end{itemize}

\realnotes This function does not use any implicit conversions; all conversions
are done with \tcode{static_cast}. It avoids multiplications and divisions when
it is known at compile time that one or more arguments is 1. Intermediate
computations are carried out in the widest representation and only converted to
the destination representation at the final step.
\end{itemdescr}

\rSec3[time.duration.literals]{Suffixes for duration literals}

\pnum
This section describes literal suffixes for constructing duration literals. The
suffixes \tcode{h}, \tcode{min}, \tcode{s}, \tcode{ms}, \tcode{us}, \tcode{ns}
denote duration values of the corresponding types \tcode{hours}, \tcode{minutes},
\tcode{seconds}, \tcode{milliseconds}, \tcode{microseconds}, and \tcode{nanoseconds}
respectively if they are applied to integral literals.

\pnum
If any of these suffixes are applied to a floating point literal the result is a
\tcode{chrono::duration} literal with an unspecified floating point representation.

\pnum
If any of these suffixes are applied to an integer literal and the resulting
\tcode{chrono::duration} value cannot be represented in the result type because
of overflow, the program is ill-formed.

\pnum
\enterexample
The following code shows some duration literals.
\begin{codeblock}
using namespace std::chrono_literals;
auto constexpr aday=24h;
auto constexpr lesson=45min;
auto constexpr halfanhour=0.5h;
\end{codeblock}
\exitexample

\begin{itemdecl}
constexpr chrono::hours                                 operator "" h(unsigned long long hours);
constexpr chrono::duration<@\unspec@, ratio<3600,1>> operator "" h(long double hours);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{hours} hours.
\end{itemdescr}

\begin{itemdecl}
constexpr chrono::minutes                             operator "" min(unsigned long long minutes);
constexpr chrono::duration<@\unspec@, ratio<60,1>> operator "" min(long double minutes);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{minutes} minutes.
\end{itemdescr}

\begin{itemdecl}
constexpr chrono::seconds                operator "" s(unsigned long long sec);
constexpr chrono::duration<@\unspec@> operator "" s(long double sec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{sec} seconds.

\pnum
\enternote
The same suffix \tcode{s} is used for \tcode{basic_string} but there is no
conflict, since duration suffixes apply to numbers and string literal suffixes
apply to character array literals.
\exitnote
\end{itemdescr}

\begin{itemdecl}
constexpr chrono::milliseconds                  operator "" ms(unsigned long long msec);
constexpr chrono::duration<@\unspec@, milli> operator "" ms(long double msec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{msec} milliseconds.
\end{itemdescr}

\begin{itemdecl}
constexpr chrono::microseconds                  operator "" us(unsigned long long usec);
constexpr chrono::duration<@\unspec@, micro> operator "" us(long double usec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{usec} microseconds.
\end{itemdescr}

\begin{itemdecl}
constexpr chrono::nanoseconds                  operator "" ns(unsigned long long nsec);
constexpr chrono::duration<@\unspec@, nano> operator "" ns(long double nsec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{nsec} nanoseconds.
\end{itemdescr}

\rSec2[time.point]{Class template \tcode{time_point}}

\begin{codeblock}
template <class Clock, class Duration = typename Clock::duration>
class time_point {
public:
  typedef Clock                     clock;
  typedef Duration                  duration;
  typedef typename duration::rep    rep;
  typedef typename duration::period period;
private:
  duration d_;  // \expos

public:
  // \ref{time.point.cons}, construct:
  constexpr time_point();  // has value epoch
  constexpr explicit time_point(const duration& d);  // same as time_point() + d
  template <class Duration2>
    constexpr time_point(const time_point<clock, Duration2>& t);

  // \ref{time.point.observer}, observer:
  constexpr duration time_since_epoch() const;

  // \ref{time.point.arithmetic}, arithmetic:
  time_point& operator+=(const duration& d);
  time_point& operator-=(const duration& d);

  // \ref{time.point.special}, special values:
  static constexpr time_point min();
  static constexpr time_point max();
};
\end{codeblock}

\pnum
\tcode{Clock} shall meet the Clock requirements~(\ref{time.clock}).

\pnum
If \tcode{Duration} is not an instance of \tcode{duration},
the program is ill-formed.

\rSec3[time.point.cons]{\tcode{time_point} constructors}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
constexpr time_point();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{duration::zero()}. Such a \tcode{time_point} object
represents the epoch.
\end{itemdescr}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
constexpr explicit time_point(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{d}. Such a \tcode{time_point} object represents the epoch
\tcode{+ d}.
\end{itemdescr}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
template <class Duration2>
  constexpr time_point(const time_point<clock, Duration2>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload resolution unless \tcode{Duration2}
is implicitly convertible to \tcode{duration}.

\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{t.time_since_epoch()}.
\end{itemdescr}

\rSec3[time.point.observer]{\tcode{time_point} observer}

\indexlibrary{\idxcode{time_point}!\idxcode{time_since_epoch}}%
\indexlibrary{\idxcode{time_since_epoch}!\idxcode{time_point}}%
\begin{itemdecl}
constexpr duration time_since_epoch() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{d_}.
\end{itemdescr}

\rSec3[time.point.arithmetic]{\tcode{time_point} arithmetic}

\indexlibrary{\idxcode{operator+=}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator+=}}%
\begin{itemdecl}
time_point& operator+=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{d_ += d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator-=}}%
\begin{itemdecl}
time_point& operator-=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{d_ -= d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec3[time.point.special]{\tcode{time_point} special values}

\indexlibrary{\idxcode{min}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{min}}%
\begin{itemdecl}
static constexpr time_point min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point(duration::min())}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{max}}%
\begin{itemdecl}
static constexpr time_point max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point(duration::max())}.
\end{itemdescr}

\rSec3[time.point.nonmember]{\tcode{time_point} non-member arithmetic}

\indexlibrary{\idxcode{operator+}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator+}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator+}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs.time_since_epoch() + rhs)}, where \tcode{CT} is the type of the return value.
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator+}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator+}}%
\begin{itemdecl}
template <class Rep1, class Period1, class Clock, class Duration2>
  constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs + lhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator-}}%
\indexlibrary{\idxcode{operator-}!\idxcode{duration}}%
\indexlibrary{\idxcode{duration}!\idxcode{operator-}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs + (-rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator-}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr common_type_t<Duration1, Duration2>
  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() - rhs.time_since_epoch()}.
\end{itemdescr}

\rSec3[time.point.comparisons]{\tcode{time_point} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator==}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() == rhs.time_since_epoch()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator<}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator<(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() < rhs.time_since_epoch()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator>}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator>(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{time_point}}%
\indexlibrary{\idxcode{time_point}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class Clock, class Duration1, class Duration2>
  constexpr bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

\rSec3[time.point.cast]{\tcode{time_point_cast}}

\indexlibrary{\idxcode{time_point_cast}}%
\begin{itemdecl}
template <class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration>
  time_point_cast(const time_point<Clock, Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload
resolution unless \tcode{ToDuration} is an
instantiation of \tcode{duration}.

\pnum
\returns \tcode{time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))}.
\end{itemdescr}

\rSec2[time.clock]{Clocks}

\pnum
The types defined in this subclause shall satisfy the
\tcode{TrivialClock}
requirements~(\ref{time.clock.req}).

\rSec3[time.clock.system]{Class \tcode{system_clock}}

\pnum
Objects of class \tcode{system_clock} represent wall clock time from the system-wide
realtime clock.

\begin{codeblock}
class system_clock {
public:
  typedef @\seebelow@                           rep;
  typedef ratio<@\unspec@, @\unspec@>   period;
  typedef chrono::duration<rep, period>       duration;
  typedef chrono::time_point<system_clock>    time_point;
  static constexpr bool is_steady =        @\unspec;@

  static time_point now() noexcept;

  // Map to C API
  static time_t      to_time_t  (const time_point& t) noexcept;
  static time_point  from_time_t(time_t t) noexcept;
};
\end{codeblock}

\indexlibrary{\idxcode{rep}!\idxcode{system_clock}}%
\indexlibrary{\idxcode{system_clock}!\idxcode{rep}}%
\begin{itemdecl}
typedef @\unspec@ system_clock::rep;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{system_clock::duration::min() < system_clock::duration::zero()} shall
be \tcode{true}. \enternote This implies that \tcode{rep} is a signed type. \exitnote
\end{itemdescr}

\indexlibrary{\idxcode{to_time_t}}%
\begin{itemdecl}
static time_t to_time_t(const time_point& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{time_t} object that represents the same point in time as \tcode{t}
when both values are restricted to the coarser of the precisions of \tcode{time_t} and
\tcode{time_point}.
It is implementation defined whether values are rounded or truncated to the
required precision.\indeximpldef{whether values are rounded or truncated to the
required precision when converting between \tcode{time_t} values and \tcode{time_point} objects.}
\end{itemdescr}

\indexlibrary{\idxcode{from_time_t}}%
\begin{itemdecl}
static time_point from_time_t(time_t t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{time_point} object that represents the same point in time as \tcode{t}
when both values are restricted to the coarser of the precisions of \tcode{time_t} and
\tcode{time_point}.
It is implementation defined whether values are rounded or truncated to the
required precision.\indeximpldef{whether values are rounded or truncated to the
required precision when converting between \tcode{time_t} values and \tcode{time_point} objects.}
\end{itemdescr}

\rSec3[time.clock.steady]{Class \tcode{steady_clock}}

\pnum
Objects of class \tcode{steady_clock} represent clocks for which values of \tcode{time_point}
never decrease as physical time advances and for which values of \tcode{time_point} advance at
a steady rate relative to real time. That is, the clock may not be adjusted.

\begin{codeblock}
class steady_clock {
public:
  typedef @\unspec@                               rep;
  typedef ratio<@\unspec@, @\unspec@>          period;
  typedef chrono::duration<rep, period>              duration;
  typedef chrono::time_point<@\unspec,@ duration>  time_point;
  static constexpr bool is_steady =               true;

  static time_point now() noexcept;
};
\end{codeblock}

\rSec3[time.clock.hires]{Class \tcode{high_resolution_clock}}

\pnum
Objects of class \tcode{high_resolution_clock} represent clocks with the
shortest tick period. \tcode{high_resolution_clock} may be a synonym for
\tcode{system_clock} or \tcode{steady_clock}.

\begin{codeblock}
class high_resolution_clock {
public:
  typedef @\unspec@                               rep;
  typedef ratio<@\unspec@, @\unspec@>          period;
  typedef chrono::duration<rep, period>              duration;
  typedef chrono::time_point<@\unspec@, duration> time_point;
  static constexpr bool is_steady =               @\unspec@;

  static time_point now() noexcept;
};
\end{codeblock}

\rSec2[date.time]{Date and time {functions}}

\pnum
Table~\ref{tab:util.hdr.ctime} describes the header
\tcode{<ctime>}.

\begin{libsyntab5}{ctime}{tab:util.hdr.ctime}

\macros             &
 \tcode{NULL}       &
 \tcode{CLOCKS_PER_SEC}     &
                    &
                    \\ \rowsep
\types              &
 \tcode{size_t}     &
 \tcode{clock_t}    &
 \tcode{time_t}     &
                    \\ \rowsep
\struct             &
 \tcode{tm}         &
                    &
                    &
                    \\ \rowsep
\cspan{\functions}  \\
\tcode{asctime}     &
 \tcode{clock}      &
 \tcode{difftime}   &
 \tcode{localtime}  &
 \tcode{strftime}   \\
\tcode{ctime}       &
 \tcode{gmtime}     &
 \tcode{mktime}     &
 \tcode{time}       &
                    \\
\end{libsyntab5}

\pnum
The contents are the same as the Standard C library header
\tcode{<time.h>.}\footnote{\tcode{strftime} supports the C conversion specifiers
\tcode{C}, \tcode{D}, \tcode{e}, \tcode{F}, \tcode{g}, \tcode{G}, \tcode{h},
\tcode{r}, \tcode{R}, \tcode{t}, \tcode{T}, \tcode{u}, \tcode{V}, and
\tcode{z}, and the modifiers \tcode{E} and \tcode{O}.}
The functions \tcode{asctime}, \tcode{ctime}, \tcode{gmtime}, and
\tcode{localtime} are not required to avoid data
races~(\ref{res.on.data.races}).

\xref
ISO C Clause 7.12, Amendment 1 Clause 4.6.4.

\rSec1[allocator.adaptor]{Class template \tcode{scoped_allocator_adaptor}}

\rSec2[allocator.adaptor.syn]{Header \tcode{<scoped_allocator>} synopsis}

\indexlibrary{\idxhdr{scoped_allocator}}%
\begin{codeblock}
  // scoped allocator adaptor
  template <class OuterAlloc, class... InnerAlloc>
    class scoped_allocator_adaptor;
  template <class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
  template <class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
\end{codeblock}

\pnum
The class template \tcode{scoped_allocator_adaptor} is an allocator template that
specifies the memory resource (the outer allocator) to be used by a container (as any
other allocator does) and also specifies an inner allocator resource to be passed to the
constructor of every element within the container. This adaptor is instantiated with one
outer and zero or more inner allocator types. If instantiated with only one allocator
type, the inner allocator becomes the \tcode{scoped_allocator_adaptor} itself, thus
using the same allocator resource for the container and every element within the
container and, if the elements themselves are containers, each of their elements
recursively. If instantiated with more than one allocator, the first allocator is the
outer allocator for use by the container, the second allocator is passed to the
constructors of the container's elements, and, if the elements themselves are
containers, the third allocator is passed to the elements' elements, and so on. If
containers are nested to a depth greater than the number of allocators, the last
allocator is used repeatedly, as in the single-allocator case, for any remaining
recursions. \enternote The \tcode{scoped_allocator_adaptor} is derived from the outer
allocator type so it can be substituted for the outer allocator type in most
expressions. \exitnote

\begin{codeblock}
namespace std {
  template <class OuterAlloc, class... InnerAllocs>
    class scoped_allocator_adaptor : public OuterAlloc {
  private:
    typedef allocator_traits<OuterAlloc> OuterTraits; // \expos
    scoped_allocator_adaptor<InnerAllocs...> inner;   // \expos
  public:
    typedef OuterAlloc outer_allocator_type;
    typedef @\seebelow@ inner_allocator_type;

    typedef typename OuterTraits::value_type value_type;
    typedef typename OuterTraits::size_type size_type;
    typedef typename OuterTraits::difference_type difference_type;
    typedef typename OuterTraits::pointer pointer;
    typedef typename OuterTraits::const_pointer const_pointer;
    typedef typename OuterTraits::void_pointer void_pointer;
    typedef typename OuterTraits::const_void_pointer const_void_pointer;

    typedef @\seebelow@ propagate_on_container_copy_assignment;
    typedef @\seebelow@ propagate_on_container_move_assignment;
    typedef @\seebelow@ propagate_on_container_swap;

    template <class Tp>
      struct rebind {
        typedef scoped_allocator_adaptor<
          OuterTraits::template rebind_alloc<Tp>, InnerAllocs...> other;
      };

    scoped_allocator_adaptor();
    template <class OuterA2>
      scoped_allocator_adaptor(OuterA2&& outerAlloc,
                               const InnerAllocs&... innerAllocs) noexcept;

    scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
    scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;

    template <class OuterA2>
      scoped_allocator_adaptor(
        const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
    template <class OuterA2>
      scoped_allocator_adaptor(
        scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;

    ~scoped_allocator_adaptor();

    inner_allocator_type& inner_allocator() noexcept;
    const inner_allocator_type& inner_allocator() const noexcept;
    outer_allocator_type& outer_allocator() noexcept;
    const outer_allocator_type& outer_allocator() const noexcept;

    pointer allocate(size_type n);
    pointer allocate(size_type n, const_void_pointer hint);
    void deallocate(pointer p, size_type n);
    size_type max_size() const;

    template <class T, class... Args>
      void construct(T* p, Args&&... args);
    template <class T1, class T2, class... Args1, class... Args2>
      void construct(pair<T1, T2>* p, piecewise_construct_t,
                     tuple<Args1...> x, tuple<Args2...> y);
    template <class T1, class T2>
      void construct(pair<T1, T2>* p);
    template <class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, U&& x, V&& y);
    template <class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, const pair<U, V>& x);
    template <class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, pair<U, V>&& x);

    template <class T>
      void destroy(T* p);

    scoped_allocator_adaptor select_on_container_copy_construction() const;
  };

  template <class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
  template <class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
}
\end{codeblock}

\rSec2[allocator.adaptor.types]{Scoped allocator adaptor member types}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{inner_allocator_type}}%
\indexlibrary{\idxcode{inner_allocator_type}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
typedef @\seebelow@ inner_allocator_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{scoped_allocator_adaptor<OuterAlloc>} if \tcode{sizeof...(InnerAllocs)} is
zero; otherwise,\\ \tcode{scoped_allocator_adaptor<InnerAllocs...>}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{propagate_on_container_copy_assignment}}%
\indexlibrary{\idxcode{propagate_on_container_copy_assignment}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_copy_assignment;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_copy_assignment::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{propagate_on_container_move_assignment}}%
\indexlibrary{\idxcode{propagate_on_container_move_assignment}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_move_assignment;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_move_assignment::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{propagate_on_container_swap}}%
\indexlibrary{\idxcode{propagate_on_container_swap}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
typedef @\seebelow@ propagate_on_container_swap;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_swap::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\rSec2[allocator.adaptor.cnstr]{Scoped allocator adaptor constructors}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects value-initializes the \tcode{OuterAlloc} base class and the \tcode{inner} allocator
object.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template <class OuterA2>
  scoped_allocator_adaptor(OuterA2&& outerAlloc,
                           const InnerAllocs&... innerAllocs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{OuterAlloc} shall be constructible from \tcode{OuterA2}.

\pnum
\effects initializes the \tcode{OuterAlloc} base class with
\tcode{std::forward<OuterA2>(outerAlloc)} and \tcode{inner} with \tcode{innerAllocs...}
(hence recursively initializing each allocator within the adaptor with the corresponding
allocator from the argument list).
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects initializes each allocator within the adaptor with the corresponding allocator
from \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects move constructs each allocator within the adaptor with the corresponding allocator
from \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template <class OuterA2>
  scoped_allocator_adaptor(const scoped_allocator_adaptor<OuterA2,
                                                          InnerAllocs...>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{OuterAlloc} shall be constructible from \tcode{OuterA2}.

\pnum
\effects initializes each allocator within the adaptor with the corresponding allocator
from \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template <class OuterA2>
  scoped_allocator_adaptor(scoped_allocator_adaptor<OuterA2,
                                                    InnerAllocs...>&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{OuterAlloc} shall be constructible from \tcode{OuterA2}.

\pnum
\effects initializes each allocator within the adaptor with the corresponding allocator rvalue
from \tcode{other}.
\end{itemdescr}

\rSec2[allocator.adaptor.members]{Scoped allocator adaptor members}

\pnum
In the \tcode{construct} member functions,
\textit{OUTERMOST(x)} is \tcode{x} if \tcode{x} does not have an
\tcode{outer_allocator()} member function and \\
\textit{OUTERMOST(x.outer_allocator())}
otherwise;
\textit{OUTERMOST_ALLOC_TRAITS(x)} is \\
\tcode{allocator_traits<decltype(\textit{OUTERMOST}(x))>}.
\enternote \textit{OUTERMOST}(x) and \\
\textit{OUTERMOST_ALLOC_TRAITS}(x) are recursive operations. It
is incumbent upon the definition of \tcode{outer_allocator()} to ensure that the
recursion terminates. It will terminate for all instantiations of \\
\tcode{scoped_allocator_adaptor}. \exitnote

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{inner_allocator}}%
\indexlibrary{\idxcode{inner_allocator}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*this} if \tcode{sizeof...(InnerAllocs)} is zero; otherwise,
\tcode{inner}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{outer_allocator}}%
\indexlibrary{\idxcode{outer_allocator}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
outer_allocator_type& outer_allocator() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<OuterAlloc\&>(*this)}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{outer_allocator}}%
\indexlibrary{\idxcode{outer_allocator}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
const outer_allocator_type& outer_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<const OuterAlloc\&>(*this)}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{allocate}}%
\indexlibrary{\idxcode{allocate}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
pointer allocate(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::allocate(outer_allocator(), n)}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{allocate}}%
\indexlibrary{\idxcode{allocate}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
pointer allocate(size_type n, const_void_pointer hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint)}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{deallocate}}%
\indexlibrary{\idxcode{deallocate}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
void deallocate(pointer p, size_type n) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n)};
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{max_size}}%
\indexlibrary{\idxcode{max_size}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
size_type max_size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::max_size(outer_allocator())}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T, class... Args>
  void construct(T* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects

\begin{itemize}
\item If \tcode{uses_allocator<T, inner_allocator_type>::value} is \tcode{false} and
\tcode{is_constructible<T, Args...>::value} is \tcode{true}, calls
\textit{OUTERMOST_ALLOC_TRAITS}(\tcode{*this})\tcode{::construct(\\
\textit{OUTERMOST}(*this), p, std::forward<Args>(args)...)}.

\item Otherwise, if \tcode{uses_allocator<T, inner_allocator_type>::value} is \tcode{true} and
\tcode{is_construc\-tible<T, allocator_arg_t, inner_allocator_type, Args...>::value} is \tcode{true}, calls
\textit{OUTERMOST_ALLOC_TRAITS}(\tcode{*this})\tcode{::construct(\textit{OUTERMOST}(*this),
p, allocator_arg,\\inner_allocator(), std::forward<Args>(args)...)}.

\item Otherwise, if \tcode{uses_allocator<T, inner_allocator_type>::value} is \tcode{true} and
\tcode{is_construct\-ible<T, Args..., inner_allocator_type>::value} is \tcode{true}, calls
\textit{OUTERMOST_ALLOC_TRAITS}(*this)::
\tcode{construct(\textit{OUTERMOST}(*this), p, std::forward<Args>(args)...,\\inner_allocator())}.

\item Otherwise, the program is ill-formed. \enternote An error will result if
\tcode{uses_allocator} evaluates to true but the specific constructor does not take an
allocator. This definition prevents a silent failure to pass an inner allocator to a
contained element. \exitnote
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T1, class T2, class... Args1, class... Args2>
  void construct(pair<T1, T2>* p,piecewise_construct_t,
                 tuple<Args1...> x, tuple<Args2...> y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires all of the types in \tcode{Args1} and \tcode{Args2} shall be
\tcode{CopyConstructible} (Table~\ref{copyconstructible}).

\pnum
\effects Constructs a \tcode{tuple} object \tcode{xprime} from \tcode{x} by the
following rules:

\begin{itemize}
\item If \tcode{uses_allocator<T1, inner_allocator_type>::value} is \tcode{false} and
\tcode{is_constructible<T1,
Args1...>::value} is \tcode{true}, then \tcode{xprime} is \tcode{x}.

\item Otherwise, if \tcode{uses_allocator<T1, inner_allocator_type>::value} is \tcode{true}
and
\tcode{is_construct\-ible<T1, allocator_arg_t, inner_allocator_type, Args1...>::value}
is
\tcode{true}, then \tcode{xprime} is
\tcode{tuple_cat(tuple<allocator_arg_t, inner_allocator_type\&>(
allocator_arg, inner_allocator()), std::move(x))}.

\item Otherwise, if \tcode{uses_allocator<T1, inner_allocator_type>::value} is
\tcode{true} and
\tcode{is_construct\-ible<T1, Args1..., inner_allocator_type>::value} is \tcode{true},
then \tcode{xprime} is
\tcode{tuple_cat(std::move(x), tuple<inner_allocator_type\&>(inner_allocator()))}.

\item Otherwise, the program is ill-formed.
\end{itemize}

and constructs a \tcode{tuple} object \tcode{yprime} from \tcode{y} by the following rules:

\begin{itemize}
\item If \tcode{uses_allocator<T2, inner_allocator_type>::value} is \tcode{false} and
\tcode{is_constructible<T2,
Args2...>::value} is \tcode{true}, then \tcode{yprime} is \tcode{y}.

\item Otherwise, if \tcode{uses_allocator<T2, inner_allocator_type>::value} is \tcode{true}
and
\tcode{is_construct\-ible<T2, allocator_arg_t, inner_allocator_type, Args2...>::value}
is
\tcode{true}, then \tcode{yprime} is
\tcode{tuple_cat(tuple<allocator_arg_t, inner_allocator_type\&>(
allocator_arg, inner_allocator()), std::move(y))}.

\item Otherwise, if \tcode{uses_allocator<T2, inner_allocator_type>::value} is
\tcode{true} and
\tcode{is_construct\-ible<T2, Args2..., inner_allocator_type>::value} is \tcode{true},
then \tcode{yprime} is
\tcode{tuple_cat(std::move(y), tuple<inner_allocator_type\&>(inner_allocator()))}.

\item Otherwise, the program is ill-formed.
\end{itemize}

then calls \tcode{\textit{OUTERMOST_ALLOC_TRAITS}(*this)::construct(\textit{OUTERMOST}(*this), p,\\
piecewise_construct, std::move(xprime), std::move(yprime))}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T1, class T2>
  void construct(pair<T1, T2>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{this->construct(p, piecewise_construct, tuple<>(), tuple<>())}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, U&& x, V&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{this->construct(p, piecewise_construct, forward_as_tuple(std::for\-ward<U>(x)), forward_as_tuple(std::forward<V>(y)))}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, const pair<U, V>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{this->construct(p, piecewise_construct, forward_as_tuple(x.first), forward_as_tuple(x.second))}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{construct}}%
\indexlibrary{\idxcode{construct}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, pair<U, V>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{this->construct(p, piecewise_construct, forward_as_tuple(std::for\-ward<U>(x.first)), forward_as_tuple(std::forward<V>(x.second)))}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!destructor}%
\begin{itemdecl}
template <class T>
  void destroy(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{\textit{OUTERMOST_ALLOC_TRAITS}(*this)::destroy(\textit{OUTERMOST}(*this), p)}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{select_on_container_copy_construction}}%
\indexlibrary{\idxcode{select_on_container_copy_construction}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
scoped_allocator_adaptor select_on_container_copy_construction() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A new scoped_allocator_adaptor object where each allocator \tcode{A} in the
adaptor is initialized from the result of calling
\tcode{allocator_traits<A>::select_on_container_copy_construction()} on the
corresponding allocator in \tcode{*this}.
\end{itemdescr}

\rSec2[scoped.adaptor.operators]{Scoped allocator operators}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{operator==}}%
\indexlibrary{\idxcode{operator==}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class OuterA1, class OuterA2, class... InnerAllocs>
  bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.outer_allocator() == b.outer_allocator()} if
\tcode{sizeof...(InnerAllocs)} is zero;
otherwise, \tcode{a.outer_allocator() == b.outer_allocator()}
\tcode{\&\&} \tcode{a.inner_allocator() == b.inner_allocator()}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!\idxcode{operator"!=}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{scoped_allocator_adaptor}}%
\begin{itemdecl}
template <class OuterA1, class OuterA2, class... InnerAllocs>
  bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(a == b)}.
\end{itemdescr}

\rSec1[type.index]{Class \tcode{type_index}}

\indexlibrary{\idxhdr{typeinfo}}%
\rSec2[type.index.synopsis]{Header \tcode{<typeindex>} synopsis}

\begin{codeblock}
namespace std {
  class type_index;
  template <class T> struct hash;
  template<> struct hash<type_index>;
}
\end{codeblock}

\rSec2[type.index.overview]{\tcode{type_index} overview}

\begin{codeblock}
namespace std {
  class type_index {
  public:
    type_index(const type_info& rhs) noexcept;
    bool operator==(const type_index& rhs) const noexcept;
    bool operator!=(const type_index& rhs) const noexcept;
    bool operator< (const type_index& rhs) const noexcept;
    bool operator<= (const type_index& rhs) const noexcept;
    bool operator> (const type_index& rhs) const noexcept;
    bool operator>= (const type_index& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;
  private:
    const type_info* target;    // \expos
    // Note that the use of a pointer here, rather than a reference,
    // means that the default copy/move constructor and assignment
    // operators will be provided and work as expected.
  };
}
\end{codeblock}

\pnum
The class \tcode{type_index} provides a simple wrapper for
\tcode{type_info} which can be used as an index type in associative
containers~(\ref{associative}) and in unordered associative
containers~(\ref{unord}).

\rSec2[type.index.members]{\tcode{type_index} members}

\indexlibrary{\idxcode{type_index}!constructor}%
\begin{itemdecl}
type_index(const type_info& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects constructs a \tcode{type_index} object, the equivalent of \tcode{target = \&rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator==}}%
\begin{itemdecl}
bool operator==(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*target == *rhs.target}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator"!=}}%
\begin{itemdecl}
bool operator!=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*target != *rhs.target}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator<}}%
\begin{itemdecl}
bool operator<(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->before(*rhs.target)}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator<=}}%
\begin{itemdecl}
bool operator<=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!rhs.target->before(*target)}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator>}}%
\begin{itemdecl}
bool operator>(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.target->before(*target)}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{operator>=}}%
\begin{itemdecl}
bool operator>=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!target->before(*rhs.target)}
\end{itemdescr}

\indexlibrary{\idxcode{hash_code}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{hash_code}}%
\begin{itemdecl}
size_t hash_code() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->hash_code()}
\end{itemdescr}

\indexlibrary{\idxcode{name}!\idxcode{type_index}}%
\indexlibrary{\idxcode{type_index}!\idxcode{name}}%
\begin{itemdecl}
const char* name() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->name()}
\end{itemdescr}

\rSec2[type.index.hash]{Hash support}

\indexlibrary{\idxcode{hash}}%
\begin{itemdecl}
template <> struct hash<type_index>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The template specialization shall meet the requirements of class template
\tcode{hash}~(\ref{unord.hash}). For an object \tcode{index} of type \tcode{type_index},
\tcode{hash<type_index>()(index)} shall evaluate to the same result as \tcode{index.hash_code()}.
\end{itemdescr}
