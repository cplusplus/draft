%!TEX root = std.tex
\rSec0[utilities]{General utilities library}

\rSec1[utilities.general]{General}

\pnum
This Clause describes utilities that are generally useful in \Cpp{} programs; some
of these utilities are used by other elements of the \Cpp{} standard library.
These utilities are summarized in \tref{util.lib.summary}.

\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{utility}               & Utility components                & \tcode{<utility>}     \\ \rowsep
\ref{intseq}                & Compile-time integer sequences    & \tcode{<utility>}     \\ \rowsep
\ref{pairs}                 & Pairs                             & \tcode{<utility>}     \\ \rowsep
\ref{tuple}                 & Tuples                            & \tcode{<tuple>}       \\ \rowsep
\ref{optional}              & Optional objects                  & \tcode{<optional>}    \\ \rowsep
\ref{variant}               & Variants                          & \tcode{<variant>}     \\ \rowsep
\ref{any}                   & Storage for any type              & \tcode{<any>}         \\ \rowsep
\ref{bitset}                & Fixed-size sequences of bits      & \tcode{<bitset>}      \\ \rowsep
\ref{memory}                & Memory                            & \tcode{<memory>}      \\
                            &                                   & \tcode{<cstdlib>}     \\ \rowsep
\ref{smartptr}              & Smart pointers                    & \tcode{<memory>}      \\ \rowsep
\ref{mem.res}               & Memory resources                  & \tcode{<memory_resource>} \\ \rowsep
\ref{allocator.adaptor}     & Scoped allocators                 & \tcode{<scoped_allocator>} \\ \rowsep
\ref{function.objects}      & Function objects                  & \tcode{<functional>}  \\ \rowsep
\ref{meta}                  & Type traits                       & \tcode{<type_traits>} \\ \rowsep
\ref{ratio}                 & Compile-time rational arithmetic  & \tcode{<ratio>}       \\ \rowsep
\ref{time}                  & Time utilities                    & \tcode{<chrono>}      \\
                            &                                   & \tcode{<ctime>}       \\ \rowsep
\ref{type.index}            & Type indexes                      & \tcode{<typeindex>}   \\ \rowsep
\ref{execpol}               & Execution policies                & \tcode{<execution>}   \\ \rowsep
\ref{charconv}              & Primitive numeric conversions     & \tcode{<charconv>}    \\
\end{libsumtab}

\rSec1[utility]{Utility components}

\indexhdr{utility}%
\indexlibrary{\idxcode{rel_ops}}%
\rSec2[utility.syn]{Header \tcode{<utility>} synopsis}

\pnum
The header \tcode{<utility>}
contains some basic function and class templates that are used
throughout the rest of the library.

\begin{codeblock}
#include <initializer_list>     // see \ref{initializer_list.syn}

namespace std {
  // \ref{utility.swap}, swap
  template<class T>
    void swap(T& a, T& b) noexcept(@\seebelow@);
  template<class T, size_t N>
    void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);

  // \ref{utility.exchange}, exchange
  template<class T, class U = T>
    constexpr T exchange(T& obj, U&& new_val);

  // \ref{forward}, forward/move
  template<class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
  template<class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
  template<class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
  template<class T>
    constexpr conditional_t<
        !is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&>
      move_if_noexcept(T& x) noexcept;

  // \ref{utility.as_const}, \tcode{as_const}
  template<class T>
    constexpr add_const_t<T>& as_const(T& t) noexcept;
  template<class T>
    void as_const(const T&&) = delete;

  // \ref{declval}, declval
  template<class T>
    add_rvalue_reference_t<T> declval() noexcept;  // as unevaluated operand
@%
\indexlibrary{\idxcode{index_sequence}}%
\indexlibrary{\idxcode{make_index_sequence}}%
\indexlibrary{\idxcode{index_sequence_for}}%
@
  // \ref{intseq}, Compile-time integer sequences
  template<class T, T...>
    struct integer_sequence;
  template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;

  template<class T, T N>
    using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
  template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;

  template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;

  // \ref{pairs}, class template \tcode{pair}
  template<class T1, class T2>
    struct pair;

  // \ref{pairs.spec}, pair specialized algorithms
  template<class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
  template<class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
  template<class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
  template<class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
  template<class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
  template<class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);

  template<class T1, class T2>
    void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));

  template<class T1, class T2>
    constexpr @\seebelow@ make_pair(T1&&, T2&&);

  // \ref{pair.astuple}, tuple-like access to pair
  template<class T> class tuple_size;
  template<size_t I, class T> class tuple_element;

  template<class T1, class T2> struct tuple_size<pair<T1, T2>>;
  template<size_t I, class T1, class T2> struct tuple_element<I, pair<T1, T2>>;

  template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
  template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
  template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
  template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
  template<class T1, class T2>
    constexpr T1& get(pair<T1, T2>& p) noexcept;
  template<class T1, class T2>
    constexpr const T1& get(const pair<T1, T2>& p) noexcept;
  template<class T1, class T2>
    constexpr T1&& get(pair<T1, T2>&& p) noexcept;
  template<class T1, class T2>
    constexpr const T1&& get(const pair<T1, T2>&& p) noexcept;
  template<class T2, class T1>
    constexpr T2& get(pair<T1, T2>& p) noexcept;
  template<class T2, class T1>
    constexpr const T2& get(const pair<T1, T2>& p) noexcept;
  template<class T2, class T1>
    constexpr T2&& get(pair<T1, T2>&& p) noexcept;
  template<class T2, class T1>
    constexpr const T2&& get(const pair<T1, T2>&& p) noexcept;

  // \ref{pair.piecewise}, pair piecewise construction
  struct piecewise_construct_t {
    explicit piecewise_construct_t() = default;
  };
  inline constexpr piecewise_construct_t piecewise_construct{};
  template<class... Types> class tuple;        // defined in \tcode{<tuple>}\iref{tuple.syn}

  // in-place construction
  struct in_place_t {
    explicit in_place_t() = default;
  };
  inline constexpr in_place_t in_place{};
  template<class T>
    struct in_place_type_t {
      explicit in_place_type_t() = default;
    };
  template<class T> inline constexpr in_place_type_t<T> in_place_type{};
  template<size_t I>
    struct in_place_index_t {
      explicit in_place_index_t() = default;
    };
  template<size_t I> inline constexpr in_place_index_t<I> in_place_index{};
}
\end{codeblock}

\rSec2[utility.swap]{\tcode{swap}}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template<class T>
  void swap(T& a, T& b) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function
is a designated customization point\iref{namespace.std} and
shall not participate in overload resolution
unless \tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_move_assignable_v<T>} is \tcode{true}.
The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>
\end{codeblock}

\pnum
\requires
Type
\tcode{T}
shall be
\tcode{MoveConstructible} (\tref{moveconstructible})
and
\tcode{MoveAssignable} (\tref{moveassignable}).

\pnum
\effects
Exchanges values stored in two locations.
\end{itemdescr}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template<class T, size_t N>
  void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution
unless \tcode{is_swappable_v<T>} is \tcode{true}.

\pnum
\requires
\tcode{a[i]} shall be swappable with\iref{swappable.requirements} \tcode{b[i]}
for all \tcode{i} in the range \range{0}{N}.

\pnum
\effects As if by \tcode{swap_ranges(a, a + N, b)}.
\end{itemdescr}

\rSec2[utility.exchange]{\tcode{exchange}}

\indexlibrary{\idxcode{exchange}}%
\begin{itemdecl}
template<class T, class U = T>
  constexpr T exchange(T& obj, U&& new_val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
T old_val = std::move(obj);
obj = std::forward<U>(new_val);
return old_val;
\end{codeblock}
\end{itemdescr}


\rSec2[forward]{Forward/move helpers}

\pnum
The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.
\indextext{signal-safe!\idxcode{forward}}%
\indextext{signal-safe!\idxcode{move}}%
\indextext{signal-safe!\idxcode{move_if_noexcept}}%
All functions specified in this subclause are signal-safe\iref{support.signal}.

\indexlibrary{\idxcode{forward}}%
\indextext{\idxcode{forward}}%
\begin{itemdecl}
template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept;
template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<T\&\&>(t)}.

\pnum
\remarks If the second form is instantiated with an lvalue reference type, the program is ill-formed.

\pnum
\begin{example}
\begin{codeblock}
template<class T, class A1, class A2>
shared_ptr<T> factory(A1&& a1, A2&& a2) {
  return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2)));
}

struct A {
  A(int&, const double&);
};

void g() {
  shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to \tcode{int\&}
  int i = 2;
  shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK
}
\end{codeblock}
In the first call to \tcode{factory},
\tcode{A1} is deduced as \tcode{int}, so 2 is forwarded
to \tcode{A}'s constructor as an rvalue.
In the second call to \tcode{factory},
\tcode{A1} is deduced as \tcode{int\&}, so \tcode{i} is forwarded
to \tcode{A}'s constructor as an lvalue. In
both cases, \tcode{A2} is deduced as \tcode{double}, so
1.414 is forwarded to \tcode{A}'s constructor as an rvalue.
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{move}!function}%
\indextext{\idxcode{move}}%
\begin{itemdecl}
template<class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{static_cast<remove_reference_t<T>\&\&>(t)}.

\pnum
\begin{example}
\begin{codeblock}
template<class T, class A1>
shared_ptr<T> factory(A1&& a1) {
  return shared_ptr<T>(new T(std::forward<A1>(a1)));
}

struct A {
  A();
  A(const A&);      // copies from lvalues
  A(A&&);           // moves from rvalues
};

void g() {
  A a;
  shared_ptr<A> sp1 = factory<A>(a);                // ``\tcode{a}\!'' binds to \tcode{A(const A\&)}
  shared_ptr<A> sp1 = factory<A>(std::move(a));     // ``\tcode{a}\!'' binds to \tcode{A(A\&\&)}
}
\end{codeblock}
In the first call to \tcode{factory},
\tcode{A1} is deduced as \tcode{A\&}, so \tcode{a} is forwarded
as a non-const lvalue. This binds to the constructor \tcode{A(const A\&)},
which copies the value from \tcode{a}.
In the second call to \tcode{factory}, because of the call
\tcode{std::move(a)},
\tcode{A1} is deduced as \tcode{A}, so \tcode{a} is forwarded
as an rvalue. This binds to the constructor \tcode{A(A\&\&)},
which moves the value from \tcode{a}.
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{move_if_noexcept}}%
\begin{itemdecl}
template<class T> constexpr conditional_t<
    !is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&>
  move_if_noexcept(T& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{std::move(x)}.
\end{itemdescr}

\rSec2[utility.as_const]{Function template \tcode{as_const}}

\indexlibrary{\idxcode{as_const}}%
\begin{itemdecl}
template<class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{t}.
\end{itemdescr}

\rSec2[declval]{Function template \tcode{declval}}

\pnum
The library provides the function template \tcode{declval} to simplify the definition of
expressions which occur as unevaluated operands\iref{expr.prop}.

\indexlibrary{\idxcode{declval}}%
\begin{itemdecl}
template<class T> add_rvalue_reference_t<T> declval() noexcept;    // as unevaluated operand
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks If this function is odr-used\iref{basic.def.odr}, the program is ill-formed.

\pnum
\remarks The template parameter \tcode{T} of \tcode{declval} may be an incomplete type.
\end{itemdescr}

\pnum
\begin{example}
\begin{codeblock}
template<class To, class From> decltype(static_cast<To>(declval<From>())) convert(From&&);
\end{codeblock}
declares a function template \tcode{convert} which only participates in overloading if the
type \tcode{From} can be explicitly converted to type \tcode{To}. For another example see class
template \tcode{common_type}\iref{meta.trans.other}.
\end{example}

\rSec1[intseq]{Compile-time integer sequences}

\rSec2[intseq.general]{In general}

\pnum
The library provides a class template that can represent an integer sequence.
When used as an argument to a function template the template parameter pack defining the
sequence can be deduced and used in a pack expansion.
\begin{note}
The \tcode{index_sequence} alias template is provided for the common case of
an integer sequence of type \tcode{size_t}; see also \ref{tuple.apply}.
\end{note}

\rSec2[intseq.intseq]{Class template \tcode{integer_sequence}}

\indexlibrary{\idxcode{integer_sequence}}%
\indexlibrarymember{value_type}{integer_sequence}%
\begin{codeblock}
namespace std {
  template<class T, T... I> struct integer_sequence {
    using value_type = T;
    static constexpr size_t size() noexcept { return sizeof...(I); }
  };
}
\end{codeblock}

\pnum
\tcode{T} shall be an integer type.

\rSec2[intseq.make]{Alias template \tcode{make_integer_sequence}}

\indexlibrary{\idxcode{make_integer_sequence}}%
\begin{itemdecl}
template<class T, T N>
  using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{N} is negative the program is ill-formed. The alias template
\tcode{make_integer_sequence} denotes a specialization of
\tcode{integer_sequence} with \tcode{N} template non-type arguments.
The type \tcode{make_integer_sequence<T, N>} denotes the type
\tcode{integer_sequence<T, 0, 1, ..., N-1>}.
\begin{note} \tcode{make_integer_sequence<int, 0>} denotes the type
\tcode{integer_sequence<int>} \end{note}
\end{itemdescr}

\rSec1[pairs]{Pairs}

\rSec2[pairs.general]{In general}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\indexlibrary{\idxcode{pair}}%
\indextext{\idxcode{pair}!tuple interface to}%
\indextext{\idxcode{tuple}!and pair@and \tcode{pair}}%

\rSec2[pairs.pair]{Class template \tcode{pair}}

\indexlibrary{\idxcode{pair}}%
\begin{codeblock}
namespace std {
  template<class T1, class T2>
  struct pair {
    using first_type  = T1;
    using second_type = T2;

    T1 first;
    T2 second;

    pair(const pair&) = default;
    pair(pair&&) = default;
    @\EXPLICIT@ constexpr pair();
    @\EXPLICIT@ constexpr pair(const T1& x, const T2& y);
    template<class U1, class U2>
      @\EXPLICIT@ constexpr pair(U1&& x, U2&& y);
    template<class U1, class U2>
      @\EXPLICIT@ constexpr pair(const pair<U1, U2>& p);
    template<class U1, class U2>
      @\EXPLICIT@ constexpr pair(pair<U1, U2>&& p);
    template<class... Args1, class... Args2>
      pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p);
    template<class U1, class U2>
      pair& operator=(const pair<U1, U2>& p);
    pair& operator=(pair&& p) noexcept(@\seebelow@);
    template<class U1, class U2>
      pair& operator=(pair<U1, U2>&& p);

    void swap(pair& p) noexcept(@\seebelow@);
  };

  template<class T1, class T2>
    pair(T1, T2) -> pair<T1, T2>;
}
\end{codeblock}

\pnum
Constructors and member functions of \tcode{pair} shall not throw exceptions unless one of
the element-wise operations specified to be called for that operation
throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of \tcode{pair} shall
be a constexpr function if and only if all required element-wise
initializations for copy and move, respectively, would satisfy the
requirements for a constexpr function.
The destructor of \tcode{pair} shall be a trivial destructor if
\tcode{(is_trivially_destructible_v<T1> \&\& is_trivially_destructible_v<T2>)}
is \tcode{true}.

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
@\EXPLICIT@ constexpr pair();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value-initializes \tcode{first} and \tcode{second}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_default_construct\-ible_v<first_type>} is \tcode{true} and
\tcode{is_default_constructible_v<second_type>} is \tcode{true}.
\begin{note} This behavior can be implemented by a constructor template
with default template arguments. \end{note}
The constructor is explicit if and only if either \tcode{first_type} or
\tcode{second_type} is not implicitly default-constructible.
\begin{note} This behavior can be implemented with a trait that checks
whether a \tcode{const first_type\&} or a \tcode{const second_type\&}
can be initialized with \tcode{\{\}}. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
@\EXPLICIT@ constexpr pair(const T1& x, const T2& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{first} with \tcode{x} and \tcode{second} with \tcode{y}.

\pnum
\remarks This constructor shall not participate in overload resolution
unless \tcode{is_copy_construct\-ible_v<first_type>} is \tcode{true} and
\tcode{is_copy_constructible_v<second_type>} is \tcode{true}.
The constructor is explicit if and only if
\tcode{is_convertible_v<const first_type\&, first_type>} is \tcode{false} or
\tcode{is_convertible_v<const second_type\&, second_type>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
template<class U1, class U2> @\EXPLICIT@ constexpr pair(U1&& x, U2&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{first} with
\tcode{std::forward<U1>(x)} and \tcode{second}
with \tcode{std::forward<U2>(y)}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<first_type, U1\&\&>} is \tcode{true} and
\tcode{is_constructible_v<second_type, U2\&\&>} is \tcode{true}.
The constructor is explicit if and only if
\tcode{is_convertible_v<U1\&\&, first_type>} is \tcode{false} or
\tcode{is_convertible_v<U2\&\&, second_type>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
template<class U1, class U2> @\EXPLICIT@ constexpr pair(const pair<U1, U2>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes members from the corresponding members of the argument.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<first_type, const U1\&>} is \tcode{true} and
\tcode{is_constructible_v<second_type, const U2\&>} is \tcode{true}.
The constructor is explicit if and only if
\tcode{is_convertible_v<const U1\&, first_type>} is \tcode{false} or
\tcode{is_convertible_v<const U2\&, second_type>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
template<class U1, class U2> @\EXPLICIT@ constexpr pair(pair<U1, U2>&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{first} with
\tcode{std::forward<U1>(p.first)}
and \tcode{second} with
\tcode{std::forward<U2>(\brk{}p.second)}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<first_type, U1\&\&>} is \tcode{true} and
\tcode{is_constructible_v<second_type, U2\&\&>} is \tcode{true}.
The constructor is explicit if and only if
\tcode{is_convertible_v<U1\&\&, first_type>} is \tcode{false} or
\tcode{is_convertible_v<U2\&\&, second_type>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!constructor}%
\begin{itemdecl}
template<class... Args1, class... Args2>
  pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_constructible_v<first_type, Args1\&\&...>} is \tcode{true}
and \tcode{is_constructible_v<sec\-ond_type, Args2\&\&...>} is \tcode{true}.

\pnum
\effects Initializes \tcode{first} with arguments of types
\tcode{Args1...} obtained by forwarding the elements of \tcode{first_args}
and initializes \tcode{second} with arguments of types \tcode{Args2...}
obtained by forwarding the elements of \tcode{second_args}. (Here, forwarding
an element \tcode{x} of type \tcode{U} within a \tcode{tuple} object means calling
\tcode{std::forward<U>(x)}.) This form of construction, whereby constructor
arguments for \tcode{first} and \tcode{second} are each provided in a separate
\tcode{tuple} object, is called \defn{piecewise construction}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
pair& operator=(const pair& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.

\pnum
\remarks This operator shall be defined as deleted unless
\tcode{is_copy_assignable_v<first_type>} is \tcode{true}
and \tcode{is_copy_assignable_v<second_type>} is \tcode{true}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
template<class U1, class U2> pair& operator=(const pair<U1, U2>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{is_assignable_v<first_type\&, const U1\&>} is \tcode{true}
and \tcode{is_assignable_v<second_type\&, const U2\&>} is \tcode{true}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
pair& operator=(pair&& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns to \tcode{first} with \tcode{std::forward<first_type>(p.first)}
and to \tcode{second} with\\ \tcode{std::forward<second_type>(p.second)}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{is_move_assignable_v<first_type>} is \tcode{true}
and \tcode{is_move_assignable_v<second_type>} is \tcode{true}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:
\begin{codeblock}
is_nothrow_move_assignable_v<T1> && is_nothrow_move_assignable_v<T2>
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
template<class U1, class U2> pair& operator=(pair<U1, U2>&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns to \tcode{first} with \tcode{std::forward<U1>(p.first)}
and to \tcode{second} with\\ \tcode{std::forward<U2>(p.second)}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{is_assignable_v<first_type\&, U1\&\&>} is \tcode{true}
and \tcode{is_assignable_v<second_type\&, U2\&\&>} is \tcode{true}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{swap}{pair}%
\begin{itemdecl}
void swap(pair& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{first} shall be swappable with\iref{swappable.requirements}
\tcode{p.first} and \tcode{second} shall be swappable with \tcode{p.second}.

\pnum
\effects Swaps
\tcode{first} with \tcode{p.first} and
\tcode{second} with \tcode{p.second}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:
\begin{codeblock}
is_nothrow_swappable_v<first_type> && is_nothrow_swappable_v<second_type>
\end{codeblock}
\end{itemdescr}

\rSec2[pairs.spec]{Specialized algorithms}

\indexlibrarymember{operator==}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first == y.first \&\& x.second == y.second}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrarymember{operator<}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first < y.first || (!(y.first < x.first) \&\& x.second < y.second)}.
\end{itemdescr}

\indexlibrarymember{operator>}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrarymember{operator<=}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}


\indexlibrary{\idxcode{swap}!\idxcode{pair}}%
\begin{itemdecl}
template<class T1, class T2>
  void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{x.swap(y)}.

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_swappable_v<T1>} is \tcode{true} and
\tcode{is_swappable_v<T2>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{make_pair}}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr pair<V1, V2> make_pair(T1&& x, T2&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y))},
where \tcode{V1} and \tcode{V2} are determined as follows: Let \tcode{Ui} be
\tcode{decay_t<Ti>} for each \tcode{Ti}. If \tcode{Ui} is a specialization
of \tcode{reference_wrapper}, then \tcode{Vi} is \tcode{Ui::type\&},
otherwise \tcode{Vi} is \tcode{Ui}.
\end{itemdescr}

\pnum
\begin{example}
In place of:
\begin{codeblock}
  return pair<int, double>(5, 3.1415926);   // explicit types
\end{codeblock}
a \Cpp{} program may contain:
\begin{codeblock}
  return make_pair(5, 3.1415926);           // types are deduced
\end{codeblock}
\end{example}

\rSec2[pair.astuple]{Tuple-like access to pair}

\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template<class T1, class T2>
  struct tuple_size<pair<T1, T2>> : integral_constant<size_t, 2> { };
\end{itemdecl}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
tuple_element<I, pair<T1, T2>>::type
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires \tcode{I < 2}. The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\textit{Value:} The type \tcode{T1} if \tcode{I == 0}, otherwise the type \tcode{T2}.
\end{itemdescr}

\indexlibrarymember{get}{pair}%
\begin{itemdecl}
template<size_t I, class T1, class T2>
  constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>& p) noexcept;
template<size_t I, class T1, class T2>
  constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>& p) noexcept;
template<size_t I, class T1, class T2>
  constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&& p) noexcept;
template<size_t I, class T1, class T2>
  constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\returns If \tcode{I == 0} returns a reference to \tcode{p.first};
if \tcode{I == 1} returns a reference to \tcode{p.second};
otherwise the program is ill-formed.
\end{itemdescr}

\indexlibrarymember{get}{pair}%
\begin{itemdecl}
template<class T1, class T2>
  constexpr T1& get(pair<T1, T2>& p) noexcept;
template<class T1, class T2>
  constexpr const T1& get(const pair<T1, T2>& p) noexcept;
template<class T1, class T2>
  constexpr T1&& get(pair<T1, T2>&& p) noexcept;
template<class T1, class T2>
  constexpr const T1&& get(const pair<T1, T2>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires \tcode{T1} and \tcode{T2} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns A reference to \tcode{p.first}.
\end{itemdescr}

\indexlibrarymember{get}{pair}%
\begin{itemdecl}
template<class T2, class T1>
  constexpr T2& get(pair<T1, T2>& p) noexcept;
template<class T2, class T1>
  constexpr const T2& get(const pair<T1, T2>& p) noexcept;
template<class T2, class T1>
  constexpr T2&& get(pair<T1, T2>&& p) noexcept;
template<class T2, class T1>
  constexpr const T2&& get(const pair<T1, T2>&& p) noexcept;
\end{itemdecl}
\begin{itemdescr}

\pnum
\requires \tcode{T1} and \tcode{T2} are distinct types. Otherwise, the program is ill-formed.

\pnum
\returns A reference to \tcode{p.second}.
\end{itemdescr}

\rSec2[pair.piecewise]{Piecewise construction}

\indexlibrary{\idxcode{piecewise_construct_t}}%
\indexlibrary{\idxcode{piecewise_construct}}%
\begin{itemdecl}
struct piecewise_construct_t {
  explicit piecewise_construct_t() = default;
};
inline constexpr piecewise_construct_t piecewise_construct{};
\end{itemdecl}

\pnum
The \tcode{struct} \tcode{piecewise_construct_t} is an empty structure type
used as a unique type to disambiguate constructor and function overloading. Specifically,
\tcode{pair} has a constructor with \tcode{piecewise_construct_t} as the
first argument, immediately followed by two \tcode{tuple}\iref{tuple} arguments used
for piecewise construction of the elements of the \tcode{pair} object.

\rSec1[tuple]{Tuples}

\rSec2[tuple.general]{In general}

\pnum
\indexlibrary{\idxcode{tuple}}%
This subclause describes the tuple library that provides a tuple type as
the class template \tcode{tuple} that can be instantiated with any number
of arguments. Each template argument specifies
the type of an element in the \tcode{tuple}.  Consequently, tuples are
heterogeneous, fixed-size collections of values. An instantiation of \tcode{tuple} with
two arguments is similar to an instantiation of \tcode{pair} with the same two arguments.
See~\ref{pairs}.

\rSec2[tuple.syn]{Header \tcode{<tuple>} synopsis}

\indexhdr{tuple}%
\begin{codeblock}
namespace std {
  // \ref{tuple.tuple}, class template \tcode{tuple}
  template<class... Types>
    class tuple;

  // \ref{tuple.creation}, tuple creation functions
  inline constexpr @\unspec@ ignore;

  template<class... TTypes>
    constexpr tuple<VTypes...> make_tuple(TTypes&&...);

  template<class... TTypes>
    constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;

  template<class... TTypes>
    constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;

  template<class... Tuples>
    constexpr tuple<CTypes...> tuple_cat(Tuples&&...);

  // \ref{tuple.apply}, calling a function with a tuple of arguments
  template<class F, class Tuple>
    constexpr decltype(auto) apply(F&& f, Tuple&& t);

  template<class T, class Tuple>
    constexpr T make_from_tuple(Tuple&& t);

  // \ref{tuple.helper}, tuple helper classes
  template<class T> class tuple_size;                  // not defined
  template<class T> class tuple_size<const T>;
  template<class T> class tuple_size<volatile T>;
  template<class T> class tuple_size<const volatile T>;

  template<class... Types> class tuple_size<tuple<Types...>>;

  template<size_t I, class T> class tuple_element;     // not defined
  template<size_t I, class T> class tuple_element<I, const T>;
  template<size_t I, class T> class tuple_element<I, volatile T>;
  template<size_t I, class T> class tuple_element<I, const volatile T>;

  template<size_t I, class... Types>
    class tuple_element<I, tuple<Types...>>;

  template<size_t I, class T>
    using tuple_element_t = typename tuple_element<I, T>::type;

  // \ref{tuple.elem}, element access
  template<size_t I, class... Types>
    constexpr tuple_element_t<I, tuple<Types...>>& get(tuple<Types...>&) noexcept;
  template<size_t I, class... Types>
    constexpr tuple_element_t<I, tuple<Types...>>&& get(tuple<Types...>&&) noexcept;
  template<size_t I, class... Types>
    constexpr const tuple_element_t<I, tuple<Types...>>& get(const tuple<Types...>&) noexcept;
  template<size_t I, class... Types>
    constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&&) noexcept;
  template<class T, class... Types>
    constexpr T& get(tuple<Types...>& t) noexcept;
  template<class T, class... Types>
    constexpr T&& get(tuple<Types...>&& t) noexcept;
  template<class T, class... Types>
    constexpr const T& get(const tuple<Types...>& t) noexcept;
  template<class T, class... Types>
    constexpr const T&& get(const tuple<Types...>&& t) noexcept;

  // \ref{tuple.rel}, relational operators
  template<class... TTypes, class... UTypes>
    constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template<class... TTypes, class... UTypes>
    constexpr bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

  // \ref{tuple.traits}, allocator-related traits
  template<class... Types, class Alloc>
    struct uses_allocator<tuple<Types...>, Alloc>;

  // \ref{tuple.special}, specialized algorithms
  template<class... Types>
    void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);

  // \ref{tuple.helper}, tuple helper classes
  template<class T>
    inline constexpr size_t tuple_size_v = tuple_size<T>::value;
}
\end{codeblock}

\rSec2[tuple.tuple]{Class template \tcode{tuple}}
\indexlibrary{\idxcode{tuple}}%

\begin{codeblock}
namespace std {
  template<class... Types>
  class tuple {
  public:
    // \ref{tuple.cnstr}, \tcode{tuple} construction
    @\EXPLICIT@ constexpr tuple();
    @\EXPLICIT@ constexpr tuple(const Types&...);          // only if \tcode{sizeof...(Types) >= 1}
    template<class... UTypes>
      @\EXPLICIT@ constexpr tuple(UTypes&&...);            // only if \tcode{sizeof...(Types) >= 1}

    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template<class... UTypes>
      @\EXPLICIT@ constexpr tuple(const tuple<UTypes...>&);
    template<class... UTypes>
      @\EXPLICIT@ constexpr tuple(tuple<UTypes...>&&);

    template<class U1, class U2>
      @\EXPLICIT@ constexpr tuple(const pair<U1, U2>&);    // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
      @\EXPLICIT@ constexpr tuple(pair<U1, U2>&&);         // only if \tcode{sizeof...(Types) == 2}

    // allocator-extended constructors
    template<class Alloc>
      tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
      tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
      tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, class... UTypes>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template<class Alloc, class U1, class U2>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
      @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

    // \ref{tuple.assign}, \tcode{tuple} assignment
    tuple& operator=(const tuple&);
    tuple& operator=(tuple&&) noexcept(@\seebelow@);

    template<class... UTypes>
      tuple& operator=(const tuple<UTypes...>&);
    template<class... UTypes>
      tuple& operator=(tuple<UTypes...>&&);

    template<class U1, class U2>
      tuple& operator=(const pair<U1, U2>&);            // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
      tuple& operator=(pair<U1, U2>&&);                 // only if \tcode{sizeof...(Types) == 2}

    // \ref{tuple.swap}, \tcode{tuple} swap
    void swap(tuple&) noexcept(@\seebelow@);
  };

  template<class... UTypes>
    tuple(UTypes...) -> tuple<UTypes...>;
  template<class T1, class T2>
    tuple(pair<T1, T2>) -> tuple<T1, T2>;
  template<class Alloc, class... UTypes>
    tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
  template<class Alloc, class T1, class T2>
    tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;
  template<class Alloc, class... UTypes>
    tuple(allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;
}
\end{codeblock}

\rSec3[tuple.cnstr]{Construction}

\pnum
For each \tcode{tuple} constructor, an exception is thrown only if the construction of
one of the types in \tcode{Types} throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of
\tcode{tuple} shall be a constexpr function if and only if all
required element-wise initializations for copy and move, respectively,
would satisfy the requirements for a constexpr function. The
defaulted move and copy constructor of \tcode{tuple<>} shall be
constexpr functions.

\pnum
The destructor of \tcode{tuple} shall be a trivial destructor if
\tcode{(is_trivially_destructible_v<Types> \&\& ...)}
is \tcode{true}.

\pnum
In the constructor descriptions that follow, let $i$ be in the range
\range{0}{sizeof...(Types)} in order, $\tcode{T}_i$
be the $i^\text{th}$ type in \tcode{Types}, and
$\tcode{U}_i$ be the $i^\text{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based.

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
@\EXPLICIT@ constexpr tuple();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Value-initializes each element.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_default_construct\-ible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
\begin{note} This behavior can be implemented by a constructor template
with default template arguments. \end{note}
The constructor is explicit if and only if $\tcode{T}_i$ is not implicitly
default-constructible for at least one $i$.
\begin{note} This behavior can be implemented with a trait that checks whether
a \tcode{const $\tcode{T}_i$\&} can be initialized with \tcode{\{\}}. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
@\EXPLICIT@ constexpr tuple(const Types&...);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes each element with the value of the
corresponding parameter.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{sizeof...(Types) >= 1} and \tcode{is_copy_constructible_v<$\tcode{T}_i$>}
is \tcode{true} for all $i$. The constructor is explicit if and only if
\tcode{is_convertible_v<const $\tcode{T}_i$\&, $\tcode{T}_i$>} is \tcode{false}
for at least one $i$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template<class... UTypes> @\EXPLICIT@ constexpr tuple(UTypes&&... u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the elements in the tuple with the
corresponding value in \tcode{std::forward<UTypes>(u)}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)} and
\tcode{sizeof...(Types) >= 1} and \tcode{is_constructible_v<$\tcode{T}_i$, $\tcode{U}_i$\&\&>}
is \tcode{true} for all $i$. The constructor is explicit if and only if
\tcode{is_convertible_v<$\tcode{U}_i$\&\&, $\tcode{T}_i$>} is \tcode{false}
for at least one $i$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
tuple(const tuple& u) = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_copy_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

\pnum
\effects Initializes each element of \tcode{*this} with the
corresponding element of \tcode{u}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
tuple(tuple&& u) = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{is_move_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

\pnum
\effects For all $i$, initializes the $i^\text{th}$ element of \tcode{*this} with
\tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template<class... UTypes> @\EXPLICIT@ constexpr tuple(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes each element of \tcode{*this}
with the corresponding element of \tcode{u}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\begin{itemize}
\item
\tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)} and
\item
\tcode{is_constructible_v<$\tcode{T}_i$, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$, and
\item
either
\tcode{sizeof...(Types) != 1}, or
(when \tcode{Types...} expands to \tcode{T} and \tcode{UTypes...} expands to \tcode{U})
\tcode{is_convertible_v<const tuple<U>\&, T>}, \tcode{is_constructible_v<T, const tuple<U>\&>}, and \tcode{is_same_v<T, U>} are all \tcode{false}.
\end{itemize}
The constructor is explicit if and only if
\tcode{is_convertible_v<const $\tcode{U}_i$\&, $\tcode{T}_i$>} is \tcode{false}
for at least one $i$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template<class... UTypes> @\EXPLICIT@ constexpr tuple(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects For all $i$,
initializes the $i^\text{th}$ element of \tcode{*this} with
\tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))}.

\pnum
\remarks This constructor shall not participate in overload resolution unless

\begin{itemize}
\item
\tcode{sizeof...(Types)} \tcode{==} \tcode{sizeof...(UTypes)}, and
\item
\tcode{is_constructible_v<$\tcode{T}_i$, $\tcode{U}_i$\&\&>} is \tcode{true} for all $i$, and
\item
either
\tcode{sizeof...(Types) != 1}, or
(when \tcode{Types...} expands to \tcode{T} and \tcode{UTypes...} expands to \tcode{U})
\tcode{is_convertible_v<tuple<U>, T>}, \tcode{is_constructible_v<T, tuple<U>>},
and \tcode{is_same_v<T, U>} are all \tcode{false}.
\end{itemize}
The constructor is explicit if and only if
\tcode{is_convertible_v<$\tcode{U}_i$\&\&, $\tcode{T}_i$>} is \tcode{false}
for at least one $i$.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template<class U1, class U2> @\EXPLICIT@ constexpr tuple(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the first element with \tcode{u.first} and the
second element with \tcode{u.second}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{sizeof...(Types) == 2},
\tcode{is_constructible_v<$\tcode{T}_0$, const U1\&>} is \tcode{true} and
\tcode{is_constructible_v<$\tcode{T}_1$, const U2\&>} is \tcode{true}.

\pnum
The constructor is explicit if and only if
\tcode{is_convertible_v<const U1\&, $\tcode{T}_0$>} is \tcode{false} or
\tcode{is_convert\-ible_v<const U2\&, $\tcode{T}_1$>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template<class U1, class U2> @\EXPLICIT@ constexpr tuple(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the first element with
\tcode{std::forward<U1>(u.first)} and the
second element with \tcode{std::forward<U2>(u.second)}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{sizeof...(Types) == 2},
\tcode{is_constructible_v<$\tcode{T}_0$, U1\&\&>} is \tcode{true} and
\tcode{is_constructible_v<$\tcode{T}_1$, U2\&\&>} is \tcode{true}.

\pnum
The constructor is explicit if and only if
\tcode{is_convertible_v<U1\&\&, $\tcode{T}_0$>} is \tcode{false} or
\tcode{is_convertible_v<U2\&\&, $\tcode{T}_1$>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple}!constructor}%
\begin{itemdecl}
template<class Alloc>
  tuple(allocator_arg_t, const Alloc& a);
template<class Alloc>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const Types&...);
template<class Alloc, class... UTypes>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
template<class Alloc>
  tuple(allocator_arg_t, const Alloc& a, const tuple&);
template<class Alloc>
  tuple(allocator_arg_t, const Alloc& a, tuple&&);
template<class Alloc, class... UTypes>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template<class Alloc, class... UTypes>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template<class Alloc, class U1, class U2>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template<class Alloc, class U1, class U2>
  @\EXPLICIT@ tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{Alloc} shall satisfy the
\tcode{Allocator} requirements (\tref{utilities.allocator.requirements}).

\pnum
\effects Equivalent to the preceding constructors except that each element is constructed with
uses-allocator construction\iref{allocator.uses.construction}.
\end{itemdescr}

\rSec3[tuple.assign]{Assignment}

\pnum
For each \tcode{tuple} assignment operator, an exception is thrown only if the
assignment of one of the types in \tcode{Types} throws an exception.
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...\brk{}(Types)}
in order, $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Types},
and $\tcode{U}_i$ be the $i^\text{th}$ type in a
template parameter pack named \tcode{UTypes}, where indexing is zero-based.

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns each element of \tcode{u} to the corresponding
element of \tcode{*this}.

\pnum
\remarks This operator shall be defined as deleted unless
\tcode{is_copy_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
tuple& operator=(tuple&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects For all $i$, assigns \tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))} to
\tcode{get<$i$>(*this)}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{is_move_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to the logical \textsc{and} of the
following expressions:

\begin{codeblock}
is_nothrow_move_assignable_v<@$\mathtt{T}_i$@>
\end{codeblock}
where $\mathtt{T}_i$ is the $i^\text{th}$ type in \tcode{Types}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
template<class... UTypes> tuple& operator=(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns each element of \tcode{u} to the corresponding element
of \tcode{*this}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{sizeof...(Types) == sizeof...(UTypes)} and
\tcode{is_assignable_v<$\tcode{T}_i$\&, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
template<class... UTypes> tuple& operator=(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects For all $i$, assigns \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))} to
\tcode{get<$i$>(*this)}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{is_assignable_v<$\tcode{T}_i$\&, $\tcode{U}_i$\&\&> == true} for all $i$ and
\tcode{sizeof...(Types) == sizeof...(UTypes)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template<class U1, class U2> tuple& operator=(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Assigns \tcode{u.first} to the first element of \tcode{*this}
and \tcode{u.second} to the second element of \tcode{*this}.

\pnum
\remarks This operator shall not participate in overload resolution unless
\tcode{sizeof...(Types) == 2} and
\tcode{is_assignable_v<$\tcode{T}_0$\&, const U1\&>} is \tcode{true} for the first type $\tcode{T}_0$ in
\tcode{Types} and \tcode{is_assignable_v<$\tcode{T}_1$\&, const U2\&>} is \tcode{true} for the
second type $\tcode{T}_1$ in \tcode{Types}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\indexlibrary{\idxcode{pair}}%
\begin{itemdecl}
template<class U1, class U2> tuple& operator=(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{std::forward<U1>(u.first)} to the first
element of \tcode{*this} and\\ \tcode{std::forward<U2>(u.second)} to the
second element of \tcode{*this}.

\pnum
\remarks
This operator shall not participate in overload resolution unless
\tcode{sizeof...(Types) == 2} and
\tcode{is_assignable_v<$\tcode{T}_0$\&, U1\&\&>} is \tcode{true} for the first type $\tcode{T}_0$ in
\tcode{Types} and \tcode{is_assignable_v<$\tcode{T}_1$\&, U2\&\&>} is \tcode{true} for the second
type $\tcode{T}_1$ in \tcode{Types}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec3[tuple.swap]{\tcode{swap}}

\indexlibrarymember{swap}{tuple}%
\begin{itemdecl}
void swap(tuple& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Each element in \tcode{*this} shall be swappable with\iref{swappable.requirements}
the corresponding element in \tcode{rhs}.

\pnum
\effects Calls \tcode{swap} for each element in \tcode{*this} and its
corresponding element in \tcode{rhs}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to the logical
\textsc{and} of the following expressions:

\begin{codeblock}
is_nothrow_swappable_v<@$\mathtt{T}_i$@>
\end{codeblock}
where $\mathtt{T}_i$ is the $i^\text{th}$ type in \tcode{Types}.

\pnum
\throws Nothing unless one of the element-wise \tcode{swap} calls throws an exception.
\end{itemdescr}

\rSec3[tuple.creation]{Tuple creation functions}

\pnum
In the function descriptions that follow, the members of a template parameter pack \tcode{\placeholder{X}Types}
are denoted by \tcode{\placeholder{X}}$_i$ for $i$ in \range{0}{sizeof...(\placeholder{X}Types)} in
order, where indexing is zero-based.

\indexlibrary{\idxcode{make_tuple}}%
\indexlibrary{\idxcode{tuple}!\idxcode{make_tuple}}%
\begin{itemdecl}
template<class... TTypes>
  constexpr tuple<VTypes...> make_tuple(TTypes&&... t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The pack \tcode{VTypes} is defined as follows. Let \tcode{U}$_i$ be \tcode{decay_t<T$_i$>} for each
\tcode{T}$_i$ in \tcode{TTypes}. If \tcode{U}$_i$ is a specialization of
\tcode{reference_wrapper}, then \tcode{V}$_i$ in \tcode{VTypes} is \tcode{U$_i$::type\&},
otherwise \tcode{V}$_i$ is \tcode{U}$_i$.

\pnum
\returns \tcode{tuple<VTypes...>(std::forward<TTypes>(t)...)}.

\pnum
\begin{example}
\begin{codeblock}
int i; float j;
make_tuple(1, ref(i), cref(j))
\end{codeblock}
creates a tuple of type \tcode{tuple<int, int\&, const float\&>}.
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{forward_as_tuple}}%
\indexlibrary{\idxcode{tuple}!\idxcode{forward_as_tuple}}%
\begin{itemdecl}
template<class... TTypes>
  constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a tuple of references to the arguments in \tcode{t} suitable
for forwarding as arguments to a function. Because the result may contain references
to temporary variables, a program shall ensure that the return value of this
function does not outlive any of its arguments (e.g., the program should typically
not store the result in a named variable).

\pnum
\returns \tcode{tuple<TTypes\&\&...>(std::forward<TTypes>(t)...)}.
\end{itemdescr}

\indexlibrary{\idxcode{tie}}%
\indexlibrary{\idxcode{ignore}}%
\indexlibrary{\idxcode{tuple}!\idxcode{tie}}%
\begin{itemdecl}
template<class... TTypes>
  constexpr tuple<TTypes&...> tie(TTypes&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{tuple<TTypes\&...>(t...)}.  When an
argument in \tcode{t} is \tcode{ignore}, assigning
any value to the corresponding tuple element has no effect.

\pnum
\begin{example}
\tcode{tie} functions allow one to create tuples that unpack
tuples into variables. \tcode{ignore} can be used for elements that
are not needed:
\begin{codeblock}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \tcode{i == 42}, \tcode{s == "C++"}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{tuple_cat}}
\begin{itemdecl}
template<class... Tuples>
  constexpr tuple<CTypes...> tuple_cat(Tuples&&... tpls);
\end{itemdecl}

\begin{itemdescr}
\pnum
In the following paragraphs, let $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Tuples},
$\tcode{U}_i$ be \tcode{remove_reference_t<T$_i$>}, and $\tcode{tp}_i$ be the $i^\text{th}$
parameter in the function parameter pack \tcode{tpls}, where all indexing is
zero-based.

\pnum
\requires For all $i$, $\tcode{U}_i$ shall be the type
$\cv_i$ \tcode{tuple<$\tcode{Args}_i$...>}, where $\cv_i$ is the (possibly empty) $i^\text{th}$
\grammarterm{cv-qualifier-seq} and $\tcode{Args}_i$ is the template parameter pack representing the element
types in $\tcode{U}_i$. Let $\tcode{A}_{ik}$ be the ${k}^\text{th}$ type in $\tcode{Args}_i$. For all
$\tcode{A}_{ik}$ the following requirements shall be satisfied:
\begin{itemize}
\item If $\tcode{T}_i$ is deduced as an lvalue reference type, then
      \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&> == true}, otherwise
\item \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&\&> == true}.
\end{itemize}

\pnum
\remarks The types in \tcode{CTypes} shall be equal to the ordered
sequence of the extended types
\tcode{$\tcode{Args}_0$..., $\tcode{Args}_1$..., $\dotsc$, $\tcode{Args}_{n-1}$...},
where $n$ is
equal to \tcode{sizeof...(Tuples)}. Let \tcode{$\tcode{e}_i$...} be the $i^\text{th}$
ordered sequence of tuple elements of the resulting \tcode{tuple} object
corresponding to the type sequence $\tcode{Args}_i$.

\pnum
\returns A \tcode{tuple} object constructed by initializing the ${k_i}^\text{th}$
type element $\tcode{e}_{ik}$ in \tcode{$\tcode{e}_i$...} with
\begin{codeblock}
get<@$k_i$@>(std::forward<@$\tcode{T}_i$@>(@$\tcode{tp}_i$@))
\end{codeblock}
for each valid $k_i$ and each group $\tcode{e}_i$ in order.

\pnum
\begin{note}
An implementation may support additional types in the template parameter
pack \tcode{Tuples} that support the \tcode{tuple}-like protocol, such as
\tcode{pair} and \tcode{array}.
\end{note}
\end{itemdescr}

\rSec3[tuple.apply]{Calling a function with a \tcode{tuple} of arguments}

\indexlibrary{\idxcode{apply}}%
\begin{itemdecl}
template<class F, class Tuple>
  constexpr decltype(auto) apply(F&& f, Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
template<class F, class Tuple, size_t... I>
constexpr decltype(auto)
    apply_impl(F&& f, Tuple&& t, index_sequence<I...>) {                // exposition only
  return @\placeholdernc{INVOKE}@(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...);  // see \ref{func.require}
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
return apply_impl(std::forward<F>(f), std::forward<Tuple>(t),
                  make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{make_from_tuple}}%
\begin{itemdecl}
template<class T, class Tuple>
  constexpr T make_from_tuple(Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
template<class T, class Tuple, size_t... I>
constexpr T make_from_tuple_impl(Tuple&& t, index_sequence<I...>) {     // exposition only
  return T(get<I>(std::forward<Tuple>(t))...);
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
return make_from_tuple_impl<T>(
           forward<Tuple>(t),
           make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\begin{note} The type of \tcode{T} must be supplied
as an explicit template parameter,
as it cannot be deduced from the argument list. \end{note}
\end{itemdescr}

\rSec3[tuple.helper]{Tuple helper classes}

\indexlibrary{\idxcode{tuple_size}!in general}%
\begin{itemdecl}
template<class T> struct tuple_size;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks All specializations of \tcode{tuple_size} shall satisfy the
\tcode{UnaryTypeTrait} requirements\iref{meta.rqmts} with a
base characteristic of \tcode{integral_constant<size_t, N>}
for some \tcode{N}.
\end{itemdescr}

\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template<class... Types>
  class tuple_size<tuple<Types...>> : public integral_constant<size_t, sizeof...(Types)> { };
\end{itemdecl}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
template<size_t I, class... Types>
  class tuple_element<I, tuple<Types...>> {
  public:
    using type = TI;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\ctype \tcode{TI} is the
type of the $\tcode{I}^\text{th}$ element of \tcode{Types},
where indexing is zero-based.
\end{itemdescr}

\indexlibrary{\idxcode{tuple_size}}%
\begin{itemdecl}
template<class T> class tuple_size<const T>;
template<class T> class tuple_size<volatile T>;
template<class T> class tuple_size<const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{TS} denote \tcode{tuple_size<T>} of the \cv-unqualified type \tcode{T}.
If the expression \tcode{TS::value} is well-formed
when treated as an unevaluated operand, then each
of the three templates shall satisfy the \tcode{UnaryTypeTrait} requirements\iref{meta.rqmts}
with a base characteristic of
\begin{codeblock}
integral_constant<size_t, TS::value>
\end{codeblock}
Otherwise, they shall have no member \tcode{value}.

\pnum
Access checking is performed as if in a context
unrelated to \tcode{TS} and \tcode{T}.
Only the validity of the immediate context of the expression is considered.
\begin{note}
The compilation of the expression can result in side effects
such as the instantiation of class template specializations and
function template specializations, the generation of implicitly-defined functions, and so on.
Such side effects are not in the ``immediate context'' and
can result in the program being ill-formed.
\end{note}

\pnum
In addition to being available via inclusion of the \tcode{<tuple>} header,
the three templates are available when either of the headers \tcode{<array>} or
\tcode{<utility>} are included.
\end{itemdescr}

\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
template<size_t I, class T> class tuple_element<I, const T>;
template<size_t I, class T> class tuple_element<I, volatile T>;
template<size_t I, class T> class tuple_element<I, const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{TE} denote \tcode{tuple_element_t<I, T>} of the \cv-unqualified type \tcode{T}. Then
each of the three templates shall satisfy the \tcode{TransformationTrait}
requirements\iref{meta.rqmts} with a member typedef \tcode{type} that names the following
type:

\begin{itemize}
\item
for the first specialization, \tcode{add_const_t<TE>},
\item
for the second specialization, \tcode{add_volatile_t<TE>}, and
\item
for the third specialization, \tcode{add_cv_t<TE>}.
\end{itemize}

\pnum
In addition to being available via inclusion of the \tcode{<tuple>} header,
the three templates are available when either of the headers \tcode{<array>} or
\tcode{<utility>} are included.
\end{itemdescr}

\rSec3[tuple.elem]{Element access}

\indexlibrarymember{get}{tuple}%
\begin{itemdecl}
template<size_t I, class... Types>
  constexpr tuple_element_t<I, tuple<Types...>>&
    get(tuple<Types...>& t) noexcept;
template<size_t I, class... Types>
  constexpr tuple_element_t<I, tuple<Types...>>&&
    get(tuple<Types...>&& t) noexcept;        // Note A
template<size_t I, class... Types>
  constexpr const tuple_element_t<I, tuple<Types...>>&
    get(const tuple<Types...>& t) noexcept;   // Note B
template<size_t I, class... Types>
  constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\returns  A reference to the $\tcode{I}^\text{th}$ element of \tcode{t}, where
indexing is zero-based.

\pnum
\begin{note}[Note A]
If a \tcode{T} in \tcode{Types} is some reference type \tcode{X\&},
the return type is \tcode{X\&}, not \tcode{X\&\&}.
However, if the element type is a non-reference type \tcode{T},
the return type is \tcode{T\&\&}.
\end{note}

\pnum
\begin{note}[Note B]
Constness is shallow. If a \tcode{T}
in \tcode{Types} is some
reference type \tcode{X\&}, the return type is \tcode{X\&}, not \tcode{const X\&}.
However, if the element type is a non-reference type \tcode{T},
the return type is \tcode{const T\&}.
This is consistent with how constness is defined to work
for member variables of reference type.
\end{note}
\end{itemdescr}

\indexlibrarymember{get}{tuple}%
\begin{itemdecl}
template<class T, class... Types>
  constexpr T& get(tuple<Types...>& t) noexcept;
template<class T, class... Types>
  constexpr T&& get(tuple<Types...>&& t) noexcept;
template<class T, class... Types>
  constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
  constexpr const T&& get(const tuple<Types...>&& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The type \tcode{T} occurs exactly once in \tcode{Types...}.
Otherwise, the program is ill-formed.

\pnum
\returns A reference to the element of \tcode{t} corresponding to the type
\tcode{T} in \tcode{Types...}.

\pnum
\begin{example}
\begin{codeblock}
  const tuple<int, const int, double, double> t(1, 2, 3.4, 5.6);
  const int& i1 = get<int>(t);        // OK. Not ambiguous. \tcode{i1 == 1}
  const int& i2 = get<const int>(t);  // OK. Not ambiguous. \tcode{i2 == 2}
  const double& d = get<double>(t);   // ERROR. ill-formed
\end{codeblock}
\end{example}
\end{itemdescr}

\pnum
\begin{note} The reason \tcode{get} is a
non-member function is that if this functionality had been
provided as a member function, code where the type
depended on a template parameter would have required using
the \tcode{template} keyword. \end{note}

\rSec3[tuple.rel]{Relational operators}

\indexlibrarymember{operator==}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires  For all \tcode{i},
where \tcode{0 <= i} and
\tcode{i < sizeof...(TTypes)}, \tcode{get<i>(t) == get<i>(u)} is a valid expression
returning a type that is convertible to \tcode{bool}.
\tcode{sizeof...(TTypes)} \tcode{==}
\tcode{sizeof...(UTypes)}.

\pnum
\returns  \tcode{true} if \tcode{get<i>(t) == get<i>(u)} for all
\tcode{i}, otherwise \tcode{false}.
For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f} returns \tcode{true}.

\pnum
\effects  The elementary comparisons are performed in order from the
zeroth index upwards.  No comparisons or element accesses are
performed after the first equality comparison that evaluates to
\tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator!=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{!(t == u)}.
\end{itemdescr}

\indexlibrarymember{operator<}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator<(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires  For all \tcode{i},
where \tcode{0 <= i} and
\tcode{i < sizeof...(TTypes)}, both \tcode{get<i>(t) < get<i>(u)}
and \tcode{get<i>(u) < get<i>(t)}
are valid expressions returning types that are
convertible to \tcode{bool}.
\tcode{sizeof...(TTypes)} \tcode{==}
\tcode{sizeof...(UTypes)}.

\pnum\returns  The result of a lexicographical comparison
between \tcode{t} and \tcode{u}. The result is defined
as: \tcode{(bool)(get<0>(t) < get<0>(u)) ||
(!(bool)(get<0>(u) < get<0>(t)) \&\& t$_{\mathrm{tail}}$ <
u$_{\mathrm{tail}}$)}, where \tcode{r$_{\mathrm{tail}}$} for some
tuple \tcode{r} is a tuple containing all but the first element
of \tcode{r}.  For any two zero-length tuples \tcode{e}
and \tcode{f}, \tcode{e < f} returns \tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator>}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{u < t}.
\end{itemdescr}

\indexlibrarymember{operator<=}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator<=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns \tcode{!(u < t)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
  constexpr bool operator>=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!(t < u)}.
\end{itemdescr}

\pnum \begin{note} The above definitions for comparison functions
do not require \tcode{t$_{\mathrm{tail}}$}
(or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It may not
even be possible, as \tcode{t} and \tcode{u} are not required to be copy
constructible. Also, all comparison functions are short circuited;
they do not perform element accesses beyond what is required to determine the
result of the comparison. \end{note}

\rSec3[tuple.traits]{Tuple traits}

\indexlibrary{\idxcode{uses_allocator<tuple>}}%
\begin{itemdecl}
template<class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc> : true_type { };
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{Alloc} shall satisfy the \tcode{Allocator}
requirements (\tref{utilities.allocator.requirements}).

\pnum
\begin{note} Specialization of this trait informs other library components that
\tcode{tuple} can be constructed with an allocator, even though it does not have
a nested \tcode{allocator_type}. \end{note}
\end{itemdescr}

\rSec3[tuple.special]{Tuple specialized algorithms}

\indexlibrary{\idxcode{swap}}%
\begin{itemdecl}
template<class... Types>
  void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{is_swappable_v<$\tcode{T}_i$>} is \tcode{true}
for all $i$, where $0 \leq i < \tcode{sizeof...(Types)}$.
The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
noexcept(x.swap(y))
\end{codeblock}

\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

\rSec1[optional]{Optional objects}

\rSec2[optional.general]{In general}

\pnum
This subclause describes class template \tcode{optional} that represents
optional objects.
An \defn{optional object} is an
object that contains the storage for another object and manages the lifetime of
this contained object, if any. The contained object may be initialized after
the optional object has been initialized, and may be destroyed before the
optional object has been destroyed. The initialization state of the contained
object is tracked by the optional object.

\rSec2[optional.syn]{Header \tcode{<optional>} synopsis}

\indexhdr{optional}%
\begin{codeblock}
namespace std {
  // \ref{optional.optional}, class template \tcode{optional}
  template<class T>
    class optional;

  // \ref{optional.nullopt}, no-value state indicator
  struct nullopt_t{@\seebelow@};
  inline constexpr nullopt_t nullopt(@\unspec@);

  // \ref{optional.bad.access}, class \tcode{bad_optional_access}
  class bad_optional_access;

  // \ref{optional.relops}, relational operators
  template<class T, class U>
    constexpr bool operator==(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>=(const optional<T>&, const optional<U>&);

  // \ref{optional.nullops}, comparison with \tcode{nullopt}
  template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator==(nullopt_t, const optional<T>&) noexcept;
  template<class T> constexpr bool operator!=(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator!=(nullopt_t, const optional<T>&) noexcept;
  template<class T> constexpr bool operator<(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator<(nullopt_t, const optional<T>&) noexcept;
  template<class T> constexpr bool operator>(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator>(nullopt_t, const optional<T>&) noexcept;
  template<class T> constexpr bool operator<=(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator<=(nullopt_t, const optional<T>&) noexcept;
  template<class T> constexpr bool operator>=(const optional<T>&, nullopt_t) noexcept;
  template<class T> constexpr bool operator>=(nullopt_t, const optional<T>&) noexcept;

  // \ref{optional.comp_with_t}, comparison with \tcode{T}
  template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);

  // \ref{optional.specalg}, specialized algorithms
  template<class T>
    void swap(optional<T>&, optional<T>&) noexcept(@\seebelow@);

  template<class T>
    constexpr optional<@\seebelow@> make_optional(T&&);
  template<class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // \ref{optional.hash}, hash support
  template<class T> struct hash;
  template<class T> struct hash<optional<T>>;
}
\end{codeblock}

\pnum
A program that necessitates the instantiation of template \tcode{optional} for
a reference type, or for possibly cv-qualified types \tcode{in_place_t} or
\tcode{nullopt_t} is ill-formed.

\rSec2[optional.optional]{Class template \tcode{optional}}

\indexlibrary{\idxcode{optional}}%
\indexlibrarymember{value_type}{optional}%
\begin{codeblock}
namespace std {
  template<class T>
  class optional {
  public:
    using value_type = T;

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&);
    constexpr optional(optional&&) noexcept(@\seebelow@);
    template<class... Args>
      constexpr explicit optional(in_place_t, Args&&...);
    template<class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
    template<class U = T>
      @\EXPLICIT@ constexpr optional(U&&);
    template<class U>
      @\EXPLICIT@ optional(const optional<U>&);
    template<class U>
      @\EXPLICIT@ optional(optional<U>&&);

    // \ref{optional.dtor}, destructor
    ~optional();

    // \ref{optional.assign}, assignment
    optional& operator=(nullopt_t) noexcept;
    optional& operator=(const optional&);
    optional& operator=(optional&&) noexcept(@\seebelow@);
    template<class U = T> optional& operator=(U&&);
    template<class U> optional& operator=(const optional<U>&);
    template<class U> optional& operator=(optional<U>&&);
    template<class... Args> T& emplace(Args&&...);
    template<class U, class... Args> T& emplace(initializer_list<U>, Args&&...);

    // \ref{optional.swap}, swap
    void swap(optional&) noexcept(@\seebelow@);

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const;
    constexpr T* operator->();
    constexpr const T& operator*() const&;
    constexpr T& operator*() &;
    constexpr T&& operator*() &&;
    constexpr const T&& operator*() const&&;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T& value() const&;
    constexpr T& value() &;
    constexpr T&& value() &&;
    constexpr const T&& value() const&&;
    template<class U> constexpr T value_or(U&&) const&;
    template<class U> constexpr T value_or(U&&) &&;

    // \ref{optional.mod}, modifiers
    void reset() noexcept;

  private:
    T *val;         // \expos
  };

  template<class T>
    optional(T) -> optional<T>;
}
\end{codeblock}

\pnum
Any instance of \tcode{optional<T>} at any given time either contains a value or does not contain a value.
When an instance of \tcode{optional<T>} \defnx{contains a value}{contains a value!\idxcode{optional}},
it means that an object of type \tcode{T}, referred to as the optional object's \defnx{contained value}{contained value!\idxcode{optional}},
is allocated within the storage of the optional object.
Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.
The contained value shall be allocated in a region of the \tcode{optional<T>} storage suitably aligned for the type \tcode{T}.
When an object of type \tcode{optional<T>} is contextually converted to \tcode{bool},
the conversion returns \tcode{true} if the object contains a value;
otherwise the conversion returns \tcode{false}.

\pnum
Member \tcode{val} is provided for exposition only. When an \tcode{optional<T>} object contains a value, \tcode{val} points to the contained value.

\pnum
\tcode{T} shall be an object type and shall satisfy the \tcode{Destructible} requirements (\tref{destructible}).

\rSec3[optional.ctor]{Constructors}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{*this} does not contain a value.

\pnum
\remarks
No contained value is initialized.
For every object type \tcode{T} these constructors shall be constexpr constructors\iref{dcl.constexpr}.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
constexpr optional(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value, initializes the contained value as if
direct-non-list-initializing an object of type \tcode{T} with the expression \tcode{*rhs}.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor shall be defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true}.
If \tcode{is_trivially_copy_constructible_v<T>} is \tcode{true},
this constructor shall be a \tcode{constexpr} constructor.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
constexpr optional(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value, initializes the contained value as if
direct-non-list-initializing an object of type \tcode{T} with the expression \tcode{std::move(*rhs)}.
\tcode{bool(rhs)} is unchanged.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to
\tcode{is_nothrow_move_constructible_v<T>}.
This constructor shall not participate in overload resolution
unless \tcode{is_move_constructible_v<T>} is \tcode{true}.
If \tcode{is_trivially_move_constructible_v<T>} is \tcode{true},
this constructor shall be a \tcode{constexpr} constructor.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
template<class... Args> constexpr explicit optional(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor shall be a constexpr constructor.
This constructor shall not participate in overload resolution
unless \tcode{is_constructible_v<T, Args...>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
template<class U, class... Args>
  constexpr explicit optional(in_place_t, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless \tcode{is_constructible_v<T, initializer_list<U>\&, Args\&\&...>} is \tcode{true}.
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor shall be a constexpr constructor.
\end{itemdescr}

\pnum
\begin{note}
The following constructors are conditionally specified as explicit.
This is typically implemented by declaring two such constructors,
of which at most one participates in overload resolution.
\end{note}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
template<class U = T> @\EXPLICIT@ constexpr optional(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T} with the expression \tcode{std::forward<U>(v)}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s selected constructor is a constexpr constructor,
this constructor shall be a constexpr constructor.
This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<T, U\&\&>} is \tcode{true},
\tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false}, and
\tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}.
The constructor is explicit if and only if
\tcode{is_convertible_v<U\&\&, T>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
template<class U> @\EXPLICIT@ optional(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value,
initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T} with the expression \tcode{*rhs}.

\pnum
\postconditions
\tcode{bool(rhs)} == \tcode{bool(*this)}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\begin{itemize}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true},
\item \tcode{is_constructible_v<T, optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&\&>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&, T>} is \tcode{false}, and
\item \tcode{is_convertible_v<const optional<U>\&\&, T>} is \tcode{false}.
\end{itemize}
The constructor is explicit if and only if
\tcode{is_convertible_v<const U\&, T>} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{optional}!constructor}%
\begin{itemdecl}
template<class U> @\EXPLICIT@ optional(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value,
initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T} with the expression \tcode{std::move(*rhs)}.
\tcode{bool(rhs)} is unchanged.

\pnum
\postconditions
\tcode{bool(rhs)} == \tcode{bool(*this)}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\begin{itemize}
\item \tcode{is_constructible_v<T, U\&\&>} is true,
\item \tcode{is_constructible_v<T, optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&\&>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&, T>} is \tcode{false}, and
\item \tcode{is_convertible_v<const optional<U>\&\&, T>} is \tcode{false}.
\end{itemize}
The constructor is explicit if and only if
\tcode{is_convertible_v<U\&\&, T>} is \tcode{false}.
\end{itemdescr}

\rSec3[optional.dtor]{Destructor}

\indexlibrary{\idxcode{optional}!destructor}%
\begin{itemdecl}
~optional();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{is_trivially_destructible_v<T> != true} and \tcode{*this} contains a value, calls
\begin{codeblock}
val->T::~T()
\end{codeblock}

\pnum
\remarks
If \tcode{is_trivially_destructible_v<T> == true} then this destructor shall be a trivial destructor.
\end{itemdescr}

\rSec3[optional.assign]{Assignment}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
optional<T>& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} contains a value, calls \tcode{val->T::\~T()} to destroy the contained value; otherwise no effect.

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{*this} does not contain a value.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
optional<T>& operator=(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tref{optional.assign.copy}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional\&)} effects}{tab:optional.assign.copy}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{bool(*this)} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s copy constructor, no effect.
If an exception is thrown during the call to \tcode{T}'s copy assignment,
the state of its contained value is as defined by the exception safety guarantee of \tcode{T}'s copy assignment.
This operator shall be defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true} and
\tcode{is_copy_assignable_v<T>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
optional<T>& operator=(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tref{optional.assign.move}.
The result of the expression \tcode{bool(rhs)} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional\&\&)} effects}{tab:optional.assign.move}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{std::move(*rhs)} to the contained value &
initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with \tcode{std::move(*rhs)} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to:
\begin{codeblock}
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T>
\end{codeblock}

\pnum
If any exception is thrown, the result of the expression \tcode{bool(*this)} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s move constructor,
the state of \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move constructor.
If an exception is thrown during the call to \tcode{T}'s move assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move assignment.
This operator shall not participate in overload resolution unless
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_move_assignable_v<T>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U = T> optional<T>& operator=(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} contains a value, assigns \tcode{std::forward<U>(v)} to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type \tcode{T} with \tcode{std::forward<U>(v)}.

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{bool(*this)} remains unchanged. If an exception is thrown during the call to \tcode{T}'s constructor, the state of \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s constructor. If an exception is thrown during the call to \tcode{T}'s assignment, the state of \tcode{*val} and \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s assignment.
This function shall not participate in overload resolution unless
\tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false},
\tcode{conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>>} is \tcode{false},
\tcode{is_constructible_v<T, U>} is \tcode{true}, and
\tcode{is_assignable_v<T\&, U>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> optional<T>& operator=(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tref{optional.assign.copy.templ}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional<U>\&)} effects}{tab:optional.assign.copy.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T} with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{bool(*this)} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
This function shall not participate in overload resolution unless
\begin{itemize}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, const U\&>} is \tcode{true},
\item \tcode{is_constructible_v<T, optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&\&>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> optional<T>& operator=(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tref{optional.assign.move.templ}.
The result of the expression \tcode{bool(rhs)} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional<U>\&\&)} effects}{tab:optional.assign.move.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{std::move(*rhs)} to the contained value &
initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T} with \tcode{std::move(*rhs)} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
\tcode{bool(rhs) == bool(*this)}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{bool(*this)} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
This function shall not participate in overload resolution unless
\begin{itemize}
\item \tcode{is_constructible_v<T, U>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, U>} is \tcode{true},
\item \tcode{is_constructible_v<T, optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&>} is \tcode{false},
\item \tcode{is_constructible_v<T, const optional<U>\&\&>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&, T>} is \tcode{false},
\item \tcode{is_convertible_v<const optional<U>\&\&, T>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class... Args> T& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_constructible_v<T, Args\&\&...>} is \tcode{true}.

\pnum
\effects
Calls \tcode{*this = nullopt}. Then initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class U, class... Args> T& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{*this = nullopt}. Then initializes the contained value as if direct-non-list-initializing an object of type \tcode{T} with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
This function shall not participate in overload resolution unless \tcode{is_constructible_v<T, initializer_list<U>\&, Args\&\&...>} is \tcode{true}.
\end{itemdescr}

\rSec3[optional.swap]{Swap}

\indexlibrarymember{swap}{optional}%
\begin{itemdecl}
void swap(optional& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Lvalues of type \tcode{T} shall be swappable and \tcode{is_move_constructible_v<T>} is \tcode{true}.

\pnum
\effects
See \tref{optional.swap}.
\begin{lib2dtab2}{\tcode{optional::swap(optional\&)} effects}{tab:optional.swap}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
calls \tcode{swap(*(*this), *rhs)} &
initializes the contained value of \tcode{*this} as if
direct-non-list-initializing an object of type \tcode{T} with the expression \tcode{std::move(*rhs)},
followed by \tcode{rhs.val->T::\~T()};
postcondition is that \tcode{*this} contains a value and \tcode{rhs} does not contain a value \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
initializes the contained value of \tcode{rhs} as if
direct-non-list-initializing an object of type \tcode{T} with the expression \tcode{std::move(*(*this))},
followed by \tcode{val->T::\~T()};
postcondition is that \tcode{*this} does not contain a value and \tcode{rhs} contains a value &
no effect \\
\end{lib2dtab2}

\pnum
\throws
Any exceptions thrown by the operations in the relevant part of \tref{optional.swap}.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to:
\begin{codeblock}
is_nothrow_move_constructible_v<T> && is_nothrow_swappable_v<T>
\end{codeblock}
If any exception is thrown, the results of the expressions \tcode{bool(*this)} and \tcode{bool(rhs)} remain unchanged.
If an exception is thrown during the call to function \tcode{swap},
the state of \tcode{*val} and \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{swap} for lvalues of \tcode{T}.
If an exception is thrown during the call to \tcode{T}'s move constructor,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move constructor.
\end{itemdescr}

\rSec3[optional.observe]{Observers}

\indexlibrarymember{operator->}{optional}%
\begin{itemdecl}
constexpr const T* operator->() const;
constexpr T* operator->();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{*this} contains a value.

\pnum
\returns
\tcode{val}.

\pnum
\throws
Nothing.

\pnum
\remarks
These functions shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator*}{optional}%
\begin{itemdecl}
constexpr const T& operator*() const&;
constexpr T& operator*() &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{*this} contains a value.

\pnum
\returns
\tcode{*val}.

\pnum
\throws
Nothing.

\pnum
\remarks
These functions shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator*}{optional}%
\begin{itemdecl}
constexpr T&& operator*() &&;
constexpr const T&& operator*() const&&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{*this} contains a value.

\pnum
\effects
Equivalent to: \tcode{return std::move(*val);}
\end{itemdescr}

\indexlibrarymember{operator bool}{optional}%
\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if and only if \tcode{*this} contains a value.

\pnum
\remarks
This function shall be a constexpr function.
\end{itemdescr}

\indexlibrarymember{has_value}{optional}%
\begin{itemdecl}
constexpr bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if and only if \tcode{*this} contains a value.

\pnum
\remarks This function shall be a constexpr function.
\end{itemdescr}

\indexlibrarymember{value}{optional}%
\begin{itemdecl}
constexpr const T& value() const&;
constexpr T& value() &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return bool(*this) ? *val : throw bad_optional_access();
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{value}{optional}%
\begin{itemdecl}
constexpr T&& value() &&;
constexpr const T&& value() const&&;
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
Equivalent to:
\begin{codeblock}
return bool(*this) ? std::move(*val) : throw bad_optional_access();
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{value_or}{optional}%
\begin{itemdecl}
template<class U> constexpr T value_or(U&& v) const&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return bool(*this) ? **this : static_cast<T>(std::forward<U>(v));
\end{codeblock}

\pnum
\remarks
If \tcode{is_copy_constructible_v<T> \&\& is_convertible_v<U\&\&, T>} is \tcode{false},
the program is ill-formed.
\end{itemdescr}

\indexlibrarymember{value_or}{optional}%
\begin{itemdecl}
template<class U> constexpr T value_or(U&& v) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v));
\end{codeblock}

\pnum
\remarks
If \tcode{is_move_constructible_v<T> \&\& is_convertible_v<U\&\&, T>} is \tcode{false},
the program is ill-formed.
\end{itemdescr}

\rSec3[optional.mod]{Modifiers}

\indexlibrarymember{reset}{optional}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} contains a value, calls \tcode{val->T::\~T()} to destroy the contained value;
otherwise no effect.

\pnum
\postconditions
\tcode{*this} does not contain a value.
\end{itemdescr}

\rSec2[optional.nullopt]{No-value state indicator}

\indexlibrary{\idxcode{nullopt_t}}%
\indexlibrary{\idxcode{nullopt}}%
\begin{itemdecl}
struct nullopt_t{@\seebelow@};
inline constexpr nullopt_t nullopt(@\unspec@);
\end{itemdecl}

\pnum
The struct \tcode{nullopt_t} is an empty structure type used as a unique type to indicate the state of not containing a value for \tcode{optional} objects.
In particular, \tcode{optional<T>} has a constructor with \tcode{nullopt_t} as a single argument;
this indicates that an optional object not containing a value shall be constructed.

\pnum
Type \tcode{nullopt_t} shall not have a default constructor or an initializer-list constructor, and shall not be an aggregate.

\rSec2[optional.bad.access]{Class \tcode{bad_optional_access}}

\begin{codeblock}
class bad_optional_access : public exception {
public:
  bad_optional_access();
};
\end{codeblock}

\pnum
The class \tcode{bad_optional_access} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of an optional object that does not contain a value.

\indexlibrary{\idxcode{bad_optional_access}!constructor}%
\indexlibrarymember{what}{bad_optional_access}%
\begin{itemdecl}
bad_optional_access();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class \tcode{bad_optional_access}.

\pnum
\postconditions
\tcode{what()} returns an
\impldef{return value of \tcode{bad_optional_access::what}}
\ntbs{}.
\end{itemdescr}

\rSec2[optional.relops]{Relational operators}

\indexlibrarymember{operator==}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator==(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x == *y} shall be well-formed and
its result shall be convertible to \tcode{bool}.
\begin{note} \tcode{T} need not be \tcode{EqualityComparable}. \end{note}

\pnum
\returns
If \tcode{bool(x) != bool(y)}, \tcode{false}; otherwise if \tcode{bool(x) == false}, \tcode{true}; otherwise \tcode{*x == *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x == *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator"!=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator!=(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x != *y} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\returns
If \tcode{bool(x) != bool(y)}, \tcode{true};
otherwise, if \tcode{bool(x) == false}, \tcode{false};
otherwise \tcode{*x != *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x != *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator<}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{*x < *y} shall be well-formed
and its result shall be convertible to \tcode{bool}.

\pnum
\returns
If \tcode{!y}, \tcode{false};
otherwise, if \tcode{!x}, \tcode{true};
otherwise \tcode{*x < *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x < *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator>}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x > *y} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\returns
If \tcode{!x}, \tcode{false};
otherwise, if \tcode{!y}, \tcode{true};
otherwise \tcode{*x > *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x > *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator<=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<=(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x <= *y} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\returns
If \tcode{!x}, \tcode{true};
otherwise, if \tcode{!y}, \tcode{false};
otherwise \tcode{*x <= *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x <= *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\indexlibrarymember{operator>=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>=(const optional<T>& x, const optional<U>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x >= *y} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\returns
If \tcode{!y}, \tcode{true};
otherwise, if \tcode{!x}, \tcode{false};
otherwise \tcode{*x >= *y}.

\pnum
\remarks
Specializations of this function template
for which \tcode{*x >= *y} is a core constant expression
shall be constexpr functions.
\end{itemdescr}

\rSec2[optional.nullops]{Comparison with \tcode{nullopt}}

\indexlibrarymember{operator==}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator==(const optional<T>& x, nullopt_t) noexcept;
template<class T> constexpr bool operator==(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!x}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator!=(const optional<T>& x, nullopt_t) noexcept;
template<class T> constexpr bool operator!=(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bool(x)}.
\end{itemdescr}

\indexlibrarymember{operator<}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator<(const optional<T>& x, nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator<}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator<(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bool(x)}.
\end{itemdescr}

\indexlibrarymember{operator>}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator>(const optional<T>& x, nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bool(x)}.
\end{itemdescr}

\indexlibrarymember{operator>}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator>(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator<=}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator<=(const optional<T>& x, nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!x}.
\end{itemdescr}

\indexlibrarymember{operator<=}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator<=(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator>=}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator>=(const optional<T>& x, nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator>=}{optional}%
\begin{itemdecl}
template<class T> constexpr bool operator>=(nullopt_t, const optional<T>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!x}.
\end{itemdescr}

\rSec2[optional.comp_with_t]{Comparison with \tcode{T}}

\indexlibrarymember{operator==}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator==(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x == v} shall be well-formed and
its result shall be convertible to \tcode{bool}.
\begin{note}
\tcode{T} need not be \tcode{EqualityComparable}.
\end{note}

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x == v :\ false;}
\end{itemdescr}

\indexlibrarymember{operator==}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator==(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v == *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v == *x :\ false;}
\end{itemdescr}

\indexlibrarymember{operator"!=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator!=(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x != v} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x != v :\ true;}
\end{itemdescr}

\indexlibrarymember{operator"!=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator!=(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v != *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v != *x :\ true;}
\end{itemdescr}

\indexlibrarymember{operator<}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x < v} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x < v :\ true;}
\end{itemdescr}

\indexlibrarymember{operator<}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v < *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v < *x :\ false;}
\end{itemdescr}

\indexlibrarymember{operator>}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x > v} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x > v :\ false;}
\end{itemdescr}

\indexlibrarymember{operator>}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v > *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v > *x :\ true;}
\end{itemdescr}

\indexlibrarymember{operator<=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<=(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x <= v} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x <= v :\ true;}
\end{itemdescr}

\indexlibrarymember{operator<=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator<=(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v <= *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v <= *x :\ false;}
\end{itemdescr}

\indexlibrarymember{operator>=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>=(const optional<T>& x, const U& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{*x >= v} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ *x >= v :\ false;}
\end{itemdescr}

\indexlibrarymember{operator>=}{optional}%
\begin{itemdecl}
template<class T, class U> constexpr bool operator>=(const T& v, const optional<U>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{v >= *x} shall be well-formed and
its result shall be convertible to \tcode{bool}.

\pnum
\effects
Equivalent to: \tcode{return bool(x) ?\ v >= *x :\ true;}
\end{itemdescr}


\rSec2[optional.specalg]{Specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{optional}}%
\begin{itemdecl}
template<class T> void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{x.swap(y)}.

\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_swappable_v<T>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{make_optional}}%
\begin{itemdecl}
template<class T> constexpr optional<decay_t<T>> make_optional(T&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{optional<decay_t<T>>(std::forward<T>(v))}.
\end{itemdescr}

\indexlibrary{\idxcode{make_optional}}%
\begin{itemdecl}
template<class T, class...Args>
  constexpr optional<T> make_optional(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return optional<T>(in_place, std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibrary{\idxcode{make_optional}}%
\begin{itemdecl}
template<class T, class U, class... Args>
  constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return optional<T>(in_place, il, std::forward<Args>(args)...);}
\end{itemdescr}

\rSec2[optional.hash]{Hash support}

\indexlibrary{\idxcode{hash}!\idxcode{optional}}%
\begin{itemdecl}
template<class T> struct hash<optional<T>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization \tcode{hash<optional<T>>} is enabled\iref{unord.hash}
if and only if \tcode{hash<remove_const_t<T>>} is enabled.
When enabled, for an object \tcode{o} of type \tcode{optional<T>},
if \tcode{bool(o) == true}, then \tcode{hash<optional<T>>()(o)}
shall evaluate to the same value as \tcode{hash<remove_const_t<T>>()(*o)};
otherwise it evaluates to an unspecified value.
The member functions are not guaranteed to be \tcode{noexcept}.
\end{itemdescr}


\rSec1[variant]{Variants}

\rSec2[variant.general]{In general}

\pnum
A variant object holds and manages the lifetime of a value.
If the \tcode{variant} holds a value, that value's type has to be one
of the template argument types given to variant.
These template arguments are called alternatives.

\rSec2[variant.syn]{Header \tcode{<variant>} synopsis}
\indexhdr{variant}%

\begin{codeblock}
namespace std {
  // \ref{variant.variant}, class template \tcode{variant}
  template<class... Types>
    class variant;

  // \ref{variant.helper}, variant helper classes
  template<class T> struct variant_size;                   // not defined
  template<class T> struct variant_size<const T>;
  template<class T> struct variant_size<volatile T>;
  template<class T> struct variant_size<const volatile T>;
  template<class T>
    inline constexpr size_t variant_size_v = variant_size<T>::value;

  template<class... Types>
    struct variant_size<variant<Types...>>;

  template<size_t I, class T> struct variant_alternative;  // not defined
  template<size_t I, class T> struct variant_alternative<I, const T>;
  template<size_t I, class T> struct variant_alternative<I, volatile T>;
  template<size_t I, class T> struct variant_alternative<I, const volatile T>;
  template<size_t I, class T>
    using variant_alternative_t = typename variant_alternative<I, T>::type;

  template<size_t I, class... Types>
    struct variant_alternative<I, variant<Types...>>;

  inline constexpr size_t variant_npos = -1;

  // \ref{variant.get}, value access
  template<class T, class... Types>
    constexpr bool holds_alternative(const variant<Types...>&) noexcept;

  template<size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>&);
  template<size_t I, class... Types>
    constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&&);
  template<size_t I, class... Types>
    constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>&);
  template<size_t I, class... Types>
    constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&&);

  template<class T, class... Types>
    constexpr T& get(variant<Types...>&);
  template<class T, class... Types>
    constexpr T&& get(variant<Types...>&&);
  template<class T, class... Types>
    constexpr const T& get(const variant<Types...>&);
  template<class T, class... Types>
    constexpr const T&& get(const variant<Types...>&&);

  template<size_t I, class... Types>
    constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
      get_if(variant<Types...>*) noexcept;
  template<size_t I, class... Types>
    constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
      get_if(const variant<Types...>*) noexcept;

  template<class T, class... Types>
    constexpr add_pointer_t<T>
      get_if(variant<Types...>*) noexcept;
  template<class T, class... Types>
    constexpr add_pointer_t<const T>
      get_if(const variant<Types...>*) noexcept;

  // \ref{variant.relops}, relational operators
  template<class... Types>
    constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);
  template<class... Types>
    constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);
  template<class... Types>
    constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);
  template<class... Types>
    constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);
  template<class... Types>
    constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);
  template<class... Types>
    constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);

  // \ref{variant.visit}, visitation
  template<class Visitor, class... Variants>
    constexpr @\seebelow@ visit(Visitor&&, Variants&&...);

  // \ref{variant.monostate}, class \tcode{monostate}
  struct monostate;

  // \ref{variant.monostate.relops}, \tcode{monostate} relational operators
  constexpr bool operator==(monostate, monostate) noexcept;
  constexpr bool operator!=(monostate, monostate) noexcept;
  constexpr bool operator<(monostate, monostate) noexcept;
  constexpr bool operator>(monostate, monostate) noexcept;
  constexpr bool operator<=(monostate, monostate) noexcept;
  constexpr bool operator>=(monostate, monostate) noexcept;

  // \ref{variant.specalg}, specialized algorithms
  template<class... Types>
    void swap(variant<Types...>&, variant<Types...>&) noexcept(@\seebelow@);

  // \ref{variant.bad.access}, class \tcode{bad_variant_access}
  class bad_variant_access;

  // \ref{variant.hash}, hash support
  template<class T> struct hash;
  template<class... Types> struct hash<variant<Types...>>;
  template<> struct hash<monostate>;
}
\end{codeblock}

\indexlibrary{\idxcode{variant}}%
\rSec2[variant.variant]{Class template \tcode{variant}}

\begin{codeblock}
namespace std {
  template<class... Types>
  class variant {
  public:
    // \ref{variant.ctor}, constructors
    constexpr variant() noexcept(@\seebelow@);
    variant(const variant&);
    variant(variant&&) noexcept(@\seebelow@);

    template<class T>
      constexpr variant(T&&) noexcept(@\seebelow@);

    template<class T, class... Args>
      constexpr explicit variant(in_place_type_t<T>, Args&&...);
    template<class T, class U, class... Args>
      constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);

    template<size_t I, class... Args>
      constexpr explicit variant(in_place_index_t<I>, Args&&...);
    template<size_t I, class U, class... Args>
      constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);

    // \ref{variant.dtor}, destructor
    ~variant();

    // \ref{variant.assign}, assignment
    variant& operator=(const variant&);
    variant& operator=(variant&&) noexcept(@\seebelow@);

    template<class T> variant& operator=(T&&) noexcept(@\seebelow@);

    // \ref{variant.mod}, modifiers
    template<class T, class... Args>
      T& emplace(Args&&...);
    template<class T, class U, class... Args>
      T& emplace(initializer_list<U>, Args&&...);
    template<size_t I, class... Args>
      variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
    template<size_t I, class U, class... Args>
      variant_alternative_t<I, variant<Types...>>& emplace(initializer_list<U>, Args&&...);

    // \ref{variant.status}, value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;

    // \ref{variant.swap}, swap
    void swap(variant&) noexcept(@\seebelow@);
  };
}
\end{codeblock}

\pnum
Any instance of \tcode{variant} at any given time either holds a value
of one of its alternative types, or it holds no value.
When an instance of \tcode{variant} holds a value of alternative type \tcode{T},
it means that a value of type \tcode{T}, referred to as the \tcode{variant}
object's \defnx{contained value}{contained value!\idxcode{variant}}, is allocated within the storage of the
\tcode{variant} object.
Implementations are not permitted to use additional storage, such as dynamic
memory, to allocate the contained value.
The contained value shall be allocated in a region of the \tcode{variant}
storage suitably aligned for all types in \tcode{Types...}.
It is \impldef{whether \tcode{variant} supports over-aligned types}
whether over-aligned types are supported.

\pnum
All types in \tcode{Types...} shall be (possibly cv-qualified)
object types that are not arrays.

\pnum
A program that instantiates the definition of \tcode{variant} with
no template arguments is ill-formed.

\rSec3[variant.ctor]{Constructors}

\pnum
In the descriptions that follow, let $i$ be in the range \range{0}{sizeof...(Types)},
and $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Types...}.

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
constexpr variant() noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{variant} holding a value-initialized value of type $\tcode{T}_0$.

\pnum
\postconditions
\tcode{valueless_by_exception()} is \tcode{false} and \tcode{index()} is \tcode{0}.

\pnum
\throws
Any exception thrown by the value-initialization of $\tcode{T}_0$.

\pnum
\remarks
This function shall be \tcode{constexpr} if and only if the
value-initialization of the alternative type $\tcode{T}_0$ would satisfy the
requirements for a constexpr function.
The expression inside \tcode{noexcept} is equivalent to
\tcode{is_nothrow_default_constructible_v<$\tcode{T}_0$>}.
This function shall not participate in overload resolution unless
\tcode{is_default_constructible_v<$\tcode{T}_0$>} is \tcode{true}.
\begin{note} See also class \tcode{monostate}. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
variant(const variant& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{w} holds a value, initializes the \tcode{variant} to hold the same
alternative as \tcode{w} and direct-initializes the contained value
with \tcode{get<j>(w)}, where \tcode{j} is \tcode{w.index()}.
Otherwise, initializes the \tcode{variant} to not hold a value.

\pnum
\throws
Any exception thrown by direct-initializing any $\tcode{T}_i$ for all $i$.

\pnum
\remarks
This constructor shall be defined as deleted unless
\tcode{is_copy_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
variant(variant&& w) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{w} holds a value, initializes the \tcode{variant} to hold the same
alternative as \tcode{w} and direct-initializes the contained value with
\tcode{get<j>(std::move(w))}, where \tcode{j} is \tcode{w.index()}.
Otherwise, initializes the \tcode{variant} to not hold a value.

\pnum
\throws
Any exception thrown by move-constructing any $\tcode{T}_i$ for all $i$.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to the logical AND of
\tcode{is_nothrow_move_constructible_v<$\tcode{T}_i$>} for all $i$.
This function shall not participate in overload resolution unless
\tcode{is_move_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
template<class T> constexpr variant(T&& t) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $\tcode{T}_j$ be a type that is determined as follows:
build an imaginary function \tcode{\placeholdernc{FUN}($\tcode{T}_i$)} for each alternative type $\tcode{T}_i$. The overload \tcode{\placeholdernc{FUN}($\tcode{T}_j$)} selected by overload
resolution for the expression \tcode{\placeholdernc{FUN}(std::forward<T>(\brk{}t))} defines
the alternative $\tcode{T}_j$ which is the type of the contained value after
construction.

\pnum
\effects
Initializes \tcode{*this} to hold the alternative type $\tcode{T}_j$ and
direct-initializes the contained value as if direct-non-list-initializing it
with \tcode{std::forward<T>(t)}.

\pnum
\postconditions
\tcode{holds_alternative<$\tcode{T}_j$>(*this)} is \tcode{true}.

\pnum
\throws
Any exception thrown by the initialization of the selected alternative $\tcode{T}_j$.

\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{itemize}
\item
  \tcode{sizeof...(Types)} is nonzero,

\item
  \tcode{is_same_v<remove_cvref_t<T>, variant>} is \tcode{false},

\item
  \tcode{remove_cvref_t<T>} is neither a specialization
  of \tcode{in_place_type_t} nor a specialization
  of \tcode{in_place_index_t},

\item
  \tcode{is_constructible_v<$\tcode{T}_j$, T>} is \tcode{true}, and

\item
  the expression \tcode{\placeholdernc{FUN}(}\brk\tcode{std::forward<T>(t))}
  (with \tcode{\placeholdernc{FUN}} being the above-mentioned set of
  imaginary functions) is well-formed.
\end{itemize}

\pnum
\begin{note}
\begin{codeblock}
variant<string, string> v("abc");
\end{codeblock}
is ill-formed, as both alternative types have an equally viable constructor
for the argument. \end{note}

\pnum
The expression inside \tcode{noexcept} is equivalent to
\tcode{is_nothrow_constructible_v<$\tcode{T}_j$, T>}.
If $\tcode{T}_j$'s selected constructor is a constexpr constructor,
this constructor shall be a constexpr constructor.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
template<class T, class... Args> constexpr explicit variant(in_place_type_t<T>, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T}
with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{holds_alternative<T>(*this)} is \tcode{true}.

\pnum
\throws
Any exception thrown by calling the selected constructor of \tcode{T}.

\pnum
\remarks
This function shall not participate in overload resolution unless there is
exactly one occurrence of \tcode{T} in \tcode{Types...} and
\tcode{is_constructible_v<T, Args...>} is \tcode{true}.
If \tcode{T}'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
template<class T, class U, class... Args>
  constexpr explicit variant(in_place_type_t<T>, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing
an object of type \tcode{T}
with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{holds_alternative<T>(*this)} is \tcode{true}.

\pnum
\throws
Any exception thrown by calling the selected constructor of \tcode{T}.

\pnum
\remarks
This function shall not participate in overload resolution unless there is
exactly one occurrence of \tcode{T} in \tcode{Types...} and
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true}.
If \tcode{T}'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
template<size_t I, class... Args> constexpr explicit variant(in_place_index_t<I>, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing
an object of type $\tcode{T}_I$
with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{index()} is \tcode{I}.

\pnum
\throws
Any exception thrown by calling the selected constructor of $\tcode{T}_I$.

\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{itemize}
\item
\tcode{I} is less than \tcode{sizeof...(Types)} and
\item
\tcode{is_constructible_v<$\tcode{T}_I$, Args...>} is \tcode{true}.
\end{itemize}
If $\tcode{T}_I$'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
\end{itemdescr}

\indexlibrary{\idxcode{variant}!constructor}%
\begin{itemdecl}
template<size_t I, class U, class... Args>
  constexpr explicit variant(in_place_index_t<I>, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the contained value as if direct-non-list-initializing
an object of type $\tcode{T}_I$
with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{index()} is \tcode{I}.

\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{itemize}
\item
\tcode{I} is less than \tcode{sizeof...(Types)} and
\item
\tcode{is_constructible_v<$\tcode{T}_I$, initializer_list<U>\&, Args...>} is \tcode{true}.
\end{itemize}
If $\tcode{T}_I$'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
\end{itemdescr}

\rSec3[variant.dtor]{Destructor}

\indexlibrary{\idxcode{variant}!destructor}%
\begin{itemdecl}
~variant();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{valueless_by_exception()} is \tcode{false},
destroys the currently contained value.

\pnum
\remarks
If \tcode{is_trivially_destructible_v<$\tcode{T}_i$> == true} for all $\tcode{T}_i$
then this destructor shall be a trivial destructor.
\end{itemdescr}

\rSec3[variant.assign]{Assignment}

\indexlibrarymember{operator=}{variant}%
\begin{itemdecl}
variant& operator=(const variant& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $j$ be \tcode{rhs.index()}.

\pnum
\effects
\begin{itemize}
\item
If neither \tcode{*this} nor \tcode{rhs} holds a value, there is no effect.
\item
Otherwise, if \tcode{*this} holds a value but \tcode{rhs} does not, destroys the value
contained in \tcode{*this} and sets \tcode{*this} to not hold a value.
\item
Otherwise, if \tcode{index() == $j$}, assigns the value contained in \tcode{rhs}
to the value contained in \tcode{*this}.
\item
Otherwise, if either \tcode{is_nothrow_copy_constructible_v<$\tcode{T}_j$>}
is \tcode{true} or
\tcode{is_nothrow_move_con\-structible_v<$\tcode{T}_j$>} is \tcode{false},
equivalent to \tcode{emplace<$j$>(get<$j$>(rhs))}.
\item
Otherwise, equivalent to \tcode{operator=(variant(rhs))}.
\end{itemize}

\pnum
\returns \tcode{*this}.

\pnum
\postconditions \tcode{index() == rhs.index()}.

\pnum
\remarks
This operator shall be defined as deleted unless
\tcode{is_copy_constructible_v<$\tcode{T}_i$> \&\&}
\tcode{is_copy_assignable_v<$\tcode{T}_i$>}
is \tcode{true} for all $i$.
\end{itemdescr}

\indexlibrarymember{operator=}{variant}%
\begin{itemdecl}
variant& operator=(variant&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $j$ be \tcode{rhs.index()}.

\pnum
\effects
\begin{itemize}
\item
If neither \tcode{*this} nor \tcode{rhs} holds a value, there is no effect.
\item
Otherwise, if \tcode{*this} holds a value but \tcode{rhs} does not, destroys the value
contained in \tcode{*this} and sets \tcode{*this} to not hold a value.
\item
Otherwise, if \tcode{index() == $j$}, assigns \tcode{get<$j$>(std::move(rhs))} to
the value contained in \tcode{*this}.
\item
Otherwise, equivalent to \tcode{emplace<$j$>(get<$j$>(std::move(rhs)))}.
\end{itemize}

\pnum
\returns \tcode{*this}.

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_move_constructible_v<$\tcode{T}_i$> \&\& is_move_assignable_v<$\tcode{T}_i$>} is
\tcode{true} for all $i$.
The expression inside \tcode{noexcept} is equivalent to:
\tcode{is_nothrow_move_constructible_v<$\tcode{T}_i$> \&\& is_nothrow_move_assignable_v<$\tcode{T}_i$>} for all $i$.
\begin{itemize}
\item If an exception is thrown during the call to $\tcode{T}_j$'s move construction
(with $j$ being \tcode{rhs.index())}, the \tcode{variant} will hold no value.
\item If an exception is thrown during the call to $\tcode{T}_j$'s move assignment,
the state of the contained value is as defined by the exception safety
guarantee of $\tcode{T}_j$'s move assignment; \tcode{index()} will be $j$.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{operator=}{variant}%
\begin{itemdecl}
template<class T> variant& operator=(T&& t) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $\tcode{T}_j$ be a type that is determined as follows:
build an imaginary function \tcode{\placeholdernc{FUN}($\tcode{T}_i$)} for each alternative type
$\tcode{T}_i$. The overload \tcode{\placeholdernc{FUN}($\tcode{T}_j$)} selected by overload
resolution for the expression \tcode{\placeholdernc{FUN}(std::forward<T>(\brk{}t))} defines
the alternative $\tcode{T}_j$ which is the type of the contained value after
assignment.

\pnum
\effects
\begin{itemize}
\item
If \tcode{*this} holds a $\tcode{T}_j$, assigns \tcode{std::forward<T>(t)} to
the value contained in \tcode{*this}.
\item
Otherwise, if \tcode{is_nothrow_constructible_v<$\tcode{T}_j$, T> ||}
\tcode{!is_nothrow_move_constructible_v<$\tcode{T}_j$>} is \tcode{true},
equivalent to \tcode{emplace<$j$>(std::forward<T>(t))}.
\item
Otherwise, equivalent to \tcode{operator=(variant(std::forward<T>(t)))}.
\end{itemize}

\pnum
\postconditions
\tcode{holds_alternative<$\tcode{T}_j$>(*this)} is \tcode{true}, with $\tcode{T}_j$
selected by the imaginary function overload resolution described above.

\pnum
\returns \tcode{*this}.

\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{itemize}
\item
  \tcode{is_same_v<remove_cvref_t<T>, variant>} is \tcode{false},

\item
  \tcode{is_assignable_v<$\tcode{T}_j$\&, T> \&\& is_constructible_v<$\tcode{T}_j$, T>}
  is \tcode{true}, and

\item
  the expression \tcode{\placeholdernc{FUN}(std::forward<T>(t))}
  (with \tcode{\placeholdernc{FUN}} being the above-mentioned set
  of imaginary functions) is well-formed.
\end{itemize}

\pnum
\begin{note}
\begin{codeblock}
variant<string, string> v;
v = "abc";
\end{codeblock}
is ill-formed, as both alternative types have an equally viable constructor
for the argument. \end{note}

\pnum
The expression inside \tcode{noexcept} is equivalent to:
\begin{codeblock}
is_nothrow_assignable_v<T@$_j$@&, T> && is_nothrow_constructible_v<T@$_j$@, T>
\end{codeblock}
\begin{itemize}
\item If an exception is thrown during the assignment of \tcode{std::forward<T>(t)}
to the value contained in \tcode{*this}, the state of the contained value and
\tcode{t} are as defined by the exception safety guarantee of the assignment
expression; \tcode{valueless_by_exception()} will be \tcode{false}.
\item If an exception is thrown during the initialization of the contained value,
the \tcode{variant} object might not hold a value.
\end{itemize}
\end{itemdescr}

\rSec3[variant.mod]{Modifiers}

\indexlibrarymember{emplace}{variant}%
\begin{itemdecl}
template<class T, class... Args> T& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $I$ be the zero-based index of \tcode{T} in \tcode{Types...}.

\pnum
\effects
Equivalent to: \tcode{return emplace<$I$>(std::forward<Args>(args)...);}

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_constructible_v<T, Args...>} is \tcode{true}, and \tcode{T} occurs
exactly once in \tcode{Types...}.
\end{itemdescr}

\indexlibrarymember{emplace}{variant}%
\begin{itemdecl}
template<class T, class U, class... Args> T& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $I$ be the zero-based index of \tcode{T} in \tcode{Types...}.

\pnum
\effects
Equivalent to: \tcode{return emplace<$I$>(il, std::forward<Args>(args)...);}

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true},
and \tcode{T} occurs exactly once in \tcode{Types...}.
\end{itemdescr}

\indexlibrarymember{emplace}{variant}%
\begin{itemdecl}
template<size_t I, class... Args>
  variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{I < sizeof...(Types)}.

\pnum
\effects
Destroys the currently contained value if \tcode{valueless_by_exception()}
is \tcode{false}.
Then initializes the contained value as if direct-non-list-initializing
a value of type $\tcode{T}_I$
with the arguments \tcode{std::forward<Ar\-gs>(args)...}.

\pnum
\postconditions
\tcode{index()} is \tcode{I}.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown during the initialization of the contained value.

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_constructible_v<$\tcode{T}_I$, Args...>} is \tcode{true}.
If an exception is thrown during the initialization of the contained value,
the \tcode{variant} might not hold a value.
\end{itemdescr}

\indexlibrarymember{emplace}{variant}%
\begin{itemdecl}
template<size_t I, class U, class... Args>
  variant_alternative_t<I, variant<Types...>>& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{I < sizeof...(Types)}.

\pnum
\effects
Destroys the currently contained value if \tcode{valueless_by_exception()}
is \tcode{false}.
Then initializes the contained value as if direct-non-list-initializing
a value of type $\tcode{T}_I$
with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions
\tcode{index()} is \tcode{I}.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown during the initialization of the contained value.

\pnum
\remarks
This function shall not participate in overload resolution unless
\tcode{is_constructible_v<$\tcode{T}_I$, initializer_list<U>\&, Args...>} is \tcode{true}.
If an exception is thrown during the initialization of the contained value,
the \tcode{variant} might not hold a value.
\end{itemdescr}

\rSec3[variant.status]{Value status}

\indexlibrarymember{valueless_by_exception}{variant}%
\begin{itemdecl}
constexpr bool valueless_by_exception() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns \tcode{false} if and only if the \tcode{variant} holds a value.

\pnum
\begin{note}
A \tcode{variant} might not hold a value if an exception is thrown during a
type-changing assignment or emplacement. The latter means that even a
\tcode{variant<float, int>} can become \tcode{valueless_by_exception()}, for
instance by
\begin{codeblock}
struct S { operator int() { throw 42; }};
variant<float, int> v{12.f};
v.emplace<1>(S());
\end{codeblock}
\end{note}
\end{itemdescr}

\indexlibrarymember{index}{variant}%
\begin{itemdecl}
constexpr size_t index() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{valueless_by_exception()} is \tcode{true}, returns \tcode{variant_npos}.
Otherwise, returns the zero-based index of the alternative of the contained value.
\end{itemdescr}

\rSec3[variant.swap]{Swap}

\indexlibrarymember{swap}{variant}%
\begin{itemdecl}
void swap(variant& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires Lvalues of type $\tcode{T}_i$ shall be swappable\iref{swappable.requirements} and
\tcode{is_move_constructible_v<$\tcode{T}_i$>} shall be \tcode{true} for all $i$.

\pnum
\effects
\begin{itemize}
\item
If \tcode{valueless_by_exception() \&\& rhs.valueless_by_exception()} no effect.
\item
Otherwise, if \tcode{index() == rhs.index()}, calls \tcode{swap(get<$i$>(*this), get<$i$>(rhs))} where $i$ is \tcode{index()}.
\item
Otherwise, exchanges values of \tcode{rhs} and \tcode{*this}.
\end{itemize}

\pnum
\throws
If \tcode{index() == rhs.index()},
any exception thrown by \tcode{swap(get<$i$>(*this), get<$i$>(rhs))}
with $i$ being \tcode{index()}.
Otherwise, any exception thrown by the move constructor
of $\tcode{T}_i$ or $\tcode{T}_j$
with $i$ being \tcode{index()} and $j$ being \tcode{rhs.index()}.

\pnum
\remarks
If an exception is thrown during the call to function \tcode{swap(get<$i$>(*this), get<$i$>(rhs))},
the states of the contained values of \tcode{*this} and of \tcode{rhs} are
determined by the exception safety guarantee of \tcode{swap} for lvalues of
$\tcode{T}_i$ with $i$ being \tcode{index()}.
If an exception is thrown during the exchange of the values of \tcode{*this}
and \tcode{rhs}, the states of the values of \tcode{*this} and of \tcode{rhs}
are determined by the exception safety guarantee of \tcode{variant}'s move constructor.
The expression inside \tcode{noexcept} is equivalent to the logical AND of
\tcode{is_nothrow_move_constructible_v<$\tcode{T}_i$> \&\& is_nothrow_swappable_v<$\tcode{T}_i$>} for all $i$.
\end{itemdescr}

\rSec2[variant.helper]{\tcode{variant} helper classes}

\indexlibrary{\idxcode{variant_size}}%
\begin{itemdecl}
template<class T> struct variant_size;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
All specializations of \tcode{variant_size} shall satisfy the
\tcode{UnaryTypeTrait} requirements\iref{meta.rqmts}
with a base characteristic of \tcode{integral_constant<size_t, N>} for some \tcode{N}.
\end{itemdescr}

\indexlibrary{\idxcode{variant_size}}%
\begin{itemdecl}
template<class T> class variant_size<const T>;
template<class T> class variant_size<volatile T>;
template<class T> class variant_size<const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VS} denote \tcode{variant_size<T>} of the cv-unqualified
type \tcode{T}. Then each of the three templates shall satisfy the
\tcode{UnaryTypeTrait} requirements\iref{meta.rqmts} with a
base characteristic of \tcode{integral_constant<size_t, VS::value>}.
\end{itemdescr}

\indexlibrary{\idxcode{variant_size}}%
\begin{itemdecl}
template<class... Types>
  struct variant_size<variant<Types...>> : integral_constant<size_t, sizeof...(Types)> { };
\end{itemdecl}
% No itemdescr needed for variant_size<variant<Types...>>

\indexlibrary{\idxcode{variant_alternative}}%
\begin{itemdecl}
template<size_t I, class T> class variant_alternative<I, const T>;
template<size_t I, class T> class variant_alternative<I, volatile T>;
template<size_t I, class T> class variant_alternative<I, const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VA} denote \tcode{variant_alternative<I, T>} of the
cv-unqualified type \tcode{T}. Then each of the three templates shall
meet the \tcode{TransformationTrait} requirements\iref{meta.rqmts} with a
member typedef \tcode{type} that names the following type:
\begin{itemize}
\item for the first specialization, \tcode{add_const_t<VA::type>},
\item for the second specialization, \tcode{add_volatile_t<VA::type>}, and
\item for the third specialization, \tcode{add_cv_t<VA::type>}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{variant_alternative}}%
\begin{itemdecl}
variant_alternative<I, variant<Types...>>::type
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{I < sizeof...(Types)}.
The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\textit{Value:} The type $\tcode{T}_I$.
\end{itemdescr}

\rSec2[variant.get]{Value access}

\indexlibrary{\idxcode{holds_alternative}}
\indexlibrary{\idxcode{variant}!\idxcode{holds_alternative}}
\begin{itemdecl}
template<class T, class... Types>
  constexpr bool holds_alternative(const variant<Types...>& v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The type \tcode{T} occurs exactly once in \tcode{Types...}.
Otherwise, the program is ill-formed.

\pnum
\returns
\tcode{true} if \tcode{index()} is equal to the zero-based index of \tcode{T} in \tcode{Types...}.
\end{itemdescr}

\indexlibrarymember{get}{variant}%
\begin{itemdecl}
template<size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v);
template<size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&& v);
template<size_t I, class... Types>
  constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>& v);
template<size_t I, class... Types>
  constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{I < sizeof...(Types)}.
Otherwise the program is ill-formed.

\pnum
\effects
If \tcode{v.index()} is \tcode{I}, returns a reference to the object stored in
the \tcode{variant}. Otherwise, throws an exception of type \tcode{bad_variant_access}.
\end{itemdescr}

\indexlibrarymember{get}{variant}%
\begin{itemdecl}
template<class T, class... Types> constexpr T& get(variant<Types...>& v);
template<class T, class... Types> constexpr T&& get(variant<Types...>&& v);
template<class T, class... Types> constexpr const T& get(const variant<Types...>& v);
template<class T, class... Types> constexpr const T&& get(const variant<Types...>&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The type \tcode{T} occurs exactly once in \tcode{Types...}.
Otherwise, the program is ill-formed.

\pnum
\effects
If \tcode{v} holds a value of type \tcode{T}, returns a reference to that value.
Otherwise, throws an exception of type \tcode{bad_variant_access}.
\end{itemdescr}

\indexlibrary{\idxcode{get_if}}%
\indexlibrary{\idxcode{variant}!\idxcode{get_if}}%
\begin{itemdecl}
template<size_t I, class... Types>
  constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
    get_if(variant<Types...>* v) noexcept;
template<size_t I, class... Types>
  constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
    get_if(const variant<Types...>* v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{I < sizeof...(Types)}.
Otherwise the program is ill-formed.

\pnum
\returns
A pointer to the value stored in the \tcode{variant}, if \tcode{v != nullptr}
and \tcode{v->index() == I}. Otherwise, returns \tcode{nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{get_if}}%
\indexlibrary{\idxcode{variant}!\idxcode{get_if}}%
\begin{itemdecl}
template<class T, class... Types>
  constexpr add_pointer_t<T>
    get_if(variant<Types...>* v) noexcept;
template<class T, class... Types>
  constexpr add_pointer_t<const T>
    get_if(const variant<Types...>* v) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The type \tcode{T} occurs exactly once in \tcode{Types...}.
Otherwise, the program is ill-formed.

\pnum
\effects
Equivalent to: \tcode{return get_if<$i$>(v);} with $i$ being the zero-based
index of \tcode{T} in \tcode{Types...}.
\end{itemdescr}

\rSec2[variant.relops]{Relational operators}

\indexlibrarymember{operator==}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator==(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) == get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{v.index() != w.index()}, \tcode{false};
otherwise if \tcode{v.valueless_by_exception()}, \tcode{true};
otherwise \tcode{get<$i$>(v) == get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator!=(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) != get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{v.index() != w.index()}, \tcode{true};
otherwise if \tcode{v.valueless_by_exception()}, \tcode{false};
otherwise \tcode{get<$i$>(v) != get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\indexlibrarymember{operator<}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator<(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) < get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{w.valueless_by_exception()}, \tcode{false};
otherwise if \tcode{v.valueless_by_exception()}, \tcode{true};
otherwise, if \tcode{v.index() < w.index()}, \tcode{true};
otherwise if \tcode{v.index() > w.index()}, \tcode{false};
otherwise \tcode{get<$i$>(v) < get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\indexlibrarymember{operator>}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator>(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) > get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{v.valueless_by_exception()}, \tcode{false};
otherwise if \tcode{w.valueless_by_exception()}, \tcode{true};
otherwise, if \tcode{v.index() > w.index()}, \tcode{true};
otherwise if \tcode{v.index() < w.index()}, \tcode{false};
otherwise \tcode{get<$i$>(v) > get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\indexlibrarymember{operator<=}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator<=(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) <= get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{v.valueless_by_exception()}, \tcode{true};
otherwise if \tcode{w.valueless_by_exception()}, \tcode{false};
otherwise, if \tcode{v.index() < w.index()}, \tcode{true};
otherwise if \tcode{v.index() > w.index()}, \tcode{false};
otherwise \tcode{get<$i$>(v) <= get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\indexlibrarymember{operator>=}{variant}%
\begin{itemdecl}
template<class... Types>
  constexpr bool operator>=(const variant<Types...>& v, const variant<Types...>& w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get<$i$>(v) >= get<$i$>(w)} is a valid expression returning a type that is
convertible to \tcode{bool}, for all $i$.

\pnum
\returns
If \tcode{w.valueless_by_exception()}, \tcode{true};
otherwise if \tcode{v.valueless_by_exception()}, \tcode{false};
otherwise, if \tcode{v.index() > w.index()}, \tcode{true};
otherwise if \tcode{v.index() < w.index()}, \tcode{false};
otherwise \tcode{get<$i$>(v) >= get<$i$>(w)} with $i$ being \tcode{v.index()}.
\end{itemdescr}

\rSec2[variant.visit]{Visitation}

\indexlibrary{\idxcode{visit}}%
\indexlibrary{\idxcode{variant}!\idxcode{visit}}%
\begin{itemdecl}
template<class Visitor, class... Variants>
  constexpr @\seebelow@ visit(Visitor&& vis, Variants&&... vars);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let $n$ be \tcode{sizeof...(Variants)}. Let \tcode{m} be a pack of $n$
values of type \tcode{size_t}. Such a pack is called valid if $0 \leq
\tcode{m}_i < \tcode{variant_size_v<remove_reference_t<Variants}_i\tcode{>>}$ for
all $0 \leq i < n$. For each valid pack $\tcode{m}$, let $e(\tcode{m})$
denote the expression:
\begin{codeblock}
@\placeholder{INVOKE}@(std::forward<Visitor>(vis), get<m>(std::forward<Variants>(vars))...) // see \ref{func.require}
\end{codeblock}

\pnum
\requires
For each valid pack \tcode{m}, $e(\tcode{m})$ shall be a valid expression.
All such expressions shall be of the same type and value category;
otherwise, the program is ill-formed.

\pnum
\returns $e(\tcode{m})$, where \tcode{m} is the pack for which
$\tcode{m}_i$ is \tcode{vars$_i$.index()} for
all $0 \leq i < n$. The return type is the type of $e(\tcode{m})$.

\pnum
\throws
\tcode{bad_variant_access} if any \tcode{variant} in \tcode{vars} is \tcode{valueless_by_exception()}.

\pnum
\complexity
For $n \leq 1$, the invocation of the callable object is
implemented in constant time, i.e., for $n = 1$, it does not depend on
the number of alternative types of $\tcode{Variants}_0$.
For $n > 1$, the invocation of the callable object has
no complexity requirements.
\end{itemdescr}

\indexlibrary{\idxcode{monostate}}%
\rSec2[variant.monostate]{Class \tcode{monostate}}

\begin{itemdecl}
struct monostate{};
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{monostate} can serve as a first alternative type for
a \tcode{variant} to make the \tcode{variant} type default constructible.
\end{itemdescr}


\rSec2[variant.monostate.relops]{\tcode{monostate} relational operators}

\indexlibrary{\idxcode{operator==}!\idxcode{monostate}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{monostate}}%
\indexlibrary{\idxcode{operator<}!\idxcode{monostate}}%
\indexlibrary{\idxcode{operator>}!\idxcode{monostate}}%
\indexlibrary{\idxcode{operator<=}!\idxcode{monostate}}%
\indexlibrary{\idxcode{operator>=}!\idxcode{monostate}}%
\begin{itemdecl}
constexpr bool operator==(monostate, monostate) noexcept { return true; }
constexpr bool operator!=(monostate, monostate) noexcept { return false; }
constexpr bool operator<(monostate, monostate) noexcept { return false; }
constexpr bool operator>(monostate, monostate) noexcept { return false; }
constexpr bool operator<=(monostate, monostate) noexcept { return true; }
constexpr bool operator>=(monostate, monostate) noexcept { return true; }
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note} \tcode{monostate} objects have only a single state; they thus always compare equal.\end{note}
\end{itemdescr}


\rSec2[variant.specalg]{Specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{variant}}%
\begin{itemdecl}
template<class... Types>
  void swap(variant<Types...>& v, variant<Types...>& w) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{v.swap(w)}.

\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{is_move_constructible_v<$\tcode{T}_i$> \&\& is_swappable_v<$\tcode{T}_i$>}
is \tcode{true} for all $i$.
The expression inside \tcode{noexcept} is equivalent to \tcode{noexcept(v.swap(w))}.
\end{itemdescr}

\indexlibrary{\idxcode{bad_variant_access}}%
\rSec2[variant.bad.access]{Class \tcode{bad_variant_access}}

\begin{codeblock}
class bad_variant_access : public exception {
public:
  bad_variant_access() noexcept;
  const char* what() const noexcept override;
};
\end{codeblock}

\pnum
Objects of type \tcode{bad_variant_access} are thrown to report invalid
accesses to the value of a \tcode{variant} object.

\indexlibrary{\idxcode{bad_variant_access}!constructor}%
\begin{itemdecl}
bad_variant_access() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
Constructs a \tcode{bad_variant_access} object.
\end{itemdescr}

\indexlibrarymember{what}{bad_variant_access}%
\begin{itemdecl}
const char* what() const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An \impldef{return value of \tcode{bad_variant_access::what}} \ntbs{}.
\end{itemdescr}

\rSec2[variant.hash]{Hash support}

\indexlibrary{\idxcode{hash}!\idxcode{variant}}%
\begin{itemdecl}
template<class... Types> struct hash<variant<Types...>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization \tcode{hash<variant<Types...>>} is enabled\iref{unord.hash}
if and only if every specialization in \tcode{hash<remove_const_t<Types>>...} is enabled.
The member functions are not guaranteed to be \tcode{noexcept}.
\end{itemdescr}

\indexlibrary{\idxcode{hash}!\idxcode{monostate}}%
\begin{itemdecl}
template<> struct hash<monostate>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization is enabled\iref{unord.hash}.
\end{itemdescr}


\rSec1[any]{Storage for any type}

\pnum
This subclause describes components that \Cpp{} programs may use to perform operations on objects of a discriminated type.

\pnum
\begin{note}
The discriminated type may contain values of different types but does not attempt conversion between them,
i.e., \tcode{5} is held strictly as an \tcode{int} and is not implicitly convertible either to \tcode{"5"} or to \tcode{5.0}.
This indifference to interpretation but awareness of type effectively allows safe, generic containers of single values, with no scope for surprises from ambiguous conversions.
\end{note}

\rSec2[any.synop]{Header \tcode{<any>} synopsis}

\indexhdr{any}%

\begin{codeblock}
namespace std {
  // \ref{any.bad_any_cast}, class \tcode{bad_any_cast}
  class bad_any_cast;

  // \ref{any.class}, class \tcode{any}
  class any;

  // \ref{any.nonmembers}, non-member functions
  void swap(any& x, any& y) noexcept;

  template<class T, class... Args>
    any make_any(Args&& ...args);
  template<class T, class U, class... Args>
    any make_any(initializer_list<U> il, Args&& ...args);

  template<class T>
    T any_cast(const any& operand);
  template<class T>
    T any_cast(any& operand);
  template<class T>
    T any_cast(any&& operand);

  template<class T>
    const T* any_cast(const any* operand) noexcept;
  template<class T>
    T* any_cast(any* operand) noexcept;
}
\end{codeblock}

\rSec2[any.bad_any_cast]{Class \tcode{bad_any_cast}}

\indexlibrary{\idxcode{bad_any_cast}}%
\begin{codeblock}
class bad_any_cast : public bad_cast {
public:
  const char* what() const noexcept override;
};
\end{codeblock}

\pnum
Objects of type \tcode{bad_any_cast} are thrown by a failed \tcode{any_cast}\iref{any.nonmembers}.

\indexlibrarymember{what}{bad_any_cast}%
\begin{itemdecl}
const char* what() const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An \impldef{return value of \tcode{bad_any_cast::what}} \ntbs{}.

\pnum
\remarks
The message may be a null-terminated multibyte string\iref{multibyte.strings},
suitable for conversion and display as a wstring~(\ref{string.classes}, \ref{locale.codecvt}).
\end{itemdescr}

\rSec2[any.class]{Class \tcode{any}}

\begin{codeblock}
namespace std {
  class any {
  public:
    // \ref{any.cons}, construction and destruction
    constexpr any() noexcept;

    any(const any& other);
    any(any&& other) noexcept;

    template<class T>
      any(T&& value);

    template<class T, class... Args>
      explicit any(in_place_type_t<T>, Args&&...);
    template<class T, class U, class... Args>
      explicit any(in_place_type_t<T>, initializer_list<U>, Args&&...);

    ~any();

    // \ref{any.assign}, assignments
    any& operator=(const any& rhs);
    any& operator=(any&& rhs) noexcept;

    template<class T>
      any& operator=(T&& rhs);

    // \ref{any.modifiers}, modifiers
    template<class T, class... Args>
      decay_t<T>& emplace(Args&& ...);
    template<class T, class U, class... Args>
      decay_t<T>& emplace(initializer_list<U>, Args&&...);
    void reset() noexcept;
    void swap(any& rhs) noexcept;

    // \ref{any.observers}, observers
    bool has_value() const noexcept;
    const type_info& type() const noexcept;
  };
}
\end{codeblock}

\pnum
An object of class \tcode{any} stores an instance of any type that satisfies the constructor requirements or it has no value,
and this is referred to as the \defn{state} of the class \tcode{any} object.
The stored instance is called the \defnx{contained value}{contained value!\idxcode{any}}.
Two states are equivalent if either they both have no value, or both have a value and the contained values are equivalent.

\pnum
The non-member \tcode{any_cast} functions provide type-safe access to the contained value.

\pnum
Implementations should avoid the use of dynamically allocated memory for a small contained value.
However, any such small-object optimization shall only be applied to types \tcode{T} for which
\tcode{is_nothrow_move_constructible_v<T>} is \tcode{true}.
\begin{example}
A contained value of type \tcode{int} could be stored in an internal buffer,
not in separately-allocated memory.
\end{example}

\rSec3[any.cons]{Construction and destruction}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
constexpr any() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{has_value()} is \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
any(const any& other);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{other.has_value()} is \tcode{false}, constructs an object that has no value.
Otherwise, equivalent to \tcode{any(in_place_type<T>, any_cast<const T\&>(other))}
where \tcode{T} is the type of the contained value.

\pnum
\throws
Any exceptions arising from calling the selected constructor for the contained value.
\end{itemdescr}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
any(any&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{other.has_value()} is \tcode{false}, constructs an object that has no value.
Otherwise, constructs an object of type \tcode{any} that
contains either the contained value of \tcode{other}, or
contains an object of the same type constructed from
the contained value of \tcode{other} considering that contained value as an rvalue.

\pnum
\postconditions
\tcode{other} is left in a valid but otherwise unspecified state.
\end{itemdescr}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
template<class T>
  any(T&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires
\tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects
Constructs an object of type \tcode{any} that contains an object of type \tcode{VT} direct-initialized with \tcode{std::forward<T>(value)}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{VT} is not the same type as \tcode{any},
\tcode{VT} is not a specialization of \tcode{in_place_type_t},
and \tcode{is_copy_constructible_v<VT>} is \tcode{true}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{VT}.
\end{itemdescr}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
template<class T, class... Args>
  explicit any(in_place_type_t<T>, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires \tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects Initializes the contained value as if direct-non-list-initializing an object of
type \tcode{VT} with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions \tcode{*this} contains a value of type \tcode{VT}.

\pnum
\throws Any exception thrown by the selected constructor of \tcode{VT}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_copy_constructible_v<VT>} is \tcode{true} and
\tcode{is_constructible_v<VT, Args...>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{any}!constructor}%
\begin{itemdecl}
template<class T, class U, class... Args>
  explicit any(in_place_type_t<T>, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires \tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects Initializes the contained value as if direct-non-list-initializing an object of
type \tcode{VT} with the arguments \tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions \tcode{*this} contains a value.

\pnum
\throws Any exception thrown by the selected constructor of \tcode{VT}.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_copy_constructible_v<VT>} is \tcode{true} and
\tcode{is_constructible_v<VT, initializer_list<U>\&, Args...>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{any}!destructor}
\begin{itemdecl}
~any();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{reset()}.
\end{itemdescr}

\rSec3[any.assign]{Assignment}

\indexlibrarymember{operator=}{any}%
\begin{itemdecl}
any& operator=(const any& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{any(rhs).swap(*this)}.
No effects if an exception is thrown.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
Any exceptions arising from the copy constructor for the contained value.
\end{itemdescr}

\indexlibrarymember{operator=}{any}%
\begin{itemdecl}
any& operator=(any&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{any(std::move(rhs)).swap(*this)}.

\pnum
\returns
\tcode{*this}.

\pnum
\postconditions
The state of \tcode{*this} is equivalent to the original state of \tcode{rhs}
and \tcode{rhs} is left in a valid but otherwise unspecified state.
\end{itemdescr}

\indexlibrarymember{operator=}{any}%
\begin{itemdecl}
template<class T>
  any& operator=(T&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires
\tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects
Constructs an object \tcode{tmp} of type \tcode{any} that contains an object of type \tcode{VT} direct-initialized with \tcode{std::forward<T>(rhs)}, and \tcode{tmp.swap(*this)}.
No effects if an exception is thrown.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
This operator shall not participate in overload resolution unless
\tcode{VT} is not the same type as \tcode{any} and
\tcode{is_copy_constructible_v<VT>} is \tcode{true}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{VT}.
\end{itemdescr}

\rSec3[any.modifiers]{Modifiers}

\indexlibrarymember{emplace}{any}%
\begin{itemdecl}
template<class T, class... Args>
  decay_t<T>& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires
\tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects Calls \tcode{reset()}.
Then initializes the contained value as if direct-non-list-initializing
an object of type \tcode{VT} with the arguments \tcode{std::forward<Args>(args)...}.

\pnum
\postconditions \tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws Any exception thrown by the selected constructor of \tcode{VT}.

\pnum
\remarks If an exception is thrown during the call to \tcode{VT}'s constructor,
\tcode{*this} does not contain a value, and any previously contained value
has been destroyed.
This function shall not participate in overload resolution unless
\tcode{is_copy_constructible_v<VT>} is \tcode{true} and
\tcode{is_constructible_v<VT, Args...>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{emplace}{any}%
\begin{itemdecl}
template<class T, class U, class... Args>
  decay_t<T>& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VT} be \tcode{decay_t<T>}.

\pnum
\requires
\tcode{VT} shall satisfy the \tcode{CopyConstructible} requirements.

\pnum
\effects Calls \tcode{reset()}. Then initializes the contained value
as if direct-non-list-initializing an object of type \tcode{VT} with the arguments
\tcode{il, std::forward<Args>(args)...}.

\pnum
\postconditions \tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws Any exception thrown by the selected constructor of \tcode{VT}.

\pnum
\remarks If an exception is thrown during the call to \tcode{VT}'s constructor,
\tcode{*this} does not contain a value, and any previously contained value
has been destroyed.
The function shall not participate in overload resolution unless
\tcode{is_copy_constructible_v<VT>} is \tcode{true} and
\tcode{is_constructible_v<VT, initializer_list<U>\&, Args...>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{reset}{any}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{has_value()} is \tcode{true}, destroys the contained value.

\pnum
\postconditions
\tcode{has_value()} is \tcode{false}.
\end{itemdescr}

\indexlibrarymember{swap}{any}%
\begin{itemdecl}
void swap(any& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects
Exchanges the states of \tcode{*this} and \tcode{rhs}.
\end{itemdescr}

\rSec3[any.observers]{Observers}

\indexlibrarymember{has_value}{any}%
\begin{itemdecl}
bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{*this} contains an object, otherwise \tcode{false}.
\end{itemdescr}

\indexlibrarymember{type}{any}%
\begin{itemdecl}
const type_info& type() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{typeid(T)} if \tcode{*this} has a contained value of type \tcode{T},
otherwise \tcode{typeid(void)}.

\pnum
\begin{note}
Useful for querying against types known either at compile time or only at runtime.
\end{note}
\end{itemdescr}

\rSec2[any.nonmembers]{Non-member functions}

\indexlibrary{\idxcode{swap}!\idxcode{any}}%
\begin{itemdecl}
void swap(any& x, any& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{x.swap(y)}.
\end{itemdescr}

\indexlibrary{\idxcode{make_any}}%
\begin{itemdecl}
template<class T, class... Args>
  any make_any(Args&& ...args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return any(in_place_type<T>, std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibrary{\idxcode{make_any}}%
\begin{itemdecl}
template<class T, class U, class... Args>
  any make_any(initializer_list<U> il, Args&& ...args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return any(in_place_type<T>, il, std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibrary{\idxcode{any_cast}}%
\begin{itemdecl}
template<class T>
  T any_cast(const any& operand);
template<class T>
  T any_cast(any& operand);
template<class T>
  T any_cast(any&& operand);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be the type \tcode{remove_cvref_t<T>}.

\pnum
\requires
For the first overload, \tcode{is_constructible_v<T, const U\&>} is \tcode{true}.
For the second overload, \tcode{is_constructible_v<T, U\&>} is \tcode{true}.
For the third overload, \tcode{is_constructible_v<T, U>} is \tcode{true}.
Otherwise the program is ill-formed.

\pnum
\returns
For the first and second overload, \tcode{static_cast<T>(*any_cast<U>(\&operand))}.
For the third overload, \tcode{static_cast<T>(std::move(*any_cast<U>(\&operand)))}.

\pnum
\throws
\tcode{bad_any_cast} if \tcode{operand.type() != typeid(remove_reference_t<T>)}.

\pnum
\begin{example}
\begin{codeblock}
any x(5);                                   // \tcode{x} holds \tcode{int}
assert(any_cast<int>(x) == 5);              // cast to value
any_cast<int&>(x) = 10;                     // cast to reference
assert(any_cast<int>(x) == 10);

x = "Meow";                                 // \tcode{x} holds \tcode{const char*}
assert(strcmp(any_cast<const char*>(x), "Meow") == 0);
any_cast<const char*&>(x) = "Harry";
assert(strcmp(any_cast<const char*>(x), "Harry") == 0);

x = string("Meow");                         // \tcode{x} holds \tcode{string}
string s, s2("Jane");
s = move(any_cast<string&>(x));             // move from \tcode{any}
assert(s == "Meow");
any_cast<string&>(x) = move(s2);            // move to \tcode{any}
assert(any_cast<const string&>(x) == "Jane");

string cat("Meow");
const any y(cat);                           // \tcode{const y} holds \tcode{string}
assert(any_cast<const string&>(y) == cat);

any_cast<string&>(y);                       // error; cannot
                                            // \tcode{any_cast} away const
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{any_cast}}%
\begin{itemdecl}
template<class T>
  const T* any_cast(const any* operand) noexcept;
template<class T>
  T* any_cast(any* operand) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{operand != nullptr \&\& operand->type() == typeid(T)},
a pointer to the object contained by \tcode{operand};
otherwise, \tcode{nullptr}.

\pnum
\begin{example}
\begin{codeblock}
bool is_string(const any& operand) {
  return any_cast<string>(&operand) != nullptr;
}
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec1[bitset]{Bitsets}
\indexlibrary{\idxcode{bitset}}%

\rSec2[bitset.syn]{Header \tcode{<bitset>} synopsis}%

\indexhdr{bitset}%

\begin{codeblock}
#include <string>
#include <iosfwd>   // for \tcode{istream}\iref{istream.syn}, \tcode{ostream}\iref{ostream.syn}, see \ref{iosfwd.syn}

namespace std {
  template<size_t N> class bitset;

  // \ref{bitset.operators}, bitset operators
  template<size_t N>
    bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;
  template<size_t N>
    bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;
  template<size_t N>
    bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
  template<class charT, class traits, size_t N>
    basic_istream<charT, traits>&
      operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
  template<class charT, class traits, size_t N>
    basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
}
\end{codeblock}

\pnum
The header
\tcode{<bitset>}
defines a
class template
and several related functions for representing
and manipulating fixed-size sequences of bits.

\rSec2[template.bitset]{Class template \tcode{bitset}}%
\indexlibrary{\idxcode{bitset}}%
\begin{codeblock}
namespace std {
  template<size_t N> class bitset {
  public:
    // bit reference
    class reference {
      friend class bitset;
      reference() noexcept;

    public:
      ~reference() noexcept;
      reference& operator=(bool x) noexcept;            // for \tcode{b[i] = x;}
      reference& operator=(const reference&) noexcept;  // for \tcode{b[i] = b[j];}
      bool operator~() const noexcept;                  // flips the bit
      operator bool() const noexcept;                   // for \tcode{x = b[i];}
      reference& flip() noexcept;                       // for \tcode{b[i].flip();}
    };

    // \ref{bitset.cons}, constructors
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template<class charT, class traits, class Allocator>
      explicit bitset(
        const basic_string<charT, traits, Allocator>& str,
        typename basic_string<charT, traits, Allocator>::size_type pos = 0,
        typename basic_string<charT, traits, Allocator>::size_type n
          = basic_string<charT, traits, Allocator>::npos,
        charT zero = charT('0'),
        charT one = charT('1'));
    template<class charT>
      explicit bitset(
        const charT* str,
        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
        charT zero = charT('0'),
        charT one = charT('1'));

    // \ref{bitset.members}, bitset operations
    bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
    bitset<N>& operator<<=(size_t pos) noexcept;
    bitset<N>& operator>>=(size_t pos) noexcept;
    bitset<N>& set() noexcept;
    bitset<N>& set(size_t pos, bool val = true);
    bitset<N>& reset() noexcept;
    bitset<N>& reset(size_t pos);
    bitset<N>  operator~() const noexcept;
    bitset<N>& flip() noexcept;
    bitset<N>& flip(size_t pos);

    // element access
    constexpr bool operator[](size_t pos) const;        // for \tcode{b[i];}
    reference operator[](size_t pos);                   // for \tcode{b[i];}

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template<class charT = char,
              class traits = char_traits<charT>,
              class Allocator = allocator<charT>>
      basic_string<charT, traits, Allocator>
        to_string(charT zero = charT('0'), charT one = charT('1')) const;

    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset<N>& rhs) const noexcept;
    bool operator!=(const bitset<N>& rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset<N> operator<<(size_t pos) const noexcept;
    bitset<N> operator>>(size_t pos) const noexcept;
  };

  // \ref{bitset.hash}, hash support
  template<class T> struct hash;
  template<size_t N> struct hash<bitset<N>>;
}
\end{codeblock}

\pnum
The class template
\tcode{bitset<N>}
describes an object that can store a sequence consisting of a fixed number of
bits, \tcode{N}.

\pnum
Each bit represents either the value zero (reset) or one (set).
To
\term{toggle}
a bit is to change the value zero to one, or the value one to
zero.
Each bit has a non-negative position \tcode{pos}.
When converting
between an object of class
\tcode{bitset<N>}
and a value of some
integral type, bit position \tcode{pos} corresponds to the
\term{bit value}
\tcode{1 << pos}.
The integral value corresponding to two
or more bits is the sum of their bit values.

\pnum
The functions described in this subclause can report three kinds of
errors, each associated with a distinct exception:

\begin{itemize}
\item
an
\term{invalid-argument}
error is associated with exceptions of type
\tcode{invalid_argument}\iref{invalid.argument};
\indexlibrary{\idxcode{invalid_argument}}%
\item
an
\term{out-of-range}
error is associated with exceptions of type
\tcode{out_of_range}\iref{out.of.range};
\indexlibrary{\idxcode{out_of_range}}%
\item
an
\term{overflow}
error is associated with exceptions of type
\tcode{overflow_error}\iref{overflow.error}.
\indexlibrary{\idxcode{overflow_error}}%
\end{itemize}

\rSec3[bitset.cons]{\tcode{bitset} constructors}

\indexlibrary{\idxcode{bitset}!constructor}%
\begin{itemdecl}
constexpr bitset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing all bits to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!constructor}%
\begin{itemdecl}
constexpr bitset(unsigned long long val) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit positions to the corresponding bit
values in \tcode{val}.
\tcode{M} is the smaller of \tcode{N} and the number of bits in the value
representation\iref{basic.types} of \tcode{unsigned long long}.
If \tcode{M < N}, the remaining bit positions are initialized to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!constructor}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  explicit bitset(
    const basic_string<charT, traits, Allocator>& str,
    typename basic_string<charT, traits, Allocator>::size_type pos = 0,
    typename basic_string<charT, traits, Allocator>::size_type n
      = basic_string<charT, traits, Allocator>::npos,
    charT zero = charT('0'),
    charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}
or \tcode{invalid_argument} if an invalid character is found (see below).%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Determines the effective length
\tcode{rlen} of the initializing string as the smaller of
\tcode{n} and
\tcode{str.size() - pos}.

The function then throws%
\indexlibrary{\idxcode{invalid_argument}}
\tcode{invalid_argument}
if any of the \tcode{rlen}
characters in \tcode{str} beginning at position \tcode{pos} is
other than \tcode{zero} or \tcode{one}. The function uses \tcode{traits::eq()}
to compare the character values.

Otherwise, the function constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit
positions to values determined from the corresponding characters in the string
\tcode{str}.
\tcode{M} is the smaller of \tcode{N} and \tcode{rlen}.

\pnum
An element of the constructed object has value zero if the
corresponding character in \tcode{str}, beginning at position
\tcode{pos}, is
\tcode{zero}.
Otherwise, the element has the value one.
Character position \tcode{pos + M - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit positions.

\pnum
If \tcode{M < N}, remaining bit positions are initialized to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!constructor}%
\begin{itemdecl}
template<class charT>
  explicit bitset(
    const charT* str,
    typename basic_string<charT>::size_type n = basic_string<charT>::npos,
    charT zero = charT('0'),
    charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{bitset<N>} as if by:
\begin{codeblock}
bitset(n == basic_string<charT>::npos
          ? basic_string<charT>(str)
          : basic_string<charT>(str, n),
       0, n, zero, one)
\end{codeblock}
\end{itemdescr}


\rSec3[bitset.members]{\tcode{bitset} members}

\indexlibrarymember{operator\&=}{bitset}%
\begin{itemdecl}
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Clears each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is clear, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator"|=}{bitset}%
\begin{itemdecl}
bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\caret=}{bitset}%
\begin{itemdecl}
bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator<<=}{bitset}%
\begin{itemdecl}
bitset<N>& operator<<=(size_t pos) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{I < pos}, the new value is zero;
\item
If \tcode{I >= pos}, the new value is the previous
value of the bit at position \tcode{I - pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator>>=}{bitset}%
\begin{itemdecl}
bitset<N>& operator>>=(size_t pos) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{pos >= N - I}, the new value is zero;
\item
If \tcode{pos < N - I}, the new value is the previous value of the bit at position \tcode{I + pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

% Do not use \indexlibrarymember.
\indexlibrary{\idxcode{set} (member)!\idxcode{bitset}}%
\indexlibrary{\idxcode{bitset}!\idxcode{set}}%
\begin{itemdecl}
bitset<N>& set() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{set} (member)!\idxcode{bitset}}%
\indexlibrary{\idxcode{bitset}!\idxcode{set}}%
\begin{itemdecl}
bitset<N>& set(size_t pos, bool val = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Stores a new value in the bit at position \tcode{pos} in
\tcode{*this}.
If \tcode{val} is \tcode{true}, the stored value is one, otherwise it is zero.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{reset}{bitset}%
\begin{itemdecl}
bitset<N>& reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Resets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{reset}{bitset}%
\begin{itemdecl}
bitset<N>& reset(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.
\indexlibrary{\idxcode{out_of_range}}%

\pnum
\effects
Resets the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\~{}}{bitset}%
\begin{itemdecl}
bitset<N> operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object \tcode{x} of class
\tcode{bitset<N>}
and initializes it with
\tcode{*this}.

\pnum
\returns
\tcode{x.flip()}.
\end{itemdescr}

\indexlibrarymember{flip}{bitset}%
\begin{itemdecl}
bitset<N>& flip() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{flip}{bitset}%
\begin{itemdecl}
bitset<N>& flip(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Toggles the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{to_ulong}{bitset}%
\begin{itemdecl}
unsigned long to_ulong() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{overflow_error}%
\indexlibrary{\idxcode{overflow_error}}
if the integral value \tcode{x} corresponding to the bits in
\tcode{*this}
cannot be represented as type
\tcode{unsigned long}.

\pnum
\returns
\tcode{x}.
\end{itemdescr}

\indexlibrarymember{to_ullong}{bitset}%
\begin{itemdecl}
unsigned long long to_ullong() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\indexlibrary{\idxcode{overflow_error}}%
\throws
\tcode{overflow_error}
if the integral value \tcode{x} corresponding to the bits in
\tcode{*this}
cannot be represented as type
\tcode{unsigned long long}.

\pnum
\returns
\tcode{x}.
\end{itemdescr}

\indexlibrarymember{to_string}{bitset}%
\begin{itemdecl}
template<class charT = char,
          class traits = char_traits<charT>,
          class Allocator = allocator<charT>>
  basic_string<charT, traits, Allocator>
    to_string(charT zero = charT('0'), charT one = charT('1')) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a string object of the appropriate type
and initializes it to a string of length \tcode{N} characters.
Each character is determined by the value of its corresponding bit position in
\tcode{*this}.
Character position \tcode{N - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit
positions.
Bit value zero becomes the character \tcode{zero},
bit value one becomes the character
\tcode{one}.

\pnum
\returns
The created object.
\end{itemdescr}

\indexlibrarymember{count}{bitset}%
\begin{itemdecl}
size_t count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A count of the number of bits set in
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{size}{bitset}%
\begin{itemdecl}
constexpr size_t size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{N}.
\end{itemdescr}

\indexlibrarymember{operator==}{bitset}%
\begin{itemdecl}
bool operator==(const bitset<N>& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if the value of each bit in
\tcode{*this}
equals the value of the corresponding bit in \tcode{rhs}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{bitset}%
\begin{itemdecl}
bool operator!=(const bitset<N>& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if
\tcode{!(*this == rhs)}.
\end{itemdescr}

\indexlibrarymember{test}{bitset}%
\begin{itemdecl}
bool test(size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\returns
\tcode{true}
if the bit at position \tcode{pos}
in
\tcode{*this}
has the value one.
\end{itemdescr}

\indexlibrarymember{all}{bitset}%
\begin{itemdecl}
bool all() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() == size()}.
\end{itemdescr}

\indexlibrary{\idxcode{any} (member)!\idxcode{bitset}}%
\indexlibrary{\idxcode{bitset}!\idxcode{any}}%
\begin{itemdecl}
bool any() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() != 0}.
\end{itemdescr}

\indexlibrarymember{none}{bitset}%
\begin{itemdecl}
bool none() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{count() == 0}.
\end{itemdescr}

\indexlibrarymember{operator<<}{bitset}%
\begin{itemdecl}
bitset<N> operator<<(size_t pos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) <<= pos}.
\end{itemdescr}

\indexlibrarymember{operator>>}{bitset}%
\begin{itemdecl}
bitset<N> operator>>(size_t pos) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) >>= pos}.
\end{itemdescr}

\indexlibrarymember{operator[]}{bitset}%
\begin{itemdecl}
constexpr bool operator[](size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} shall be valid.

\pnum
\returns
\tcode{true} if the bit at position \tcode{pos} in \tcode{*this} has the value
one, otherwise \tcode{false}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{operator[]}{bitset}%
\begin{itemdecl}
bitset<N>::reference operator[](size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} shall be valid.

\pnum
\returns
An object of type
\tcode{bitset<N>::reference}
such that
\tcode{(*this)[pos] == this->test(pos)},
and such that
\tcode{(*this)[pos] = val}
is equivalent to
\tcode{this->set(pos, val)}.

\pnum
\throws Nothing.

\pnum
\remarks For the purpose of determining the presence of a data
race\iref{intro.multithread}, any access or update through the resulting
reference potentially accesses or modifies, respectively, the entire
underlying bitset.
\end{itemdescr}

\rSec2[bitset.hash]{\tcode{bitset} hash support}

\indexlibrary{\idxcode{hash_code}}%
\begin{itemdecl}
template<size_t N> struct hash<bitset<N>>;
\end{itemdecl}

\begin{itemdescr}
\pnum The specialization is enabled\iref{unord.hash}.
\end{itemdescr}


\rSec2[bitset.operators]{\tcode{bitset} operators}

\indexlibrarymember{operator\&}{bitset}%
\begin{itemdecl}
bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \&= rhs}.
\end{itemdescr}

\indexlibrarymember{operator"|}{bitset}%
\begin{itemdecl}
bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) |= rhs}.
\end{itemdescr}

\indexlibrarymember{operator\caret}{bitset}%
\begin{itemdecl}
bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \caret= rhs}.
\end{itemdescr}

\indexlibrarymember{operator>>}{bitset}%
\begin{itemdecl}
template<class charT, class traits, size_t N>
  basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
A formatted input function\iref{istream.formatted}.

\pnum
\effects
Extracts up to \tcode{N} characters from \tcode{is}.
Stores these characters in a temporary object \tcode{str} of type
\tcode{basic_string<charT, traits>},
then evaluates the expression
\tcode{x = bitset<N>(str)}.
Characters are extracted and stored until any of the following occurs:

\begin{itemize}
\item
\tcode{N} characters have been extracted and stored;
\item
end-of-file occurs on the input sequence;%
\indextext{end-of-file}
\item
the next input character is neither
\tcode{is.widen('0')}
nor
\tcode{is.widen('1')}
(in which case the input character is not extracted).
\end{itemize}

\pnum
If no characters are stored in \tcode{str}, calls
\tcode{is.setstate(ios_base::failbit)}
(which may throw
\tcode{ios_base::failure}\iref{iostate.flags}).

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrarymember{operator<<}{bitset}%
\begin{itemdecl}
template<class charT, class traits, size_t N>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
os << x.template to_string<charT, traits, allocator<charT>>(
  use_facet<ctype<charT>>(os.getloc()).widen('0'),
  use_facet<ctype<charT>>(os.getloc()).widen('1'))
\end{codeblock}
(see~\ref{ostream.formatted}).
\end{itemdescr}

\rSec1[memory]{Memory}

\rSec2[memory.general]{In general}

\pnum
This subclause describes the contents of the header
\tcode{<memory>}\iref{memory.syn} and some
of the contents of the header \tcode{<cstdlib>}\iref{cstdlib.syn}.

\rSec2[memory.syn]{Header \tcode{<memory>} synopsis}

\pnum
The header \tcode{<memory>} defines several types and function templates that
describe properties of pointers and pointer-like types, manage memory
for containers and other template types, destroy objects, and
construct multiple objects in
uninitialized memory
buffers~(\ref{pointer.traits}--\ref{specialized.algorithms}).
The header also defines the templates
\tcode{unique_ptr}, \tcode{shared_ptr}, \tcode{weak_ptr}, and various function
templates that operate on objects of these types\iref{smartptr}.

\indexhdr{memory}%
\begin{codeblock}
namespace std {
  // \ref{pointer.traits}, pointer traits
  template<class Ptr> struct pointer_traits;
  template<class T> struct pointer_traits<T*>;

  // \ref{pointer.conversion}, pointer conversion
  template<class Ptr>
    auto to_address(const Ptr& p) noexcept;
  template<class T>
    constexpr T* to_address(T* p) noexcept;

  // \ref{util.dynamic.safety}, pointer safety
  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template<class T>
    T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;

  // \ref{ptr.align}, pointer alignment function
  void* align(size_t alignment, size_t size, void*& ptr, size_t& space);

  // \ref{allocator.tag}, allocator argument tag
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};

  // \ref{allocator.uses}, \tcode{uses_allocator}
  template<class T, class Alloc> struct uses_allocator;

  // \ref{allocator.traits}, allocator traits
  template<class Alloc> struct allocator_traits;

  // \ref{default.allocator}, the default allocator
  template<class T> class allocator;
  template<class T, class U>
    bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
  template<class T, class U>
    bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

  // \ref{specialized.algorithms}, specialized algorithms
  template<class T>
    constexpr T* addressof(T& r) noexcept;
  template<class T>
    const T* addressof(const T&&) = delete;
  template<class ForwardIterator>
    void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_default_construct(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                         ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                                      ForwardIterator first, Size n);
  template<class ForwardIterator>
    void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_value_construct(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                       ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                                    ForwardIterator first, Size n);
  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                         InputIterator first, Size n,
                                         ForwardIterator result);
  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(InputIterator first, Size n,
                                                              ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                                              InputIterator first, Size n,
                                                              ForwardIterator result);
  template<class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void uninitialized_fill(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last, const T& x);
  template<class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                                         ForwardIterator first, Size n, const T& x);
  template<class T>
    void destroy_at(T* location);
  template<class ForwardIterator>
    void destroy(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void destroy(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator destroy_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator destroy_n(ExecutionPolicy&& exec, // see \ref{algorithms.parallel.overloads}
                              ForwardIterator first, Size n);

  // \ref{unique.ptr}, class template \tcode{unique_ptr}
  template<class T> struct default_delete;
  template<class T> struct default_delete<T[]>;
  template<class T, class D = default_delete<T>> class unique_ptr;
  template<class T, class D> class unique_ptr<T[], D>;

  template<class T, class... Args> unique_ptr<T>
    make_unique(Args&&... args);                                                // \tcode{T} is not array
  template<class T> unique_ptr<T>
    make_unique(size_t n);                                                      // \tcode{T} is \tcode{U[]}
  template<class T, class... Args>
    @\unspecnc@ make_unique(Args&&...) = delete;                                // \tcode{T} is \tcode{U[N]}

  template<class T, class D>
    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

  template<class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

  template<class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template<class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template<class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template<class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template<class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
  template<class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
  template<class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
  template<class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
  template<class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
  template<class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
  template<class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
  template<class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

  template<class E, class T, class Y, class D>
    basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const unique_ptr<Y, D>& p);

  // \ref{util.smartptr.weak.bad}, class \tcode{bad_weak_ptr}
  class bad_weak_ptr;

  // \ref{util.smartptr.shared}, class template \tcode{shared_ptr}
  template<class T> class shared_ptr;

  // \ref{util.smartptr.shared.create}, \tcode{shared_ptr} creation
  template<class T, class... Args>
    shared_ptr<T> make_shared(Args&&... args);                                  // \tcode{T} is not array
  template<class T, class A, class... Args>
    shared_ptr<T> allocate_shared(const A& a, Args&&... args);                  // \tcode{T} is not array

  template<class T>
    shared_ptr<T> make_shared(size_t N);                                        // \tcode{T} is \tcode{U[]}
  template<class T, class A>
    shared_ptr<T> allocate_shared(const A& a, size_t N);                        // \tcode{T} is \tcode{U[]}

  template<class T>
    shared_ptr<T> make_shared();                                                // \tcode{T} is \tcode{U[N]}
  template<class T, class A>
    shared_ptr<T> allocate_shared(const A& a);                                  // \tcode{T} is \tcode{U[N]}

  template<class T>
    shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u);           // \tcode{T} is \tcode{U[]}
  template<class T, class A>
    shared_ptr<T> allocate_shared(const A& a, size_t N,
                                  const remove_extent_t<T>& u);                 // \tcode{T} is \tcode{U[]}

  template<class T> shared_ptr<T>
    make_shared(const remove_extent_t<T>& u);                                   // \tcode{T} is \tcode{U[N]}
  template<class T, class A>
    shared_ptr<T> allocate_shared(const A& a, const remove_extent_t<T>& u);     // \tcode{T} is \tcode{U[N]}

  // \ref{util.smartptr.shared.cmp}, \tcode{shared_ptr} comparisons
  template<class T, class U>
    bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator!=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator<=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
  template<class T, class U>
    bool operator>=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

  template<class T>
    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
  template<class T>
    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
  template<class T>
    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
  template<class T>
    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
  template<class T>
    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
  template<class T>
    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
  template<class T>
    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

  // \ref{util.smartptr.shared.spec}, \tcode{shared_ptr} specialized algorithms
  template<class T>
    void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

  // \ref{util.smartptr.shared.cast}, \tcode{shared_ptr} casts
  template<class T, class U>
    shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
  template<class T, class U>
    shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
  template<class T, class U>
    shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
  template<class T, class U>
    shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;

  // \ref{util.smartptr.getdeleter}, \tcode{shared_ptr} \tcode{get_deleter}
  template<class D, class T>
    D* get_deleter(const shared_ptr<T>& p) noexcept;

  // \ref{util.smartptr.shared.io}, \tcode{shared_ptr} I/O
  template<class E, class T, class Y>
    basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const shared_ptr<Y>& p);

  // \ref{util.smartptr.weak}, class template \tcode{weak_ptr}
  template<class T> class weak_ptr;

  // \ref{util.smartptr.weak.spec}, \tcode{weak_ptr} specialized algorithms
  template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

  // \ref{util.smartptr.ownerless}, class template \tcode{owner_less}
  template<class T = void> struct owner_less;

  // \ref{util.smartptr.enab}, class template \tcode{enable_shared_from_this}
  template<class T> class enable_shared_from_this;

  // \ref{util.smartptr.hash}, hash support
  template<class T> struct hash;
  template<class T, class D> struct hash<unique_ptr<T, D>>;
  template<class T> struct hash<shared_ptr<T>>;

  // \ref{util.smartptr.atomic}, atomic smart pointers
  template<class T> struct atomic<shared_ptr<T>>;
  template<class T> struct atomic<weak_ptr<T>>;

  // \ref{allocator.uses.trait}, \tcode{uses_allocator}
  template<class T, class Alloc>
    inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;
}
\end{codeblock}

\rSec2[pointer.traits]{Pointer traits}

\pnum
The class template \tcode{pointer_traits} supplies a uniform interface to certain
attributes of pointer-like types.

\indexlibrary{\idxcode{pointer_traits}}%
\begin{codeblock}
namespace std {
  template<class Ptr> struct pointer_traits {
    using pointer         = Ptr;
    using element_type    = @\seebelow@;
    using difference_type = @\seebelow@;

    template<class U> using rebind = @\seebelow@;

    static pointer pointer_to(@\seebelow@ r);
  };

  template<class T> struct pointer_traits<T*> {
    using pointer         = T*;
    using element_type    = T;
    using difference_type = ptrdiff_t;

    template<class U> using rebind = U*;

    static pointer pointer_to(@\seebelow@ r) noexcept;
  };
}
\end{codeblock}

\rSec3[pointer.traits.types]{Pointer traits member types}

\indexlibrarymember{element_type}{pointer_traits}%
\begin{itemdecl}
using element_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Ptr::element_type} if
the \grammarterm{qualified-id} \tcode{Ptr::element_type} is valid and denotes a
type\iref{temp.deduct}; otherwise, \tcode{T} if
\tcode{Ptr} is a class template instantiation of the form \tcode{SomePointer<T, Args>},
where \tcode{Args} is zero or more type arguments; otherwise, the specialization is
ill-formed.
\end{itemdescr}

\indexlibrarymember{difference_type}{pointer_traits}%
\begin{itemdecl}
using difference_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Ptr::difference_type} if
the \grammarterm{qualified-id} \tcode{Ptr::difference_type} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{ptrdiff_t}.
\end{itemdescr}

\indexlibrarymember{rebind}{pointer_traits}%
\begin{itemdecl}
template<class U> using rebind = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\templalias \tcode{Ptr::rebind<U>} if
the \grammarterm{qualified-id} \tcode{Ptr::rebind<U>} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{SomePointer<U, Args>} if
\tcode{Ptr} is a class template instantiation of the form \tcode{SomePointer<T, Args>},
where \tcode{Args} is zero or more type arguments; otherwise, the instantiation of
\tcode{rebind} is ill-formed.
\end{itemdescr}

\rSec3[pointer.traits.functions]{Pointer traits member functions}

\indexlibrarymember{pointer_to}{pointer_traits}%
\begin{itemdecl}
static pointer pointer_traits::pointer_to(@\seebelow@ r);
static pointer pointer_traits<T*>::pointer_to(@\seebelow@ r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks If \tcode{element_type} is \cv{}~\tcode{void}, the type of
\tcode{r} is unspecified; otherwise, it is \tcode{element_type\&}.

\pnum
\returns The first member function returns a pointer to \tcode{r}
obtained by calling \tcode{Ptr::pointer_to(r)} through which
indirection is valid; an instantiation of this function is
ill-formed if \tcode{Ptr} does not have a matching \tcode{pointer_to} static member
function. The second member function returns \tcode{addressof(r)}.
\end{itemdescr}

\rSec3[pointer.traits.optmem]{Pointer traits optional members}

\pnum
Specializations of \tcode{pointer_traits} may define the member declared
in this subclause to customize the behavior of the standard library.

\indexlibrarymember{to_address}{pointer_traits}%
\begin{itemdecl}
static element_type* to_address(pointer p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer of type \tcode{element_type*} that references
the same location as the argument \tcode{p}.

\pnum
\begin{note}
This function should be the inverse of \tcode{pointer_to}.
If defined, it customizes the behavior of
the non-member function
\tcode{to_address}\iref{pointer.conversion}.
\end{note}
\end{itemdescr}

\rSec2[pointer.conversion]{Pointer conversion}

\indexlibrary{\idxcode{to_address}}%
\begin{itemdecl}
template<class Ptr> auto to_address(const Ptr& p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{pointer_traits<Ptr>::to_address(p)} if that expression is well-formed
(see \ref{pointer.traits.optmem}),
otherwise \tcode{to_address(p.operator->())}.
\end{itemdescr}

\indexlibrary{\idxcode{to_address}}%
\begin{itemdecl}
template<class T> constexpr T* to_address(T* p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{T} is not a function type. Otherwise the program is ill-formed.

\pnum
\returns \tcode{p}.
\end{itemdescr}

\rSec2[util.dynamic.safety]{Pointer safety}

\pnum
A complete object is \techterm{declared reachable} while the number of calls to
\tcode{declare_reachable} with an argument referencing the object exceeds the
number of calls to \tcode{undeclare_reachable} with an argument referencing the
object.

\indexlibrary{\idxcode{declare_reachable}}%
\begin{itemdecl}
void declare_reachable(void* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall be a safely-derived
pointer\iref{basic.stc.dynamic.safety} or a null pointer value.

\pnum
\effects If \tcode{p} is not null, the complete object referenced by \tcode{p}
is subsequently declared reachable\iref{basic.stc.dynamic.safety}.

\pnum
\throws May throw \tcode{bad_alloc} if the system cannot allocate
additional memory that may be required to track objects declared reachable.
\end{itemdescr}

\indexlibrary{\idxcode{undeclare_reachable}}%
\begin{itemdecl}
template<class T> T* undeclare_reachable(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{p} is not null, the complete object referenced by \tcode{p}
shall have been previously declared reachable, and shall be
live\iref{basic.life} from the time of the call until the last
\tcode{undeclare_reachable(p)} call on the object.

\pnum
\returns A safely derived copy of \tcode{p} which shall compare equal to \tcode{p}.

\pnum
\throws Nothing.

\pnum \begin{note} It is expected that calls to \tcode{declare_reachable(p)} will consume
a small amount of memory in addition to that occupied by the referenced object until the
matching call to \tcode{undeclare_reachable(p)} is encountered. Long running programs
should arrange that calls are matched. \end{note} \end{itemdescr}

\indexlibrary{\idxcode{declare_no_pointers}}%
\begin{itemdecl}
void declare_no_pointers(char* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires No bytes in the specified range
are currently registered with
\tcode{declare_no_pointers()}. If the specified range is in an allocated object,
then it shall be entirely within a single allocated object. The object shall be
live until the corresponding \tcode{undeclare_no_pointers()} call. \begin{note} In
a garbage-collecting implementation, the fact that a region in an object is
registered with \tcode{declare_no_pointers()} should not prevent the object from
being collected. \end{note}

\pnum
\effects The \tcode{n} bytes starting at \tcode{p} no longer contain
traceable pointer locations, independent of their type. Hence
indirection through a pointer located there is undefined if the object
it points to was created by global \tcode{operator new} and not
previously declared reachable. \begin{note} This may be used to inform a
garbage collector or leak detector that this region of memory need not
be traced. \end{note}

\pnum
\throws Nothing.

\pnum
\begin{note} Under some conditions implementations may need to allocate memory.
However, the request can be ignored if memory allocation fails. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{undeclare_no_pointers}}%
\begin{itemdecl}
void undeclare_no_pointers(char* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The same range shall previously have been passed to
\tcode{declare_no_pointers()}.

\pnum
\effects Unregisters a range registered with \tcode{declare_no_pointers()} for
destruction. It shall be called before the lifetime of the object ends.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{get_pointer_safety}}%
\begin{itemdecl}
pointer_safety get_pointer_safety() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{pointer_safety::strict} if the implementation has strict pointer
safety\iref{basic.stc.dynamic.safety}. It is
\impldef{whether \tcode{get_pointer_safety} returns
\tcode{pointer_safety::relaxed} or
\tcode{pointer_safety::\brk{}preferred} if the implementation has relaxed pointer safety}
whether
\tcode{get_pointer_safety} returns \tcode{pointer_safety::relaxed} or
\tcode{point\-er_safety::preferred} if the implementation has relaxed pointer
safety.\footnote{\tcode{pointer_safety::preferred} might be returned to indicate
that a leak detector is running so that the program can avoid spurious leak
reports.}
\end{itemdescr}


\rSec2[ptr.align]{Align}

\indexlibrary{\idxcode{align}}%
\begin{itemdecl}
void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If it is possible to fit \tcode{size} bytes
of storage aligned by \tcode{alignment} into the buffer pointed to by
\tcode{ptr} with length \tcode{space}, the function updates
\tcode{ptr} to represent the first possible address of such storage
and decreases \tcode{space} by the number of bytes used for alignment.
Otherwise, the function does nothing.

\pnum
\requires

\begin{itemize}
\item \tcode{alignment} shall be a power of two

\item \tcode{ptr} shall represent the address of contiguous storage of at least
\tcode{space} bytes
\end{itemize}

\pnum
\returns A null pointer if the requested aligned buffer
would not fit into the available space, otherwise the adjusted value
of \tcode{ptr}.

\pnum
\begin{note} The function updates its \tcode{ptr}
and \tcode{space} arguments so that it can be called repeatedly
with possibly different \tcode{alignment} and \tcode{size}
arguments for the same buffer.  \end{note}
\end{itemdescr}

\rSec2[allocator.tag]{Allocator argument tag}

\indexlibrary{\idxcode{allocator_arg_t}}%
\indexlibrary{\idxcode{allocator_arg}}%
\begin{itemdecl}
namespace std {
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};
}
\end{itemdecl}

\pnum
The \tcode{allocator_arg_t} struct is an empty structure type used as a unique type to
disambiguate constructor and function overloading. Specifically, several types (see
\tcode{tuple}~\ref{tuple}) have constructors with \tcode{allocator_arg_t} as the first
argument, immediately followed by an argument of a type that satisfies the
\tcode{Allocator} requirements (\tref{utilities.allocator.requirements}).

\rSec2[allocator.uses]{\tcode{uses_allocator}}

\rSec3[allocator.uses.trait]{\tcode{uses_allocator} trait}

\indexlibrary{\idxcode{uses_allocator}}%
\begin{itemdecl}
template<class T, class Alloc> struct uses_allocator;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks Automatically detects whether \tcode{T} has a nested \tcode{allocator_type} that
is convertible from \tcode{Alloc}. Meets the \tcode{BinaryTypeTrait}
requirements\iref{meta.rqmts}. The implementation shall provide a definition that is
derived from \tcode{true_type} if the \grammarterm{qualified-id} \tcode{T::allocator_type}
is valid and denotes a type\iref{temp.deduct} and
\tcode{is_convertible_v<Alloc, T::allocator_type> != false}, otherwise it shall be
derived from \tcode{false_type}. A program may specialize this template to derive from
\tcode{true_type} for a user-defined type \tcode{T} that does not have a nested
\tcode{allocator_type} but nonetheless can be constructed with an allocator where
either:

\begin{itemize}
\item the first argument of a constructor has type \tcode{allocator_arg_t} and the
second argument has type \tcode{Alloc} or

\item the last argument of a constructor has type \tcode{Alloc}.
\end{itemize}
\end{itemdescr}

\rSec3[allocator.uses.construction]{Uses-allocator construction}

\pnum
\defnx{Uses-allocator construction}{uses-allocator construction} with allocator \tcode{Alloc} refers to the
construction of an object \tcode{obj} of type \tcode{T}, using constructor arguments
\tcode{v1, v2, ..., vN} of types \tcode{V1, V2, ..., VN}, respectively, and an allocator
\tcode{alloc} of type \tcode{Alloc}, according to the following rules:

\begin{itemize}
\item if \tcode{uses_allocator_v<T, Alloc>} is \tcode{false} and
\tcode{is_constructible_v<T, V1, V2, ..., VN>} is \tcode{true}, then \tcode{obj} is
initialized as \tcode{obj(v1, v2, ..., vN)};

\item otherwise, if \tcode{uses_allocator_v<T, Alloc>} is \tcode{true} and
\tcode{is_constructible_v<T, allocator_arg_t, Alloc,} \tcode{V1, V2, ..., VN>} is
\tcode{true}, then \tcode{obj} is initialized as \tcode{obj(allocator_arg, alloc, v1,
v2, ..., vN)};

\item otherwise, if \tcode{uses_allocator_v<T, Alloc>} is \tcode{true} and
\tcode{is_constructible_v<T, V1, V2, ..., VN, Alloc>} is \tcode{true}, then
\tcode{obj} is initialized as \tcode{obj(v1, v2, ..., vN, alloc)};

\item otherwise, the request for uses-allocator construction is ill-formed. \begin{note}
An error will result if \tcode{uses_allocator_v<T, Alloc>} is \tcode{true} but the
specific constructor does not take an allocator. This definition prevents a silent
failure to pass the allocator to an element. \end{note}
\end{itemize}

\rSec2[allocator.traits]{Allocator traits}

\pnum
The class template \tcode{allocator_traits} supplies a uniform interface to all
allocator types.
An allocator cannot be a non-class type, however, even if \tcode{allocator_traits}
supplies the entire required interface. \begin{note} Thus, it is always possible to create
a derived class from an allocator. \end{note}

\indexlibrary{\idxcode{allocator_traits}}%
\begin{codeblock}
namespace std {
  template<class Alloc> struct allocator_traits {
    using allocator_type     = Alloc;

    using value_type         = typename Alloc::value_type;

    using pointer            = @\seebelow@;
    using const_pointer      = @\seebelow@;
    using void_pointer       = @\seebelow@;
    using const_void_pointer = @\seebelow@;

    using difference_type    = @\seebelow@;
    using size_type          = @\seebelow@;

    using propagate_on_container_copy_assignment = @\seebelow@;
    using propagate_on_container_move_assignment = @\seebelow@;
    using propagate_on_container_swap            = @\seebelow@;
    using is_always_equal                        = @\seebelow@;

    template<class T> using rebind_alloc = @\seebelow@;
    template<class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;

    [[nodiscard]] static pointer allocate(Alloc& a, size_type n);
    [[nodiscard]] static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);

    static void deallocate(Alloc& a, pointer p, size_type n);

    template<class T, class... Args>
      static void construct(Alloc& a, T* p, Args&&... args);

    template<class T>
      static void destroy(Alloc& a, T* p);

    static size_type max_size(const Alloc& a) noexcept;

    static Alloc select_on_container_copy_construction(const Alloc& rhs);
  };
}
\end{codeblock}

\rSec3[allocator.traits.types]{Allocator traits member types}

\indexlibrarymember{pointer}{allocator_traits}%
\begin{itemdecl}
using pointer = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::pointer} if
the \grammarterm{qualified-id} \tcode{Alloc::pointer} is valid and denotes a
type\iref{temp.deduct}; otherwise, \tcode{value_type*}.
\end{itemdescr}

\indexlibrarymember{const_pointer}{allocator_traits}%
\begin{itemdecl}
using const_pointer = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::const_pointer} if
the \grammarterm{qualified-id} \tcode{Alloc::const_pointer} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{pointer_traits<pointer>::rebind<\brk{}const value_type>}.
\end{itemdescr}

\indexlibrarymember{void_pointer}{allocator_traits}%
\begin{itemdecl}
using void_pointer = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::void_pointer} if
the \grammarterm{qualified-id} \tcode{Alloc::void_pointer} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{pointer_traits<pointer>::rebind<\brk{}void>}.
\end{itemdescr}

\indexlibrarymember{const_void_pointer}{allocator_traits}%
\begin{itemdecl}
using const_void_pointer = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::const_void_pointer} if
the \grammarterm{qualified-id} \tcode{Alloc::const_void_pointer} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{pointer_traits<pointer>::\brk{}rebind<const void>}.
\end{itemdescr}

\indexlibrarymember{difference_type}{allocator_traits}%
\begin{itemdecl}
using difference_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::difference_type} if
the \grammarterm{qualified-id} \tcode{Alloc::difference_type} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{pointer_traits<pointer>::dif\-ference_type}.
\end{itemdescr}

\indexlibrarymember{size_type}{allocator_traits}%
\begin{itemdecl}
using size_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::size_type} if
the \grammarterm{qualified-id} \tcode{Alloc::size_type} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{make_unsigned_t<difference_type>}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_copy_assignment}{allocator_traits}%
\begin{itemdecl}
using propagate_on_container_copy_assignment = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_copy_assignment} if
the \grammarterm{qualified-id} \tcode{Alloc::propagate_on_container_copy_assignment} is valid and denotes a
type\iref{temp.deduct}; otherwise
\tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_move_assignment}{allocator_traits}%
\begin{itemdecl}
using propagate_on_container_move_assignment = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_move_assignment} if
the \grammarterm{qualified-id} \tcode{Alloc::propagate_on_container_move_assignment} is valid and denotes a
type\iref{temp.deduct}; otherwise
\tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_swap}{allocator_traits}%
\begin{itemdecl}
using propagate_on_container_swap = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::propagate_on_container_swap} if
the \grammarterm{qualified-id} \tcode{Alloc::propagate_on_container_swap} is valid and denotes a
type\iref{temp.deduct}; otherwise
\tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{is_always_equal}{allocator_traits}%
\begin{itemdecl}
using is_always_equal = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{Alloc::is_always_equal} if
the \grammarterm{qualified-id} \tcode{Alloc::is_always_equal}
is valid and denotes a type\iref{temp.deduct};
otherwise \tcode{is_empty<Alloc>::type}.
\end{itemdescr}

\indexlibrarymember{rebind_alloc}{allocator_traits}%
\begin{itemdecl}
template<class T> using rebind_alloc = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\templalias \tcode{Alloc::rebind<T>::other} if
the \grammarterm{qualified-id} \tcode{Alloc::rebind<T>::other} is valid and denotes a
type\iref{temp.deduct}; otherwise,
\tcode{Alloc<T, Args>} if \tcode{Alloc} is a class template instantiation
of the form \tcode{Alloc<U, Args>}, where \tcode{Args} is zero or more type arguments;
otherwise, the instantiation of \tcode{rebind_alloc} is ill-formed.
\end{itemdescr}

\rSec3[allocator.traits.members]{Allocator traits static member functions}

\indexlibrarymember{allocate}{allocator_traits}%
\begin{itemdecl}
[[nodiscard]] static pointer allocate(Alloc& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.allocate(n)}.
\end{itemdescr}

\indexlibrarymember{allocate}{allocator_traits}%
\begin{itemdecl}
[[nodiscard]] static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.allocate(n, hint)} if that expression is well-formed; otherwise, \tcode{a.allocate(n)}.
\end{itemdescr}

\indexlibrarymember{deallocate}{allocator_traits}%
\begin{itemdecl}
static void deallocate(Alloc& a, pointer p, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{a.deallocate(p, n)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{construct}{allocator_traits}%
\begin{itemdecl}
template<class T, class... Args>
  static void construct(Alloc& a, T* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{a.construct(p, std::forward<Args>(args)...)}
if that call is well-formed;
otherwise, invokes \tcode{::new (static_cast<void*>(p)) T(std::forward<Args>(args)...)}.
\end{itemdescr}

\indexlibrarymember{destroy}{allocator_traits}%
\begin{itemdecl}
template<class T>
  static void destroy(Alloc& a, T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{a.destroy(p)} if that call is well-formed; otherwise, invokes
\tcode{p->\~{}T()}.
\end{itemdescr}

\indexlibrarymember{max_size}{allocator_traits}%
\begin{itemdecl}
static size_type max_size(const Alloc& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.max_size()} if that expression is well-formed; otherwise,
\tcode{numeric_limits<size_type>::\brk{}max()/sizeof(value_type)}.
\end{itemdescr}

\indexlibrarymember{select_on_container_copy_construction}{allocator_traits}%
\begin{itemdecl}
static Alloc select_on_container_copy_construction(const Alloc& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.select_on_container_copy_construction()} if that expression is
well-formed; otherwise, \tcode{rhs}.
\end{itemdescr}

\rSec2[default.allocator]{The default allocator}

\pnum
All specializations of the default allocator satisfy the
allocator completeness requirements\iref{allocator.requirements.completeness}.

\indexlibrary{\idxcode{allocator}}%
\indexlibrarymember{value_type}{allocator}%
\indexlibrarymember{propagate_on_container_move_assignment}{allocator}%
\indexlibrarymember{is_always_equal}{allocator}%
\begin{codeblock}
namespace std {
  template<class T> class allocator {
   public:
    using value_type      = T;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal = true_type;

    constexpr allocator() noexcept;
    constexpr allocator(const allocator&) noexcept;
    template<class U> constexpr allocator(const allocator<U>&) noexcept;
    ~allocator();

    [[nodiscard]] T* allocate(size_t n);
    void deallocate(T* p, size_t n);
  };
}
\end{codeblock}

\rSec3[allocator.members]{\tcode{allocator} members}

\pnum
Except for the destructor, member functions of the default allocator shall not introduce
data races\iref{intro.multithread} as a result of concurrent calls to those member
functions from different threads. Calls to these functions that allocate or deallocate a
particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.

\indexlibrarymember{allocate}{allocator}%
\begin{itemdecl}
[[nodiscard]] T* allocate(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the initial element of an array of storage of size \tcode{n}
\tcode{* sizeof(T)}, aligned appropriately for objects of type \tcode{T}.

\pnum
\remarks
the storage is obtained by calling \tcode{::operator new}\iref{new.delete},
but it is unspecified when or how often this
function is called.

\pnum
\throws
\tcode{bad_alloc} if the storage cannot be obtained.
\end{itemdescr}

\indexlibrarymember{deallocate}{allocator}%
\begin{itemdecl}
void deallocate(T* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} shall be a pointer value obtained from \tcode{allocate()}.
\tcode{n} shall equal the value passed as the first argument
to the invocation of allocate which returned \tcode{p}.

\pnum
\effects
Deallocates the storage referenced by \tcode{p} .

\pnum
\remarks
Uses
\tcode{::operator delete}\iref{new.delete},
but it is unspecified
when this function is called.
\end{itemdescr}

\rSec3[allocator.globals]{\tcode{allocator} globals}

\indexlibrarymember{operator==}{allocator}%
\begin{itemdecl}
template<class T, class U>
  bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{allocator}%
\begin{itemdecl}
template<class T, class U>
  bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false}.
\end{itemdescr}

\rSec2[specialized.algorithms]{Specialized algorithms}

\pnum
Throughout this subclause,
the names of template parameters are used to express type requirements.
\begin{itemize}
\item
If an algorithm's template parameter is named \tcode{InputIterator},
the template argument shall satisfy the requirements
of an input iterator\iref{input.iterators}.
\item
If an algorithm's template parameter is named \tcode{ForwardIterator},
the template argument shall satisfy the requirements
of a forward iterator\iref{forward.iterators}, and
is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
\end{itemize}
Unless otherwise specified,
if an exception is thrown in the following algorithms there are no effects.

\rSec3[specialized.addressof]{\tcode{addressof}}

\indexlibrary{\idxcode{addressof}}%
\begin{itemdecl}
template<class T> constexpr T* addressof(T& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The actual address of the object or function referenced by \tcode{r}, even in the
presence of an overloaded \tcode{operator\&}.

\pnum
\remarks An expression \tcode{addressof(E)}
is a constant subexpression\iref{defns.const.subexpr}
if \tcode{E} is an lvalue constant subexpression.
\end{itemdescr}

\rSec3[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}

\indexlibrary{\idxcode{uninitialized_default_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_default_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type;
return first;
\end{codeblock}
\end{itemdescr}

\rSec3[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}

\indexlibrary{\idxcode{uninitialized_value_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type();
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_value_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type();
return first;
\end{codeblock}
\end{itemdescr}

\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for (; first != last; ++result, (void) ++first)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for ( ; n > 0; ++result, (void) ++first, --n) {
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(*first);
}
\end{codeblock}

\pnum
\returns \tcode{result}.
\end{itemdescr}

\rSec3[uninitialized.move]{\tcode{uninitialized_move}}

\indexlibrary{\idxcode{uninitialized_move}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; (void)++result, ++first)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return result;
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range \range{first}{last}
are left in a valid but unspecified state.
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_move_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; ++result, (void) ++first, --n)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return {first,result};
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range \range{first}{std::next(first,n)}
are left in a valid but unspecified state.
\end{itemdescr}

\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for (; n--; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type(x);
return first;
\end{codeblock}
\end{itemdescr}

\rSec3[specialized.destroy]{\tcode{destroy}}

\indexlibrary{\idxcode{destroy_at}}%
\begin{itemdecl}
template<class T>
  void destroy_at(T* location);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
location->~T();
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{destroy}}%
\begin{itemdecl}
template<class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first!=last; ++first)
  destroy_at(addressof(*first));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{destroy_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}

\rSec2[c.malloc]{C library memory allocation}

\pnum
\indexhdr{cstdlib}%
\begin{note}
The header \tcode{<cstdlib>}\iref{cstdlib.syn}
declares the functions described in this subclause.
\end{note}

\indexlibrary{\idxcode{aligned_alloc}}%
\indexlibrary{\idxcode{calloc}}%
\indexlibrary{\idxcode{malloc}}%
\indexlibrary{\idxcode{realloc}}%
\begin{itemdecl}
void* aligned_alloc(size_t alignment, size_t size);
void* calloc(size_t nmemb, size_t size);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
These functions have the semantics specified in the C standard library.

\pnum
\remarks
These functions do not attempt to allocate
storage by calling \tcode{::operator new()}\iref{support.dynamic}.
\indexlibrary{\idxcode{new}!\idxcode{operator}}%

\pnum
Storage allocated directly with these functions
is implicitly declared reachable
(see~\ref{basic.stc.dynamic.safety}) on allocation, ceases to be declared
reachable on deallocation, and need not cease to be declared reachable as the
result of an \tcode{undeclare_reachable()} call. \begin{note} This allows existing
C libraries to remain unaffected by restrictions on pointers that are not safely
derived, at the expense of providing far fewer garbage collection and leak
detection options for \tcode{malloc()}-allocated objects. It also allows
\tcode{malloc()} to be implemented with a separate allocation arena, bypassing
the normal \tcode{declare_reachable()} implementation. The above functions
should never intentionally be used as a replacement for
\tcode{declare_reachable()}, and newly written code is strongly encouraged to
treat memory allocated with these functions as though it were allocated with
\tcode{operator new}. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{free}}%
\begin{itemdecl}
void free(void* ptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
This function has the semantics specified in the C standard library.

\pnum
\remarks
This function does not attempt to
deallocate storage by calling
\tcode{::operator delete()}\indexlibrary{\idxcode{delete}!\idxcode{operator}}.
\end{itemdescr}

\xrefc{7.22.3}

\rSec1[smartptr]{Smart pointers}

\rSec2[unique.ptr]{Class template \tcode{unique_ptr}}

\pnum
A \defn{unique pointer} is an object that owns another object and
manages that other object through a pointer. More precisely, a unique pointer
is an object \textit{u} that stores a pointer to a second object \textit{p} and
will dispose of \textit{p} when \textit{u} is itself destroyed (e.g., when
leaving block scope\iref{stmt.dcl}). In this context, \textit{u} is said
to \defn{own} \tcode{p}.

\pnum
The mechanism by which \textit{u} disposes of \textit{p} is known as
\textit{p}'s associated \defn{deleter}, a function object whose correct
invocation results in \textit{p}'s appropriate disposition (typically its deletion).

\pnum
Let the notation \textit{u.p} denote the pointer stored by \textit{u}, and
let \textit{u.d} denote the associated deleter. Upon request, \textit{u} can
\defn{reset} (replace) \textit{u.p} and \textit{u.d} with another pointer and
deleter, but properly disposes of its owned object via the associated
deleter before such replacement is considered completed.

\pnum
Each object of a type \tcode{U} instantiated from the \tcode{unique_ptr} template
specified in this subclause has the strict ownership semantics, specified above,
of a unique pointer. In partial satisfaction of these semantics, each such \tcode{U}
is \tcode{MoveConstructible} and \tcode{MoveAssignable}, but is not
\tcode{CopyConstructible} nor \tcode{CopyAssignable}.
The template parameter \tcode{T} of \tcode{unique_ptr} may be an incomplete type.

\pnum
\begin{note} The uses
of \tcode{unique_ptr} include providing exception safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. \end{note}

\rSec3[unique.ptr.dltr]{Default deleters}

\rSec4[unique.ptr.dltr.general]{In general}

\pnum
The class template \tcode{default_delete} serves as the default deleter (destruction policy)
for the class template \tcode{unique_ptr}.

\pnum
The template parameter \tcode{T} of \tcode{default_delete} may be
an incomplete type.

\rSec4[unique.ptr.dltr.dflt]{\tcode{default_delete}}

\begin{codeblock}
namespace std {
  template<class T> struct default_delete {
    constexpr default_delete() noexcept = default;
    template<class U> default_delete(const default_delete<U>&) noexcept;
    void operator()(T*) const;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{default_delete}!constructor}%
\begin{itemdecl}
template<class U> default_delete(const default_delete<U>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{default_delete} object
from another \tcode{default_delete<U>} object.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{U*} is implicitly convertible to \tcode{T*}.
\end{itemdescr}

\indexlibrarymember{operator()}{default_delete}%
\begin{itemdecl}
void operator()(T* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{delete} on \tcode{ptr}.

\pnum
\remarks If \tcode{T} is an incomplete type, the program is ill-formed.
\end{itemdescr}

\rSec4[unique.ptr.dltr.dflt1]{\tcode{default_delete<T[]>}}

\begin{codeblock}
namespace std {
  template<class T> struct default_delete<T[]> {
    constexpr default_delete() noexcept = default;
    template<class U> default_delete(const default_delete<U[]>&) noexcept;
    template<class U> void operator()(U* ptr) const;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{default_delete}!constructor}
\begin{itemdecl}
template<class U> default_delete(const default_delete<U[]>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{default_delete} object from another \tcode{default_delete<U[]>} object.

\pnum
\remarks
This constructor shall not participate in overload resolution unless \tcode{U(*)[]} is
convertible to \tcode{T(*)[]}.
\end{itemdescr}

\indexlibrarymember{operator()}{default_delete}%
\begin{itemdecl}
template<class U> void operator()(U* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{delete[]} on \tcode{ptr}.

\pnum
\remarks If \tcode{U} is an incomplete type, the program is ill-formed.
This function shall not participate in overload resolution
unless \tcode{U(*)[]} is convertible to \tcode{T(*)[]}.
\end{itemdescr}

\rSec3[unique.ptr.single]{\tcode{unique_ptr} for single objects}

\indexlibrary{\idxcode{unique_ptr}}%
\begin{codeblock}
namespace std {
  template<class T, class D = default_delete<T>> class unique_ptr {
  public:
    using pointer      = @\seebelow@;
    using element_type = T;
    using deleter_type = D;

    // \ref{unique.ptr.single.ctor}, constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, @\seebelow@ d1) noexcept;
    unique_ptr(pointer p, @\seebelow@ d2) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
    template<class U, class E>
      unique_ptr(unique_ptr<U, E>&& u) noexcept;

    // \ref{unique.ptr.single.dtor}, destructor
    ~unique_ptr();

    // \ref{unique.ptr.single.asgn}, assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template<class U, class E>
      unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.single.observers}, observers
    add_lvalue_reference_t<T> operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.single.modifiers}, modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
The default type for the template parameter \tcode{D} is
\tcode{default_delete}. A client-supplied template argument
\tcode{D} shall be a function
object type\iref{function.objects}, lvalue reference to function, or
lvalue reference to function object type
for which, given
a value \tcode{d} of type \tcode{D} and a value
\tcode{ptr} of type \tcode{unique_ptr<T, D>::pointer}, the expression
\tcode{d(ptr)} is valid and has the effect of disposing of the
pointer as appropriate for that deleter.

\pnum
If the deleter's type \tcode{D} is not a reference type, \tcode{D} shall satisfy
the \tcode{Destructible} requirements (\tref{destructible}).

\pnum
If the \grammarterm{qualified-id} \tcode{remove_reference_t<D>::pointer} is valid and denotes a
type\iref{temp.deduct}, then \tcode{unique_ptr<T,
D>::pointer} shall be a synonym for \tcode{remove_reference_t<D>::pointer}. Otherwise
\tcode{unique_ptr<T, D>::pointer} shall be a synonym for \tcode{element_type*}. The type \tcode{unique_ptr<T,
D>::pointer} shall
satisfy the \tcode{NullablePointer} requirements (\tref{nullablepointer}).

\pnum
\begin{example} Given an allocator type \tcode{X} (\tref{utilities.allocator.requirements}) and
letting \tcode{A} be a synonym for \tcode{allocator_traits<X>}, the types \tcode{A::pointer},
\tcode{A::const_pointer}, \tcode{A::void_pointer}, and \tcode{A::const_void_pointer}
may be used as \tcode{unique_ptr<T, D>::pointer}. \end{example}

\rSec4[unique.ptr.single.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
constexpr unique_ptr() noexcept;
constexpr unique_ptr(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the \tcode{DefaultConstructible} requirements (\tref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} object that owns
nothing, value-initializing the stored pointer and the stored deleter.

\pnum
\postconditions \tcode{get() == nullptr}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\remarks If \tcode{is_pointer_v<deleter_type>} is \tcode{true} or
\tcode{is_default_constructible_v<deleter_type>} is \tcode{false},
this constructor shall not participate in overload resolution.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
explicit unique_ptr(pointer p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the \tcode{DefaultConstructible} requirements (\tref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} which owns
\tcode{p}, initializing the stored pointer with \tcode{p} and
value-initializing the stored deleter.

\pnum
\postconditions \tcode{get() == p}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\remarks If \tcode{is_pointer_v<deleter_type>} is \tcode{true} or
\tcode{is_default_constructible_v<deleter_type>} is \tcode{false},
this constructor shall not participate in overload resolution.
If class template argument deduction\iref{over.match.class.deduct}
would select the function template corresponding to this constructor,
then the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
unique_ptr(pointer p, @\seebelow@ d1) noexcept;
unique_ptr(pointer p, @\seebelow@ d2) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The signature of these constructors depends upon whether \tcode{D}
is a reference type. If \tcode{D} is a non-reference type
\tcode{A}, then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d) noexcept;
unique_ptr(pointer p, A&& d) noexcept;
\end{codeblock}

\pnum
If \tcode{D} is an lvalue reference type \tcode{A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, A& d) noexcept;
unique_ptr(pointer p, A&& d) = delete;
\end{codeblock}

\pnum
If \tcode{D} is an lvalue reference type \tcode{const A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d) noexcept;
unique_ptr(pointer p, const A&& d) = delete;
\end{codeblock}

\pnum
\requires For the first constructor, if \tcode{D} is not a reference type,
\tcode{D} shall satisfy the \tcode{CopyConstructible} requirements and
such construction shall not exit via an exception.
For the second constructor, if \tcode{D} is not a reference type,
\tcode{D} shall satisfy the \tcode{MoveConstructible} requirements and
such construction shall not exit via an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} object which owns \tcode{p}, initializing
the stored pointer with \tcode{p} and initializing the deleter
from \tcode{std::forward<decltype(d)>(d)}.

\pnum
\remarks These constructors shall not participate in overload resolution
unless \tcode{is_constructible_v<D, decltype(d)>} is \tcode{true}.

\pnum
\postconditions \tcode{get() == p}.
\tcode{get_deleter()} returns a reference to the stored
deleter. If \tcode{D} is a reference type then \tcode{get_deleter()}
returns a reference to the lvalue \tcode{d}.

\pnum
\remarks If class template argument deduction\iref{over.match.class.deduct}
would select a function template corresponding to either of these constructors,
then the program is ill-formed.

\pnum
\begin{example}
\begin{codeblock}
D d;
unique_ptr<int, D> p1(new int, D());        // \tcode{D} must be \tcode{MoveConstructible}
unique_ptr<int, D> p2(new int, d);          // \tcode{D} must be \tcode{CopyConstructible}
unique_ptr<int, D&> p3(new int, d);         // \tcode{p3} holds a reference to \tcode{d}
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined
                                            // with reference deleter type
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
unique_ptr(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type,
\tcode{D} shall satisfy the \tcode{MoveConstructible}
requirements (\tref{moveconstructible}).
Construction
of the deleter from an rvalue of type \tcode{D} shall not
throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} from
\tcode{u}. If \tcode{D} is a reference type, this
deleter is copy constructed from \tcode{u}'s deleter; otherwise, this
deleter is move constructed from \tcode{u}'s deleter. \begin{note} The
construction of the deleter can be implemented with \tcode{std::forward<D>}. \end{note}

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction. \tcode{u.get() == nullptr}.
\tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}. If \tcode{D} is a reference type then
\tcode{get_deleter()} and \tcode{u.get_deleter()} both reference
the same lvalue deleter.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template<class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type,
construction of the deleter from an rvalue of type
\tcode{E} shall be well-formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and construction of the deleter from an
lvalue of type \tcode{E} shall be well-formed and shall not throw an exception.

\pnum
\remarks This constructor shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer},
\item \tcode{U} is not an array type, and
\item either \tcode{D} is a reference type and \tcode{E} is the same type as \tcode{D}, or
\tcode{D} is not a reference type and \tcode{E} is implicitly convertible to \tcode{D}.
\end{itemize}

\pnum
\effects Constructs a \tcode{unique_ptr} from \tcode{u}.
If \tcode{E} is a reference type, this deleter is copy constructed from
\tcode{u}'s deleter; otherwise, this deleter is move constructed from \tcode{u}'s
deleter. \begin{note} The deleter constructor can be implemented with
\tcode{std::forward<E>}. \end{note}

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction. \tcode{u.get() == nullptr}.
\tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}.
\end{itemdescr}

\rSec4[unique.ptr.single.dtor]{\tcode{unique_ptr} destructor}

\indexlibrary{\idxcode{unique_ptr}!destructor}%
\begin{itemdecl}
~unique_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well-formed,
shall have well-defined behavior, and shall not throw exceptions. \begin{note} The
use of \tcode{default_delete} requires \tcode{T} to be a complete type.
\end{note}

\pnum
\effects If \tcode{get() == nullptr} there are no effects.
Otherwise \tcode{get_deleter()(get())}.
\end{itemdescr}

\rSec4[unique.ptr.single.asgn]{\tcode{unique_ptr} assignment}

\indexlibrarymember{operator=}{unique_ptr}%
\begin{itemdecl}
unique_ptr& operator=(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type, \tcode{D} shall satisfy the
\tcode{MoveAssignable} requirements (\tref{moveassignable}) and assignment
of the deleter from an rvalue of type \tcode{D} shall not throw an exception.
Otherwise, \tcode{D} is a reference type;
\tcode{remove_reference_t<D>} shall satisfy the \tcode{CopyAssignable}
requirements and assignment of the deleter from an
lvalue of type \tcode{D} shall not throw an exception.

\pnum
\effects Calls \tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<D>(u.get_dele\-ter())}.

\pnum
\returns \tcode{*this}.

\pnum
\postconditions \tcode{u.get() == nullptr}.
\end{itemdescr}

\indexlibrarymember{operator=}{unique_ptr}%
\begin{itemdecl}
template<class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type, assignment of the deleter from
an rvalue of type \tcode{E} shall be well-formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and assignment of the deleter from an lvalue
of type \tcode{E} shall be well-formed and shall not throw an exception.

\pnum
\remarks This operator shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer}, and
\item \tcode{U} is not an array type, and
\item \tcode{is_assignable_v<D\&, E\&\&>} is \tcode{true}.
\end{itemize}

\pnum
\effects Calls \tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<E>(u.get_dele\-ter())}.

\pnum
\returns \tcode{*this}.

\pnum
\postconditions \tcode{u.get() == nullptr}.
\end{itemdescr}

\indexlibrarymember{operator=}{unique_ptr}%
\begin{itemdecl}
unique_ptr& operator=(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{reset()}.

\pnum
\postconditions \tcode{get() == nullptr}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[unique.ptr.single.observers]{\tcode{unique_ptr} observers}

\indexlibrarymember{operator*}{unique_ptr}%
\begin{itemdecl}
add_lvalue_reference_t<T> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{*get()}.

\end{itemdescr}

\indexlibrarymember{operator->}{unique_ptr}%
\begin{itemdecl}
pointer operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{get()}.

\pnum
\begin{note}
The use of this function typically requires that \tcode{T} be a complete type.
\end{note}
\end{itemdescr}

\indexlibrarymember{get}{unique_ptr}%
\begin{itemdecl}
pointer get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored pointer.
\end{itemdescr}

\indexlibrarymember{get_deleter}{unique_ptr}%
\begin{itemdecl}
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A reference to the stored deleter.
\end{itemdescr}

\indexlibrarymember{operator bool}{unique_ptr}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get() != nullptr}.
\end{itemdescr}

\rSec4[unique.ptr.single.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrarymember{release}{unique_ptr}%
\begin{itemdecl}
pointer release() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{get() == nullptr}.

\pnum
\returns The value \tcode{get()} had at the start of
the call to \tcode{release}.
\end{itemdescr}

\indexlibrarymember{reset}{unique_ptr}%
\begin{itemdecl}
void reset(pointer p = pointer()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well-formed, shall have
well-defined behavior, and shall not throw exceptions.

\pnum
\effects Assigns \tcode{p} to the stored pointer, and then if and only if the old value of the
stored pointer, \tcode{old_p}, was not equal to \tcode{nullptr}, calls
\tcode{get_deleter()(old_p)}. \begin{note} The order of these operations is significant
because the call to \tcode{get_deleter()} may destroy \tcode{*this}. \end{note}

\pnum
\postconditions \tcode{get() == p}.
\begin{note} The postcondition does not hold if the call to \tcode{get_deleter()}
destroys \tcode{*this} since \tcode{this->get()} is no longer a valid expression.
\end{note}
\end{itemdescr}

\indexlibrarymember{swap}{unique_ptr}%
\begin{itemdecl}
void swap(unique_ptr& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get_deleter()} shall be
swappable\iref{swappable.requirements} and shall
not throw an exception
under \tcode{swap}.

\pnum
\effects Invokes \tcode{swap} on the stored pointers and on the stored
deleters of \tcode{*this} and \tcode{u}.
\end{itemdescr}

\rSec3[unique.ptr.runtime]{\tcode{unique_ptr} for array objects with a runtime length}

\indexlibrary{\idxcode{unique_ptr}}%
\begin{codeblock}
namespace std {
  template<class T, class D> class unique_ptr<T[], D> {
  public:
    using pointer      = @\seebelow@;
    using element_type = T;
    using deleter_type = D;

    // \ref{unique.ptr.runtime.ctor}, constructors
    constexpr unique_ptr() noexcept;
    template<class U> explicit unique_ptr(U p) noexcept;
    template<class U> unique_ptr(U p, @\seebelow@ d) noexcept;
    template<class U> unique_ptr(U p, @\seebelow@ d) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    template<class U, class E>
      unique_ptr(unique_ptr<U, E>&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template<class U, class E>
      unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.runtime.observers}, observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.runtime.modifiers}, modifiers
    pointer release() noexcept;
    template<class U> void reset(U p) noexcept;
    void reset(nullptr_t = nullptr) noexcept;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
A specialization for array types is provided with a slightly altered
interface.

\begin{itemize}
\item Conversions between different types of
\tcode{unique_ptr<T[], D>}
that would be disallowed for the corresponding pointer-to-array types,
and conversions to or from the non-array forms of
\tcode{unique_ptr}, produce an ill-formed program.

\item Pointers to types derived from \tcode{T} are
rejected by the constructors, and by \tcode{reset}.

\item The observers \tcode{operator*} and
\tcode{operator->} are not provided.

\item The indexing observer \tcode{operator[]} is provided.

\item The default deleter will call \tcode{delete[]}.
\end{itemize}

\pnum
Descriptions are provided below only for members that
differ from the primary template.

\pnum
The template argument \tcode{T} shall be a complete type.

\rSec4[unique.ptr.runtime.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template<class U> explicit unique_ptr(U p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor behaves the same as
the constructor in the primary template that
takes a single parameter of type \tcode{pointer}
except that it additionally
shall not participate in overload resolution unless

\begin{itemize}
\item \tcode{U} is the same type as \tcode{pointer}, or
\item \tcode{pointer} is the same type as \tcode{element_type*},
\tcode{U} is a pointer type \tcode{V*}, and
\tcode{V(*)[]} is convertible to \tcode{element_type(*)[]}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template<class U> unique_ptr(U p, @\seebelow@ d) noexcept;
template<class U> unique_ptr(U p, @\seebelow@ d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
These constructors behave the same as
the constructors in the primary template that
take a parameter of type \tcode{pointer} and a second parameter
except that they
shall not participate in overload resolution unless either

\begin{itemize}
\item \tcode{U} is the same type as \tcode{pointer},
\item \tcode{U} is \tcode{nullptr_t}, or
\item \tcode{pointer} is the same type as \tcode{element_type*},
      \tcode{U} is a pointer type \tcode{V*}, and
      \tcode{V(*)[]} is convertible to \tcode{element_type(*)[]}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template<class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor behaves the same as in the primary template,
except that it shall not participate in overload resolution
unless all of the following conditions hold,
where \tcode{UP} is \tcode{unique_ptr<U, E>}:

\begin{itemize}
\item \tcode{U} is an array type, and
\item \tcode{pointer} is the same type as \tcode{element_type*}, and
\item \tcode{UP::pointer} is the same type as \tcode{UP::element_type*}, and
\item \tcode{UP::element_type(*)[]} is convertible to \tcode{element_type(*)[]}, and
\item either \tcode{D} is a reference type and \tcode{E} is the same type as \tcode{D},
      or \tcode{D} is not a reference type and \tcode{E} is implicitly convertible to \tcode{D}.
\end{itemize}

\begin{note}
This replaces the overload-resolution specification of the primary template
\end{note}
\end{itemdescr}

\rSec4[unique.ptr.runtime.asgn]{\tcode{unique_ptr} assignment}

\indexlibrarymember{operator=}{unique_ptr}%
\begin{itemdecl}
template<class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u)noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
This operator behaves the same as in the primary template,
except that it shall not participate in overload resolution
unless all of the following conditions hold,
where \tcode{UP} is \tcode{unique_ptr<U, E>}:

\begin{itemize}
\item \tcode{U} is an array type, and
\item \tcode{pointer} is the same type as \tcode{element_type*}, and
\item \tcode{UP::pointer} is the same type as \tcode{UP::element_type*}, and
\item \tcode{UP::element_type(*)[]} is convertible to \tcode{element_type(*)[]}, and
\item \tcode{is_assignable_v<D\&, E\&\&>} is \tcode{true}.
\end{itemize}

\begin{note}
This replaces the overload-resolution specification of the primary template
\end{note}
\end{itemdescr}

\rSec4[unique.ptr.runtime.observers]{\tcode{unique_ptr} observers}

\indexlibrarymember{operator[]}{unique_ptr}%
\begin{itemdecl}
T& operator[](size_t i) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{i <} the
number of elements in the array to which
the stored pointer points.

\pnum
\returns \tcode{get()[i]}.
\end{itemdescr}

\rSec4[unique.ptr.runtime.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrarymember{reset}{unique_ptr}%
\begin{itemdecl}
void reset(nullptr_t p = nullptr) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{reset(pointer())}.
\end{itemdescr}

\indexlibrarymember{reset}{unique_ptr}%
\begin{itemdecl}
template<class U> void reset(U p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function behaves the same as
the \tcode{reset} member of the primary template,
except that it shall not participate in overload resolution
unless either

\begin{itemize}
\item \tcode{U} is the same type as \tcode{pointer}, or
\item \tcode{pointer} is the same type as \tcode{element_type*},
      \tcode{U} is a pointer type \tcode{V*}, and
      \tcode{V(*)[]} is convertible to \tcode{element_type(*)[]}.
\end{itemize}
\end{itemdescr}

\rSec3[unique.ptr.create]{\tcode{unique_ptr} creation}

\indexlibrary{\idxcode{make_unique}}%
\begin{itemdecl}
template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is not an array.

\pnum
\returns \tcode{unique_ptr<T>(new T(std::forward<Args>(args)...))}.

\end{itemdescr}

\indexlibrary{\idxcode{make_unique}}%
\begin{itemdecl}
template<class T> unique_ptr<T> make_unique(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of unknown bound.

\pnum
\returns \tcode{unique_ptr<T>(new remove_extent_t<T>[n]())}.

\end{itemdescr}

\indexlibrary{\idxcode{make_unique}}%
\begin{itemdecl}
template<class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of known bound.

\end{itemdescr}

\rSec3[unique.ptr.special]{\tcode{unique_ptr} specialized algorithms}

\indexlibrary{\idxcode{swap(unique_ptr\&, unique_ptr\&)}}%
\begin{itemdecl}
template<class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{is_swappable_v<D>} is \tcode{true}.

\pnum
\effects Calls \tcode{x.swap(y)}.
\end{itemdescr}

\indexlibrarymember{operator==}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() == y.get()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() != y.get()}.
\end{itemdescr}

\indexlibrarymember{operator<}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires Let \tcode{CT} denote
\begin{codeblock}
common_type_t<typename unique_ptr<T1, D1>::pointer,
              typename unique_ptr<T2, D2>::pointer>
\end{codeblock}
Then the specialization
\tcode{less<CT>} shall be a function object type\iref{function.objects} that
induces a strict weak ordering\iref{alg.sorting} on the pointer values.

\pnum
\returns \tcode{less<CT>()(x.get(), y.get())}.

\pnum
\remarks If \tcode{unique_ptr<T1, D1>::pointer} is not implicitly convertible
to \tcode{CT} or \tcode{unique_ptr<T2, D2>::pointer} is not implicitly
convertible to \tcode{CT}, the program is ill-formed.
\end{itemdescr}

\indexlibrarymember{operator>}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrarymember{operator<=}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{unique_ptr}%
\begin{itemdecl}
template<class T1, class D1, class T2, class D2>
  bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\indexlibrarymember{operator==}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template<class T, class D>
  bool operator==(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!x}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template<class T, class D>
  bool operator!=(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(bool)x}.
\end{itemdescr}

\indexlibrarymember{operator<}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
  bool operator<(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The specialization \tcode{less<unique_ptr<T, D>::pointer>} shall be
a function object type\iref{function.objects} that induces a strict weak
ordering\iref{alg.sorting} on the pointer values.

\pnum
\returns
The first function template returns
\begin{codeblock}
less<unique_ptr<T, D>::pointer>()(x.get(), nullptr)
\end{codeblock}
The second function template returns
\begin{codeblock}
less<unique_ptr<T, D>::pointer>()(nullptr, x.get())
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator>}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
  bool operator>(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{nullptr < x}.
The second function template returns \tcode{x < nullptr}.
\end{itemdescr}

\indexlibrarymember{operator<=}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
  bool operator<=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(nullptr < x)}.
The second function template returns \tcode{!(x < nullptr)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{unique_ptr}%
\begin{itemdecl}
template<class T, class D>
  bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
  bool operator>=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(x < nullptr)}.
The second function template returns \tcode{!(nullptr < x)}.
\end{itemdescr}

\rSec3[unique.ptr.io]{\tcode{unique_ptr} I/O}

\indexlibrarymember{operator<<}{unique_ptr}%
\begin{itemdecl}
template<class E, class T, class Y, class D>
  basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const unique_ptr<Y, D>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{os << p.get();}

\pnum
\returns \tcode{os}.

\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{os << p.get()} is a valid expression.
\end{itemdescr}

\indextext{smart pointers|(}%
\rSec2[util.smartptr.weak.bad]{Class \tcode{bad_weak_ptr}}
\indexlibrary{\idxcode{bad_weak_ptr}}%
\begin{codeblock}
namespace std {
  class bad_weak_ptr : public exception {
  public:
    bad_weak_ptr() noexcept;
  };
}
\end{codeblock}

\pnum
An exception of type \tcode{bad_weak_ptr} is thrown by the \tcode{shared_ptr}
constructor taking a \tcode{weak_ptr}.

\indexlibrary{\idxcode{bad_weak_ptr}!constructor}%
\indexlibrarymember{what}{bad_weak_ptr}%
\begin{itemdecl}
bad_weak_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions  \tcode{what()} returns an
\impldef{return value of \tcode{bad_weak_ptr::what}} \ntbs{}.

\end{itemdescr}

\rSec2[util.smartptr.shared]{Class template \tcode{shared_ptr}}

\pnum
\indexlibrary{\idxcode{shared_ptr}}%
The \tcode{shared_ptr} class template stores a pointer, usually obtained
via \tcode{new}. \tcode{shared_ptr} implements semantics of shared ownership;
the last remaining owner of the pointer is responsible for destroying
the object, or otherwise releasing the resources associated with the stored pointer. A
\tcode{shared_ptr} is said to be empty if it does not own a pointer.

\begin{codeblock}
namespace std {
  template<class T> class shared_ptr {
  public:
    using element_type = remove_extent_t<T>;
    using weak_type    = weak_ptr<T>;

    // \ref{util.smartptr.shared.const}, constructors
    constexpr shared_ptr() noexcept;
    constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
    template<class Y>
      explicit shared_ptr(Y* p);
    template<class Y, class D>
      shared_ptr(Y* p, D d);
    template<class Y, class D, class A>
      shared_ptr(Y* p, D d, A a);
    template<class D>
      shared_ptr(nullptr_t p, D d);
    template<class D, class A>
      shared_ptr(nullptr_t p, D d, A a);
    template<class Y>
      shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
    shared_ptr(const shared_ptr& r) noexcept;
    template<class Y>
      shared_ptr(const shared_ptr<Y>& r) noexcept;
    shared_ptr(shared_ptr&& r) noexcept;
    template<class Y>
      shared_ptr(shared_ptr<Y>&& r) noexcept;
    template<class Y>
      explicit shared_ptr(const weak_ptr<Y>& r);
    template<class Y, class D>
      shared_ptr(unique_ptr<Y, D>&& r);

    // \ref{util.smartptr.shared.dest}, destructor
    ~shared_ptr();

    // \ref{util.smartptr.shared.assign}, assignment
    shared_ptr& operator=(const shared_ptr& r) noexcept;
    template<class Y>
      shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
    shared_ptr& operator=(shared_ptr&& r) noexcept;
    template<class Y>
      shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
    template<class Y, class D>
      shared_ptr& operator=(unique_ptr<Y, D>&& r);

    // \ref{util.smartptr.shared.mod}, modifiers
    void swap(shared_ptr& r) noexcept;
    void reset() noexcept;
    template<class Y>
      void reset(Y* p);
    template<class Y, class D>
      void reset(Y* p, D d);
    template<class Y, class D, class A>
      void reset(Y* p, D d, A a);

    // \ref{util.smartptr.shared.obs}, observers
    element_type* get() const noexcept;
    T& operator*() const noexcept;
    T* operator->() const noexcept;
    element_type& operator[](ptrdiff_t i) const;
    long use_count() const noexcept;
    explicit operator bool() const noexcept;
    template<class U>
      bool owner_before(const shared_ptr<U>& b) const noexcept;
    template<class U>
      bool owner_before(const weak_ptr<U>& b) const noexcept;
  };

  template<class T>
    shared_ptr(weak_ptr<T>) -> shared_ptr<T>;
  template<class T, class D>
    shared_ptr(unique_ptr<T, D>) -> shared_ptr<T>;
}
\end{codeblock}

\pnum
Specializations of \tcode{shared_ptr} shall be \tcode{CopyConstructible},
\tcode{CopyAssignable}, and \tcode{LessThanComparable}, allowing their use in standard
containers. Specializations of \tcode{shared_ptr} shall be
contextually convertible to \tcode{bool},
allowing their use in boolean expressions and declarations in conditions. The template
parameter \tcode{T} of \tcode{shared_ptr} may be an incomplete type.

\pnum
\begin{example}
\begin{codeblock}
if (shared_ptr<X> px = dynamic_pointer_cast<X>(py)) {
  // do something with \tcode{px}
}
\end{codeblock}
\end{example}

\pnum
For purposes of determining the presence of a data race, member functions shall
access and modify only the \tcode{shared_ptr} and \tcode{weak_ptr} objects
themselves and not objects they refer to. Changes in \tcode{use_count()} do not
reflect modifications that can introduce data races.

\pnum
For the purposes of subclause \ref{smartptr},
a pointer type \tcode{Y*} is said to be
\defnx{compatible with}{compatible with!\idxcode{shared_ptr}}
a pointer type \tcode{T*} when either
\tcode{Y*} is convertible to \tcode{T*} or
\tcode{Y} is \tcode{U[N]} and \tcode{T} is \cv{}~\tcode{U[]}.

\rSec3[util.smartptr.shared.const]{\tcode{shared_ptr} constructors}

\pnum
In the constructor definitions below,
enables \tcode{shared_from_this} with \tcode{p},
for a pointer \tcode{p} of type \tcode{Y*},
means that if \tcode{Y} has an unambiguous and accessible base class
that is a specialization of \tcode{enable_shared_from_this}\iref{util.smartptr.enab},
then \tcode{remove_cv_t<Y>*} shall be implicitly convertible to \tcode{T*} and
the constructor evaluates the statement:
\begin{codeblock}
if (p != nullptr && p->weak_this.expired())
  p->weak_this = shared_ptr<remove_cv_t<Y>>(*this, const_cast<remove_cv_t<Y>*>(p));
\end{codeblock}
The assignment to the \tcode{weak_this} member is not atomic and
conflicts with any potentially concurrent access to the same object\iref{intro.multithread}.

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
constexpr shared_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs an empty \tcode{shared_ptr} object.

\pnum\postconditions  \tcode{use_count() == 0 \&\& get() == nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y> explicit shared_ptr(Y* p);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires \tcode{Y} shall be a complete type. The expression
\tcode{delete[] p}, when \tcode{T} is an array type, or
\tcode{delete p}, when \tcode{T} is not an array type,
shall have well-defined behavior, and
shall not throw exceptions.

\pnum\effects When \tcode{T} is not an array type,
constructs a \tcode{shared_ptr} object
that owns the pointer \tcode{p}.
Otherwise, constructs a \tcode{shared_ptr}
that owns \tcode{p} and a deleter of an
unspecified type that calls \tcode{delete[] p}.
When \tcode{T} is not an array type,
enables \tcode{shared_from_this} with \tcode{p}.
If an exception is thrown, \tcode{delete p} is called
when \tcode{T} is not an array type, \tcode{delete[] p} otherwise.

\pnum\postconditions  \tcode{use_count() == 1 \&\& get() == p}.

\pnum\throws \tcode{bad_alloc}, or an \impldef{exception type when \tcode{shared_ptr}
constructor fails} exception when a resource other than memory could not be obtained.

\pnum\remarks When \tcode{T} is an array type,
this constructor shall not participate in overload resolution unless
the expression \tcode{delete[] p} is well-formed and either
\tcode{T} is \tcode{U[N]} and \tcode{Y(*)[N]} is convertible to \tcode{T*}, or
\tcode{T} is \tcode{U[]} and \tcode{Y(*)[]} is convertible to \tcode{T*}.
When \tcode{T} is not an array type,
this constructor shall not participate in overload resolution unless
the expression \tcode{delete p} is well-formed and
\tcode{Y*} is convertible to \tcode{T*}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template<class D> shared_ptr(nullptr_t p, D d);
template<class D, class A> shared_ptr(nullptr_t p, D d, A a);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires Construction of \tcode{d} and a deleter of type \tcode{D}
initialized with \tcode{std::move(d)} shall not throw exceptions.
The expression \tcode{d(p)}
shall have well-defined behavior and shall not throw exceptions.
\tcode{A} shall satisfy the \tcode{Allocator} requirements
(\tref{utilities.allocator.requirements}).

\pnum\effects  Constructs a \tcode{shared_ptr} object that owns the
object \tcode{p} and the deleter \tcode{d}.
When \tcode{T} is not an array type,
the first and second constructors enable \tcode{shared_from_this} with \tcode{p}.
The second and fourth constructors shall use a copy of \tcode{a} to
allocate memory for internal use.
If an exception is thrown, \tcode{d(p)} is called.

\pnum\postconditions  \tcode{use_count() == 1 \&\& get() == p}.

\pnum\throws  \tcode{bad_alloc}, or an \impldef{exception type when \tcode{shared_ptr}
constructor fails} exception
when a resource other than memory could not be obtained.

\pnum\remarks
When \tcode{T} is an array type,
this constructor shall not participate in overload resolution unless
\tcode{is_move_constructible_v<D>} is \tcode{true},
the expression \tcode{d(p)} is well-formed, and either
\tcode{T} is \tcode{U[N]} and \tcode{Y(*)[N]} is convertible to \tcode{T*}, or
\tcode{T} is \tcode{U[]} and \tcode{Y(*)[]} is convertible to \tcode{T*}.
When \tcode{T} is not an array type,
this constructor shall not participate in overload resolution unless
\tcode{is_move_constructible_v<D>} is \tcode{true},
the expression \tcode{d(p)} is well-formed, and
\tcode{Y*} is convertible to \tcode{T*}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
template<class Y> shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{shared_ptr} instance that
stores \tcode{p} and shares ownership with \tcode{r}.

\pnum
\postconditions \tcode{get() == p \&\& use_count() == r.use_count()}.

\pnum
\begin{note} To avoid the possibility of a dangling pointer, the
user of this constructor should ensure that \tcode{p} remains valid at
least until the ownership group of \tcode{r} is destroyed. \end{note}

\pnum
\begin{note} This constructor allows creation of an empty
\tcode{shared_ptr} instance with a non-null stored pointer. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remarks
The second constructor shall not participate in overload resolution unless
\tcode{Y*} is compatible with \tcode{T*}.

\pnum\effects  If \tcode{r} is empty, constructs
an empty \tcode{shared_ptr} object; otherwise, constructs
a \tcode{shared_ptr} object that shares ownership with \tcode{r}.

\pnum\postconditions  \tcode{get() == r.get() \&\& use_count() == r.use_count()}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\begin{itemdecl}
shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks The second constructor shall not participate in overload resolution unless
\tcode{Y*} is compatible with \tcode{T*}.

\pnum
\effects Move constructs a \tcode{shared_ptr} instance from \tcode{r}.

\pnum
\postconditions \tcode{*this} shall contain the old value of
\tcode{r}. \tcode{r} shall be empty. \tcode{r.get() == nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\indexlibrary{\idxcode{weak_ptr}}%
\begin{itemdecl}
template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs a \tcode{shared_ptr} object that shares ownership with
\tcode{r} and stores a copy of the pointer stored in \tcode{r}.
If an exception is thrown, the constructor has no effect.

\pnum\postconditions  \tcode{use_count() == r.use_count()}.

\pnum\throws  \tcode{bad_weak_ptr} when \tcode{r.expired()}.

\pnum\remarks This constructor shall not participate in overload resolution unless
\tcode{Y*} is compatible with \tcode{T*}.
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}!constructor}%
\indexlibrary{\idxcode{unique_ptr}}%
\begin{itemdecl}
template<class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum\remarks This constructor shall not participate in overload resolution
unless \tcode{Y*} is compatible with \tcode{T*} and
\tcode{unique_ptr<Y, D>::pointer} is convertible to \tcode{element_type*}.

\pnum
\effects If \tcode{r.get() == nullptr}, equivalent to \tcode{shared_ptr()}.
Otherwise, if \tcode{D} is not a reference type,
equivalent to \tcode{shared_ptr(r.release(), r.get_deleter())}.
Otherwise, equivalent to \tcode{shared_ptr(r.release(), ref(r.get_deleter()))}.
If an exception is thrown, the constructor has no effect.
\end{itemdescr}

\rSec3[util.smartptr.shared.dest]{\tcode{shared_ptr} destructor}

\indexlibrary{\idxcode{shared_ptr}!destructor}%
\begin{itemdecl}
~shared_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects
\begin{itemize}
\item If \tcode{*this} is empty or shares ownership with another
\tcode{shared_ptr} instance (\tcode{use_count() > 1}), there are no side effects.

\item
Otherwise, if \tcode{*this} owns an object
\tcode{p} and a deleter \tcode{d}, \tcode{d(p)} is called.

\item Otherwise, \tcode{*this} owns a pointer \tcode{p},
and \tcode{delete p} is called.
\end{itemize}
\end{itemdescr}

\pnum
\begin{note} Since the destruction of \tcode{*this}
decreases the number of instances that share ownership with \tcode{*this}
by one,
after \tcode{*this} has been destroyed
all \tcode{shared_ptr} instances that shared ownership with
\tcode{*this} will report a \tcode{use_count()} that is one less
than its previous value. \end{note}

\rSec3[util.smartptr.shared.assign]{\tcode{shared_ptr} assignment}

\indexlibrarymember{operator=}{shared_ptr}%
\begin{itemdecl}
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(r).swap(*this)}.

\pnum\returns  \tcode{*this}.

\pnum \begin{note}
The use count updates caused by the temporary object
construction and destruction are not observable side
effects, so the implementation may meet the effects (and the
implied guarantees) via different means, without creating a
temporary. In particular, in the example:
\begin{codeblock}
shared_ptr<int> p(new int);
shared_ptr<void> q(p);
p = p;
q = p;
\end{codeblock}
both assignments may be no-ops. \end{note}
\end{itemdescr}

\indexlibrarymember{operator=}{shared_ptr}%
\begin{itemdecl}
shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{shared_ptr(std::move(r)).swap(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{shared_ptr}%
\begin{itemdecl}
template<class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{shared_ptr(std::move(r)).swap(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec3[util.smartptr.shared.mod]{\tcode{shared_ptr} modifiers}

\indexlibrarymember{swap}{shared_ptr}%
\begin{itemdecl}
void swap(shared_ptr& r) noexcept;
\end{itemdecl}

\begin{itemdescr}

\pnum\effects  Exchanges the contents of \tcode{*this} and \tcode{r}.
\end{itemdescr}

\indexlibrarymember{reset}{shared_ptr}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr().swap(*this)}.
\end{itemdescr}

\indexlibrarymember{reset}{shared_ptr}%
\begin{itemdecl}
template<class Y> void reset(Y* p);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(p).swap(*this)}.
\end{itemdescr}

\indexlibrarymember{reset}{shared_ptr}%
\begin{itemdecl}
template<class Y, class D> void reset(Y* p, D d);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{shared_ptr(p, d).swap(*this)}.
\end{itemdescr}

\indexlibrarymember{reset}{shared_ptr}%
\begin{itemdecl}
template<class Y, class D, class A> void reset(Y* p, D d, A a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Equivalent to \tcode{shared_ptr(p, d, a).swap(*this)}.
\end{itemdescr}

\rSec3[util.smartptr.shared.obs]{\tcode{shared_ptr} observers}
\indexlibrarymember{get}{shared_ptr}%
\begin{itemdecl}
element_type* get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns The stored pointer.
\end{itemdescr}

\indexlibrarymember{operator*}{shared_ptr}%
\begin{itemdecl}
T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{get() != 0}.

\pnum\returns  \tcode{*get()}.

\pnum\remarks When \tcode{T} is an array type or \cv{}~\tcode{void},
it is unspecified whether this
member function is declared. If it is declared, it is unspecified what its
return type is, except that the declaration (although not necessarily the
definition) of the function shall be well-formed.
\end{itemdescr}

\indexlibrarymember{operator->}{shared_ptr}%
\begin{itemdecl}
T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires  \tcode{get() != 0}.

\pnum\returns  \tcode{get()}.

\pnum\remarks When \tcode{T} is an array type,
it is unspecified whether this member function is declared.
If it is declared, it is unspecified what its return type is,
except that the declaration (although not necessarily the definition)
of the function shall be well-formed.
\end{itemdescr}

\indexlibrarymember{operator[]}{shared_ptr}%
\begin{itemdecl}
element_type& operator[](ptrdiff_t i) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\requires \tcode{get() != 0 \&\& i >= 0}.
If \tcode{T} is \tcode{U[N]}, \tcode{i < N}.

\pnum\returns \tcode{get()[i]}.

\pnum\remarks When \tcode{T} is not an array type,
it is unspecified whether this member function is declared.
If it is declared, it is unspecified what its return type is,
except that the declaration (although not necessarily the definition)
of the function shall be well-formed.

\pnum\throws Nothing.
\end{itemdescr}

\indexlibrarymember{use_count}{shared_ptr}%
\begin{itemdecl}
long use_count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  The number of \tcode{shared_ptr} objects, \tcode{*this} included,
that share ownership with \tcode{*this}, or \tcode{0} when \tcode{*this} is
empty.

\pnum\sync None.

\pnum \begin{note} \tcode{get() == nullptr}
does not imply a specific return value of \tcode{use_count()}. \end{note}

\pnum \begin{note} \tcode{weak_ptr<T>::lock()}
can affect the return value of \tcode{use_count()}. \end{note}

\pnum \begin{note} When multiple threads
can affect the return value of \tcode{use_count()},
the result should be treated as approximate.
In particular, \tcode{use_count() == 1} does not imply that accesses through
a previously destroyed \tcode{shared_ptr} have in any sense completed. \end{note}
\end{itemdescr}

\indexlibrarymember{operator bool}{shared_ptr}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{get() != 0}.
\end{itemdescr}

\indexlibrarymember{owner_before}{shared_ptr}%
\begin{itemdecl}
template<class U> bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> bool owner_before(const weak_ptr<U>& b) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An unspecified value such that

\begin{itemize}
\item \tcode{x.owner_before(y)} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{owner_before},
\tcode{!a.owner_before(b) \&\& !b.owner_before(a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or
are both empty.
\end{itemize}

\end{itemdescr}

\rSec3[util.smartptr.shared.create]{\tcode{shared_ptr} creation}

\pnum
The common requirements that apply to
all \tcode{make_shared} and \tcode{allocate_shared} overloads,
unless specified otherwise, are described below.

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T, ...>
  shared_ptr<T> make_shared(@\placeholdernc{args}@);
template<class T, class A, ...>
  shared_ptr<T> allocate_shared(const A& a, @\placeholdernc{args}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{A} shall satisfy the \tcode{Allocator}
requirements (\tref{utilities.allocator.requirements}).

\pnum
\effects Allocates memory for an object of type \tcode{T}
(or \tcode{U[N]} when \tcode{T} is \tcode{U[]},
where \tcode{N} is determined from \placeholder{args} as specified by the concrete overload).
The object is initialized from \placeholder{args} as specified by the concrete overload.
The \tcode{allocate_shared} templates use a copy of \tcode{a}
(rebound for an unspecified \tcode{value_type}) to allocate memory.
If an exception is thrown, the functions have no effect.

\pnum
\returns A \tcode{shared_ptr} instance that stores and owns the address of
the newly constructed object.

\pnum
\postconditions \tcode{r.get() != 0 \&\& r.use_count() == 1},
where \tcode{r} is the return value.

\pnum
\throws \tcode{bad_alloc}, or
an exception thrown from \tcode{allocate} or from the initialization of the object.

\pnum
\remarks
\begin{itemize}
\item
  Implementations should perform no more than one memory allocation.
  \begin{note}
  This provides efficiency equivalent to an intrusive smart pointer.
  \end{note}
\item
  When an object of an array type \tcode{U} is specified to have
  an initial value of \tcode{u} (of the same type),
  this shall be interpreted to mean that
  each array element of the object has as its initial value
  the corresponding element from \tcode{u}.
\item
  When an object of an array type is specified to have
  a default initial value,
  this shall be interpreted to mean that each array element of the object
  has a default initial value.
\item
  When a (sub)object of a non-array type \tcode{U} is specified to have
  an initial value of \tcode{v}, or \tcode{U(l...)},
  where \tcode{l...} is a list of constructor arguments,
  \tcode{make_shared} shall initialize this (sub)object
  via the expression \tcode{::new(pv) U(v)} or \tcode{::new(pv) U(l...)} respectively,
  where \tcode{pv} has type \tcode{void*} and points to storage
  suitable to hold an object of type \tcode{U}.
\item
  When a (sub)object of a non-array type \tcode{U} is specified to have
  an initial value of \tcode{v}, or \tcode{U(l...)},
  where \tcode{l...} is a list of constructor arguments,
  \tcode{allocate_shared} shall initialize this (sub)object
  via the expression
  \begin{itemize}
  \item \tcode{allocator_traits<A2>::construct(a2, pv, v)} or
  \item \tcode{allocator_traits<A2>::construct(a2, pv, l...)}
  \end{itemize}
  respectively,
  where \tcode{pv} points to storage
  suitable to hold an object of type \tcode{U} and
  \tcode{a2} of type \tcode{A2} is a rebound copy of
  the allocator \tcode{a} passed to \tcode{allocate_shared}
  such that its \tcode{value_type} is \tcode{remove_cv_t<U>}.
\item
  When a (sub)object of non-array type \tcode{U} is specified to have
  a default initial value,
  \tcode{make_shared} shall initialize this (sub)object
  via the expression \tcode{::new(pv) U()},
  where \tcode{pv} has type \tcode{void*} and points to storage
  suitable to hold an object of type \tcode{U}.
\item
  When a (sub)object of non-array type \tcode{U} is specified to have
  a default initial value,
  \tcode{allocate_shared} shall initialize this (sub)object
  via the expression \tcode{allocator_traits<A2>::construct(a2, pv)},
  where \tcode{pv} points to storage
  suitable to hold an object of type \tcode{U} and
  \tcode{a2} of type \tcode{A2} is a rebound copy of
  the allocator \tcode{a} passed to \tcode{allocate_shared}
  such that its \tcode{value_type} is \tcode{remove_cv_t<U>}.
\item
  Array elements are initialized in ascending order of their addresses.
\item
  When the lifetime of the object managed by the return value ends, or
  when the initialization of an array element throws an exception,
  the initialized elements are destroyed in the reverse order
  of their original construction.
\end{itemize}
\begin{note}
These functions will typically allocate more memory than \tcode{sizeof(T)} to
allow for internal bookkeeping structures such as reference counts.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T, class... Args>
  shared_ptr<T> make_shared(Args&&... args);                    // \tcode{T} is not array
template<class T, class A, class... Args>
  shared_ptr<T> allocate_shared(const A& a, Args&&... args);    // \tcode{T} is not array
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{shared_ptr} to an object of type \tcode{T}
with an initial value \tcode{T(forward<Args>(args)...)}.

\pnum
\remarks These overloads shall only participate in overload resolution
when \tcode{T} is not an array type.
The \tcode{shared_ptr} constructors called by these functions
enable \tcode{shared_from_this}
with the address of the newly constructed object of type \tcode{T}.

\pnum
\begin{example}
\begin{codeblock}
shared_ptr<int> p = make_shared<int>(); // \tcode{shared_ptr} to \tcode{int()}
shared_ptr<vector<int>> q = make_shared<vector<int>>(16, 1);
  // \tcode{shared_ptr} to vector of \tcode{16} elements with value \tcode{1}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T> shared_ptr<T>
  make_shared(size_t N);                                        // \tcode{T} is \tcode{U[]}
template<class T, class A>
  shared_ptr<T> allocate_shared(const A& a, size_t N);          // \tcode{T} is \tcode{U[]}
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{shared_ptr} to an object of type \tcode{U[N]}
with a default initial value,
where \tcode{U} is \tcode{remove_extent_t<T>}.

\pnum
\remarks These overloads shall only participate in overload resolution
when \tcode{T} is of the form \tcode{U[]}.

\pnum
\begin{example}
\begin{codeblock}
shared_ptr<double[]> p = make_shared<double[]>(1024);
  // \tcode{shared_ptr} to a value-initialized \tcode{double[1024]}
shared_ptr<double[][2][2]> q = make_shared<double[][2][2]>(6);
  // \tcode{shared_ptr} to a value-initialized \tcode{double[6][2][2]}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> make_shared();                                  // \tcode{T} is \tcode{U[N]}
template<class T, class A>
  shared_ptr<T> allocate_shared(const A& a);                    // \tcode{T} is \tcode{U[N]}
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{shared_ptr} to an object of type \tcode{T}
with a default initial value.

\pnum
\remarks These overloads shall only participate in overload resolution
when \tcode{T} is of the form \tcode{U[N]}.

\pnum
\begin{example}
\begin{codeblock}
shared_ptr<double[1024]> p = make_shared<double[1024]>();
  // \tcode{shared_ptr} to a value-initialized \tcode{double[1024]}
shared_ptr<double[6][2][2]> q = make_shared<double[6][2][2]>();
  // \tcode{shared_ptr} to a value-initialized \tcode{double[6][2][2]}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> make_shared(size_t N,
                            const remove_extent_t<T>& u);       // \tcode{T} is \tcode{U[]}
template<class T, class A>
  shared_ptr<T> allocate_shared(const A& a, size_t N,
                                const remove_extent_t<T>& u);   // \tcode{T} is \tcode{U[]}
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{shared_ptr} to an object of type \tcode{U[N]},
where \tcode{U} is \tcode{remove_extent_t<T>} and
each array element has an initial value of \tcode{u}.

\pnum
\remarks These overloads shall only participate in overload resolution
when \tcode{T} is of the form \tcode{U[]}.

\pnum
\begin{example}
\begin{codeblock}
shared_ptr<double[]> p = make_shared<double[]>(1024, 1.0);
  // \tcode{shared_ptr} to a \tcode{double[1024]}, where each element is \tcode{1.0}
shared_ptr<double[][2]> q = make_shared<double[][2]>(6, {1.0, 0.0});
  // \tcode{shared_ptr} to a \tcode{double[6][2]}, where each \tcode{double[2]} element is \tcode{\{1.0, 0.0\}}
shared_ptr<vector<int>[]> r = make_shared<vector<int>[]>(4, {1, 2});
  // \tcode{shared_ptr} to a \tcode{vector<int>[4]}, where each vector has contents \tcode{\{1, 2\}}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{make_shared}}%
\indexlibrary{\idxcode{allocate_shared}}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> make_shared(const remove_extent_t<T>& u);       // \tcode{T} is \tcode{U[N]}
template<class T, class A>
  shared_ptr<T> allocate_shared(const A& a,
                                const remove_extent_t<T>& u);   // \tcode{T} is \tcode{U[N]}
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{shared_ptr} to an object of type \tcode{T},
where each array element of type \tcode{remove_extent_t<T>}
has an initial value of \tcode{u}.

\pnum
\remarks These overloads shall only participate in overload resolution
when \tcode{T} is of the form \tcode{U[N]}.

\pnum
\begin{example}
\begin{codeblock}
shared_ptr<double[1024]> p = make_shared<double[1024]>(1.0);
  // \tcode{shared_ptr} to a \tcode{double[1024]}, where each element is \tcode{1.0}
shared_ptr<double[6][2]> q = make_shared<double[6][2]>({1.0, 0.0});
  // \tcode{shared_ptr} to a \tcode{double[6][2]}, where each double[2] element is \tcode{\{1.0, 0.0\}}
shared_ptr<vector<int>[4]> r = make_shared<vector<int>[4]>({1, 2});
  // \tcode{shared_ptr} to a \tcode{vector<int>[4]}, where each vector has contents \tcode{\{1, 2\}}
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec3[util.smartptr.shared.cmp]{\tcode{shared_ptr} comparison}

\indexlibrarymember{operator==}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{a.get() == b.get()}.
\end{itemdescr}

\indexlibrarymember{operator<}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{less<>()(a.get(), b.get())}.

\pnum
\begin{note}
Defining a comparison function allows \tcode{shared_ptr} objects to be
used as keys in associative containers.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator==}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator==(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!a}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator!=(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator!=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(bool)a}.
\end{itemdescr}

\indexlibrarymember{operator<}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator<(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator<(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns
\begin{codeblock}
less<typename shared_ptr<T>::element_type*>()(a.get(), nullptr)
\end{codeblock}
The second function template returns
\begin{codeblock}
less<typename shared_ptr<T>::element_type*>()(nullptr, a.get())
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator>}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator>(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator>(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{nullptr < a}.
The second function template returns \tcode{a < nullptr}.
\end{itemdescr}

\indexlibrarymember{operator<=}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator<=(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator<=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(nullptr < a)}.
The second function template returns \tcode{!(a < nullptr)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool operator>=(const shared_ptr<T>& a, nullptr_t) noexcept;
template<class T>
  bool operator>=(nullptr_t, const shared_ptr<T>& a) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(a < nullptr)}.
The second function template returns \tcode{!(nullptr < a)}.
\end{itemdescr}

\rSec3[util.smartptr.shared.spec]{\tcode{shared_ptr} specialized algorithms}

\indexlibrarymember{swap}{shared_ptr}%
\begin{itemdecl}
template<class T>
  void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{a.swap(b)}.
\end{itemdescr}

\rSec3[util.smartptr.shared.cast]{\tcode{shared_ptr} casts}

\indexlibrarymember{static_pointer_cast}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{static_cast<T*>((U*)nullptr)} shall
be well-formed.

\pnum
\returns
\begin{codeblock}
shared_ptr<T>(r, static_cast<typename shared_ptr<T>::element_type*>(r.get()))
\end{codeblock}

\pnum
\begin{note}
The seemingly equivalent expression
\tcode{shared_ptr<T>(static_cast<T*>(r.get()))}
will eventually result in undefined behavior, attempting to delete the
same object twice.
\end{note}
\end{itemdescr}

\indexlibrarymember{dynamic_pointer_cast}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{dynamic_cast<T*>((U*)nullptr)}
shall be well-formed.
The expression \tcode{dynamic_cast<typename shared_ptr<T>::element_type*>(r.get())}
shall be well formed and shall have well-defined behavior.

\pnum
\returns
\begin{itemize}
\item When \tcode{dynamic_cast<typename shared_ptr<T>::element_type*>(r.get())}
returns a non-null value \tcode{p}, \tcode{shared_ptr<T>(r, p)}.
\item Otherwise, \tcode{shared_ptr<T>()}.
\end{itemize}

\pnum
\begin{note}
The seemingly equivalent expression
\tcode{shared_ptr<T>(dynamic_cast<T*>(r.get()))} will eventually result in
undefined behavior, attempting to delete the same object twice.
\end{note}
\end{itemdescr}

\indexlibrarymember{const_pointer_cast}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{const_cast<T*>((U*)nullptr)} shall
be well-formed.

\pnum
\returns
\begin{codeblock}
shared_ptr<T>(r, const_cast<typename shared_ptr<T>::element_type*>(r.get()))
\end{codeblock}

\pnum
\begin{note}
The seemingly equivalent expression
\tcode{shared_ptr<T>(const_cast<T*>(r.get()))} will eventually result in
undefined behavior, attempting to delete the same object twice.
\end{note}
\end{itemdescr}

\indexlibrarymember{reinterpret_pointer_cast}{shared_ptr}%
\begin{itemdecl}
template<class T, class U>
  shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{reinterpret_cast<T*>((U*)nullptr)}
shall be well-formed.

\pnum\returns
\begin{codeblock}
shared_ptr<T>(r, reinterpret_cast<typename shared_ptr<T>::element_type*>(r.get()))
\end{codeblock}

\pnum
\begin{note}
The seemingly equivalent expression
\tcode{shared_ptr<T>(reinterpret_cast<T*>(r.get()))} will eventually result in
undefined behavior, attempting to delete the same object twice.
\end{note}
\end{itemdescr}

\rSec3[util.smartptr.getdeleter]{\tcode{get_deleter}}

\indexlibrarymember{get_deleter}{shared_ptr}%
\begin{itemdecl}
template<class D, class T>
  D* get_deleter(const shared_ptr<T>& p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  If \tcode{p} owns a deleter \tcode{d} of type cv-unqualified
\tcode{D}, returns \tcode{addressof(d)}; otherwise returns \tcode{nullptr}.
The returned
pointer remains valid as long as there exists a \tcode{shared_ptr} instance
that owns \tcode{d}. \begin{note} It is unspecified whether the pointer
remains valid longer than that. This can happen if the implementation doesn't destroy
the deleter until all \tcode{weak_ptr} instances that share ownership with
\tcode{p} have been destroyed. \end{note}
\end{itemdescr}

\rSec3[util.smartptr.shared.io]{\tcode{shared_ptr} I/O}

\indexlibrarymember{operator<<}{shared_ptr}%
\begin{itemdecl}
template<class E, class T, class Y>
  basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const shared_ptr<Y>& p);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects As if by: \tcode{os <{}< p.get();}

\pnum\returns  \tcode{os}.
\end{itemdescr}

\rSec2[util.smartptr.weak]{Class template \tcode{weak_ptr}}

\pnum
\indexlibrary{\idxcode{weak_ptr}}%
The \tcode{weak_ptr} class template stores a weak reference to an object
that is already managed by a \tcode{shared_ptr}. To access the object, a
\tcode{weak_ptr} can be converted to a \tcode{shared_ptr} using the member
function \tcode{lock}.

\begin{codeblock}
namespace std {
  template<class T> class weak_ptr {
  public:
    using element_type = remove_extent_t<T>;

    // \ref{util.smartptr.weak.const}, constructors
    constexpr weak_ptr() noexcept;
    template<class Y>
      weak_ptr(const shared_ptr<Y>& r) noexcept;
    weak_ptr(const weak_ptr& r) noexcept;
    template<class Y>
      weak_ptr(const weak_ptr<Y>& r) noexcept;
    weak_ptr(weak_ptr&& r) noexcept;
    template<class Y>
      weak_ptr(weak_ptr<Y>&& r) noexcept;

    // \ref{util.smartptr.weak.dest}, destructor
    ~weak_ptr();

    // \ref{util.smartptr.weak.assign}, assignment
    weak_ptr& operator=(const weak_ptr& r) noexcept;
    template<class Y>
      weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
    template<class Y>
      weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
    weak_ptr& operator=(weak_ptr&& r) noexcept;
    template<class Y>
      weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;

    // \ref{util.smartptr.weak.mod}, modifiers
    void swap(weak_ptr& r) noexcept;
    void reset() noexcept;

    // \ref{util.smartptr.weak.obs}, observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr<T> lock() const noexcept;
    template<class U>
      bool owner_before(const shared_ptr<U>& b) const noexcept;
    template<class U>
      bool owner_before(const weak_ptr<U>& b) const noexcept;
  };

  template<class T>
    weak_ptr(shared_ptr<T>) -> weak_ptr<T>;

  // \ref{util.smartptr.weak.spec}, specialized algorithms
  template<class T>
    void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
}
\end{codeblock}

\pnum
Specializations of \tcode{weak_ptr} shall be \tcode{CopyConstructible} and
\tcode{CopyAssignable}, allowing their use in standard
containers.  The template parameter \tcode{T} of \tcode{weak_ptr} may be an
incomplete type.

\rSec3[util.smartptr.weak.const]{\tcode{weak_ptr} constructors}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
constexpr weak_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Constructs an empty \tcode{weak_ptr} object.

\pnum\postconditions  \tcode{use_count() == 0}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
weak_ptr(const weak_ptr& r) noexcept;
template<class Y> weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remarks The second and third constructors shall not participate in
overload resolution unless \tcode{Y*} is compatible with \tcode{T*}.

\pnum\effects  If \tcode{r} is empty, constructs
an empty \tcode{weak_ptr} object; otherwise, constructs
a \tcode{weak_ptr} object that shares ownership
with \tcode{r} and stores a copy of the pointer stored in \tcode{r}.

\pnum\postconditions  \tcode{use_count() == r.use_count()}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}!constructor}%
\begin{itemdecl}
weak_ptr(weak_ptr&& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\remarks The second constructor shall not participate in overload resolution unless
\tcode{Y*} is compatible with \tcode{T*}.

\pnum\effects Move constructs a \tcode{weak_ptr} instance from \tcode{r}.

\pnum\postconditions \tcode{*this} shall contain the old value of \tcode{r}.
\tcode{r} shall be empty. \tcode{r.use_count() == 0}.
\end{itemdescr}

\rSec3[util.smartptr.weak.dest]{\tcode{weak_ptr} destructor}

\indexlibrary{\idxcode{weak_ptr}!destructor}%
\begin{itemdecl}
~weak_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Destroys this \tcode{weak_ptr} object but has no
effect on the object its stored pointer points to.
\end{itemdescr}

\rSec3[util.smartptr.weak.assign]{\tcode{weak_ptr} assignment}

\indexlibrarymember{operator=}{weak_ptr}%
\begin{itemdecl}
weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr(r).swap(*this)}.

\pnum\remarks  The implementation may meet the effects (and the
implied guarantees) via different means, without creating a temporary object.

\pnum\returns  \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{weak_ptr}%
\begin{itemdecl}
weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr(std::move(r)).swap(*this)}.

\pnum\returns  \tcode{*this}.
\end{itemdescr}

\rSec3[util.smartptr.weak.mod]{\tcode{weak_ptr} modifiers}
\indexlibrarymember{swap}{weak_ptr}%
\begin{itemdecl}
void swap(weak_ptr& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Exchanges the contents of \tcode{*this} and \tcode{r}.
\end{itemdescr}

\indexlibrarymember{reset}{weak_ptr}%
\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Equivalent to \tcode{weak_ptr().swap(*this)}.
\end{itemdescr}

\rSec3[util.smartptr.weak.obs]{\tcode{weak_ptr} observers}
\indexlibrarymember{use_count}{weak_ptr}%
\begin{itemdecl}
long use_count() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{0} if \tcode{*this} is empty;
otherwise, the number of \tcode{shared_ptr} instances
that share ownership with \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{expired}{weak_ptr}%
\begin{itemdecl}
bool expired() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{use_count() == 0}.
\end{itemdescr}

\indexlibrarymember{lock}{weak_ptr}%
\begin{itemdecl}
shared_ptr<T> lock() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{expired() ?\ shared_ptr<T>() :\ shared_ptr<T>(*this)}, executed atomically.
\end{itemdescr}

\indexlibrarymember{owner_before}{weak_ptr}%
\begin{itemdecl}
template<class U> bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> bool owner_before(const weak_ptr<U>& b) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns An unspecified value such that

\begin{itemize}
\item \tcode{x.owner_before(y)} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{owner_before},
\tcode{!a.owner_before(b) \&\& !b.owner_before(a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or are
both empty.
\end{itemize}
\end{itemdescr}


\rSec3[util.smartptr.weak.spec]{\tcode{weak_ptr} specialized algorithms}

\indexlibrarymember{swap}{weak_ptr}%
\begin{itemdecl}
template<class T>
  void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Equivalent to \tcode{a.swap(b)}.
\end{itemdescr}

\rSec2[util.smartptr.ownerless]{Class template \tcode{owner_less}}

\pnum
The class template \tcode{owner_less} allows ownership-based mixed comparisons of shared
and weak pointers.

\indexlibrary{\idxcode{owner_less}}%
\begin{codeblock}
namespace std {
  template<class T = void> struct owner_less;

  template<class T> struct owner_less<shared_ptr<T>> {
    bool operator()(const shared_ptr<T>&, const shared_ptr<T>&) const noexcept;
    bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
    bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
  };

  template<class T> struct owner_less<weak_ptr<T>> {
    bool operator()(const weak_ptr<T>&, const weak_ptr<T>&) const noexcept;
    bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
    bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
  };

  template<> struct owner_less<void> {
    template<class T, class U>
      bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
    template<class T, class U>
      bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
    template<class T, class U>
      bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
    template<class T, class U>
      bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;

    using is_transparent = @\unspec@;
  };
}
\end{codeblock}

\indexlibrarymember{operator()}{owner_less}%
\pnum \tcode{operator()(x, y)} shall return \tcode{x.owner_before(y)}. \begin{note}
Note that

\begin{itemize}
\item \tcode{operator()} defines a strict weak ordering as defined in~\ref{alg.sorting};

\item under the equivalence relation defined by \tcode{operator()},
\tcode{!operator()(a, b) \&\& !operator()(b, a)}, two \tcode{shared_ptr} or
\tcode{weak_ptr} instances are equivalent if and only if they share ownership or are
both empty.
\end{itemize} \end{note}

\rSec2[util.smartptr.enab]{Class template \tcode{enable_shared_from_this}}

\pnum
\indexlibrary{\idxcode{enable_shared_from_this}}%
A class \tcode{T} can inherit from \tcode{enable_shared_from_this<T>}
to inherit the \tcode{shared_from_this} member functions that obtain
a \tcode{shared_ptr} instance pointing to \tcode{*this}.

\pnum
\begin{example}
\begin{codeblock}
struct X: public enable_shared_from_this<X> { };

int main() {
  shared_ptr<X> p(new X);
  shared_ptr<X> q = p->shared_from_this();
  assert(p == q);
  assert(!p.owner_before(q) && !q.owner_before(p)); // p and q share ownership
}
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std {
  template<class T> class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(const enable_shared_from_this&) noexcept;
    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept;
    ~enable_shared_from_this();

  public:
    shared_ptr<T> shared_from_this();
    shared_ptr<T const> shared_from_this() const;
    weak_ptr<T> weak_from_this() noexcept;
    weak_ptr<T const> weak_from_this() const noexcept;

  private:
    mutable weak_ptr<T> weak_this;  // \expos
  };
}
\end{codeblock}

\pnum
The template parameter \tcode{T} of \tcode{enable_shared_from_this}
may be an incomplete type.

\indexlibrary{\idxcode{enable_shared_from_this}!constructor}%
\begin{itemdecl}
constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects  Value-initializes \tcode{weak_this}.
\end{itemdescr}

\indexlibrarymember{operator=}{enable_shared_from_this}%
\begin{itemdecl}
enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{*this}.

\pnum\begin{note} \tcode{weak_this} is not changed. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{shared_ptr}}%
\indexlibrarymember{shared_from_this}{enable_shared_from_this}%
\begin{itemdecl}
shared_ptr<T>       shared_from_this();
shared_ptr<T const> shared_from_this() const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{shared_ptr<T>(weak_this)}.
\end{itemdescr}

\indexlibrary{\idxcode{weak_ptr}}%
\indexlibrarymember{weak_from_this}{enable_shared_from_this}%
\begin{itemdecl}
weak_ptr<T>       weak_from_this() noexcept;
weak_ptr<T const> weak_from_this() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{weak_this}.
\end{itemdescr}

\rSec2[util.smartptr.hash]{Smart pointer hash support}

\indexlibrary{\idxcode{hash}!\idxcode{unique_ptr}}%
\begin{itemdecl}
template<class T, class D> struct hash<unique_ptr<T, D>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Letting \tcode{UP} be \tcode{unique_ptr<T,D>},
the specialization \tcode{hash<UP>} is enabled\iref{unord.hash}
if and only if \tcode{hash<typename UP::pointer>} is enabled.
When enabled, for an object \tcode{p} of type \tcode{UP},
\tcode{hash<UP>()(p)} shall evaluate to
the same value as \tcode{hash<typename UP::pointer>()(p.get())}.
The member functions are not guaranteed to be \tcode{noexcept}.
\end{itemdescr}

\indexlibrary{\idxcode{hash}!\idxcode{shared_ptr}}%
\begin{itemdecl}
template<class T> struct hash<shared_ptr<T>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
For an object \tcode{p} of type \tcode{shared_ptr<T>},
\tcode{hash<shared_ptr<T>>()(p)} shall evaluate to
the same value as \tcode{hash<typename shared_ptr<T>::element_type*>()(p.get())}.
\end{itemdescr}%
\indextext{smart pointers|)}

\indextext{atomic smart pointers|(}%
\rSec2[util.smartptr.atomic]{Atomic specializations for smart pointers}

\pnum
The library provides partial specializations of the \tcode{atomic} template
for shared-ownership smart pointers.
The behavior of all operations is as specified in \ref{atomics.types.generic},
unless specified otherwise.
The template parameter \tcode{T} of these partial specializations
may be an incomplete type.

\pnum
All changes to an atomic smart pointer in this subclause, and
all associated \tcode{use_count} increments,
are guaranteed to be performed atomically.
Associated \tcode{use_count} decrements
are sequenced after the atomic operation,
but are not required to be part of it.
Any associated deletion and deallocation
are sequenced after the atomic update step and
are not part of the atomic operation.
\begin{note}
If the atomic operation uses locks,
locks acquired by the implementation
will be held when any \tcode{use_count} adjustments are performed, and
will not be held when any destruction or deallocation
resulting from this is performed.
\end{note}

\rSec3[util.smartptr.atomic.shared]{Atomic specialization for \tcode{shared_ptr}}
\indexlibrary{\idxcode{atomic<shared_ptr<T>>}}%
\begin{codeblock}
namespace std {
  template<class T> struct atomic<shared_ptr<T>> {
    using value_type = shared_ptr<T>;
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;

    bool is_lock_free() const noexcept;
    void store(shared_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
    shared_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
    operator shared_ptr<T>() const noexcept;

    shared_ptr<T> exchange(shared_ptr<T> desired,
                           memory_order order = memory_order::seq_cst) noexcept;

    bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                                 memory_order success, memory_order failure) noexcept;

    bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                                 memory_order order = memory_order::seq_cst) noexcept;

    constexpr atomic() noexcept = default;
    atomic(shared_ptr<T> desired) noexcept;
    atomic(const atomic&) = delete;
    void operator=(const atomic&) = delete;
    void operator=(shared_ptr<T> desired) noexcept;

  private:
    shared_ptr<T> p;            // \expos
  };
}
\end{codeblock}

\indexlibrary{\idxcode{atomic<shared_ptr<T>>}!constructor}%
\begin{itemdecl}
constexpr atomic() noexcept = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{p\{\}}.
\end{itemdescr}

\indexlibrary{\idxcode{atomic<shared_ptr<T>>}!constructor}%
\begin{itemdecl}
atomic(shared_ptr<T> desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the object with the value \tcode{desired}.
Initialization is not an atomic operation\iref{intro.multithread}.
\begin{note}
It is possible to have an access to
an atomic object \tcode{A} race with its construction,
for example,
by communicating the address of the just-constructed object \tcode{A}
to another thread via \tcode{memory_order::relaxed} operations
on a suitable atomic pointer variable, and
then immediately accessing \tcode{A} in the receiving thread.
This results in undefined behavior.
\end{note}
\end{itemdescr}

\indexlibrarymember{store}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
void store(shared_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The \tcode{order} argument shall not be
\tcode{memory_order::consume},
\tcode{memory_order::acquire}, nor
\tcode{memory_order::acq_rel}.

\pnum
\effects
Atomically replaces the value pointed to by \tcode{this} with
the value of \tcode{desired} as if by \tcode{p.swap(desired)}.
Memory is affected according to the value of \tcode{order}.
\end{itemdescr}

\indexlibrarymember{operator=}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
void operator=(shared_ptr<T> desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{store(desired)}.
\end{itemdescr}

\indexlibrarymember{load}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
shared_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{order} shall not be
\tcode{memory_order::release} nor \tcode{memory_order::acq_rel}.

\pnum
\effects
Memory is affected according to the value of \tcode{order}.

\pnum
\returns
Atomically returns \tcode{p}.
\end{itemdescr}

\indexlibrarymember{operator shared_ptr<T>}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
operator shared_ptr<T>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return load();}
\end{itemdescr}

\indexlibrarymember{exchange}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
shared_ptr<T> exchange(shared_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Atomically replaces \tcode{p} with \tcode{desired}
as if by \tcode{p.swap(desired)}.
Memory is affected according to the value of \tcode{order}.
This is an atomic read-modify-write operation\iref{intro.races}.

\pnum
\returns
Atomically returns the value of \tcode{p} immediately before the effects.
\end{itemdescr}

\indexlibrarymember{compare_exchange_weak}{atomic<shared_ptr<T>>}%
\indexlibrarymember{compare_exchange_strong}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                           memory_order success, memory_order failure) noexcept;
bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                             memory_order success, memory_order failure) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{failure} shall not be
\tcode{memory_order::release} nor \tcode{memory_order::acq_rel}.

\pnum
\effects
If \tcode{p} is equivalent to \tcode{expected},
assigns \tcode{desired} to \tcode{p} and
has synchronization semantics corresponding to the value of \tcode{success},
otherwise assigns \tcode{p} to \tcode{expected} and
has synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns
\tcode{true} if \tcode{p} was equivalent to \tcode{expected},
\tcode{false} otherwise.

\pnum
\remarks
Two \tcode{shared_ptr} objects are equivalent if
they store the same pointer value and
either share ownership, or both are empty.
The weak form may fail spuriously. See \ref{atomics.types.operations}.

\pnum
If the operation returns \tcode{true},
\tcode{expected} is not accessed after the atomic update and
the operation is an atomic read-modify-write operation\iref{intro.multithread}
on the memory pointed to by \tcode{this}.
Otherwise, the operation is an atomic load operation on that memory, and
\tcode{expected} is updated with the existing value
read from the atomic object in the attempted atomic update.
The \tcode{use_count} update corresponding to the write to \tcode{expected}
is part of the atomic operation.
The write to \tcode{expected} itself
is not required to be part of the atomic operation.
\end{itemdescr}

\indexlibrarymember{compare_exchange_weak}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
                           memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return compare_exchange_weak(expected, desired, order, fail_order);
\end{codeblock}
where \tcode{fail_order} is the same as \tcode{order}
except that a value of \tcode{memory_order::acq_rel}
shall be replaced by the value \tcode{memory_order::acquire} and
a value of \tcode{memory_order::release}
shall be replaced by the value \tcode{memory_order::relaxed}.
\end{itemdescr}

\indexlibrarymember{compare_exchange_strong}{atomic<shared_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
                             memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return compare_exchange_strong(expected, desired, order, fail_order);
\end{codeblock}
where \tcode{fail_order} is the same as \tcode{order}
except that a value of \tcode{memory_order::acq_rel}
shall be replaced by the value \tcode{memory_order::acquire} and
a value of \tcode{memory_order::release}
shall be replaced by the value \tcode{memory_order::relaxed}.
\end{itemdescr}

\rSec3[util.smartptr.atomic.weak]{Atomic specialization for \tcode{weak_ptr}}
\indexlibrary{\idxcode{atomic<weak_ptr<T>>}}%
\begin{codeblock}
namespace std {
  template<class T> struct atomic<weak_ptr<T>> {
    using value_type = weak_ptr<T>;
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;

    bool is_lock_free() const noexcept;
    void store(weak_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
    weak_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
    operator weak_ptr<T>() const noexcept;

    weak_ptr<T> exchange(weak_ptr<T> desired,
                         memory_order order = memory_order::seq_cst) noexcept;

    bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                                 memory_order success, memory_order failure) noexcept;

    bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                                 memory_order order = memory_order::seq_cst) noexcept;

    constexpr atomic() noexcept = default;
    atomic(weak_ptr<T> desired) noexcept;
    atomic(const atomic&) = delete;
    void operator=(const atomic&) = delete;
    void operator=(weak_ptr<T> desired) noexcept;

  private:
    weak_ptr<T> p;              // \expos
  };
}
\end{codeblock}

\indexlibrary{\idxcode{atomic<weak_ptr<T>>}!constructor}%
\begin{itemdecl}
constexpr atomic() noexcept = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{p\{\}}.
\end{itemdescr}

\indexlibrary{\idxcode{atomic<weak_ptr<T>>}!constructor}%
\begin{itemdecl}
atomic(weak_ptr<T> desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the object with the value \tcode{desired}.
Initialization is not an atomic operation\iref{intro.multithread}.
\begin{note}
It is possible to have an access to
an atomic object \tcode{A} race with its construction,
for example,
by communicating the address of the just-constructed object \tcode{A}
to another thread via \tcode{memory_order::relaxed} operations
on a suitable atomic pointer variable, and
then immediately accessing \tcode{A} in the receiving thread.
This results in undefined behavior.
\end{note}
\end{itemdescr}

\indexlibrarymember{store}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
void store(weak_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The \tcode{order} argument shall not be
\tcode{memory_order::consume},
\tcode{memory_order::acquire}, nor
\tcode{memory_order::acq_rel}.

\pnum
\effects
Atomically replaces the value pointed to by \tcode{this} with
the value of \tcode{desired} as if by \tcode{p.swap(desired)}.
Memory is affected according to the value of \tcode{order}.
\end{itemdescr}

\indexlibrarymember{operator=}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
void operator=(weak_ptr<T> desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{store(desired)}.
\end{itemdescr}

\indexlibrarymember{load}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
weak_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{order} shall not be
\tcode{memory_order::release} nor \tcode{memory_order::acq_rel}.

\pnum
\effects
Memory is affected according to the value of \tcode{order}.

\pnum
\returns
Atomically returns \tcode{p}.
\end{itemdescr}

\indexlibrarymember{operator weak_ptr<T>}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
operator weak_ptr<T>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return load();}
\end{itemdescr}

\indexlibrarymember{exchange}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
weak_ptr<T> exchange(weak_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Atomically replaces \tcode{p} with \tcode{desired}
as if by \tcode{p.swap(desired)}.
Memory is affected according to the value of \tcode{order}.
This is an atomic read-modify-write operation\iref{intro.races}.

\pnum
\returns
Atomically returns the value of \tcode{p} immediately before the effects.
\end{itemdescr}

\indexlibrarymember{compare_exchange_weak}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                           memory_order success, memory_order failure) noexcept;
bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                             memory_order success, memory_order failure) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{failure} shall not be
\tcode{memory_order::release} nor \tcode{memory_order::acq_rel}.

\pnum
\effects
If \tcode{p} is equivalent to \tcode{expected},
assigns \tcode{desired} to \tcode{p} and
has synchronization semantics corresponding to the value of \tcode{success},
otherwise assigns \tcode{p} to \tcode{expected} and
has synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns
\tcode{true} if \tcode{p} was equivalent to \tcode{expected},
\tcode{false} otherwise.

\pnum
\remarks
Two \tcode{weak_ptr} objects are equivalent if
they store the same pointer value and
either share ownership, or both are empty.
The weak form may fail spuriously. See \ref{atomics.types.operations}.

\pnum
If the operation returns \tcode{true},
\tcode{expected} is not accessed after the atomic update and
the operation is an atomic read-modify-write operation\iref{intro.multithread}
on the memory pointed to by \tcode{this}.
Otherwise, the operation is an atomic load operation on that memory, and
\tcode{expected} is updated with the existing value
read from the atomic object in the attempted atomic update.
The \tcode{use_count} update corresponding to the write to \tcode{expected}
is part of the atomic operation.
The write to \tcode{expected} itself
is not required to be part of the atomic operation.
\end{itemdescr}

\indexlibrarymember{compare_exchange_weak}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
                           memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return compare_exchange_weak(expected, desired, order, fail_order);
\end{codeblock}
where \tcode{fail_order} is the same as \tcode{order}
except that a value of \tcode{memory_order::acq_rel}
shall be replaced by the value \tcode{memory_order::acquire} and
a value of \tcode{memory_order::release}
shall be replaced by the value \tcode{memory_order::relaxed}.
\end{itemdescr}

\indexlibrarymember{compare_exchange_strong}{atomic<weak_ptr<T>>}%
\begin{itemdecl}
bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
                             memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return compare_exchange_strong(expected, desired, order, fail_order);
\end{codeblock}
where \tcode{fail_order} is the same as \tcode{order}
except that a value of \tcode{memory_order::acq_rel}
shall be replaced by the value \tcode{memory_order::acquire} and
a value of \tcode{memory_order::release}
shall be replaced by the value \tcode{memory_order::relaxed}.
\end{itemdescr}
\indextext{atomic smart pointers|)}

\rSec1[mem.res]{Memory resources}

\rSec2[mem.res.syn]{Header \tcode{<memory_resource>} synopsis}

\indexhdr{memory_resource}%
\begin{codeblock}
namespace std::pmr {
  // \ref{mem.res.class}, class \tcode{memory_resource}
  class memory_resource;

  bool operator==(const memory_resource& a, const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a, const memory_resource& b) noexcept;

  // \ref{mem.poly.allocator.class}, class template \tcode{polymorphic_allocator}
  template<class Tp> class polymorphic_allocator;

  template<class T1, class T2>
    bool operator==(const polymorphic_allocator<T1>& a,
                    const polymorphic_allocator<T2>& b) noexcept;
  template<class T1, class T2>
    bool operator!=(const polymorphic_allocator<T1>& a,
                    const polymorphic_allocator<T2>& b) noexcept;

  // \ref{mem.res.global}, global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // \ref{mem.res.pool}, pool resource classes
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;
}
\end{codeblock}

\rSec2[mem.res.class]{Class \tcode{memory_resource}}

\pnum
The \tcode{memory_resource} class is an abstract interface to an unbounded set of classes encapsulating memory resources.

\indexlibrary{\idxcode{memory_resource}}%
\begin{codeblock}
namespace std::pmr {
  class memory_resource {
    static constexpr size_t max_align = alignof(max_align_t);   // \expos

  public:
    virtual ~memory_resource();

    [[nodiscard]] void* allocate(size_t bytes, size_t alignment = max_align);
    void deallocate(void* p, size_t bytes, size_t alignment = max_align);

    bool is_equal(const memory_resource& other) const noexcept;

  private:
    virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
    virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;

    virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
  };
}
\end{codeblock}


\rSec3[mem.res.public]{\tcode{memory_resource} public member functions}

\indexlibrary{\idxcode{memory_resource}!destructor}%
\begin{itemdecl}
~memory_resource();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys this \tcode{memory_resource}.
\end{itemdescr}

\indexlibrarymember{allocate}{memory_resource}%
\begin{itemdecl}
[[nodiscard]] void* allocate(size_t bytes, size_t alignment = max_align);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return do_allocate(bytes, alignment);}
\end{itemdescr}

\indexlibrarymember{deallocate}{memory_resource}%
\begin{itemdecl}
void deallocate(void* p, size_t bytes, size_t alignment = max_align);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{do_deallocate(p, bytes, alignment)}.
\end{itemdescr}

\indexlibrarymember{is_equal}{memory_resource}%
\begin{itemdecl}
bool is_equal(const memory_resource& other) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return do_is_equal(other);}
\end{itemdescr}


\rSec3[mem.res.private]{\tcode{memory_resource} private virtual member functions}

\indexlibrarymember{do_allocate}{memory_resource}%
\begin{itemdecl}
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{alignment} shall be a power of two.

\pnum
\returns
A derived class shall implement this function to
return a pointer to allocated storage\iref{basic.stc.dynamic.allocation}
with a size of at least \tcode{bytes},
aligned to the specified \tcode{alignment}.

\pnum
\throws
A derived class implementation shall throw an appropriate exception if it is unable to allocate memory with the requested size and alignment.
\end{itemdescr}

\indexlibrarymember{do_deallocate}{memory_resource}%
\begin{itemdecl}
virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} shall have been returned from a prior call to \tcode{allocate(bytes, alignment)} on a memory resource equal to \tcode{*this},
and the storage at \tcode{p} shall not yet have been deallocated.

\pnum
\effects
A derived class shall implement this function to dispose of allocated storage.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{do_is_equal}{memory_resource}%
\begin{itemdecl}
virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A derived class shall implement this function to return \tcode{true} if memory allocated from \tcode{this} can be deallocated from \tcode{other} and vice-versa,
otherwise \tcode{false}.
\begin{note}
The most-derived type of \tcode{other} might not match the type of \tcode{this}.
For a derived class \tcode{D}, an implementation of this function
could immediately return \tcode{false}
if \tcode{dynamic_cast<const D*>(\&other) == nullptr}.\end{note}
\end{itemdescr}

\rSec3[mem.res.eq]{\tcode{memory_resource} equality}

\indexlibrarymember{operator==}{memory_resource}%
\begin{itemdecl}
bool operator==(const memory_resource& a, const memory_resource& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\&a == \&b || a.is_equal(b)}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{memory_resource}%
\begin{itemdecl}
bool operator!=(const memory_resource& a, const memory_resource& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(a == b)}.
\end{itemdescr}

\rSec2[mem.poly.allocator.class]{Class template \tcode{polymorphic_allocator}}

\pnum
A specialization of class template \tcode{pmr::polymorphic_allocator}
satisfies the \tcode{Allocator} requirements (\tref{utilities.allocator.requirements}).
Constructed with different memory resources,
different instances of the same specialization of \tcode{pmr::polymorphic_allocator}
can exhibit entirely different allocation behavior.
This runtime polymorphism allows objects that use \tcode{polymorphic_allocator}
to behave as if they used different allocator types at run time
even though they use the same static allocator type.

\indexlibrary{\idxcode{polymorphic_allocator}}%
\indexlibrarymember{value_type}{polymorphic_allocator}%
\begin{codeblock}
namespace std::pmr {
  template<class Tp> class polymorphic_allocator {
    memory_resource* memory_rsrc;     // \expos

  public:
    using value_type = Tp;

    // \ref{mem.poly.allocator.ctor}, constructors
    polymorphic_allocator() noexcept;
    polymorphic_allocator(memory_resource* r);

    polymorphic_allocator(const polymorphic_allocator& other) = default;

    template<class U>
      polymorphic_allocator(const polymorphic_allocator<U>& other) noexcept;

    polymorphic_allocator& operator=(const polymorphic_allocator& rhs) = delete;

    // \ref{mem.poly.allocator.mem}, member functions
    [[nodiscard]] Tp* allocate(size_t n);
    void deallocate(Tp* p, size_t n);

    template<class T, class... Args>
      void construct(T* p, Args&&... args);

    template<class T1, class T2, class... Args1, class... Args2>
      void construct(pair<T1, T2>* p, piecewise_construct_t,
                     tuple<Args1...> x, tuple<Args2...> y);
    template<class T1, class T2>
      void construct(pair<T1, T2>* p);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, U&& x, V&& y);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, const pair<U, V>& pr);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, pair<U, V>&& pr);

    template<class T>
      void destroy(T* p);

    polymorphic_allocator select_on_container_copy_construction() const;

    memory_resource* resource() const;
  };
}
\end{codeblock}

\rSec3[mem.poly.allocator.ctor]{\tcode{polymorphic_allocator} constructors}

\indexlibrary{\idxcode{polymorphic_allocator}!constructor}%
\begin{itemdecl}
polymorphic_allocator() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets \tcode{memory_rsrc} to \tcode{get_default_resource()}.
\end{itemdescr}

\indexlibrary{\idxcode{polymorphic_allocator}!constructor}%
\begin{itemdecl}
polymorphic_allocator(memory_resource* r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{r} is non-null.

\pnum
\effects
Sets \tcode{memory_rsrc} to \tcode{r}.

\pnum
\throws
Nothing.

\pnum
\begin{note}
This constructor provides an implicit conversion from \tcode{memory_resource*}.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{polymorphic_allocator}!constructor}%
\begin{itemdecl}
template<class U> polymorphic_allocator(const polymorphic_allocator<U>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets \tcode{memory_rsrc} to \tcode{other.resource()}.
\end{itemdescr}


\rSec3[mem.poly.allocator.mem]{\tcode{polymorphic_allocator} member functions}

\indexlibrarymember{allocate}{polymorphic_allocator}%
\begin{itemdecl}
[[nodiscard]] Tp* allocate(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return static_cast<Tp*>(memory_rsrc->allocate(n * sizeof(Tp), alignof(Tp)));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{deallocate}{polymorphic_allocator}%
\begin{itemdecl}
void deallocate(Tp* p, size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} was allocated from a memory resource \tcode{x},
equal to \tcode{*memory_rsrc},
using \tcode{x.allocate(n * sizeof(Tp), alignof(Tp))}.

\pnum
\effects
Equivalent to \tcode{memory_rsrc->deallocate(p, n * sizeof(Tp), alignof(Tp))}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T, class... Args>
  void construct(T* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Uses-allocator construction of \tcode{T}
with allocator \tcode{*this} (see~\ref{allocator.uses.construction})
and constructor arguments \tcode{std::forward<Args>(args)...} is well-formed.
\begin{note}
Uses-allocator construction is always well-formed
for types that do not use allocators.\end{note}

\pnum
\effects
Construct a \tcode{T} object in the storage
whose address is represented by \tcode{p}
by uses-allocator construction with allocator \tcode{*this}
and constructor arguments \tcode{std::forward<Args>(args)...}.

\pnum
\throws
Nothing unless the constructor for \tcode{T} throws.

\pnum
\remarks
This function shall not participate in overload resolution if
\tcode{T} is a specialization of \tcode{pair}.
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2, class... Args1, class... Args2>
  void construct(pair<T1, T2>* p, piecewise_construct_t, tuple<Args1...> x, tuple<Args2...> y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note}
This member function and the \tcode{construct} member functions that follow
are overloads for piecewise construction of pairs\iref{pairs.pair}.
\end{note}

\pnum
\effects
Let \tcode{xprime} be a \tcode{tuple} constructed from \tcode{x}
according to the appropriate rule from the following list.
\begin{note}
The following description can be summarized as
constructing a \tcode{pair<T1, T2>} object
in the storage whose address is represented by \tcode{p},
as if by separate uses-allocator construction
with allocator \tcode{*this}\iref{allocator.uses.construction}
of \tcode{p->first} using the elements of \tcode{x}
and \tcode{p->second} using the elements of \tcode{y}.
\end{note}
\begin{itemize}
\item
If \tcode{uses_allocator_v<T1,polymorphic_allocator>} is \tcode{false}
\\
and
\tcode{is_constructible_v<T1,Args1...>} is \tcode{true},
\\
then \tcode{xprime} is \tcode{x}.
\item
Otherwise, if \tcode{uses_allocator_v<T1,polymorphic_allocator>} is \tcode{true}
\\
and
\tcode{is_constructible_v<T1,allocator_arg_t,polymorphic_allocator,Args1...>} is \tcode{true},
\\
then \tcode{xprime} is \tcode{tuple_cat(make_tuple(allocator_arg, *this), std::move(x))}.
\item
Otherwise, if \tcode{uses_allocator_v<T1,polymorphic_allocator>} is \tcode{true}
\\
and
\tcode{is_constructible_v<T1,Args1...,polymorphic_allocator>} is \tcode{true},
\\
then \tcode{xprime} is \tcode{tuple_cat(std::move(x), make_tuple(*this))}.
\item
Otherwise the program is ill formed.
\end{itemize}
Let \tcode{yprime} be a tuple constructed from \tcode{y}
according to the appropriate rule from the following list:
\begin{itemize}
\item
If \tcode{uses_allocator_v<T2,polymorphic_allocator>} is \tcode{false}
\\
and
\tcode{is_constructible_v<T2,Args2...>} is \tcode{true},
\\
then \tcode{yprime} is \tcode{y}.
\item
Otherwise, if \tcode{uses_allocator_v<T2,polymorphic_allocator>} is \tcode{true}
\\
and
\tcode{is_constructible_v<T2,allocator_arg_t,polymorphic_allocator,Args2...>} is \tcode{true},
\\
then \tcode{yprime} is \tcode{tuple_cat(make_tuple(allocator_arg, *this), std::move(y))}.
\item
Otherwise, if \tcode{uses_allocator_v<T2,polymorphic_allocator>} is \tcode{true}
\\
and
\tcode{is_constructible_v<T2,Args2...,polymorphic_allocator>} is \tcode{true},
\\
then
\tcode{yprime} is \tcode{tuple_cat(std::move(y), make_tuple(*this))}.
\item
Otherwise the program is ill formed.
\end{itemize}

Then, using \tcode{piecewise_construct}, \tcode{xprime}, and \tcode{yprime}
as the constructor arguments,
this function constructs a \tcode{pair<T1, T2>} object
in the storage whose address is represented by \tcode{p}.
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2>
  void construct(pair<T1, T2>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct, tuple<>(), tuple<>());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, U&& x, V&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(std::forward<U>(x)),
          forward_as_tuple(std::forward<V>(y)));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, const pair<U, V>& pr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(pr.first),
          forward_as_tuple(pr.second));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, pair<U, V>&& pr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(std::forward<U>(pr.first)),
          forward_as_tuple(std::forward<V>(pr.second)));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{destroy}{polymorphic_allocator}%
\begin{itemdecl}
template<class T>
  void destroy(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{p->\~T()}.
\end{itemdescr}

\indexlibrarymember{select_on_container_copy_construction}{polymorphic_allocator}%
\begin{itemdecl}
polymorphic_allocator select_on_container_copy_construction() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{polymorphic_allocator()}.

\pnum
\begin{note}
The memory resource is not propagated.
\end{note}
\end{itemdescr}

\indexlibrarymember{resource}{polymorphic_allocator}%
\begin{itemdecl}
memory_resource* resource() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{memory_rsrc}.
\end{itemdescr}

\rSec3[mem.poly.allocator.eq]{\tcode{polymorphic_allocator} equality}

\indexlibrarymember{operator==}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*a.resource() == *b.resource()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{polymorphic_allocator}%
\begin{itemdecl}
template<class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(a == b)}.
\end{itemdescr}


\rSec2[mem.res.global]{Access to program-wide \tcode{memory_resource} objects}

\indexlibrary{\idxcode{new_delete_resource}}%
\begin{itemdecl}
memory_resource* new_delete_resource() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to a static-duration object of a type derived from \tcode{memory_resource}
that can serve as a resource for allocating memory
using \tcode{::operator new} and \tcode{::operator delete}.
The same value is returned every time this function is called.
For a return value \tcode{p} and a memory resource \tcode{r},
\tcode{p->is_equal(r)} returns \tcode{\&r == p}.
\end{itemdescr}

\indexlibrary{\idxcode{null_memory_resource}}%
\begin{itemdecl}
memory_resource* null_memory_resource() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to a static-duration object of a type derived from \tcode{memory_resource}
for which \tcode{allocate()} always throws \tcode{bad_alloc} and
for which \tcode{deallocate()} has no effect.
The same value is returned every time this function is called.
For a return value \tcode{p} and a memory resource \tcode{r},
\tcode{p->is_equal(r)} returns \tcode{\&r == p}.
\end{itemdescr}

\pnum
The \defn{default memory resource pointer} is a pointer to a memory resource
that is used by certain facilities when an explicit memory resource
is not supplied through the interface.
Its initial value is the return value of \tcode{new_delete_resource()}.

\indexlibrary{\idxcode{set_default_resource}}%
\begin{itemdecl}
memory_resource* set_default_resource(memory_resource* r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{r} is non-null,
sets the value of the default memory resource pointer to \tcode{r},
otherwise sets the default memory resource pointer to \tcode{new_delete_resource()}.

\pnum
\returns
The previous value of the default memory resource pointer.

\pnum
\remarks
Calling the \tcode{set_default_resource} and
\tcode{get_default_resource} functions shall not incur a data race.
A call to the \tcode{set_default_resource} function
shall synchronize with subsequent calls to
the \tcode{set_default_resource} and \tcode{get_default_resource} functions.
\end{itemdescr}

\indexlibrary{\idxcode{get_default_resource}}%
\begin{itemdecl}
memory_resource* get_default_resource() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The current value of the default memory resource pointer.
\end{itemdescr}

\rSec2[mem.res.pool]{Pool resource classes}

\rSec3[mem.res.pool.overview]{Classes \tcode{synchronized_pool_resource} and \tcode{unsynchronized_pool_resource}}

\pnum
The \tcode{synchronized_pool_resource} and
\tcode{unsynchronized_pool_resource} classes
(collectively called \defn{pool resource classes})
are general-purpose memory resources having the following qualities:
\begin{itemize}
\item
Each resource frees its allocated memory on destruction,
even if \tcode{deallocate} has not been called for some of the allocated blocks.
\item
A pool resource consists of a collection of \defn{pools},
serving requests for different block sizes.
Each individual pool manages a collection of \defn{chunks}
that are in turn divided into blocks of uniform size,
returned via calls to \tcode{do_allocate}.
Each call to \tcode{do_allocate(size, alignment)} is dispatched
to the pool serving the smallest blocks accommodating at least \tcode{size} bytes.
\item
When a particular pool is exhausted,
allocating a block from that pool results in the allocation
of an additional chunk of memory from the \defn{upstream allocator}
(supplied at construction), thus replenishing the pool.
With each successive replenishment,
the chunk size obtained increases geometrically.
\begin{note}
By allocating memory in chunks,
the pooling strategy increases the chance that consecutive allocations
will be close together in memory.\end{note}
\item
Allocation requests that exceed the largest block size of any pool
are fulfilled directly from the upstream allocator.
\item
A \tcode{pool_options} struct may be passed to the pool resource constructors
to tune the largest block size and the maximum chunk size.
\end{itemize}

\pnum
A \tcode{synchronized_pool_resource} may be accessed from multiple threads
without external synchronization
and may have thread-specific pools to reduce synchronization costs.
An \tcode{unsynchronized_pool_resource} class may not be accessed
from multiple threads simultaneously
and thus avoids the cost of synchronization entirely
in single-threaded applications.

\indexlibrary{\idxcode{pool_options}}%
\indexlibrary{\idxcode{synchronized_pool_resource}}%
\indexlibrary{\idxcode{unsynchronized_pool_resource}}%
\begin{codeblock}
namespace std::pmr {
  struct pool_options {
    size_t max_blocks_per_chunk = 0;
    size_t largest_required_pool_block = 0;
  };

  class synchronized_pool_resource : public memory_resource {
  public:
    synchronized_pool_resource(const pool_options& opts, memory_resource* upstream);

    synchronized_pool_resource()
        : synchronized_pool_resource(pool_options(), get_default_resource()) {}
    explicit synchronized_pool_resource(memory_resource* upstream)
        : synchronized_pool_resource(pool_options(), upstream) {}
    explicit synchronized_pool_resource(const pool_options& opts)
        : synchronized_pool_resource(opts, get_default_resource()) {}

    synchronized_pool_resource(const synchronized_pool_resource&) = delete;
    virtual ~synchronized_pool_resource();

    synchronized_pool_resource& operator=(const synchronized_pool_resource&) = delete;

    void release();
    memory_resource* upstream_resource() const;
    pool_options options() const;

  protected:
    void* do_allocate(size_t bytes, size_t alignment) override;
    void do_deallocate(void* p, size_t bytes, size_t alignment) override;

    bool do_is_equal(const memory_resource& other) const noexcept override;
  };

  class unsynchronized_pool_resource : public memory_resource {
  public:
    unsynchronized_pool_resource(const pool_options& opts, memory_resource* upstream);

    unsynchronized_pool_resource()
        : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
    explicit unsynchronized_pool_resource(memory_resource* upstream)
        : unsynchronized_pool_resource(pool_options(), upstream) {}
    explicit unsynchronized_pool_resource(const pool_options& opts)
        : unsynchronized_pool_resource(opts, get_default_resource()) {}

    unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete;
    virtual ~unsynchronized_pool_resource();

    unsynchronized_pool_resource& operator=(const unsynchronized_pool_resource&) = delete;

    void release();
    memory_resource* upstream_resource() const;
    pool_options options() const;

  protected:
    void* do_allocate(size_t bytes, size_t alignment) override;
    void do_deallocate(void* p, size_t bytes, size_t alignment) override;

    bool do_is_equal(const memory_resource& other) const noexcept override;
  };
}
\end{codeblock}

\rSec3[mem.res.pool.options]{\tcode{pool_options} data members}

\pnum
The members of \tcode{pool_options}
comprise a set of constructor options for pool resources.
The effect of each option on the pool resource behavior is described below:

\indexlibrary{\idxcode{pool_options}!\idxcode{max_blocks_per_chunk}}%
\begin{itemdecl}
size_t max_blocks_per_chunk;
\end{itemdecl}

\begin{itemdescr}
\pnum
The maximum number of blocks that will be allocated at once
from the upstream memory resource\iref{mem.res.monotonic.buffer}
to replenish a pool.
If the value of \tcode{max_blocks_per_chunk} is zero or
is greater than an \impldef{largest supported value to configure the maximum number of blocks to replenish a pool}
limit, that limit is used instead.
The implementation
may choose to use a smaller value than is specified in this field and
may use different values for different pools.
\end{itemdescr}

\indexlibrary{\idxcode{pool_options}!\idxcode{largest_required_pool_block}}%
\begin{itemdecl}
size_t largest_required_pool_block;
\end{itemdecl}

\begin{itemdescr}
\pnum
The largest allocation size that is required to be fulfilled
using the pooling mechanism.
Attempts to allocate a single block larger than this threshold
will be allocated directly from the upstream memory resource.
If \tcode{largest_required_pool_block} is zero or
is greater than an \impldef{largest supported value to configure the largest allocation satisfied directly by a pool}
limit, that limit is used instead.
The implementation may choose a pass-through threshold
larger than specified in this field.
\end{itemdescr}

\rSec3[mem.res.pool.ctor]{Pool resource constructors and destructors}

\indexlibrary{\idxcode{synchronized_pool_resource}!constructor}%
\indexlibrary{\idxcode{unsynchronized_pool_resource}!constructor}%
\begin{itemdecl}
synchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
unsynchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{upstream} is the address of a valid memory resource.

\pnum
\effects
Constructs a pool resource object that will obtain memory from \tcode{upstream}
whenever the pool resource is unable to satisfy a memory request
from its own internal data structures.
The resulting object will hold a copy of \tcode{upstream},
but will not own the resource to which \tcode{upstream} points.
\begin{note}
The intention is that calls to \tcode{upstream->allocate()}
will be substantially fewer than calls to \tcode{this->allocate()}
in most cases.\end{note}
The behavior of the pooling mechanism is tuned
according to the value of the \tcode{opts} argument.

\pnum
\throws
Nothing unless \tcode{upstream->allocate()} throws.
It is unspecified if, or under what conditions,
this constructor calls \tcode{upstream->allocate()}.
\end{itemdescr}

\indexlibrary{\idxcode{synchronized_pool_resource}!destructor}%
\indexlibrary{\idxcode{unsynchronized_pool_resource}!destructor}%
\begin{itemdecl}
virtual ~synchronized_pool_resource();
virtual ~unsynchronized_pool_resource();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{release()}.
\end{itemdescr}

\rSec3[mem.res.pool.mem]{Pool resource members}

\indexlibrarymember{release}{synchronized_pool_resource}%
\indexlibrarymember{release}{unsynchronized_pool_resource}%
\begin{itemdecl}
void release();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{upstream_resource()->deallocate()} as necessary
to release all allocated memory.
\begin{note}
The memory is released back to \tcode{upstream_resource()}
even if \tcode{deallocate} has not been called
for some of the allocated blocks.\end{note}
\end{itemdescr}

\indexlibrarymember{upstream_resource}{synchronized_pool_resource}%
\indexlibrarymember{upstream_resource}{unsynchronized_pool_resource}%
\begin{itemdecl}
memory_resource* upstream_resource() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of the \tcode{upstream} argument
provided to the constructor of this object.
\end{itemdescr}

\indexlibrarymember{options}{synchronized_pool_resource}%
\indexlibrarymember{options}{unsynchronized_pool_resource}%
\begin{itemdecl}
pool_options options() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The options that control the pooling behavior of this resource.
The values in the returned struct may differ
from those supplied to the pool resource constructor in that
values of zero will be replaced with \impldef{default configuration of a pool}
defaults, and sizes may be rounded to unspecified granularity.
\end{itemdescr}

\indexlibrarymember{do_allocate}{synchronized_pool_resource}%
\indexlibrarymember{do_allocate}{unsynchronized_pool_resource}%
\begin{itemdecl}
void* do_allocate(size_t bytes, size_t alignment) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to allocated storage\iref{basic.stc.dynamic.allocation}
with a size of at least \tcode{bytes}.
The size and alignment of the allocated memory shall meet the requirements
for a class derived from \tcode{memory_resource}\iref{mem.res.class}.

\pnum
\effects
If the pool selected for a block of size \tcode{bytes}
is unable to satisfy the memory request from its own internal data structures,
it will call \tcode{upstream_resource()->allocate()} to obtain more memory.
If \tcode{bytes} is larger than that which the largest pool can handle,
then memory will be allocated using \tcode{upstream_resource()->allocate()}.

\pnum
\throws
Nothing unless \tcode{upstream_resource()->allocate()} throws.
\end{itemdescr}

\indexlibrarymember{do_deallocate}{synchronized_pool_resource}%
\indexlibrarymember{do_deallocate}{unsynchronized_pool_resource}%
\begin{itemdecl}
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns the memory at \tcode{p} to the pool.
It is unspecified if, or under what circumstances,
this operation will result in a call to \tcode{upstream_resource()->deallocate()}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{do_is_equal}{synchronized_pool_resource}%
\indexlibrarymember{do_is_equal}{unsynchronized_pool_resource}%
\begin{itemdecl}
bool do_is_equal(const memory_resource& other) const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{this == \&other}.
\end{itemdescr}

\rSec2[mem.res.monotonic.buffer]{Class \tcode{monotonic_buffer_resource}}

\pnum
A \tcode{monotonic_buffer_resource} is a special-purpose memory resource
intended for very fast memory allocations in situations
where memory is used to build up a few objects
and then is released all at once when the memory resource object is destroyed.
It has the following qualities:
\begin{itemize}
\item
A call to \tcode{deallocate} has no effect,
thus the amount of memory consumed increases monotonically
until the resource is destroyed.
\item
The program can supply an initial buffer,
which the allocator uses to satisfy memory requests.
\item
When the initial buffer (if any) is exhausted,
it obtains additional buffers from an \defn{upstream} memory resource
supplied at construction.
Each additional buffer is larger than the previous one,
following a geometric progression.
\item
It is intended for access from one thread of control at a time.
Specifically, calls to \tcode{allocate} and \tcode{deallocate}
do not synchronize with one another.
\item
It frees the allocated memory on destruction,
even if \tcode{deallocate} has not been called for some of the allocated blocks.
\end{itemize}

\indexlibrary{\idxcode{monotonic_buffer_resource}}%
\begin{codeblock}
namespace std::pmr {
  class monotonic_buffer_resource : public memory_resource {
    memory_resource* upstream_rsrc;     // \expos
    void* current_buffer;               // \expos
    size_t next_buffer_size;            // \expos

  public:
    explicit monotonic_buffer_resource(memory_resource* upstream);
    monotonic_buffer_resource(size_t initial_size, memory_resource* upstream);
    monotonic_buffer_resource(void* buffer, size_t buffer_size, memory_resource* upstream);

    monotonic_buffer_resource()
        : monotonic_buffer_resource(get_default_resource()) {}
    explicit monotonic_buffer_resource(size_t initial_size)
        : monotonic_buffer_resource(initial_size, get_default_resource()) {}
    monotonic_buffer_resource(void* buffer, size_t buffer_size)
        : monotonic_buffer_resource(buffer, buffer_size, get_default_resource()) {}

    monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;

    virtual ~monotonic_buffer_resource();

    monotonic_buffer_resource& operator=(const monotonic_buffer_resource&) = delete;

    void release();
    memory_resource* upstream_resource() const;

  protected:
    void* do_allocate(size_t bytes, size_t alignment) override;
    void do_deallocate(void* p, size_t bytes, size_t alignment) override;

    bool do_is_equal(const memory_resource& other) const noexcept override;
  };
}
\end{codeblock}

\rSec3[mem.res.monotonic.buffer.ctor]{\tcode{monotonic_buffer_resource} constructor and destructor}

\indexlibrary{\idxcode{monotonic_buffer_resource}!constructor}%
\begin{itemdecl}
explicit monotonic_buffer_resource(memory_resource* upstream);
monotonic_buffer_resource(size_t initial_size, memory_resource* upstream);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{upstream} shall be the address of a valid memory resource.
\tcode{initial_size}, if specified, shall be greater than zero.

\pnum
\effects
Sets \tcode{upstream_rsrc} to \tcode{upstream} and
\tcode{current_buffer} to \tcode{nullptr}.
If \tcode{initial_size} is specified,
sets \tcode{next_buffer_size} to at least \tcode{initial_size};
otherwise sets \tcode{next_buffer_size} to an
\impldef{default \tcode{next_buffer_size} for a \tcode{monotonic_buffer_resource}} size.
\end{itemdescr}

\indexlibrary{\idxcode{monotonic_buffer_resource}!constructor}%
\begin{itemdecl}
monotonic_buffer_resource(void* buffer, size_t buffer_size, memory_resource* upstream);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{upstream} shall be the address of a valid memory resource.
\tcode{buffer_size} shall be no larger than the number of bytes in \tcode{buffer}.

\pnum
\effects
Sets \tcode{upstream_rsrc} to \tcode{upstream},
\tcode{current_buffer} to \tcode{buffer}, and
\tcode{next_buffer_size} to \tcode{buffer_size} (but not less than 1),
then increases \tcode{next_buffer_size}
by an \impldef{growth factor for \tcode{monotonic_buffer_resource}} growth factor (which need not be integral).
\end{itemdescr}

\indexlibrary{\idxcode{monotonic_buffer_resource}!destructor}%
\begin{itemdecl}
~monotonic_buffer_resource();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{release()}.
\end{itemdescr}


\rSec3[mem.res.monotonic.buffer.mem]{\tcode{monotonic_buffer_resource} members}

\indexlibrarymember{release}{monotonic_buffer_resource}%
\begin{itemdecl}
void release();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{upstream_rsrc->deallocate()} as necessary
to release all allocated memory.

\pnum
\begin{note}
The memory is released back to \tcode{upstream_rsrc}
even if some blocks that were allocated from \tcode{this}
have not been deallocated from \tcode{this}.\end{note}
\end{itemdescr}

\indexlibrarymember{upstream_resource}{monotonic_buffer_resource}%
\begin{itemdecl}
memory_resource* upstream_resource() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The value of \tcode{upstream_rsrc}.
\end{itemdescr}

\indexlibrarymember{do_allocate}{monotonic_buffer_resource}%
\begin{itemdecl}
void* do_allocate(size_t bytes, size_t alignment) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to allocated storage\iref{basic.stc.dynamic.allocation}
with a size of at least \tcode{bytes}.
The size and alignment of the allocated memory shall meet the requirements
for a class derived from \tcode{memory_resource}\iref{mem.res.class}.

\pnum
\effects
If the unused space in \tcode{current_buffer}
can fit a block with the specified \tcode{bytes} and \tcode{alignment},
then allocate the return block from \tcode{current_buffer};
otherwise set \tcode{current_buffer} to \tcode{upstream_rsrc->allocate(n, m)},
where \tcode{n} is not less than \tcode{max(bytes, next_buffer_size)} and
\tcode{m} is not less than \tcode{alignment},
and increase \tcode{next_buffer_size}
by an \impldef{growth factor for \tcode{monotonic_buffer_resource}} growth factor (which need not be integral),
then allocate the return block from the newly-allocated \tcode{current_buffer}.

\pnum
\throws
Nothing unless \tcode{upstream_rsrc->allocate()} throws.
\end{itemdescr}

\indexlibrarymember{do_deallocate}{monotonic_buffer_resource}%
\begin{itemdecl}
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
None.

\pnum
\throws
Nothing.

\pnum
\remarks
Memory used by this resource increases monotonically until its destruction.
\end{itemdescr}

\indexlibrarymember{do_is_equal}{monotonic_buffer_resource}%
\begin{itemdecl}
bool do_is_equal(const memory_resource& other) const noexcept override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{this == \&other}.
\end{itemdescr}


\rSec1[allocator.adaptor]{Class template \tcode{scoped_allocator_adaptor}}

\rSec2[allocator.adaptor.syn]{Header \tcode{<scoped_allocator>} synopsis}

\indexhdr{scoped_allocator}%
\begin{codeblock}
namespace std {
  // class template \tcode{scoped allocator adaptor}
  template<class OuterAlloc, class... InnerAlloc>
    class scoped_allocator_adaptor;

  // \ref{scoped.adaptor.operators}, scoped allocator operators
  template<class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
  template<class OuterA1, class OuterA2, class... InnerAllocs>
    bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
}
\end{codeblock}

\pnum
The class template \tcode{scoped_allocator_adaptor} is an allocator template that
specifies the memory resource (the outer allocator) to be used by a container (as any
other allocator does) and also specifies an inner allocator resource to be passed to the
constructor of every element within the container. This adaptor is instantiated with one
outer and zero or more inner allocator types. If instantiated with only one allocator
type, the inner allocator becomes the \tcode{scoped_allocator_adaptor} itself, thus
using the same allocator resource for the container and every element within the
container and, if the elements themselves are containers, each of their elements
recursively. If instantiated with more than one allocator, the first allocator is the
outer allocator for use by the container, the second allocator is passed to the
constructors of the container's elements, and, if the elements themselves are
containers, the third allocator is passed to the elements' elements, and so on. If
containers are nested to a depth greater than the number of allocators, the last
allocator is used repeatedly, as in the single-allocator case, for any remaining
recursions. \begin{note} The \tcode{scoped_allocator_adaptor} is derived from the outer
allocator type so it can be substituted for the outer allocator type in most
expressions. \end{note}

\indexlibrary{\idxcode{scoped_allocator_adaptor}}%
\indexlibrarymember{outer_allocator_type}{scoped_allocator_adaptor}%
\indexlibrarymember{value_type}{scoped_allocator_adaptor}%
\indexlibrarymember{size_type}{scoped_allocator_adaptor}%
\indexlibrarymember{difference_type}{scoped_allocator_adaptor}%
\indexlibrarymember{pointer}{scoped_allocator_adaptor}%
\indexlibrarymember{const_pointer}{scoped_allocator_adaptor}%
\indexlibrarymember{void_pointer}{scoped_allocator_adaptor}%
\indexlibrarymember{const_void_pointer}{scoped_allocator_adaptor}%
\begin{codeblock}
namespace std {
  template<class OuterAlloc, class... InnerAllocs>
  class scoped_allocator_adaptor : public OuterAlloc {
  private:
    using OuterTraits = allocator_traits<OuterAlloc>;   // \expos
    scoped_allocator_adaptor<InnerAllocs...> inner;     // \expos

  public:
    using outer_allocator_type = OuterAlloc;
    using inner_allocator_type = @\seebelow@;

    using value_type           = typename OuterTraits::value_type;
    using size_type            = typename OuterTraits::size_type;
    using difference_type      = typename OuterTraits::difference_type;
    using pointer              = typename OuterTraits::pointer;
    using const_pointer        = typename OuterTraits::const_pointer;
    using void_pointer         = typename OuterTraits::void_pointer;
    using const_void_pointer   = typename OuterTraits::const_void_pointer;

    using propagate_on_container_copy_assignment = @\seebelow@;
    using propagate_on_container_move_assignment = @\seebelow@;
    using propagate_on_container_swap            = @\seebelow@;
    using is_always_equal                        = @\seebelow@;

    template<class Tp> struct rebind {
      using other = scoped_allocator_adaptor<
        OuterTraits::template rebind_alloc<Tp>, InnerAllocs...>;
    };

    scoped_allocator_adaptor();
    template<class OuterA2>
      scoped_allocator_adaptor(OuterA2&& outerAlloc,
                               const InnerAllocs&... innerAllocs) noexcept;

    scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
    scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;

    template<class OuterA2>
      scoped_allocator_adaptor(
        const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
    template<class OuterA2>
      scoped_allocator_adaptor(
        scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;

    scoped_allocator_adaptor& operator=(const scoped_allocator_adaptor&) = default;
    scoped_allocator_adaptor& operator=(scoped_allocator_adaptor&&) = default;

    ~scoped_allocator_adaptor();

    inner_allocator_type& inner_allocator() noexcept;
    const inner_allocator_type& inner_allocator() const noexcept;
    outer_allocator_type& outer_allocator() noexcept;
    const outer_allocator_type& outer_allocator() const noexcept;

    [[nodiscard]] pointer allocate(size_type n);
    [[nodiscard]] pointer allocate(size_type n, const_void_pointer hint);
    void deallocate(pointer p, size_type n);
    size_type max_size() const;

    template<class T, class... Args>
      void construct(T* p, Args&&... args);
    template<class T1, class T2, class... Args1, class... Args2>
      void construct(pair<T1, T2>* p, piecewise_construct_t,
                     tuple<Args1...> x, tuple<Args2...> y);
    template<class T1, class T2>
      void construct(pair<T1, T2>* p);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, U&& x, V&& y);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, const pair<U, V>& x);
    template<class T1, class T2, class U, class V>
      void construct(pair<T1, T2>* p, pair<U, V>&& x);

    template<class T>
      void destroy(T* p);

    scoped_allocator_adaptor select_on_container_copy_construction() const;
  };

  template<class OuterAlloc, class... InnerAllocs>
    scoped_allocator_adaptor(OuterAlloc, InnerAllocs...)
      -> scoped_allocator_adaptor<OuterAlloc, InnerAllocs...>;
}
\end{codeblock}

\rSec2[allocator.adaptor.types]{Scoped allocator adaptor member types}

\indexlibrarymember{inner_allocator_type}{scoped_allocator_adaptor}%
\begin{itemdecl}
using inner_allocator_type = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{scoped_allocator_adaptor<OuterAlloc>} if \tcode{sizeof...(InnerAllocs)} is
zero; otherwise,\\ \tcode{scoped_allocator_adaptor<InnerAllocs...>}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_copy_assignment}{scoped_allocator_adaptor}%
\begin{itemdecl}
using propagate_on_container_copy_assignment = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_copy_assignment::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_move_assignment}{scoped_allocator_adaptor}%
\begin{itemdecl}
using propagate_on_container_move_assignment = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_move_assignment::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{propagate_on_container_swap}{scoped_allocator_adaptor}%
\begin{itemdecl}
using propagate_on_container_swap = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::propagate_on_container_swap::value} is
\tcode{true} for any \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\indexlibrarymember{is_always_equal}{scoped_allocator_adaptor}%
\begin{itemdecl}
using is_always_equal = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ctype \tcode{true_type} if
\tcode{allocator_traits<A>::is_always_equal::value} is
\tcode{true} for every \tcode{A} in the set of \tcode{OuterAlloc} and
\tcode{InnerAllocs...}; otherwise, \tcode{false_type}.
\end{itemdescr}

\rSec2[allocator.adaptor.cnstr]{Scoped allocator adaptor constructors}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Value-initializes the \tcode{OuterAlloc} base class and the \tcode{inner} allocator
object.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template<class OuterA2>
  scoped_allocator_adaptor(OuterA2&& outerAlloc, const InnerAllocs&... innerAllocs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the \tcode{OuterAlloc} base class with
\tcode{std::forward<OuterA2>(outerAlloc)} and \tcode{inner} with \tcode{innerAllocs...}
(hence recursively initializing each allocator within the adaptor with the corresponding
allocator from the argument list).

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<OuterAlloc, OuterA2>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes each allocator within the adaptor with the corresponding allocator
from \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Move constructs each allocator within the adaptor with the corresponding allocator
from \tcode{other}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template<class OuterA2>
  scoped_allocator_adaptor(
    const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes each allocator within the adaptor with the corresponding allocator
from \tcode{other}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<OuterAlloc, const OuterA2\&>} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{scoped_allocator_adaptor}!constructor}%
\begin{itemdecl}
template<class OuterA2>
  scoped_allocator_adaptor(scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes each allocator within the adaptor with the corresponding allocator rvalue
from \tcode{other}.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{is_constructible_v<OuterAlloc, OuterA2>} is \tcode{true}.
\end{itemdescr}

\rSec2[allocator.adaptor.members]{Scoped allocator adaptor members}

\pnum
In the \tcode{construct} member functions,
\tcode{\placeholdernc{OUTERMOST}(x)} is \tcode{x} if \tcode{x} does not have an
\tcode{outer_allocator()} member function and
\tcode{\placeholdernc{OUTERMOST}(x.outer_allocator())}
otherwise;
\tcode{\placeholdernc{OUTERMOST_ALLOC_TRAITS}(x)} is
\tcode{allocator_traits<decltype(\placeholdernc{OUTERMOST}(x))>}.
\begin{note} \tcode{\placeholdernc{OUTERMOST}(x)} and
\tcode{\placeholdernc{OUTERMOST_ALLOC_TRAITS}(x)} are recursive operations. It
is incumbent upon the definition of \tcode{outer_allocator()} to ensure that the
recursion terminates. It will terminate for all instantiations of
\tcode{scoped_allocator_adaptor}. \end{note}

\indexlibrarymember{inner_allocator}{scoped_allocator_adaptor}%
\begin{itemdecl}
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*this} if \tcode{sizeof...(InnerAllocs)} is zero; otherwise,
\tcode{inner}.
\end{itemdescr}

\indexlibrarymember{outer_allocator}{scoped_allocator_adaptor}%
\begin{itemdecl}
outer_allocator_type& outer_allocator() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<OuterAlloc\&>(*this)}.
\end{itemdescr}

\indexlibrarymember{outer_allocator}{scoped_allocator_adaptor}%
\begin{itemdecl}
const outer_allocator_type& outer_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{static_cast<const OuterAlloc\&>(*this)}.
\end{itemdescr}

\indexlibrarymember{allocate}{scoped_allocator_adaptor}%
\begin{itemdecl}
[[nodiscard]] pointer allocate(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::allocate(outer_allocator(), n)}.
\end{itemdescr}

\indexlibrarymember{allocate}{scoped_allocator_adaptor}%
\begin{itemdecl}
[[nodiscard]] pointer allocate(size_type n, const_void_pointer hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint)}.
\end{itemdescr}

\indexlibrarymember{deallocate}{scoped_allocator_adaptor}%
\begin{itemdecl}
void deallocate(pointer p, size_type n) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by:
\tcode{allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n);}
\end{itemdescr}

\indexlibrarymember{max_size}{scoped_allocator_adaptor}%
\begin{itemdecl}
size_type max_size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{allocator_traits<OuterAlloc>::max_size(outer_allocator())}.
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T, class... Args>
  void construct(T* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item If \tcode{uses_allocator_v<T, inner_allocator_type>} is \tcode{false} and
\tcode{is_constructible_v<T,\\ Args...>} is \tcode{true}, calls:
\begin{codeblock}
@\placeholdernc{OUTERMOST_ALLOC_TRAITS}@(*this)::construct(
    @\placeholdernc{OUTERMOST}@(*this), p, std::forward<Args>(args)...)
\end{codeblock}

\item Otherwise, if \tcode{uses_allocator_v<T, inner_allocator_type>} is \tcode{true} and
\tcode{is_constructible_v<T, allocator_arg_t, inner_allocator_type\&, Args...>} is \tcode{true}, calls:
\begin{codeblock}
@\placeholdernc{OUTERMOST_ALLOC_TRAITS}@(*this)::construct(
    @\placeholdernc{OUTERMOST}@(*this), p, allocator_arg, inner_allocator(), std::forward<Args>(args)...)
\end{codeblock}

\item Otherwise, if \tcode{uses_allocator_v<T, inner_allocator_type>} is \tcode{true} and
\tcode{is_constructible_v<T, Args..., inner_allocator_type\&>} is \tcode{true}, calls:
\begin{codeblock}
@\placeholdernc{OUTERMOST_ALLOC_TRAITS}@(*this)::construct(
    @\placeholdernc{OUTERMOST}@(*this), p, std::forward<Args>(args)..., inner_allocator())
\end{codeblock}

\item Otherwise, the program is ill-formed.
\begin{note}
An error will result if
\tcode{uses_allocator} evaluates to \tcode{true} but the specific constructor does not take an
allocator. This definition prevents a silent failure to pass an inner allocator to a
contained element.
\end{note}
\end{itemize}

\pnum
\remarks
This function shall not participate in overload resolution if
\tcode{T} is a specialization of \tcode{pair}.
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T1, class T2, class... Args1, class... Args2>
  void construct(pair<T1, T2>* p, piecewise_construct_t, tuple<Args1...> x, tuple<Args2...> y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires All of the types in \tcode{Args1} and \tcode{Args2} shall be
\tcode{CopyConstructible} (\tref{copyconstructible}).

\pnum
\effects Constructs a \tcode{tuple} object \tcode{xprime} from \tcode{x} by the
following rules:
\begin{itemize}
\item If \tcode{uses_allocator_v<T1, inner_allocator_type>} is \tcode{false} and
\tcode{is_constructible_v<T1,\\ Args1...>} is \tcode{true},
then \tcode{xprime} is \tcode{x}.

\item Otherwise, if \tcode{uses_allocator_v<T1, inner_allocator_type>} is \tcode{true}
and
\tcode{is_construct\-ible_v<T1, allocator_arg_t, inner_allocator_type\&, Args1...>}
is
\tcode{true}, then \tcode{xprime} is:
\begin{codeblock}
tuple_cat(
    tuple<allocator_arg_t, inner_allocator_type&>(allocator_arg, inner_allocator()),
    std::move(x))
\end{codeblock}

\item Otherwise, if \tcode{uses_allocator_v<T1, inner_allocator_type>} is
\tcode{true} and
\tcode{is_construct\-ible_v<T1, Args1..., inner_allocator_type\&>} is \tcode{true},
then \tcode{xprime} is:
\begin{codeblock}
tuple_cat(std::move(x), tuple<inner_allocator_type&>(inner_allocator()))
\end{codeblock}

\item Otherwise, the program is ill-formed.
\end{itemize}
and constructs a \tcode{tuple} object \tcode{yprime} from \tcode{y} by the following rules:
\begin{itemize}
\item If \tcode{uses_allocator_v<T2, inner_allocator_type>} is \tcode{false} and
\tcode{is_constructible_v<T2,\\ Args2...>} is \tcode{true}, then \tcode{yprime} is \tcode{y}.

\item Otherwise, if \tcode{uses_allocator_v<T2, inner_allocator_type>} is \tcode{true}
and
\tcode{is_constructible_v<T2, allocator_arg_t, inner_allocator_type\&, Args2...>}
is
\tcode{true}, then \tcode{yprime} is:
\begin{codeblock}
tuple_cat(
    tuple<allocator_arg_t, inner_allocator_type&>(allocator_arg, inner_allocator()),
    std::move(y))
\end{codeblock}

\item Otherwise, if \tcode{uses_allocator_v<T2, inner_allocator_type>} is
\tcode{true} and
\tcode{is_constructible_v<T2, Args2..., inner_allocator_type\&>} is \tcode{true},
then \tcode{yprime} is:
\begin{codeblock}
tuple_cat(std::move(y), tuple<inner_allocator_type&>(inner_allocator()))
\end{codeblock}

\item Otherwise, the program is ill-formed.
\end{itemize}
then calls:
\begin{codeblock}
@\placeholdernc{OUTERMOST_ALLOC_TRAITS}@(*this)::construct(
    @\placeholdernc{OUTERMOST}@(*this), p, piecewise_construct, std::move(xprime), std::move(yprime))
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T1, class T2>
  void construct(pair<T1, T2>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct, tuple<>(), tuple<>());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, U&& x, V&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(std::forward<U>(x)),
          forward_as_tuple(std::forward<V>(y)));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, const pair<U, V>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(x.first),
          forward_as_tuple(x.second));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{construct}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T1, class T2, class U, class V>
  void construct(pair<T1, T2>* p, pair<U, V>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
construct(p, piecewise_construct,
          forward_as_tuple(std::forward<U>(x.first)),
          forward_as_tuple(std::forward<V>(x.second)));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{destroy}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class T>
  void destroy(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{\placeholdernc{OUTERMOST_ALLOC_TRAITS}(*this)::destroy(\placeholdernc{OUTERMOST}(*this), p)}.
\end{itemdescr}

\indexlibrarymember{select_on_container_copy_construction}{scoped_allocator_adaptor}%
\begin{itemdecl}
scoped_allocator_adaptor select_on_container_copy_construction() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A new \tcode{scoped_allocator_adaptor} object where each allocator \tcode{A} in the
adaptor is initialized from the result of calling
\tcode{allocator_traits<A>::select_on_container_copy_construction()} on the
corresponding allocator in \tcode{*this}.
\end{itemdescr}

\rSec2[scoped.adaptor.operators]{Scoped allocator operators}

\indexlibrarymember{operator==}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class OuterA1, class OuterA2, class... InnerAllocs>
  bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{sizeof...(InnerAllocs)} is zero,
\begin{codeblock}
a.outer_allocator() == b.outer_allocator()
\end{codeblock}
otherwise
\begin{codeblock}
a.outer_allocator() == b.outer_allocator() && a.inner_allocator() == b.inner_allocator()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator"!=}{scoped_allocator_adaptor}%
\begin{itemdecl}
template<class OuterA1, class OuterA2, class... InnerAllocs>
  bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(a == b)}.
\end{itemdescr}

\rSec1[function.objects]{Function objects}

\pnum
A \defnx{function object type}{function object!type} is an object
type\iref{basic.types} that can be the type of the
\grammarterm{postfix-expression} in a function call
(\ref{expr.call}, \ref{over.match.call}).\footnote{Such a type is a function
pointer or a class type which has a member \tcode{operator()} or a class type
which has a conversion to a pointer to function.} A \defn{function object} is an
object of a function object type. In the places where one would expect to pass a
pointer to a function to an algorithmic template\iref{algorithms}, the
interface is specified to accept a function object. This not only makes
algorithmic templates work with pointers to functions, but also enables them to
work with arbitrary function objects.

\rSec2[functional.syn]{Header \tcode{<functional>} synopsis}

\indexhdr{functional}%
\begin{codeblock}
namespace std {
  // \ref{func.invoke}, invoke
  template<class F, class... Args>
    invoke_result_t<F, Args...> invoke(F&& f, Args&&... args)
      noexcept(is_nothrow_invocable_v<F, Args...>);

  // \ref{refwrap}, \tcode{reference_wrapper}
  template<class T> class reference_wrapper;

  template<class T> reference_wrapper<T> ref(T&) noexcept;
  template<class T> reference_wrapper<const T> cref(const T&) noexcept;
  template<class T> void ref(const T&&) = delete;
  template<class T> void cref(const T&&) = delete;

  template<class T> reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
  template<class T> reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;

  // \ref{arithmetic.operations}, arithmetic operations
  template<class T = void> struct plus;
  template<class T = void> struct minus;
  template<class T = void> struct multiplies;
  template<class T = void> struct divides;
  template<class T = void> struct modulus;
  template<class T = void> struct negate;
  template<> struct plus<void>;
  template<> struct minus<void>;
  template<> struct multiplies<void>;
  template<> struct divides<void>;
  template<> struct modulus<void>;
  template<> struct negate<void>;

  // \ref{comparisons}, comparisons
  template<class T = void> struct equal_to;
  template<class T = void> struct not_equal_to;
  template<class T = void> struct greater;
  template<class T = void> struct less;
  template<class T = void> struct greater_equal;
  template<class T = void> struct less_equal;
  template<> struct equal_to<void>;
  template<> struct not_equal_to<void>;
  template<> struct greater<void>;
  template<> struct less<void>;
  template<> struct greater_equal<void>;
  template<> struct less_equal<void>;

  // \ref{logical.operations}, logical operations
  template<class T = void> struct logical_and;
  template<class T = void> struct logical_or;
  template<class T = void> struct logical_not;
  template<> struct logical_and<void>;
  template<> struct logical_or<void>;
  template<> struct logical_not<void>;

  // \ref{bitwise.operations}, bitwise operations
  template<class T = void> struct bit_and;
  template<class T = void> struct bit_or;
  template<class T = void> struct bit_xor;
  template<class T = void> struct bit_not;
  template<> struct bit_and<void>;
  template<> struct bit_or<void>;
  template<> struct bit_xor<void>;
  template<> struct bit_not<void>;

  // \ref{func.not_fn}, function template \tcode{not_fn}
  template<class F> @\unspec@ not_fn(F&& f);

  // \ref{func.bind}, bind
  template<class T> struct is_bind_expression;
  template<class T> struct is_placeholder;

  template<class F, class... BoundArgs>
    @\unspec@ bind(F&&, BoundArgs&&...);
  template<class R, class F, class... BoundArgs>
    @\unspec@ bind(F&&, BoundArgs&&...);

  namespace placeholders {
    // \tcode{\placeholder{M}} is the \impldef{number of placeholders for bind expressions} number of placeholders
    @\seebelownc@ _1;
    @\seebelownc@ _2;
               .
               .
               .
    @\seebelownc@ _@\placeholdernc{M}@;
  }

  // \ref{func.memfn}, member function adaptors
  template<class R, class T>
    @\unspec@ mem_fn(R T::*) noexcept;

  // \ref{func.wrap}, polymorphic function wrappers
  class bad_function_call;

  template<class> class function; // not defined
  template<class R, class... ArgTypes> class function<R(ArgTypes...)>;

  template<class R, class... ArgTypes>
    void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;

  template<class R, class... ArgTypes>
    bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
  template<class R, class... ArgTypes>
    bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
  template<class R, class... ArgTypes>
    bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
  template<class R, class... ArgTypes>
    bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

  // \ref{func.search}, searchers
  template<class ForwardIterator, class BinaryPredicate = equal_to<>>
    class default_searcher;

  template<class RandomAccessIterator,
           class Hash = hash<typename iterator_traits<RandomAccessIterator>::value_type>,
           class BinaryPredicate = equal_to<>>
    class boyer_moore_searcher;

  template<class RandomAccessIterator,
           class Hash = hash<typename iterator_traits<RandomAccessIterator>::value_type>,
           class BinaryPredicate = equal_to<>>
    class boyer_moore_horspool_searcher;

  // \ref{unord.hash}, hash function primary template
  template<class T>
    struct hash;

  // \ref{func.bind}, function object binders
  template<class T>
    inline constexpr bool is_bind_expression_v = is_bind_expression<T>::value;
  template<class T>
    inline constexpr int is_placeholder_v = is_placeholder<T>::value;
}
\end{codeblock}

\pnum
\begin{example}
If a \Cpp{} program wants to have a by-element addition of two vectors \tcode{a}
and \tcode{b} containing \tcode{double} and put the result into \tcode{a},
it can do:

\begin{codeblock}
transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
\end{codeblock}
\end{example}

\pnum
\begin{example}
To negate every element of \tcode{a}:

\begin{codeblock}
transform(a.begin(), a.end(), a.begin(), negate<double>());
\end{codeblock}

\end{example}

\rSec2[func.def]{Definitions}

\pnum
The following definitions apply to this Clause:

\pnum
A \defn{call signature} is the name of a return type followed by a
parenthesized comma-separated list of zero or more argument types.

\pnum
A \defn{callable type} is a function object type\iref{function.objects} or a pointer to member.

\pnum
A \defn{callable object} is an object of a callable type.

\pnum
A \defnx{call wrapper type}{call wrapper!type} is a type that holds a callable object
and supports a call operation that forwards to that object.

\pnum
A \defn{call wrapper} is an object of a call wrapper type.

\pnum
A \defn{target object} is the callable object held by a call wrapper.

\rSec2[func.require]{Requirements}

\pnum
\indexlibrary{invoke@\tcode{\placeholder{INVOKE}}}%
Define \tcode{\placeholdernc{INVOKE}(f, t$_1$, t$_2$, $\dotsc$, t$_N$)} as follows:

\begin{itemize}
\item \tcode{(t$_1$.*f)(t$_2$, $\dotsc$, t$_N$)} when \tcode{f} is a pointer to a
member function of a class \tcode{T}
and \tcode{is_base_of_v<T, remove_reference_t<decltype(t$_1$)>>} is \tcode{true};

\item \tcode{(t$_1$.get().*f)(t$_2$, $\dotsc$, t$_N$)} when \tcode{f} is a pointer to a
member function of a class \tcode{T}
and \tcode{remove_cvref_t<decltype(t$_1$)>} is a specialization of \tcode{reference_wrapper};

\item \tcode{((*t$_1$).*f)(t$_2$, $\dotsc$, t$_N$)} when \tcode{f} is a pointer to a
member function of a class \tcode{T}
and \tcode{t$_1$} does not satisfy the previous two items;

\item \tcode{t$_1$.*f} when \tcode{N == 1} and \tcode{f} is a pointer to
data member of a class \tcode{T}
and \tcode{is_base_of_v<T, remove_reference_t<decltype(t$_1$)>>} is \tcode{true};

\item \tcode{t$_1$.get().*f} when \tcode{N == 1} and \tcode{f} is a pointer to
data member of a class \tcode{T}
and \tcode{remove_cvref_t<decltype(t$_1$)>} is a specialization of \tcode{reference_wrapper};

\item \tcode{(*t$_1$).*f} when \tcode{N == 1} and \tcode{f} is a pointer to
data member of a class \tcode{T}
and \tcode{t$_1$} does not satisfy the previous two items;

\item \tcode{f(t$_1$, t$_2$, $\dotsc$, t$_N$)} in all other cases.
\end{itemize}

\pnum
\indexlibrary{invoke@\tcode{\placeholder{INVOKE}}}%
Define \tcode{\placeholdernc{INVOKE}<R>(f, t$_1$, t$_2$, $\dotsc$, t$_N$)} as
\tcode{static_cast<void>(\placeholdernc{INVOKE}(f, t$_1$, t$_2$, $\dotsc$, t$_N$))}
if \tcode{R} is \cv{}~\tcode{void}, otherwise
\tcode{\placeholdernc{INVOKE}(f, t$_1$, t$_2$, $\dotsc$, t$_N$)} implicitly converted
to \tcode{R}.

\pnum
\indextext{call wrapper}%
\indextext{call wrapper!simple}%
\indextext{call wrapper!forwarding}%
Every call wrapper\iref{func.def} shall be
\tcode{MoveConstructible}.
A \defn{forwarding call wrapper} is a
call wrapper that can be called with an arbitrary argument list
and delivers the arguments to the wrapped callable object as references.
This forwarding step shall ensure that rvalue arguments are delivered as rvalue references
and lvalue arguments are delivered as lvalue references.
A \defn{simple call wrapper} is a forwarding call wrapper that is
\tcode{CopyConstructible} and \tcode{CopyAssignable} and
whose copy constructor, move constructor, copy assignment operator,
and move assignment operator do not throw exceptions.
\begin{note}
In a typical implementation
forwarding call wrappers have an overloaded function call
operator of
the form
\begin{codeblock}
template<class... UnBoundArgs>
  R operator()(UnBoundArgs&&... unbound_args) @\textit{cv-qual}@;
\end{codeblock}
\end{note}

\rSec2[func.invoke]{Function template \tcode{invoke}}
\indexlibrary{\idxcode{invoke}}%
\indexlibrary{invoke@\tcode{\placeholder{INVOKE}}}%
\begin{itemdecl}
template<class F, class... Args>
  invoke_result_t<F, Args...> invoke(F&& f, Args&&... args)
    noexcept(is_nothrow_invocable_v<F, Args...>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\placeholdernc{INVOKE}(std::forward<F>(f), std::forward<Args>(args)...)}\iref{func.require}.
\end{itemdescr}

\rSec2[refwrap]{Class template \tcode{reference_wrapper}}

\indexlibrary{\idxcode{reference_wrapper}}%
\indextext{function object!\idxcode{reference_wrapper}}%
\begin{codeblock}
namespace std {
  template<class T> class reference_wrapper {
  public:
    // types
    using type = T;

    // construct/copy/destroy
    template<class U>
      reference_wrapper(U&&) noexcept(@\seebelow@);
    reference_wrapper(const reference_wrapper& x) noexcept;

    // assignment
    reference_wrapper& operator=(const reference_wrapper& x) noexcept;

    // access
    operator T& () const noexcept;
    T& get() const noexcept;

    // invocation
    template<class... ArgTypes>
      invoke_result_t<T&, ArgTypes...> operator()(ArgTypes&&...) const;
  };
  template<class T>
    reference_wrapper(T&) -> reference_wrapper<T>;
}
\end{codeblock}

\pnum
\tcode{reference_wrapper<T>} is a \tcode{CopyConstructible} and \tcode{CopyAssignable} wrapper
around a reference to an object or function of type \tcode{T}.

\pnum
\tcode{reference_wrapper<T>} is a trivially copyable type\iref{basic.types}.

\rSec3[refwrap.const]{\tcode{reference_wrapper} construct/copy/destroy}

\indexlibrary{\idxcode{reference_wrapper}!constructor}%
\begin{itemdecl}
template<class U>
  reference_wrapper(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks Let \tcode{\placeholdernc{FUN}} denote the exposition-only functions
\begin{codeblock}
void @\placeholdernc{FUN}@(T&) noexcept;
void @\placeholdernc{FUN}@(T&&) = delete;
\end{codeblock}
This constructor shall not participate in overload resolution unless
the expression \tcode{\placeholdernc{FUN}(declval<U>())} is well-formed and
\tcode{is_same_v<remove_cvref_t<U>, reference_wrapper>} is \tcode{false}.
The expression inside \tcode{noexcept}
is equivalent to \tcode{noexcept(\placeholdernc{FUN}(declval<U>()))}.

\pnum
\effects Creates a variable \tcode{r}
as if by \tcode{T\& r = std::forward<U>(u)},
then constructs a \tcode{reference_wrapper} object
that stores a reference to \tcode{r}.
\end{itemdescr}

\indexlibrary{\idxcode{reference_wrapper}!constructor}%
\begin{itemdecl}
reference_wrapper(const reference_wrapper& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Constructs a \tcode{reference_wrapper} object that
stores a reference to \tcode{x.get()}.
\end{itemdescr}

\rSec3[refwrap.assign]{\tcode{reference_wrapper} assignment}

\indexlibrarymember{operator=}{reference_wrapper}%
\begin{itemdecl}
reference_wrapper& operator=(const reference_wrapper& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions \tcode{*this} stores a reference to  \tcode{x.get()}.
\end{itemdescr}

\rSec3[refwrap.access]{\tcode{reference_wrapper} access}

\indexlibrarymember{operator T\&}{reference_wrapper}%
\begin{itemdecl}
operator T& () const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns The stored reference.
\end{itemdescr}

\indexlibrarymember{get}{reference_wrapper}%
\begin{itemdecl}
T& get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns The stored reference.
\end{itemdescr}


\rSec3[refwrap.invoke]{\tcode{reference_wrapper} invocation}

\indexlibrarymember{operator()}{reference_wrapper}%
\begin{itemdecl}
template<class... ArgTypes>
  invoke_result_t<T&, ArgTypes...>
    operator()(ArgTypes&&... args) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{\placeholdernc{INVOKE}(get(), std::forward<ArgTypes>(args)...)}.\iref{func.require}
\end{itemdescr}


\rSec3[refwrap.helpers]{\tcode{reference_wrapper} helper functions}

\indexlibrarymember{ref}{reference_wrapper}%
\begin{itemdecl}
template<class T> reference_wrapper<T> ref(T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{reference_wrapper<T>(t)}.
\end{itemdescr}

\indexlibrarymember{ref}{reference_wrapper}%
\begin{itemdecl}
template<class T> reference_wrapper<T> ref(reference_wrapper<T> t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{ref(t.get())}.
\end{itemdescr}

\indexlibrarymember{cref}{reference_wrapper}%
\begin{itemdecl}
template<class T> reference_wrapper<const T> cref(const T& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{reference_wrapper <const T>(t)}.
\end{itemdescr}

\indexlibrarymember{cref}{reference_wrapper}%
\begin{itemdecl}
template<class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{cref(t.get())}.
\end{itemdescr}

\rSec2[arithmetic.operations]{Arithmetic operations}

\pnum
The library provides basic function object classes for all of the arithmetic
operators in the language~(\ref{expr.mul}, \ref{expr.add}).

\rSec3[arithmetic.operations.plus]{Class template \tcode{plus}}

\indexlibrary{\idxcode{plus}}%
\begin{itemdecl}
template<class T = void> struct plus {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{plus}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x + y}.
\end{itemdescr}

\indexlibrary{\idxcode{plus<>}}%
\begin{itemdecl}
template<> struct plus<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) + std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{plus<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) + std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) + std::forward<U>(u)}.
\end{itemdescr}

\rSec3[arithmetic.operations.minus]{Class template \tcode{minus}}

\indexlibrary{\idxcode{minus}}%
\begin{itemdecl}
template<class T = void> struct minus {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{minus}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x - y}.
\end{itemdescr}

\indexlibrary{\idxcode{minus<>}}%
\begin{itemdecl}
template<> struct minus<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) - std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{minus<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) - std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) - std::forward<U>(u)}.
\end{itemdescr}

\rSec3[arithmetic.operations.multiplies]{Class template \tcode{multiplies}}

\indexlibrary{\idxcode{multiplies}}%
\begin{itemdecl}
template<class T = void> struct multiplies {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{multiplies}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x * y}.
\end{itemdescr}

\indexlibrary{\idxcode{multiplies<>}}%
\begin{itemdecl}
template<> struct multiplies<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) * std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{multiplies<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) * std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) * std::forward<U>(u)}.
\end{itemdescr}

\rSec3[arithmetic.operations.divides]{Class template \tcode{divides}}

\indexlibrary{\idxcode{divides}}%
\begin{itemdecl}
template<class T = void> struct divides {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{divides}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x / y}.
\end{itemdescr}

\indexlibrary{\idxcode{divides<>}}%
\begin{itemdecl}
template<> struct divides<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) / std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{divides<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) / std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) / std::forward<U>(u)}.
\end{itemdescr}

\rSec3[arithmetic.operations.modulus]{Class template \tcode{modulus}}

\indexlibrary{\idxcode{modulus}}%
\begin{itemdecl}
template<class T = void> struct modulus {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{modulus}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x \% y}.
\end{itemdescr}

\indexlibrary{\idxcode{modulus<>}}%
\begin{itemdecl}
template<> struct modulus<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) % std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{modulus<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) % std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) \% std::forward<U>(u)}.
\end{itemdescr}

\rSec3[arithmetic.operations.negate]{Class template \tcode{negate}}

\indexlibrary{\idxcode{negate}}%
\begin{itemdecl}
template<class T = void> struct negate {
  constexpr T operator()(const T& x) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{negate}%
\begin{itemdecl}
constexpr T operator()(const T& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{-x}.
\end{itemdescr}

\indexlibrary{\idxcode{negate<>}}%
\begin{itemdecl}
template<> struct negate<void> {
  template<class T> constexpr auto operator()(T&& t) const
    -> decltype(-std::forward<T>(t));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{negate<>}%
\begin{itemdecl}
template<class T> constexpr auto operator()(T&& t) const
    -> decltype(-std::forward<T>(t));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{-std::forward<T>(t)}.
\end{itemdescr}


\rSec2[comparisons]{Comparisons}

\pnum
The library provides basic function object classes for all of the comparison
operators in the language~(\ref{expr.rel}, \ref{expr.eq}).

\pnum
For templates \tcode{less}, \tcode{greater}, \tcode{less_equal}, and
\tcode{greater_equal}, the specializations for any pointer type
yield a strict total order that is consistent among those specializations and
is also consistent with the partial order imposed by
the built-in operators \tcode{<}, \tcode{>}, \tcode{<=}, \tcode{>=}.
\begin{note} When \tcode{a < b} is well-defined
for pointers \tcode{a} and \tcode{b} of type \tcode{P},
this implies \tcode{(a < b) == less<P>(a, b)},
\tcode{(a > b) == greater<P>(a, b)}, and so forth. \end{note}
For template specializations \tcode{less<void>}, \tcode{greater<void>},
\tcode{less_equal<void>}, and \tcode{greater_equal<void>},
if the call operator calls a built-in operator comparing pointers,
the call operator yields a strict total order
that is consistent among those specializations and
is also consistent with the partial order imposed by those built-in operators.

\rSec3[comparisons.equal_to]{Class template \tcode{equal_to}}

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template<class T = void> struct equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{equal_to}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x == y}.
\end{itemdescr}

\indexlibrary{\idxcode{equal_to<>}}%
\begin{itemdecl}
template<> struct equal_to<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) == std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{equal_to<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) == std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) == std::forward<U>(u)}.
\end{itemdescr}

\rSec3[comparisons.not_equal_to]{Class template \tcode{not_equal_to}}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template<class T = void> struct not_equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{not_equal_to}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x != y}.
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to<>}}%
\begin{itemdecl}
template<> struct not_equal_to<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) != std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{not_equal_to<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) != std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) != std::forward<U>(u)}.
\end{itemdescr}

\rSec3[comparisons.greater]{Class template \tcode{greater}}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template<class T = void> struct greater {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{greater}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x > y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater<>}}%
\begin{itemdecl}
template<> struct greater<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) > std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{greater<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) > std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) > std::forward<U>(u)}.
\end{itemdescr}

\rSec3[comparisons.less]{Class template \tcode{less}}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template<class T = void> struct less {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{less}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x < y}.
\end{itemdescr}

\indexlibrary{\idxcode{less<>}}%
\begin{itemdecl}
template<> struct less<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) < std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{less<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) < std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) < std::forward<U>(u)}.
\end{itemdescr}

\rSec3[comparisons.greater_equal]{Class template \tcode{greater_equal}}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template<class T = void> struct greater_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{greater_equal}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x >= y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal<>}}%
\begin{itemdecl}
template<> struct greater_equal<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) >= std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{greater_equal<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) >= std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) >= std::forward<U>(u)}.
\end{itemdescr}

\rSec3[comparisons.less_equal]{Class template \tcode{less_equal}}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template<class T = void> struct less_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{less_equal}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x <= y}.
\end{itemdescr}

\indexlibrary{\idxcode{less_equal<>}}%
\begin{itemdecl}
template<> struct less_equal<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) <= std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{less_equal<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) <= std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) <= std::forward<U>(u)}.
\end{itemdescr}


\rSec2[logical.operations]{Logical operations}

\pnum
The library provides basic function object classes for all of the logical
operators in the language~(\ref{expr.log.and}, \ref{expr.log.or}, \ref{expr.unary.op}).

\rSec3[logical.operations.and]{Class template \tcode{logical_and}}

\indexlibrary{\idxcode{logical_and}}%
\begin{itemdecl}
template<class T = void> struct logical_and {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_and}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x \&\& y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_and<>}}%
\begin{itemdecl}
template<> struct logical_and<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) && std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_and<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) && std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) \&\& std::forward<U>(u)}.
\end{itemdescr}

\rSec3[logical.operations.or]{Class template \tcode{logical_or}}

\indexlibrary{\idxcode{logical_or}}%
\begin{itemdecl}
template<class T = void> struct logical_or {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_or}%
\begin{itemdecl}
constexpr bool operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x || y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_or<>}}%
\begin{itemdecl}
template<> struct logical_or<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) || std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_or<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) || std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) || std::forward<U>(u)}.
\end{itemdescr}

\rSec3[logical.operations.not]{Class template \tcode{logical_not}}

\indexlibrary{\idxcode{logical_not}}%
\begin{itemdecl}
template<class T = void> struct logical_not {
  constexpr bool operator()(const T& x) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_not}%
\begin{itemdecl}
constexpr bool operator()(const T& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!x}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_not<>}}%
\begin{itemdecl}
template<> struct logical_not<void> {
  template<class T> constexpr auto operator()(T&& t) const
    -> decltype(!std::forward<T>(t));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{logical_not<>}%
\begin{itemdecl}
template<class T> constexpr auto operator()(T&& t) const
    -> decltype(!std::forward<T>(t));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!std::forward<T>(t)}.
\end{itemdescr}


\rSec2[bitwise.operations]{Bitwise operations}

\pnum
The library provides basic function object classes for all of the bitwise
operators in the language~(\ref{expr.bit.and}, \ref{expr.or},
\ref{expr.xor}, \ref{expr.unary.op}).

\rSec3[bitwise.operations.and]{Class template \tcode{bit_and}}

\indexlibrary{\idxcode{bit_and}}%
\begin{itemdecl}
template<class T = void> struct bit_and {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_and}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x \& y}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_and<>}}%
\begin{itemdecl}
template<> struct bit_and<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) & std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_and<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) & std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) \& std::forward<U>(u)}.
\end{itemdescr}

\rSec3[bitwise.operations.or]{Class template \tcode{bit_or}}

\indexlibrary{\idxcode{bit_or}}%
\begin{itemdecl}
template<class T = void> struct bit_or {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_or}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x | y}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_or<>}}%
\begin{itemdecl}
template<> struct bit_or<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) | std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_or<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) | std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) | std::forward<U>(u)}.
\end{itemdescr}

\rSec3[bitwise.operations.xor]{Class template \tcode{bit_xor}}

\indexlibrary{\idxcode{bit_xor}}%
\begin{itemdecl}
template<class T = void> struct bit_xor {
  constexpr T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_xor}%
\begin{itemdecl}
constexpr T operator()(const T& x, const T& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{x \caret{} y}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_xor<>}}%
\begin{itemdecl}
template<> struct bit_xor<void> {
  template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) ^ std::forward<U>(u));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_xor<>}%
\begin{itemdecl}
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
    -> decltype(std::forward<T>(t) ^ std::forward<U>(u));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{std::forward<T>(t) \caret{} std::forward<U>(u)}.
\end{itemdescr}

\rSec3[bitwise.operations.not]{Class template \tcode{bit_not}}

\begin{itemdecl}
template<class T = void> struct bit_not {
  constexpr T operator()(const T& x) const;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_not}%
\begin{itemdecl}
constexpr T operator()(const T& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{\~{}x}.
\end{itemdescr}

\indexlibrary{\idxcode{bit_not<>}}%
\begin{itemdecl}
template<> struct bit_not<void> {
  template<class T> constexpr auto operator()(T&& t) const
    -> decltype(~std::forward<T>(t));

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\indexlibrarymember{operator()}{bit_not<>}%
\begin{itemdecl}
template<class T> constexpr auto operator()(T&&) const
    -> decltype(~std::forward<T>(t));
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{\~{}std::forward<T>(t)}.
\end{itemdescr}


\rSec2[func.not_fn]{Function template \tcode{not_fn}}

\indexlibrary{\idxcode{not_fn}}%
\begin{itemdecl}
template<class F> @\unspec@ not_fn(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return \placeholder{call_wrapper}(std::forward<F>(f));}
where \tcode{\placeholder{call_wrapper}} is an exposition only class defined as follows:
\begin{codeblock}
class @\placeholder{call_wrapper}@ {
  using FD = decay_t<F>;
  FD fd;

  explicit @\placeholder{call_wrapper}@(F&& f);

public:
  @\placeholder{call_wrapper}@(@\placeholder{call_wrapper}@&&) = default;
  @\placeholder{call_wrapper}@(const @\placeholder{call_wrapper}@&) = default;

  template<class... Args>
    auto operator()(Args&&...) &
      -> decltype(!declval<invoke_result_t<FD&, Args...>>());

  template<class... Args>
    auto operator()(Args&&...) const&
      -> decltype(!declval<invoke_result_t<const FD&, Args...>>());

  template<class... Args>
    auto operator()(Args&&...) &&
      -> decltype(!declval<invoke_result_t<FD, Args...>>());

  template<class... Args>
    auto operator()(Args&&...) const&&
      -> decltype(!declval<invoke_result_t<const FD, Args...>>());
};
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
explicit @\placeholdernc{call_wrapper}@(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{FD} shall satisfy the \tcode{MoveConstructible} requirements.
\tcode{is_constructible_v<FD, F>} shall be \tcode{true}.
\tcode{fd} shall be a callable object\iref{func.def}.

\pnum
\effects
Initializes \tcode{fd} from \tcode{std::forward<F>(f)}.

\pnum
\throws
Any exception thrown by construction of \tcode{fd}.
\end{itemdescr}

\begin{itemdecl}
template<class... Args>
  auto operator()(Args&&... args) &
    -> decltype(!declval<invoke_result_t<FD&, Args...>>());
template<class... Args>
  auto operator()(Args&&... args) const&
    -> decltype(!declval<invoke_result_t<const FD&, Args...>>());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return !@\placeholdernc{INVOKE}@(fd, std::forward<Args>(args)...);              // see \ref{func.require}
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<class... Args>
  auto operator()(Args&&... args) &&
    -> decltype(!declval<invoke_result_t<FD, Args...>>());
template<class... Args>
  auto operator()(Args&&... args) const&&
    -> decltype(!declval<invoke_result_t<const FD, Args...>>());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return !@\placeholdernc{INVOKE}@(std::move(fd), std::forward<Args>(args)...);   // see \ref{func.require}
\end{codeblock}
\end{itemdescr}

\rSec2[func.bind]{Function object binders}%
\indextext{function object!binders|(}

\pnum
This subclause describes a uniform mechanism for binding
arguments of callable objects.

\rSec3[func.bind.isbind]{Class template \tcode{is_bind_expression}}

\indexlibrary{\idxcode{is_bind_expression}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_bind_expression;  // see below
}
\end{codeblock}

\pnum
The class template \tcode{is_bind_expression} can be used to detect function objects
generated by \tcode{bind}. The function template \tcode{bind}
uses \tcode{is_bind_expression} to detect subexpressions.

\pnum
Instantiations of the \tcode{is_bind_expression} template shall satisfy
the \tcode{UnaryTypeTrait} requirements\iref{meta.rqmts}. The implementation
shall provide a definition that has a base characteristic of
\tcode{true_type} if \tcode{T} is a type returned from \tcode{bind},
otherwise it shall have a base characteristic of \tcode{false_type}.
A program may specialize this template for a user-defined type \tcode{T}
to have a base characteristic of \tcode{true_type} to indicate that
\tcode{T} should be treated as a subexpression in a \tcode{bind} call.

\rSec3[func.bind.isplace]{Class template \tcode{is_placeholder}}

\indexlibrary{\idxcode{is_placeholder}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_placeholder;      // see below
}
\end{codeblock}

\pnum
The class template \tcode{is_placeholder} can be used to detect the standard placeholders
\tcode{_1}, \tcode{_2}, and so on. The function template \tcode{bind} uses
\tcode{is_placeholder} to detect placeholders.

\pnum
Instantiations of the \tcode{is_placeholder} template shall satisfy
the \tcode{UnaryTypeTrait} requirements\iref{meta.rqmts}. The implementation
shall provide a definition that has the base characteristic of
\tcode{integral_constant<int, \placeholder{J}>} if \tcode{T} is the type of
\tcode{std::placeholders::_\placeholder{J}}, otherwise it shall have a
base characteristic of \tcode{integral_constant<int, 0>}. A program
may specialize this template for a user-defined type \tcode{T} to
have a base characteristic of \tcode{integral_constant<int, N>}
with \tcode{N > 0} to indicate that \tcode{T} should be
treated as a placeholder type.

\rSec3[func.bind.bind]{Function template \tcode{bind}}
\indexlibrary{\idxcode{bind}|(}

\pnum
In the text that follows:

\begin{itemize}
\item \tcode{FD} is the type \tcode{decay_t<F>},
\item \tcode{fd} is an lvalue of type \tcode{FD} constructed from \tcode{std::forward<F>(f)},
\item $\tcode{T}_i$ is the $i^\text{th}$ type in the template parameter pack \tcode{BoundArgs},
\item $\tcode{TD}_i$ is the type \tcode{decay_t<$\tcode{T}_i$>},
\item $\tcode{t}_i$ is the $i^\text{th}$ argument in the function parameter pack \tcode{bound_args},
\item $\tcode{td}_i$ is an lvalue of type $\tcode{TD}_i$ constructed from \tcode{std::forward<$\tcode{T}_i$>($\tcode{t}_i$)},
\item $\tcode{U}_j$ is the $j^\text{th}$ deduced type of the \tcode{UnBoundArgs\&\&...} parameter
  of the forwarding call wrapper, and
\item $\tcode{u}_j$ is the $j^\text{th}$ argument associated with $\tcode{U}_j$.
\end{itemize}

\indexlibrary{\idxcode{bind}}%
\begin{itemdecl}
template<class F, class... BoundArgs>
  @\unspec@ bind(F&& f, BoundArgs&&... bound_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_constructible_v<FD, F>} shall be \tcode{true}. For each $\tcode{T}_i$
in \tcode{BoundArgs}, \tcode{is_cons\-tructible_v<$\tcode{TD}_i$, $\tcode{T}_i$>} shall be \tcode{true}.
\tcode{\placeholdernc{INVOKE}(fd, $\tcode{w}_1$, $\tcode{w}_2$, $\dotsc$,
$\tcode{w}_N$)}\iref{func.require} shall be a valid expression for some
values $\tcode{w}_1$, $\tcode{w}_2$, $\dotsc{}$, $\tcode{w}_N$, where
$N$ has the value \tcode{sizeof...(bound_args)}.
The cv-qualifiers \cv{} of the call wrapper \tcode{g},
as specified below, shall be neither \tcode{volatile} nor \tcode{const volatile}.

\pnum\returns
A forwarding call wrapper \tcode{g}\iref{func.require}.
The effect of \tcode{g($\tcode{u}_1$, $\tcode{u}_2$, $\dotsc$, $\tcode{u}_M$)} shall
be
\begin{codeblock}
@\placeholdernc{INVOKE}@(fd, std::forward<@$\tcode{V}_1$@>(@$\tcode{v}_1$@), std::forward<@$\tcode{V}_2$@>(@$\tcode{v}_2$@), @$\dotsc$@, std::forward<@$\tcode{V}_N$@>(@$\tcode{v}_N$@))
\end{codeblock}
where the values and types of the bound
arguments $\tcode{v}_1$, $\tcode{v}_2$, $\dotsc$, $\tcode{v}_N$ are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of \tcode{FD} or of any of the types
$\tcode{TD}_i$ throws an exception.

\pnum
\throws Nothing unless the construction of
\tcode{fd} or of one of the values $\tcode{td}_i$ throws an exception.

\pnum
\remarks The return type shall satisfy the \tcode{MoveConstructible} requirements. If all
of \tcode{FD} and $\tcode{TD}_i$ satisfy the \tcode{CopyConstructible} requirements, then the
return type shall satisfy the \tcode{CopyConstructible} requirements. \begin{note} This implies
that all of \tcode{FD} and $\tcode{TD}_i$ are \tcode{MoveConstructible}. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{bind}}%
\begin{itemdecl}
template<class R, class F, class... BoundArgs>
  @\unspec@ bind(F&& f, BoundArgs&&... bound_args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{is_constructible_v<FD, F>} shall be \tcode{true}. For each $\tcode{T}_i$
in \tcode{BoundArgs}, \tcode{is_con\-structible_v<$\tcode{TD}_i$, $\tcode{T}_i$>} shall be \tcode{true}.
\tcode{\placeholdernc{INVOKE}(fd, $\tcode{w}_1$, $\tcode{w}_2$, $\dotsc$, $\tcode{w}_N$)} shall be  a valid
expression for some
values $\tcode{w}_1$, $\tcode{w}_2$, $\dotsc$, $\tcode{w}_N$, where
$N$ has the value \tcode{sizeof...(bound_args)}.
The cv-qualifiers \cv{} of the call wrapper \tcode{g},
as specified below, shall be neither \tcode{volatile} nor \tcode{const volatile}.

\pnum
\returns
A forwarding call wrapper \tcode{g}\iref{func.require}.
The effect of
\tcode{g($\tcode{u}_1$, $\tcode{u}_2$, $\dotsc$, $\tcode{u}_M$)} shall be
\begin{codeblock}
@\placeholdernc{INVOKE}@<R>(fd, std::forward<@$\tcode{V}_1$@>(@$\tcode{v}_1$@), std::forward<@$\tcode{V}_2$@>(@$\tcode{v}_2$@), @$\dotsc$@, std::forward<@$\tcode{V}_N$@>(@$\tcode{v}_N$@))
\end{codeblock}
where the values and types of the bound
arguments $\tcode{v}_1$, $\tcode{v}_2$, $\dotsc$, $\tcode{v}_N$ are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of \tcode{FD} or of any of the types
$\tcode{TD}_i$ throws an exception.

\pnum
\throws Nothing unless the construction of
\tcode{fd} or of one of the values $\tcode{td}_i$ throws an exception.

\pnum
\remarks The return type shall satisfy the \tcode{MoveConstructible} requirements. If all
of \tcode{FD} and $\tcode{TD}_i$ satisfy the \tcode{CopyConstructible} requirements, then the
return type shall satisfy the \tcode{CopyConstructible} requirements. \begin{note} This implies
that all of \tcode{FD} and $\tcode{TD}_i$ are \tcode{MoveConstructible}. \end{note}
\end{itemdescr}

\pnum
\indextext{bound arguments}%
The values of the \techterm{bound arguments} $\tcode{v}_1$, $\tcode{v}_2$, $\dotsc$, $\tcode{v}_N$ and their
corresponding types $\tcode{V}_1$, $\tcode{V}_2$, $\dotsc$, $\tcode{V}_N$ depend on the
types $\tcode{TD}_i$ derived from
the call to \tcode{bind} and the
cv-qualifiers \cv{} of the call wrapper \tcode{g} as follows:

\begin{itemize}
\item if $\tcode{TD}_i$ is \tcode{reference_wrapper<T>}, the
argument is \tcode{$\tcode{td}_i$.get()} and its type $\tcode{V}_i$ is \tcode{T\&};

\item if the value of \tcode{is_bind_expression_v<$\tcode{TD}_i$>}
is \tcode{true}, the argument is \tcode{$\tcode{td}_i$(std::forward<$\tcode{U}_j$>($\tcode{u}_j$)...)}  and its
type $\tcode{V}_i$ is
\tcode{invoke_result_t<$\tcode{TD}_i$ \cv{} \&, $\tcode{U}_j$...>\&\&};

\item if the value \tcode{j} of \tcode{is_placeholder_v<$\tcode{TD}_i$>}
is not zero, the  argument is \tcode{std::forward<$\tcode{U}_j$>($\tcode{u}_j$)}
and its type $\tcode{V}_i$
is \tcode{$\tcode{U}_j$\&\&};

\item otherwise, the value is $\tcode{td}_i$ and its type $\tcode{V}_i$
is \tcode{$\tcode{TD}_i$ \cv{} \&}.
\end{itemize}
\indexlibrary{\idxcode{bind}|)}%

\rSec3[func.bind.place]{Placeholders}

\indexlibrary{\idxcode{placeholders}}%
\indexlibrary{1@\tcode{_1}}%
\begin{codeblock}
namespace std::placeholders {
  // M is the \impldef{number of placeholders for bind expressions} number of placeholders
  @\seebelow@ _1;
  @\seebelow@ _2;
              .
              .
              .
  @\seebelow@ _M;
}
\end{codeblock}

\pnum
All placeholder types shall be \tcode{DefaultConstructible} and
\tcode{CopyConstructible}, and their default constructors and copy/move
constructors shall not throw exceptions. It is \impldef{assignability of placeholder
objects} whether
placeholder types are \tcode{CopyAssignable}. \tcode{CopyAssignable} placeholders' copy
assignment operators shall not throw exceptions.

\pnum
Placeholders should be defined as:
\begin{codeblock}
inline constexpr @\unspec@ _1{};
\end{codeblock}
If they are not, they shall be declared as:
\begin{codeblock}
extern @\unspec@ _1;
\end{codeblock}%
\indextext{function object!binders|)}

\rSec2[func.memfn]{Function template \tcode{mem_fn}}%
\indextext{function object!\idxcode{mem_fn}|(}

\indexlibrary{\idxcode{mem_fn}}%
\begin{itemdecl}
template<class R, class T> @\unspec@ mem_fn(R T::* pm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A simple call wrapper\iref{func.def} \tcode{fn}
such that the expression \tcode{fn(t, a$_2$, $\dotsc$, a$_N$)} is equivalent
to \tcode{\placeholdernc{INVOKE}(pm, t, a$_2$, $\dotsc$, a$_N$)}\iref{func.require}.
\end{itemdescr}
\indextext{function object!\idxcode{mem_fn}|)}

\rSec2[func.wrap]{Polymorphic function wrappers}%
\indextext{function object!wrapper|(}

\pnum
This subclause describes a polymorphic wrapper class that
encapsulates arbitrary callable objects.

\rSec3[func.wrap.badcall]{Class \tcode{bad_function_call}}%
\indexlibrary{\idxcode{bad_function_call}}%

\pnum
An exception of type \tcode{bad_function_call} is thrown by
\tcode{function::operator()}\iref{func.wrap.func.inv}
when the function wrapper object has no target.

\begin{codeblock}
namespace std {
  class bad_function_call : public exception {
  public:
    // \ref{func.wrap.badcall.const}, constructor
    bad_function_call() noexcept;
  };
}
\end{codeblock}

\rSec4[func.wrap.badcall.const]{\tcode{bad_function_call} constructor}

\indexlibrary{\idxcode{bad_function_call}!constructor}%
\indexlibrarymember{what}{bad_function_call}%
\begin{itemdecl}
bad_function_call() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Constructs a \tcode{bad_function_call} object.
\end{itemdescr}

\begin{itemdescr}
\pnum\postconditions  \tcode{what()} returns an
\impldef{return value of \tcode{bad_function_call::what}} \ntbs{}.
\end{itemdescr}

\rSec3[func.wrap.func]{Class template \tcode{function}}
\indexlibrary{\idxcode{function}}%

\begin{codeblock}
namespace std {
  template<class> class function; // not defined

  template<class R, class... ArgTypes>
  class function<R(ArgTypes...)> {
  public:
    using result_type = R;

    // \ref{func.wrap.func.con}, construct/copy/destroy
    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&);
    function(function&&);
    template<class F> function(F);

    function& operator=(const function&);
    function& operator=(function&&);
    function& operator=(nullptr_t) noexcept;
    template<class F> function& operator=(F&&);
    template<class F> function& operator=(reference_wrapper<F>) noexcept;

    ~function();

    // \ref{func.wrap.func.mod}, function modifiers
    void swap(function&) noexcept;

    // \ref{func.wrap.func.cap}, function capacity
    explicit operator bool() const noexcept;

    // \ref{func.wrap.func.inv}, function invocation
    R operator()(ArgTypes...) const;

    // \ref{func.wrap.func.targ}, function target access
    const type_info& target_type() const noexcept;
    template<class T>       T* target() noexcept;
    template<class T> const T* target() const noexcept;
  };

  template<class R, class... ArgTypes>
    function(R(*)(ArgTypes...)) -> function<R(ArgTypes...)>;

  template<class F> function(F) -> function<@\seebelow@>;

  // \ref{func.wrap.func.nullptr}, Null pointer comparisons
  template<class R, class... ArgTypes>
    bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

  template<class R, class... ArgTypes>
    bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

  template<class R, class... ArgTypes>
    bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

  template<class R, class... ArgTypes>
    bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

  // \ref{func.wrap.func.alg}, specialized algorithms
  template<class R, class... ArgTypes>
    void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
}
\end{codeblock}

\pnum
The \tcode{function} class template provides polymorphic wrappers that
generalize the notion of a function pointer. Wrappers can store, copy,
and call arbitrary callable objects\iref{func.def}, given a call
signature\iref{func.def}, allowing functions to be first-class objects.

\pnum
\indextext{callable type}%
A callable type\iref{func.def} \tcode{F}
is \defn{Lvalue-Callable} for argument
types \tcode{ArgTypes}
and return type \tcode{R}
if the expression
\tcode{\placeholdernc{INVOKE}<R>(declval<F\&>(), declval<ArgTypes>()...)},
considered as an unevaluated operand\iref{expr.prop}, is
well-formed\iref{func.require}.

\pnum
The \tcode{function} class template is a call
wrapper\iref{func.def} whose call signature\iref{func.def}
is \tcode{R(ArgTypes...)}.

\pnum
\begin{note}
The types deduced by the deduction guides for \tcode{function}
may change in future versions of this International Standard.
\end{note}

\rSec4[func.wrap.func.con]{\tcode{function} construct/copy/destroy}

\indexlibrary{\idxcode{function}!constructor}%
\begin{itemdecl}
function() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\postconditions \tcode{!*this}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!constructor}%
\begin{itemdecl}
function(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{!*this}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!constructor}%
\begin{itemdecl}
function(const function& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{!*this} if \tcode{!f}; otherwise,
\tcode{*this} targets a copy of \tcode{f.target()}.

\pnum
\throws Shall not throw exceptions if \tcode{f}'s target is
a specialization of \tcode{reference_wrapper} or
a function pointer. Otherwise, may throw \tcode{bad_alloc}
or any exception thrown by the copy constructor of the stored callable object.
\begin{note} Implementations should avoid the use of
dynamically allocated memory for small callable objects, for example, where
\tcode{f}'s target is an object holding only a pointer or reference
to an object and a member function pointer. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{function}!constructor}%
\begin{itemdecl}
function(function&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions If \tcode{!f}, \tcode{*this} has no target;
otherwise, the target of \tcode{*this} is equivalent to
the target of \tcode{f} before the construction, and
\tcode{f} is in a valid state with an unspecified value.

\pnum
\throws Shall not throw exceptions if \tcode{f}'s target is
a specialization of \tcode{reference_wrapper} or
a function pointer. Otherwise, may throw \tcode{bad_alloc} or
any exception thrown by the copy or move constructor
of the stored callable object.
\begin{note} Implementations should avoid the use of
dynamically allocated memory for small callable objects, for example,
where \tcode{f}'s target is an object holding only a pointer or reference
to an object and a member function pointer. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{function}!constructor}%
\begin{itemdecl}
template<class F> function(F f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{F} shall be \tcode{CopyConstructible}.

\pnum
\remarks This constructor template shall not participate in overload resolution unless
\tcode{F} is Lvalue-Callable\iref{func.wrap.func} for argument types
\tcode{ArgTypes...} and return type \tcode{R}.

\pnum
\postconditions \tcode{!*this} if any of the following hold:
\begin{itemize}
\item \tcode{f} is a null function pointer value.
\item \tcode{f} is a null member pointer value.
\item \tcode{F} is an instance of the \tcode{function} class template, and
  \tcode{!f}.
\end{itemize}

\pnum
Otherwise, \tcode{*this} targets a copy of \tcode{f}
initialized with \tcode{std::move(f)}.
\begin{note} Implementations should avoid the use of
dynamically allocated memory for small callable objects, for example,
where \tcode{f} is an object holding only a pointer or
reference to an object and a member function pointer. \end{note}

\pnum
\throws Shall not throw exceptions when \tcode{f} is a function pointer
or a \tcode{reference_wrapper<T>} for some \tcode{T}. Otherwise,
may throw \tcode{bad_alloc} or any exception thrown by \tcode{F}'s copy
or move constructor.
\end{itemdescr}


\begin{itemdecl}
template<class F> function(F) -> function<@\seebelow@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This deduction guide participates in overload resolution only if
\tcode{\&F::operator()} is well-formed when treated as an unevaluated operand.
In that case, if \tcode{decltype(\&F::operator())} is of the form
\tcode{R(G::*)(A...)}~\cv{}~\tcode{\opt{\&}~\opt{noexcept}}
for a class type \tcode{G}, then the deduced type is \tcode{function<R(A...)>}.

\pnum
\begin{example}
\begin{codeblock}
void f() {
  int i{5};
  function g = [&](double) { return i; }; // deduces \tcode{function<int(double)>}
}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator=}{function}%
\begin{itemdecl}
function& operator=(const function& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{function(f).swap(*this);}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{function}%
\begin{itemdecl}
function& operator=(function&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Replaces the target of \tcode{*this}
with the target of \tcode{f}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{function}%
\begin{itemdecl}
function& operator=(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If \tcode{*this != nullptr}, destroys the target of \tcode{this}.

\pnum\postconditions \tcode{!(*this)}.

\pnum\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{function}%
\begin{itemdecl}
template<class F> function& operator=(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects As if by: \tcode{function(std::forward<F>(f)).swap(*this);}

\pnum\returns \tcode{*this}.

\pnum\remarks This assignment operator shall not participate in overload
resolution unless \tcode{decay_t<F>} is
Lvalue-Callable\iref{func.wrap.func} for argument types \tcode{ArgTypes...} and
return type \tcode{R}.
\end{itemdescr}

\indexlibrarymember{operator=}{function}%
\begin{itemdecl}
template<class F> function& operator=(reference_wrapper<F> f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects As if by: \tcode{function(f).swap(*this);}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{function}!destructor}%
\begin{itemdecl}
~function();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If \tcode{*this != nullptr}, destroys the target of \tcode{this}.
\end{itemdescr}

\rSec4[func.wrap.func.mod]{\tcode{function} modifiers}

\indexlibrarymember{swap}{function}%
\begin{itemdecl}
void swap(function& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Interchanges the targets of \tcode{*this} and \tcode{other}.
\end{itemdescr}

\rSec4[func.wrap.func.cap]{\tcode{function} capacity}

\indexlibrarymember{operator bool}{function}%
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if \tcode{*this} has a target, otherwise \tcode{false}.
\end{itemdescr}

\rSec4[func.wrap.func.inv]{\tcode{function} invocation}

\indexlibrary{\idxcode{function}!invocation}%
\indexlibrarymember{operator()}{function}%
\begin{itemdecl}
R operator()(ArgTypes... args) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\placeholdernc{INVOKE}<R>(f, std::forward<ArgTypes>(args)...)}\iref{func.require},
where \tcode{f} is the target object\iref{func.def} of \tcode{*this}.

\pnum\throws
\tcode{bad_function_call} if \tcode{!*this}; otherwise, any
exception thrown by the wrapped callable object.
\end{itemdescr}

\rSec4[func.wrap.func.targ]{\tcode{function} target access}

\indexlibrarymember{target_type}{function}%
\begin{itemdecl}
const type_info& target_type() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns If \tcode{*this} has a target of type \tcode{T},
  \tcode{typeid(T)}; otherwise, \tcode{typeid(void)}.
\end{itemdescr}

\indexlibrarymember{target}{function}%
\begin{itemdecl}
template<class T>       T* target() noexcept;
template<class T> const T* target() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns If \tcode{target_type() == typeid(T)}
a pointer to the stored function target; otherwise a null pointer.
\end{itemdescr}

\rSec4[func.wrap.func.nullptr]{null pointer comparison functions}

\indexlibrarymember{operator==}{function}%
\begin{itemdecl}
template<class R, class... ArgTypes>
  bool operator==(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template<class R, class... ArgTypes>
  bool operator==(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{!f}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{function}%
\begin{itemdecl}
template<class R, class... ArgTypes>
  bool operator!=(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template<class R, class... ArgTypes>
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{(bool)f}.
\end{itemdescr}

\rSec4[func.wrap.func.alg]{specialized algorithms}

\indexlibrarymember{swap}{function}%
\begin{itemdecl}
template<class R, class... ArgTypes>
  void swap(function<R(ArgTypes...)>& f1, function<R(ArgTypes...)>& f2) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects As if by: \tcode{f1.swap(f2);}
\end{itemdescr}%
\indextext{function object!wrapper|)}

\rSec2[func.search]{Searchers}

\pnum
This subclause provides function object types\iref{function.objects} for
operations that search for a sequence \range{pat\textunderscore\nobreak first}{pat_last} in another
sequence \range{first}{last} that is provided to the object's function call
operator.  The first sequence (the pattern to be searched for) is provided to
the object's constructor, and the second (the sequence to be searched) is
provided to the function call operator.

\pnum
Each specialization of a class template specified in this subclause \ref{func.search} shall satisfy the \tcode{CopyConstructible} and \tcode{CopyAssignable} requirements.
Template parameters named
\begin{itemize}
\item \tcode{ForwardIterator},
\item \tcode{ForwardIterator1},
\item \tcode{ForwardIterator2},
\item \tcode{RandomAccessIterator},
\item \tcode{RandomAccessIterator1},
\item \tcode{RandomAccessIterator2}, and
\item \tcode{BinaryPredicate}
\end{itemize}
of templates specified in this subclause
\ref{func.search} shall satisfy the same requirements and semantics as
specified in \ref{algorithms.general}.
Template parameters named \tcode{Hash} shall satisfy the \tcode{Hash}
requirements (\tref{hash}).

\pnum
The Boyer-Moore searcher implements the Boyer-Moore search algorithm.
The Boyer-Moore-Horspool searcher implements the Boyer-Moore-Horspool search algorithm.
In general, the Boyer-Moore searcher will use more memory and give better runtime performance than Boyer-Moore-Horspool.

\rSec3[func.search.default]{Class template \tcode{default_searcher}}

\indexlibrary{\idxcode{default_searcher}}%
\begin{codeblock}
template<class ForwardIterator1, class BinaryPredicate = equal_to<>>
  class default_searcher {
  public:
    default_searcher(ForwardIterator1 pat_first, ForwardIterator1 pat_last,
                     BinaryPredicate pred = BinaryPredicate());

    template<class ForwardIterator2>
      pair<ForwardIterator2, ForwardIterator2>
        operator()(ForwardIterator2 first, ForwardIterator2 last) const;

  private:
    ForwardIterator1 pat_first_;        // \expos
    ForwardIterator1 pat_last_;         // \expos
    BinaryPredicate pred_;              // \expos
  };
\end{codeblock}

\indexlibrary{\idxcode{default_searcher}!constructor}%
\begin{itemdecl}
default_searcher(ForwardIterator pat_first, ForwardIterator pat_last,
                 BinaryPredicate pred = BinaryPredicate());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
% FIXME: The mbox prevents TeX from adding a bizarre hyphen after pat_last_.
Constructs a \tcode{default_searcher} object, initializing \tcode{pat_first_}
with \tcode{pat_first}, \mbox{\tcode{pat_last_}} with \tcode{pat_last}, and
\tcode{pred_} with \tcode{pred}.

\pnum
\throws
Any exception thrown by the copy constructor of \tcode{BinaryPredicate} or
\tcode{ForwardIterator1}.
\end{itemdescr}

\indexlibrarymember{operator()}{default_searcher}%
\begin{itemdecl}
template<class ForwardIterator2>
  pair<ForwardIterator2, ForwardIterator2>
    operator()(ForwardIterator2 first, ForwardIterator2 last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns a pair of iterators \tcode{i} and \tcode{j} such that
\begin{itemize}
\item \tcode{i == search(first, last, pat_first_, pat_last_, pred_)}, and
\item if \tcode{i == last}, then \tcode{j == last},
otherwise \tcode{j == next(i, distance(pat_first_, pat_last_))}.
\end{itemize}
\end{itemdescr}

\rSec3[func.search.bm]{Class template \tcode{boyer_moore_searcher}}

\indexlibrary{\idxcode{boyer_moore_searcher}}%
\begin{codeblock}
template<class RandomAccessIterator1,
         class Hash = hash<typename iterator_traits<RandomAccessIterator1>::value_type>,
         class BinaryPredicate = equal_to<>>
  class boyer_moore_searcher {
  public:
    boyer_moore_searcher(RandomAccessIterator1 pat_first,
                         RandomAccessIterator1 pat_last,
                         Hash hf = Hash(),
                         BinaryPredicate pred = BinaryPredicate());

    template<class RandomAccessIterator2>
      pair<RandomAccessIterator2, RandomAccessIterator2>
        operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

  private:
    RandomAccessIterator1 pat_first_;   // \expos
    RandomAccessIterator1 pat_last_;    // \expos
    Hash hash_;                         // \expos
    BinaryPredicate pred_;              // \expos
  };
\end{codeblock}

\indexlibrary{\idxcode{boyer_moore_searcher}!constructor}%
\begin{itemdecl}
boyer_moore_searcher(RandomAccessIterator1 pat_first,
                     RandomAccessIterator1 pat_last,
                     Hash hf = Hash(),
                     BinaryPredicate pred = BinaryPredicate());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The value type of \tcode{RandomAccessIterator1} shall satisfy the \tcode{DefaultConstructible} requirements,
the \tcode{CopyConstructible} requirements, and the \tcode{CopyAssignable} requirements.

\pnum
\requires
For any two values \tcode{A} and \tcode{B} of the type \tcode{iterator_traits<RandomAccessIterator1>::val\-ue_type},
if \tcode{pred(A, B) == true}, then \tcode{hf(A) == hf(B)} shall be \tcode{true}.

\pnum
\effects
Constructs a \tcode{boyer_moore_searcher} object, initializing \tcode{pat_first_} with \tcode{pat_first},
\tcode{pat_last_} with \tcode{pat_last}, \tcode{hash_} with \tcode{hf}, and \tcode{pred_} with \tcode{pred}.

\pnum
\throws
Any exception thrown by the copy constructor of \tcode{RandomAccessIterator1},
or by the default constructor, copy constructor, or the copy assignment operator of the value type of \tcode{RandomAccess\-Iterator1},
or the copy constructor or \tcode{operator()} of \tcode{BinaryPredicate} or \tcode{Hash}.
May throw \tcode{bad_alloc} if additional memory needed for internal data structures cannot be allocated.
\end{itemdescr}

\indexlibrarymember{operator()}{boyer_moore_searcher}%
\begin{itemdecl}
template<class RandomAccessIterator2>
  pair<RandomAccessIterator2, RandomAccessIterator2>
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator1} and \tcode{RandomAccessIterator2} shall have the same value type.

\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
A pair of iterators \tcode{i} and \tcode{j} such that
\begin{itemize}
\item \tcode{i} is the first iterator
in the range \range{first}{last - (pat_last_ - pat_first_)} such that
for every non-negative integer \tcode{n} less than \tcode{pat_last_ - pat_first_}
the following condition holds:
\tcode{pred(*(i + n), *(pat_first_ + n)) != false}, and
\item \tcode{j == next(i, distance(pat_first_, pat_last_))}.
\end{itemize}
Returns \tcode{make_pair(first, first)} if \range{pat_first_}{pat_last_} is empty,
otherwise returns \tcode{make_pair(last, last)} if no such iterator is found.

\pnum
\complexity
At most \tcode{(last - first) * (pat_last_ - pat_first_)} applications of the predicate.
\end{itemdescr}

\rSec3[func.search.bmh]{Class template \tcode{boyer_moore_horspool_searcher}}

\indexlibrary{\idxcode{boyer_moore_horspool_searcher}}%
\begin{codeblock}
template<class RandomAccessIterator1,
         class Hash = hash<typename iterator_traits<RandomAccessIterator1>::value_type>,
         class BinaryPredicate = equal_to<>>
  class boyer_moore_horspool_searcher {
  public:
    boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                                  RandomAccessIterator1 pat_last,
                                  Hash hf = Hash(),
                                  BinaryPredicate pred = BinaryPredicate());

    template<class RandomAccessIterator2>
      pair<RandomAccessIterator2, RandomAccessIterator2>
        operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

  private:
    RandomAccessIterator1 pat_first_;   // \expos
    RandomAccessIterator1 pat_last_;    // \expos
    Hash hash_;                         // \expos
    BinaryPredicate pred_;              // \expos
  };
\end{codeblock}

\indexlibrary{\idxcode{boyer_moore_horspool_searcher}!constructor}%
\begin{itemdecl}
boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                              RandomAccessIterator1 pat_last,
                              Hash hf = Hash(),
                              BinaryPredicate pred = BinaryPredicate());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The value type of \tcode{RandomAccessIterator1} shall satisfy the \tcode{DefaultConstructible},
\tcode{Copy\-Constructible}, and \tcode{CopyAssignable} requirements.

\pnum
\requires
For any two values \tcode{A} and \tcode{B} of the type \tcode{iterator_traits<RandomAccessIterator1>::val\-ue_type},
if \tcode{pred(A, B) == true}, then \tcode{hf(A) == hf(B)} shall be \tcode{true}.

\pnum
\effects
Constructs a \tcode{boyer_moore_horspool_searcher} object, initializing \tcode{pat_first_} with \tcode{pat_first},
\tcode{pat_last_} with \tcode{pat_last}, \tcode{hash_} with \tcode{hf}, and \tcode{pred_} with \tcode{pred}.

\pnum
\throws
Any exception thrown by the copy constructor of \tcode{RandomAccessIterator1},
or by the default constructor, copy constructor, or the copy assignment operator of the value type of \tcode{RandomAccess\-Iterator1}
or the copy constructor or \tcode{operator()} of \tcode{BinaryPredicate} or \tcode{Hash}.
May throw \tcode{bad_alloc} if additional memory needed for internal data structures cannot be allocated.
\end{itemdescr}

\indexlibrarymember{operator()}{boyer_moore_horspool_searcher}%
\begin{itemdecl}
template<class RandomAccessIterator2>
  pair<RandomAccessIterator2, RandomAccessIterator2>
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{RandomAccessIterator1} and \tcode{RandomAccessIterator2} shall have the same value type.

\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
A pair of iterators \tcode{i} and \tcode{j} such that
\begin{itemize}
\item \tcode{i} is the first iterator \tcode{i} in the range
\range{first}{last - (pat_last_ - pat_first_)} such that
for every non-negative integer \tcode{n} less than \tcode{pat_last_ - pat_first_}
the following condition holds:
\tcode{pred(*(i + n), *(pat_first_ + n)) != false}, and
\item \tcode{j == next(i, distance(pat_first_, pat_last_))}.
\end{itemize}
Returns \tcode{make_pair(first, first)} if \range{pat_first_}{pat_last_} is empty,
otherwise returns \tcode{make_pair(last, last)} if no such iterator is found.

\pnum
\complexity
At most \tcode{(last - first) * (pat_last_ - pat_first_)} applications of the predicate.
\end{itemdescr}

\rSec2[unord.hash]{Class template \tcode{hash}}

\pnum
\indexlibrary{\idxcode{hash}}%
\indextext{\idxcode{hash}!instantiation restrictions}%
The unordered associative containers defined in \ref{unord} use
specializations of the class template \tcode{hash}\iref{functional.syn}
as the default hash function.

\pnum
Each specialization of \tcode{hash} is either enabled or disabled,
as described below.
\begin{note}
Enabled specializations meet the \tcode{Hash} requirements, and
disabled specializations do not.
\end{note}
Each header that declares the template \tcode{hash}
provides enabled specializations of \tcode{hash} for \tcode{nullptr_t} and
all cv-unqualified arithmetic, enumeration, and pointer types.
For any type \tcode{Key} for which neither the library nor the user provides
an explicit or partial specialization of the class template \tcode{hash},
\tcode{hash<Key>} is disabled.

\pnum
If the library provides an explicit or partial specialization of \tcode{hash<Key>},
that specialization is enabled except as noted otherwise,
and its member functions are \tcode{noexcept} except as noted otherwise.

\pnum
If \tcode{H} is a disabled specialization of \tcode{hash},
these values are \tcode{false}:
\tcode{is_default_constructible_v<H>},
\tcode{is_copy_constructible_v<H>},
\tcode{is_move_constructible_v<H>},
\tcode{is_copy_assignable_v<H>}, and
\tcode{is_move_assignable_v<H>}.
Disabled specializations of \tcode{hash}
are not function object types\iref{function.objects}.
\begin{note}
This means that the specialization of \tcode{hash} exists, but
any attempts to use it as a \tcode{Hash} will be ill-formed.
\end{note}

\pnum
An enabled specialization \tcode{hash<Key>} will:
\begin{itemize}
\item satisfy the \tcode{Hash} requirements (\tref{hash}),
with \tcode{Key} as the function
call argument type, the \tcode{Default\-Constructible} requirements (\tref{defaultconstructible}),
the \tcode{CopyAssignable} requirements (\tref{copyassignable}),
\item be swappable\iref{swappable.requirements} for lvalues,
\item satisfy the requirement that if \tcode{k1 == k2} is \tcode{true}, \tcode{h(k1) == h(k2)} is
also \tcode{true}, where \tcode{h} is an object of type \tcode{hash<Key>} and \tcode{k1} and \tcode{k2}
are objects of type \tcode{Key};
\item satisfy the requirement that the expression \tcode{h(k)}, where \tcode{h}
is an object of type \tcode{hash<Key>} and \tcode{k} is an object of type
\tcode{Key}, shall not throw an exception unless \tcode{hash<Key>} is a
user-defined specialization that depends on at least one user-defined type.
\end{itemize}

\rSec1[meta]{Metaprogramming and type traits}

\pnum
This subclause describes components used by \Cpp{} programs, particularly in
templates, to support the widest possible range of types, optimise
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible \Cpp{} types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.

\pnum
\indextext{signal-safe!type traits}%
All functions specified in this subclause are signal-safe\iref{support.signal}.

\rSec2[meta.rqmts]{Requirements}

\pnum
A \defn{UnaryTypeTrait} describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be \tcode{DefaultConstructible},
\tcode{CopyConstructible},
and publicly and unambiguously derived, directly or indirectly, from
its \defn{base characteristic}, which is
a specialization of the template
\tcode{integral_constant}\iref{meta.help}, with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular property being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the \tcode{UnaryTypeTrait}.

\pnum
A \defn{BinaryTypeTrait} describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be \tcode{DefaultConstructible}, \tcode{CopyConstructible},
and publicly and unambiguously derived, directly or
indirectly, from
its \term{base characteristic}, which is a specialization
of the template
\tcode{integral_constant}\iref{meta.help}, with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular relationship being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the \tcode{BinaryTypeTrait}.

\pnum
A \defn{TransformationTrait}
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named \tcode{type}, which shall be a synonym for the modified type.

\rSec2[meta.type.synop]{Header \tcode{<type_traits>} synopsis}

\indexhdr{type_traits}%
\begin{codeblock}
namespace std {
  // \ref{meta.help}, helper class
  template<class T, T v> struct integral_constant;

  template<bool B>
    using bool_constant = integral_constant<bool, B>;
  using true_type  = bool_constant<true>;
  using false_type = bool_constant<false>;

  // \ref{meta.unary.cat}, primary type categories
  template<class T> struct is_void;
  template<class T> struct is_null_pointer;
  template<class T> struct is_integral;
  template<class T> struct is_floating_point;
  template<class T> struct is_array;
  template<class T> struct is_pointer;
  template<class T> struct is_lvalue_reference;
  template<class T> struct is_rvalue_reference;
  template<class T> struct is_member_object_pointer;
  template<class T> struct is_member_function_pointer;
  template<class T> struct is_enum;
  template<class T> struct is_union;
  template<class T> struct is_class;
  template<class T> struct is_function;

  // \ref{meta.unary.comp}, composite type categories
  template<class T> struct is_reference;
  template<class T> struct is_arithmetic;
  template<class T> struct is_fundamental;
  template<class T> struct is_object;
  template<class T> struct is_scalar;
  template<class T> struct is_compound;
  template<class T> struct is_member_pointer;

  // \ref{meta.unary.prop}, type properties
  template<class T> struct is_const;
  template<class T> struct is_volatile;
  template<class T> struct is_trivial;
  template<class T> struct is_trivially_copyable;
  template<class T> struct is_standard_layout;
  template<class T> struct is_empty;
  template<class T> struct is_polymorphic;
  template<class T> struct is_abstract;
  template<class T> struct is_final;
  template<class T> struct is_aggregate;

  template<class T> struct is_signed;
  template<class T> struct is_unsigned;

  template<class T, class... Args> struct is_constructible;
  template<class T> struct is_default_constructible;
  template<class T> struct is_copy_constructible;
  template<class T> struct is_move_constructible;

  template<class T, class U> struct is_assignable;
  template<class T> struct is_copy_assignable;
  template<class T> struct is_move_assignable;

  template<class T, class U> struct is_swappable_with;
  template<class T> struct is_swappable;

  template<class T> struct is_destructible;

  template<class T, class... Args> struct is_trivially_constructible;
  template<class T> struct is_trivially_default_constructible;
  template<class T> struct is_trivially_copy_constructible;
  template<class T> struct is_trivially_move_constructible;

  template<class T, class U> struct is_trivially_assignable;
  template<class T> struct is_trivially_copy_assignable;
  template<class T> struct is_trivially_move_assignable;
  template<class T> struct is_trivially_destructible;

  template<class T, class... Args> struct is_nothrow_constructible;
  template<class T> struct is_nothrow_default_constructible;
  template<class T> struct is_nothrow_copy_constructible;
  template<class T> struct is_nothrow_move_constructible;

  template<class T, class U> struct is_nothrow_assignable;
  template<class T> struct is_nothrow_copy_assignable;
  template<class T> struct is_nothrow_move_assignable;

  template<class T, class U> struct is_nothrow_swappable_with;
  template<class T> struct is_nothrow_swappable;

  template<class T> struct is_nothrow_destructible;

  template<class T> struct has_virtual_destructor;

  template<class T> struct has_unique_object_representations;

  // \ref{meta.unary.prop.query}, type property queries
  template<class T> struct alignment_of;
  template<class T> struct rank;
  template<class T, unsigned I = 0> struct extent;

  // \ref{meta.rel}, type relations
  template<class T, class U> struct is_same;
  template<class Base, class Derived> struct is_base_of;
  template<class From, class To> struct is_convertible;

  template<class Fn, class... ArgTypes> struct is_invocable;
  template<class R, class Fn, class... ArgTypes> struct is_invocable_r;

  template<class Fn, class... ArgTypes> struct is_nothrow_invocable;
  template<class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;

  // \ref{meta.trans.cv}, const-volatile modifications
  template<class T> struct remove_const;
  template<class T> struct remove_volatile;
  template<class T> struct remove_cv;
  template<class T> struct add_const;
  template<class T> struct add_volatile;
  template<class T> struct add_cv;

  template<class T>
    using remove_const_t    = typename remove_const<T>::type;
  template<class T>
    using remove_volatile_t = typename remove_volatile<T>::type;
  template<class T>
    using remove_cv_t       = typename remove_cv<T>::type;
  template<class T>
    using add_const_t       = typename add_const<T>::type;
  template<class T>
    using add_volatile_t    = typename add_volatile<T>::type;
  template<class T>
    using add_cv_t          = typename add_cv<T>::type;

  // \ref{meta.trans.ref}, reference modifications
  template<class T> struct remove_reference;
  template<class T> struct add_lvalue_reference;
  template<class T> struct add_rvalue_reference;

  template<class T>
    using remove_reference_t     = typename remove_reference<T>::type;
  template<class T>
    using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
  template<class T>
    using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

  // \ref{meta.trans.sign}, sign modifications
  template<class T> struct make_signed;
  template<class T> struct make_unsigned;

  template<class T>
    using make_signed_t   = typename make_signed<T>::type;
  template<class T>
    using make_unsigned_t = typename make_unsigned<T>::type;

  // \ref{meta.trans.arr}, array modifications
  template<class T> struct remove_extent;
  template<class T> struct remove_all_extents;

  template<class T>
    using remove_extent_t      = typename remove_extent<T>::type;
  template<class T>
    using remove_all_extents_t = typename remove_all_extents<T>::type;

  // \ref{meta.trans.ptr}, pointer modifications
  template<class T> struct remove_pointer;
  template<class T> struct add_pointer;

  template<class T>
    using remove_pointer_t = typename remove_pointer<T>::type;
  template<class T>
    using add_pointer_t    = typename add_pointer<T>::type;

  // \ref{meta.trans.other}, other transformations
  template<size_t Len, size_t Align = @\textit{default-alignment}@> // see \ref{meta.trans.other}
    struct aligned_storage;
  template<size_t Len, class... Types> struct aligned_union;
  template<class T> struct remove_cvref;
  template<class T> struct decay;
  template<bool, class T = void> struct enable_if;
  template<bool, class T, class F> struct conditional;
  template<class... T> struct common_type;
  template<class T> struct underlying_type;
  template<class Fn, class... ArgTypes> struct invoke_result;

  template<size_t Len, size_t Align = @\textit{default-alignment}@> // see \ref{meta.trans.other}
    using aligned_storage_t = typename aligned_storage<Len, Align>::type;
  template<size_t Len, class... Types>
    using aligned_union_t   = typename aligned_union<Len, Types...>::type;
  template<class T>
    using remove_cvref_t    = typename remove_cvref<T>::type;
  template<class T>
    using decay_t           = typename decay<T>::type;
  template<bool b, class T = void>
    using enable_if_t       = typename enable_if<b, T>::type;
  template<bool b, class T, class F>
    using conditional_t     = typename conditional<b, T, F>::type;
  template<class... T>
    using common_type_t     = typename common_type<T...>::type;
  template<class T>
    using underlying_type_t = typename underlying_type<T>::type;
  template<class Fn, class... ArgTypes>
    using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;
  template<class...>
    using void_t            = void;

  // \ref{meta.logical}, logical operator traits
  template<class... B> struct conjunction;
  template<class... B> struct disjunction;
  template<class B> struct negation;

  // \ref{meta.endian}, endian
  enum class endian {
    little = @\seebelow@,
    big    = @\seebelow@,
    native = @\seebelow@
  };

  // \ref{meta.unary.cat}, primary type categories
  template<class T>
    inline constexpr bool is_void_v = is_void<T>::value;
  template<class T>
    inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
  template<class T>
    inline constexpr bool is_integral_v = is_integral<T>::value;
  template<class T>
    inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
  template<class T>
    inline constexpr bool is_array_v = is_array<T>::value;
  template<class T>
    inline constexpr bool is_pointer_v = is_pointer<T>::value;
  template<class T>
    inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
  template<class T>
    inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
  template<class T>
    inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
  template<class T>
    inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;
  template<class T>
    inline constexpr bool is_enum_v = is_enum<T>::value;
  template<class T>
    inline constexpr bool is_union_v = is_union<T>::value;
  template<class T>
    inline constexpr bool is_class_v = is_class<T>::value;
  template<class T>
    inline constexpr bool is_function_v = is_function<T>::value;

  // \ref{meta.unary.comp}, composite type categories
  template<class T>
    inline constexpr bool is_reference_v = is_reference<T>::value;
  template<class T>
    inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
  template<class T>
    inline constexpr bool is_fundamental_v = is_fundamental<T>::value;
  template<class T>
    inline constexpr bool is_object_v = is_object<T>::value;
  template<class T>
    inline constexpr bool is_scalar_v = is_scalar<T>::value;
  template<class T>
    inline constexpr bool is_compound_v = is_compound<T>::value;
  template<class T>
    inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

  // \ref{meta.unary.prop}, type properties
  template<class T>
    inline constexpr bool is_const_v = is_const<T>::value;
  template<class T>
    inline constexpr bool is_volatile_v = is_volatile<T>::value;
  template<class T>
    inline constexpr bool is_trivial_v = is_trivial<T>::value;
  template<class T>
    inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;
  template<class T>
    inline constexpr bool is_standard_layout_v = is_standard_layout<T>::value;
  template<class T>
    inline constexpr bool is_empty_v = is_empty<T>::value;
  template<class T>
    inline constexpr bool is_polymorphic_v = is_polymorphic<T>::value;
  template<class T>
    inline constexpr bool is_abstract_v = is_abstract<T>::value;
  template<class T>
    inline constexpr bool is_final_v = is_final<T>::value;
  template<class T>
    inline constexpr bool is_aggregate_v = is_aggregate<T>::value;
  template<class T>
    inline constexpr bool is_signed_v = is_signed<T>::value;
  template<class T>
    inline constexpr bool is_unsigned_v = is_unsigned<T>::value;
  template<class T, class... Args>
    inline constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
  template<class T>
    inline constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
  template<class T>
    inline constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;
  template<class T>
    inline constexpr bool is_move_constructible_v = is_move_constructible<T>::value;
  template<class T, class U>
    inline constexpr bool is_assignable_v = is_assignable<T, U>::value;
  template<class T>
    inline constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;
  template<class T>
    inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
  template<class T, class U>
    inline constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
  template<class T>
    inline constexpr bool is_swappable_v = is_swappable<T>::value;
  template<class T>
    inline constexpr bool is_destructible_v = is_destructible<T>::value;
  template<class T, class... Args>
    inline constexpr bool is_trivially_constructible_v
      = is_trivially_constructible<T, Args...>::value;
  template<class T>
    inline constexpr bool is_trivially_default_constructible_v
      = is_trivially_default_constructible<T>::value;
  template<class T>
    inline constexpr bool is_trivially_copy_constructible_v
      = is_trivially_copy_constructible<T>::value;
  template<class T>
    inline constexpr bool is_trivially_move_constructible_v
      = is_trivially_move_constructible<T>::value;
  template<class T, class U>
    inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;
  template<class T>
    inline constexpr bool is_trivially_copy_assignable_v
      = is_trivially_copy_assignable<T>::value;
  template<class T>
    inline constexpr bool is_trivially_move_assignable_v
      = is_trivially_move_assignable<T>::value;
  template<class T>
    inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;
  template<class T, class... Args>
    inline constexpr bool is_nothrow_constructible_v
      = is_nothrow_constructible<T, Args...>::value;
  template<class T>
    inline constexpr bool is_nothrow_default_constructible_v
      = is_nothrow_default_constructible<T>::value;
  template<class T>
    inline constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible<T>::value;
  template<class T>
    inline constexpr bool is_nothrow_move_constructible_v
      = is_nothrow_move_constructible<T>::value;
  template<class T, class U>
    inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;
  template<class T>
    inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;
  template<class T>
    inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;
  template<class T, class U>
    inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
  template<class T>
    inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;
  template<class T>
    inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
  template<class T>
    inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<T>::value;
  template<class T>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<T>::value;

  // \ref{meta.unary.prop.query}, type property queries
  template<class T>
    inline constexpr size_t alignment_of_v = alignment_of<T>::value;
  template<class T>
    inline constexpr size_t rank_v = rank<T>::value;
  template<class T, unsigned I = 0>
    inline constexpr size_t extent_v = extent<T, I>::value;

  // \ref{meta.rel}, type relations
  template<class T, class U>
    inline constexpr bool is_same_v = is_same<T, U>::value;
  template<class Base, class Derived>
    inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;
  template<class From, class To>
    inline constexpr bool is_convertible_v = is_convertible<From, To>::value;
  template<class Fn, class... ArgTypes>
    inline constexpr bool is_invocable_v = is_invocable<Fn, ArgTypes...>::value;
  template<class R, class Fn, class... ArgTypes>
    inline constexpr bool is_invocable_r_v = is_invocable_r<R, Fn, ArgTypes...>::value;
  template<class Fn, class... ArgTypes>
    inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<Fn, ArgTypes...>::value;
  template<class R, class Fn, class... ArgTypes>
    inline constexpr bool is_nothrow_invocable_r_v
      = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;

  // \ref{meta.logical}, logical operator traits
  template<class... B>
    inline constexpr bool conjunction_v = conjunction<B...>::value;
  template<class... B>
    inline constexpr bool disjunction_v = disjunction<B...>::value;
  template<class B>
    inline constexpr bool negation_v = negation<B>::value;
}
\end{codeblock}

\pnum
The behavior of a program that adds specializations for any of
the templates defined in this subclause is undefined unless otherwise specified.

\pnum
Unless otherwise specified, an incomplete type may be used
to instantiate a template in this subclause.

\rSec2[meta.help]{Helper classes}

\indexlibrarymember{value_type}{integral_constant}%
\begin{codeblock}
namespace std {
  template<class T, T v> struct integral_constant {
    static constexpr T value = v;

    using value_type = T;
    using type = integral_constant<T, v>;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
}
\end{codeblock}

\indexlibrary{\idxcode{integral_constant}}%
\indexlibrary{\idxcode{bool_constant}}%
\indexlibrary{\idxcode{true_type}}%
\indexlibrary{\idxcode{false_type}}%
\pnum
The class template \tcode{integral_constant},
alias template \tcode{bool_constant}, and
its associated \grammarterm{typedef-name}{s}
\tcode{true_type} and \tcode{false_type}
are used as base classes to define
the interface for various type traits.

\rSec2[meta.unary]{Unary type traits}

\pnum
This subclause contains templates that may be used to query the
properties of a type at compile time.

\pnum
Each of these templates shall be a
\tcode{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of
\tcode{true_type} if the corresponding condition is \tcode{true}, otherwise
\tcode{false_type}.

\rSec3[meta.unary.cat]{Primary type categories}

\pnum
The primary type categories correspond to the descriptions given in
subclause~\ref{basic.types} of the \Cpp{} standard.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T} and to \cv{}~\tcode{T} shall yield the same result.

\pnum
\begin{note}
For any given type \tcode{T}, exactly one of the primary type categories
has a \tcode{value} member that evaluates to \tcode{true}.
\end{note}

\begin{libreqtab3e}{Primary type category predicates}{tab:type-traits.primary}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\\capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\indexlibrary{\idxcode{is_void}}%
\tcode{template<class T>}\br
 \tcode{struct is_void;}                &
\tcode{T} is \tcode{void}       &   \\ \rowsep
\indexlibrary{\idxcode{is_null_pointer}}%
\tcode{template<class T>}\br
 \tcode{struct is_null_pointer;}                &
\tcode{T} is \tcode{nullptr_t}\iref{basic.fundamental}       &   \\ \rowsep
\indexlibrary{\idxcode{is_integral}}%
\tcode{template<class T>}\br
 \tcode{struct is_integral;}        &
\tcode{T} is an integral type\iref{basic.fundamental}                 &   \\ \rowsep
\indexlibrary{\idxcode{is_floating_point}}%
\tcode{template<class T>}\br
 \tcode{struct is_floating_point;}  &
\tcode{T} is a floating-point type\iref{basic.fundamental}            &   \\ \rowsep
\indexlibrary{\idxcode{is_array}}%
\tcode{template<class T>}\br
 \tcode{struct is_array;}           &
\tcode{T} is an array type\iref{basic.compound} of known or unknown extent    &
Class template \tcode{array}\iref{array}
is not an array type.                   \\ \rowsep
\indexlibrary{\idxcode{is_pointer}}%
\tcode{template<class T>}\br
 \tcode{struct is_pointer;}         &
\tcode{T} is a pointer type\iref{basic.compound}                      &
Includes pointers to functions
but not pointers to non-static members.                        \\ \rowsep
\indexlibrary{\idxcode{is_lvalue_reference}}%
\tcode{template<class T>}\br
 \tcode{struct is_lvalue_reference;}    &
 \tcode{T} is an lvalue reference type\iref{dcl.ref}   &   \\ \rowsep
\indexlibrary{\idxcode{is_rvalue_reference}}%
\tcode{template<class T>}\br
 \tcode{struct is_rvalue_reference;}    &
 \tcode{T} is an rvalue reference type\iref{dcl.ref}   &   \\ \rowsep
\indexlibrary{\idxcode{is_member_object_pointer}}%
\tcode{template<class T>}\br
 \tcode{struct is_member_object_pointer;}&
 \tcode{T} is a pointer to data member                              &   \\ \rowsep
\indexlibrary{\idxcode{is_member_function_pointer}}%
\tcode{template<class T>}\br
 \tcode{struct is_member_function_pointer;}&
\tcode{T} is a pointer to member function                           &   \\ \rowsep
\indexlibrary{\idxcode{is_enum}}%
\tcode{template<class T>}\br
 \tcode{struct is_enum;}            &
\tcode{T} is an enumeration type\iref{basic.compound}                 &   \\ \rowsep
\indexlibrary{\idxcode{is_union}}%
\tcode{template<class T>}\br
 \tcode{struct is_union;}           &
\tcode{T} is a union type\iref{basic.compound}                        &   \\ \rowsep
\indexlibrary{\idxcode{is_class}}%
\tcode{template<class T>}\br
 \tcode{struct is_class;}           &
\tcode{T} is a non-union class type\iref{basic.compound} & \\ \rowsep
\indexlibrary{\idxcode{is_function}}%
\tcode{template<class T>}\br
 \tcode{struct is_function;}        &
\tcode{T} is a function type\iref{basic.compound}                     &   \\
\end{libreqtab3e}

\rSec3[meta.unary.comp]{Composite type traits}

\pnum
These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in subclause~\ref{basic.types}.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T} and to \cv{}~\tcode{T} shall yield the same result.

\begin{libreqtab3b}{Composite type category predicates}{tab:type-traits.composite}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\indexlibrary{\idxcode{is_reference}}%
\tcode{template<class T>}\br
 \tcode{struct is_reference;}   &
 \tcode{T} is an lvalue reference or an rvalue reference &  \\ \rowsep
\indexlibrary{\idxcode{is_arithmetic}}%
\tcode{template<class T>}\br
 \tcode{struct is_arithmetic;}          &
 \tcode{T} is an arithmetic type\iref{basic.fundamental}              &   \\ \rowsep
\indexlibrary{\idxcode{is_fundamental}}%
\tcode{template<class T>}\br
 \tcode{struct is_fundamental;}         &
 \tcode{T} is a fundamental type\iref{basic.fundamental}              &   \\ \rowsep
\indexlibrary{\idxcode{is_object}}%
\tcode{template<class T>}\br
 \tcode{struct is_object;}              &
 \tcode{T} is an object type\iref{basic.types}                            &   \\ \rowsep
\indexlibrary{\idxcode{is_scalar}}%
\tcode{template<class T>}\br
 \tcode{struct is_scalar;}              &
 \tcode{T} is a scalar type\iref{basic.types}                         &   \\ \rowsep
\indexlibrary{\idxcode{is_compound}}%
\tcode{template<class T>}\br
 \tcode{struct is_compound;}            &
 \tcode{T} is a compound type\iref{basic.compound}                        &   \\ \rowsep
\indexlibrary{\idxcode{is_member_pointer}}%
\tcode{template<class T>}\br
 \tcode{struct is_member_pointer;}      &
 \tcode{T} is a pointer-to-member type\iref{basic.compound}               &   \\
\end{libreqtab3b}

\rSec3[meta.unary.prop]{Type properties}

\pnum
These templates provide access to some of the more important
properties of types.

\pnum
It is unspecified whether the library defines any full or partial
specializations of any of these templates.

\pnum
For all of the class templates \tcode{X} declared in this subclause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of \tcode{X} require that
the argument is a complete type.

\pnum
For the purpose of defining the templates in this subclause,
a function call expression \tcode{declval<T>()} for any type \tcode{T}
is considered to be a trivial~(\ref{basic.types}, \ref{special}) function call
that is not an odr-use\iref{basic.def.odr} of \tcode{declval}
in the context of the corresponding definition
notwithstanding the restrictions of~\ref{declval}.

\begin{libreqtab3b}{Type property predicates}{tab:type-traits.properties}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endhead

\indexlibrary{\idxcode{is_const}}%
\tcode{template<class T>}\br
 \tcode{struct is_const;}               &
 \tcode{T} is const-qualified\iref{basic.type.qualifier}                  &   \\ \rowsep

\indexlibrary{\idxcode{is_volatile}}%
\tcode{template<class T>}\br
 \tcode{struct is_volatile;}            &
 \tcode{T} is volatile-qualified\iref{basic.type.qualifier}                   &   \\ \rowsep


\indexlibrary{\idxcode{is_trivial}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivial;}                 &
 \tcode{T} is a trivial type\iref{basic.types}     &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or \cv{}~\tcode{void}.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_copyable}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copyable;}      &
 \tcode{T} is a trivially copyable type\iref{basic.types} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 \cv{}~\tcode{void}.                               \\ \rowsep

\indexlibrary{\idxcode{is_standard_layout}}%
\tcode{template<class T>}\br
 \tcode{struct is_standard_layout;}                 &
 \tcode{T} is a standard-layout type\iref{basic.types}   &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or \cv{}~\tcode{void}.                \\ \rowsep

\indexlibrary{\idxcode{is_empty}!class}%
\tcode{template<class T>}\br
 \tcode{struct is_empty;}               &
 \tcode{T} is a class type, but not a union type, with no non-static data
 members other than subobjects of zero size, no virtual member functions,
 no virtual base classes, and no base class \tcode{B} for
 which \tcode{is_empty_v<B>} is \tcode{false}. &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                               \\ \rowsep

\indexlibrary{\idxcode{is_polymorphic}}%
\tcode{template<class T>}\br
 \tcode{struct is_polymorphic;}         &
 \tcode{T} is a polymorphic class\iref{class.virtual}                             &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibrary{\idxcode{is_abstract}}%
\tcode{template<class T>}\br
 \tcode{struct is_abstract;}            &
 \tcode{T} is an abstract class\iref{class.abstract}                              &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibrary{\idxcode{is_final}}%
\tcode{template<class T>}\br
 \tcode{struct is_final;}               &
 \tcode{T} is a class type marked with the \grammarterm{class-virt-specifier}
 \tcode{final}\iref{class}. \begin{note} A union is a class type that
 can be marked with \tcode{final}. \end{note}                                        &
 If \tcode{T} is a class type, \tcode{T} shall be a complete type.                          \\ \rowsep

\indexlibrary{\idxcode{is_aggregate}}%
\tcode{template<class T>}\br
  \tcode{struct is_aggregate;}           &
 \tcode{T} is an aggregate type\iref{dcl.init.aggr} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or \cv~\tcode{void}.              \\ \rowsep

\indexlibrary{\idxcode{is_signed}!class}%
\tcode{template<class T>}\br
  \tcode{struct is_signed;}              &
  If \tcode{is_arithmetic_v<T>} is \tcode{true}, the same result as
  \tcode{T(-1) < T(0)};
  otherwise, \tcode{false}   &   \\  \rowsep

\indexlibrary{\idxcode{is_unsigned}}%
\tcode{template<class T>}\br
  \tcode{struct is_unsigned;}            &
  If \tcode{is_arithmetic_v<T>} is \tcode{true}, the same result as
  \tcode{T(0) < T(-1)};
  otherwise, \tcode{false}   &   \\  \rowsep

\indexlibrary{\idxcode{is_constructible}}%
\tcode{template<class T, class... Args>}\br
 \tcode{struct is_constructible;}   &
 For a function type \tcode{T} or
 for a \cv{}~\tcode{void} type \tcode{T},
 \tcode{is_constructible_v<T, Args...>} is \tcode{false},
 otherwise \seebelow                &
 \tcode{T} and all types in the template parameter pack \tcode{Args}
 shall be complete types, \cv{}~\tcode{void},
 or arrays of unknown bound.  \\ \rowsep

\indexlibrary{\idxcode{is_default_constructible}}%
\tcode{template<class T>}\br
  \tcode{struct is_default_constructible;} &
  \tcode{is_constructible_v<T>} is \tcode{true}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_copy_constructible}}%
\tcode{template<class T>}\br
  \tcode{struct is_copy_constructible;} &
  For a referenceable type \tcode{T}\iref{defns.referenceable}, the same result as
  \tcode{is_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_move_constructible}}%
\tcode{template<class T>}\br
  \tcode{struct is_move_constructible;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_assignable}}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_assignable;} &
  The expression \tcode{declval<T>() =} \tcode{declval<U>()} is well-formed
  when treated as an unevaluated
  operand\iref{expr.prop}. Access checking is performed as if in a context
  unrelated to \tcode{T} and \tcode{U}. Only the validity of the immediate context
  of the assignment expression is considered. \begin{note} The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the ``immediate
  context'' and can result in the program being ill-formed. \end{note} &
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\tcode{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_copy_assignable}}%
\tcode{template<class T>}\br
  \tcode{struct is_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_move_assignable}}%
\tcode{template<class T>}\br
  \tcode{struct is_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_swappable_with}}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_swappable_with;} &
  The expressions \tcode{swap(declval<T>(), declval<U>())} and
  \tcode{swap(declval<U>(), declval<T>())} are each well-formed
  when treated as an unevaluated operand\iref{expr.prop}
  in an overload-resolution context
  for swappable values\iref{swappable.requirements}.
  Access checking is performed as if in a context
  unrelated to \tcode{T} and \tcode{U}.
  Only the validity of the immediate context
  of the \tcode{swap} expressions is considered.
  \begin{note}
  The compilation of the expressions can result in side effects
  such as the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such side effects are not in the ``immediate context'' and
  can result in the program being ill-formed.
  \end{note} &
  \tcode{T} and \tcode{U} shall be complete types,
  \cv{}~\tcode{void}, or
  arrays of unknown bound.  \\ \rowsep

\indexlibrary{\idxcode{is_swappable}}%
\tcode{template<class T>}\br
  \tcode{struct is_swappable;} &
  For a referenceable type \tcode{T},
  the same result as \tcode{is_swappable_with_v<T\&, T\&>},
  otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
  \cv{}~\tcode{void}, or
  an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_destructible}}%
\tcode{template<class T>}\br
  \tcode{struct is_destructible;} &
  Either \tcode{T} is a reference type,
  or \tcode{T} is a complete object type
  for which the expression
  \tcode{declval<U\&>().\~U()}
  is well-formed
  when treated as an unevaluated operand\iref{expr.prop},
  where \tcode{U} is
  \tcode{remove_all_extents_t<T>}. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void},
  or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_trivially_constructible}}%
\tcode{template<class T, class... Args>}\br
  \tcode{struct}\br
  \tcode{is_trivially_constructible;} &
  \tcode{is_constructible_v<T,}\br
  \tcode{Args...>} is \tcode{true} and the variable
  definition for \tcode{is_constructible}, as defined below, is known to call
  no operation that is not trivial~(\ref{basic.types}, \ref{special}). &
  \tcode{T} and all types in the template parameter pack \tcode{Args} shall be complete types,
  \cv{}~\tcode{void}, or arrays of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_trivially_default_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_default_constructible;} &
 \tcode{is_trivially_constructible_v<T>} is \tcode{true}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_copy_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_move_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_assignable}}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_trivially_assignable;} &
  \tcode{is_assignable_v<T, U>} is \tcode{true} and the assignment, as defined by
  \tcode{is_assignable}, is known to call no operation that is not trivial
 ~(\ref{basic.types}, \ref{special}). &
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\tcode{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_trivially_copy_assignable}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_move_assignable}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown bound.                \\ \rowsep

\indexlibrary{\idxcode{is_trivially_destructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_destructible;} &
 \tcode{is_destructible_v<T>} is \tcode{true} and
 \tcode{remove_all_extents_t<T>} is either a non-class type or
 a class type with a trivial destructor. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_constructible}}%
\tcode{template<class T, class... Args>}\br
 \tcode{struct is_nothrow_constructible;}   &
 \tcode{is_constructible_v<T,} \tcode{ Args...>} is \tcode{true}
 and the
 variable definition for \tcode{is_constructible}, as defined below, is known not to
 throw any exceptions\iref{expr.unary.noexcept}.
 &
 \tcode{T} and all types in the template parameter pack \tcode{Args}
 shall be complete types, \cv{}~\tcode{void},
 or arrays of unknown bound.  \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_default_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_default_constructible;} &
 \tcode{is_nothrow_constructible_v<T>} is \tcode{true}.  &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_copy_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_move_constructible}}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_assignable}}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_nothrow_assignable;} &
  \tcode{is_assignable_v<T, U>} is \tcode{true} and the assignment is known not to
  throw any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\tcode{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_copy_assignable}}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_move_assignable}}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_nothrow_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\tcode{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_swappable_with}}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_nothrow_swappable_with;} &
  \tcode{is_swappable_with_v<T, U>} is \tcode{true} and
  each \tcode{swap} expression of the definition of
  \tcode{is_swappable_with<T, U>} is known not to throw
  any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} and \tcode{U} shall be complete types,
  \cv{}~\tcode{void}, or
  arrays of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_swappable}}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_swappable;} &
  For a referenceable type \tcode{T},
  the same result as \tcode{is_nothrow_swappable_with_v<T\&, T\&>},
  otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
  \cv{}~\tcode{void}, or
  an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_destructible}}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_destructible;} &
  \tcode{is_destructible_v<T>} is \tcode{true} and the indicated destructor is known
  not to throw any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} shall be a complete type,
  \cv{}~\tcode{void}, or an array of unknown
  bound.                \\ \rowsep

\indexlibrary{\idxcode{has_virtual_destructor}}%
\tcode{template<class T>}\br
 \tcode{struct has_virtual_destructor;} &
 \tcode{T} has a virtual destructor\iref{class.dtor} &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibrary{\idxcode{has_unique_object_representations}}%
\tcode{template<class T>}\br
  \tcode{struct has_unique_object_representations;} &
  For an array type \tcode{T}, the same result as
  \tcode{has_unique_object_representations_v<remove_all_extents_t<T>>},
  otherwise \seebelow. &
  \tcode{T} shall be a complete type, \cv{}~\tcode{void}, or
  an array of unknown bound. \\ \rowsep

\end{libreqtab3b}

\pnum
\begin{example}
\begin{codeblock}
is_const_v<const volatile int>      // \tcode{true}
is_const_v<const int*>              // \tcode{false}
is_const_v<const int&>              // \tcode{false}
is_const_v<int[3]>                  // \tcode{false}
is_const_v<const int[3]>            // \tcode{true}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
remove_const_t<const volatile int>  // \tcode{volatile int}
remove_const_t<const int* const>    // \tcode{const int*}
remove_const_t<const int&>          // \tcode{const int\&}
remove_const_t<const int[3]>        // \tcode{int[3]}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// Given:
struct P final { };
union U1 { };
union U2 final { };

// the following assertions hold:
static_assert(!is_final_v<int>);
static_assert(is_final_v<P>);
static_assert(!is_final_v<U1>);
static_assert(is_final_v<U2>);
\end{codeblock}
\end{example}

\indexlibrary{\idxcode{is_constructible}}%
\pnum
The predicate condition for a template specialization
\tcode{is_constructible<T, Args...>} shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable \tcode{t}:

\begin{codeblock}
T t(declval<Args>()...);
\end{codeblock}

\begin{note} These tokens are never interpreted as a function declaration.
\end{note} Access checking is performed as if in a context unrelated to \tcode{T}
and any of the \tcode{Args}. Only the validity of the immediate context of the
variable initialization is considered. \begin{note} The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
``immediate context'' and can result in the program being ill-formed. \end{note}

\indexlibrary{\idxcode{has_unique_object_representations}}%
\pnum
The predicate condition for a template specialization
\tcode{has_unique_object_representations<T>}
shall be satisfied if and only if:
\begin{itemize}
\item \tcode{T} is trivially copyable, and
\item any two objects of type \tcode{T} with the same value
have the same object representation, where
two objects of array or non-union class type are considered to have the same value
if their respective sequences of direct subobjects have the same values, and
two objects of union type are considered to have the same value
if they have the same active member and the corresponding members have the same value.
\end{itemize}
The set of scalar types for which this condition holds is
\impldef{which scalar types have unique object representations}.
\begin{note} If a type has padding bits, the condition does not hold;
otherwise, the condition holds true for unsigned integral types. \end{note}

\rSec2[meta.unary.prop.query]{Type property queries}

\pnum
This subclause contains templates that may be used to query
properties of types at compile time.

\begin{libreqtab2a}{Type property queries}{tab:type-traits.properties.queries}
\\ \topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endhead

\indexlibrary{\idxcode{alignment_of}}%
\tcode{template<class T>\br
 struct alignment_of;}      &
 \tcode{alignof(T)}.\br
 \requires{}
 \tcode{alignof(T)} shall be a valid expression\iref{expr.alignof}  \\  \rowsep

\indexlibrary{\idxcode{rank}}%
\tcode{template<class T>\br
 struct rank;}      &
 If \tcode{T} names an array type, an integer value representing
 the number of dimensions of \tcode{T}; otherwise, 0. \\    \rowsep

\indexlibrary{\idxcode{extent}}%
\tcode{template<class T,\br
 unsigned I = 0>\br
 struct extent;}        &
 If \tcode{T} is not an array type, or if it has rank less
 than or equal to \tcode{I}, or if \tcode{I} is 0 and \tcode{T}
 has type ``array of unknown bound of \tcode{U}'', then
 0; otherwise, the bound\iref{dcl.array} of the \tcode{I}'th dimension of
\tcode{T}, where indexing of \tcode{I} is zero-based \\
\end{libreqtab2a}

\pnum
Each of these templates shall be a \tcode{UnaryTypeTrait}\iref{meta.rqmts} with a
base characteristic of \tcode{integral_constant<size_t, Value>}.

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
assert(rank_v<int> == 0);
assert(rank_v<int[2]> == 1);
assert(rank_v<int[][4]> == 2);
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
assert(extent_v<int> == 0);
assert(extent_v<int[2]> == 2);
assert(extent_v<int[2][4]> == 2);
assert(extent_v<int[][4]> == 0);
assert((extent_v<int, 1>) == 0);
assert((extent_v<int[2], 1>) == 0);
assert((extent_v<int[2][4], 1>) == 4);
assert((extent_v<int[][4], 1>) == 4);
\end{codeblock}
\end{example}

\rSec2[meta.rel]{Relationships between types}

\pnum
This subclause contains templates that may be used to query
relationships between types at compile time.

\pnum
Each of these templates shall be a
\tcode{BinaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of
\tcode{true_type} if the corresponding condition is true, otherwise
\tcode{false_type}.

\begin{libreqtab3f}{Type relationship predicates}{tab:type-traits.relationship}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template<class T, class U>}\br
 \tcode{struct is_same;}                    &
 \tcode{T} and \tcode{U} name the same type with the same cv-qualifications                            &   \\ \rowsep

\indexlibrary{\idxcode{is_base_of}}%
\tcode{template<class Base, class Derived>}\br
 \tcode{struct is_base_of;}                 &
 \tcode{Base} is a base class of \tcode{Derived}\iref{class.derived}
 without regard to cv-qualifiers
 or \tcode{Base} and \tcode{Derived} are not unions and
 name the same class type
 without regard to cv-qualifiers            &
 If \tcode{Base} and
 \tcode{Derived} are non-union class types and are
not possibly cv-qualified versions of the same type,
 \tcode{Derived} shall be a complete
 type.
 \begin{note} Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes. \end{note} \\ \rowsep

\indexlibrary{\idxcode{is_convertible}}%
\tcode{template<class From, class To>}\br
 \tcode{struct is_convertible;}             &
 \seebelow                                  &
 \tcode{From} and \tcode{To} shall be complete
 types, arrays of unknown
 bound, or \cv{}~\tcode{void} types.                \\ \rowsep

\indexlibrary{\idxcode{is_invocable}}%
\tcode{template<class Fn, class... ArgTypes>}\br
 \tcode{struct is_invocable;}                      &
 The expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}
 is well-formed when treated as an unevaluated operand                &
 \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\tcode{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibrary{\idxcode{is_invocable_r}}%
\tcode{template<class R, class Fn, class... ArgTypes>}\br
 \tcode{struct is_invocable_r;}                      &
 The expression \tcode{\placeholdernc{INVOKE}<R>(declval<Fn>(), declval<ArgTypes>()...)}
 is well-formed when treated as an unevaluated operand                &
 \tcode{Fn}, \tcode{R}, and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\tcode{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_invocable}}%
\tcode{template<class Fn, class... ArgTypes>}\br
 \tcode{struct is_nothrow_invocable;}              &
 \tcode{is_invocable_v<}\br\tcode{Fn, ArgTypes...>} is \tcode{true} and
 the expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}
 is known not to throw any exceptions                                 &
 \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\tcode{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibrary{\idxcode{is_nothrow_invocable_r}}%
\tcode{template<class R, class Fn, class... ArgTypes>}\br
 \tcode{struct is_nothrow_invocable_r;}              &
 \tcode{is_invocable_r_v<}\br\tcode{R, Fn, ArgTypes...>} is \tcode{true} and
 the expression \tcode{\placeholdernc{INVOKE}<R>(declval<Fn>(), declval<ArgTypes>()...)}
 is known not to throw any exceptions                                 &
 \tcode{Fn}, \tcode{R}, and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\tcode{void}, or
 arrays of unknown bound.                                             \\
\end{libreqtab3f}

\pnum
For the purpose of defining the templates in this subclause,
a function call expression \tcode{declval<T>()} for any type \tcode{T}
is considered to be a trivial~(\ref{basic.types}, \ref{special}) function call
that is not an odr-use\iref{basic.def.odr} of \tcode{declval}
in the context of the corresponding definition
notwithstanding the restrictions of~\ref{declval}.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of_v<B, D>         // \tcode{true}
is_base_of_v<const B, D>   // \tcode{true}
is_base_of_v<B, const D>   // \tcode{true}
is_base_of_v<B, const B>   // \tcode{true}
is_base_of_v<D, B>         // \tcode{false}
is_base_of_v<B&, D&>       // \tcode{false}
is_base_of_v<B[3], D[3]>   // \tcode{false}
is_base_of_v<int, int>     // \tcode{false}
\end{codeblock}
\end{example}

\indexlibrary{\idxcode{is_convertible}}%
\pnum
The predicate condition for a template specialization \tcode{is_convertible<From, To>}
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:

\begin{codeblock}
To test() {
  return declval<From>();
}
\end{codeblock}

\begin{note} This requirement gives well-defined results for reference types, void
types, array types, and function types.\end{note} Access checking is performed
in a context unrelated to \tcode{To} and \tcode{From}. Only the validity of
the immediate context of the \grammarterm{expression} of the \tcode{return} statement\iref{stmt.return}
(including initialization of the returned object or reference) is considered. \begin{note} The
initialization can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the ``immediate context'' and can result in the program
being ill-formed. \end{note}

\rSec2[meta.trans]{Transformations between types}
\pnum
This subclause contains templates that may be used to transform one
type to another following some predefined rule.

\pnum
Each of the templates in this subclause shall be a
\tcode{TransformationTrait}\iref{meta.rqmts}.

\rSec3[meta.trans.cv]{Const-volatile modifications}

\begin{libreqtab2a}{Const-volatile modifications}{tab:type-traits.const-volatile}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{remove_const}}%
\tcode{template<class T>\br
 struct remove_const;}                  &
 The member typedef \tcode{type} names
 the same type as \tcode{T}
 except that any top-level const-qualifier has been removed.
 \begin{example} \tcode{remove_const_t<const volatile int>} evaluates
 to \tcode{volatile int}, whereas \tcode{remove_const_t<const int*>} evaluates to
 \tcode{const int*}. \end{example}                          \\  \rowsep

\indexlibrary{\idxcode{remove_volatile}}%
\tcode{template<class T>\br
 struct remove_volatile;}               &
 The member typedef \tcode{type} names
 the same type as \tcode{T}
 except that any top-level volatile-qualifier has been removed.
 \begin{example} \tcode{remove_volatile_t<const volatile int>}
 evaluates to \tcode{const int},
 whereas \tcode{remove_volatile_t<volatile int*>} evaluates to \tcode{volatile int*}.
 \end{example}                                              \\  \rowsep

\indexlibrary{\idxcode{remove_cv}}%
\tcode{template<class T>\br
 struct remove_cv;}                 &
 The member typedef \tcode{type} shall be the same as \tcode{T}
 except that any top-level cv-qualifier has been removed.
 \begin{example} \tcode{remove_cv_t<const volatile int>}
 evaluates to \tcode{int}, whereas \tcode{remove_cv_t<const volatile int*>}
 evaluates to \tcode{const volatile int*}. \end{example}  \\  \rowsep

\indexlibrary{\idxcode{add_const}}%
\tcode{template<class T>\br
 struct add_const;}                 &
 If \tcode{T} is a reference, function, or top-level const-qualified
 type, then \tcode{type} names
 the same type as \tcode{T}, otherwise
 \tcode{T const}.                                                           \\  \rowsep

\indexlibrary{\idxcode{add_volatile}}%
\tcode{template<class T>\br
 struct add_volatile;}                  &
 If \tcode{T} is a reference, function, or top-level volatile-qualified
 type, then \tcode{type} names
 the same type as \tcode{T}, otherwise
 \tcode{T volatile}.                                                            \\  \rowsep

\indexlibrary{\idxcode{add_cv}}%
\tcode{template<class T>\br
 struct add_cv;}                    &
 The member typedef \tcode{type} names
 the same type as
 \tcode{add_const_t<add_volatile_t<T>{>}}.                               \\
\end{libreqtab2a}

\rSec3[meta.trans.ref]{Reference modifications}

\begin{libreqtab2a}{Reference modifications}{tab:type-traits.reference}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{remove_reference}}%
\tcode{template<class T>\br
 struct remove_reference;}                  &
 If \tcode{T} has type ``reference to \tcode{T1}'' then the
 member typedef \tcode{type} names \tcode{T1};
 otherwise, \tcode{type} names \tcode{T}.\\ \rowsep

\indexlibrary{\idxcode{add_lvalue_reference}}%
\tcode{template<class T>\br
 struct add_lvalue_reference;}                     &
 If \tcode{T} names a referenceable type\iref{defns.referenceable} then
 the member typedef \tcode{type} names \tcode{T\&};
 otherwise, \tcode{type} names \tcode{T}.
 \begin{note}
 This rule reflects the semantics of reference collapsing\iref{dcl.ref}.
 \end{note}\\ \rowsep

\indexlibrary{\idxcode{add_rvalue_reference}}%
\tcode{template<class T>}\br
 \tcode{struct add_rvalue_reference;}    &
 If \tcode{T} names a referenceable type then
 the member typedef \tcode{type} names \tcode{T\&\&};
 otherwise, \tcode{type} names \tcode{T}.
 \begin{note} This rule reflects the semantics of reference collapsing\iref{dcl.ref}.
 For example, when a type \tcode{T} names a type \tcode{T1\&}, the type
 \tcode{add_rvalue_reference_t<T>} is not an rvalue reference.
 \end{note} \\
\end{libreqtab2a}

\rSec3[meta.trans.sign]{Sign modifications}
\begin{libreqtab2a}{Sign modifications}{tab:type-traits.sign}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{make_signed}}%
\tcode{template<class T>}\br
 \tcode{struct make_signed;} &
 If \tcode{T} names a (possibly cv-qualified) signed integer
 type\iref{basic.fundamental} then the member typedef
 \tcode{type} names the type \tcode{T}; otherwise,
 if \tcode{T} names a (possibly cv-qualified) unsigned integer
 type then \tcode{type} names the corresponding
 signed integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} names the signed integer type with smallest
 rank\iref{conv.rank} for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \requires{} \tcode{T} shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a \tcode{bool} type.\\ \rowsep

\indexlibrary{\idxcode{make_unsigned}}%
\tcode{template<class T>}\br
 \tcode{struct make_unsigned;} &
 If \tcode{T} names a (possibly cv-qualified) unsigned integer
 type\iref{basic.fundamental} then the member typedef
 \tcode{type} names the type \tcode{T}; otherwise,
 if \tcode{T} names a (possibly cv-qualified) signed integer
 type then \tcode{type} names the corresponding
 unsigned integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} names the unsigned integer type with smallest
 rank\iref{conv.rank} for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \requires{} \tcode{T} shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a \tcode{bool} type.\\
\end{libreqtab2a}

\rSec3[meta.trans.arr]{Array modifications}
\begin{libreqtab2a}{Array modifications}{tab:type-traits.array}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{remove_extent}}%
\tcode{template<class T>\br
 struct remove_extent;}                 &
 If \tcode{T} names a type ``array of \tcode{U}'',
 the member typedef \tcode{type} shall
 be \tcode{U}, otherwise \tcode{T}.
 \begin{note} For multidimensional arrays, only the first array dimension is
 removed. For a type ``array of \tcode{const U}'', the resulting type is
 \tcode{const U}. \end{note}                                 \\  \rowsep

\indexlibrary{\idxcode{remove_all_extents}}%
\tcode{template<class T>\br
 struct remove_all_extents;}                &
 If \tcode{T} is ``multi-dimensional array of \tcode{U}'', the resulting member
 typedef \tcode{type} is \tcode{U}, otherwise \tcode{T}.                                       \\
\end{libreqtab2a}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
assert((is_same_v<remove_extent_t<int>, int>));
assert((is_same_v<remove_extent_t<int[2]>, int>));
assert((is_same_v<remove_extent_t<int[2][3]>, int[3]>));
assert((is_same_v<remove_extent_t<int[][3]>, int[3]>));
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
assert((is_same_v<remove_all_extents_t<int>, int>));
assert((is_same_v<remove_all_extents_t<int[2]>, int>));
assert((is_same_v<remove_all_extents_t<int[2][3]>, int>));
assert((is_same_v<remove_all_extents_t<int[][3]>, int>));
\end{codeblock}
\end{example}

\rSec3[meta.trans.ptr]{Pointer modifications}
\begin{libreqtab2a}{Pointer modifications}{tab:type-traits.pointer}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{remove_pointer}}%
\tcode{template<class T>\br
 struct remove_pointer;}                    &
 If \tcode{T} has type ``(possibly cv-qualified) pointer
 to \tcode{T1}'' then the member typedef \tcode{type}
 names \tcode{T1}; otherwise, it names \tcode{T}.\\ \rowsep

\indexlibrary{\idxcode{add_pointer}}%
\tcode{template<class T>\br
 struct add_pointer;}                       &
 If \tcode{T} names a referenceable type\iref{defns.referenceable} or a
 \cv{}~\tcode{void} type then
 the member typedef \tcode{type} names the same type as
 \tcode{remove_reference_t<T>*};
 otherwise, \tcode{type} names \tcode{T}.             \\
\end{libreqtab2a}

\rSec3[meta.trans.other]{Other transformations}

\begin{libreqtab2a}{Other transformations}{tab:type-traits.other}
\\ \topline
\lhdr{Template}   &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template}   &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibrary{\idxcode{aligned_storage}}%
\tcode{template<size_t Len,\br
 size_t Align\br
 = \textit{default-alignment}>\br
 struct aligned_storage;}
 &
 The value of \textit{default-alignment} shall be the most
 stringent alignment requirement for any \Cpp{} object type whose size
 is no greater than \tcode{Len}\iref{basic.types}.
 The member typedef \tcode{type} shall be a trivial standard-layout type
 suitable for use as uninitialized storage for any object whose size
 is at most \tcode{Len} and whose alignment is a divisor of \tcode{Align}.\br
 \requires{} \tcode{Len} shall not be zero. \tcode{Align} shall be equal to
 \tcode{alignof(T)} for some type \tcode{T} or to \textit{default-alignment}.\\ \rowsep

\indexlibrary{\idxcode{aligned_union}}%
\tcode{template<size_t Len,\br
  class... Types>\br
  struct aligned_union;}
  &
  The member typedef \tcode{type} shall be a trivial standard-layout type suitable for use as
  uninitialized storage for any object whose type is listed in \tcode{Types};
  its size shall be at least \tcode{Len}. The static member \tcode{alignment_value}
  shall be an integral constant of type \tcode{size_t} whose value is the
  strictest alignment of all types listed in \tcode{Types}.\br
 \requires{} At least one type is provided.
  Each type in the template parameter pack \tcode{Types} shall be a complete object type.
  \\ \rowsep

\indexlibrary{\idxcode{remove_cvref}}%
\tcode{template<class T>\br struct remove_cvref;}
 &
 The member typedef \tcode{type} names the same type as
 \tcode{remove_cv_t<remove_reference_t<T>>}.
 \\ \rowsep

\indexlibrary{\idxcode{decay}}%
\tcode{template<class T>\br struct decay;}
 &
 Let \tcode{U} be \tcode{remove_reference_t<T>}. If \tcode{is_array_v<U>} is
 \tcode{true}, the member typedef \tcode{type} shall equal
 \tcode{remove_extent_t<U>*}. If \tcode{is_function_v<U>} is \tcode{true},
 the member typedef \tcode{type} shall equal \tcode{add_pointer_t<U>}. Otherwise
 the member typedef \tcode{type} equals \tcode{remove_cv_t<U>}.
 \begin{note} This behavior is similar to the lvalue-to-rvalue\iref{conv.lval},
 array-to-pointer\iref{conv.array}, and function-to-pointer\iref{conv.func}
 conversions applied when an lvalue expression is used as an rvalue, but also
 strips \cv-qualifiers from class types in order to more closely model by-value
 argument passing. \end{note}
 \\ \rowsep

\indexlibrary{\idxcode{enable_if}}%
\tcode{template<bool B, class T = void>} \tcode{struct enable_if;}
 &
 If \tcode{B} is \tcode{true}, the member typedef \tcode{type}
 shall equal \tcode{T}; otherwise, there shall be no member
 \tcode{type}. \\ \rowsep

\tcode{template<bool B, class T,}
 \tcode{class F>}\br
 \tcode{struct conditional;}
 &
 If \tcode{B} is \tcode{true},  the member typedef \tcode{type} shall equal \tcode{T}.
 If \tcode{B} is \tcode{false}, the member typedef \tcode{type} shall equal \tcode{F}. \\ \rowsep

 \tcode{template<class... T>} \tcode{struct common_type;}
 &
 Unless this trait is specialized (as specified in Note B, below),
 the member \tcode{type} shall be defined or omitted as specified in Note A, below.
 If it is omitted, there shall be no member \tcode{type}.
 Each type in the template parameter pack \tcode{T} shall be
 complete, \cv{}~\tcode{void}, or an array of unknown bound. \\ \rowsep

\indexlibrary{\idxcode{underlying_type}}%
\tcode{template<class T>}\br
 \tcode{struct underlying_type;}
 &
 The member typedef \tcode{type} names the underlying type
 of \tcode{T}.\br
 \requires{} \tcode{T} shall be a complete enumeration type\iref{dcl.enum} \\ \rowsep

\tcode{template<class Fn,}\br
 \tcode{class... ArgTypes>}\br
 \tcode{struct invoke_result;}
 &
 If the expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}
 is well-formed when treated as an unevaluated operand\iref{expr.prop},
 the member typedef \tcode{type} names the type
 \tcode{decltype(\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...))};
 otherwise, there shall be no member \tcode{type}. Access checking is
 performed as if in a context unrelated to \tcode{Fn} and
 \tcode{ArgTypes}. Only the validity of the immediate context of the
 expression is considered.
 \begin{note}
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the ``immediate
 context'' and can result in the program being ill-formed.
 \end{note} \br
 \requires{} \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes} shall
 be complete types, \cv{}~\tcode{void}, or arrays of
 unknown bound.\\
\end{libreqtab2a}

\indexlibrary{\idxcode{aligned_storage}}%
\pnum
\begin{note} A typical implementation would define \tcode{aligned_storage} as:

\begin{codeblock}
template<size_t Len, size_t Alignment>
struct aligned_storage {
  typedef struct {
    alignas(Alignment) unsigned char __data[Len];
  } type;
};
\end{codeblock}
\end{note}

\pnum
It is \impldef{support for extended alignment} whether any extended alignment is
supported\iref{basic.align}.

\indexlibrary{\idxcode{common_type}}%
\pnum
Note A:
For the \tcode{common_type} trait applied to a template parameter pack \tcode{T} of types,
the member \tcode{type} shall be either defined or not present as follows:

\begin{itemize}
\item If \tcode{sizeof...(T)} is zero, there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is one, let \tcode{T0} denote the sole type
constituting the pack \tcode{T}.
The member \grammarterm{typedef-name} \tcode{type} shall denote the same
type, if any, as \tcode{common_type_t<T0, T0>};
otherwise there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is two,
let the first and second types constituting \tcode{T} be denoted
by \tcode{T1} and \tcode{T2}, respectively, and
let \tcode{D1} and \tcode{D2} denote
the same types as \tcode{decay_t<T1>} and \tcode{decay_t<T2>}, respectively.
  \begin{itemize}
  \item If \tcode{is_same_v<T1, D1>} is \tcode{false} or
     \tcode{is_same_v<T2, D2>} is \tcode{false},
     let \tcode{C} denote the same type, if any, as \tcode{common_type_t<D1, D2>}.
  \item Otherwise, let \tcode{C} denote the same type, if any, as
\begin{codeblock}
decay_t<decltype(false ? declval<D1>() : declval<D2>())>
\end{codeblock}
     \begin{note}
     This will not apply if there is a specialization \tcode{common_type<D1, D2>}.
     \end{note}
  \end{itemize}
In either case, the member \grammarterm{typedef-name} \tcode{type} shall denote
the same type, if any, as \tcode{C}.
Otherwise, there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is greater than two,
let \tcode{T1}, \tcode{T2}, and \tcode{R}, respectively,
denote the first, second, and (pack of) remaining types constituting \tcode{T}.
Let \tcode{C} denote the same type, if any, as \tcode{common_type_t<T1, T2>}.
If there is such a type \tcode{C}, the member \grammarterm{typedef-name} \tcode{type}
shall denote the same type, if any, as \tcode{common_type_t<C, R...>}.
Otherwise, there shall be no member \tcode{type}.
\end{itemize}

\pnum
Note B: Notwithstanding the provisions of \ref{meta.type.synop}, and
pursuant to \ref{namespace.std},
a program may specialize \tcode{common_type<T1, T2>}
for types \tcode{T1} and \tcode{T2} such that
\tcode{is_same_v<T1, decay_t<T1>>} and
\tcode{is_same_v<T2, decay_t<T2>>} are each \tcode{true}.
\begin{note}
Such specializations are needed when only explicit conversions
are desired between the template arguments.
\end{note}
Such a specialization need not have a member named \tcode{type},
but if it does, that member shall be a \grammarterm{typedef-name}
for an accessible and unambiguous cv-unqualified non-reference type \tcode{C}
to which each of the types \tcode{T1} and \tcode{T2} is explicitly convertible.
Moreover, \tcode{common_type_t<T1, T2>} shall denote
the same type, if any, as does \tcode{common_type_t<T2, T1>}.
No diagnostic is required for a violation of this Note's rules.

\pnum
\begin{example}
Given these definitions:
\begin{codeblock}
using PF1 = bool  (&)();
using PF2 = short (*)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&);
  void fn(long) const;
  char data;
};

using PMF = void (S::*)(long) const;
using PMD = char  S::*;
\end{codeblock}

the following assertions will hold:

\begin{codeblock}
static_assert(is_same_v<invoke_result_t<S, int>, short>);
static_assert(is_same_v<invoke_result_t<S&, unsigned char, int&>, double>);
static_assert(is_same_v<invoke_result_t<PF1>, bool>);
static_assert(is_same_v<invoke_result_t<PMF, unique_ptr<S>, int>, void>);
static_assert(is_same_v<invoke_result_t<PMD, S>, char&&>);
static_assert(is_same_v<invoke_result_t<PMD, const S*>, const char&>);
\end{codeblock}
\end{example}

\rSec2[meta.logical]{Logical operator traits}

\pnum
This subclause describes type traits for applying logical operators
to other type traits.

\indexlibrary{\idxcode{conjunction}}%
\begin{itemdecl}
template<class... B> struct conjunction : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{conjunction}
forms the logical conjunction of its template type arguments.

\pnum
For a specialization \tcode{conjunction<B1, ..., BN>},
if there is a template type argument \tcode{Bi} for which \tcode{bool(Bi::value)} is \tcode{false},
then instantiating \tcode{conjunction<B1, ..., BN>::value}
does not require the instantiation of \tcode{Bj::value} for \tcode{j > i}.
\begin{note} This is analogous to the short-circuiting behavior of
the built-in operator \tcode{\&\&}.
\end{note}

\pnum
Every template type argument
for which \tcode{Bi::value} is instantiated
shall be usable as a base class and
shall have a member \tcode{value} which
is convertible to \tcode{bool},
is not hidden, and
is unambiguously available in the type.

\pnum
The specialization \tcode{conjunction<B1, ..., BN>}
has a public and unambiguous base that is either
\begin{itemize}
\item
the first type \tcode{Bi} in the list \tcode{true_type, B1, ..., BN}
for which \tcode{bool(Bi::value)} is \tcode{false}, or
\item
if there is no such \tcode{Bi}, the last type in the list.
\end{itemize}
\begin{note} This means a specialization of \tcode{conjunction}
does not necessarily inherit from
either \tcode{true_type} or \tcode{false_type}.
\end{note}

\pnum
The member names of the base class, other than \tcode{conjunction} and
\tcode{operator=}, shall not be hidden and shall be unambiguously available
in \tcode{conjunction}.
\end{itemdescr}

\indexlibrary{\idxcode{disjunction}}%
\begin{itemdecl}
template<class... B> struct disjunction : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{disjunction}
forms the logical disjunction of its template type arguments.

\pnum
For a specialization \tcode{disjunction<B1, ..., BN>},
if there is a template type argument \tcode{Bi} for which \tcode{bool(Bi::value)} is \tcode{true},
then instantiating \tcode{disjunction<B1, ..., BN>::value}
does not require the instantiation of \tcode{Bj::value} for \tcode{j > i}.
\begin{note} This is analogous to the short-circuiting behavior of
the built-in operator \tcode{||}.
\end{note}

\pnum
Every template type argument
for which \tcode{Bi::value} is instantiated
shall be usable as a base class and
shall have a member \tcode{value} which
is convertible to \tcode{bool},
is not hidden, and
is unambiguously available in the type.

\pnum
The specialization \tcode{disjunction<B1, ..., BN>}
has a public and unambiguous base that is either
\begin{itemize}
\item the first type \tcode{Bi} in the list \tcode{false_type, B1, ..., BN}
for which \tcode{bool(Bi::value)} is \tcode{true}, or
\item if there is no such \tcode{Bi}, the last type in the list.
\end{itemize}
\begin{note} This means a specialization of \tcode{disjunction}
does not necessarily inherit from
either \tcode{true_type} or \tcode{false_type}.
\end{note}

\pnum
The member names of the base class,
other than \tcode{disjunction} and \tcode{operator=},
shall not be hidden and shall be unambiguously available in \tcode{disjunction}.
\end{itemdescr}

\indexlibrary{\idxcode{negation}}%
\begin{itemdecl}
template<class B> struct negation : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{negation}
forms the logical negation of its template type argument.
The type \tcode{negation<B>}
is a \tcode{UnaryTypeTrait} with a base characteristic of \tcode{bool_constant<!bool(B::value)>}.
\end{itemdescr}

\rSec2[meta.endian]{Endian}

\pnum
Two common methods of byte ordering in multibyte scalar types are big-endian
and little-endian in the execution environment. Big-endian is a format for
storage of binary data in which the most significant byte is placed first,
with the rest in descending order. Little-endian is a format for storage of
binary data in which the least significant byte is placed first, with the rest
in ascending order. This subclause describes the endianness of the scalar types
of the execution environment.

\indexlibrary{\idxcode{endian}}%
\indexlibrarymember{little}{endian}%
\indexlibrarymember{big}{endian}%
\indexlibrarymember{native}{endian}%
\begin{itemdecl}
enum class endian {
  little = @\seebelow@,
  big    = @\seebelow@,
  native = @\seebelow@
};
\end{itemdecl}

\begin{itemdescr}
\pnum
If all scalar types have size 1 byte, then all of \tcode{endian::little},
\tcode{endian::big}, and \tcode{endian::native} have the same value.
Otherwise, \tcode{endian::little} is not equal to \tcode{endian::big}.
If all scalar types are big-endian, \tcode{endian::native} is
equal to \tcode{endian::big}.
If all scalar types are little-endian, \tcode{endian::native} is
equal to \tcode{endian::little}.
Otherwise, \tcode{endian::native} is not equal
to either \tcode{endian::big} or \tcode{endian::little}.
\end{itemdescr}

\rSec1[ratio]{Compile-time rational arithmetic}

\rSec2[ratio.general]{In general}

\pnum
\indexlibrary{\idxcode{ratio}}%
This subclause describes the ratio library. It provides a class template
\tcode{ratio} which exactly represents any finite rational number with a
numerator and denominator representable by compile-time constants of type
\tcode{intmax_t}.

\pnum
Throughout this subclause, the names of template parameters are used to express
type requirements. If a template parameter is named \tcode{R1} or \tcode{R2},
and the template argument is not a specialization of the \tcode{ratio} template,
the program is ill-formed.

\rSec2[ratio.syn]{Header \tcode{<ratio>} synopsis}

\indexhdr{ratio}%
\begin{codeblockdigitsep}
namespace std {
  // \ref{ratio.ratio}, class template \tcode{ratio}
  template<intmax_t N, intmax_t D = 1> class ratio;

  // \ref{ratio.arithmetic}, ratio arithmetic
  template<class R1, class R2> using ratio_add = @\seebelow@;
  template<class R1, class R2> using ratio_subtract = @\seebelow@;
  template<class R1, class R2> using ratio_multiply = @\seebelow@;
  template<class R1, class R2> using ratio_divide = @\seebelow@;

  // \ref{ratio.comparison}, ratio comparison
  template<class R1, class R2> struct ratio_equal;
  template<class R1, class R2> struct ratio_not_equal;
  template<class R1, class R2> struct ratio_less;
  template<class R1, class R2> struct ratio_less_equal;
  template<class R1, class R2> struct ratio_greater;
  template<class R1, class R2> struct ratio_greater_equal;

  template<class R1, class R2>
    inline constexpr bool ratio_equal_v = ratio_equal<R1, R2>::value;
  template<class R1, class R2>
    inline constexpr bool ratio_not_equal_v = ratio_not_equal<R1, R2>::value;
  template<class R1, class R2>
    inline constexpr bool ratio_less_v = ratio_less<R1, R2>::value;
  template<class R1, class R2>
    inline constexpr bool ratio_less_equal_v = ratio_less_equal<R1, R2>::value;
  template<class R1, class R2>
    inline constexpr bool ratio_greater_v = ratio_greater<R1, R2>::value;
  template<class R1, class R2>
    inline constexpr bool ratio_greater_equal_v = ratio_greater_equal<R1, R2>::value;

  // \ref{ratio.si}, convenience SI typedefs
  using yocto = ratio<1, 1'000'000'000'000'000'000'000'000>;  // see below
  using zepto = ratio<1,     1'000'000'000'000'000'000'000>;  // see below
  using atto  = ratio<1,         1'000'000'000'000'000'000>;
  using femto = ratio<1,             1'000'000'000'000'000>;
  using pico  = ratio<1,                 1'000'000'000'000>;
  using nano  = ratio<1,                     1'000'000'000>;
  using micro = ratio<1,                         1'000'000>;
  using milli = ratio<1,                             1'000>;
  using centi = ratio<1,                               100>;
  using deci  = ratio<1,                                10>;
  using deca  = ratio<                               10, 1>;
  using hecto = ratio<                              100, 1>;
  using kilo  = ratio<                            1'000, 1>;
  using mega  = ratio<                        1'000'000, 1>;
  using giga  = ratio<                    1'000'000'000, 1>;
  using tera  = ratio<                1'000'000'000'000, 1>;
  using peta  = ratio<            1'000'000'000'000'000, 1>;
  using exa   = ratio<        1'000'000'000'000'000'000, 1>;
  using zetta = ratio<    1'000'000'000'000'000'000'000, 1>;  // see below
  using yotta = ratio<1'000'000'000'000'000'000'000'000, 1>;  // see below
}
\end{codeblockdigitsep}

\rSec2[ratio.ratio]{Class template \tcode{ratio}}

\indexlibrary{\idxcode{ratio}}%
\begin{codeblock}
namespace std {
  template<intmax_t N, intmax_t D = 1> class ratio {
  public:
    static constexpr intmax_t num;
    static constexpr intmax_t den;
    using type = ratio<num, den>;
  };
}
\end{codeblock}

\pnum
\indextext{signed integer representation!two's complement}%
If the template argument \tcode{D} is zero or the absolute values of either of the
template arguments \tcode{N} and \tcode{D} is not representable by type
\tcode{intmax_t}, the program is ill-formed. \begin{note} These rules ensure that infinite
ratios are avoided and that for any negative input, there exists a representable value
of its absolute value which is positive. In a two's complement representation, this
excludes the most negative value. \end{note}

\pnum
The static data members \tcode{num} and \tcode{den} shall have the following values,
where \tcode{gcd} represents the greatest common divisor of the absolute values of
\tcode{N} and \tcode{D}:

\begin{itemize}
\item \tcode{num} shall have the value \tcode{sign(N) * sign(D) * abs(N) / gcd}.
\item \tcode{den} shall have the value \tcode{abs(D) / gcd}.
\end{itemize}

\rSec2[ratio.arithmetic]{Arithmetic on \tcode{ratio}{s}}

\pnum
Each of the alias templates \tcode{ratio_add}, \tcode{ratio_subtract}, \tcode{ratio_multiply},
and \tcode{ratio_divide} denotes the result of an arithmetic computation on two
\tcode{ratio}{s} \tcode{R1} and \tcode{R2}. With \tcode{X} and \tcode{Y} computed (in the
absence of arithmetic overflow) as specified by \tref{ratio.arithmetic}, each alias
denotes a \tcode{ratio<U, V>} such that \tcode{U} is the same as \tcode{ratio<X, Y>::num} and
\tcode{V} is the same as \tcode{ratio<X, Y>::den}.

\pnum
If it is not possible to represent \tcode{U} or \tcode{V} with \tcode{intmax_t}, the program is
ill-formed. Otherwise, an implementation should yield correct values of \tcode{U} and
\tcode{V}. If it is not possible to represent \tcode{X} or \tcode{Y} with \tcode{intmax_t}, the
program is ill-formed unless the implementation yields correct values of \tcode{U} and
\tcode{V}.

\begin{floattable}{Expressions used to perform ratio arithmetic}{tab:ratio.arithmetic}
{lll}
\topline
\lhdr{Type}                     &
  \chdr{Value of \tcode{X}}     &
  \rhdr{Value of \tcode{Y}}     \\ \rowsep

\tcode{ratio_add<R1, R2>}       &
  \tcode{R1::num * R2::den +}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_subtract<R1, R2>}  &
  \tcode{R1::num * R2::den -}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_multiply<R1, R2>}  &
  \tcode{R1::num * R2::num}     &
  \tcode{R1::den * R2::den}     \\ \rowsep

\tcode{ratio_divide<R1, R2>}    &
  \tcode{R1::num * R2::den}     &
  \tcode{R1::den * R2::num}     \\
\end{floattable}

\pnum
\begin{example}

\begin{codeblock}
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::den == 2, "1/3*3/2 == 1/2");

// The following cases may cause the program to be ill-formed under some implementations
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::num == 2,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::den == INT_MAX,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::num == 1,
  "1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::den == 2,
  "1/MAX * MAX/2 == 1/2");
\end{codeblock}

\end{example}

\rSec2[ratio.comparison]{Comparison of \tcode{ratio}{s}}

\indexlibrary{\idxcode{ratio_equal}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_equal : bool_constant<R1::num == R2::num && R1::den == R2::den> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_not_equal}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_not_equal : bool_constant<!ratio_equal_v<R1, R2>> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_less}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_less : bool_constant<@\seebelow@> { };
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{R1::num} $\times$ \tcode{R2::den} is less than \tcode{R2::num} $\times$ \tcode{R1::den},
\tcode{ratio_less<R1, R2>} shall be
derived from \tcode{bool_constant<true>}; otherwise it shall be derived from
\tcode{bool_constant<false>}. Implementations may use other algorithms to
compute this relationship to avoid overflow. If overflow occurs, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{ratio_less_equal}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_less_equal : bool_constant<!ratio_less_v<R2, R1>> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_greater}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_greater : bool_constant<ratio_less_v<R2, R1>> { };
\end{itemdecl}

\indexlibrary{\idxcode{ratio_greater_equal}}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_greater_equal : bool_constant<!ratio_less_v<R1, R2>> { };
\end{itemdecl}

\rSec2[ratio.si]{SI types for \tcode{ratio}}

\pnum
For each of the \grammarterm{typedef-name}{s} \tcode{yocto}, \tcode{zepto},
\tcode{zetta}, and \tcode{yotta}, if both of the constants used in its
specification are representable by \tcode{intmax_t}, the typedef shall be
defined; if either of the constants is not representable by \tcode{intmax_t},
the typedef shall not be defined.

\rSec1[time]{Time utilities}

\rSec2[time.general]{In general}

\pnum
\indexlibrary{\idxcode{chrono}}%
This subclause describes the chrono library\iref{time.syn} and various C
functions\iref{ctime.syn} that provide generally useful time
utilities.

\rSec2[time.syn]{Header \tcode{<chrono>} synopsis}

\indexhdr{chrono}%
\indexlibrary{\idxcode{treat_as_floating_point_v}}%
\indexlibrary{\idxcode{is_clock_v}}%
\indexlibrary{\idxcode{nanoseconds}}%
\indexlibrary{\idxcode{microseconds}}%
\indexlibrary{\idxcode{milliseconds}}%
\indexlibrary{\idxcode{seconds}}%
\indexlibrary{\idxcode{minutes}}%
\indexlibrary{\idxcode{hours}}%
\indexlibrary{\idxcode{days}}%
\indexlibrary{\idxcode{weeks}}%
\indexlibrary{\idxcode{years}}%
\indexlibrary{\idxcode{months}}%
\indexlibrary{\idxcode{sys_time}}%
\indexlibrary{\idxcode{sys_seconds}}%
\indexlibrary{\idxcode{sys_days}}%
\indexlibrary{\idxcode{utc_time}}%
\indexlibrary{\idxcode{utc_seconds}}%
\indexlibrary{\idxcode{tai_time}}%
\indexlibrary{\idxcode{tai_seconds}}%
\indexlibrary{\idxcode{gps_time}}%
\indexlibrary{\idxcode{gps_seconds}}%
\indexlibrary{\idxcode{file_time}}%
\indexlibrary{\idxcode{local_time}}%
\indexlibrary{\idxcode{local_seconds}}%
\indexlibrary{\idxcode{local_days}}%
\indexlibrary{\idxcode{local_t}}%
\indexlibrary{\idxcode{choose}}%
\indexlibrarymember{earliest}{choose}%
\indexlibrarymember{latest}{choose}%
\begin{codeblock}
namespace std {
  namespace chrono {
    // \ref{time.duration}, class template \tcode{duration}
    template<class Rep, class Period = ratio<1>> class duration;

    // \ref{time.point}, class template \tcode{time_point}
    template<class Clock, class Duration = typename Clock::duration> class time_point;
  }

  // \ref{time.traits.specializations}, \tcode{common_type} specializations
  template<class Rep1, class Period1, class Rep2, class Period2>
    struct common_type<chrono::duration<Rep1, Period1>,
                       chrono::duration<Rep2, Period2>>;

  template<class Clock, class Duration1, class Duration2>
    struct common_type<chrono::time_point<Clock, Duration1>,
                       chrono::time_point<Clock, Duration2>>;

  namespace chrono {
    // \ref{time.traits}, customization traits
    template<class Rep> struct treat_as_floating_point;
    template<class Rep> struct duration_values;
    template<class Rep>
      inline constexpr bool treat_as_floating_point_v = treat_as_floating_point<Rep>::value;

    template<class T> struct is_clock;
    template<class T> inline constexpr bool is_clock_v = is_clock<T>::value;

    // \ref{time.duration.nonmember}, \tcode{duration} arithmetic
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator*(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Rep2, class Period>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator*(const Rep1& s, const duration<Rep2, Period>& d);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator/(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<Rep1, Rep2>
        operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator%(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

    // \ref{time.duration.comparisons}, \tcode{duration} comparisons
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator==(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator!=(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator< (const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator> (const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);

    // \ref{time.duration.cast}, \tcode{duration_cast}
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration floor(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration ceil(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration round(const duration<Rep, Period>& d);

    // \ref{time.duration.io}, \tcode{duration} I/O
    template<class charT, class traits, class Rep, class Period>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os,
                   const duration<Rep, Period>& d);
    template<class charT, class traits, class Rep, class Period>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const duration<Rep, Period>& d);
    template<class charT, class traits, class Rep, class Period, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    duration<Rep, Period>& d,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // convenience typedefs
    using nanoseconds  = duration<@\term{signed integer type of at least 64 bits}@, nano>;
    using microseconds = duration<@\term{signed integer type of at least 55 bits}@, micro>;
    using milliseconds = duration<@\term{signed integer type of at least 45 bits}@, milli>;
    using seconds      = duration<@\term{signed integer type of at least 35 bits}@>;
    using minutes      = duration<@\term{signed integer type of at least 29 bits}@, ratio<  60>>;
    using hours        = duration<@\term{signed integer type of at least 23 bits}@, ratio<3600>>;
    using days         = duration<@\term{signed integer type of at least 25 bits}@,
                                  ratio_multiply<ratio<24>, hours::period>>;
    using weeks        = duration<@\term{signed integer type of at least 22 bits}@,
                                  ratio_multiply<ratio<7>, days::period>>;
    using years        = duration<@\term{signed integer type of at least 17 bits}@,
                                  ratio_multiply<ratio<146097, 400>, days::period>>;
    using months       = duration<@\term{signed integer type of at least 20 bits}@,
                                  ratio_divide<years::period, ratio<12>>>;

    // \ref{time.point.nonmember}, \tcode{time_point} arithmetic
    template<class Clock, class Duration1, class Rep2, class Period2>
      constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
        operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Clock, class Duration2>
      constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
        operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Rep2, class Period2>
      constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
        operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Clock, class Duration1, class Duration2>
      constexpr common_type_t<Duration1, Duration2>
        operator-(const time_point<Clock, Duration1>& lhs,
                  const time_point<Clock, Duration2>& rhs);

    // \ref{time.point.comparisons}, \tcode{time_point} comparisons
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator!=(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator< (const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator> (const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);

    // \ref{time.point.cast}, \tcode{time_point_cast}
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration>
        time_point_cast(const time_point<Clock, Duration>& t);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp);

    // \ref{time.duration.alg}, specialized algorithms
    template<class Rep, class Period>
      constexpr duration<Rep, Period> abs(duration<Rep, Period> d);

    // \ref{time.clock.system}, class \tcode{system_clock}
    class system_clock;

    template<class Duration>
      using sys_time  = time_point<system_clock, Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days    = sys_time<days>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const sys_time<Duration>& tp);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const sys_days& dp);

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const sys_time<Duration>& tp);

    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    sys_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.utc}, class \tcode{utc_clock}
    class utc_clock;

    template<class Duration>
      using utc_time  = time_point<utc_clock, Duration>;
    using utc_seconds = utc_time<seconds>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const utc_time<Duration>& t);
    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const utc_time<Duration>& tp);
    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    utc_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.tai}, class \tcode{tai_clock}
    class tai_clock;

    template<class Duration>
      using tai_time  = time_point<tai_clock, Duration>;
    using tai_seconds = tai_time<seconds>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const tai_time<Duration>& t);
    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const tai_time<Duration>& tp);
    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    tai_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.gps}, class \tcode{gps_clock}
    class gps_clock;

    template<class Duration>
      using gps_time  = time_point<gps_clock, Duration>;
    using gps_seconds = gps_time<seconds>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const gps_time<Duration>& t);
    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const gps_time<Duration>& tp);
    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    gps_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.file}, class \tcode{file_clock}
    class file_clock;

    template<class Duration>
      using file_time = time_point<file_clock, Duration>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const file_time<Duration>& tp);
    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const file_time<Duration>& tp);
    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    file_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.steady}, class \tcode{steady_clock}
    class steady_clock;

    // \ref{time.clock.hires}, class \tcode{high_resolution_clock}
    class high_resolution_clock;

    // \ref{time.clock.local}, local time
    struct local_t {};
    template<class Duration>
      using local_time  = time_point<local_t, Duration>;
    using local_seconds = local_time<seconds>;
    using local_days    = local_time<days>;

    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const local_time<Duration>& tp);
    template<class charT, class traits, class Duration>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const local_time<Duration>& tp,
                  const string* abbrev = nullptr, const seconds* offset_sec = nullptr);
    template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    local_time<Duration>& tp,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.clock.cast}, \tcode{time_point} conversions
    template<class DestClock, class SourceClock>
      struct clock_time_conversion;

    template<class DestClock, class SourceClock, class Duration>
      auto clock_cast(const time_point<SourceClock, Duration>& t);

    // \ref{time.cal.last}, class \tcode{last_spec}
    struct last_spec;

    // \ref{time.cal.day}, class \tcode{day}
    class day;

    constexpr bool operator==(const day& x, const day& y) noexcept;
    constexpr bool operator!=(const day& x, const day& y) noexcept;
    constexpr bool operator< (const day& x, const day& y) noexcept;
    constexpr bool operator> (const day& x, const day& y) noexcept;
    constexpr bool operator<=(const day& x, const day& y) noexcept;
    constexpr bool operator>=(const day& x, const day& y) noexcept;

    constexpr day  operator+(const day&  x, const days& y) noexcept;
    constexpr day  operator+(const days& x, const day&  y) noexcept;
    constexpr day  operator-(const day&  x, const days& y) noexcept;
    constexpr days operator-(const day&  x, const day&  y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const day& d);
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const day& d);
    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    day& d, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.month}, class \tcode{month}
    class month;

    constexpr bool operator==(const month& x, const month& y) noexcept;
    constexpr bool operator!=(const month& x, const month& y) noexcept;
    constexpr bool operator< (const month& x, const month& y) noexcept;
    constexpr bool operator> (const month& x, const month& y) noexcept;
    constexpr bool operator<=(const month& x, const month& y) noexcept;
    constexpr bool operator>=(const month& x, const month& y) noexcept;

    constexpr month  operator+(const month&  x, const months& y) noexcept;
    constexpr month  operator+(const months& x,  const month& y) noexcept;
    constexpr month  operator-(const month&  x, const months& y) noexcept;
    constexpr months operator-(const month&  x,  const month& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const month& m);
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month& m);
    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    month& m, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.year}, class \tcode{year}
    class year;

    constexpr bool operator==(const year& x, const year& y) noexcept;
    constexpr bool operator!=(const year& x, const year& y) noexcept;
    constexpr bool operator< (const year& x, const year& y) noexcept;
    constexpr bool operator> (const year& x, const year& y) noexcept;
    constexpr bool operator<=(const year& x, const year& y) noexcept;
    constexpr bool operator>=(const year& x, const year& y) noexcept;

    constexpr year  operator+(const year&  x, const years& y) noexcept;
    constexpr year  operator+(const years& x, const year&  y) noexcept;
    constexpr year  operator-(const year&  x, const years& y) noexcept;
    constexpr years operator-(const year&  x, const year&  y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year& y);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year& y);

    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    year& y, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.wd}, class \tcode{weekday}
    class weekday;

    constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
    constexpr bool operator!=(const weekday& x, const weekday& y) noexcept;

    constexpr weekday operator+(const weekday& x, const days&    y) noexcept;
    constexpr weekday operator+(const days&    x, const weekday& y) noexcept;
    constexpr weekday operator-(const weekday& x, const days&    y) noexcept;
    constexpr days    operator-(const weekday& x, const weekday& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const weekday& wd);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const weekday& wd);

    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    weekday& wd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.wdidx}, class \tcode{weekday_indexed}
    class weekday_indexed;

    constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
    constexpr bool operator!=(const weekday_indexed& x, const weekday_indexed& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const weekday_indexed& wdi);

    // \ref{time.cal.wdlast}, class \tcode{weekday_last}
    class weekday_last;

    constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
    constexpr bool operator!=(const weekday_last& x, const weekday_last& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const weekday_last& wdl);

    // \ref{time.cal.md}, class \tcode{month_day}
    class month_day;

    constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
    constexpr bool operator!=(const month_day& x, const month_day& y) noexcept;
    constexpr bool operator< (const month_day& x, const month_day& y) noexcept;
    constexpr bool operator> (const month_day& x, const month_day& y) noexcept;
    constexpr bool operator<=(const month_day& x, const month_day& y) noexcept;
    constexpr bool operator>=(const month_day& x, const month_day& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const month_day& md);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month_day& md);

    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    month_day& md, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.mdlast}, class \tcode{month_day_last}
    class month_day_last;

    constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
    constexpr bool operator!=(const month_day_last& x, const month_day_last& y) noexcept;
    constexpr bool operator< (const month_day_last& x, const month_day_last& y) noexcept;
    constexpr bool operator> (const month_day_last& x, const month_day_last& y) noexcept;
    constexpr bool operator<=(const month_day_last& x, const month_day_last& y) noexcept;
    constexpr bool operator>=(const month_day_last& x, const month_day_last& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const month_day_last& mdl);

    // \ref{time.cal.mwd}, class \tcode{month_weekday}
    class month_weekday;

    constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
    constexpr bool operator!=(const month_weekday& x, const month_weekday& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const month_weekday& mwd);

    // \ref{time.cal.mwdlast}, class \tcode{month_weekday_last}
    class month_weekday_last;

    constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
    constexpr bool operator!=(const month_weekday_last& x, const month_weekday_last& y) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const month_weekday_last& mwdl);

    // \ref{time.cal.ym}, class \tcode{year_month}
    class year_month;

    constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
    constexpr bool operator!=(const year_month& x, const year_month& y) noexcept;
    constexpr bool operator< (const year_month& x, const year_month& y) noexcept;
    constexpr bool operator> (const year_month& x, const year_month& y) noexcept;
    constexpr bool operator<=(const year_month& x, const year_month& y) noexcept;
    constexpr bool operator>=(const year_month& x, const year_month& y) noexcept;

    constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
    constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
    constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
    constexpr months operator-(const year_month& x, const year_month& y) noexcept;
    constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
    constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
    constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year_month& ym);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year_month& ym);

    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    year_month& ym, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.ymd}, class \tcode{year_month_day}
    class year_month_day;

    constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
    constexpr bool operator!=(const year_month_day& x, const year_month_day& y) noexcept;
    constexpr bool operator< (const year_month_day& x, const year_month_day& y) noexcept;
    constexpr bool operator> (const year_month_day& x, const year_month_day& y) noexcept;
    constexpr bool operator<=(const year_month_day& x, const year_month_day& y) noexcept;
    constexpr bool operator>=(const year_month_day& x, const year_month_day& y) noexcept;

    constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
    constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
    constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
    constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
    constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
    constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year_month_day& ymd);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const year_month_day& ymd);

    template<class charT, class traits, class Alloc = allocator<charT>>
      basic_istream<charT, traits>&
        from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                    year_month_day& ymd,
                    basic_string<charT, traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);

    // \ref{time.cal.ymdlast}, class \tcode{year_month_day_last}
    class year_month_day_last;

    constexpr bool operator==(const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr bool operator!=(const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr bool operator< (const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr bool operator> (const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr bool operator<=(const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr bool operator>=(const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;

    constexpr year_month_day_last
      operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
    constexpr year_month_day_last
      operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
    constexpr year_month_day_last
      operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
    constexpr year_month_day_last
      operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
    constexpr year_month_day_last
      operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
    constexpr year_month_day_last
      operator-(const year_month_day_last& ymdl, const years& dy) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year_month_day_last& ymdl);

    // \ref{time.cal.ymwd}, class \tcode{year_month_weekday}
    class year_month_weekday;

    constexpr bool operator==(const year_month_weekday& x,
                              const year_month_weekday& y) noexcept;
    constexpr bool operator!=(const year_month_weekday& x,
                              const year_month_weekday& y) noexcept;

    constexpr year_month_weekday
      operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
    constexpr year_month_weekday
      operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
    constexpr year_month_weekday
      operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
    constexpr year_month_weekday
      operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
    constexpr year_month_weekday
      operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
    constexpr year_month_weekday
      operator-(const year_month_weekday& ymwd, const years& dy) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year_month_weekday& ymwdi);

    // \ref{time.cal.ymwdlast}, class \tcode{year_month_weekday_last}
    class year_month_weekday_last;

    constexpr bool operator==(const year_month_weekday_last& x,
                              const year_month_weekday_last& y) noexcept;
    constexpr bool operator!=(const year_month_weekday_last& x,
                              const year_month_weekday_last& y) noexcept;

    constexpr year_month_weekday_last
      operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
    constexpr year_month_weekday_last
      operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
    constexpr year_month_weekday_last
      operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
    constexpr year_month_weekday_last
      operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
    constexpr year_month_weekday_last
      operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
    constexpr year_month_weekday_last
      operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const year_month_weekday_last& ymwdl);

    // \ref{time.cal.operators}, civil calendar conventional syntax operators
    constexpr year_month
      operator/(const year& y, const month& m) noexcept;
    constexpr year_month
      operator/(const year& y, int m) noexcept;
    constexpr month_day
      operator/(const month& m, const day& d) noexcept;
    constexpr month_day
      operator/(const month& m, int d) noexcept;
    constexpr month_day
      operator/(int m, const day& d) noexcept;
    constexpr month_day
      operator/(const day& d, const month& m) noexcept;
    constexpr month_day
      operator/(const day& d, int m) noexcept;
    constexpr month_day_last
      operator/(const month& m, last_spec) noexcept;
    constexpr month_day_last
      operator/(int m, last_spec) noexcept;
    constexpr month_day_last
      operator/(last_spec, const month& m) noexcept;
    constexpr month_day_last
      operator/(last_spec, int m) noexcept;
    constexpr month_weekday
      operator/(const month& m, const weekday_indexed& wdi) noexcept;
    constexpr month_weekday
      operator/(int m, const weekday_indexed& wdi) noexcept;
    constexpr month_weekday
      operator/(const weekday_indexed& wdi, const month& m) noexcept;
    constexpr month_weekday
      operator/(const weekday_indexed& wdi, int m) noexcept;
    constexpr month_weekday_last
      operator/(const month& m, const weekday_last& wdl) noexcept;
    constexpr month_weekday_last
      operator/(int m, const weekday_last& wdl) noexcept;
    constexpr month_weekday_last
      operator/(const weekday_last& wdl, const month& m) noexcept;
    constexpr month_weekday_last
      operator/(const weekday_last& wdl, int m) noexcept;
    constexpr year_month_day
      operator/(const year_month& ym, const day& d) noexcept;
    constexpr year_month_day
      operator/(const year_month& ym, int d) noexcept;
    constexpr year_month_day
      operator/(const year& y, const month_day& md) noexcept;
    constexpr year_month_day
      operator/(int y, const month_day& md) noexcept;
    constexpr year_month_day
      operator/(const month_day& md, const year& y) noexcept;
    constexpr year_month_day
      operator/(const month_day& md, int y) noexcept;
    constexpr year_month_day_last
      operator/(const year_month& ym, last_spec) noexcept;
    constexpr year_month_day_last
      operator/(const year& y, const month_day_last& mdl) noexcept;
    constexpr year_month_day_last
      operator/(int y, const month_day_last& mdl) noexcept;
    constexpr year_month_day_last
      operator/(const month_day_last& mdl, const year& y) noexcept;
    constexpr year_month_day_last
      operator/(const month_day_last& mdl, int y) noexcept;
    constexpr year_month_weekday
      operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
    constexpr year_month_weekday
      operator/(const year& y, const month_weekday& mwd) noexcept;
    constexpr year_month_weekday
      operator/(int y, const month_weekday& mwd) noexcept;
    constexpr year_month_weekday
      operator/(const month_weekday& mwd, const year& y) noexcept;
    constexpr year_month_weekday
      operator/(const month_weekday& mwd, int y) noexcept;
    constexpr year_month_weekday_last
      operator/(const year_month& ym, const weekday_last& wdl) noexcept;
    constexpr year_month_weekday_last
      operator/(const year& y, const month_weekday_last& mwdl) noexcept;
    constexpr year_month_weekday_last
      operator/(int y, const month_weekday_last& mwdl) noexcept;
    constexpr year_month_weekday_last
      operator/(const month_weekday_last& mwdl, const year& y) noexcept;
    constexpr year_month_weekday_last
      operator/(const month_weekday_last& mwdl, int y) noexcept;

    // \ref{time.tod}, class template \tcode{time_of_day}
    template<class Duration> class time_of_day;
    template<> class time_of_day<hours>;
    template<> class time_of_day<minutes>;
    template<> class time_of_day<seconds>;
    template<class Rep, class Period> class time_of_day<duration<Rep, Period>>;

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const time_of_day<hours>& t);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const time_of_day<minutes>& t);

    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const time_of_day<seconds>& t);

    template<class charT, class traits, class Rep, class Period>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os,
                   const time_of_day<duration<Rep, Period>>& t);

    // \ref{time.zone.db}, time zone database
    struct tzdb;
    class tzdb_list;

    // \ref{time.zone.db.access}, time zone database access
    const tzdb& get_tzdb();
    tzdb_list& get_tzdb_list();
    const time_zone* locate_zone(string_view tz_name);
    const time_zone* current_zone();

    // \ref{time.zone.db.remote}, remote time zone database support
    const tzdb& reload_tzdb();
    string remote_version();

    // \ref{time.zone.exception}, exception classes
    class nonexistent_local_time;
    class ambiguous_local_time;

    // \ref{time.zone.info}, information classes
    struct sys_info;
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const sys_info& si);

    struct local_info;
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os, const local_info& li);

    // \ref{time.zone.timezone}, class \tcode{time_zone}
    enum class choose {earliest, latest};
    class time_zone;

    bool operator==(const time_zone& x, const time_zone& y) noexcept;
    bool operator!=(const time_zone& x, const time_zone& y) noexcept;

    bool operator<(const time_zone& x, const time_zone& y) noexcept;
    bool operator>(const time_zone& x, const time_zone& y) noexcept;
    bool operator<=(const time_zone& x, const time_zone& y) noexcept;
    bool operator>=(const time_zone& x, const time_zone& y) noexcept;

    // \ref{time.zone.zonedtraits}, class template \tcode{zoned_traits}
    template<class T> struct zoned_traits;

    // \ref{time.zone.zonedtime}, class template \tcode{zoned_time}
    template<class Duration, class TimeZonePtr = const time_zone*> class zoned_time;

    using zoned_seconds = zoned_time<seconds>;

    template<class Duration1, class Duration2, class TimeZonePtr>
      bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
                      const zoned_time<Duration2, TimeZonePtr>& y);

    template<class Duration1, class Duration2, class TimeZonePtr>
      bool operator!=(const zoned_time<Duration1, TimeZonePtr>& x,
                      const zoned_time<Duration2, TimeZonePtr>& y);

    template<class charT, class traits, class Duration, class TimeZonePtr>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os,
                   const zoned_time<Duration, TimeZonePtr>& t);

    template<class charT, class traits, class Duration, class TimeZonePtr>
      basic_ostream<charT, traits>&
        to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
                  const zoned_time<Duration, TimeZonePtr>& tp);

    // \ref{time.zone.leap}, leap second support
    class leap;

    bool operator==(const leap& x, const leap& y);
    bool operator!=(const leap& x, const leap& y);
    bool operator< (const leap& x, const leap& y);
    bool operator> (const leap& x, const leap& y);
    bool operator<=(const leap& x, const leap& y);
    bool operator>=(const leap& x, const leap& y);

    template<class Duration>
      bool operator==(const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator==(const sys_time<Duration>& x, const leap& y);
    template<class Duration>
      bool operator!=(const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator!=(const sys_time<Duration>& x, const leap& y);
    template<class Duration>
      bool operator< (const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator< (const sys_time<Duration>& x, const leap& y);
    template<class Duration>
      bool operator> (const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator> (const sys_time<Duration>& x, const leap& y);
    template<class Duration>
      bool operator<=(const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator<=(const sys_time<Duration>& x, const leap& y);
    template<class Duration>
      bool operator>=(const leap& x, const sys_time<Duration>& y);
    template<class Duration>
      bool operator>=(const sys_time<Duration>& x, const leap& y);

    // \ref{time.zone.link}, class \tcode{link}
    class link;

    bool operator==(const link& x, const link& y);
    bool operator!=(const link& x, const link& y);
    bool operator< (const link& x, const link& y);
    bool operator> (const link& x, const link& y);
    bool operator<=(const link& x, const link& y);
    bool operator>=(const link& x, const link& y);

    // \ref{time.format}, formatting
    template<class charT, class Streamable>
      basic_string<charT>
        format(const charT* fmt, const Streamable& s);
    template<class charT, class Streamable>
      basic_string<charT>
        format(const locale& loc, const charT* fmt, const Streamable& s);
    template<class charT, class traits, class Alloc, class Streamable>
      basic_string<charT, traits, Alloc>
        format(const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);
    template<class charT, class traits, class Alloc, class Streamable>
      basic_string<charT, traits, Alloc>
        format(const locale& loc, const basic_string<charT, traits, Alloc>& fmt,
               const Streamable& s);

    // \ref{time.parse}, parsing
    template<class charT, class traits, class Alloc, class Parsable>
      @\unspec@
        parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp);

    template<class charT, class traits, class Alloc, class Parsable>
      @\unspec@
        parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
              basic_string<charT, traits, Alloc>& abbrev);

    template<class charT, class traits, class Alloc, class Parsable>
      @\unspec@
        parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
              minutes& offset);

    template<class charT, class traits, class Alloc, class Parsable>
      @\unspec@
        parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
              basic_string<charT, traits, Alloc>& abbrev, minutes& offset);

    // calendrical constants
    inline constexpr last_spec last{};

    inline constexpr weekday Sunday{0};
    inline constexpr weekday Monday{1};
    inline constexpr weekday Tuesday{2};
    inline constexpr weekday Wednesday{3};
    inline constexpr weekday Thursday{4};
    inline constexpr weekday Friday{5};
    inline constexpr weekday Saturday{6};

    inline constexpr month January{1};
    inline constexpr month February{2};
    inline constexpr month March{3};
    inline constexpr month April{4};
    inline constexpr month May{5};
    inline constexpr month June{6};
    inline constexpr month July{7};
    inline constexpr month August{8};
    inline constexpr month September{9};
    inline constexpr month October{10};
    inline constexpr month November{11};
    inline constexpr month December{12};
  }

  inline namespace literals {
  inline namespace chrono_literals {
    // \ref{time.duration.literals}, suffixes for duration literals
    constexpr chrono::hours                                 operator""h(unsigned long long);
    constexpr chrono::duration<@\unspec,@ ratio<3600, 1>> operator""h(long double);

    constexpr chrono::minutes                             operator""min(unsigned long long);
    constexpr chrono::duration<@\unspec,@ ratio<60, 1>> operator""min(long double);

    constexpr chrono::seconds               operator""s(unsigned long long);
    constexpr chrono::duration<@\unspec@>@\itcorr[-1]@ operator""s(long double);

    constexpr chrono::milliseconds                 operator""ms(unsigned long long);
    constexpr chrono::duration<@\unspec,@ milli> operator""ms(long double);

    constexpr chrono::microseconds                 operator""us(unsigned long long);
    constexpr chrono::duration<@\unspec,@ micro> operator""us(long double);

    constexpr chrono::nanoseconds                 operator""ns(unsigned long long);
    constexpr chrono::duration<@\unspec,@ nano> operator""ns(long double);

    // \ref{time.cal.day.nonmembers}, non-member functions
    constexpr chrono::day  operator""d(unsigned long long d) noexcept;

    // \ref{time.cal.year.nonmembers}, non-member functions
    constexpr chrono::year operator""y(unsigned long long y) noexcept;
  }
  }

  namespace chrono {
    using namespace literals::chrono_literals;
  }
}
\end{codeblock}

\rSec2[time.clock.req]{Clock requirements}

\pnum
A clock is a bundle consisting of a \tcode{duration}, a
\tcode{time_point}, and a function \tcode{now()} to get the current \tcode{time_point}.
The origin of the clock's \tcode{time_point} is referred to as the clock's \defn{epoch}.
 A clock shall satisfy the requirements in \tref{time.clock}.

\pnum
In \tref{time.clock} \tcode{C1} and \tcode{C2} denote clock types. \tcode{t1} and
\tcode{t2} are values returned by \tcode{C1::now()} where the call returning \tcode{t1} happens
before\iref{intro.multithread} the call returning \tcode{t2} and both of these calls
occur
before \tcode{C1::time_point::max()}.
\begin{note} This means \tcode{C1} did not wrap around between \tcode{t1} and
\tcode{t2}. \end{note}

\begin{libreqtab3a}
{Clock requirements}
{tab:time.clock}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Operational semantics} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}       &   \chdr{Return type}  &   \rhdr{Operational semantics}       \\ \capsep
\endhead

\tcode{C1::rep} &
  An arithmetic type or a class emulating an arithmetic type &
  The representation type of \tcode{C1::duration}.  \\ \rowsep

\tcode{C1::period}  &
  a specialization of \tcode{ratio}     &
  The tick period of the clock in seconds.  \\ \rowsep

\tcode{C1::duration}  &
  \tcode{chrono::duration<C1::rep, C1::period>} &
  The \tcode{duration} type of the clock. \\ \rowsep

\tcode{C1::time_point}  &
  \tcode{chrono::time_point<C1>} or \tcode{chrono::time_point<C2, C1::duration>}  &
  The \tcode{time_point} type of the clock. \tcode{C1} and \tcode{C2} shall
  refer to the same epoch. \\ \rowsep

\tcode{C1::is_steady}  &
  \tcode{const bool}      &
  \tcode{true} if \tcode{t1 <= t2} is always \tcode{true} and the time between clock
  ticks is constant, otherwise \tcode{false}.  \\ \rowsep

\tcode{C1::now()} &
  \tcode{C1::time_point}  &
  Returns a \tcode{time_point} object representing the current point in time. \\

\end{libreqtab3a}

\pnum
\begin{note} The relative difference in durations between those reported by a given clock and the
SI definition is a measure of the quality of implementation. \end{note}

\pnum
A type \tcode{TC} meets the \tcode{TrivialClock} requirements if:

\begin{itemize}
\item \tcode{TC} satisfies the \tcode{Clock} requirements\iref{time.clock.req},

\item the types \tcode{TC::rep}, \tcode{TC::duration}, and \tcode{TC::time_point}
satisfy the \tcode{EqualityComparable} (\tref{equalitycomparable}),
\tcode{LessThanComparable} (\tref{lessthancomparable}),
\tcode{DefaultConstructible} (\tref{defaultconstructible}),
\tcode{CopyCon\-structible} (\tref{copyconstructible}),
\tcode{CopyAssignable} (\tref{copyassignable}), and
\tcode{Destructible} (\tref{destructible}) requirements and the requirements of
numeric types\iref{numeric.requirements}. \begin{note} This means, in particular,
that operations on these types will not throw exceptions. \end{note}

\item lvalues of the types \tcode{TC::rep}, \tcode{TC::duration}, and
\tcode{TC::time_point} are swappable\iref{swappable.requirements},

\item the function \tcode{TC::now()} does not throw exceptions, and

\item the type \tcode{TC::time_point::clock} meets the \tcode{TrivialClock}
requirements, recursively.
\end{itemize}

\rSec2[time.traits]{Time-related traits}

\rSec3[time.traits.is_fp]{\tcode{treat_as_floating_point}}

\indexlibrary{\idxcode{treat_as_floating_point}}%
\begin{itemdecl}
template<class Rep> struct treat_as_floating_point : is_floating_point<Rep> { };
\end{itemdecl}

\pnum
The \tcode{duration} template uses the \tcode{treat_as_floating_point} trait to
help determine if a \tcode{duration} object can be converted to another
\tcode{duration} with a different tick \tcode{period}. If
\tcode{treat_as_floating_point_v<Rep>} is \tcode{true}, then implicit conversions
are allowed among \tcode{duration}s. Otherwise, the implicit convertibility
depends on the tick \tcode{period}s of the \tcode{duration}s.
\begin{note}
The intention of this trait is to indicate whether a given class behaves like a floating-point
type, and thus allows division of one value by another with acceptable loss of precision. If
\tcode{treat_as_floating_point_v<Rep>} is \tcode{false}, \tcode{Rep} will be treated as
if it behaved like an integral type for the purpose of these conversions.
\end{note}

\rSec3[time.traits.duration_values]{\tcode{duration_values}}

\indexlibrary{\idxcode{duration_values}}%
\begin{itemdecl}
template<class Rep>
  struct duration_values {
  public:
    static constexpr Rep zero();
    static constexpr Rep min();
    static constexpr Rep max();
};
\end{itemdecl}

\pnum
The \tcode{duration} template uses the \tcode{duration_values} trait to
construct special values of the duration's representation (\tcode{Rep}). This is
done because the representation might be a class type with behavior which
requires some other implementation to return these special values. In that case,
the author of that class type should specialize \tcode{duration_values} to
return the indicated values.

\indexlibrarymember{zero}{duration_values}%
\begin{itemdecl}
static constexpr Rep zero();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{Rep(0)}. \begin{note} \tcode{Rep(0)} is specified instead of
\tcode{Rep()} because \tcode{Rep()} may have some other meaning, such as an
uninitialized value. \end{note}

\pnum
\remarks The value returned shall be the additive identity.
\end{itemdescr}

\indexlibrarymember{min}{duration_values}%
\begin{itemdecl}
static constexpr Rep min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{numeric_limits<Rep>::lowest()}.

\pnum
\remarks The value returned shall compare less than or equal to \tcode{zero()}.
\end{itemdescr}

\indexlibrarymember{max}{duration_values}%
\begin{itemdecl}
static constexpr Rep max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{numeric_limits<Rep>::max()}.

\pnum
\remarks The value returned shall compare greater than \tcode{zero()}.
\end{itemdescr}

\rSec3[time.traits.specializations]{Specializations of \tcode{common_type}}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>> {
  using type = chrono::duration<common_type_t<Rep1, Rep2>, @\seebelow@>;
};
\end{itemdecl}

\pnum
The \tcode{period} of the \tcode{duration} indicated by this specialization of
\tcode{common_type} shall be the greatest common divisor of \tcode{Period1} and
\tcode{Period2}. \begin{note} This can be computed by forming a ratio of the
greatest common divisor of \tcode{Period1::num} and \tcode{Period2::num} and the
least common multiple of \tcode{Period1::den} and \tcode{Period2::den}.
\end{note}

\pnum
\begin{note} The \tcode{typedef} name \tcode{type} is a synonym for the
\tcode{duration} with the largest tick \tcode{period} possible where both
\tcode{duration} arguments will convert to it without requiring a division
operation. The representation of this type is intended to be able to hold any
value resulting from this conversion with no truncation error, although
floating-point durations may have round-off errors. \end{note}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>> {
    using type = chrono::time_point<Clock, common_type_t<Duration1, Duration2>>;
};
\end{itemdecl}

\pnum
The common type of two \tcode{time_point} types is a \tcode{time_point} with the same
clock as the two types and the common type of their two \tcode{duration}s.

\rSec3[time.traits.is_clock]{Class template \tcode{is_clock}}

\indexlibrary{\idxcode{is_clock}}%
\begin{itemdecl}
template<class T> struct is_clock;
\end{itemdecl}

\pnum
\tcode{is_clock} is a UnaryTypeTrait\iref{meta.rqmts}
with a base characteristic of \tcode{true_type}
if \tcode{T} meets the Clock requirements\iref{time.clock.req},
otherwise \tcode{false_type}.
For the purposes of the specification of this trait,
the extent to which an implementation determines
that a type cannot meet the Clock requirements is unspecified,
except that as a minimum
a type \tcode{T} shall not qualify as a Clock
unless it satisfies all of the following conditions:

\begin{itemize}
\item the \grammarterm{qualified-id}s
\tcode{T::rep},
\tcode{T::period},
\tcode{T::duration}, and
\tcode{T::time_point}
are valid and each denotes a type\iref{temp.deduct},
\item the expression
\tcode{T::is_steady}
is well-formed when treated as an unevaluated operand,
\item the expression
\tcode{T::now()}
is well-formed when treated as an unevaluated operand.
\end{itemize}

\pnum
The behavior of a program that adds specializations for \tcode{is_clock} is undefined.

\rSec2[time.duration]{Class template \tcode{duration}}

\pnum
A \tcode{duration} type measures time between two points in time (\tcode{time_point}s).
A \tcode{duration} has a representation which holds a count of ticks and a tick period.
The tick period is the amount of time which occurs from one tick to the next, in units
of seconds. It is expressed as a rational constant using the template \tcode{ratio}.

\indexlibrary{\idxcode{duration}}%
\begin{codeblock}
namespace std::chrono {
  template<class Rep, class Period = ratio<1>>
  class duration {
  public:
    using rep    = Rep;
    using period = typename Period::type;

  private:
    rep rep_;       // \expos

  public:
    // \ref{time.duration.cons}, construct/copy/destroy
    constexpr duration() = default;
    template<class Rep2>
      constexpr explicit duration(const Rep2& r);
    template<class Rep2, class Period2>
      constexpr duration(const duration<Rep2, Period2>& d);
    ~duration() = default;
    duration(const duration&) = default;
    duration& operator=(const duration&) = default;

    // \ref{time.duration.observer}, observer
    constexpr rep count() const;

    // \ref{time.duration.arithmetic}, arithmetic
    constexpr common_type_t<duration> operator+() const;
    constexpr common_type_t<duration> operator-() const;
    constexpr duration& operator++();
    constexpr duration  operator++(int);
    constexpr duration& operator--();
    constexpr duration  operator--(int);

    constexpr duration& operator+=(const duration& d);
    constexpr duration& operator-=(const duration& d);

    constexpr duration& operator*=(const rep& rhs);
    constexpr duration& operator/=(const rep& rhs);
    constexpr duration& operator%=(const rep& rhs);
    constexpr duration& operator%=(const duration& rhs);

    // \ref{time.duration.special}, special values
    static constexpr duration zero();
    static constexpr duration min();
    static constexpr duration max();
  };
}
\end{codeblock}

\pnum
\tcode{Rep} shall be an arithmetic type or a class emulating an arithmetic type.
If \tcode{duration} is instantiated with a \tcode{duration} type as the argument for the template
parameter \tcode{Rep}, the program is ill-formed.

\pnum
If \tcode{Period} is not a specialization of \tcode{ratio}, the program is ill-formed.
If \tcode{Period::num} is not positive, the program is ill-formed.

\pnum
Members of \tcode{duration} shall not throw exceptions other than
those thrown by the indicated operations on their representations.

\pnum
The defaulted copy constructor of duration shall be a
constexpr function if and only if the required initialization
of the member \tcode{rep_} for copy and move, respectively, would
satisfy the requirements for a constexpr function.

\pnum
\begin{example}
\begin{codeblock}
duration<long, ratio<60>> d0;       // holds a count of minutes using a \tcode{long}
duration<long long, milli> d1;      // holds a count of milliseconds using a \tcode{long long}
duration<double, ratio<1, 30>>  d2; // holds a count with a tick period of $\frac{1}{30}$ of a second
                                    // (30 Hz) using a \tcode{double}
\end{codeblock}
\end{example}

\rSec3[time.duration.cons]{\tcode{duration} constructors}

\indexlibrary{\idxcode{duration}!constructor}%
\begin{itemdecl}
template<class Rep2>
  constexpr explicit duration(const Rep2& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload
resolution unless
\tcode{Rep2} is implicitly convertible to \tcode{rep} and
\begin{itemize}
\item \tcode{treat_as_floating_point_v<rep>} is \tcode{true} or
\item \tcode{treat_as_floating_point_v<Rep2>} is \tcode{false}.
\end{itemize}
\begin{example}
\begin{codeblock}
duration<int, milli> d(3);          // OK
duration<int, milli> d(3.5);        // error
\end{codeblock}
\end{example}

\pnum
\effects Constructs an object of type \tcode{duration}.

\pnum
\postconditions \tcode{count() == static_cast<rep>(r)}.
\end{itemdescr}

\indexlibrary{\idxcode{duration}!constructor}%
\begin{itemdecl}
template<class Rep2, class Period2>
  constexpr duration(const duration<Rep2, Period2>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload resolution unless
no overflow is induced in the conversion and
\tcode{treat_as_floating_point_v<rep>} is \tcode{true} or both
\tcode{ratio_divide<Period2, period>::den} is \tcode{1} and
\tcode{treat_as_floating_point_v<Rep2>} is \tcode{false}. \begin{note} This
requirement prevents implicit truncation error when converting between
integral-based \tcode{duration} types. Such a construction could easily lead to
confusion about the value of the \tcode{duration}. \end{note}
\begin{example}
\begin{codeblock}
duration<int, milli> ms(3);
duration<int, micro> us = ms;       // OK
duration<int, milli> ms2 = us;      // error
\end{codeblock}
\end{example}

\pnum
\effects Constructs an object of type \tcode{duration}, constructing \tcode{rep_} from\\
\tcode{duration_cast<duration>(d).count()}.
\end{itemdescr}

\rSec3[time.duration.observer]{\tcode{duration} observer}

\indexlibrarymember{count}{duration}%
\begin{itemdecl}
constexpr rep count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rep_}.
\end{itemdescr}

\rSec3[time.duration.arithmetic]{\tcode{duration} arithmetic}

\indexlibrarymember{operator+}{duration}%
\begin{itemdecl}
constexpr common_type_t<duration> operator+() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{common_type_t<duration>(*this)}.
\end{itemdescr}

\indexlibrarymember{operator-}{duration}%
\begin{itemdecl}
constexpr common_type_t<duration> operator-() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{common_type_t<duration>(-rep_)}.
\end{itemdescr}

\indexlibrarymember{operator++}{duration}%
\begin{itemdecl}
constexpr duration& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{++rep_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{duration}%
\begin{itemdecl}
constexpr duration operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(rep_++)}.
\end{itemdescr}

\indexlibrarymember{operator\dcr}{duration}%
\begin{itemdecl}
constexpr duration& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{--rep_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\dcr}{duration}%
\begin{itemdecl}
constexpr duration operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(rep_-{}-)}.
\end{itemdescr}

\indexlibrarymember{operator+=}{duration}%
\begin{itemdecl}
constexpr duration& operator+=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ += d.count();}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{duration}%
\begin{itemdecl}
constexpr duration& operator-=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ -= d.count();}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*=}{duration}%
\begin{itemdecl}
constexpr duration& operator*=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ *= rhs;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator/=}{duration}%
\begin{itemdecl}
constexpr duration& operator/=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ /= rhs;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\%=}{duration}%
\begin{itemdecl}
constexpr duration& operator%=(const rep& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ \%= rhs;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\%=}{duration}%
\begin{itemdecl}
constexpr duration& operator%=(const duration& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{rep_ \%= rhs.count();}

\pnum
\returns \tcode{*this}.
\end{itemdescr}


\rSec3[time.duration.special]{\tcode{duration} special values}

\indexlibrarymember{zero}{duration}%
\begin{itemdecl}
static constexpr duration zero();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::zero())}.
\end{itemdescr}

\indexlibrarymember{min}{duration}%
\begin{itemdecl}
static constexpr duration min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::min())}.
\end{itemdescr}

\indexlibrarymember{max}{duration}%
\begin{itemdecl}
static constexpr duration max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{duration(duration_values<rep>::max())}.
\end{itemdescr}

\rSec3[time.duration.nonmember]{\tcode{duration} non-member arithmetic}

\pnum
In the function descriptions that follow, \tcode{CD} represents the return type
of the function.

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
    operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CD(CD(lhs).count() + CD(rhs).count())}.
\end{itemdescr}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CD(CD(lhs).count() - CD(rhs).count())}.
\end{itemdescr}

\indexlibrarymember{operator*}{duration}%
\begin{itemdecl}
template<class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
    operator*(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{common_type_t<Rep1, Rep2>}.

\pnum
\returns \tcode{CD(CD(d).count() * s)}.
\end{itemdescr}

\indexlibrarymember{operator*}{duration}%
\begin{itemdecl}
template<class Rep1, class Rep2, class Period>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
    operator*(const Rep1& s, const duration<Rep2, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep1} is implicitly convertible to \tcode{common_type_t<Rep1, Rep2>}.

\pnum
\returns \tcode{d * s}.
\end{itemdescr}

\indexlibrarymember{operator/}{duration}%
\begin{itemdecl}
template<class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
    operator/(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{common_type_t<Rep1, Rep2>}
and \tcode{Rep2} is not a specialization of \tcode{duration}.

\pnum
\returns \tcode{CD(CD(d).count() / s)}.
\end{itemdescr}

\indexlibrarymember{operator/}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<Rep1, Rep2>
    operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CD(lhs).count() / CD(rhs).count()}.
\end{itemdescr}

\indexlibrarymember{operator\%}{duration}%
\begin{itemdecl}
template<class Rep1, class Period, class Rep2>
  constexpr duration<common_type_t<Rep1, Rep2>, Period>
    operator%(const duration<Rep1, Period>& d, const Rep2& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This operator shall not participate in overload
resolution unless \tcode{Rep2} is implicitly convertible to \tcode{common_type_t<Rep1, Rep2>} and
\tcode{Rep2} is not a specialization of \tcode{duration}.

\pnum
\returns \tcode{CD(CD(d).count() \% s)}.
\end{itemdescr}

\indexlibrarymember{operator\%}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
    operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CD(CD(lhs).count() \% CD(rhs).count())}.
\end{itemdescr}


\rSec3[time.duration.comparisons]{\tcode{duration} comparisons}

\pnum
In the function descriptions that follow, \tcode{CT} represents
\tcode{common_type_t<A, B>}, where \tcode{A} and \tcode{B} are the types of
the two arguments to the function.

\indexlibrarymember{operator==}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator==(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs).count() == CT(rhs).count()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator!=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrarymember{operator<}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator<(const duration<Rep1, Period1>& lhs,
                           const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs).count() < CT(rhs).count()}.
\end{itemdescr}

\indexlibrarymember{operator>}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator>(const duration<Rep1, Period1>& lhs,
                           const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

\indexlibrarymember{operator<=}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Rep2, class Period2>
  constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
                            const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

\rSec3[time.duration.cast]{\tcode{duration_cast}}

\indexlibrary{\idxcode{duration}!\idxcode{duration_cast}}%
\indexlibrary{\idxcode{duration_cast}}%
\begin{itemdecl}
template<class ToDuration, class Rep, class Period>
  constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns Let \tcode{CF} be \tcode{ratio_divide<Period, typename
ToDuration::period>}, and \tcode{CR} be \tcode{common_type<typename
ToDuration::rep, Rep, intmax_t>::type}.
\begin{itemize}
\item If \tcode{CF::num == 1} and \tcode{CF::den == 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(d.count()))
\end{codeblock}

\item otherwise, if \tcode{CF::num != 1} and \tcode{CF::den == 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) * static_cast<CR>(CF::num)))
\end{codeblock}

\item otherwise, if \tcode{CF::num == 1} and \tcode{CF::den != 1}, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) / static_cast<CR>(CF::den)))
\end{codeblock}

\item otherwise, returns
\begin{codeblock}
ToDuration(static_cast<typename ToDuration::rep>(
  static_cast<CR>(d.count()) * static_cast<CR>(CF::num) / static_cast<CR>(CF::den)))
\end{codeblock}
\end{itemize}

\pnum
\begin{note}
This function does not use any implicit conversions; all conversions
are done with \tcode{static_cast}. It avoids multiplications and divisions when
it is known at compile time that one or more arguments is 1. Intermediate
computations are carried out in the widest representation and only converted to
the destination representation at the final step.
\end{note}
\end{itemdescr}

\indexlibrarymember{floor}{duration}%
\begin{itemdecl}
template<class ToDuration, class Rep, class Period>
  constexpr ToDuration floor(const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns The greatest result \tcode{t} representable in \tcode{ToDuration}
for which \tcode{t <= d}.
\end{itemdescr}

\indexlibrarymember{ceil}{duration}%
\begin{itemdecl}
template<class ToDuration, class Rep, class Period>
  constexpr ToDuration ceil(const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns The least result \tcode{t} representable in \tcode{ToDuration}
for which \tcode{t >= d}.
\end{itemdescr}

\indexlibrarymember{round}{duration}%
\begin{itemdecl}
template<class ToDuration, class Rep, class Period>
  constexpr ToDuration round(const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration},
and \tcode{treat_as_floating_point_v<typename ToDuration::rep>}
is \tcode{false}.

\pnum
\returns The value of \tcode{ToDuration} that is closest to \tcode{d}.
If there are two closest values, then return the value \tcode{t}
for which \tcode{t \% 2 == 0}.
\end{itemdescr}

\rSec3[time.duration.literals]{Suffixes for duration literals}

\pnum
This subclause describes literal suffixes for constructing duration literals. The
suffixes \tcode{h}, \tcode{min}, \tcode{s}, \tcode{ms}, \tcode{us}, \tcode{ns}
denote duration values of the corresponding types \tcode{hours}, \tcode{minutes},
\tcode{seconds}, \tcode{milliseconds}, \tcode{microseconds}, and \tcode{nanoseconds}
respectively if they are applied to integral literals.

\pnum
If any of these suffixes are applied to a floating-point literal the result is a
\tcode{chrono::duration} literal with an unspecified floating-point representation.

\pnum
If any of these suffixes are applied to an integer literal and the resulting
\tcode{chrono::duration} value cannot be represented in the result type because
of overflow, the program is ill-formed.

\pnum
\begin{example}
The following code shows some duration literals.
\begin{codeblock}
using namespace std::chrono_literals;
auto constexpr aday=24h;
auto constexpr lesson=45min;
auto constexpr halfanhour=0.5h;
\end{codeblock}
\end{example}

\indexlibrarymember{operator""""h}{duration}%
\begin{itemdecl}
constexpr chrono::hours                                 operator""h(unsigned long long hours);
constexpr chrono::duration<@\unspec,@ ratio<3600, 1>> operator""h(long double hours);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{hours} hours.
\end{itemdescr}

\indexlibrarymember{operator""""min}{duration}%
\begin{itemdecl}
constexpr chrono::minutes                             operator""min(unsigned long long minutes);
constexpr chrono::duration<@\unspec,@ ratio<60, 1>> operator""min(long double minutes);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{minutes} minutes.
\end{itemdescr}

\indexlibrarymember{operator""""s}{duration}%
\begin{itemdecl}
constexpr chrono::seconds  @\itcorr@             operator""s(unsigned long long sec);
constexpr chrono::duration<@\unspec@> operator""s(long double sec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{sec} seconds.

\pnum
\begin{note}
The same suffix \tcode{s} is used for \tcode{basic_string} but there is no
conflict, since duration suffixes apply to numbers and string literal suffixes
apply to character array literals.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator""""ms}{duration}%
\begin{itemdecl}
constexpr chrono::milliseconds                 operator""ms(unsigned long long msec);
constexpr chrono::duration<@\unspec,@ milli> operator""ms(long double msec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{msec} milliseconds.
\end{itemdescr}

\indexlibrarymember{operator""""us}{duration}%
\begin{itemdecl}
constexpr chrono::microseconds                 operator""us(unsigned long long usec);
constexpr chrono::duration<@\unspec,@ micro> operator""us(long double usec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{usec} microseconds.
\end{itemdescr}

\indexlibrarymember{operator""""ns}{duration}%
\begin{itemdecl}
constexpr chrono::nanoseconds                 operator""ns(unsigned long long nsec);
constexpr chrono::duration<@\unspec,@ nano> operator""ns(long double nsec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{duration} literal representing \tcode{nsec} nanoseconds.
\end{itemdescr}

\rSec3[time.duration.alg]{\tcode{duration} algorithms}

\indexlibrarymember{abs}{duration}%
\begin{itemdecl}
template<class Rep, class Period>
  constexpr duration<Rep, Period> abs(duration<Rep, Period> d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{numeric_limits<Rep>::is_signed} is \tcode{true}.

\pnum
\returns If \tcode{d >= d.zero()}, return \tcode{d},
otherwise return \tcode{-d}.
\end{itemdescr}

\rSec3[time.duration.io]{\tcode{duration} I/O}

\indexlibrarymember{operator<<}{duration}%
\begin{itemdecl}
template<class charT, class traits, class Rep, class Period>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{Rep} is an integral type
whose integer conversion rank\iref{conv.rank}
is greater than or equal to that of \tcode{short},
or a floating point type.
\tcode{charT} is \tcode{char} or \tcode{wchar_t}.

\pnum
\effects
Forms a \tcode{basic_string<charT, traits>} from \tcode{d.count()}
using \tcode{to_string} if \tcode{charT} is \tcode{char},
or \tcode{to_wstring} if \tcode{charT} is \tcode{wchar_t}.
Appends the units suffix described below to the \tcode{basic_string}.
Inserts the resulting \tcode{basic_string} into \tcode{os}.
\begin{note}
This specification ensures that the result of this streaming operation
will obey the width and alignment properties of the stream.
\end{note}

\pnum
The units suffix depends on the type \tcode{Period::type} as follows:
\begin{itemize}
\item If \tcode{Period::type} is \tcode{atto}, the suffix is \tcode{"as"}.
\item Otherwise, if \tcode{Period::type} is \tcode{femto}, the suffix is \tcode{"fs"}.
\item Otherwise, if \tcode{Period::type} is \tcode{pico}, the suffix is \tcode{"ps"}.
\item Otherwise, if \tcode{Period::type} is \tcode{nano}, the suffix is \tcode{"ns"}.
\item Otherwise, if \tcode{Period::type} is \tcode{micro}, the suffix is \tcode{"\textmu{}s"} (\tcode{"\textbackslash{}u00b5\textbackslash{}u0073"}).
\item Otherwise, if \tcode{Period::type} is \tcode{milli}, the suffix is \tcode{"ms"}.
\item Otherwise, if \tcode{Period::type} is \tcode{centi}, the suffix is \tcode{"cs"}.
\item Otherwise, if \tcode{Period::type} is \tcode{deci}, the suffix is \tcode{"ds"}.
\item Otherwise, if \tcode{Period::type} is \tcode{ratio<1>}, the suffix is \tcode{"s"}.
\item Otherwise, if \tcode{Period::type} is \tcode{deca}, the suffix is \tcode{"das"}.
\item Otherwise, if \tcode{Period::type} is \tcode{hecto}, the suffix is \tcode{"hs"}.
\item Otherwise, if \tcode{Period::type} is \tcode{kilo}, the suffix is \tcode{"ks"}.
\item Otherwise, if \tcode{Period::type} is \tcode{mega}, the suffix is \tcode{"Ms"}.
\item Otherwise, if \tcode{Period::type} is \tcode{giga}, the suffix is \tcode{"Gs"}.
\item Otherwise, if \tcode{Period::type} is \tcode{tera}, the suffix is \tcode{"Ts"}.
\item Otherwise, if \tcode{Period::type} is \tcode{peta}, the suffix is \tcode{"Ps"}.
\item Otherwise, if \tcode{Period::type} is \tcode{exa}, the suffix is \tcode{"Es"}.
\item Otherwise, if \tcode{Period::type} is \tcode{ratio<60>}, the suffix is \tcode{"min"}.
\item Otherwise, if \tcode{Period::type} is \tcode{ratio<3600>}, the suffix is \tcode{"h"}.
\item Otherwise, if \tcode{Period::type::den == 1}, the suffix is \tcode{"[\placeholder{num}]s"}.
\item Otherwise, the suffix is \tcode{"[\placeholder{num}/\placeholder{den}]s"}.
\end{itemize}
In the list above the use of \tcode{\placeholder{num}} and \tcode{\placeholder{den}}
refer to the static data members of \tcode{Period::type},
which are converted to arrays of \tcode{charT} using a decimal conversion with no leading zeroes.

\pnum
For streams where \tcode{charT} has an 8-bit representation,
\tcode{"\textmu{}s"} should be encoded as UTF-8. Otherwise UTF-16 or UTF-32 is encouraged.
The implementation may substitute other encodings, including \tcode{"us"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{duration}%
\begin{itemdecl}
template<class charT, class traits, class Rep, class Period>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
              const duration<Rep, Period>& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{d} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{duration}%
\begin{itemdecl}
template<class charT, class traits, class Rep, class Period, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                duration<Rep, Period>& d,
                basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the duration \tcode{d}
using the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse parses everything specified by the parsing format flags without error,
and yet none of the flags impacts a duration,
\tcode{d} will be assigned a zero value.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec2[time.point]{Class template \tcode{time_point}}

\indexlibrary{\idxcode{time_point}}%
\begin{codeblock}
namespace std::chrono {
  template<class Clock, class Duration = typename Clock::duration>
  class time_point {
  public:
    using clock    = Clock;
    using duration = Duration;
    using rep      = typename duration::rep;
    using period   = typename duration::period;

  private:
    duration d_;                                                // \expos

  public:
    // \ref{time.point.cons}, construct
    constexpr time_point();                                     // has value epoch
    constexpr explicit time_point(const duration& d);           // same as \tcode{time_point() + d}
    template<class Duration2>
      constexpr time_point(const time_point<clock, Duration2>& t);

    // \ref{time.point.observer}, observer
    constexpr duration time_since_epoch() const;

    // \ref{time.point.arithmetic}, arithmetic
    constexpr time_point& operator++();
    constexpr time_point operator++(int);
    constexpr time_point& operator--();
    constexpr time_point operator--(int);
    constexpr time_point& operator+=(const duration& d);
    constexpr time_point& operator-=(const duration& d);

    // \ref{time.point.special}, special values
    static constexpr time_point min();
    static constexpr time_point max();
  };
}
\end{codeblock}

\pnum
\tcode{Clock} shall either
satisfy the Clock requirements\iref{time.clock.req}
or be the type \tcode{local_t}.

\pnum
If \tcode{Duration} is not an instance of \tcode{duration},
the program is ill-formed.

\rSec3[time.point.cons]{\tcode{time_point} constructors}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
constexpr time_point();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{duration::zero()}. Such a \tcode{time_point} object
represents the epoch.
\end{itemdescr}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
constexpr explicit time_point(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{d}. Such a \tcode{time_point} object represents the epoch
\tcode{+ d}.
\end{itemdescr}

\indexlibrary{\idxcode{time_point}!constructor}%
\begin{itemdecl}
template<class Duration2>
  constexpr time_point(const time_point<clock, Duration2>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This constructor shall not participate in overload resolution unless \tcode{Duration2}
is implicitly convertible to \tcode{duration}.

\pnum
\effects Constructs an object of type \tcode{time_point}, initializing
\tcode{d_} with \tcode{t.time_since_epoch()}.
\end{itemdescr}

\rSec3[time.point.observer]{\tcode{time_point} observer}

\indexlibrarymember{time_since_epoch}{time_point}%
\begin{itemdecl}
constexpr duration time_since_epoch() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{d_}.
\end{itemdescr}

\rSec3[time.point.arithmetic]{\tcode{time_point} arithmetic}

\indexlibrarymember{operator++}{time_point}%
\begin{itemdecl}
constexpr time_point& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++d_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{time_point}%
\begin{itemdecl}
constexpr time_point operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point\{d_++\}}.
\end{itemdescr}

\indexlibrarymember{operator--}{time_point}%
\begin{itemdecl}
constexpr time_point& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--d_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator--}{time_point}%
\begin{itemdecl}
constexpr time_point operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point\{d_--\}}.
\end{itemdescr}

\indexlibrarymember{operator+=}{time_point}%
\begin{itemdecl}
constexpr time_point& operator+=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{d_ += d;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{time_point}%
\begin{itemdecl}
constexpr time_point& operator-=(const duration& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{d_ -= d;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec3[time.point.special]{\tcode{time_point} special values}

\indexlibrarymember{min}{time_point}%
\begin{itemdecl}
static constexpr time_point min();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point(duration::min())}.
\end{itemdescr}

\indexlibrarymember{max}{time_point}%
\begin{itemdecl}
static constexpr time_point max();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{time_point(duration::max())}.
\end{itemdescr}

\rSec3[time.point.nonmember]{\tcode{time_point} non-member arithmetic}

\indexlibrarymember{operator+}{time_point}%
\indexlibrarymember{operator+}{duration}%
\begin{itemdecl}
template<class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
    operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs.time_since_epoch() + rhs)}, where \tcode{CT} is the type of the return value.
\end{itemdescr}

\indexlibrarymember{operator+}{time_point}%
\indexlibrarymember{operator+}{duration}%
\begin{itemdecl}
template<class Rep1, class Period1, class Clock, class Duration2>
  constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
    operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs + lhs}.
\end{itemdescr}

\indexlibrarymember{operator-}{time_point}%
\indexlibrarymember{operator-}{duration}%
\begin{itemdecl}
template<class Clock, class Duration1, class Rep2, class Period2>
  constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
    operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{CT(lhs.time_since_epoch() - rhs)},
where \tcode{CT} is the type of the return value.
\end{itemdescr}

\indexlibrarymember{operator-}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr common_type_t<Duration1, Duration2>
    operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() - rhs.time_since_epoch()}.
\end{itemdescr}

\rSec3[time.point.comparisons]{\tcode{time_point} comparisons}

\indexlibrarymember{operator==}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
                            const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() == rhs.time_since_epoch()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator!=(const time_point<Clock, Duration1>& lhs,
                            const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrarymember{operator<}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator<(const time_point<Clock, Duration1>& lhs,
                           const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.time_since_epoch() < rhs.time_since_epoch()}.
\end{itemdescr}

\indexlibrarymember{operator>}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator>(const time_point<Clock, Duration1>& lhs,
                           const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

\indexlibrarymember{operator<=}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
                            const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{time_point}%
\begin{itemdecl}
template<class Clock, class Duration1, class Duration2>
  constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
                            const time_point<Clock, Duration2>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

\rSec3[time.point.cast]{\tcode{time_point_cast}}

\indexlibrary{\idxcode{time_point}!\idxcode{time_point_cast}}%
\indexlibrary{\idxcode{time_point_cast}}%
\begin{itemdecl}
template<class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns
\begin{codeblock}
time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{floor}{time_point}%
\begin{itemdecl}
template<class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns \tcode{time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch()))}.
\end{itemdescr}

\indexlibrarymember{ceil}{time_point}%
\begin{itemdecl}
template<class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}.

\pnum
\returns \tcode{time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch()))}.
\end{itemdescr}

\indexlibrarymember{round}{time_point}%
\begin{itemdecl}
template<class ToDuration, class Clock, class Duration>
  constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution
unless \tcode{ToDuration} is a specialization of \tcode{duration}, and
\tcode{treat_as_floating_point_v<typename ToDuration::rep>} is \tcode{false}.

\pnum
\returns \tcode{time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch()))}.
\end{itemdescr}

\rSec2[time.clock]{Clocks}

\pnum
The types defined in this subclause shall satisfy the
\tcode{TrivialClock}
requirements\iref{time.clock.req}
unless otherwise specified.

\rSec3[time.clock.system]{Class \tcode{system_clock}}

\rSec4[time.clock.system.overview]{Overview}
\indexlibrary{\idxcode{system_clock}}%

\begin{codeblock}
namespace std::chrono {
  class system_clock {
  public:
    using rep        = @\seebelow@;
    using period     = ratio<@\unspecnc@, @\unspec{}@>;
    using duration   = chrono::duration<rep, period>;
    using time_point = chrono::time_point<system_clock>;
    static constexpr bool is_steady = @\unspec;@

    static time_point now() noexcept;

    // mapping to/from C type \tcode{time_t}
    static time_t      to_time_t  (const time_point& t) noexcept;
    static time_point  from_time_t(time_t t) noexcept;
  };
}
\end{codeblock}

\pnum
Objects of type \tcode{system_clock} represent wall clock time from the system-wide
realtime clock.
Objects of type \tcode{sys_time<Duration>} measure time since (and before)
1970-01-01 00:00:00 UTC excluding leap seconds.
This measure is commonly referred to as \defn{Unix time}.
This measure facilitates an efficient mapping between
\tcode{sys_time} and calendar types\iref{time.cal}.
\begin{example} \\
\tcode{sys_seconds\{sys_days\{1970y/January/1\}\}.time_since_epoch()} is \tcode{0s}. \\
\tcode{sys_seconds\{sys_days\{2000y/January/1\}\}.time_since_epoch()} is \tcode{946'684'800s},
which is \tcode{10'957 * 86'400s}. \\
\end{example}

\rSec4[time.clock.system.members]{Members}

\indexlibrarymember{rep}{system_clock}%
\begin{itemdecl}
using system_clock::rep = @\unspec@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{system_clock::duration::min() < system_clock::duration::zero()} shall
be \tcode{true}.\\
\begin{note} This implies that \tcode{rep} is a signed type. \end{note}
\end{itemdescr}

\indexlibrarymember{to_time_t}{system_clock}%
\begin{itemdecl}
static time_t to_time_t(const time_point& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{time_t} object that represents the same point in time as \tcode{t}
when both values are restricted to the coarser of the precisions of \tcode{time_t} and
\tcode{time_point}.
It is \impldef{whether values are rounded or truncated to the
required precision when converting between \tcode{time_t} values and \tcode{time_point} objects}
whether values are rounded or truncated to the required precision.
\end{itemdescr}

\indexlibrarymember{from_time_t}{system_clock}%
\begin{itemdecl}
static time_point from_time_t(time_t t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{time_point} object that represents the same point in time as \tcode{t}
when both values are restricted to the coarser of the precisions of \tcode{time_t} and
\tcode{time_point}.
It is \impldef{whether values are rounded or truncated to the
required precision when converting between \tcode{time_t} values and \tcode{time_point} objects}
whether values are rounded or truncated to the required precision.
\end{itemdescr}

\rSec4[time.clock.system.nonmembers]{Non-member functions}

\indexlibrarymember{operator<<}{sys_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const sys_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This operator shall not participate in overload resolution if
\tcode{treat_as_floating_point_v<typename Duration::rep>} is \tcode{true},
or if \tcode{Duration\{1\} >= days\{1\}}.

\pnum
\effects
\begin{codeblock}
auto const dp = floor<days>(tp);
os << year_month_day{dp} << ' ' << time_of_day{tp-dp};
\end{codeblock}

\pnum
\returns \tcode{os}.

\pnum
\begin{example}
\begin{codeblock}
cout << sys_seconds{0s} << '\n';                // 1970-01-01 00:00:00
cout << sys_seconds{946'684'800s} << '\n';      // 2000-01-01 00:00:00
cout << sys_seconds{946'688'523s} << '\n';      // 2000-01-01 01:02:03
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{sys_days}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const sys_days& dp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{os << year_month_day\{dp\}}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{sys_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const sys_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used, it will be replaced with
\tcode{"UTC"} widened to \tcode{charT}.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
an offset of \tcode{0min} will be formatted.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{sys_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                sys_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Attempts to parse the input stream \tcode{is}
into the \tcode{sys_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)}
shall be called and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.
Additionally, the parsed offset will be subtracted
from the successfully parsed timestamp
prior to assigning that difference to \tcode{tp}.

\pnum
\returns is.
\end{itemdescr}

\rSec3[time.clock.utc]{Class \tcode{utc_clock}}

\rSec4[time.clock.utc.overview]{Overview}
\indexlibrary{\idxcode{utc_clock}}%

\begin{codeblock}
namespace std::chrono {
  class utc_clock {
  public:
    using rep                       = @\textit{a signed arithmetic type}@;
    using period                    = ratio<@\unspecnc@, @\unspec@>;
    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<utc_clock>;
    static constexpr bool is_steady = @\unspec@;

    static time_point now();

    template<class Duration>
      static sys_time<common_type_t<Duration, seconds>>
        to_sys(const utc_time<Duration>& t);
    template<class Duration>
      static utc_time<common_type_t<Duration, seconds>>
        from_sys(const sys_time<Duration>& t);
  };
}
\end{codeblock}

\pnum
In contrast to \tcode{sys_time},
which does not take leap seconds into account,
\tcode{utc_clock} and its associated \tcode{time_point}, \tcode{utc_time},
count time, including leap seconds, since 1970-01-01 00:00:00 UTC.
\begin{example} \\
\tcode{clock_cast<utc_clock>(sys_seconds\{sys_days\{1970y/January/1\}\}).time_since_epoch()} is \tcode{0s}. \\
\tcode{clock_cast<utc_clock>(sys_seconds\{sys_days\{2000y/January/1\}\}).time_since_epoch()} \\
is \tcode{946'684'822s}, which is \tcode{10'957 * 86'400s + 22s}. \\
\end{example}

\pnum
\tcode{utc_clock} is not a TrivialClock
unless the implementation can guarantee that \tcode{utc_clock::now()}
does not propagate an exception.
\begin{note} \tcode{noexcept(from_sys(system_clock::now()))} is \tcode{false}. \end{note}

\rSec4[time.clock.utc.members]{Member functions}

\indexlibrarymember{now}{utc_clock}%
\begin{itemdecl}
static time_point now();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{from_sys(system_clock::now())}, or a more accurate value of \tcode{utc_time}.
\end{itemdescr}

\indexlibrarymember{to_sys}{utc_clock}%
\begin{itemdecl}
template<typename Duration>
  static sys_time<common_type_t<Duration, seconds>>
    to_sys(const utc_time<Duration>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{sys_time} \tcode{t},
such that \tcode{from_sys(t) == u} if such a mapping exists.
Otherwise \tcode{u} represents a \tcode{time_point}
during a leap second insertion
and the last representable value of \tcode{sys_time}
prior to the insertion of the leap second is returned.
\end{itemdescr}

\indexlibrarymember{from_sys}{utc_clock}%
\begin{itemdecl}
template<typename Duration>
  static utc_time<common_type_t<Duration, seconds>>
    from_sys(const sys_time<Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{utc_time} \tcode{u}, such that
\tcode{u.time_since_epoch() - t.time_since_epoch()}
is equal to the number of leap seconds that were inserted
between \tcode{t} and 1970-01-01.
If \tcode{t} is exactly the date of leap second insertion,
then the conversion counts that leap second as inserted.

\begin{example}
\begin{codeblock}
auto t = sys_days{July/1/2015} - 2ns;
auto u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
t += 1ns;
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec4[time.clock.utc.nonmembers]{Non-member functions}

\indexlibrarymember{operator<<}{utc_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const utc_time<Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{to_stream(os, fmt, t)},
where \tcode{fmt} is a string containing \tcode{"\%F \%T"}
widened to \tcode{charT}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{utc_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const utc_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used, it will be replaced with \tcode{"UTC"} widened to \tcode{charT}.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
an offset of \tcode{0min} will be formatted.
If \tcode{tp} represents a time during a leap second insertion,
and if a seconds field is formatted,
the integral portion of that format shall be \tcode{"60"} widened to \tcode{charT}.

\pnum
\returns \tcode{os}.

\pnum
\begin{example}
\begin{codeblock}
auto t = sys_days{July/1/2015} - 500ms;
auto u = clock_cast<utc_clock>(t);
for (auto i = 0; i < 8; ++i, u += 250ms)
  cout << u << " UTC\n";
\end{codeblock}

Produces this output:

\begin{codeblock}
2015-06-30 23:59:59.500 UTC
2015-06-30 23:59:59.750 UTC
2015-06-30 23:59:60.000 UTC
2015-06-30 23:59:60.250 UTC
2015-06-30 23:59:60.500 UTC
2015-06-30 23:59:60.750 UTC
2015-07-01 00:00:00.000 UTC
2015-07-01 00:00:00.250 UTC
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{from_stream}{utc_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                utc_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{utc_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.
Additionally, the parsed offset will be subtracted from
the successfully parsed timestamp
prior to assigning that difference to \tcode{tp}.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.clock.tai]{Class \tcode{tai_clock}}

\rSec4[time.clock.tai.overview]{Overview}
\indexlibrary{\idxcode{tai_clock}}%

\begin{codeblock}
namespace std::chrono {
  class tai_clock {
  public:
    using rep                       = @\textit{a signed arithmetic type}@;
    using period                    = ratio<@\unspecnc@, @\unspec@>;
    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<tai_clock>;
    static constexpr bool is_steady = @\unspec@;

    static time_point now();

    template<class Duration>
      static utc_time<common_type_t<Duration, seconds>>
        to_utc(const tai_time<Duration>&) noexcept;
    template<class Duration>
      static tai_time<common_type_t<Duration, seconds>>
        from_utc(const utc_time<Duration>&) noexcept;
  };
}
\end{codeblock}

\pnum
The clock \tcode{tai_clock} measures seconds since 1958-01-01 00:00:00
and is offset 10s ahead of UTC at this date.
That is, 1958-01-01 00:00:00 TAI is equivalent to 1957-12-31 23:59:50 UTC.
Leap seconds are not inserted into TAI.
Therefore every time a leap second is inserted into UTC,
UTC falls another second behind TAI.
For example by 2000-01-01 there had been 22 leap seconds inserted
so 2000-01-01 00:00:00 UTC is equivalent to 2000-01-01 00:00:32 TAI
(22s plus the initial 10s offset).

\pnum
\tcode{tai_clock} is not a TrivialClock
unless the implementation can guarantee that \tcode{tai_clock::now()}
does not propagate an exception.
\begin{note}
\tcode{noexcept(from_utc(utc_clock::now()))} is \tcode{false}.
\end{note}

\rSec4[time.clock.tai.members]{Member functions}

\indexlibrarymember{now}{tai_clock}%
\begin{itemdecl}
static time_point now();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{from_utc(utc_clock::now())}, or a more accurate value of \tcode{tai_time}.
\end{itemdescr}

\indexlibrarymember{to_utc}{tai_clock}%
\begin{itemdecl}
template<class Duration>
  static utc_time<common_type_t<Duration, seconds>>
    to_utc(const tai_time<Duration>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
utc_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} - 378691210s
\end{codeblock}
\begin{note}
\begin{codeblock}
378691210s == sys_days{1970y/January/1} - sys_days{1958y/January/1} + 10s
\end{codeblock}
\end{note}
\end{itemdescr}

\indexlibrarymember{from_utc}{tai_clock}%
\begin{itemdecl}
template<class Duration>
  static tai_time<common_type_t<Duration, seconds>>
    from_utc(const utc_time<Duration>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
tai_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} + 378691210s
\end{codeblock}
\begin{note}
\begin{codeblock}
378691210s == sys_days{1970y/January/1} - sys_days{1958y/January/1} + 10s
\end{codeblock}
\end{note}
\end{itemdescr}

\rSec4[time.clock.tai.nonmembers]{Non-member functions}

\indexlibrarymember{operator<<}{tai_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const tai_time<Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{to_stream(os, fmt, t)},
where \tcode{fmt} is a string containing
\tcode{"\%F \%T"} widened to \tcode{charT}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{tai_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const tai_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used, it will be replaced with \tcode{"TAI"}.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
an offset of \tcode{0min} will be formatted.
The date and time formatted shall be equivalent to
that formatted by a \tcode{sys_time} initialized with:
\begin{codeblock}
sys_time<Duration>{tp.time_since_epoch()} -
  (sys_days{1970y/January/1} - sys_days{1958y/January/1})
\end{codeblock}

\pnum
\returns os.

\pnum
\begin{example}
\begin{codeblock}
auto st = sys_days{2000y/January/1};
auto tt = clock_cast<tai_clock>(st);
cout << format("%F %T %Z == ", st) << format("%F %T %Z\n", tt);
\end{codeblock}

Produces this output:

\begin{codeblock}
2000-01-01 00:00:00 UTC == 2000-01-01 00:00:32 TAI
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{from_stream}{tai_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                tai_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{tai_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.
Additionally, the parsed offset will be subtracted from
the successfully parsed timestamp prior to assigning that difference to \tcode{tp}.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.clock.gps]{Class \tcode{gps_clock}}

\rSec4[time.clock.gps.overview]{Overview}
\indexlibrary{\idxcode{gps_clock}}%

\begin{codeblock}
namespace std::chrono {
  class gps_clock {
  public:
    using rep                       = @\textit{a signed arithmetic type}@;
    using period                    = ratio<@\unspecnc@, @\unspec@>;
    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<gps_clock>;
    static constexpr bool is_steady = @\unspec@;

    static time_point now();

    template<class Duration>
      static utc_time<common_type_t<Duration, seconds>>
        to_utc(const gps_time<Duration>&) noexcept;
    template<class Duration>
      static gps_time<common_type_t<Duration, seconds>>
        from_utc(const utc_time<Duration>&) noexcept;
  };
}
\end{codeblock}

\pnum
The clock \tcode{gps_clock} measures
seconds since the first Sunday of January, 1980 00:00:00 UTC.
Leap seconds are not inserted into GPS.
Therefore every time a leap second is inserted into UTC,
UTC falls another second behind GPS.
Aside from the offset from \tcode{1958y/January/1} to \tcode{1980y/January/Sunday[1]},
GPS is behind TAI by 19s due to the 10s offset between 1958 and 1970
and the additional 9 leap seconds inserted between 1970 and 1980.

\pnum
\tcode{gps_clock} is not a TrivialClock
unless the implementation can guarantee that
\tcode{gps_clock::now()} does not propagate an exception.
\begin{note}
\tcode{noexcept(from_utc(utc_clock::now()))} is \tcode{false}.
\end{note}

\rSec4[time.clock.gps.members]{Member functions}

\indexlibrarymember{now}{gps_clock}%
\begin{itemdecl}
static time_point now();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{from_utc(utc_clock::now())}, or a more accurate value of \tcode{gps_time}.
\end{itemdescr}

\indexlibrarymember{to_utc}{gps_clock}%
\begin{itemdecl}
template<class Duration>
  static utc_time<common_type_t<Duration, seconds>>
    to_utc(const gps_time<Duration>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
gps_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} + 315964809s
\end{codeblock}
\begin{note}
\begin{codeblock}
315964809s == sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1} + 9s
\end{codeblock}
\end{note}
\end{itemdescr}

\indexlibrarymember{from_utc}{gps_clock}%
\begin{itemdecl}
template<class Duration>
  static gps_time<common_type_t<Duration, seconds>>
    from_utc(const utc_time<Duration>& t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
gps_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} - 315964809s
\end{codeblock}
\begin{note}
\begin{codeblock}
315964809s == sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1} + 9s
\end{codeblock}
\end{note}
\end{itemdescr}

\rSec4[time.clock.gps.nonmembers]{Non-member functions}

\indexlibrarymember{operator<<}{gps_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const gps_time<Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{to_stream(os, fmt, t)},
where \tcode{fmt} is a string containing
\tcode{"\%F \%T"} widened to \tcode{charT}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{gps_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const gps_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used, it will be replaced with \tcode{"GPS"}.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
an offset of \tcode{0min} will be formatted.
The date and time formatted
shall be equivalent to that formatted by a \tcode{sys_time} initialized with:
\begin{codeblock}
sys_time<Duration>{tp.time_since_epoch()} +
  (sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1})
\end{codeblock}

\pnum
\returns os.

\pnum
\begin{example}
\begin{codeblock}
auto st = sys_days{2000y/January/1};
auto gt = clock_cast<gps_clock>(st);
cout << format("%F %T %Z == ", st) << format("%F %T %Z\n", gt);
\end{codeblock}

Produces this output:

\begin{codeblock}
2000-01-01 00:00:00 UTC == 2000-01-01 00:00:13 GPS
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{from_stream}{gps_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                gps_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{gps_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.
Additionally, the parsed offset will be subtracted from
the successfully parsed timestamp prior to assigning that difference to \tcode{tp}.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.clock.file]{Class \tcode{file_clock}}

\rSec4[time.clock.file.overview]{Overview}
\indexlibrary{\idxcode{file_clock}}%

\begin{codeblock}
namespace std::chrono {
  class file_clock {
  public:
    using rep                       = @\textit{a signed arithmetic type}@;
    using period                    = ratio<@\unspecnc@, @\unspec@>;
    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<file_clock>;
    static constexpr bool is_steady = @\unspec@;

    static time_point now() noexcept;

    // Conversion functions, see below
  };
}
\end{codeblock}

\pnum
The clock \tcode{file_clock} is used to create the \tcode{time_point} system
used for \tcode{file_time_type}\iref{filesystems}. Its epoch is unspecified.

\rSec4[time.clock.file.members]{Member functions}

\indexlibrarymember{now}{file_clock}%
\begin{itemdecl}
static time_point now();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{file_clock::time_point} indicating the current time.
\end{itemdescr}

\pnum
The class \tcode{file_clock} shall provide
precisely one of the following two sets of static member functions:

\begin{codeblock}
template<class Duration>
  static sys_time<@\seebelow@>
    to_sys(const file_time<Duration>&);
template<class Duration>
  static file_time<@\seebelow@>
    from_sys(const sys_time<Duration>&);
\end{codeblock}

or:

\begin{codeblock}
template<class Duration>
  static utc_time<@\seebelow@>
    to_utc(const file_time<Duration>&);
template<class Duration>
  static file_time<@\seebelow@>
    from_utc(const utc_time<Duration>&);
\end{codeblock}

These member functions shall provide \tcode{time_point} conversions
consistent with those specified by
\tcode{utc_clock}, \tcode{tai_clock}, and \tcode{gps_clock}.
The \tcode{Duration} of the resultant \tcode{time_point}
is computed from the \tcode{Duration} of the input \tcode{time_point}.

\rSec4[time.clock.file.nonmembers]{Non-member functions}

\indexlibrarymember{operator<<}{file_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const file_time<Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{to_stream(os, fmt, t)},
where \tcode{fmt} is a string containing
\tcode{"\%F \%T"} widened to \tcode{charT}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{file_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const file_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used, it will be replaced with \tcode{"UTC"} widened to \tcode{charT}.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
an offset of \tcode{0min} will be formatted.
The date and time formatted shall be equivalent to
that formatted by a \tcode{sys_time} initialized with
\tcode{clock_cast<system_clock>(tp)},
or by a \tcode{utc_time} initialized with
\tcode{clock_cast<utc_clock>(tp)}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{file_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                file_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{file_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.
Additionally, the parsed offset will be subtracted from
the successfully parsed timestamp prior to assigning that difference to \tcode{tp}.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.clock.steady]{Class \tcode{steady_clock}}
\indexlibrary{\idxcode{steady_clock}}%

\begin{codeblock}
namespace std::chrono {
  class steady_clock {
  public:
    using rep        = @\unspec@;
    using period     = ratio<@\unspecnc@, @\unspec{}@>;
    using duration   = chrono::duration<rep, period>;
    using time_point = chrono::time_point<@\unspecnc@, duration>;
    static constexpr bool is_steady = true;

    static time_point now() noexcept;
  };
}
\end{codeblock}

\pnum
Objects of class \tcode{steady_clock} represent clocks for which values of \tcode{time_point}
never decrease as physical time advances and for which values of \tcode{time_point} advance at
a steady rate relative to real time. That is, the clock may not be adjusted.

\rSec3[time.clock.hires]{Class \tcode{high_resolution_clock}}
\indexlibrary{\idxcode{high_resolution_clock}}%

\begin{codeblock}
namespace std::chrono {
  class high_resolution_clock {
  public:
    using rep        = @\unspec@;
    using period     = ratio<@\unspecnc@, @\unspec{}@>;
    using duration   = chrono::duration<rep, period>;
    using time_point = chrono::time_point<@\unspecnc@, duration>;
    static constexpr bool is_steady = @\unspec@;

    static time_point now() noexcept;
  };
}
\end{codeblock}

\pnum
Objects of class \tcode{high_resolution_clock} represent clocks with the
shortest tick period. \tcode{high_resolution_clock} may be a synonym for
\tcode{system_clock} or \tcode{steady_clock}.

\rSec3[time.clock.local]{Local time}
\indexlibrary{\idxcode{local_time}}%

\pnum
The family of time points
denoted by \tcode{local_time<Duration>}
are based on the pseudo clock \tcode{local_t}.
\tcode{local_t} has no member \tcode{now()}
and thus does not meet the clock requirements.
Nevertheless \tcode{local_time<Duration>} serves the vital role of
representing local time with respect to a not-yet-specified time zone.
Aside from being able to get the current time,
the complete \tcode{time_point} algebra is available
for \tcode{local_time<Duration>} (just as for \tcode{sys_time<Duration>}).

\indexlibrarymember{operator<<}{local_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const local_time<Duration>& lt);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
os << sys_time<Duration>{lt.time_since_epoch()};
\end{codeblock}

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{local_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const local_time<Duration>& tp,
              const string* abbrev = nullptr, const seconds* offset_sec = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{tp} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.
If \tcode{\%Z} is used,
it will be replaced with \tcode{*abbrev} if \tcode{abbrev} is not equal to \tcode{nullptr}.
If \tcode{abbrev} is equal to \tcode{nullptr} (and \tcode{\%Z} is used),
\tcode{os.setstate(ios_base::failbit)} shall be called.
If \tcode{\%z} is used (or a modified variant of \tcode{\%z}),
it will be formatted with the value of \tcode{*offset_sec}
if \tcode{offset_sec} is not equal to \tcode{nullptr}.
If \tcode{\%z} (or a modified variant of \tcode{\%z}) is used,
and \tcode{offset_sec} is equal to \tcode{nullptr}, then
\tcode{os.setstate(ios_base::failbit)} shall be called.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{local_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                local_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{local_time} \tcode{tp} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid date,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{tp} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.clock.cast]{\tcode{time_point} conversions}

\rSec4[time.clock.conv]{Class template \tcode{clock_time_conversion}}
\indexlibrary{\idxcode{clock_time_conversion}}%

\begin{codeblock}
namespace std::chrono {
  template<class DestClock, class SourceClock>
  struct clock_time_conversion {};
}
\end{codeblock}

\pnum
\tcode{clock_time_conversion} serves as a trait
which can be used to specify how to convert
a source \tcode{time_point} of type
\tcode{time_point<SourceClock, Duration>}
to a destination \tcode{time_point} of type
\tcode{time_point<DestClock, Duration>}
via a specialization:
\tcode{clock_time_conversion<DestClock, SourceClock>}.
A specialization of \tcode{clock_time_conversion<DestClock, SourceClock>}
shall provide a const-qualified \tcode{operator()}
that takes a parameter of type \tcode{time_point<SourceClock, Duration>}
and returns a \tcode{time_point<DestClock, OtherDuration>}
representing an equivalent point in time.
\tcode{OtherDuration} is a \tcode{chrono::duration}
whose specialization is computed from the input \tcode{Duration}
in a manner which can vary for each \tcode{clock_time_conversion} specialization.
A program may specialize \tcode{clock_time_conversion}
if at least one of the template parameters is a user-defined clock type.

\pnum
Several specializations are provided by the implementation,
as described in
\ref{time.clock.cast.id},
\ref{time.clock.cast.sys.utc},
\ref{time.clock.cast.sys}, and
\ref{time.clock.cast.utc}.

\rSec4[time.clock.cast.id]{Identity conversions}

\begin{codeblock}
template<typename Clock>
struct clock_time_conversion<Clock, Clock> {
  template<class Duration>
    time_point<Clock, Duration>
      operator()(const time_point<Clock, Duration>& t) const;
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  time_point<Clock, Duration>
    operator()(const time_point<Clock, Duration>& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{t}.
\end{itemdescr}

\begin{codeblock}
template<>
struct clock_time_conversion<system_clock, system_clock> {
  template<class Duration>
    sys_time<Duration>
      operator()(const sys_time<Duration>& t) const;
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  sys_time<Duration>
    operator()(const sys_time<Duration>& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{t}.
\end{itemdescr}

\begin{codeblock}
template<>
struct clock_time_conversion<utc_clock, utc_clock> {
  template<class Duration>
    utc_time<Duration>
      operator()(const utc_time<Duration>& t) const;
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  utc_time<Duration>
    operator()(const utc_time<Duration>& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{t}.
\end{itemdescr}

\rSec4[time.clock.cast.sys.utc]{Conversions between \tcode{system_clock} and \tcode{utc_clock}}

\begin{codeblock}
template<>
struct clock_time_conversion<utc_clock, system_clock> {
  template<class Duration>
    utc_time<common_type_t<Duration, seconds>>
      operator()(const sys_time<Duration>& t) const;
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  utc_time<common_type_t<Duration, seconds>>
    operator()(const sys_time<Duration>& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{utc_clock::from_sys(t)}.
\end{itemdescr}

\begin{codeblock}
template<>
struct clock_time_conversion<system_clock, utc_clock> {
  template<class Duration>
    sys_time<common_type_t<Duration, seconds>>
      operator()(const utc_time<Duration>& t) const;
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  sys_time<common_type_t<Duration, seconds>>
    operator()(const utc_time<Duration>& t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{utc_clock::to_sys(t)}.
\end{itemdescr}

\rSec4[time.clock.cast.sys]{Conversions between \tcode{system_clock} and other clocks}

\begin{codeblock}
template<class SourceClock>
struct clock_time_conversion<system_clock, SourceClock> {
  template<class Duration>
    auto operator()(const time_point<SourceClock, Duration>& t) const
      -> decltype(SourceClock::to_sys(t));
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  auto operator()(const time_point<SourceClock, Duration>& t) const
    -> decltype(SourceClock::to_sys(t));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function does not participate in overload resolution unless
\tcode{SourceClock::to_sys(t)} is well-formed.
If \tcode{SourceClock::to_sys(t)}
does not return \tcode{sys_time<Duration>},
where \tcode{Duration} is a valid \tcode{chrono::duration} specialization,
the program is ill-formed.

\pnum
\returns \tcode{SourceClock::to_sys(t)}.
\end{itemdescr}

\begin{codeblock}
template<class DestClock>
struct clock_time_conversion<DestClock, system_clock> {
  template<class Duration>
    auto operator()(const sys_time<Duration>& t) const
      -> decltype(DestClock::from_sys(t));
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  auto operator()(const sys_time<Duration>& t) const
    -> decltype(DestClock::from_sys(t));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function does not participate in overload resolution unless
\tcode{DestClock::from_sys(t)} is well-formed.
If \tcode{DestClock::from_sys(t)} does not return
\tcode{time_point<DestClock, Duration>},
where \tcode{Duration} is a valid \tcode{chrono::duration} specialization,
the program is ill-formed.

\pnum
\returns \tcode{DestClock::from_sys(t)}.
\end{itemdescr}

\rSec4[time.clock.cast.utc]{Conversions between \tcode{utc_clock} and other clocks}

\begin{codeblock}
template<class SourceClock>
struct clock_time_conversion<utc_clock, SourceClock> {
  template<class Duration>
    auto operator()(const time_point<SourceClock, Duration>& t) const
      -> decltype(SourceClock::to_utc(t));
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  auto operator()(const time_point<SourceClock, Duration>& t) const
    -> decltype(SourceClock::to_utc(t));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function does not participate in overload resolution unless
\tcode{SourceClock::to_utc(t)} is well-formed.
If \tcode{SourceClock::to_utc(t)} does not return
\tcode{utc_time<Duration>},
where \tcode{Duration} is a valid \tcode{chrono::duration} specialization,
the program is ill-formed.

\pnum
\returns \tcode{SourceClock::to_utc(t)}.
\end{itemdescr}

\begin{codeblock}
template<class DestClock>
struct clock_time_conversion<DestClock, utc_clock> {
  template<class Duration>
    auto operator()(const utc_time<Duration>& t) const
      -> decltype(DestClock::from_utc(t));
};
\end{codeblock}

\indexlibrarymember{operator()}{clock_time_conversion}%
\begin{itemdecl}
template<class Duration>
  auto operator()(const utc_time<Duration>& t) const
    -> decltype(DestClock::from_utc(t));
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function does not participate in overload resolution unless
\tcode{DestClock::from_utc(t)} is well-formed.
If \tcode{DestClock::from_utc(t)} does not return
\tcode{time_point<DestClock, Duration>},
where \tcode{Duration} is a valid \tcode{chrono::duration} specialization,
the program is ill-formed.

\pnum
\returns \tcode{DestClock::from_utc(t)}.
\end{itemdescr}

\rSec4[time.clock.cast.fn]{Function template \tcode{clock_cast}}

\indexlibrary{\idxcode{clock_cast}}%
\begin{itemdecl}
template<class DestClock, class SourceClock, class Duration>
  auto clock_cast(const time_point<SourceClock, Duration>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function does not participate in overload resolution unless
at least one of the following clock time conversion expressions
is well-formed:

\begin{itemize}
\item
\begin{codeblock}
clock_time_conversion<DestClock, SourceClock>{}(t)
\end{codeblock}

\item
\begin{codeblock}
clock_time_conversion<DestClock, system_clock>{}(
    clock_time_conversion<system_clock, SourceClock>{}(t))
\end{codeblock}

\item
\begin{codeblock}
clock_time_conversion<DestClock, utc_clock>{}(
    clock_time_conversion<utc_clock, SourceClock>{}(t))
\end{codeblock}

\item
\begin{codeblock}
clock_time_conversion<DestClock, utc_clock>{}(
    clock_time_conversion<utc_clock, system_clock>{}(
        clock_time_conversion<system_clock, SourceClock>{}(t)))
\end{codeblock}

\item
\begin{codeblock}
clock_time_conversion<DestClock, system_clock>{}(
    clock_time_conversion<system_clock, utc_clock>{}(
        clock_time_conversion<utc_clock, SourceClock>{}(t)))
\end{codeblock}
\end{itemize}

A clock time conversion expression is considered better than
another clock time conversion expression if it involves fewer
\tcode{operator()} calls on \tcode{clock_time_conversion}
specializations.
If, among the well-formed clock time conversion expressions
from the above list, there is not a unique best expression,
the \tcode{clock_cast} is ambiguous and the program is ill-formed.

\pnum
\returns
The best well-formed clock time conversion expression in the above list.
\end{itemdescr}

\rSec2[time.cal]{The civil calendar}

\rSec3[time.cal.general]{In general}

\pnum
The types in \ref{time.cal} describe the civil (Gregorian) calendar
and its relationship to \tcode{sys_days} and \tcode{local_days}.

\rSec3[time.cal.last]{Class \tcode{last_spec}}
\indexlibrary{\idxcode{last_spec}}%

\begin{codeblock}
namespace std::chrono {
  struct last_spec {
    explicit last_spec() = default;
  };
}
\end{codeblock}

\pnum
The type \tcode{last_spec} is used
in conjunction with other calendar types
to specify the last in a sequence.
For example, depending on context,
it can represent the last day of a month,
or the last day of the week of a month.

\rSec3[time.cal.day]{Class \tcode{day}}

\rSec4[time.cal.day.overview]{Overview}
\indexlibrary{\idxcode{day}}

\begin{codeblock}
namespace std::chrono {
  class day {
    unsigned char d_;           // \expos
  public:
    day() = default;
    explicit constexpr day(unsigned d) noexcept;

    constexpr day& operator++()    noexcept;
    constexpr day  operator++(int) noexcept;
    constexpr day& operator--()    noexcept;
    constexpr day  operator--(int) noexcept;

    constexpr day& operator+=(const days& d) noexcept;
    constexpr day& operator-=(const days& d) noexcept;

    explicit constexpr operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{day} represents a day of a month.
It normally holds values in the range 1 to 31,
but may hold non-negative values outside this range.
It can be constructed with any \tcode{unsigned} value,
which will be subsequently truncated to fit into \tcode{day}'s unspecified internal storage.
\tcode{day} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}),
and participates in basic arithmetic with \tcode{days} objects,
which represent a difference between two \tcode{day} objects.

\pnum
\tcode{day} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.day.members]{Member functions}

\indexlibrary{\idxcode{day}!constructor}%
\begin{itemdecl}
explicit constexpr day(unsigned d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{day} by
initializing \tcode{d_} with \tcode{d}.
The value held is unspecified if \tcode{d} is not in the range \crange{0}{255}.
\end{itemdescr}

\indexlibrarymember{operator++}{day}%
\begin{itemdecl}
constexpr day& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++d_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{day}%
\begin{itemdecl}
constexpr day operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator--}{day}%
\begin{itemdecl}
constexpr day& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--d_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator--}{day}%
\begin{itemdecl}
constexpr day operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator+=}{day}%
\begin{itemdecl}
constexpr day& operator+=(const days& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{day}%
\begin{itemdecl}
constexpr day& operator-=(const days& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator unsigned}{day}%
\begin{itemdecl}
explicit constexpr operator unsigned() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{d_}.
\end{itemdescr}

\indexlibrarymember{ok}{day}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{1 <= d_ \&\& d_ <= 31}.
\end{itemdescr}

\rSec4[time.cal.day.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{day}%
\begin{itemdecl}
constexpr bool operator==(const day& x, const day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{unsigned\{x\} == unsigned\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator<}{day}%
\begin{itemdecl}
constexpr bool operator<(const day& x, const day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{unsigned\{x\} < unsigned\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{day}%
\begin{itemdecl}
constexpr day operator+(const day& x, const days& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{day(unsigned\{x\} + y.count())}.
\end{itemdescr}

\indexlibrarymember{operator+}{day}%
\begin{itemdecl}
constexpr day operator+(const days& x, const day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y + x}.
\end{itemdescr}

\indexlibrarymember{operator-}{day}%
\begin{itemdecl}
constexpr day operator-(const day& x, const days& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + -y}.
\end{itemdescr}

\indexlibrarymember{operator-}{day}%
\begin{itemdecl}
constexpr days operator-(const day& x, const day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{days\{int(unsigned\{x\}) - int(unsigned\{y\})}.
\end{itemdescr}

\indexlibrarymember{operator<<}{day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const day& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts \tcode{format(fmt, d)}
where \tcode{fmt} is \tcode{"\%d"} widened to \tcode{charT}.
If \tcode{!d.ok()}, appends with \tcode{" is not a valid day"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const day& d);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{d} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{day}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                day& d, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{day} \tcode{d} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid day,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{d} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\indexlibrarymember{operator""""d}{day}%
\begin{itemdecl}
constexpr day operator""d(unsigned long long d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{day\{static_cast<unsigned>(d)\}}.
\end{itemdescr}

\rSec3[time.cal.month]{Class \tcode{month}}

\rSec4[time.cal.month.overview]{Overview}
\indexlibrary{\idxcode{month}}

\begin{codeblock}
namespace std::chrono {
  class month {
    unsigned char m_;           // \expos
  public:
    month() = default;
    explicit constexpr month(unsigned m) noexcept;

    constexpr month& operator++()    noexcept;
    constexpr month  operator++(int) noexcept;
    constexpr month& operator--()    noexcept;
    constexpr month  operator--(int) noexcept;

    constexpr month& operator+=(const months& m) noexcept;
    constexpr month& operator-=(const months& m) noexcept;

    explicit constexpr operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{month} represents a month of a year.
It normally holds values in the range 1 to 12,
but may hold non-negative values outside this range.
It can be constructed with any \tcode{unsigned} value,
which will be subsequently truncated to fit into \tcode{month}'s unspecified internal storage.
\tcode{month} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}),
and participates in basic arithmetic with \tcode{months} objects,
which represent a difference between two \tcode{month} objects.

\pnum
\tcode{month} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.month.members]{Member functions}

\indexlibrary{\idxcode{month}!constructor}%
\begin{itemdecl}
explicit constexpr month(unsigned m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{month} by
initializing \tcode{m_} with \tcode{m}.
The value held is unspecified if \tcode{m} is not in the range \crange{0}{255}.
\end{itemdescr}

\indexlibrarymember{operator++}{month}%
\begin{itemdecl}
constexpr month& month::operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this += months\{1\}}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{month}%
\begin{itemdecl}
constexpr month operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator--}{month}%
\begin{itemdecl}
constexpr month& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this -= months\{1\}}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator--}{month}%
\begin{itemdecl}
constexpr month operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator+=}{month}%
\begin{itemdecl}
constexpr month& operator+=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{month}%
\begin{itemdecl}
constexpr month& operator-=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator unsigned}{month}%
\begin{itemdecl}
explicit constexpr month::operator unsigned() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{ok}{month}%
\begin{itemdecl}
constexpr bool month::ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{1 <= m_ \&\& m_ <= 12}.
\end{itemdescr}

\rSec4[time.cal.month.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{month}%
\begin{itemdecl}
constexpr bool operator==(const month& x, const month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{unsigned\{x\} == unsigned\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator<}{month}%
\begin{itemdecl}
constexpr bool operator<(const month& x, const month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{unsigned\{x\} < unsigned\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{month}%
\begin{itemdecl}
constexpr month operator+(const month& x, const months& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
month{modulo(static_cast<long long>(unsigned{x}) + (y.count() - 1), 12) + 1}
\end{codeblock}
where \tcode{modulo(n, 12)} computes the remainder of \tcode{n} divided by 12 using Euclidean division.
\begin{note}
Given a divisor of 12, Euclidean division truncates towards negative infinity and
always produces a remainder in the range of \crange{0}{11}.
Assuming no overflow in the signed summation,
this operation results in a \tcode{month} holding a value in the range \crange{1}{12} even if \tcode{!x.ok()}.
\end{note}
\begin{example}
\tcode{February + months\{11\} == January}.
\end{example}
\end{itemdescr}

\indexlibrarymember{operator+}{month}%
\begin{itemdecl}
constexpr month operator+(const months& x, const month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y + x}.
\end{itemdescr}

\indexlibrarymember{operator-}{month}%
\begin{itemdecl}
constexpr month operator-(const month& x, const months& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + -y}.
\end{itemdescr}

\indexlibrarymember{operator-}{month}%
\begin{itemdecl}
constexpr months operator-(const month& x, const month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.ok() == true}
and \tcode{y.ok() == true},
returns a value \tcode{m}
in the range \crange{months\{0\}}{months\{11\}}
satisfying \tcode{y + m == x}.
Otherwise the value returned is unspecified.
\begin{example}
\tcode{January - February == months\{11\}}.
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{month}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const month& m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{m.ok() == true}
inserts \tcode{format(os.getloc(), fmt, m)}
where fmt is \tcode{"\%b"} widened to \tcode{charT}.
Otherwise inserts \tcode{unsigned\{m\} << " is not a valid month"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{month}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month& m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{m} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{month}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                month& m, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{month} \tcode{m} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid month,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{m} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.cal.year]{Class \tcode{year}}

\rSec4[time.cal.year.overview]{Overview}
\indexlibrary{\idxcode{year}}

\begin{codeblock}
namespace std::chrono {
  class year {
    short y_;                   // \expos
  public:
    year() = default;
    explicit constexpr year(int y) noexcept;

    constexpr year& operator++()    noexcept;
    constexpr year  operator++(int) noexcept;
    constexpr year& operator--()    noexcept;
    constexpr year  operator--(int) noexcept;

    constexpr year& operator+=(const years& y) noexcept;
    constexpr year& operator-=(const years& y) noexcept;

    constexpr year operator+() const noexcept;
    constexpr year operator-() const noexcept;

    constexpr bool is_leap() const noexcept;

    explicit constexpr operator int() const noexcept;
    constexpr bool ok() const noexcept;

    static constexpr year min() noexcept;
    static constexpr year max() noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year} represents a year in the civil calendar.
It can represent values in the range \crange{min()}{max()}.
It can be constructed with any \tcode{int} value,
which will be subsequently truncated to fit into \tcode{year}'s unspecified internal storage.
\tcode{year} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}),
and participates in basic arithmetic with \tcode{years} objects,
which represent a difference between two \tcode{year} objects.

\pnum
\tcode{year} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.year.members]{Member functions}

\indexlibrary{\idxcode{year}!constructor}%
\begin{itemdecl}
explicit constexpr year(int y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year} by
initializing \tcode{y_} with \tcode{y}.
The value held is unspecified if \tcode{y} is not in the range \crange{-32767}{32767}.
\end{itemdescr}

\indexlibrarymember{operator++}{year}%
\begin{itemdecl}
constexpr year& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++y_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{year}%
\begin{itemdecl}
constexpr year operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator--}{year}%
\begin{itemdecl}
constexpr year& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--y_}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator--}{year}%
\begin{itemdecl}
constexpr year operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator+=}{year}%
\begin{itemdecl}
constexpr year& operator+=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year}%
\begin{itemdecl}
constexpr year& operator-=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+}{year}%
\begin{itemdecl}
constexpr year operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-}{year}%
\begin{itemdecl}
constexpr year year::operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year\{-y_\}}.
\end{itemdescr}

\indexlibrarymember{is_leap}{year}%
\begin{itemdecl}
constexpr bool is_leap() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_ \% 4 == 0 \&\& (y_ \% 100 != 0 || y_ \% 400 == 0)}.
\end{itemdescr}

\indexlibrarymember{operator int}{year}%
\begin{itemdecl}
explicit constexpr operator int() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{ok}{year}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{min() <= y_ \&\& y_ <= max()}.
\end{itemdescr}

\indexlibrarymember{min}{year}%
\begin{itemdecl}
static constexpr year min() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year\{-32767\}}.
\end{itemdescr}

\indexlibrarymember{max}{year}%
\begin{itemdecl}
static constexpr year max() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year\{32767\}}.
\end{itemdescr}

\rSec4[time.cal.year.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year}%
\begin{itemdecl}
constexpr bool operator==(const year& x, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{int\{x\} == int\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator<}{year}%
\begin{itemdecl}
constexpr bool operator<(const year& x, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{int\{x\} < int\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{year}%
\begin{itemdecl}
constexpr year operator+(const year& x, const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year\{int\{x\} + y.count()\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{year}%
\begin{itemdecl}
constexpr year operator+(const years& x, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y + x}.
\end{itemdescr}

\indexlibrarymember{operator-}{year}%
\begin{itemdecl}
constexpr year operator-(const year& x, const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + -y}.
\end{itemdescr}

\indexlibrarymember{operator-}{year}%
\begin{itemdecl}
constexpr years operator-(const year& x, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{years\{int\{x\} - int\{y\}\}}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts \tcode{format(fmt, y)} where \tcode{fmt} is
\tcode{"\%Y"} widened to \tcode{charT}.
If \tcode{!y.ok()}, appends with \tcode{" is not a valid year"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{year}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{y} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{year}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                year& y, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{year} \tcode{y} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid year,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{y} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\indexlibrarymember{operator""""y}{year}%
\begin{itemdecl}
constexpr year operator""y(unsigned long long y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year\{static_cast<int>(y)\}}.
\end{itemdescr}

\rSec3[time.cal.wd]{Class \tcode{weekday}}

\rSec4[time.cal.wd.overview]{Overview}
\indexlibrary{\idxcode{weekday}}

\begin{codeblock}
namespace std::chrono {
  class weekday {
    unsigned char wd_;          // \expos
  public:
    weekday() = default;
    explicit constexpr weekday(unsigned wd) noexcept;
    constexpr weekday(const sys_days& dp) noexcept;
    explicit constexpr weekday(const local_days& dp) noexcept;

    constexpr weekday& operator++()    noexcept;
    constexpr weekday  operator++(int) noexcept;
    constexpr weekday& operator--()    noexcept;
    constexpr weekday  operator--(int) noexcept;

    constexpr weekday& operator+=(const days& d) noexcept;
    constexpr weekday& operator-=(const days& d) noexcept;

    explicit constexpr operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;

    constexpr weekday_indexed operator[](unsigned index) const noexcept;
    constexpr weekday_last    operator[](last_spec) const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{weekday} represents a day of the week in the civil calendar.
It normally holds values in the range \tcode{0} to \tcode{6},
corresponding to Sunday through Saturday, but
it may hold non-negative values outside this range.
It can be constructed with any \tcode{unsigned} value,
which will be subsequently truncated to fit into \tcode{weekday}'s unspecified internal storage.
\tcode{weekday} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable}).
\begin{note}
\tcode{weekday} is not
\tcode{LessThanComparable}
because there is no universal consensus on which day is the first day of the week.
\tcode{weekday}'s arithmetic operations treat the days of the week as a circular range,
with no beginning and no end.
\end{note}

\pnum
\tcode{weekday} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.wd.members]{Member functions}

\indexlibrary{\idxcode{weekday}!constructor}%
\begin{itemdecl}
explicit constexpr weekday(unsigned wd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{weekday} by
initializing \tcode{wd_} with \tcode{wd}.
The value held is unspecified if \tcode{wd} is not in the range \crange{0}{255}.
\end{itemdescr}

\indexlibrary{\idxcode{weekday}!constructor}%
\begin{itemdecl}
constexpr weekday(const sys_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{weekday} by
computing what day of the week corresponds to the \tcode{sys_days} \tcode{dp},
and representing that day of the week in \tcode{wd_}.

\pnum
\begin{example}
If \tcode{dp} represents 1970-01-01,
the constructed \tcode{weekday} represents Thursday
by storing \tcode{4} in \tcode{wd_}.
\end{example}
\end{itemdescr}

\indexlibrary{\idxcode{weekday}!constructor}%
\begin{itemdecl}
explicit constexpr weekday(const local_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{weekday} by
computing what day of the week corresponds to the \tcode{local_days} \tcode{dp},
and representing that day of the week in \tcode{wd_}.

\pnum
\remarks
The value after construction is identical to that constructed from
\tcode{sys_days\{dp.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{operator++}{weekday}%
\begin{itemdecl}
constexpr weekday& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this += days\{1\}}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{weekday}%
\begin{itemdecl}
constexpr weekday operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator--}{weekday}%
\begin{itemdecl}
constexpr weekday& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this -= days\{1\}}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator--}{weekday}%
\begin{itemdecl}
constexpr weekday operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{--(*this)}.

\pnum
\returns A copy of \tcode{*this} as it existed on entry to this member function.
\end{itemdescr}

\indexlibrarymember{operator+=}{weekday}%
\begin{itemdecl}
constexpr weekday& operator+=(const days& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{weekday}%
\begin{itemdecl}
constexpr weekday& operator-=(const days& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - d}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator unsigned}{weekday}%
\begin{itemdecl}
explicit constexpr operator unsigned() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_}.
\end{itemdescr}

\indexlibrarymember{ok}{weekday}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_ <= 6}.
\end{itemdescr}

\indexlibrarymember{operator[]}{weekday}%
\begin{itemdecl}
constexpr weekday_indexed operator[](unsigned index) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{*this, index\}}.
\end{itemdescr}

\indexlibrarymember{operator[]}{weekday}%
\begin{itemdecl}
constexpr weekday_last operator[](last_spec) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{weekday_last\{*this\}}.
\end{itemdescr}

\rSec4[time.cal.wd.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{weekday}%
\begin{itemdecl}
constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{unsigned\{x\} == unsigned\{y\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{weekday}%
\begin{itemdecl}
constexpr weekday operator+(const weekday& x, const days& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
weekday{modulo(static_cast<long long>(unsigned{x}) + y.count(), 7)}
\end{codeblock}
where \tcode{modulo(n, 7)} computes the remainder of \tcode{n} divided by 7 using Euclidean division.
\begin{note}
Given a divisor of 7, Euclidean division truncates towards negative infinity and
always produces a remainder in the range of \crange{0}{6}.
Assuming no overflow in the signed summation,
this operation results in a \tcode{weekday} holding a value in the range \crange{0}{6} even if \tcode{!x.ok()}.
\end{note}
\begin{example}
\tcode{Monday + days\{6\} == Sunday}.
\end{example}
\end{itemdescr}

\indexlibrarymember{operator+}{weekday}%
\begin{itemdecl}
constexpr weekday operator+(const days& x, const weekday& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y + x}.
\end{itemdescr}

\indexlibrarymember{operator-}{weekday}%
\begin{itemdecl}
constexpr weekday operator-(const weekday& x, const days& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + -y}.
\end{itemdescr}

\indexlibrarymember{operator-}{weekday}%
\begin{itemdecl}
constexpr days operator-(const weekday& x, const weekday& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.ok() == true}
and \tcode{y.ok() == true},
returns a value \tcode{d}
in the range \crange{days\{0\}}{days\{6\}}
satisfying \tcode{y + d == x}.
Otherwise the value returned is unspecified.
\begin{example}
\tcode{Sunday - Monday == days\{6\}}.
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{weekday}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const weekday& wd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{wd.ok() == true}
inserts \tcode{format(os.getloc(), fmt, wd)}
where \tcode{fmt} is \tcode{"\%a"} widened to \tcode{charT}.
Otherwise inserts \tcode{unsigned\{wd\} << " is not a valid weekday"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{weekday}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const weekday& wd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{wd} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{weekday}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                weekday& wd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{weekday} \tcode{wd} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid weekday,
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{wd} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.cal.wdidx]{Class \tcode{weekday_indexed}}

\rSec4[time.cal.wdidx.overview]{Overview}
\indexlibrary{\idxcode{weekday_indexed}}

\begin{codeblock}
namespace std::chrono {
  class weekday_indexed {
    chrono::weekday  wd_;       // \expos
    unsigned char    index_;    // \expos

  public:
    weekday_indexed() = default;
    constexpr weekday_indexed(const chrono::weekday& wd, unsigned index) noexcept;

    constexpr chrono::weekday weekday() const noexcept;
    constexpr unsigned        index()   const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{weekday_indexed} represents a \tcode{weekday}
and a small index in the range 1 to 5.
This class is used to represent the
first, second, third, fourth, or fifth weekday of a month.

\pnum
\begin{note}
A \tcode{weekday_indexed} object
can be constructed by indexing a \tcode{weekday}
with an \tcode{unsigned}.
\end{note}
\begin{example}
\begin{codeblock}
constexpr auto wdi = Sunday[2]; // \tcode{wdi} is the second Sunday of an as yet unspecified month
static_assert(wdi.weekday() == Sunday);
static_assert(wdi.index() == 2);
\end{codeblock}
\end{example}

\pnum
\tcode{weekday_indexed} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.wdidx.members]{Member functions}

\indexlibrary{\idxcode{weekday_indexed}!constructor}%
\begin{itemdecl}
constexpr weekday_indexed(const chrono::weekday& wd, unsigned index) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{weekday_indexed} by
initializing \tcode{wd_} with \tcode{wd} and \tcode{index_} with \tcode{index}.
The values held are unspecified if \tcode{!wd.ok()} or \tcode{index} is not in the range \crange{1}{5}.
\end{itemdescr}

\indexlibrarymember{weekday}{weekday_indexed}%
\begin{itemdecl}
constexpr chrono::weekday weekday() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_}.
\end{itemdescr}

\indexlibrarymember{index}{weekday_indexed}%
\begin{itemdecl}
constexpr unsigned index() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{index_}.
\end{itemdescr}

\indexlibrarymember{ok}{weekday_indexed}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_.ok() \&\& 1 <= index_ \&\& index_ <= 5}.
\end{itemdescr}

\rSec4[time.cal.wdidx.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{weekday_indexed}%
\begin{itemdecl}
constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.weekday() == y.weekday() \&\& x.index() == y.index()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{weekday_indexed}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const weekday_indexed& wdi);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{os << wdi.weekday() << '[' << wdi.index()}.
If \tcode{wdi.index()} is in the range \crange{1}{5},
appends with \tcode{']'},
otherwise
appends with \tcode{" is not a valid index]"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\rSec3[time.cal.wdlast]{Class \tcode{weekday_last}}

\rSec4[time.cal.wdlast.overview]{Overview}
\indexlibrary{\idxcode{weekday_last}}

\begin{codeblock}
namespace std::chrono {
  class weekday_last {
    chrono::weekday wd_;                // \expos

    public:
    explicit constexpr weekday_last(const chrono::weekday& wd) noexcept;

    constexpr chrono::weekday weekday() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{weekday_last} represents the last weekday of a month.

\pnum
\begin{note}
A \tcode{weekday_last} object
can be constructed by indexing a \tcode{weekday} with \tcode{last}.
\end{note}
\begin{example}
\begin{codeblock}
constexpr auto wdl = Sunday[last];      // \tcode{wdl} is the last Sunday of an as yet unspecified month
static_assert(wdl.weekday() == Sunday);
\end{codeblock}
\end{example}

\pnum
\tcode{weekday_last} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.wdlast.members]{Member functions}

\indexlibrary{\idxcode{weekday_last}!constructor}%
\begin{itemdecl}
explicit constexpr weekday_last(const chrono::weekday& wd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{weekday_last} by
initializing \tcode{wd_} with \tcode{wd}.
\end{itemdescr}

\indexlibrarymember{weekday_last}{weekday}%
\begin{itemdecl}
constexpr chrono::weekday weekday() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_}.
\end{itemdescr}

\indexlibrarymember{ok}{weekday_last}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wd_.ok()}.
\end{itemdescr}

\rSec4[time.cal.wdlast.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{weekday_last}%
\begin{itemdecl}
constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.weekday() == y.weekday()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{weekday_last}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const weekday_last& wdl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << wdl.weekday() << "[last]"}.
\end{itemdescr}

\rSec3[time.cal.md]{Class \tcode{month_day}}

\rSec4[time.cal.md.overview]{Overview}
\indexlibrary{\idxcode{month_day}}

\begin{codeblock}
namespace std::chrono {
  class month_day {
    chrono::month m_;           // \expos
    chrono::day   d_;           // \expos

  public:
    month_day() = default;
    constexpr month_day(const chrono::month& m, const chrono::day& d) noexcept;

    constexpr chrono::month month() const noexcept;
    constexpr chrono::day   day()   const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{month_day} represents a specific day of a specific month,
but with an unspecified year.
\tcode{month_day} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\tcode{month_day} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.md.members]{Member functions}

\indexlibrary{\idxcode{month_day}!constructor}%
\begin{itemdecl}
constexpr month_day(const chrono::month& m, const chrono::day& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{month_day} by
initializing \tcode{m_} with \tcode{m}, and \tcode{d_} with \tcode{d}.
\end{itemdescr}

\indexlibrarymember{month}{month_day}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{day}{month_day}%
\begin{itemdecl}
constexpr chrono::day day() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{d_}.
\end{itemdescr}

\indexlibrarymember{ok}{month_day}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if
\tcode{m_.ok()} is \tcode{true},
\tcode{1d <= d_}, and
\tcode{d_} is less than or equal to the number of days in month \tcode{m_};
otherwise returns \tcode{false}.
When \tcode{m_ == February},
the number of days is considered to be 29.
\end{itemdescr}

\rSec4[time.cal.md.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{month_day}%
\begin{itemdecl}
constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.month() == y.month() \&\& x.day() == y.day()}.
\end{itemdescr}

\indexlibrarymember{operator<}{month_day}%
\begin{itemdecl}
constexpr bool operator<(const month_day& x, const month_day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.month() < y.month()} returns \tcode{true}.
Otherwise, if \tcode{x.month() > y.month()} returns \tcode{false}.
Otherwise, returns \tcode{x.day() < y.day()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{month_day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const month_day& md);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << md.month() << '/' << md.day()}.
\end{itemdescr}

\indexlibrarymember{to_stream}{month_day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const month_day& md);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{md} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{month_day}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                month_day& md, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{month_day} \tcode{md} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid \tcode{month_day},
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{md} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.cal.mdlast]{Class \tcode{month_day_last}}
\indexlibrary{\idxcode{month_day_last}}

\begin{codeblock}
namespace std::chrono {
  class month_day_last {
    chrono::month m_;                   // \expos

  public:
    explicit constexpr month_day_last(const chrono::month& m) noexcept;

    constexpr chrono::month month() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{month_day_last} represents the last day of a month.

\pnum
\begin{note}
A \tcode{month_day_last} object
can be constructed using the expression \tcode{m/last} or \tcode{last/m},
where \tcode{m} is an expression of type \tcode{month}.
\end{note}
\begin{example}
\begin{codeblock}
constexpr auto mdl = February/last;     // \tcode{mdl} is the last day of February of an as yet unspecified year
static_assert(mdl.month() == February);
\end{codeblock}
\end{example}

\pnum
\tcode{month_day_last} is a trivially copyable and standard-layout class type.

\indexlibrary{\idxcode{month_day_last}!constructor}%
\begin{itemdecl}
explicit constexpr month_day_last(const chrono::month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{month_day_last} by
initializing \tcode{m_} with \tcode{m}.
\end{itemdescr}

\indexlibrarymember{month}{month_day_last}%
\begin{itemdecl}
constexpr month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{ok}{month_day_last}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_.ok()}.
\end{itemdescr}

\indexlibrarymember{operator==}{month_day_last}%
\begin{itemdecl}
constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.month() == y.month()}.
\end{itemdescr}

\indexlibrarymember{operator<}{month_day_last}%
\begin{itemdecl}
constexpr bool operator<(const month_day_last& x, const month_day_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.month() < y.month()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{month_day_last}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const month_day_last& mdl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << mdl.month() << "/last"}.
\end{itemdescr}

\rSec3[time.cal.mwd]{Class \tcode{month_weekday}}

\rSec4[time.cal.mwd.overview]{Overview}
\indexlibrary{\idxcode{month_weekday}}

\begin{codeblock}
namespace std::chrono {
  class month_weekday {
    chrono::month           m_;         // \expos
    chrono::weekday_indexed wdi_;       // \expos
  public:
    constexpr month_weekday(const chrono::month& m, const chrono::weekday_indexed& wdi) noexcept;

    constexpr chrono::month           month()           const noexcept;
    constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{month_weekday} represents the n$^\textrm{th}$ weekday of a month,
of an as yet unspecified year.
To do this the \tcode{month_weekday} stores a \tcode{month} and a \tcode{weekday_indexed}.

\pnum
\begin{example}
\begin{codeblock}
constexpr auto mwd
    = February/Tueday[3];               // \tcode{mwd} is the third Tuesday of February of an as yet unspecified year
static_assert(mwd.month() == February);
static_assert(mwd.weekday_indexed() == Tueday[3]);
\end{codeblock}
\end{example}

\pnum
\tcode{month_weekday} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.mwd.members]{Member functions}

\indexlibrary{\idxcode{month_weekday}!constructor}%
\begin{itemdecl}
constexpr month_weekday(const chrono::month& m, const chrono::weekday_indexed& wdi) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{month_weekday} by
initializing \tcode{m_} with \tcode{m}, and \tcode{wdi_} with \tcode{wdi}.
\end{itemdescr}

\indexlibrarymember{month}{month_weekday}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{weekday_indexed}{month_weekday}%
\begin{itemdecl}
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdi_}.
\end{itemdescr}

\indexlibrarymember{ok}{month_weekday}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_.ok() \&\& wdi_.ok()}.
\end{itemdescr}

\rSec4[time.cal.mwd.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{month_weekday}%
\begin{itemdecl}
constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.month() == y.month() \&\& x.weekday_indexed() == y.weekday_indexed()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{month_weekday}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const month_weekday& mwd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << mwd.month() << '/' << mwd.weekday_indexed()}.
\end{itemdescr}

\rSec3[time.cal.mwdlast]{Class \tcode{month_weekday_last}}

\rSec4[time.cal.mwdlast.overview]{Overview}
\indexlibrary{\idxcode{month_weekday_last}}

\begin{codeblock}
namespace std::chrono {
  class month_weekday_last {
    chrono::month        m_;    // \expos
    chrono::weekday_last wdl_;  // \expos
  public:
    constexpr month_weekday_last(const chrono::month& m,
                                 const chrono::weekday_last& wdl) noexcept;

    constexpr chrono::month        month()        const noexcept;
    constexpr chrono::weekday_last weekday_last() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{month_weekday_last} represents the last weekday of a month,
of an as yet unspecified year.
To do this the \tcode{month_weekday_last} stores a \tcode{month} and a \tcode{weekday_last}.

\pnum
\begin{example}
\begin{codeblock}
constexpr auto mwd
    = February/Tueday[last];    // \tcode{mwd} is the last Tuesday of February of an as yet unspecified year
static_assert(mwd.month() == February);
static_assert(mwd.weekday_last() == Tueday[last]);
\end{codeblock}
\end{example}

\pnum
\tcode{month_weekday_last} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.mwdlast.members]{Member functions}

\indexlibrary{\idxcode{month_weekday_last}!constructor}%
\begin{itemdecl}
constexpr month_weekday_last(const chrono::month& m,
                             const chrono::weekday_last& wdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{month_weekday_last} by
initializing \tcode{m_} with \tcode{m}, and \tcode{wdl_} with \tcode{wdl}.
\end{itemdescr}

\indexlibrarymember{month}{month_weekday_last}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{weekday_last}{month_weekday_last}%
\begin{itemdecl}
constexpr chrono::weekday_last weekday_last() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdl_}.
\end{itemdescr}

\indexlibrarymember{ok}{month_weekday_last}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_.ok() \&\& wdl_.ok()}.
\end{itemdescr}

\rSec4[time.cal.mwdlast.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{month_weekday_last}%
\begin{itemdecl}
constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.month() == y.month() \&\& x.weekday_last() == y.weekday_last()}.
\end{itemdescr}

\indexlibrarymember{operator<<}{month_weekday_last}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const month_weekday_last& mwdl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << mwdl.month() << '/' << mwdl.weekday_last()}.
\end{itemdescr}

\rSec3[time.cal.ym]{Class \tcode{year_month}}

\rSec4[time.cal.ym.overview]{Overview}
\indexlibrary{\idxcode{year_month}}

\begin{codeblock}
namespace std::chrono {
  class year_month {
    chrono::year  y_;           // \expos
    chrono::month m_;           // \expos

  public:
    year_month() = default;
    constexpr year_month(const chrono::year& y, const chrono::month& m) noexcept;

    constexpr chrono::year  year()  const noexcept;
    constexpr chrono::month month() const noexcept;

    constexpr year_month& operator+=(const months& dm) noexcept;
    constexpr year_month& operator-=(const months& dm) noexcept;
    constexpr year_month& operator+=(const years& dy)  noexcept;
    constexpr year_month& operator-=(const years& dy)  noexcept;

    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year_month} represents a specific month of a specific year,
but with an unspecified day.
\tcode{year_month} is a field-based time point with a resolution of \tcode{months}.
\tcode{year_month} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\tcode{year_month} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.ym.members]{Member functions}

\indexlibrary{\idxcode{year_month}!constructor}%
\begin{itemdecl}
constexpr year_month(const chrono::year& y, const chrono::month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month} by
initializing \tcode{y_} with \tcode{y}, and \tcode{m_} with \tcode{m}.
\end{itemdescr}

\indexlibrarymember{year}{year_month}%
\begin{itemdecl}
constexpr chrono::year year() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{month}{year_month}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month}%
\begin{itemdecl}
constexpr year_month& operator+=(const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + dm}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month}%
\begin{itemdecl}
constexpr year_month& operator-=(const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - dm}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month}%
\begin{itemdecl}
constexpr year_month& operator+=(const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + dy}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month}%
\begin{itemdecl}
constexpr year_month& operator-=(const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - dy}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{ok}{year_month}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_.ok() \&\& m_.ok()}.
\end{itemdescr}

\rSec4[time.cal.ym.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year_month}%
\begin{itemdecl}
constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.year() == y.year() \&\& x.month() == y.month()}.
\end{itemdescr}

\indexlibrarymember{operator<}{year_month}%
\begin{itemdecl}
constexpr bool operator<(const year_month& x, const year_month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.year() < y.year()} returns \tcode{true}.
Otherwise, if \tcode{x.year() > y.year()} returns \tcode{false}.
Otherwise, returns \tcode{x.month() < y.month()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month}%
\begin{itemdecl}
constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A \tcode{year_month} value \tcode{z} such that \tcode{z - ym == dm}.

\complexity
\bigoh{1} with respect to the value of \tcode{dm}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month}%
\begin{itemdecl}
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ym + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month}%
\begin{itemdecl}
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ym + -dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month}%
\begin{itemdecl}
constexpr months operator-(const year_month& x, const year_month& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
x.year() - y.year() + months{static_cast<int>(unsigned{x.month()}) -
                             static_cast<int>(unsigned{y.month()})}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{year_month}%
\begin{itemdecl}
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ym.year() + dy) / ym.month()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month}%
\begin{itemdecl}
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ym + dy}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month}%
\begin{itemdecl}
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ym + -dy}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year_month}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year_month& ym);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << ym.year() << '/' << ym.month()}.
\end{itemdescr}

\indexlibrarymember{to_stream}{year_month}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year_month& ym);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{ym} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{year_month}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                year_month& ym, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{year_month} \tcode{ym} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid \tcode{year_month},
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{ym} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.cal.ymd]{Class \tcode{year_month_day}}

\rSec4[time.cal.ymd.overview]{Overview}
\indexlibrary{\idxcode{year_month_day}}

\begin{codeblock}
namespace std::chrono {
  class year_month_day {
    chrono::year  y_;           // \expos
    chrono::month m_;           // \expos
    chrono::day   d_;           // \expos

  public:
    year_month_day() = default;
    constexpr year_month_day(const chrono::year& y, const chrono::month& m,
                             const chrono::day& d) noexcept;
    constexpr year_month_day(const year_month_day_last& ymdl) noexcept;
    constexpr year_month_day(const sys_days& dp) noexcept;
    explicit constexpr year_month_day(const local_days& dp) noexcept;

    constexpr year_month_day& operator+=(const months& m) noexcept;
    constexpr year_month_day& operator-=(const months& m) noexcept;
    constexpr year_month_day& operator+=(const years& y)  noexcept;
    constexpr year_month_day& operator-=(const years& y)  noexcept;

    constexpr chrono::year  year()  const noexcept;
    constexpr chrono::month month() const noexcept;
    constexpr chrono::day   day()   const noexcept;

    constexpr          operator sys_days()   const noexcept;
    explicit constexpr operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year_month_day} represents a specific year, month, and day.
\tcode{year_month_day} is a field-based time point with a resolution of \tcode{days}.
\begin{note}
\tcode{year_month_day} supports \tcode{years}- and \tcode{months}-oriented arithmetic,
but not \tcode{days}-oriented arithmetic.
For the latter, there is a conversion to \tcode{sys_days},
which efficiently supports \tcode{days}-oriented arithmetic.
\end{note}
\tcode{year_month_day} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}),

\pnum
\tcode{year_month_day} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.ymd.members]{Member functions}

\indexlibrary{\idxcode{year_month_day}!constructor}%
\begin{itemdecl}
constexpr year_month_day(const chrono::year& y, const chrono::month& m,
                         const chrono::day& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_day} by
initializing
\tcode{y_} with \tcode{y},
\tcode{m_} with \tcode{m}, and
\tcode{d_} with \tcode{d}.
\end{itemdescr}

\indexlibrary{\idxcode{year_month_day}!constructor}%
\begin{itemdecl}
constexpr year_month_day(const year_month_day_last& ymdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_day} by
initializing
\tcode{y_} with \tcode{ymdl.year()},
\tcode{m_} with \tcode{ymdl.month()}, and
\tcode{d_} with \tcode{ymdl.day()}.
\begin{note}
This conversion from \tcode{year_month_day_last} to \tcode{year_month_day}
may be more efficient than converting a \tcode{year_month_day_last} to a \tcode{sys_days},
and then converting that \tcode{sys_days} to a \tcode{year_month_day}.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{year_month_day}!constructor}%
\begin{itemdecl}
constexpr year_month_day(const sys_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_day}
that corresponds to the date represented by \tcode{dp}.

\pnum
\remarks
For any value \tcode{ymd} of type \tcode{year_month_day}
for which \tcode{ymd.ok()} is \tcode{true},
\tcode{ymd == year_month_day\{sys_days\{ymd\}\}}
is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{year_month_day}!constructor}%
\begin{itemdecl}
explicit constexpr year_month_day(const local_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_day}
that corresponds to the date represented by \tcode{dp}.

\pnum
\remarks
Equivalent to constructing with \tcode{sys_days\{dp.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day& operator+=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day& operator-=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day& year_month_day::operator+=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day& year_month_day::operator-=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{year}{year_month_day}%
\begin{itemdecl}
constexpr chrono::year year() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{month}{year_month_day}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{day}{year_month_day}%
\begin{itemdecl}
constexpr chrono::day day() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{d_}.
\end{itemdescr}

\indexlibrarymember{operator sys_days}{year_month_day}%
\begin{itemdecl}
constexpr operator sys_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{ok()},
returns a \tcode{sys_days}
holding a count of days from the \tcode{sys_days} epoch to \tcode{*this}
(a negative value if \tcode{*this} represents a date prior to the \tcode{sys_days} epoch).
Otherwise, if \tcode{y_.ok() \&\& m_.ok()} is \tcode{true},
returns a \tcode{sys_days}
which is offset from \tcode{sys_days\{y_/m_/last\}}
by the number of days \tcode{d_} is offset from \tcode{sys_days\{y_/m_/last\}.day()}.
Otherwise the value returned is unspecified.

\pnum
\remarks
A \tcode{sys_days} in the range \crange{days\{-12687428\}}{days\{11248737\}}
which is converted to a \tcode{year_month_day}
shall have the same value when converted back to a \tcode{sys_days}.

\pnum
\begin{example}
\begin{codeblock}
static_assert(year_month_day{sys_days{2017y/January/0}}  == 2016y/December/31);
static_assert(year_month_day{sys_days{2017y/January/31}} == 2017y/January/31);
static_assert(year_month_day{sys_days{2017y/January/32}} == 2017y/February/1);
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator local_days}{year_month_day}%
\begin{itemdecl}
explicit constexpr operator local_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{local_days\{sys_days\{*this\}.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{ok}{year_month_day}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{y_.ok()} is \tcode{true},
and \tcode{m_.ok()} is \tcode{true},
and \tcode{d_} is in the range \crange{1d}{(y_/m_/last).day()},
then returns \tcode{true}; otherwise returns \tcode{false}.
\end{itemdescr}

\rSec4[time.cal.ymd.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year_month_day}%
\begin{itemdecl}
constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.year() == y.year() \&\& x.month() == y.month() \&\& x.day() == y.day()}.
\end{itemdescr}

\indexlibrarymember{operator<}{year_month_day}%
\begin{itemdecl}
constexpr bool operator<(const year_month_day& x, const year_month_day& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.year() < y.year()}, returns \tcode{true}.
Otherwise, if \tcode{x.year() > y.year()}, returns \tcode{false}.
Otherwise, if \tcode{x.month() < y.month()}, returns \tcode{true}.
Otherwise, if \tcode{x.month() > y.month()}, returns \tcode{false}.
Otherwise, returns \tcode{x.day() < y.day()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ymd.year() / ymd.month() + dm) / ymd.day()}.

\pnum
\begin{note}
If \tcode{ymd.day()} is in the range \crange{1d}{28d},
\tcode{ok()} will return \tcode{true} for
the resultant \tcode{year_month_day}.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymd + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymd + (-dm)}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ymd.year() + dy) / ymd.month() / ymd.day()}.

\pnum
\begin{note}
If \tcode{ymd.month()} is February
and \tcode{ymd.day()} is not in the range \crange{1d}{28d},
\tcode{ok()} may return \tcode{false} for
the resultant \tcode{year_month_day}.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymd + dy}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_day}%
\begin{itemdecl}
constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymd + (-dy)}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year_month_day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year_month_day& ymd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts \tcode{format(fmt, ymd)}
where \tcode{fmt} is \tcode{"\%F"} widened to \tcode{charT}.
If \tcode{!ymd.ok()}, appends with \tcode{" is not a valid date"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{year_month_day}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt, const year_month_day& ymd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams \tcode{ymd} into \tcode{os} using
the format specified by the NTCTS \tcode{fmt}.
\tcode{fmt} encoding follows the rules specified in \ref{time.format}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{from_stream}{year_month_day}%
\begin{itemdecl}
template<class charT, class traits, class Alloc = allocator<charT>>
  basic_istream<charT, traits>&
    from_stream(basic_istream<charT, traits>& is, const charT* fmt,
                year_month_day& ymd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
                minutes* offset = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Attempts to parse the input stream \tcode{is}
into the \tcode{year_month_day} \tcode{ymd} using
the format flags given in the NTCTS \tcode{fmt}
as specified in \ref{time.parse}.
If the parse fails to decode a valid \tcode{year_month_day},
\tcode{is.setstate(ios_base::failbit)} shall be called
and \tcode{ymd} shall not be modified.
If \tcode{\%Z} is used and successfully parsed,
that value will be assigned to \tcode{*abbrev} if \tcode{abbrev} is non-null.
If \tcode{\%z} (or a modified variant) is used and successfully parsed,
that value will be assigned to \tcode{*offset} if \tcode{offset} is non-null.

\pnum
\returns \tcode{is}.
\end{itemdescr}

\rSec3[time.cal.ymdlast]{Class \tcode{year_month_day_last}}

\rSec4[time.cal.ymdlast.overview]{Overview}
\indexlibrary{\idxcode{year_month_day_last}}

\begin{codeblock}
namespace std::chrono {
  class year_month_day_last {
    chrono::year           y_;          // \expos
    chrono::month_day_last mdl_;        // \expos

  public:
    constexpr year_month_day_last(const chrono::year& y,
                                  const chrono::month_day_last& mdl) noexcept;

    constexpr year_month_day_last& operator+=(const months& m) noexcept;
    constexpr year_month_day_last& operator-=(const months& m) noexcept;
    constexpr year_month_day_last& operator+=(const years& y)  noexcept;
    constexpr year_month_day_last& operator-=(const years& y)  noexcept;

    constexpr chrono::year           year()           const noexcept;
    constexpr chrono::month          month()          const noexcept;
    constexpr chrono::month_day_last month_day_last() const noexcept;
    constexpr chrono::day            day()            const noexcept;

    constexpr          operator sys_days()   const noexcept;
    explicit constexpr operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year_month_day_last} represents the last day of a specific year and month.
\tcode{year_month_day_last} is a field-based time point with a resolution of \tcode{days},
except that it is restricted to pointing to the last day of a year and month.
\begin{note}
\tcode{year_month_day_last} supports \tcode{years}- and \tcode{months}-oriented arithmetic,
but not \tcode{days}-oriented arithmetic.
For the latter, there is a conversion to \tcode{sys_days},
which efficiently supports \tcode{days}-oriented arithmetic.
\end{note}
\tcode{year_month_day_last} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable})
and \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}),

\pnum
\tcode{year_month_day_last} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.ymdlast.members]{Member functions}

\indexlibrary{\idxcode{year_month_day_last}!constructor}%
\begin{itemdecl}
constexpr year_month_day_last(const chrono::year& y,
                              const chrono::month_day_last& mdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_day_last} by
initializing \tcode{y_} with \tcode{y} and \tcode{mdl_} with \tcode{mdl}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last& operator+=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last& operator-=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last& operator+=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last& operator-=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{year}{year_month_day_last}%
\begin{itemdecl}
constexpr chrono::year year() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{month}{year_month_day_last}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{mdl_.month()}.
\end{itemdescr}

\indexlibrarymember{month_day_last}{year_month_day_last}%
\begin{itemdecl}
constexpr chrono::month_day_last month_day_last() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{mdl_}.
\end{itemdescr}

\indexlibrarymember{day}{year_month_day_last}%
\begin{itemdecl}
constexpr chrono::day day() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{day} representing the last day of the (\tcode{year}, \tcode{month}) pair
represented by \tcode{*this}.

\pnum
\begin{note}
This value may be computed on demand.
\end{note}
\end{itemdescr}

\indexlibrarymember{operator sys_days}{year_month_day_last}%
\begin{itemdecl}
constexpr operator sys_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{sys_days\{year()/month()/day()\}}.
\end{itemdescr}

\indexlibrarymember{operator local_days}{year_month_day_last}%
\begin{itemdecl}
explicit constexpr operator local_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{local_days\{sys_days\{*this\}.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{ok}{year_month_day_last}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_.ok() \&\& mdl_.ok()}.
\end{itemdescr}

\rSec4[time.cal.ymdlast.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year_month_day_last}%
\begin{itemdecl}
constexpr bool operator==(const year_month_day_last& x, const year_month_day_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.year() == y.year() \&\& x.month_day_last() == y.month_day_last()}.
\end{itemdescr}

\indexlibrarymember{operator<}{year_month_day_last}%
\begin{itemdecl}
constexpr bool operator<(const year_month_day_last& x, const year_month_day_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{x.year() < y.year()}, returns \tcode{true}.
Otherwise, if \tcode{x.year() > y.year()}, returns \tcode{false}.
Otherwise, returns \tcode{x.month_day_last() < y.month_day_last()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ymdl.year() / ymdl.month() + dm) / last}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymdl + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymdl + (-dm)}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ymdl.year()+dy, ymdl.month_day_last()\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymdl + dy}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_day_last}%
\begin{itemdecl}
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymdl + (-dy)}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year_month_day_last}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year_month_day_last& ymdl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << ymdl.year() << '/' << ymdl.month_day_last()}.
\end{itemdescr}

\rSec3[time.cal.ymwd]{Class \tcode{year_month_weekday}}

\rSec4[time.cal.ymwd.overview]{Overview}
\indexlibrary{\idxcode{year_month_weekday}}

\begin{codeblock}
namespace std::chrono {
  class year_month_weekday {
    chrono::year            y_;         // \expos
    chrono::month           m_;         // \expos
    chrono::weekday_indexed wdi_;       // \expos

  public:
    year_month_weekday() = default;
    constexpr year_month_weekday(const chrono::year& y, const chrono::month& m,
                                 const chrono::weekday_indexed& wdi) noexcept;
    constexpr year_month_weekday(const sys_days& dp) noexcept;
    explicit constexpr year_month_weekday(const local_days& dp) noexcept;

    constexpr year_month_weekday& operator+=(const months& m) noexcept;
    constexpr year_month_weekday& operator-=(const months& m) noexcept;
    constexpr year_month_weekday& operator+=(const years& y)  noexcept;
    constexpr year_month_weekday& operator-=(const years& y)  noexcept;

    constexpr chrono::year            year()            const noexcept;
    constexpr chrono::month           month()           const noexcept;
    constexpr chrono::weekday         weekday()         const noexcept;
    constexpr unsigned                index()           const noexcept;
    constexpr chrono::weekday_indexed weekday_indexed() const noexcept;

    constexpr          operator sys_days()   const noexcept;
    explicit constexpr operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year_month_weekday} represents a specific year, month,
and n$^\textrm{th}$ weekday of the month.
\tcode{year_month_weekday} is a field-based time point with a resolution of \tcode{days}.
\begin{note}
\tcode{year_month_weekday} supports \tcode{years}- and \tcode{months}-oriented arithmetic,
but not \tcode{days}-oriented arithmetic.
For the latter, there is a conversion to \tcode{sys_days},
which efficiently supports \tcode{days}-oriented arithmetic.
\end{note}
\tcode{year_month_weekday} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable}).

\pnum
\tcode{year_month_weekday} is a trivially copyable and standard-layout class type.

\rSec4[time.cal.ymwd.members]{Member functions}

\indexlibrary{\idxcode{year_month_weekday}!constructor}%
\begin{itemdecl}
constexpr year_month_weekday(const chrono::year& y, const chrono::month& m,
                             const chrono::weekday_indexed& wdi) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_weekday} by
initializing \tcode{y_} with \tcode{y}, \tcode{m_} with \tcode{m}, and \tcode{wdi_} with \tcode{wdi}.
\end{itemdescr}

\indexlibrary{\idxcode{year_month_weekday}!constructor}%
\begin{itemdecl}
constexpr year_month_weekday(const sys_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_weekday}
which corresponds to the date represented by \tcode{dp}.

\pnum
\remarks
For any value \tcode{ymdl} of type \tcode{year_month_weekday}
for which \tcode{ymdl.ok()} is \tcode{true},
\tcode{ymdl == year_month_weekday\{sys_days\{ymdl\}\}} is \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{year_month_weekday}!constructor}%
\begin{itemdecl}
explicit constexpr year_month_weekday(const local_days& dp) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_weekday}
that corresponds to the date represented by \tcode{dp}.

\pnum
\remarks
Equivalent to constructing with \tcode{sys_days\{dp.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday& operator+=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday& operator-=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday& operator+=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday& operator-=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{year}{year_month_weekday}%
\begin{itemdecl}
constexpr chrono::year year() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{month}{year_month_weekday}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{weekday}{year_month_weekday}%
\begin{itemdecl}
constexpr chrono::weekday weekday() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdi_.weekday()}.
\end{itemdescr}

\indexlibrarymember{index}{year_month_weekday}%
\begin{itemdecl}
constexpr unsigned index() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdi_.index()}.
\end{itemdescr}

\indexlibrarymember{weekday_indexed}{year_month_weekday}%
\begin{itemdecl}
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdi_}.
\end{itemdescr}

\indexlibrarymember{operator sys_days}{year_month_weekday}%
\begin{itemdecl}
constexpr operator sys_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{y_.ok() \&\& m_.ok() \&\& wdi_.weekday().ok()},
returns a \tcode{sys_days} that
represents the date \tcode{(index() - 1) * 7} days after
the first \tcode{weekday()} of \tcode{year()/month()}.
If \tcode{index()} is 0
the returned \tcode{sys_days}
represents the date 7 days prior to
the first \tcode{weekday()} of \tcode{year()/month()}.
Otherwise the returned value is unspecified.
\end{itemdescr}

\indexlibrarymember{operator local_days}{year_month_weekday}%
\begin{itemdecl}
explicit constexpr operator local_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{local_days\{sys_days\{*this\}.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{ok}{year_month_weekday}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If any of
\tcode{y_.ok()},
\tcode{m_.ok()}, or
\tcode{wdi_.ok()}
is \tcode{false}, returns \tcode{false}.
Otherwise, if \tcode{*this} represents a valid date,
returns \tcode{true}.
Otherwise, returns \tcode{false}.
\end{itemdescr}

\rSec4[time.cal.ymwd.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year_month_weekday}%
\begin{itemdecl}
constexpr bool operator==(const year_month_weekday& x, const year_month_weekday& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
x.year() == y.year() && x.month() == y.month() && x.weekday_indexed() == y.weekday_indexed()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ymwd.year() / ymwd.month() + dm) / ymwd.weekday_indexed()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwd + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwd + (-dm)}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ymwd.year()+dy, ymwd.month(), ymwd.weekday_indexed()\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwd + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_weekday}%
\begin{itemdecl}
constexpr year_month_weekday operator-(const year_month_weekday& ymwd, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwd + (-dm)}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year_month_weekday}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year_month_weekday& ymwd);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << ymwdi.year() << '/' << ymwdi.month() << '/' << ymwdi.weekday_indexed()}.
\end{itemdescr}

\rSec3[time.cal.ymwdlast]{Class \tcode{year_month_weekday_last}}

\rSec4[time.cal.ymwdlast.overview]{Overview}
\indexlibrary{\idxcode{year_month_weekday_last}}

\begin{codeblock}
namespace std::chrono {
  class year_month_weekday_last {
    chrono::year         y_;    // \expos
    chrono::month        m_;    // \expos
    chrono::weekday_last wdl_;  // \expos

  public:
    constexpr year_month_weekday_last(const chrono::year& y, const chrono::month& m,
                                      const chrono::weekday_last& wdl) noexcept;

    constexpr year_month_weekday_last& operator+=(const months& m) noexcept;
    constexpr year_month_weekday_last& operator-=(const months& m) noexcept;
    constexpr year_month_weekday_last& operator+=(const years& y)  noexcept;
    constexpr year_month_weekday_last& operator-=(const years& y)  noexcept;

    constexpr chrono::year         year()         const noexcept;
    constexpr chrono::month        month()        const noexcept;
    constexpr chrono::weekday      weekday()      const noexcept;
    constexpr chrono::weekday_last weekday_last() const noexcept;

    constexpr          operator sys_days()   const noexcept;
    explicit constexpr operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
  };
}
\end{codeblock}

\pnum
\tcode{year_month_weekday_last} represents a specific year, month,
and last weekday of the month.
\tcode{year_month_weekday_last} is a field-based time point with a resolution of \tcode{days},
except that it is restricted to pointing to the last weekday of a year and month.
\begin{note}
\tcode{year_month_weekday_last} supports \tcode{years}- and \tcode{months}-oriented arithmetic,
but not \tcode{days}-oriented arithmetic.
For the latter, there is a conversion to \tcode{sys_days},
which efficiently supports \tcode{days}-oriented arithmetic.
\end{note}
\tcode{year_month_weekday_last} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable}).

\rSec4[time.cal.ymwdlast.members]{Member functions}

\pnum
\tcode{year_month_weekday_last} is a trivially copyable and standard-layout class type.

\indexlibrary{\idxcode{year_month_weekday_last}!constructor}%
\begin{itemdecl}
constexpr year_month_weekday_last(const chrono::year& y, const chrono::month& m,
                                  const chrono::weekday_last& wdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{year_month_weekday_last} by
initializing \tcode{y_} with \tcode{y}, \tcode{m_} with \tcode{m}, and \tcode{wdl_} with \tcode{wdl}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last& operator+=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last& operator-=(const months& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - m}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator+=}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last& operator+=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this + y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last& operator-=(const years& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{*this = *this - y}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{year}{year_month_weekday_last}%
\begin{itemdecl}
constexpr chrono::year year() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_}.
\end{itemdescr}

\indexlibrarymember{month}{year_month_weekday_last}%
\begin{itemdecl}
constexpr chrono::month month() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m_}.
\end{itemdescr}

\indexlibrarymember{weekday}{year_month_weekday_last}%
\begin{itemdecl}
constexpr chrono::weekday weekday() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdl_.weekday()}.
\end{itemdescr}

\indexlibrarymember{weekday_last}{year_month_weekday_last}%
\begin{itemdecl}
constexpr chrono::weekday_last weekday_last() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{wdl_}.
\end{itemdescr}

\indexlibrarymember{operator sys_days}{year_month_weekday_last}%
\begin{itemdecl}
constexpr operator sys_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{ok() == true},
returns a \tcode{sys_days} that represents
the last \tcode{weekday()} of \tcode{year()/month()}.
Otherwise the returned value is unspecified.
\end{itemdescr}

\indexlibrarymember{operator local_days}{year_month_weekday_last}%
\begin{itemdecl}
explicit constexpr operator local_days() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{local_days\{sys_days\{*this\}.time_since_epoch()\}}.
\end{itemdescr}

\indexlibrarymember{ok}{year_month_weekday_last}%
\begin{itemdecl}
constexpr bool ok() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y_.ok() \&\& m_.ok() \&\& wdl_.ok()}.
\end{itemdescr}

\rSec4[time.cal.ymwdlast.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{year_month_weekday_last}%
\begin{itemdecl}
constexpr bool operator==(const year_month_weekday_last& x,
                          const year_month_weekday_last& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
x.year() == y.year() && x.month() == y.month() && x.weekday_last() == y.weekday_last()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(ymwdl.year() / ymwdl.month() + dm) / ymwdl.weekday_last()}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwdl + dm}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwdl + (-dm)}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ymwdl.year()+dy, ymwdl.month(), ymwdl.weekday_last()\}}.
\end{itemdescr}

\indexlibrarymember{operator+}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwdl + dy}.
\end{itemdescr}

\indexlibrarymember{operator-}{year_month_weekday_last}%
\begin{itemdecl}
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ymwdl + (-dy)}.
\end{itemdescr}

\indexlibrarymember{operator<<}{year_month_weekday_last}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const year_month_weekday_last& ymwdl);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{os << ymwdl.year() << '/' << ymwdl.month() << '/' << ymwdl.weekday_last()}.
\end{itemdescr}

\rSec3[time.cal.operators]{Conventional syntax operators}
\indexlibrary{\idxcode{operator/}!calendar types|(}

\pnum
A set of overloaded \tcode{operator/} functions provides
a conventional syntax for the creation of civil calendar dates.

\pnum
\begin{note}
The year, month, and day are accepted in any of the following 3 orders:

\begin{codeblock}
@\tcode{\placeholder{year}}@/@\tcode{\placeholder{month}}@/@\tcode{\placeholder{day}}@
@\tcode{\placeholder{month}}@/@\tcode{\placeholder{day}}@/@\tcode{\placeholder{year}}@
@\tcode{\placeholder{day}}@/@\tcode{\placeholder{month}}@/@\tcode{\placeholder{year}}@
\end{codeblock}

Anywhere a \tcode{\placeholder{day}} is required, any of the following can also be specified:

\begin{codeblock}
last
@\tcode{\placeholder{weekday}}@[@\tcode{\placeholder{i}}@]
@\tcode{\placeholder{weekday}}@[last]
\end{codeblock}
\end{note}

\pnum
\begin{note}
Partial-date types such as \tcode{year_month} and \tcode{month_day}
can be created by not applying the second division operator
for any of the three orders. For example:

\begin{codeblock}
year_month ym = 2015y/April;
month_day md1 = April/4;
month_day md2 = 4d/April;
\end{codeblock}
\end{note}

\pnum
\begin{example}
\begin{codeblock}
auto a = 2015/4/4;         // \tcode{a == int(125)}
auto b = 2015y/4/4;        // \tcode{b == year_month_day\{year(2015), month(4), day(4)\}}
auto c = 2015y/4d/April;   // error: no viable \tcode{operator/} for first \tcode{/}
auto d = 2015/April/4;     // error: no viable \tcode{operator/} for first \tcode{/}
\end{codeblock}
\end{example}

\begin{itemdecl}
constexpr year_month
  operator/(const year& y, const month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{y, m\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month
  operator/(const year& y, int   m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / month(m)}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day
  operator/(const month& m, const day& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{m, d\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day
  operator/(const month& m, int d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m / day(d)}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day
  operator/(int m, const day& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / d}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day
  operator/(const day& d, const month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m / d}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day
  operator/(const day& d, int m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / d}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day_last
  operator/(const month& m, last_spec) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month_day_last\{m\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day_last
  operator/(int m, last_spec) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / last}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day_last
  operator/(last_spec, const month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m / last}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_day_last
  operator/(last_spec, int m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / last}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday
  operator/(const month& m, const weekday_indexed& wdi) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{m, wdi\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday
  operator/(int m, const weekday_indexed& wdi) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / wdi}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday
  operator/(const weekday_indexed& wdi, const month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m / wdi}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday
  operator/(const weekday_indexed& wdi, int m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / wdi}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday_last
  operator/(const month& m, const weekday_last& wdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{m, wdl\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday_last
  operator/(int m, const weekday_last& wdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / wdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday_last
  operator/(const weekday_last& wdl, const month& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{m / wdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr month_weekday_last
  operator/(const weekday_last& wdl, int m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{month(m) / wdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(const year_month& ym, const day& d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ym.year(), ym.month(), d\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(const year_month& ym, int d) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ym / day(d)}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(const year& y, const month_day& md) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / md.month() / md.day()}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(int y, const month_day& md) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / md}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(const month_day& md, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / md}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day
  operator/(const month_day& md, int y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / md}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day_last
  operator/(const year_month& ym, last_spec) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ym.year(), month_day_last\{ym.month()\}\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day_last
  operator/(const year& y, const month_day_last& mdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{y, mdl\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day_last
  operator/(int y, const month_day_last& mdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day_last
  operator/(const month_day_last& mdl, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / mdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_day_last
  operator/(const month_day_last& mdl, int y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday
  operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ym.year(), ym.month(), wdi\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday
  operator/(const year& y, const month_weekday& mwd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{y, mwd.month(), mwd.weekday_indexed()\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday
  operator/(int y, const month_weekday& mwd) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mwd}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday
  operator/(const month_weekday& mwd, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / mwd}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday
  operator/(const month_weekday& mwd, int y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mwd}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday_last
  operator/(const year_month& ym, const weekday_last& wdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{ym.year(), ym.month(), wdl\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday_last
  operator/(const year& y, const month_weekday_last& mwdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\{y, mwdl.month(), mwdl.weekday_last()\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday_last
  operator/(int y, const month_weekday_last& mwdl) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mwdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, const year& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y / mwdl}.
\end{itemdescr}

\begin{itemdecl}
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, int y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{year(y) / mwdl}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/}!calendar types|)}

\rSec2[time.tod]{Class template \tcode{time_of_day}}

\rSec3[time.tod.overview]{Overview}
\indexlibrary{\idxcode{time_of_day}}

\begin{codeblock}
namespace std::chrono {
  template<class Duration> class time_of_day;

  template<> class time_of_day<hours>;
  template<> class time_of_day<minutes>;
  template<> class time_of_day<seconds>;
  template<class Rep, class Period> class time_of_day<duration<Rep, Period>>;
}
\end{codeblock}

\pnum
The \tcode{time_of_day} class template
splits a \tcode{duration} representing the time elapsed since midnight
into a ``broken down'' time of day such as
$hours$:$minutes$:$seconds$.
The \tcode{Duration} template parameter dictates
the precision to which the time is broken down.
\begin{note}
This can vary from a coarse precision of hours
to a very fine precision of nanoseconds.
\end{note}
A \tcode{time_of_day} object also tracks
whether it should be output
as a 12-hour time format or a 24-hour time format.

\pnum
The primary \tcode{time_of_day} template is not defined.
Four specializations are provided to handle four different
levels of precision.

\pnum
Each specialization of \tcode{time_of_day} is a trivially copyable
and standard-layout class type.

\rSec3[time.tod.hours]{Hours precision}
\indexlibrary{\idxcode{time_of_day<hours>}}

\begin{codeblock}
namespace std::chrono {
  template<>
  class time_of_day<hours> {
  public:
    using precision = chrono::hours;

    time_of_day() = default;
    explicit constexpr time_of_day(chrono::hours since_midnight) noexcept;

    constexpr chrono::hours hours() const noexcept;

    explicit constexpr operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    constexpr void make24() noexcept;
    constexpr void make12() noexcept;
  };
}
\end{codeblock}

\pnum
\begin{note}
This specialization handles hours since midnight.
\end{note}

\indexlibrary{\idxcode{time_of_day<hours>}!constructor}%
\begin{itemdecl}
explicit constexpr time_of_day(chrono::hours since_midnight) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{time_of_day} in 24-hour format
corresponding to \tcode{since_midnight} hours after 00:00:00.

\pnum
\postconditions
\tcode{hours()} returns the integral number of hours \tcode{since_midnight} is after 00:00:00.
\end{itemdescr}

\indexlibrarymember{hours}{time_of_day<hours>}%
\begin{itemdecl}
constexpr chrono::hours hours() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored hour of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator precision}{time_of_day<hours>}%
\begin{itemdecl}
explicit constexpr operator precision() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The number of hours since midnight.
\end{itemdescr}

\indexlibrarymember{to_duration}{time_of_day<hours>}%
\begin{itemdecl}
constexpr precision to_duration() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{precision\{*this\}}.
\end{itemdescr}

\indexlibrarymember{make24}{time_of_day<hours>}%
\begin{itemdecl}
constexpr void make24() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 12-hour time,
converts to a 24-hour time.
Otherwise, no effects.
\end{itemdescr}

\indexlibrarymember{make12}{time_of_day<hours>}%
\begin{itemdecl}
constexpr void make12() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 24-hour time,
converts to a 12-hour time.
Otherwise, no effects.
\end{itemdescr}

\rSec3[time.tod.minutes]{Minutes precision}
\indexlibrary{\idxcode{time_of_day<minutes>}}

\begin{codeblock}
namespace std::chrono {
  template<>
  class time_of_day<minutes> {
  public:
    using precision = chrono::minutes;

    time_of_day() = default;
    explicit constexpr time_of_day(chrono::minutes since_midnight) noexcept;

    constexpr chrono::hours    hours()   const noexcept;
    constexpr chrono::minutes  minutes() const noexcept;

    explicit constexpr operator precision()    const noexcept;
    constexpr          precision to_duration() const noexcept;

    constexpr void make24() noexcept;
    constexpr void make12() noexcept;
  };
}
\end{codeblock}

\pnum
\begin{note}
This specialization handles hours and minutes since midnight.
\end{note}

\indexlibrary{\idxcode{time_of_day<minutes>}!constructor}%
\begin{itemdecl}
explicit constexpr time_of_day(minutes since_midnight) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{time_of_day}
in 24-hour format
corresponding to \tcode{since_midnight} minutes after 00:00:00.

\pnum
\postconditions
\tcode{hours()} returns the integral number of hours
\tcode{since_midnight} is after 00:00:00.
\tcode{minutes()} returns the integral number of minutes
\tcode{since_midnight} is after \tcode{(\textrm{00:00:00} + hours())}.
\end{itemdescr}

\indexlibrarymember{hours}{time_of_day<minutes>}%
\begin{itemdecl}
constexpr chrono::hours hours() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored hour of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{minutes}{time_of_day<minutes>}%
\begin{itemdecl}
constexpr chrono::minutes minutes() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored minute of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator precision}{time_of_day<minutes>}%
\begin{itemdecl}
explicit constexpr operator precision() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The number of minutes since midnight.
\end{itemdescr}

\indexlibrarymember{to_duration}{time_of_day<minutes>}%
\begin{itemdecl}
constexpr precision to_duration() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{precision\{*this\}}.
\end{itemdescr}

\indexlibrarymember{make24}{time_of_day<minutes>}%
\begin{itemdecl}
constexpr void make24() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 12-hour time,
converts to a 24-hour time.
Otherwise, no effects.
\end{itemdescr}

\indexlibrarymember{make12}{time_of_day<minutes>}%
\begin{itemdecl}
constexpr void make12() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 24-hour time,
converts to a 12-hour time.
Otherwise, no effects.
\end{itemdescr}

\rSec3[time.tod.seconds]{Seconds precision}
\indexlibrary{\idxcode{time_of_day<seconds>}}

\begin{codeblock}
namespace std::chrono {
  template<>
  class time_of_day<seconds> {
  public:
    using precision = chrono::seconds;

    time_of_day() = default;
    explicit constexpr time_of_day(chrono::seconds since_midnight) noexcept;

    constexpr chrono::hours   hours()   const noexcept;
    constexpr chrono::minutes minutes() const noexcept;
    constexpr chrono::seconds seconds() const noexcept;

    explicit constexpr operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    constexpr void make24() noexcept;
    constexpr void make12() noexcept;
  };
}
\end{codeblock}

\pnum
\begin{note}
This specialization handles hours, minutes, and seconds since midnight.
\end{note}

\indexlibrary{\idxcode{time_of_day<seconds>}!constructor}%
\begin{itemdecl}
explicit constexpr time_of_day(seconds since_midnight) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{time_of_day}
in 24-hour format
corresponding to \tcode{since_midnight} seconds after 00:00:00.

\pnum
\postconditions
\tcode{hours()} returns the integral number of hours
\tcode{since_midnight} is after 00:00:00.
\tcode{minutes()} returns the integral number of minutes
\tcode{since_midnight} is after \tcode{(\textrm{00:00:00} + hours())}.
\tcode{seconds()} returns the integral number of seconds
\tcode{since_midnight} is after \tcode{(\textrm{00:00:00} + hours() + minutes())}.
\end{itemdescr}

\indexlibrarymember{hours}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr chrono::hours hours() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored hour of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{minutes}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr chrono::minutes minutes() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored minute of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{seconds}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr chrono::seconds seconds() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored second of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator precision}{time_of_day<seconds>}%
\begin{itemdecl}
explicit constexpr operator precision() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The number of seconds since midnight.
\end{itemdescr}

\indexlibrarymember{to_duration}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr precision to_duration() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{precision\{*this\}}.
\end{itemdescr}

\indexlibrarymember{make24}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr void make24() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 12-hour time,
converts to a 24-hour time.
Otherwise, no effects.
\end{itemdescr}

\indexlibrarymember{make12}{time_of_day<seconds>}%
\begin{itemdecl}
constexpr void make12() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 24-hour time,
converts to a 12-hour time.
Otherwise, no effects.
\end{itemdescr}

\rSec3[time.tod.subsecond]{Sub-second precision}
\indexlibrary{\idxcode{time_of_day<\placeholder{sub-second duration}>}}

\begin{codeblock}
namespace std::chrono {
  template<class Rep, class Period>
  class time_of_day<duration<Rep, Period>> {
  public:
    using precision = duration<Rep, Period>;

    time_of_day() = default;
    explicit constexpr time_of_day(precision since_midnight) noexcept;

    constexpr chrono::hours     hours()      const noexcept;
    constexpr chrono::minutes   minutes()    const noexcept;
    constexpr chrono::seconds   seconds()    const noexcept;
    constexpr precision subseconds() const noexcept;

    explicit constexpr operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    constexpr void make24() noexcept;
    constexpr void make12() noexcept;
  };
}
\end{codeblock}

\pnum
This specialization shall not exist unless
\tcode{treat_as_floating_point_v<Rep>} is \tcode{false}
and
\tcode{duration<Rep, Period>} is not convertible to \tcode{seconds}.
\begin{note}
This specialization handles hours, minutes, seconds, and fractional seconds since midnight.
Typical uses are with \tcode{milliseconds}, \tcode{microseconds} and \tcode{nanoseconds}.
\end{note}

\indexlibrary{\idxcode{time_of_day<\placeholder{sub-second duration}>}!constructor}%
\begin{itemdecl}
explicit constexpr time_of_day(precision since_midnight) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{time_of_day}
in 24-hour format
corresponding to \tcode{since_midnight} fractional seconds after 00:00:00.

\pnum
\postconditions
\tcode{hours()} returns the integral number of hours
\tcode{since_midnight} is after 00:00:00.
\tcode{minutes()} returns the integral number of minutes
\tcode{since_midnight }is after \tcode{(\textrm{00:00:00} + hours())}.
\tcode{seconds()} returns the integral number of seconds
\tcode{since_midnight }is after \tcode{(\textrm{00:00:00} + hours() + minutes())}.
\tcode{subseconds()} returns the integral number of fractional seconds
\tcode{since_midnight} is after \tcode{(\textrm{00:00:00} + hours() + minutes() + seconds())}.
\end{itemdescr}

\indexlibrarymember{hours}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr chrono::hours hours() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored hour of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{minutes}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr chrono::minutes minutes() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored minute of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{seconds}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr chrono::seconds seconds() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored second of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{subseconds}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr duration<Rep, Period> subseconds() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The stored subsecond of \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator precision}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
explicit constexpr operator precision() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The number of subseconds since midnight.
\end{itemdescr}

\indexlibrarymember{to_duration}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr precision to_duration() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{precision\{*this\}}.
\end{itemdescr}

\indexlibrarymember{make24}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr void make24() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 12-hour time,
converts to a 24-hour time.
Otherwise, no effects.
\end{itemdescr}

\indexlibrarymember{make12}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
constexpr void make12() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} is a 24-hour time,
converts to a 12-hour time.
Otherwise, no effects.
\end{itemdescr}

\rSec3[time.tod.io]{Formatted output}

\indexlibrarymember{operator<<}{time_of_day<hours>}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const time_of_day<hours>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{t} is a 24-hour time,
outputs to \tcode{os} according to the format
\tcode{"\%H00"}\iref{time.format}.
Otherwise
outputs to \tcode{os} according to the format
\tcode{"\%I\%p"}\iref{time.format}.

\pnum
\returns \tcode{os}.

\pnum
\begin{example}
\begin{codeblock}
for (hours h : {1h, 18h}) {
  time_of_day<hours> tod(h);
  os << tod << '\n';
  tod.make12();
  os << tod << '\n';
}
\end{codeblock}

Produces the output:

\begin{codeblock}
0100
1am
1800
6pm
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{time_of_day<minutes>}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const time_of_day<minutes>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{t} is a 24-hour time,
outputs to \tcode{os} according to the format
\tcode{"\%H:\%M"}\iref{time.format}.
Otherwise
outputs to \tcode{os} according to the format
\tcode{"\%I:\%M\%p"}\iref{time.format}.

\pnum
\returns \tcode{os}.

\begin{example}
\begin{codeblock}
for (minutes m : {68min, 1095min}) {
  time_of_day<minutes> tod(m);
  os << tod << '\n';
  tod.make12();
  os << tod << '\n';
}
\end{codeblock}

Produces the output:

\begin{codeblock}
01:08
1:08am
18:15
6:15pm
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{time_of_day<seconds>}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const time_of_day<seconds>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{t} is a 24-hour time,
outputs to \tcode{os} according to the format
\tcode{"\%T"}\iref{time.format}.
Otherwise
outputs to \tcode{os} according to the format
\tcode{"\%I:\%M:\%S\%p"}\iref{time.format}.

\pnum
\returns \tcode{os}.

\begin{example}
\begin{codeblock}
for (seconds s : {4083s, 65745s}) {
  time_of_day<seconds> tod(s);
  os << tod << '\n';
  tod.make12();
  os << tod << '\n';
}
\end{codeblock}

Produces the output:

\begin{codeblock}
01:08:03
1:08:03am
18:15:45
6:15:45pm
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{operator<<}{time_of_day<\placeholder{sub-second duration}>}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const time_of_day<duration<Rep, Period>>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{t} is a 24-hour time,
outputs to \tcode{os} according to the format
\tcode{"\%T"}\iref{time.format}.
Otherwise
outputs to \tcode{os} according to the format
\tcode{"\%I:\%M:\%S\%p"}\iref{time.format}.

\pnum
\returns \tcode{os}.

\begin{example}
\begin{codeblock}
for (milliseconds ms : {4083007ms, 65745123ms}) {
  time_of_day<seconds> tod(ms);
  os << tod << '\n';
  tod.make12();
  os << tod << '\n';
}
\end{codeblock}

Produces the output:

\begin{codeblock}
01:08:03.007
1:08:03.007am
18:15:45.123
6:15:45.123pm
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec2[time.zone]{Time zones}

\rSec3[time.zone.general]{In general}

\pnum
\ref{time.zone} describes an interface for accessing
the IANA Time Zone database described in RFC 6557,
that interoperates with \tcode{sys_time} and \tcode{local_time}.
This interface provides time zone support to
both the civil calendar types\iref{time.cal}
and to user-defined calendars.

\rSec3[time.zone.db]{Time zone database}

\rSec4[time.zone.db.tzdb]{Class \tcode{tzdb}}
\indexlibrary{\idxcode{tzdb}}

\begin{codeblock}
namespace std::chrono {
  struct tzdb {
    string            version;
    vector<time_zone> zones;
    vector<link>      links;
    vector<leap>      leaps;

    const time_zone* locate_zone(string_view tz_name) const;
    const time_zone* current_zone() const;
  };
}
\end{codeblock}

\pnum
Each \tcode{vector} in a \tcode{tzdb} object
is sorted to enable fast lookup.

\indexlibrarymember{locate_zone}{tzdb}%
\begin{itemdecl}
const time_zone* locate_zone(string_view tz_name) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If a \tcode{time_zone} is found
for which \tcode{name() == tz_name},
returns a pointer to that \tcode{time_zone}.
Otherwise
if a \tcode{link} is found
for which \tcode{tz_name == link.name()},
then a pointer is returned
to the \tcode{time_zone} for which \tcode{zone.name() == link.target()}.
\begin{note}
A \tcode{link} specifies an alternative name for a \tcode{time_zone}.
\end{note}

\throws
If a \tcode{const time_zone*} cannot be found
as described in the \returns clause,
throws a \tcode{runtime_error}.
\begin{note}
On non-exceptional return, the return value is always a pointer to a valid \tcode{time_zone}.
\end{note}
\end{itemdescr}

\indexlibrarymember{current_zone}{tzdb}%
\begin{itemdecl}
const time_zone* current_zone() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the time zone which the computer has set as its local time zone.
\end{itemdescr}

\rSec4[time.zone.db.list]{Class \tcode{tzdb_list}}
\indexlibrary{\idxcode{tzdb_list}}

\begin{codeblock}
namespace std::chrono {
  class tzdb_list {
  public:
    tzdb_list(const tzdb_list&) = delete;
    tzdb_list& operator=(const tzdb_list&) = delete;

    // unspecified additional constructors

    class const_iterator;

    const tzdb& front() const noexcept;

    const_iterator erase_after(const_iterator p);

    const_iterator begin() const noexcept;
    const_iterator end()   const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cend()   const noexcept;
  };
}
\end{codeblock}

\pnum
The \tcode{tzdb_list} database is a singleton;
the unique object of type \tcode{tzdb_list} can be
accessed via the \tcode{get_tzdb_list()} function.
\begin{note}
This access is only needed for those applications
that need to have long uptimes and
have a need to update the time zone database while running.
Other applications can implicitly access the \tcode{front()} of this list
via the read-only namespace scope functions
\tcode{get_tzdb()},
\tcode{locate_zone()}, and
\tcode{current_zone()}.
\end{note}
The \tcode{tzdb_list} object contains a list of \tcode{tzdb} objects.

\pnum
\tcode{tzdb_list::const_iterator} is a constant iterator
which meets the forward iterator requirements
and has a value type of \tcode{tzdb}.

\indexlibrarymember{front}{tzdb_list}%
\begin{itemdecl}
const tzdb& front() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to the first \tcode{tzdb} in the container.

\pnum
\remarks
This operation is thread-safe with respect to \tcode{reload_tzdb()}.
\begin{note}
\tcode{reload_tzdb()} pushes a new \tcode{tzdb}
onto the front of this container.
\end{note}
\end{itemdescr}

\indexlibrarymember{erase_after}{tzdb_list}%
\begin{itemdecl}
const_iterator erase_after(const_iterator p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The iterator following \tcode{p} is dereferenceable.

\pnum
\effects
Erases the \tcode{tzdb} referred to by the iterator following \tcode{p}.

\pnum
\returns
An iterator pointing to the element following the one that was erased,
or \tcode{end()} if no such element exists.

\pnum
\remarks
No pointers, references, or iterators are invalidated
except those referring to the erased \tcode{tzdb}.
\begin{note}
It is not possible to erase the \tcode{tzdb}
referred to by \tcode{begin()}.
\end{note}

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{begin}{tzdb_list}%
\begin{itemdecl}
const_iterator begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referring to the first \tcode{tzdb} in the container.
\end{itemdescr}

\indexlibrarymember{end}{tzdb_list}%
\begin{itemdecl}
const_iterator end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator referring to the position one past the last \tcode{tzdb} in the container.
\end{itemdescr}

\indexlibrarymember{cbegin}{tzdb_list}%
\begin{itemdecl}
const_iterator cbegin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{begin()}.
\end{itemdescr}

\indexlibrarymember{cend}{tzdb_list}%
\begin{itemdecl}
const_iterator cend() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{end()}.
\end{itemdescr}

\rSec4[time.zone.db.access]{Time zone database access}

\indexlibrary{\idxcode{get_tzdb_list}}%
\begin{itemdecl}
tzdb_list& get_tzdb_list();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If this is the first access to the time zone database,
initializes the database.
If this call initializes the database,
the resulting database will be a \tcode{tzdb_list}
holding a single initialized \tcode{tzdb}.

\pnum
\returns
A reference to the database.

\pnum
\remarks
It is safe to call this function from multiple threads at one time.

\pnum
\throws
\tcode{runtime_error} if for any reason
a reference cannot be returned to a valid \tcode{tzdb_list}
containing one or more valid \tcode{tzdb}s.
\end{itemdescr}

\indexlibrary{\idxcode{get_tzdb}}%
\begin{itemdecl}
const tzdb& get_tzdb();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get_tzdb_list().front()}.
\end{itemdescr}

\indexlibrary{\idxcode{locate_zone}}%
\begin{itemdecl}
const time_zone* locate_zone(string_view tz_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get_tzdb().locate_zone(tz_name)}.

\pnum
\begin{note}
The time zone database will be initialized
if this is the first reference to the database.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{current_zone}}%
\begin{itemdecl}
const time_zone* current_zone();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get_tzdb().current_zone()}.
\end{itemdescr}

\rSec4[time.zone.db.remote]{Remote time zone database support}

\pnum
The local time zone database
is that supplied by the implementation
when the program first accesses the database,
for example via \tcode{current_zone()}.
While the program is running,
the implementation may choose to update the time zone database.
This update shall not impact the program in any way
unless the program calls the functions in this section.
This potentially updated time zone database
is referred to as the \defn{remote time zone database}.

\indexlibrary{\idxcode{reload_tzdb}}%
\begin{itemdecl}
const tzdb& reload_tzdb();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
This function first checks
the version of the remote time zone database.
If the versions of the local and remote databases are the same,
there are no effects.
Otherwise the remote database is pushed
to the front of the \tcode{tzdb_list}
accessed by \tcode{get_tzdb_list()}.

\pnum
\returns \tcode{get_tzdb_list().front()}.

\pnum
\remarks
No pointers, references, or iterators are invalidated.

\pnum
\remarks
This function is thread-safe with respect to
\tcode{get_tzdb_list().front()} and \tcode{get_tzdb_list().erase_after()}.

\pnum
\throws
\tcode{runtime_error} if for any reason
a reference cannot be returned to a valid \tcode{tzdb}.
\end{itemdescr}

\indexlibrary{\idxcode{remote_version}}%
\begin{itemdecl}
string remote_version();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The latest remote database version.

\begin{note}
This can be compared with \tcode{get_tzdb().version}
to discover if the local and remote databases are equivalent.
\end{note}
\end{itemdescr}

\rSec3[time.zone.exception]{Exception classes}

\rSec4[time.zone.exception.nonexist]{Class \tcode{nonexistent_local_time}}
\indexlibrary{\idxcode{nonexistent_local_time}}

\begin{codeblock}
namespace std::chrono {
  class nonexistent_local_time : public runtime_error {
  public:
    template<class Duration>
      nonexistent_local_time(const local_time<Duration>& tp, const local_info& i);
  };
}
\end{codeblock}

\pnum
\tcode{nonexistent_local_time} is thrown when
an attempt is made
to convert a non-existent \tcode{local_time} to a \tcode{sys_time}
without specifying \tcode{choose::earliest} or \tcode{choose::latest}.

\indexlibrary{\idxcode{nonexistent_local_time}!constructor}%
\begin{itemdecl}
template<class Duration>
  nonexistent_local_time(const local_time<Duration>& tp, const local_info& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{i.result == local_info::nonexistent}.

\pnum
\effects
Constructs a \tcode{nonexistent_local_time}
by initializing the base class with a sequence of \tcode{char}
equivalent to that produced by \tcode{os.str()}
initialized as shown below:

\begin{codeblock}
ostringstream os;
os << tp << " is in a gap between\n"
   << local_seconds{i.first.end.time_since_epoch()} + i.first.offset << ' '
   << i.first.abbrev << " and\n"
   << local_seconds{i.second.begin.time_since_epoch()} + i.second.offset << ' '
   << i.second.abbrev
   << " which are both equivalent to\n"
   << i.first.end << " UTC";
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
#include <chrono>
#include <iostream>

int main() {
  using namespace std::chrono;
  try {
    auto zt = zoned_time{"America/New_York",
                         local_days{Sunday[2]/March/2016} + 2h + 30min};
  } catch (const nonexistent_local_time& e) {
    std::cout << e.what() << '\n';
  }
}
\end{codeblock}

Produces the output:

\begin{codeblock}
2016-03-13 02:30:00 is in a gap between
2016-03-13 02:00:00 EST and
2016-03-13 03:00:00 EDT which are both equivalent to
2016-03-13 07:00:00 UTC
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec4[time.zone.exception.ambig]{Class \tcode{ambiguous_local_time}}
\indexlibrary{\idxcode{ambiguous_local_time}}

\begin{codeblock}
namespace std::chrono {
  class ambiguous_local_time : public runtime_error {
  public:
    template<class Duration>
      ambiguous_local_time(const local_time<Duration>& tp, const local_info& i);
  };
}
\end{codeblock}

\pnum
\tcode{ambiguous_local_time} is thrown when
an attempt is made
to convert an ambiguous \tcode{local_time} to a \tcode{sys_time}
without specifying \tcode{choose::earliest} or \tcode{choose::latest}.

\indexlibrary{\idxcode{ambiguous_local_time}!constructor}%
\begin{itemdecl}
template<class Duration>
  ambiguous_local_time(const local_time<Duration>& tp, const local_info& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{i.result == local_info::ambiguous}.

\pnum
\effects
Constructs an \tcode{ambiguous_local_time}
by initializing the base class with a sequence of \tcode{char}
equivalent to that produced by \tcode{os.str()}
initialized as shown below:

\begin{codeblock}
ostringstream os;
os << tp << " is ambiguous.  It could be\n"
   << tp << ' ' << i.first.abbrev << " == "
   << tp - i.first.offset << " UTC or\n"
   << tp << ' ' << i.second.abbrev  << " == "
   << tp - i.second.offset  << " UTC";
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
#include <chrono>
#include <iostream>

int main() {
  using namespace std::chrono;
  try {
    auto zt = zoned_time{"America/New_York",
                         local_days{Sunday[1]/November/2016} + 1h + 30min};
  } catch (const ambiguous_local_time& e) {
    std::cout << e.what() << '\n';
  }
}
\end{codeblock}

Produces the output:

\begin{codeblock}
2016-11-06 01:30:00 is ambiguous.  It could be
2016-11-06 01:30:00 EDT == 2016-11-06 05:30:00 UTC or
2016-11-06 01:30:00 EST == 2016-11-06 06:30:00 UTC
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec3[time.zone.info]{Information classes}

\rSec4[time.zone.info.sys]{Class \tcode{sys_info}}
\indexlibrary{\idxcode{sys_info}}

\begin{codeblock}
namespace std::chrono {
  struct sys_info {
    sys_seconds   begin;
    sys_seconds   end;
    seconds       offset;
    minutes       save;
    string        abbrev;
  };
}
\end{codeblock}

\pnum
A \tcode{sys_info} structure can be obtained
from the combination of a \tcode{time_zone} and
either a \tcode{sys_time} or \tcode{local_time}.
It can also be obtained from a \tcode{zoned_time},
which is effectively a pair of a \tcode{time_zone} and \tcode{sys_time}.

\pnum
\begin{note}
This type provides a low-level interface to time zone information.
Typical conversions from \tcode{sys_time} to \tcode{local_time}
will use this structure implicitly, not explicitly.
\end{note}

\pnum
\indexlibrarymember{begin}{sys_info}%
\indexlibrarymember{end}{sys_info}%
The \tcode{begin} and \tcode{end} data members indicate that,
for the associated \tcode{time_zone} and \tcode{time_point},
the \tcode{offset} and \tcode{abbrev} are in effect in the range \range{begin}{end}.
This information can be used to efficiently iterate the transitions of a \tcode{time_zone}.

\pnum
\indexlibrarymember{offset}{sys_info}%
The \tcode{offset} data member indicates
the UTC offset in effect
for the associated \tcode{time_zone} and \tcode{time_point}.
The relationship between \tcode{local_time} and \tcode{sys_time} is:

\begin{codeblock}
offset = local_time - sys_time
\end{codeblock}

\pnum
\indexlibrarymember{save}{sys_info}%
The \tcode{save} data member is extra information not normally needed
for conversion between \tcode{local_time} and \tcode{sys_time}.
If \tcode{save != 0min}, this \tcode{sys_info} is said to be on ``daylight saving'' time,
and \tcode{offset - save} suggests what offset this \tcode{time_zone} might use
if it were off daylight saving time.
However, this information should not be taken as authoritative.
The only sure way to get such information
is to query the \tcode{time_zone} with a \tcode{time_point}
that returns a \tcode{sys_info} where \tcode{save == 0min}.
There is no guarantee what \tcode{time_point} might return such a \tcode{sys_info}
except that it is guaranteed not to be in the range \range{begin}{end}
(if \tcode{save != 0min} for this \tcode{sys_info}).

\pnum
\indexlibrarymember{abbrev}{sys_info}%
The \tcode{abbrev} data member indicates
the current abbreviation used for the associated \tcode{time_zone} and \tcode{time_point}.
Abbreviations are not unique among the \tcode{time_zones},
and so one cannot reliably map abbreviations back to a \tcode{time_zone} and UTC offset.

\indexlibrarymember{operator<<}{sys_info}
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const sys_info& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams out the \tcode{sys_info} object \tcode{r} in an unspecified format.
\end{itemdescr}

\rSec4[time.zone.info.local]{Class \tcode{local_info}}
\indexlibrary{\idxcode{local_info}}

\indexlibrarymember{unique}{local_info}%
\indexlibrarymember{nonexistent}{local_info}%
\indexlibrarymember{ambiguous}{local_info}%
\indexlibrarymember{result}{local_info}%
\indexlibrarymember{first}{local_info}%
\indexlibrarymember{second}{local_info}%
\begin{codeblock}
namespace std::chrono {
  struct local_info {
    static constexpr int unique      = 0;
    static constexpr int nonexistent = 1;
    static constexpr int ambiguous   = 2;

    int result;
    sys_info first;
    sys_info second;
  };
}
\end{codeblock}

\pnum
\begin{note}
This type provides a low-level interface to time zone information.
Typical conversions from \tcode{local_time} to \tcode{sys_time}
will use this structure implicitly, not explicitly.
\end{note}

\pnum
Describes the result of converting a \tcode{local_time} to a \tcode{sys_time}
as follows:
\begin{itemize}
\item
When a \tcode{local_time} to \tcode{sys_time} conversion is unique,
\tcode{result == unique},
\tcode{first} will be filled out with the correct \tcode{sys_info},
and
\tcode{second} will be zero-initialized.

\item
If the conversion stems from a nonexistent \tcode{local_time}
then \tcode{result == nonexistent},
\tcode{first} will be filled out with the \tcode{sys_info}
that ends just prior to the \tcode{local_time},
and
\tcode{second} will be filled out with the \tcode{sys_info}
that begins just after the \tcode{local_time}.

\item
If the conversion stems from an ambiguous \tcode{local_time},
then \tcode{result == ambiguous},
\tcode{first} will be filled out with the \tcode{sys_info}
that ends just after the \tcode{local_time},
and
\tcode{second} will be filled out with the \tcode{sys_info}
that starts just before the \tcode{local_time}.
\end{itemize}

\indexlibrarymember{operator<<}{local_info}%
\begin{itemdecl}
template<class charT, class traits>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const local_info& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
Streams out the \tcode{local_info} object \tcode{r} in an unspecified format.
\end{itemdescr}

\rSec3[time.zone.timezone]{Class \tcode{time_zone}}

\rSec4[time.zone.overview]{Overview}
\indexlibrary{\idxcode{time_zone}}

\begin{codeblock}
namespace std::chrono {
  class time_zone {
  public:
    time_zone(time_zone&&) = default;
    time_zone& operator=(time_zone&&) = default;

    // unspecified additional constructors

    string_view name() const noexcept;

    template<class Duration> sys_info   get_info(const sys_time<Duration>& st)   const;
    template<class Duration> local_info get_info(const local_time<Duration>& tp) const;

    template<class Duration>
      sys_time<common_type_t<Duration, seconds>>
        to_sys(const local_time<Duration>& tp) const;

    template<class Duration>
      sys_time<common_type_t<Duration, seconds>>
        to_sys(const local_time<Duration>& tp, choose z) const;

    template<class Duration>
      local_time<common_type_t<Duration, seconds>>
        to_local(const sys_time<Duration>& tp) const;
  };
}
\end{codeblock}

\pnum
A \tcode{time_zone} represents all time zone transitions
for a specific geographic area.
\tcode{time_zone} construction is unspecified,
and performed as part of database initialization.
\begin{note}
\tcode{const time_zone} objects can be accessed
via functions such as \tcode{locate_zone}.
\end{note}

\rSec4[time.zone.members]{Member functions}

\indexlibrarymember{name}{time_zone}%
\begin{itemdecl}
string_view name() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The name of the \tcode{time_zone}.

\pnum
\begin{example}
\tcode{"America/New_York"}.
\end{example}
\end{itemdescr}

\indexlibrarymember{get_info}{time_zone}%
\begin{itemdecl}
template<class Duration>
  sys_info get_info(const sys_time<Duration>& st) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{sys_info} \tcode{i} for which
\tcode{st} is in the range \range{i.begin}{i.end}.
\end{itemdescr}

\indexlibrarymember{get_info}{time_zone}%
\begin{itemdecl}
template<class Duration>
  local_info get_info(const local_time<Duration>& tp) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{local_info} for \tcode{tp}.
\end{itemdescr}

\indexlibrarymember{to_sys}{time_zone}%
\begin{itemdecl}
template<class Duration>
  sys_time<common_type_t<Duration, seconds>>
    to_sys(const local_time<Duration>& tp) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{sys_time} that is at least as fine as \tcode{seconds},
and will be finer if the argument \tcode{tp} has finer precision.
This \tcode{sys_time} is the UTC equivalent of \tcode{tp}
according to the rules of this \tcode{time_zone}.

\pnum
\throws
If the conversion from \tcode{tp} to a \tcode{sys_time} is ambiguous,
throws \tcode{ambiguous_local_time}.
If the \tcode{tp} represents a non-existent time between two UTC \tcode{time_points},
throws \tcode{nonexistent_local_time}.
\end{itemdescr}

\indexlibrarymember{to_sys}{time_zone}%
\begin{itemdecl}
template<class Duration>
  sys_time<common_type_t<Duration, seconds>>
    to_sys(const local_time<Duration>& tp, choose z) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A \tcode{sys_time} that is at least as fine as \tcode{seconds},
and will be finer if the argument \tcode{tp} has finer precision.
This \tcode{sys_time} is the UTC equivalent of \tcode{tp}
according to the rules of this \tcode{time_zone}.
If the conversion from \tcode{tp} to a \tcode{sys_time} is ambiguous,
returns the earlier \tcode{sys_time} if \tcode{z == choose::earliest}, and
returns the later \tcode{sys_time} if \tcode{z == choose::latest}.
If the \tcode{tp} represents a non-existent time between two UTC \tcode{time_points},
then the two UTC \tcode{time_points} will be the same,
and that UTC \tcode{time_point} will be returned.
\end{itemdescr}

\indexlibrarymember{to_local}{time_zone}%
\begin{itemdecl}
template<class Duration>
  local_time<common_type_t<Duration, seconds>>
    to_local(const sys_time<Duration>& tp) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The \tcode{local_time} associated with \tcode{tp} and this \tcode{time_zone}.
\end{itemdescr}

\rSec4[time.zone.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{time_zone}%
\begin{itemdecl}
bool operator==(const time_zone& x, const time_zone& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.name() == y.name()}.
\end{itemdescr}

\indexlibrarymember{operator<}{time_zone}%
\begin{itemdecl}
bool operator<(const time_zone& x, const time_zone& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.name() < y.name()}.
\end{itemdescr}

\rSec3[time.zone.zonedtraits]{Class template \tcode{zoned_traits}}
\indexlibrary{\idxcode{zoned_traits}}

\begin{codeblock}
namespace std::chrono {
  template<class T> struct zoned_traits {};
}
\end{codeblock}

\pnum
\tcode{zoned_traits} provides a means for customizing
the behavior of \tcode{zoned_time<Duration, TimeZonePtr>}
for the \tcode{zoned_time} default constructor,
and constructors taking \tcode{string_view}.
A specialization for \tcode{const time_zone*} is provided by the implementation:

\begin{codeblock}
namespace std::chrono {
  template<> struct zoned_traits<const time_zone*> {
    static const time_zone* default_zone();
    static const time_zone* locate_zone(string_view name);
  };
}
\end{codeblock}

\indexlibrarymember{default_zone}{zoned_traits<const time_zone*>}%
\begin{itemdecl}
static const time_zone* default_zone();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{std::chrono::locate_zone("UTC")}.
\end{itemdescr}

\indexlibrarymember{locate_zone}{zoned_traits<const time_zone*>}%
\begin{itemdecl}
static const time_zone* locate_zone(string_view name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{std::chrono::locate_zone(name)}.
\end{itemdescr}

\rSec3[time.zone.zonedtime]{Class template \tcode{zoned_time}}

\rSec4[time.zone.zonedtime.overview]{Overview}
\indexlibrary{\idxcode{zoned_time}}

\begin{codeblock}
namespace std::chrono {
  template<class Duration, class TimeZonePtr = const time_zone*>
  class zoned_time {
  public:
    using duration = common_type_t<Duration, seconds>;

  private:
    TimeZonePtr        zone_;                   // \expos
    sys_time<duration> tp_;                     // \expos

    using traits = zoned_traits<TimeZonePtr>;   // \expos

  public:
    zoned_time();
    zoned_time(const zoned_time&) = default;
    zoned_time& operator=(const zoned_time&) = default;

    zoned_time(const sys_time<Duration>& st);
    explicit zoned_time(TimeZonePtr z);
    explicit zoned_time(string_view name);

    template<class Duration2>
      zoned_time(const zoned_time<Duration2, TimeZonePtr>& zt) noexcept;

    zoned_time(TimeZonePtr z,    const sys_time<Duration>& st);
    zoned_time(string_view name, const sys_time<Duration>& st);

    zoned_time(TimeZonePtr z,    const local_time<Duration>& tp);
    zoned_time(string_view name, const local_time<Duration>& tp);
    zoned_time(TimeZonePtr z,    const local_time<Duration>& tp, choose c);
    zoned_time(string_view name, const local_time<Duration>& tp, choose c);

    template<class Duration2, class TimeZonePtr2>
      zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& zt);
    template<class Duration2, class TimeZonePtr2>
      zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& zt, choose);

    zoned_time(string_view name, const zoned_time<Duration>& zt);
    zoned_time(string_view name, const zoned_time<Duration>& zt, choose);

    zoned_time& operator=(const sys_time<Duration>& st);
    zoned_time& operator=(const local_time<Duration>& ut);

    operator sys_time<duration>() const;
    explicit operator local_time<duration>() const;

    TimeZonePtr          get_time_zone()  const;
    local_time<duration> get_local_time() const;
    sys_time<duration>   get_sys_time()   const;
    sys_info             get_info()       const;
  };

  zoned_time() -> zoned_time<seconds>;

  template<class Duration>
    zoned_time(sys_time<Duration>)
      -> zoned_time<common_type_t<Duration, seconds>>;

  template<class TimeZonePtr, class Duration>
    zoned_time(TimeZonePtr, sys_time<Duration>)
      -> zoned_time<common_type_t<Duration, seconds>, TimeZonePtr>;

  template<class TimeZonePtr, class Duration>
    zoned_time(TimeZonePtr, local_time<Duration>, choose = choose::earliest)
      -> zoned_time<common_type_t<Duration, seconds>, TimeZonePtr>;

  template<class TimeZonePtr, class Duration>
    zoned_time(TimeZonePtr, zoned_time<Duration>, choose = choose::earliest)
      -> zoned_time<common_type_t<Duration, seconds>, TimeZonePtr>;

  zoned_time(string_view) -> zoned_time<seconds>;

  template<class Duration>
    zoned_time(string_view, sys_time<Duration>)
      -> zoned_time<common_type_t<Duration, seconds>>;

  template<class Duration>
    zoned_time(string_view, local_time<Duration>, choose = choose::earliest)
      -> zoned_time<common_type_t<Duration, seconds>>;

  template<class Duration, class TimeZonePtr, class TimeZonePtr2>
    zoned_time(TimeZonePtr, zoned_time<Duration, TimeZonePtr2>, choose = choose::earliest)
      -> zoned_time<Duration, TimeZonePtr>;
}
\end{codeblock}

\pnum
\tcode{zoned_time} represents a logical pairing of
a \tcode{time_zone} and a \tcode{time_point} with precision \tcode{Duration}.
\tcode{zoned_time<Duration>} maintains the invariant that
it always refers to a valid time zone and
represents a point in time that exists and is not ambiguous
in that time zone.

\pnum
If \tcode{Duration} is not a specialization of \tcode{chrono::duration},
the program is ill-formed.

\rSec4[time.zone.zonedtime.ctor]{Constructors}

\indexlibrary{\idxcode{zoned_time}!constructor|(}%
\begin{itemdecl}
zoned_time();
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{traits::default_zone()} is a well-formed expression.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{traits::default_zone()} and
default constructing \tcode{tp_}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(const sys_time<Duration>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{traits::default_zone()} is a well-formed expression.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{traits::default_zone()} and \tcode{tp_} with \tcode{st}.
\end{itemdescr}

\begin{itemdecl}
explicit zoned_time(TimeZonePtr z);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{z} refers to a time zone.

\pnum
\effects Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{std::move(z)}.
% FIXME: What about tp_?
\end{itemdescr}

\begin{itemdecl}
explicit zoned_time(string_view name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{traits::locate_zone(string_view\{\})} is a well-formed expression and
\tcode{zoned_time} is constructible from the return type of \tcode{traits::locate_zone(string_view\{\})}.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{traits::locate_zone(name)} and
default constructing \tcode{tp_}.
\end{itemdescr}

\begin{itemdecl}
template<class Duration2>
  zoned_time(const zoned_time<Duration2, TimeZonePtr>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Does not participate in overload resolution unless
\tcode{sys_time<Duration2>} is implicitly convertible to \tcode{sys_time<Duration>}.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{y.zone_} and \tcode{tp_} with \tcode{y.tp_}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(TimeZonePtr z, const sys_time<Duration>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{z} refers to a time zone.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{std::move(z)} and \tcode{tp_} with \tcode{st}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(string_view name, const sys_time<Duration>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{zoned_time} is constructible from the return type of \tcode{traits::locate_zone(name)} and \tcode{st}.

\pnum
\effects
Equivalent to construction with \tcode{\{traits::locate_zone(name), st\}}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(TimeZonePtr z, const local_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{z} refers to a time zone.

\pnum
\remarks
This constructor does not participate in overload resolution unless
\begin{codeblock}
decltype(declval<TimeZonePtr&>()->to_sys(local_time<Duration>{}))
\end{codeblock}
is convertible to \tcode{sys_time<duration>}.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{std::move(z)} and \tcode{tp_} with \tcode{zone_->to_sys(tp)}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(string_view name, const local_time<Duration>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{zoned_time} is constructible from the return type of \tcode{traits::locate_zone(name)} and \tcode{tp}.

\pnum
\effects
Equivalent to construction with \tcode{\{traits::locate_zone(name), tp\}}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(TimeZonePtr z, const local_time<Duration>& tp, choose c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{z} refers to a time zone.

\pnum
\remarks
This constructor does not participate in overload resolution unless
\begin{codeblock}
decltype(declval<TimeZonePtr&>()->to_sys(local_time<Duration>{}, choose::earliest))
\end{codeblock}
is convertible to \tcode{sys_time<duration>}.

\pnum
\effects
Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{std::move(z)} and \tcode{tp_} with \tcode{zone_->to_sys(tp, c)}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(string_view name, const local_time<Duration>& tp, choose c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{zoned_time} is constructible from
the return type of \tcode{traits::locate_zone(name)}, \tcode{local_time<Duration>}, and \tcode{choose}.

\pnum
\effects
Equivalent to construction with \tcode{\{traits::locate_zone(name), tp, c\}}.
\end{itemdescr}

\begin{itemdecl}
template<class Duration2, class TimeZonePtr2>
  zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Does not participate in overload resolution unless
\tcode{sys_time<Duration2>} is implicitly convertible to \tcode{sys_time<Duration>}.

\pnum
\requires \tcode{z} refers to a valid time zone.

\pnum
\effects Constructs a \tcode{zoned_time} by
initializing \tcode{zone_} with \tcode{std::move(z)} and \tcode{tp_} with \tcode{y.tp_}.
\end{itemdescr}

\begin{itemdecl}
template<class Duration2, class TimeZonePtr2>
  zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y, choose);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Does not participate in overload resolution unless
\tcode{sys_time<Duration2>} is implicitly convertible to \tcode{sys_time<Duration>}.

\pnum
\requires \tcode{z} refers to a valid time zone.

\pnum
\effects
Equivalent to construction with \tcode{\{z, y\}}.

\pnum
\begin{note}
The \tcode{choose} parameter has no effect.
\end{note}
\end{itemdescr}

\begin{itemdecl}
zoned_time(string_view name, const zoned_time<Duration>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{zoned_time} is constructible from the return type of \tcode{traits::locate_zone(name)} and \tcode{zoned_time}.

\pnum
\effects
Equivalent to construction with \tcode{\{traits::locate_zone(name), y\}}.
\end{itemdescr}

\begin{itemdecl}
zoned_time(string_view name, const zoned_time<Duration>& y, choose c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This constructor does not participate in overload resolution unless
\tcode{zoned_time} is constructible from
the return type of \tcode{traits::locate_zone(name)}, \tcode{zoned_time}, and \tcode{choose}.

\pnum
\effects
Equivalent to construction with \tcode{\{traits::locate_zone(name), y, c\}}.

\pnum
\begin{note}
The \tcode{choose} parameter has no effect.
\end{note}
\end{itemdescr}
\indexlibrary{\idxcode{zoned_time}!constructor|)}%

\rSec4[time.zone.zonedtime.members]{Member functions}

\indexlibrarymember{operator=}{zoned_time}%
\begin{itemdecl}
zoned_time& operator=(const sys_time<Duration>& st);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
After assignment, \tcode{get_sys_time() == st}.
This assignment has no effect on the return value of \tcode{get_time_zone()}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{zoned_time}%
\begin{itemdecl}
zoned_time& operator=(const local_time<Duration>& lt);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
After assignment, \tcode{get_local_time() == lt}.
This assignment has no effect on the return value of \tcode{get_time_zone()}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator sys_time}{zoned_time}%
\begin{itemdecl}
operator sys_time<duration>() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get_sys_time()}.
\end{itemdescr}

\indexlibrarymember{operator local_time}{zoned_time}%
\begin{itemdecl}
explicit operator local_time<duration>() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get_local_time()}.
\end{itemdescr}

\indexlibrarymember{get_time_zone}{zoned_time}%
\begin{itemdecl}
TimeZonePtr get_time_zone() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{zone_}.
\end{itemdescr}

\indexlibrarymember{get_local_time}{zoned_time}%
\begin{itemdecl}
local_time<duration> get_local_time() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{zone_->to_local(tp_)}.
\end{itemdescr}

\indexlibrarymember{get_sys_time}{zoned_time}%
\begin{itemdecl}
sys_time<duration> get_sys_time() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{tp_}.
\end{itemdescr}

\indexlibrarymember{get_info}{zoned_time}%
\begin{itemdecl}
sys_info get_info() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{zone_->get_info(tp_)}.
\end{itemdescr}

\rSec4[time.zone.zonedtime.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{zoned_time}%
\begin{itemdecl}
template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.zone_ == y.zone_ \&\& x.tp_ == y.tp_}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{zoned_time}%
\begin{itemdecl}
template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator!=(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrarymember{operator<<}{zoned_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class TimeZonePtr>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os,
               const zoned_time<Duration, TimeZonePtr>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Streams
the value returned from \tcode{t.get_local_time()}
to \tcode{os}
using the format \tcode{"\%F \%T \%Z"}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\indexlibrarymember{to_stream}{zoned_time}%
\begin{itemdecl}
template<class charT, class traits, class Duration, class TimeZonePtr>
  basic_ostream<charT, traits>&
    to_stream(basic_ostream<charT, traits>& os, const charT* fmt,
              const zoned_time<Duration, TimeZonePtr>& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
First obtains a \tcode{sys_info} via \tcode{tp.get_info()}
which for exposition purposes will be referred to as \tcode{info}.
Then calls \tcode{to_stream(os, fmt, tp.get_local_time(), \&info.abbrev, \&info.offset)}.

\pnum
\returns \tcode{os}.
\end{itemdescr}

\rSec3[time.zone.leap]{Class \tcode{leap}}

\rSec4[time.zone.leap.overview]{Overview}
\indexlibrary{\idxcode{leap}}

\begin{codeblock}
namespace std::chrono {
  class leap {
  public:
    leap(const leap&)            = default;
    leap& operator=(const leap&) = default;

    // unspecified additional constructors

    constexpr sys_seconds date() const noexcept;
  };
}
\end{codeblock}

\pnum
Objects of type \tcode{leap} representing
the date of the leap second insertions
are constructed and stored in the time zone database when initialized.

\pnum
\begin{example}
\begin{codeblock}
for (auto& l : get_tzdb().leaps)
  if (l <= 2018y/March/17d)
    cout << l.date() << '\n';
\end{codeblock}

Produces the output:

\begin{codeblock}
1972-07-01 00:00:00
1973-01-01 00:00:00
1974-01-01 00:00:00
1975-01-01 00:00:00
1976-01-01 00:00:00
1977-01-01 00:00:00
1978-01-01 00:00:00
1979-01-01 00:00:00
1980-01-01 00:00:00
1981-07-01 00:00:00
1982-07-01 00:00:00
1983-07-01 00:00:00
1985-07-01 00:00:00
1988-01-01 00:00:00
1990-01-01 00:00:00
1991-01-01 00:00:00
1992-07-01 00:00:00
1993-07-01 00:00:00
1994-07-01 00:00:00
1996-01-01 00:00:00
1997-07-01 00:00:00
1999-01-01 00:00:00
2006-01-01 00:00:00
2009-01-01 00:00:00
2012-07-01 00:00:00
2015-07-01 00:00:00
2017-01-01 00:00:00
\end{codeblock}
\end{example}

\rSec4[time.zone.leap.members]{Member functions}

\indexlibrarymember{date}{leap}%
\begin{itemdecl}
constexpr sys_seconds date() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The date and time at which the leap second was inserted.
\end{itemdescr}

\rSec4[time.zone.leap.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{leap}%
\begin{itemdecl}
constexpr bool operator==(const leap& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.date() == y.date()}.
\end{itemdescr}

\indexlibrarymember{operator<}{leap}%
\begin{itemdecl}
constexpr bool operator<(const leap& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.date() < y.date()}.
\end{itemdescr}

\indexlibrarymember{operator==}{leap}%
\indexlibrarymember{operator==}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator==(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.date() == y}.
\end{itemdescr}

\indexlibrarymember{operator==}{leap}%
\indexlibrarymember{operator==}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator==(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y == x}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{leap}%
\indexlibrarymember{operator"!=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator!=(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{leap}%
\indexlibrarymember{operator"!=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator!=(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrarymember{operator<}{leap}%
\indexlibrarymember{operator<}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator<(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.date() < y}.
\end{itemdescr}

\indexlibrarymember{operator<}{leap}%
\indexlibrarymember{operator<}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator<(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x < y.date()}.
\end{itemdescr}

\indexlibrarymember{operator>}{leap}%
\indexlibrarymember{operator>}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator>(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrarymember{operator>}{leap}%
\indexlibrarymember{operator>}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator>(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrarymember{operator<=}{leap}%
\indexlibrarymember{operator<=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator<=(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrarymember{operator<=}{leap}%
\indexlibrarymember{operator<=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator<=(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{leap}%
\indexlibrarymember{operator>=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator>=(const leap& x, const sys_time<Duration>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{leap}%
\indexlibrarymember{operator>=}{sys_time}%
\begin{itemdecl}
template<class Duration>
  constexpr bool operator>=(const sys_time<Duration>& x, const leap& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec3[time.zone.link]{Class \tcode{link}}

\rSec4[time.zone.link.overview]{Overview}
\indexlibrary{\idxcode{link}}

\begin{codeblock}
namespace std::chrono {
  class link {
  public:
    link(link&&)            = default;
    link& operator=(link&&) = default;

    // unspecified additional constructors

    string_view name()   const noexcept;
    string_view target() const noexcept;
  };
}
\end{codeblock}

\pnum
A \tcode{link} specifies an alternative name for a \tcode{time_zone}.
\tcode{link}s are constructed when the time zone database is initialized.

\rSec4[time.zone.link.members]{Member functions}

\indexlibrarymember{name}{link}%
\begin{itemdecl}
string_view name() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The alternative name for the time zone.
\end{itemdescr}

\indexlibrarymember{target}{link}%
\begin{itemdecl}
string_view target() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The name of the \tcode{time_zone} for which
this \tcode{link} provides an alternative name.
\end{itemdescr}

\rSec4[time.zone.link.nonmembers]{Non-member functions}

\indexlibrarymember{operator==}{link}%
\begin{itemdecl}
bool operator==(const link& x, const link& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.name() == y.name()}.
\end{itemdescr}

\indexlibrarymember{operator<}{link}%
\begin{itemdecl}
bool operator<(const link& x, const link& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.name() < y.name()}.
\end{itemdescr}

\rSec2[time.format]{Formatting}

\pnum
Each \tcode{format} overload specified in this subclause
calls \tcode{to_stream} unqualified,
so as to enable argument dependent lookup\iref{basic.lookup.argdep}.

\indexlibrary{\idxcode{format}|(}%
\begin{itemdecl}
template<class charT, class Streamable>
  basic_string<charT>
    format(const charT* fmt, const Streamable& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
to_stream(declval<basic_ostream<charT>&>(), fmt, s)
\end{codeblock}
is a valid expression.

\pnum
\effects
Constructs a local variable of type
\tcode{basic_ostringstream<charT>}
(named \tcode{os} for exposition purposes).
Executes \tcode{os.exceptions(ios::failbit | ios::badbit)}.
Then calls \tcode{to_stream(os, fmt, s)}.

\pnum
\returns \tcode{os.str()}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class Streamable>
  basic_string<charT>
    format(const locale& loc, const charT* fmt, const Streamable& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
to_stream(declval<basic_ostream<charT>&>(), fmt, s)
\end{codeblock}
is a valid expression.

\pnum
\effects
Constructs a local variable of type
\tcode{basic_ostringstream<charT>}
(named \tcode{os} for exposition purposes).
Executes \tcode{os.exceptions(ios::failbit | ios::badbit)}.
Then calls \tcode{os.imbue(loc)}.
Then calls \tcode{to_stream(os, fmt, s)}.

\pnum
\returns \tcode{os.str()}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
to_stream(declval<basic_ostringstream<charT, traits, Alloc>&>(), fmt.c_str(), s)
\end{codeblock}
is a valid expression.

\pnum
\effects
Constructs a local variable of type
\tcode{basic_ostringstream<charT, traits, Alloc>}
(named \tcode{os} for exposition purposes).
Executes \tcode{os.exceptions(ios::failbit | ios::badbit)}.
Then calls \tcode{to_stream(os, fmt.c_str(), s)}.

\pnum
\returns \tcode{os.str()}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const locale& loc, const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
to_stream(declval<basic_ostringstream<charT, traits, Alloc>&>(), fmt.c_str(), s)
\end{codeblock}
is a valid expression.

\pnum
\effects
Constructs a local variable of type
\tcode{basic_ostringstream<charT, traits, Alloc>}
(named \tcode{os} for exposition purposes).
Then calls \tcode{os.imbue(loc)}.
Executes \tcode{os.exceptions(ios::failbit | ios::badbit)}.
Then calls \tcode{to_stream(os, fmt.c_str(), s)}.

\pnum
\returns \tcode{os.str()}.
\end{itemdescr}

\pnum
The \tcode{format} functions call a \tcode{to_stream} function with
a \tcode{basic_ostream},
a formatting string specifier,
and a \tcode{Streamable} argument.
Each \tcode{to_stream} overload is customized for each \tcode{Streamable} type.
However all \tcode{to_stream} overloads
treat the formatting string specifier
according to the following specification:

\pnum
The \tcode{fmt} string consists of zero or more conversion specifiers
and ordinary multibyte characters.
A conversion specifier consists of
a \tcode{\%} character,
possibly followed by an \tcode{E} or \tcode{O} modifier character (described below),
followed by a character that determines the behavior of the conversion specifier.
All ordinary multibyte characters (excluding the terminating null character)
are streamed unchanged into the \tcode{basic_ostream}.

\pnum
Each conversion specifier is replaced by appropriate characters
as described in Table~\ref{tab:time.format.spec}.
Some of the conversion specifiers
depend on the locale which is imbued to the \tcode{basic_ostream}.
If the \tcode{Streamable} object does not contain
the information the conversion specifier refers to,
the value streamed to the \tcode{basic_ostream} is unspecified.

\pnum
Unless explicitly specified,
\tcode{Streamable} types will not contain time zone abbreviation
and time zone offset information.
If available,
the conversion specifiers \tcode{\%Z} and \tcode{\%z}
will format this information (respectively).
If the information is not available,
and \tcode{\%Z} or \tcode{\%z} are contained in \tcode{fmt},
\tcode{os.setstate(ios_base::failbit)} shall be called.

\begin{LongTable}{Meaning of \tcode{format} conversion specifiers}{tab:time.format.spec}{lx{.8\hsize}}
\\ \topline
\lhdr{Specifier} & \rhdr{Replacement} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Specifier} & \rhdr{Replacement} \\ \capsep
\endhead
\tcode{\%a} &
The locale's abbreviated weekday name.
If the value does not contain a valid weekday,
\tcode{setstate(ios::failbit)} is called.
\\ \rowsep
\tcode{\%A} &
The locale's full weekday name.
If the value does not contain a valid weekday,
\tcode{setstate(ios::failbit)} is called.
\\ \rowsep
\tcode{\%b} &
The locale's abbreviated month name.
If the value does not contain a valid month,
\tcode{setstate(ios::failbit)} is called.
\\ \rowsep
\tcode{\%B} &
The locale's full month name.
If the value does not contain a valid month,
\tcode{setstate(ios::failbit)} is called.
\\ \rowsep
\tcode{\%c} &
The locale's date and time representation.
The modified command \tcode{\%Ec} produces
the locale's alternate date and time representation.
\\ \rowsep
\tcode{\%C} &
The year divided by 100 using floored division.
If the result is a single decimal digit,
it is prefixed with \tcode{0}.
The modified command \tcode{\%EC} produces
the locale's alternative representation of the century.
\\ \rowsep
\tcode{\%d} &
The day of month as a decimal number.
If the result is a single decimal digit,
it is prefixed with \tcode{0}.
The modified command \tcode{\%Od} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%D} &
Equivalent to \tcode{\%m/\%d/\%y}.
\\ \rowsep
\tcode{\%e} &
The day of month as a decimal number.
If the result is a single decimal digit,
it is prefixed with a space.
The modified command \tcode{\%Oe} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%F} &
Equivalent to \tcode{\%Y-\%m-\%d}.
\\ \rowsep
\tcode{\%g} &
The last two decimal digits of the ISO week-based year.
If the result is a single digit it is prefixed by \tcode{0}.
\\ \rowsep
\tcode{\%G} &
The ISO week-based year as a decimal number.
If the result is less than four digits
it is left-padded with \tcode{0} to four digits.
\\ \rowsep
\tcode{\%h} &
Equivalent to \tcode{\%b}.
\\ \rowsep
\tcode{\%H} &
The hour (24-hour clock) as a decimal number.
If the result is a single digit,
it is prefixed with \tcode{0}.
The modified command \tcode{\%OH} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%I} &
The hour (12-hour clock) as a decimal number.
If the result is a single digit,
it is prefixed with \tcode{0}.
The modified command \tcode{\%OI} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%j} &
The day of the year as a decimal number.
Jan 1 is \tcode{001}.
If the result is less than three digits,
it is left-padded with \tcode{0} to three digits.
\\ \rowsep
\tcode{\%m} &
The month as a decimal number.
Jan is \tcode{01}.
If the result is a single digit, it is prefixed with \tcode{0}.
The modified command \tcode{\%Om} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%M} &
The minute as a decimal number.
If the result is a single digit, it is prefixed with \tcode{0}.
The modified command \tcode{\%OM} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%n} &
A new-line character.
\\ \rowsep
\tcode{\%p} &
The locale's equivalent of the AM/PM designations associated with a 12-hour clock.
\\ \rowsep
\tcode{\%r} &
The locale's 12-hour clock time.
\\ \rowsep
\tcode{\%R} &
Equivalent to \tcode{\%H:\%M}.
\\ \rowsep
\tcode{\%S} &
Seconds as a decimal number.
If the number of seconds is less than \tcode{10}, the result is prefixed with \tcode{0}.
If the precision of the input cannot be exactly represented with seconds,
then the format is a decimal floating point number with a fixed format
and a precision matching that of the precision of the input
(or to a microseconds precision if the conversion to floating point decimal seconds
cannot be made within 18 fractional digits).
The character for the decimal point is localized according to the locale.
The modified command \tcode{\%OS} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%t} &
A horizontal-tab character.
\\ \rowsep
\tcode{\%T} &
Equivalent to \tcode{\%H:\%M:\%S}.
\\ \rowsep
\tcode{\%u} &
The ISO weekday as a decimal number (\tcode{1}-\tcode{7}),
where Monday is \tcode{1}.
The modified command \tcode{\%Ou} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%U} &
The week number of the year as a decimal number.
The first Sunday of the year is the first day of week \tcode{01}.
Days of the same year prior to that are in week \tcode{00}.
If the result is a single digit, it is prefixed with \tcode{0}.
The modified command \tcode{\%OU} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%V} &
The ISO week-based week number as a decimal number.
If the result is a single digit, it is prefixed with \tcode{0}.
The modified command \tcode{\%OV} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%w} &
The weekday as a decimal number (\tcode{0}-\tcode{6}), where Sunday is \tcode{0}.
The modified command \tcode{\%Ow} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%W} &
The week number of the year as a decimal number.
The first Monday of the year is the first day of week \tcode{01}.
Days of the same year prior to that are in week \tcode{00}.
If the result is a single digit, it is prefixed with \tcode{0}.
The modified command \tcode{\%OW} produces
the locale's alternative representation.
\\ \rowsep
\tcode{\%x} &
The locale's date representation.
The modified command \tcode{\%Ex} produces
the locale's alternate date representation.
\\ \rowsep
\tcode{\%X} &
The locale's time representation.
The modified command \tcode{\%EX} produces
the locale's alternate time representation.
\\ \rowsep
\tcode{\%y} &
The last two decimal digits of the year.
If the result is a single digit it is prefixed by \tcode{0}.
\\ \rowsep
\tcode{\%Y} &
The year as a decimal number.
If the result is less than four digits
it is left-padded with \tcode{0} to four digits.
\\ \rowsep
\tcode{\%z} &
The offset from UTC in the ISO 8601 format.
For example \tcode{-0430} refers to 4 hours 30 minutes behind UTC.
If the offset is zero, \tcode{+0000} is used.
The modified commands \tcode{\%Ez} and  \tcode{\%Oz}
insert a \tcode{:} between the hours and minutes: \tcode{-04:30}.
If the offset information is not available,
\tcode{setstate(ios_base::failbit)} shall be called.
\\ \rowsep
\tcode{\%Z} &
The time zone abbreviation.
If the time zone abbreviation is not available,
\tcode{setstate(ios_base::failbit)} shall be called.
\\ \rowsep
\tcode{\%\%} &
A \tcode{\%} character.
\\
\end{LongTable}

\indexlibrary{\idxcode{format}|)}%

\rSec2[time.parse]{Parsing}

\indexlibrary{\idxcode{parse}|(}%

\pnum
Each \tcode{parse} overload specified in this subclause
calls \tcode{from_stream} unqualified,
so as to enable argument dependent lookup\iref{basic.lookup.argdep}.

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Parsable>
  @\unspec@
    parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
from_stream(declval<basic_istream<charT, traits>&>(), fmt.c_str(), tp)
\end{codeblock}
is a valid expression.

\pnum
\returns
A manipulator that, when extracted from a
\tcode{basic_istream<charT, traits>} \tcode{is},
calls \tcode{from_stream(is, fmt.c_str(), tp)}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Parsable>
  @\unspec@
    parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
from_stream(declval<basic_istream<charT, traits>&>(), fmt.c_str(), tp, &abbrev)
\end{codeblock}
is a valid expression.

\pnum
\returns
A manipulator that, when extracted from a
\tcode{basic_istream<charT, traits>} \tcode{is},
calls \tcode{from_stream(is, fmt.c_str(), tp, \&abbrev)}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Parsable>
  @\unspec@
    parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
          minutes& offset);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
from_stream(declval<basic_istream<charT, traits>&>(), fmt.c_str(), tp, nullptr, &offset)
\end{codeblock}
is a valid expression.

\pnum
\returns
A manipulator that, when extracted from a
\tcode{basic_istream<charT, traits>} \tcode{is},
calls \tcode{from_stream(is, fmt.c_str(), tp, nullptr, \&offset)}.
\end{itemdescr}

\begin{itemdecl}
template<class charT, class traits, class Alloc, class Parsable>
  @\unspec@
    parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev, minutes& offset);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
This function shall not participate in overload resolution unless
\begin{codeblock}
from_stream(declval<basic_istream<charT, traits>&>(), fmt.c_str(), tp, &abbrev, &offset)
\end{codeblock}
is a valid expression.

\pnum
\returns
A manipulator that, when extracted from a
\tcode{basic_istream<charT, traits>} \tcode{is},
calls \tcode{from_stream(is, fmt.c_str(), tp, \&abbrev, \&offset)}.
\end{itemdescr}

\pnum
All \tcode{from_stream} overloads behave as unformatted input functions,
except that they have an unspecified effect
on the value returned by subsequent calls to \tcode{basic_istream<>::gcount()}.
Each overload takes a format string containing ordinary characters
and flags which have special meaning.
Each flag begins with a \tcode{\%}.
Some flags can be modified by \tcode{E} or \tcode{O}.
During parsing each flag interprets characters as parts of date and time types
according to the table below.
Some flags can be modified by a width parameter
given as a positive decimal integer called out as \tcode{\placeholder{N}} below
which governs how many characters are parsed from the stream in interpreting the flag.
All characters in the format string that are not represented in the table below,
except for white space, are parsed unchanged from the stream.
A white space character matches zero or more white space characters in the input stream.

\pnum
If the \tcode{from_stream} overload fails to parse
everything specified by the format string,
or if insufficient information is parsed to specify a complete
duration, time point, or calendrical data structure,
\tcode{setstate(ios_base::failbit)}
is called on the \tcode{basic_istream}.

\begin{LongTable}{Meaning of \tcode{parse} flags}{tab:time.parse.spec}{lx{.8\hsize}}
\\ \topline
\lhdr{Flag} & \rhdr{Parsed value} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Flag} & \rhdr{Parsed value} \\ \capsep
\endhead
\tcode{\%a} &
The locale's full or abbreviated case-insensitive weekday name.
\\ \rowsep
\tcode{\%A} &
Equivalent to \tcode{\%a}.
\\ \rowsep
\tcode{\%b} &
The locale's full or abbreviated case-insensitive month name.
\\ \rowsep
\tcode{\%B} &
Equivalent to \tcode{\%b}.
\\ \rowsep
\tcode{\%c} &
The locale's date and time representation.
The modified command \tcode{\%Ec} interprets
the locale's alternate date and time representation.
\\ \rowsep
\tcode{\%C} &
The century as a decimal number.
The modified command \tcode{\%\placeholder{N}C} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified commands \tcode{\%EC} and \tcode{\%OC} interpret
the locale's alternative representation of the century.
\\ \rowsep
\tcode{\%d} &
The day of the month as a decimal number.
The modified command \tcode{\%\placeholder{N}d} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified command \tcode{\%Ed} interprets
the locale's alternative representation of the day of the month.
\\ \rowsep
\tcode{\%D} &
Equivalent to \tcode{\%m/\%d/\%y}.
\\ \rowsep
\tcode{\%e} &
Equivalent to \tcode{\%d} and can be modified like \tcode{\%d}.
\\ \rowsep
\tcode{\%F} &
Equivalent to \tcode{\%Y-\%m-\%d}.
If modified with a width \tcode{\placeholder{N}},
the width is applied to only \tcode{\%Y}.
\\ \rowsep
\tcode{\%g} &
The last two decimal digits of the ISO week-based year.
The modified command \tcode{\%\placeholder{N}g} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%G} &
The ISO week-based year as a decimal number.
The modified command \tcode{\%\placeholder{N}G} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 4.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%h} &
Equivalent to \tcode{\%b}.
\\ \rowsep
\tcode{\%H} &
The hour (24-hour clock) as a decimal number.
The modified command \tcode{\%\placeholder{N}H} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified command \tcode{\%OH} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%I} &
The hour (12-hour clock) as a decimal number.
The modified command \tcode{\%\placeholder{N}I} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%j} &
The day of the year as a decimal number.
Jan 1 is \tcode{1}.
The modified command \tcode{\%\placeholder{N}j} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 3.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%m} &
The month as a decimal number.
Jan is \tcode{1}.
The modified command \tcode{\%\placeholder{N}m} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified command \tcode{\%Om} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%M} &
The minutes as a decimal number.
The modified command \tcode{\%\placeholder{N}M} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified command \tcode{\%OM} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%n} &
Matches one white space character.
\begin{note}
\tcode{\%n}, \tcode{\%t}, and a space
can be combined to match a wide range of white-space patterns.
For example,
\tcode{"\%n "} matches one or more white space characters, and
\tcode{"\%n\%t\%t"} matches one to three white space characters.
\end{note}
\\ \rowsep
\tcode{\%p} &
The locale's equivalent of the AM/PM designations associated with a 12-hour clock.
The command \tcode{\%I} must precede \tcode{\%p} in the format string.
\\ \rowsep
\tcode{\%r} &
The locale's 12-hour clock time.
\\ \rowsep
\tcode{\%R} &
Equivalent to \tcode{\%H:\%M}.
\\ \rowsep
\tcode{\%S} &
The seconds as a decimal number.
The modified command \tcode{\%\placeholder{N}S} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified,
the default is 2 if the input time has a precision convertible to seconds.
Otherwise the default width is determined by
the decimal precision of the input
and the field is interpreted as a \tcode{long double} in a fixed format.
If encountered, the locale determines the decimal point character.
Leading zeroes are permitted but not required.
The modified command \tcode{\%OS} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%t} &
Matches zero or one white space characters.
\\ \rowsep
\tcode{\%T} &
Equivalent to \tcode{\%H:\%M:\%S}.
\\ \rowsep
\tcode{\%u} &
The ISO weekday as a decimal number (\tcode{1}-\tcode{7}), where Monday is \tcode{1}.
The modified command \tcode{\%\placeholder{N}u} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is \tcode{1}.
Leading zeroes are permitted but not required.
The modified command \tcode{\%Ou} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%U} &
The week number of the year as a decimal number.
The first Sunday of the year is the first day of week \tcode{01}.
Days of the same year prior to that are in week \tcode{00}.
The modified command \tcode{\%\placeholder{N}U} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%V} &
The ISO week-based week number as a decimal number.
The modified command \tcode{\%\placeholder{N}V} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%w} &
The weekday as a decimal number (\tcode{0}-\tcode{6}), where Sunday is \tcode{0}.
The modified command \tcode{\%\placeholder{N}w} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is \tcode{1}.
Leading zeroes are permitted but not required.
The modified command \tcode{\%Ow} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%W} &
The week number of the year as a decimal number.
The first Monday of the year is the first day of week \tcode{01}.
Days of the same year prior to that are in week \tcode{00}.
The modified command \tcode{\%\placeholder{N}W} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
\\ \rowsep
\tcode{\%x} &
The locale's date representation.
The modified command \tcode{\%Ex} produces the locale's alternate date representation.
\\ \rowsep
\tcode{\%X} &
The locale's time representation.
The modified command \tcode{\%EX} produces the locale's alternate time representation.
\\ \rowsep
\tcode{\%y} &
The last two decimal digits of the year.
If the century is not otherwise specified
(e.g.  with \tcode{\%C}),
values in the range \crange{69}{99}
are presumed to refer to the years 1969 to 1999,
and values in the range \crange{00}{68}
are presumed to refer to the years 2000 to 2068.
The modified command \tcode{\%\placeholder{N}y} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 2.
Leading zeroes are permitted but not required.
The modified commands \tcode{\%Ey} and \tcode{\%Oy} interpret
the locale's alternative representation.
\\ \rowsep
\tcode{\%Y} &
The year as a decimal number.
The modified command \tcode{\%\placeholder{N}Y} specifies
the maximum number of characters to read.
If \tcode{\placeholder{N}} is not specified, the default is 4.
Leading zeroes are permitted but not required.
The modified command \tcode{\%EY} interprets
the locale's alternative representation.
\\ \rowsep
\tcode{\%z} &
The offset from UTC in the format \tcode{[+|-]hh[mm]}.
For example \tcode{-0430} refers to 4 hours 30 minutes behind UTC,
and \tcode{04} refers to 4 hours ahead of UTC.
The modified commands \tcode{\%Ez} and \tcode{\%Oz}
parse a \tcode{:} between the hours and minutes
and render leading zeroes on the hour field optional:
\tcode{[+|-]h[h][:mm]}.
For example \tcode{-04:30} refers to 4 hours 30 minutes behind UTC,
and \tcode{4} refers to 4 hours ahead of UTC.
\\ \rowsep
\tcode{\%Z} &
The time zone abbreviation or name.
A single word is parsed.
This word can only contain characters
from the basic source character set\iref{lex.charset}
that are alphanumeric, or one of
\tcode{'_'}, \tcode{'/'}, \tcode{'-'}, or \tcode{'+'}.
\\ \rowsep
\tcode{\%\%} &
A \tcode{\%} character is extracted.
\\
\end{LongTable}

\indexlibrary{\idxcode{parse}|)}

\rSec2[ctime.syn]{Header \tcode{<ctime>} synopsis}

\indexhdr{ctime}%
\indexlibrary{\idxcode{CLOCKS_PER_SEC}}%
\indexlibrary{\idxcode{NULL}}%
\indexlibrary{\idxcode{TIME_UTC}}%
\indexlibrary{\idxcode{asctime}}%
\indexlibrary{\idxcode{clock_t}}%
\indexlibrary{\idxcode{clock}}%
\indexlibrary{\idxcode{ctime}}%
\indexlibrary{\idxcode{difftime}}%
\indexlibrary{\idxcode{gmtime}}%
\indexlibrary{\idxcode{localtime}}%
\indexlibrary{\idxcode{mktime}}%
\indexlibrary{\idxcode{size_t}}%
\indexlibrary{\idxcode{strftime}}%
\indexlibrary{\idxcode{time_t}}%
\indexlibrary{\idxcode{timespec_get}}%
\indexlibrary{\idxcode{timespec}}%
\indexlibrary{\idxcode{time}}%
\indexlibrary{\idxcode{tm}}%
\begin{codeblock}
#define NULL @\textit{see \ref{support.types.nullptr}}@
#define CLOCKS_PER_SEC @\seebelow@
#define TIME_UTC @\seebelow@

namespace std {
  using size_t = @\textit{see \ref{support.types.layout}}@;
  using clock_t = @\seebelow@;
  using time_t = @\seebelow@;

  struct timespec;
  struct tm;

  clock_t clock();
  double difftime(time_t time1, time_t time0);
  time_t mktime(struct tm* timeptr);
  time_t time(time_t* timer);
  int timespec_get(timespec* ts, int base);
  char* asctime(const struct tm* timeptr);
  char* ctime(const time_t* timer);
  struct tm* gmtime(const time_t* timer);
  struct tm* localtime(const time_t* timer);
  size_t strftime(char* s, size_t maxsize, const char* format, const struct tm* timeptr);
}
\end{codeblock}

\pnum
\indexhdr{time.h}%
\indexhdr{ctime}%
The contents of the header \tcode{<ctime>} are the same as the C standard library header \tcode{<time.h>}.%
\footnote{\tcode{strftime} supports the C conversion specifiers
\tcode{C}, \tcode{D}, \tcode{e}, \tcode{F}, \tcode{g}, \tcode{G}, \tcode{h},
\tcode{r}, \tcode{R}, \tcode{t}, \tcode{T}, \tcode{u}, \tcode{V}, and
\tcode{z}, and the modifiers \tcode{E} and \tcode{O}.}

\pnum
The functions \tcode{asctime}, \tcode{ctime}, \tcode{gmtime}, and
\tcode{localtime} are not required to avoid data
races\iref{res.on.data.races}.

\xrefc{7.27}

\rSec1[type.index]{Class \tcode{type_index}}

\rSec2[type.index.synopsis]{Header \tcode{<typeindex>} synopsis}

\indexhdr{typeindex}%
\begin{codeblock}
namespace std {
  class type_index;
  template<class T> struct hash;
  template<> struct hash<type_index>;
}
\end{codeblock}

\rSec2[type.index.overview]{\tcode{type_index} overview}

\indexlibrary{\idxcode{type_index}}%
\begin{codeblock}
namespace std {
  class type_index {
  public:
    type_index(const type_info& rhs) noexcept;
    bool operator==(const type_index& rhs) const noexcept;
    bool operator!=(const type_index& rhs) const noexcept;
    bool operator< (const type_index& rhs) const noexcept;
    bool operator> (const type_index& rhs) const noexcept;
    bool operator<= (const type_index& rhs) const noexcept;
    bool operator>= (const type_index& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

  private:
    const type_info* target;    // \expos
    // Note that the use of a pointer here, rather than a reference,
    // means that the default copy/move constructor and assignment
    // operators will be provided and work as expected.
  };
}
\end{codeblock}

\pnum
The class \tcode{type_index} provides a simple wrapper for
\tcode{type_info} which can be used as an index type in associative
containers\iref{associative} and in unordered associative
containers\iref{unord}.

\rSec2[type.index.members]{\tcode{type_index} members}

\indexlibrary{\idxcode{type_index}!constructor}%
\begin{itemdecl}
type_index(const type_info& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{type_index} object, the equivalent of \tcode{target = \&rhs}.
\end{itemdescr}

\indexlibrarymember{operator==}{type_index}%
\begin{itemdecl}
bool operator==(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*target == *rhs.target}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{type_index}%
\begin{itemdecl}
bool operator!=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*target != *rhs.target}.
\end{itemdescr}

\indexlibrarymember{operator<}{type_index}%
\begin{itemdecl}
bool operator<(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->before(*rhs.target)}.
\end{itemdescr}

\indexlibrarymember{operator>}{type_index}%
\begin{itemdecl}
bool operator>(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.target->before(*target)}.
\end{itemdescr}

\indexlibrarymember{operator<=}{type_index}%
\begin{itemdecl}
bool operator<=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!rhs.target->before(*target)}.
\end{itemdescr}

\indexlibrarymember{operator>=}{type_index}%
\begin{itemdecl}
bool operator>=(const type_index& rhs) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!target->before(*rhs.target)}.
\end{itemdescr}

\indexlibrarymember{hash_code}{type_index}%
\begin{itemdecl}
size_t hash_code() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->hash_code()}.
\end{itemdescr}

\indexlibrarymember{name}{type_index}%
\begin{itemdecl}
const char* name() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{target->name()}.
\end{itemdescr}

\rSec2[type.index.hash]{Hash support}

\indexlibrary{\idxcode{hash}!\idxcode{type_index}}%
\begin{itemdecl}
template<> struct hash<type_index>;
\end{itemdecl}

\begin{itemdescr}
\pnum
For an object \tcode{index} of type \tcode{type_index},
\tcode{hash<type_index>()(index)} shall evaluate to the same result as \tcode{index.hash_code()}.
\end{itemdescr}

\rSec1[execpol]{Execution policies}
\rSec2[execpol.general]{In general}

\pnum
This subclause describes classes that are \defn{execution policy} types. An
object of an execution policy type indicates the kinds of parallelism allowed
in the execution of an algorithm and expresses the consequent requirements on
the element access functions.
\begin{example}
\begin{codeblock}
using namespace std;
vector<int> v = @\commentellip@;

// standard sequential sort
sort(v.begin(), v.end());

// explicitly sequential sort
sort(execution::seq, v.begin(), v.end());

// permitting parallel execution
sort(execution::par, v.begin(), v.end());

// permitting vectorization as well
sort(execution::par_unseq, v.begin(), v.end());
\end{codeblock}
\end{example}
\begin{note}
Because different parallel architectures may require idiosyncratic
parameters for efficient execution, implementations
may provide additional execution policies to those described in this
standard as extensions.
\end{note}

\rSec2[execution.syn]{Header \tcode{<execution>} synopsis}

\indexhdr{execution}%
\begin{codeblock}
namespace std {
  // \ref{execpol.type}, execution policy type trait
  template<class T> struct is_execution_policy;
  template<class T> inline constexpr bool is_execution_policy_v = is_execution_policy<T>::value;
}

namespace std::execution {
  // \ref{execpol.seq}, sequenced execution policy
  class sequenced_policy;

  // \ref{execpol.par}, parallel execution policy
  class parallel_policy;

  // \ref{execpol.parunseq}, parallel and unsequenced execution policy
  class parallel_unsequenced_policy;

  // \ref{execpol.objects}, execution policy objects
  inline constexpr sequenced_policy            seq{ @\unspec@ };
  inline constexpr parallel_policy             par{ @\unspec@ };
  inline constexpr parallel_unsequenced_policy par_unseq{ @\unspec@ };
}
\end{codeblock}

\rSec2[execpol.type]{Execution policy type trait}

\indexlibrary{\idxcode{is_execution_policy}}%
\begin{itemdecl}
template<class T> struct is_execution_policy { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{is_execution_policy} can be used to detect execution policies for the
purpose of excluding function signatures from otherwise ambiguous overload
resolution participation.

\pnum
\tcode{is_execution_policy<T>} shall be a \tcode{UnaryTypeTrait} with a
base characteristic of \tcode{true_type} if \tcode{T} is the type of a standard
or \impldef{additional execution policies supported by parallel algorithms}
execution policy, otherwise \tcode{false_type}.

\begin{note}
This provision reserves the privilege of creating non-standard execution
policies to the library implementation.
\end{note}

\pnum
The behavior of a program that adds specializations for
\tcode{is_execution_policy} is undefined.
\end{itemdescr}

\rSec2[execpol.seq]{Sequenced execution policy}

\indexlibrary{\idxcode{execution::sequenced_policy}}%
\begin{itemdecl}
class execution::sequenced_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::sequenced_policy} is an execution policy type used
as a unique type to disambiguate parallel algorithm overloading and require
that a parallel algorithm's execution may not be parallelized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::sequenced_policy} policy,
if the invocation of an element access function exits via an uncaught exception,
\tcode{terminate()} shall be called.
\end{itemdescr}

\rSec2[execpol.par]{Parallel execution policy}

\indexlibrary{\idxcode{execution::parallel_policy}}%
\begin{itemdecl}
class execution::parallel_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::parallel_policy} is an execution policy type used as
a unique type to disambiguate parallel algorithm overloading and indicate that
a parallel algorithm's execution may be parallelized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::parallel_policy} policy,
if the invocation of an element access function exits via an uncaught exception,
\tcode{terminate()} shall be called.
\end{itemdescr}

\rSec2[execpol.parunseq]{Parallel and unsequenced execution policy}

\indexlibrary{\idxcode{execution::parallel_unsequenced_policy}}%
\begin{itemdecl}
class execution::parallel_unsequenced_policy { @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class \tcode{execution::parallel_unsequenced_policy} is an execution policy type
used as a unique type to disambiguate parallel algorithm overloading and
indicate that a parallel algorithm's execution may be parallelized and
vectorized.

\pnum
During the execution of a parallel algorithm with
the \tcode{execution::parallel_unsequenced_policy} policy,
if the invocation of an element access function exits via an uncaught exception,
\tcode{terminate()} shall be called.
\end{itemdescr}

\rSec2[execpol.objects]{Execution policy objects}

\indexlibrary{\idxcode{seq}}%
\indexlibrary{\idxcode{par}}%
\indexlibrary{\idxcode{par_unseq}}%
\indexlibrary{\idxcode{execution}!\idxcode{seq}}%
\indexlibrary{\idxcode{execution}!\idxcode{par}}%
\indexlibrary{\idxcode{execution}!\idxcode{par_unseq}}%
\begin{itemdecl}
inline constexpr execution::sequenced_policy            execution::seq{ @\unspec@ };
inline constexpr execution::parallel_policy             execution::par{ @\unspec@ };
inline constexpr execution::parallel_unsequenced_policy execution::par_unseq{ @\unspec@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The header \tcode{<execution>} declares global objects associated with each type of execution policy.
\end{itemdescr}

\rSec1[charconv]{Primitive numeric conversions}

\rSec2[charconv.syn]{Header \tcode{<charconv>} synopsis}

\indexhdr{charconv}%
\begin{codeblock}
@%
\indexlibrary{\idxcode{chars_format}}%
\indexlibrarymember{scientific}{chars_format}%
\indexlibrarymember{fixed}{chars_format}%
\indexlibrarymember{hex}{chars_format}%
\indexlibrarymember{general}{chars_format}%
@namespace std {
  // floating-point format for primitive numerical conversion
  enum class chars_format {
    scientific = @\unspec@,
    fixed = @\unspec@,
    hex = @\unspec@,
    general = fixed | scientific
  };
@%
\indexlibrary{\idxcode{to_chars_result}}%
\indexlibrarymember{ptr}{to_chars_result}%
\indexlibrarymember{ec}{to_chars_result}
@
  // \ref{charconv.to.chars}, primitive numerical output conversion
  struct to_chars_result {
    char* ptr;
    errc ec;
  };

  to_chars_result to_chars(char* first, char* last, @\seebelow@ value, int base = 10);

  to_chars_result to_chars(char* first, char* last, float value);
  to_chars_result to_chars(char* first, char* last, double value);
  to_chars_result to_chars(char* first, char* last, long double value);

  to_chars_result to_chars(char* first, char* last, float value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, double value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, long double value, chars_format fmt);

  to_chars_result to_chars(char* first, char* last, float value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, double value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, long double value,
                           chars_format fmt, int precision);
@%
\indexlibrary{\idxcode{from_chars_result}}%
\indexlibrarymember{ptr}{from_chars_result}%
\indexlibrarymember{ec}{from_chars_result}
@
  // \ref{charconv.from.chars}, primitive numerical input conversion
  struct from_chars_result {
    const char* ptr;
    errc ec;
  };

  from_chars_result from_chars(const char* first, const char* last,
                               @\seebelow@& value, int base = 10);

  from_chars_result from_chars(const char* first, const char* last, float& value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, double& value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, long double& value,
                               chars_format fmt = chars_format::general);
}
\end{codeblock}

\pnum
The type \tcode{chars_format} is a bitmask type\iref{bitmask.types}
with elements \tcode{scientific}, \tcode{fixed}, and \tcode{hex}.

\rSec2[charconv.to.chars]{Primitive numeric output conversion}

\pnum
All functions named \tcode{to_chars}
convert \tcode{value} into a character string
by successively filling the range
\range{first}{last},
where \range{first}{last} is required to be a valid range.
If the member \tcode{ec}
of the return value
is such that the value
is equal to the value of a value-initialized \tcode{errc},
the conversion was successful
and the member \tcode{ptr}
is the one-past-the-end pointer of the characters written.
Otherwise,
the member \tcode{ec} has the value \tcode{errc::value_too_large},
the member \tcode{ptr} has the value \tcode{last},
and the contents of the range \range{first}{last} are unspecified.

\pnum
The functions that take a floating-point \tcode{value}
but not a \tcode{precision} parameter
ensure that the string representation
consists of the smallest number of characters
such that
there is at least one digit before the radix point (if present) and
parsing the representation using the corresponding \tcode{from_chars} function
recovers \tcode{value} exactly.
\begin{note}
This guarantee applies only if
\tcode{to_chars} and \tcode{from_chars}
are executed on the same implementation.
\end{note}
If there are several such representations,
the representation with the smallest difference from
the floating-point argument value is chosen,
resolving any remaining ties using rounding according to
\tcode{round_to_nearest}\iref{round.style}.

\pnum
The functions taking a \tcode{chars_format} parameter
determine the conversion specifier for \tcode{printf} as follows:
The conversion specifier is
\tcode{f} if \tcode{fmt} is \tcode{chars_format::fixed},
\tcode{e} if \tcode{fmt} is \tcode{chars_format::scientific},
\tcode{a} (without leading \tcode{"0x"} in the result)
if \tcode{fmt} is \tcode{chars_format::hex},
and
\tcode{g} if \tcode{fmt} is \tcode{chars_format::general}.

\indexlibrary{\idxcode{to_chars}}%
\begin{itemdecl}
to_chars_result to_chars(char* first, char* last, @\seebelow@ value, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{base} has a value between 2 and 36 (inclusive).

\pnum
\effects The value of \tcode{value} is converted
to a string of digits in the given base
(with no redundant leading zeroes).
Digits in the range 10..35 (inclusive)
are represented as lowercase characters \tcode{a}..\tcode{z}.
If \tcode{value} is less than zero,
the representation starts with \tcode{'-'}.

\pnum
\throws Nothing.

\pnum
\remarks
The implementation shall provide overloads
for all signed and unsigned integer types
and \tcode{char}
as the type of the parameter \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{to_chars}}%
\begin{itemdecl}
to_chars_result to_chars(char* first, char* last, float value);
to_chars_result to_chars(char* first, char* last, double value);
to_chars_result to_chars(char* first, char* last, long double value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{value} is converted to a string
in the style of \tcode{printf}
in the \tcode{"C"} locale.
The conversion specifier is \tcode{f} or \tcode{e},
chosen according to the requirement for a shortest representation
(see above);
a tie is resolved in favor of \tcode{f}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{to_chars}}%
\begin{itemdecl}
to_chars_result to_chars(char* first, char* last, float value, chars_format fmt);
to_chars_result to_chars(char* first, char* last, double value, chars_format fmt);
to_chars_result to_chars(char* first, char* last, long double value, chars_format fmt);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{fmt} has the value of
one of the enumerators of \tcode{chars_format}.

\pnum
\effects \tcode{value} is converted to a string
in the style of \tcode{printf}
in the \tcode{"C"} locale.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrary{\idxcode{to_chars}}%
\begin{itemdecl}
to_chars_result to_chars(char* first, char* last, float value,
                         chars_format fmt, int precision);
to_chars_result to_chars(char* first, char* last, double value,
                         chars_format fmt, int precision);
to_chars_result to_chars(char* first, char* last, long double value,
                         chars_format fmt, int precision);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{fmt} has the value of
one of the enumerators of \tcode{chars_format}.

\pnum
\effects \tcode{value} is converted to a string
in the style of \tcode{printf}
in the \tcode{"C"} locale
with the given precision.

\pnum
\throws Nothing.
\end{itemdescr}

\xrefc{7.21.6.1}

\rSec2[charconv.from.chars]{Primitive numeric input conversion}

\pnum
All functions named \tcode{from_chars}
analyze the string \range{first}{last}
for a pattern,
where \range{first}{last} is required to be a valid range.
If no characters match the pattern,
\tcode{value} is unmodified,
the member \tcode{ptr} of the return value is \tcode{first} and
the member \tcode{ec} is equal to \tcode{errc::invalid_argument}.
\begin{note} If the pattern allows for an optional sign,
but the string has no digit characters following the sign,
no characters match the pattern. \end{note}
Otherwise,
the characters matching the pattern
are interpreted as a representation
of a value of the type of \tcode{value}.
The member \tcode{ptr}
of the return value
points to the first character
not matching the pattern,
or has the value \tcode{last}
if all characters match.
If the parsed value
is not in the range
representable by the type of \tcode{value},
\tcode{value} is unmodified and
the member \tcode{ec} of the return value
is equal to \tcode{errc::result_out_of_range}.
Otherwise,
\tcode{value} is set to the parsed value,
after rounding according to \tcode{round_to_nearest}\iref{round.style}, and
the member \tcode{ec} is value-initialized.

\indexlibrary{\idxcode{from_chars}}%
\begin{itemdecl}
from_chars_result from_chars(const char* first, const char* last,
                             @\seebelow@&@\itcorr[-1]@ value, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{base} has a value between 2 and 36 (inclusive).

\pnum
\effects The pattern is the expected form of the subject sequence
in the \tcode{"C"} locale
for the given nonzero base,
as described for \tcode{strtol},
except that no \tcode{"0x"} or \tcode{"0X"} prefix shall appear
if the value of \tcode{base} is 16,
and except that \tcode{'-'}
is the only sign that may appear,
and only if \tcode{value} has a signed type.

\pnum
\throws Nothing.

\pnum
\remarks
The implementation shall provide overloads
for all signed and unsigned integer types
and \tcode{char}
as the referenced type of the parameter \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{from_chars}}%
\begin{itemdecl}
from_chars_result from_chars(const char* first, const char* last, float& value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double& value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double& value,
                             chars_format fmt = chars_format::general);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{fmt} has the value of
one of the enumerators of \tcode{chars_format}.

\pnum
\effects The pattern is the expected form of the subject sequence
in the \tcode{"C"} locale,
as described for \tcode{strtod},
except that
\begin{itemize}
\item
the only sign that may appear is \tcode{'-'};
\item
if \tcode{fmt} has \tcode{chars_format::scientific} set
but not \tcode{chars_format::fixed},
the otherwise optional exponent part shall appear;
\item
if \tcode{fmt} has \tcode{chars_format::fixed} set
but not \tcode{chars_format::scientific},
the optional exponent part shall not appear; and
\item
if \tcode{fmt} is \tcode{chars_format::hex},
the prefix \tcode{"0x"} or \tcode{"0X"} is assumed.
\begin{example}
The string \tcode{0x123}
is parsed to have the value
\tcode{0}
with remaining characters \tcode{x123}.
\end{example}
\end{itemize}
In any case, the resulting \tcode{value} is one of
at most two floating-point values
closest to the value of the string matching the pattern.

\pnum
\throws Nothing.
\end{itemdescr}

\xrefc{7.22.1.3, 7.22.1.4}
