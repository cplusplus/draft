%!TEX root = std.tex
\infannex{ifndr}{Enumeration of Ill-formed, No Diagnostic Required}

\rSec1[ifndr.general]{General}

This Annex documents ill-formed no diagnostic required behavior called out in the main standard text by
the following phrases: no diagnostic is required, no diagnostic required and no diagnostic shall be issued.
Each entry contains a title, a numeric cross reference to the main standard text, a summary of the issue
and a code example demonstrating the issue. The code examples are there to clarify the ill-formed no
diagnostic required cases and will not exhaustively cover all possible ways of invoking that case.

\rSec1[ifndr.lex]{\ref{lex}: Lexical conventions}

\rSec2[ifndr.lex.name]{Identifiers}

\pnum
\ifndrxref{lex.name.reserved} \\
Some identifiers are reserved for use by \Cpp{} implementations and shall not be used otherwise; no
diagnostic is required.

\pnum
\begin{example}
\begin{codeblock}
int _z; // no diagnostic required, \tcode{\_z} is reserved because it starts with \tcode{\_} at global scope

int main() {
    int __x;    // no diagnostic required, \tcode{\_\_x} is reserved because it starts with \tcode{\_\_}
    int _Y;     // no diagnostic required, \tcode{\_Y} is reserved because it starts with \tcode{\_} followed by a capital letter
    int x__y;   // no diagnostic required, \tcode{x\_\_y} is reserved because it contains \tcode{\_\_}
}
\end{codeblock}
\end{example}


\rSec1[ifndr.basic]{\ref{basic}: Basics}

\rSec2[ifndr.basic.def.odr]{One-definition rule}

\pnum
\ifndrxref{basic.def.odr.exact.one.def} \\
Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in
that program outside of a discarded statement \iref{stmt.if}; no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
auto f() {
  struct A {};
  return A{};
}
decltype(f()) g();
auto x = g();   // ill-formed, no diagnostic required, function \tcode{g} is used but not defined
                // in this translation unit, and cannot be defined in any other translation unit
                // because its type does not have linkage
\end{codeblock}
\end{example}


\pnum
\ifndrxref{basic.def.odr.unnamed.enum.same.type} \\
If, at any point in the program, there is more than one reachable unnamed enumeration definition in the same scope that have
the same first enumerator name and do not have typedef names for linkage purposes \iref{dcl.enum}, those unnamed enumeration
types shall be the same; no diagnostic required.


\pnum
\begin{example}
\begin{codeblock}
// a.h
enum { a };

// b.h
enum { a, b };

// main.cpp
import "a.h";
import "b.h";
auto n = decltype(a)::b;        // ill-formed no diagnostic required, more than one unnammed enum
                                // definition reachable at this point but their types are not the same
\end{codeblock}
\end{example}


\rSec2[ifndr.class.member.lookup]{Member name lookup}

\pnum
\ifndrxref{class.member.lookup.name.refers.diff.decl} \\
A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S.

\pnum
\begin{example}
\begin{codeblock}
struct foo {};

struct bar {
  foo *m_foo;

  foo *foo() {
    return m_foo;
  } // IFNDR, foo now refers to member function foo() while previously referred to struct foo
};
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
struct B {
  static int f();
};

struct D : public B {
  using B::f;
  int g(decltype(f()) x) {
    return 0;
  } // Ill-formed no diagnostic required,
    // decltype(f()) will refer to B::f() here but if
    // moved to the end of D would refer to D::f()
  static float f();
};

int main() {
  D d;

  return d.g(0);
}
\end{codeblock}
\end{example}


\rSec1[ifndr.expr]{\ref{expr}: Expressions}

\rSec2[ifndr.expr.prim.req]{Requires expressions}

\pnum
\ifndrxref{expr.prim.req.always.sub.fail} \\
If the substitution of template arguments into a \grammarterm{requirement}
would always result in a substitution failure, the program is ill-formed; no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
template <typename T> concept C = requires {
  new int[-(int)sizeof(T)]; // ill-formed, no diagnostic required, the size of the allocation is
                            // required to be greater than zero but can never be
};
\end{codeblock}
\end{example}


\rSec1[ifndr.stmt.stmt]{\ref{stmt}: Statements}

\rSec2[ifndr.stmt.ambig]{Ambiguity resolution}

\pnum
\ifndrxref{stmt.ambig.bound.diff.parse} \\
If, during
parsing, a name in a template parameter is bound differently than it would be bound during a trial parse,
the program is ill-formed. No diagnostic is required.

\pnum
\begin{example}
\begin{codeblock}
template <int N> struct A { const static int a = 20; };

template <> struct A<100> { using a = char; };

const int x = 10;

int main() {
  using T = const int;
  T(x)
  (100), (y)(A<x>::a);  // ill-formed no diagnostic required, during trial parse the template
                        // parameter \tcode{x} is bound to the global \tcode{x} later during parsing the template
                        // parameter \tcode{x} is bound to the local \tcode{x} declared on the same line
}
\end{codeblock}
\end{example}


\rSec1[ifndr.dcl.dcl]{\ref{dcl}: Declarations}

\rSec2[ifndr.dcl.align]{Alignment specifier}

\pnum
\ifndrxref{dcl.align.diff.translation.units} \\
No diagnostic is required if declarations of an entity have different \grammarterm{alignment-specifier}s in different
translation units.

\pnum
\begin{example}
\begin{codeblocktu}{Translation unit \#1}
struct S { int x; } s, *p = &s;
\end{codeblocktu}
\begin{codeblocktu}{Translation unit \#2}
struct alignas(16) S;   // ill-formed, no diagnostic required, definition of \tcode{S} lacks alignment
extern S* p;
\end{codeblocktu}
\end{example}

\rSec2[ifndr.dcl.attr.noreturn]{Noreturn attribute}

\pnum
\ifndrxref{dcl.attr.noreturn.trans.unit.mismatch} \\

\pnum
\begin{example}
\begin{codeblocktu}{Translation unit \#1}
[[noreturn]] void f() {}
\end{codeblocktu}
\begin{codeblocktu}{Translation unit \#2}
void f(int i);          // ill-formed no diagnostic required, declared without \tcode{noreturn}
\end{codeblocktu}
\end{example}

\rSec1[ifndr.module]{\ref{module}: Modules}

\rSec2[ifndr.module.unit]{Module units and purviews}

\pnum
\ifndrxref{module.unit.reserved.identifiers} \\
All \grammarterm{module-name}s either beginning with an identifier consisting of
std followed by zero or more digits or containing a reserved identifier\iref{lex.token} are reserved and shall not be
specified in a \grammarterm{module-declaration}; no diagnostic is required.

\pnum
\begin{example}
\begin{codeblock}
module std;             // ill-formed no diagnostic required, \tcode{std} is not allowed at the beginning
module module;          // ill-formed no diagnostic required, \tcode{module} is a reserved identifier
module std0;            // ill-formed no diagnostic required, \tcode{std} followed by digits is not allowed at the beginning
export module _Test;    // ill-formed no diagnostic required, \tcode{_Test} is a reserved identifier
export module te__st;   // ill-formed no diagnostic required, \tcode{te__st} is a reserved identifier
\end{codeblock}
\end{example}


\pnum
\ifndrxref{module.unit.named.module.no.partition} \\
A named module shall contain exactly one module interface
unit with no module-partition, known as the primary module interface unit of the module; no diagnostic is
required.

\pnum
\begin{example}
\begin{codeblock}
module A;
export import :Internals;       // ill-formed no diagnostic required, module partition not allowed
\end{codeblock}
\end{example}


\rSec1[ifndr.class]{\ref{class}: Classes}

\rSec2[ifndr.class.base.init]{Initializing bases and members}

\pnum
\ifndrxref{class.base.init.delegate.itself} \\
If a constructor delegates to itself directly or indirectly,
the program is ill-formed, no diagnostic required

\pnum
\begin{example}
\begin{codeblock}
struct C {
  C( int ) { }                  // \#1: non-delegating constructor
  C(): C(42) { }                // \#2: delegates to \#1
  C( char c ) : C(42.0) { }     // \#3: ill-formed no diagnostic required due to recursion with \#4
  C( double d ) : C('a') { }    // \#4: ill-formed no diagnostic required due to recursion with \#3
};
\end{codeblock}
\end{example}


\rSec2[ifndr.class.virtual]{Virtual functions}

\pnum
\ifndrxref{class.virtual.pure.or.defined} \\
A virtual function must be declared pure or defined, no diagnostic required. A virtual function declared pure can be defined
out of line

\pnum
\begin{example}
\begin{codeblock}
class A {
  virtual void f();
};

int main() {
  A a;      // ill-formed no diagnostic required, virtual function that is not pure but has not definition
}
\end{codeblock}
\end{example}


\rSec1[ifndr.over]{\ref{over}: Overloading}

\rSec2[ifndr.over.literal]{User-defined literals}

\pnum
\ifndrxref{over.literal.reserved} \\
Some literal suffix identifiers are
reserved for future standardization. A declaration whose literal-operator-id uses such a literal
suffix identifier is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
float operator ""E(const char*);        // ill-formed, no diagnostic required, reserved literal suffix
double operator"" _Bq(long double);     // ill-formed, no diagnostic required, // uses the reserved identifier \tcode{_Bq}
\end{codeblock}
\end{example}

\rSec1[ifndr.temp]{\ref{temp}: Templates}

\rSec2[ifndr.temp.pre]{Preamble}

\pnum
\ifndrxref{temp.pre.reach.def} \\
A definition of a function template, member function of a class template, variable template, or static data
member of a class template shall be reachable from the end of every definition domain\iref{basic.def.odr} in which it is
implicitly instantiated\iref{temp.inst} unless the corresponding specialization is explicitly instantiated\iref{temp.explicit} in
some translation unit; no diagnostic is required.

\pnum
\begin{example}
\begin{codeblock}
// a.h
template <typename T>
void f();

// a.cpp
#include "a.h"
int main() {
    f<int>();   // ill-formed no diagnostic required, function template implicity
                // instantiated but not reachable definition
}
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.arg.template]{Template template arguments}

\pnum
\ifndrxref{temp.arg.template.sat.constraints} \\
Any partial specializations\iref{temp.spec.partial} associated with the primary template are considered when a specialization
based on the template template-parameter is instantiated. If a specialization is not reachable from the point of
instantiation, and it would have been selected had it been reachable, the program is ill-formed, no diagnostic
required.

\pnum
\begin{example}
\begin{codeblock}
template<class T> struct A {
  int x;
};

template<template<class U> class V> struct C {
  V<int> y;
  V<int*> z;
};

C<A> c;

// Ill-formed no diagnostic required, specialization is not reachable from point
// of instantiation above and it would have been selected if it had
template<class T> struct A<T*> {
  long x;
};
\end{codeblock}
\end{example}


\rSec2[ifndr.constr.atomic]{Atomic constraints}

\pnum
\ifndrxref{temp.constr.atomic.equiv.but.not.equiv} \\
If the validity or meaning of the program depends on whether two atomic
constraints are equivalent,
and they are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
template <unsigned N> void f2()
requires Add1<2 * N>;
template <unsigned N> int f2()
requires Add1<N * 2> && true;
void h2() {
f2<0>();        // ill-formed, no diagnostic required,
                // requires determination of subsumption between atomic constraints that are
                // functionally equivalent but not equivalent
\end{codeblock}
\end{example}

\pnum
\ifndrxref{temp.constr.atomic.sat.result.diff} \\
If, at different points in the program, the satisfaction result is different for identical atomic constraints and template arguments, the program is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
template<class T>
concept Complete = sizeof(T) == sizeof(T);

struct A;
static_assert(!Complete<A>);    // \#1
struct A {};
static_assert(Complete<A>);     // ill-formed no diagnostic required, satisfaction
                                // result differs from point \#1
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.constr.normal]{Constraint normalization}

\pnum
\ifndrxref{temp.constr.normal.invalid} \\
If during constraint normalization any such substitution results in an invalid type or expression,
the program is ill-formed; no diagnostic is required

\pnum
\begin{example}
\begin{codeblock}
template<typename T> concept A = T::value || true;
template<typename U> concept B = A<U*>;
template<typename V> concept C = B<V&>; // Ill-formed no diagnostic required, it
					// would form the invalid type V\&* in the parameter mapping
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.spec.partial]{Partial specialization}

\pnum
\ifndrxref{temp.spec.partial.general.partial.reachable} \\
A partial specialization shall be reachable from any use of a template specialization that would make use of the
partial specialization as the result of an implicit or explicit instantiation; no diagnostic is required.

\pnum
\begin{example}
\begin{codeblock}
template<typename T> class X{
public:
  void foo(){};
};

template class X<void *>;       // ill-formed no diagnostic required, explicit instantiation
                                // and partial specialization is not reachable

template<typename T> class X<T*>{
public:
  void baz();
};
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.names]{Names of template specializations}

\pnum
\ifndrxref{temp.names.sat.constraints} \\
When the template-name of a simple-template-id names a constrained non-function template or a constrained
template template-parameter, and all template-arguments in the simple-template-id are non-dependent\iref{temp.dep.temp},
the associated constraints\iref{temp.constr.decl} of the constrained template shall be satisfied\iref{temp.constr.constr}.

\pnum
\begin{example}
\begin{codeblock}
template<typename T> concept C1 = sizeof(T) != sizeof(int);
template<C1 T> using Ptr = T*;

Ptr<int> p; // error: constraints not satisfied

template<typename T>
struct S2 { Ptr<int> x; };      // ill-formed, no diagnostic required
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.fct]{Function templates}

\rSec3[ifndr.temp.over.link]{Function template overloading}

\pnum
\ifndrxref{temp.over.link.equiv.not.equiv} \\
If the validity or meaning of the program depends on whether two constructs are equivalent, and they are
functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
template <int I>
struct A{};

// ill-formed, no diagnostic required, the following declarations are functionally equivalent but not equivalent
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);
\end{codeblock}
\end{example}

\rSec2[ifndr.temp.res]{Name resolution}

\rSec3[ifndr.temp.res.general]{General}

\pnum
\ifndrxref{temp.res.general.default.but.not.found} \\
If the validity or meaning of the program would be changed by considering a default argument or default
template argument introduced in a declaration that is reachable from the point of instantiation of a
specialization\iref{temp.point} but is not found by lookup for the specialization, the program is ill-formed, no
diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
\end{codeblock}
\end{example}

\rSec2[ifndr.temp.dep.res]{Dependent name resolution}

\rSec3[ifndr.temp.point]{Point of instantiation}

\pnum
\ifndrxref{temp.point.diff.pt.diff.meaning} \\
A specialization for a class template has at most one point of instantiation within a translation unit. A
specialization for any template may have points of instantiation in multiple translation units. If two different
points of instantiation give a template specialization different meanings according to the one-definition
rule (6.3), the program is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
// a.h
#include <type_traits>

template <typename T, typename Enabler = void>
struct is_complete : std::false_type {};

template <typename T>
struct is_complete<T, std::void_t<decltype(sizeof(T) != 0)>> : std::true_type {};

// a.cpp
#include "a.h"
struct X;
static_assert(!is_complete<X>::value);

// b.cpp
#include "a.h"
struct X { };
static_assert(is_complete<X>::value);
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.explicit]{Explicit instantiation}

\pnum
\ifndrxref{temp.explicit.decl.implicit.inst} \\
An entity that is the subject of
an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit
instantiation\iref{temp.inst} in the translation unit shall be the subject of an explicit instantiation definition
somewhere in the program; otherwise the program is ill-formed, no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
// Explicit instantiation declaration
extern template class std::vector<int>;

int main() {
  std::cout << std::vector<int>().size();   // ill-formed no diagnostic required, implicit instantiation
                                            // but no explicit instantiation definition
}
\end{codeblock}
\end{example}


\rSec2[ifndr.temp.deduct]{Template argument deduction}

\rSec3[ifndr.temp.deduct.general]{General}

\pnum
\ifndrxref{temp.deduct.general.diff.order} \\
If substitution
into different declarations of the same function template would cause template instantiations to occur in a
different order or not at all, the program is ill-formed; no diagnostic required.

\pnum
\begin{example}
\begin{codeblock}
template <class T> typename T::X h(typename A<T>::X);
template <class T> auto h(typename A<T>::X) -> typename T::X;   // redeclaration
template <class T> void h(...) { }

void x() {
  h<int>(0);    // ill-formed, no diagnostic required
}
\end{codeblock}
\end{example}
