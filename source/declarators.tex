%!TEX root = std.tex
\rSec0[dcl.decl]{Declarators}%
\indextext{declarator|(}

%gram: \rSec1[gram.decl]{Declarators}
%gram:

\indextext{initialization!class~object|seealso{constructor}}%
\indextext{\idxcode{*}|see{declarator, pointer}}
\indextext{\idxcode{\&}|see{declarator, reference}}%
\indextext{\idxcode{::*}|see{declarator, pointer to member}}%
\indextext{\idxcode{[]}|see{declarator, array}}%
\indextext{\idxcode{()}|see{declarator, function}}%

\pnum
A declarator declares a single variable, function, or type, within a declaration.
The
\grammarterm{init-declarator-list}
appearing in a declaration
is a comma-separated sequence of declarators,
each of which can have an initializer.

\begin{bnf}
\nontermdef{init-declarator-list}\br
    init-declarator\br
    init-declarator-list \terminal{,} init-declarator
\end{bnf}

\begin{bnf}
\nontermdef{init-declarator}\br
    declarator initializer\opt
\end{bnf}

\pnum
The three components of a
\grammarterm{simple-declaration}
are the
attributes~(\ref{dcl.attr}), the
specifiers
(\grammarterm{decl-specifier-seq};
\ref{dcl.spec}) and the declarators
(\grammarterm{init-declarator-list}).
The specifiers indicate the type, storage class or other properties of
the entities being declared.
The declarators specify the names of these entities
and (optionally) modify the type of the specifiers with operators such as
\tcode{*}
(pointer
to)
and
\tcode{()}
(function returning).
Initial values can also be specified in a declarator;
initializers are discussed in~\ref{dcl.init} and~\ref{class.init}.

\pnum
Each
\grammarterm{init-declarator}
in a declaration is analyzed separately as if it was in a declaration by
itself.\footnote{A declaration with several declarators is usually equivalent
to the corresponding sequence of declarations each with a single declarator.
That is

\tcode{T  D1, D2, ... Dn;}

\noindent is usually equivalent to

\tcode{T  D1; T D2; ... T Dn;}

\noindent where
\tcode{T}
is a
\grammarterm{decl-specifier-seq}
and each
\tcode{Di}
is an
\grammarterm{init-declarator}.
An exception occurs when a name introduced by one of the
\grammarterm{declarator}{s}
hides a type name used by the
\grammarterm{decl-specifiers},
so that when the same
\grammarterm{decl-specifiers}
are used in a subsequent declaration, they do not have the same meaning,
as in

\tcode{struct S { ... };}\\
\indent\tcode{S S, T; \textrm{// declare two instances of \tcode{struct S}}}

\noindent which is not equivalent to

\tcode{struct S { ... };}\\
\indent\tcode{S S;}\\
\indent\tcode{S T; \textrm{// error}}

\noindent Another exception occurs when \tcode{T} is \tcode{auto}~(\ref{dcl.spec.auto}),
for example:

\tcode{auto i = 1, j = 2.0; \textrm{// error: deduced types for \tcode{i} and \tcode{j} do not match}}\\
\noindent as opposed to\\
\indent\tcode{auto i = 1;    \textrm{// OK: \tcode{i} deduced to have type \tcode{int}}}\\
\indent\tcode{auto j = 2.0;  \textrm{// OK: \tcode{j} deduced to have type \tcode{double}}}
}

\pnum
Declarators have the syntax

\begin{bnf}
\nontermdef{declarator}\br
    ptr-declarator\br
    noptr-declarator parameters-and-qualifiers trailing-return-type
\end{bnf}

\begin{bnf}
\nontermdef{ptr-declarator}\br
    noptr-declarator\br
    ptr-operator ptr-declarator
\end{bnf}

\begin{bnf}
\nontermdef{noptr-declarator}\br
    declarator-id attribute-specifier-seq\opt\br
    noptr-declarator parameters-and-qualifiers\br
    noptr-declarator \terminal{[} constant-expression\opt{} \terminal{]} attribute-specifier-seq\opt\br
    \terminal{(} ptr-declarator \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{parameters-and-qualifiers}\br
    \terminal{(} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt\br
\hspace*{\bnfindentinc}ref-qualifier\opt exception-specification\opt attribute-specifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{trailing-return-type}\br
    \terminal{->} type-id
\end{bnf}

\begin{bnf}
\nontermdef{ptr-operator}\br
    \terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt\br
    \terminal{\&} attribute-specifier-seq\opt\br
    \terminal{\&\&} attribute-specifier-seq\opt\br
    nested-name-specifier \terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{cv-qualifier-seq}\br
    cv-qualifier cv-qualifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{cv-qualifier}\br
    \terminal{const}\br
    \terminal{volatile}
\end{bnf}

\begin{bnf}
\nontermdef{ref-qualifier}\br
    \terminal{\&}\br
    \terminal{\&\&}
\end{bnf}

\begin{bnf}
\nontermdef{declarator-id}\br
    \terminal{...}\opt id-expression
\end{bnf}

\rSec1[dcl.name]{Type names}

\pnum
\indextext{type~name}%
To specify type conversions explicitly,
\indextext{operator!cast}%
and as an argument of
\tcode{sizeof},
\tcode{alignof},
\tcode{new},
or
\tcode{typeid},
the name of a type shall be specified.
This can be done with a
\grammarterm{type-id},
which is syntactically a declaration for a variable or function
of that type that omits the name of the entity.

\begin{bnf}
\nontermdef{type-id}\br
    type-specifier-seq abstract-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{defining-type-id}\br
    defining-type-specifier-seq abstract-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{abstract-declarator}\br
    ptr-abstract-declarator\br
    noptr-abstract-declarator\opt parameters-and-qualifiers trailing-return-type\br
    abstract-pack-declarator
\end{bnf}

\begin{bnf}
\nontermdef{ptr-abstract-declarator}\br
    noptr-abstract-declarator\br
    ptr-operator ptr-abstract-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{noptr-abstract-declarator}\br
    noptr-abstract-declarator\opt parameters-and-qualifiers\br
    noptr-abstract-declarator\opt{} \terminal{[} constant-expression\opt{} \terminal{]} attribute-specifier-seq\opt\br
    \terminal{(} ptr-abstract-declarator \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{abstract-pack-declarator}\br
    noptr-abstract-pack-declarator\br
    ptr-operator abstract-pack-declarator
\end{bnf}

\begin{bnf}
\nontermdef{noptr-abstract-pack-declarator}\br
    noptr-abstract-pack-declarator parameters-and-qualifiers\br
    noptr-abstract-pack-declarator \terminal{[} constant-expression\opt{} \terminal{]} attribute-specifier-seq\opt\br
    \terminal{...}
\end{bnf}

It is possible to identify uniquely the location in the
\grammarterm{abstract-declarator}
where the identifier would appear if the construction were a declarator
in a declaration.
The named type is then the same as the type of the
hypothetical identifier.
\begin{example}

\indextext{example!type~name}%
\indextext{example!declarator}%
\begin{codeblock}
int                 // \tcode{int i}
int *               // \tcode{int *pi}
int *[3]            // \tcode{int *p[3]}
int (*)[3]          // \tcode{int (*p3i)[3]}
int *()             // \tcode{int *f()}
int (*)(double)     // \tcode{int (*pf)(double)}
\end{codeblock}

name respectively the types
``\tcode{int}'',
``pointer to
\tcode{int}'',
``array of 3 pointers to
\tcode{int}'',
``pointer to array of 3
\tcode{int}'',
``function of (no parameters) returning pointer to
\tcode{int}'',
and ``pointer to a function of
(\tcode{double})
returning
\tcode{int}''.
\end{example}

\pnum
A type can also be named (often more easily) by using a
\grammarterm{typedef}
(\ref{dcl.typedef}).

\rSec1[dcl.ambig.res]{Ambiguity resolution}%
\indextext{ambiguity!declaration~versus cast}%
\indextext{declaration!parentheses~in}

\pnum
The ambiguity arising from the similarity between a function-style cast and
a declaration mentioned in~\ref{stmt.ambig} can also occur in the context of a declaration.
In that context, the choice is between a function declaration with
a redundant set of parentheses around a parameter name and an object declaration
with a function-style cast as the initializer.
Just as for the ambiguities mentioned in~\ref{stmt.ambig},
the resolution is to consider any construct that could possibly
be a declaration a declaration.
\begin{note}
A declaration can be explicitly disambiguated by a nonfunction-style
cast, by an
\tcode{=}
to indicate initialization or
by removing the redundant parentheses around the parameter name.
\end{note}
\begin{example}

\begin{codeblock}
struct S {
  S(int);
};

void foo(double a) {
  S w(int(a));      // function declaration
  S x(int());       // function declaration
  S y((int)a);      // object declaration
  S z = int(a);     // object declaration
}
\end{codeblock}
\end{example}

\pnum
The ambiguity arising from the similarity between a function-style
cast and a
\grammarterm{type-id}
can occur in different contexts.
The ambiguity appears as a choice between a function-style cast
expression and a declaration of a type.
The resolution is that any construct that could possibly be a
\grammarterm{type-id}
in its syntactic context shall be considered a
\grammarterm{type-id}.

\pnum
\begin{example}

\begin{codeblock}
#include <cstddef>
char* p;
void* operator new(std::size_t, int);
void foo()  {
  const int x = 63;
  new (int(*p)) int;            // new-placement
  new (int(*[x]));              // parenthesized type-id
}
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
template <class T>
struct S {
  T* p;
};
S<int()> x;                     // type-id
S<int(1)> y;                    // expression (ill-formed)
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
void foo() {
  sizeof(int(1));               // expression
  sizeof(int());                // type-id (ill-formed)
}
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
void foo() {
  (int(1));                     // expression
  (int())1;                     // type-id (ill-formed)
}
\end{codeblock}
\end{example}

\pnum
Another ambiguity arises in a
\grammarterm{parameter-declaration-clause}
of a function declaration, or in a
\grammarterm{type-id}
that is the operand of a
\tcode{sizeof}
or
\tcode{typeid}
operator, when a
\grammarterm{type-name}
is nested in parentheses.
In this case, the choice is between the declaration of a parameter of type
pointer to function and the declaration of a parameter with redundant
parentheses around the
\grammarterm{declarator-id}.
The resolution is to consider the
\grammarterm{type-name}
as a
\grammarterm{simple-type-specifier}
rather than a
\grammarterm{declarator-id}.
\begin{example}

\begin{codeblock}
class C { };
void f(int(C)) { }              // \tcode{void f(int(*fp)(C c)) \{ \}}
                                // not: \tcode{void f(int C)};

int g(C);

void foo() {
  f(1);                         // error: cannot convert \tcode{1} to function pointer
  f(g);                         // OK
}
\end{codeblock}

For another example,

\begin{codeblock}
class C { };
void h(int *(C[10]));           // \tcode{void h(int *(*_fp)(C _parm[10]));}
                                // not: \tcode{void h(int *C[10]);}
\end{codeblock}
\end{example}

\rSec1[dcl.meaning]{Meaning of declarators}%
\indextext{declarator!meaning~of|(}

\pnum
\indextext{declaration!type}%
A declarator contains exactly one
\grammarterm{declarator-id};
it names the identifier that is declared.
An
\grammarterm{unqualified-id}
occurring in
a
\grammarterm{declarator-id}
shall be a simple
\grammarterm{identifier}
except for the declaration of some special functions~(\ref{class.ctor},
\ref{class.conv}, \ref{class.dtor}, \ref{over.oper}) and
for the declaration of template specializations
or partial specializations~(\ref{temp.spec}).
When the
\grammarterm{declarator-id}
is qualified, the declaration shall refer to a previously declared member
of the class or namespace to which the qualifier refers (or,
in the case of a namespace,
of an element of the inline namespace
set of that namespace~(\ref{namespace.def})) or to a specialization thereof; the member
shall not merely have been introduced by a
\grammarterm{using-declaration}
in the scope of the class or namespace nominated by the
\grammarterm{nested-name-specifier}
of the
\grammarterm{declarator-id}.
The \grammarterm{nested-name-specifier} of a qualified \grammarterm{declarator-id} shall not
begin with a \grammarterm{decltype-specifier}.
\begin{note}
If the qualifier is the global
\tcode{::}
scope resolution operator, the
\grammarterm{declarator-id}
refers to a name declared in the global namespace scope.
\end{note}
The optional \grammarterm{attribute-specifier-seq} following a \grammarterm{declarator-id} appertains to the entity that is declared.

\pnum
A
\tcode{static},
\tcode{thread_local},
\tcode{extern},
\tcode{mutable},
\tcode{friend},
\tcode{inline},
\tcode{virtual},
\tcode{constexpr},
\tcode{explicit},
or
\tcode{typedef}
specifier applies directly to each \grammarterm{declarator-id}
in an \grammarterm{init-declarator-list} or \grammarterm{member-declarator-list};
the type specified for each \grammarterm{declarator-id} depends on
both the \grammarterm{decl-specifier-seq} and its \grammarterm{declarator}.

\pnum
Thus, a declaration of a particular identifier has the form

\begin{codeblock}
T D
\end{codeblock}

where
\tcode{T}
is of the form \grammarterm{attribute-specifier-seq\opt}
\grammarterm{decl-specifier-seq}
and
\tcode{D}
is a declarator.
Following is a recursive procedure for determining
the type specified for the contained
\grammarterm{declarator-id}
by such a declaration.

\pnum
First, the
\grammarterm{decl-specifier-seq}
determines a type.
In a declaration

\begin{codeblock}
T D
\end{codeblock}

the
\grammarterm{decl-specifier-seq}
\tcode{T}
determines the type
\tcode{T}.
\begin{example}
in the declaration

\begin{codeblock}
int unsigned i;
\end{codeblock}

the type specifiers
\tcode{int}
\tcode{unsigned}
determine the type
``\tcode{unsigned int}''
(\ref{dcl.type.simple}).
\end{example}

\pnum
In a declaration
\grammarterm{attribute-specifier-seq\opt}
\tcode{T}
\tcode{D}
where
\tcode{D}
is an unadorned identifier the type of this identifier is
``\tcode{T}''.

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
( D1 )
\end{ncsimplebnf}

the type of the contained
\grammarterm{declarator-id}
is the same as that of the contained
\grammarterm{declarator-id}
in the declaration

\begin{codeblock}
T D1
\end{codeblock}

\indextext{declaration!parentheses~in}%
Parentheses do not alter the type of the embedded
\grammarterm{declarator-id},
but they can alter the binding of complex declarators.

\rSec2[dcl.ptr]{Pointers}%
\indextext{declarator!pointer}%

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt{} \terminal{D1}
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T}'',
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list cv-qualifier-seq} pointer to
\tcode{T}''.
\indextext{declaration!pointer}%
\indextext{declaration!constant~pointer}%
The
\grammarterm{cv-qualifier}{s}
apply to the pointer and not to the object pointed to.
Similarly, the optional \grammarterm{attribute-specifier-seq}~(\ref{dcl.attr.grammar}) appertains to the pointer and not to the object pointed to.

\pnum
\begin{example}
the declarations
\indextext{example!\idxcode{const}}%
\indextext{example!constant pointer}%
\begin{codeblock}
const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;
\end{codeblock}

declare
\tcode{ci},
a constant integer;
\tcode{pc},
a pointer to a constant integer;
\tcode{cpc},
a constant pointer to a constant integer;
\tcode{ppc},
a pointer to a pointer to a constant integer;
\tcode{i},
an integer;
\tcode{p},
a pointer to integer; and
\tcode{cp},
a constant pointer to integer.
The value of
\tcode{ci},
\tcode{cpc},
and
\tcode{cp}
cannot be changed after initialization.
The value of
\tcode{pc}
can be changed, and so can the object pointed to by
\tcode{cp}.
Examples of
some correct operations are

\begin{codeblock}
i = ci;
*cp = ci;
pc++;
pc = cpc;
pc = p;
ppc = &pc;
\end{codeblock}

Examples of ill-formed operations are

\begin{codeblock}
ci = 1;             // error
ci++;               // error
*pc = 2;            // error
cp = &ci;           // error
cpc++;              // error
p = pc;             // error
ppc = &p;           // error
\end{codeblock}

Each is unacceptable because it would either change the value of an object declared
\tcode{const}
or allow it to be changed through a cv-unqualified pointer later, for example:

\begin{codeblock}
*ppc = &ci;         // OK, but would make \tcode{p} point to \tcode{ci} ...
                    // ... because of previous error
*p = 5;             // clobber \tcode{ci}
\end{codeblock}
\end{example}

\pnum
See also~\ref{expr.ass} and~\ref{dcl.init}.

\pnum
\begin{note}
Forming a pointer to reference type is ill-formed; see~\ref{dcl.ref}.
Forming a function pointer type is ill-formed if the function type has
\grammarterm{cv-qualifier}{s} or a \grammarterm{ref-qualifier};
see~\ref{dcl.fct}.
Since the address of a bit-field (\ref{class.bit}) cannot be taken,
a pointer can never point to a bit-field.
\end{note}

\rSec2[dcl.ref]{References}%
\indextext{declarator!reference}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has either of the forms

\begin{ncsimplebnf}
\terminal{\&} attribute-specifier-seq\opt{} \terminal{D1}\br
\terminal{\&\&} attribute-specifier-seq\opt{} \terminal{D1}
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T}'',
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} reference to
\tcode{T}''.
The optional \grammarterm{attribute-specifier-seq} appertains to the reference type.
Cv-qualified references are ill-formed except when the cv-qualifiers
are introduced through the use of a
\grammarterm{typedef-name}~(\ref{dcl.typedef}, \ref{temp.param}) or
\grammarterm{decltype-specifier}~(\ref{dcl.type.simple}),
in which case the cv-qualifiers are ignored.
\begin{example}

\begin{codeblock}
typedef int& A;
const A aref = 3;   // ill-formed; lvalue reference to non-\tcode{const} initialized with rvalue
\end{codeblock}

The type of
\tcode{aref}
is ``lvalue reference to \tcode{int}'',
not ``lvalue reference to \tcode{const int}''.
\end{example}
\begin{note}
A reference can be thought of as a name of an object.
\end{note}
\indextext{\idxcode{void\&}}%
A declarator that specifies the type
``reference to \textit{cv} \tcode{void}''
is ill-formed.


\pnum
\indextext{lvalue~reference}%
\indextext{rvalue~reference}%
A reference type that is declared using \tcode{\&} is called an
\term{lvalue reference}, and a reference type that
is declared using \tcode{\&\&} is called an
\term{rvalue reference}. Lvalue references and
rvalue references are distinct types. Except where explicitly noted, they are
semantically equivalent and commonly referred to as references.

\pnum
\indextext{declaration!reference}%
\indextext{parameter!reference}%
\begin{example}

\begin{codeblock}
void f(double& a) { a += 3.14; }
// ...
double d = 0;
f(d);
\end{codeblock}

declares
\tcode{a}
to be a reference parameter of
\tcode{f}
so the call
\tcode{f(d)}
will add
\tcode{3.14}
to
\tcode{d}.

\begin{codeblock}
int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;
\end{codeblock}

declares the function
\tcode{g()}
to return a reference to an integer so
\tcode{g(3)=7}
will assign
\tcode{7}
to the fourth element of the array
\tcode{v}.
For another example,

\begin{codeblock}
struct link {
  link* next;
};

link* first;

void h(link*& p) {  // \tcode{p} is a reference to pointer
  p->next = first;
  first = p;
  p = 0;
}

void k() {
   link* q = new link;
   h(q);
}
\end{codeblock}

declares
\tcode{p}
to be a reference to a pointer to
\tcode{link}
so
\tcode{h(q)}
will leave
\tcode{q}
with the value zero.
See also~\ref{dcl.init.ref}.
\end{example}

\pnum
It is unspecified whether or not
a reference requires storage (\ref{basic.stc}).

\pnum
\indextext{restriction!reference}%
There shall be no references to references,
no arrays of references, and no pointers to references.
\indextext{initialization!reference}%
The declaration of a reference shall contain an
\grammarterm{initializer}
(\ref{dcl.init.ref})
except when the declaration contains an explicit
\tcode{extern}
specifier (\ref{dcl.stc}),
is a class member (\ref{class.mem}) declaration within a class definition,
or is the declaration of a parameter or a return type (\ref{dcl.fct}); see~\ref{basic.def}.
A reference shall be initialized to refer to a valid object or function.
\begin{note}
\indextext{reference!null}%
in particular, a null reference cannot exist in a well-defined program,
because the only way to create such a reference would be to bind it to
the ``object'' obtained by indirection through a null pointer,
which causes undefined behavior.
As described in~\ref{class.bit}, a reference cannot be bound directly
to a bit-field.
\end{note}

\pnum
\indextext{reference collapsing}%
If a \grammarterm{typedef-name}~(\ref{dcl.typedef}, \ref{temp.param})
or a \grammarterm{decltype-specifier}~(\ref{dcl.type.simple}) denotes a type \tcode{TR} that
is a reference to a type \tcode{T}, an attempt to create the type ``lvalue reference to \cv\ 
\tcode{TR}'' creates the type ``lvalue reference to \tcode{T}'', while an attempt to create
the type ``rvalue reference to \cv\ \tcode{TR}'' creates the type \tcode{TR}. \begin{example}

\begin{codeblock}
int i;
typedef int& LRI;
typedef int&& RRI;

LRI& r1 = i;                    // \tcode{r1} has the type \tcode{int\&}
const LRI& r2 = i;              // \tcode{r2} has the type \tcode{int\&}
const LRI&& r3 = i;             // \tcode{r3} has the type \tcode{int\&}

RRI& r4 = i;                    // \tcode{r4} has the type \tcode{int\&}
RRI&& r5 = 5;                   // \tcode{r5} has the type \tcode{int\&\&}

decltype(r2)& r6 = i;           // \tcode{r6} has the type \tcode{int\&}
decltype(r2)&& r7 = i;          // \tcode{r7} has the type \tcode{int\&}
\end{codeblock}
\end{example}

\pnum
\begin{note} Forming a reference to function type is ill-formed if the function
type has \grammarterm{cv-qualifier}{s} or a \grammarterm{ref-qualifier};
see~\ref{dcl.fct}.
\end{note}

\rSec2[dcl.mptr]{Pointers to members}%
\indextext{declarator!pointer to member}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
nested-name-specifier \terminal{*} attribute-specifier-seq\opt cv-qualifier-seq\opt \tcode{D1}
\end{ncsimplebnf}

and the
\grammarterm{nested-name-specifier}
denotes a class,
and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T}'',
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list cv-qualifier-seq} pointer to member of class
\nonterminal{nested-name-specifier} of type
\tcode{T}''.
The optional \grammarterm{attribute-specifier-seq}~(\ref{dcl.attr.grammar}) appertains to the 
pointer-to-member.

\pnum
\begin{example}%
\indextext{example!pointer~to~member}

\begin{codeblock}
struct X {
  void f(int);
  int a;
};
struct Y;

int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X::* pmd;
char Y::* pmc;
\end{codeblock}

declares
\tcode{pmi},
\tcode{pmf},
\tcode{pmd}
and
\tcode{pmc}
to be a pointer to a member of
\tcode{X}
of type
\tcode{int},
a pointer to a member of
\tcode{X}
of type
\tcode{void(int)},
a pointer to a member of
\tcode{X}
of type
\tcode{double}
and a pointer to a member of
\tcode{Y}
of type
\tcode{char}
respectively.
The declaration of
\tcode{pmd}
is well-formed even though
\tcode{X}
has no members of type
\tcode{double}.
Similarly, the declaration of
\tcode{pmc}
is well-formed even though
\tcode{Y}
is an incomplete type.
\tcode{pmi}
and
\tcode{pmf}
can be used like this:

\begin{codeblock}
X obj;
// ...
obj.*pmi = 7;       // assign \tcode{7} to an integer
                    // member of \tcode{obj}
(obj.*pmf)(7);      // call a function member of \tcode{obj}
                    // with the argument \tcode{7}
\end{codeblock}
\end{example}

\pnum
A pointer to member shall not point to a static member
of a class (\ref{class.static}),
a member with reference type,
or
``\textit{cv}
\tcode{void}''.

\begin{note}
See also~\ref{expr.unary} and~\ref{expr.mptr.oper}.
The type ``pointer to member'' is distinct from the type ``pointer'',
that is, a pointer to member is declared only by the pointer to member
declarator syntax, and never by the pointer declarator syntax.
There is no ``reference-to-member'' type in \Cpp.
\end{note}

\rSec2[dcl.array]{Arrays}%
\indextext{declarator!array}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{D1 [} constant-expression\opt{} \terminal{]} attribute-specifier-seq\opt
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is
``\grammarterm{derived-declarator-type-list}
\tcode{T}'',
then the type of the identifier of
\tcode{D}
is an array type; if the type of the identifier of \tcode{D}
contains the \tcode{auto} \nonterminal{type-specifier},
the program is ill-formed.
\tcode{T}
is called the array
\term{element type};
this type shall not be a reference type, the (possibly cv-qualified) type
\tcode{void},
a function type or an abstract class type.
\indextext{declaration!array}%
If the
\grammarterm{constant-expression}
(\ref{expr.const}) is present, it shall be a converted constant
expression of type \tcode{std\colcol{}size_t} and
its value shall be greater than zero.
The constant expression specifies the
\indextext{array!bound}%
\indextext{bound,~of~array}%
\term{bound}
of (number of elements in) the array.
If the value of the constant expression is
\tcode{N},
the array has
\tcode{N}
elements numbered
\tcode{0}
to
\tcode{N-1},
and the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} array of
\tcode{N}
\tcode{T}''.
An object of array type contains a contiguously allocated non-empty set of
\tcode{N}
subobjects of type
\tcode{T}.
Except as noted below, if
the constant expression is omitted, the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} array of unknown bound of
\tcode{T}'',
an incomplete object type.
The type ``\nonterminal{derived-declarator-type-list} array of
\tcode{N}
\tcode{T}''
is a different type from the type
``\nonterminal{derived-declarator-type-list} array of unknown bound of
\tcode{T}'',
see~\ref{basic.types}.
Any type of the form
``\nonterminal{cv-qualifier-seq} array of
\tcode{N}
\tcode{T}''
is adjusted to
``array of
\tcode{N}
\nonterminal{cv-qualifier-seq}
\tcode{T}'',
and similarly for
``array of unknown bound of
\tcode{T}''.
The optional \grammarterm{attribute-specifier-seq} appertains to the array.
\begin{example}

\begin{codeblock}
typedef int A[5], AA[2][3];
typedef const A CA;             // type is ``array of 5 \tcode{const int}''
typedef const AA CAA;           // type is ``array of 2 array of 3 \tcode{const int}''
\end{codeblock}
\end{example}
\begin{note}
An
``array of
\tcode{N}
\nonterminal{cv-qualifier-seq}
\tcode{T}''
has cv-qualified type; see~\ref{basic.type.qualifier}.
\end{note}

\pnum
An array can be constructed from one of the fundamental types
(except
\tcode{void}),
from a pointer,
from a pointer to member, from a class,
from an enumeration type,
or from another array.

\pnum
When several ``array of'' specifications are adjacent, a multidimensional
array type is created;
only the first of
the constant expressions that specify the bounds
of the arrays may be omitted.
In addition to declarations in which an incomplete object type is allowed,
an array bound may be omitted in some cases in the declaration of a function
parameter~(\ref{dcl.fct}).
An array bound may also be omitted
when the declarator is followed by an
\grammarterm{initializer}~(\ref{dcl.init}) or
when a declarator for a static data member is followed by a
\grammarterm{brace-or-equal-initializer}~(\ref{class.mem}).
In both cases the bound is calculated from the number
\indextext{array~size!default}%
of initial elements (say,
\tcode{N})
supplied
(\ref{dcl.init.aggr}), and the type of the identifier of
\tcode{D}
is ``array of
\tcode{N}
\tcode{T}''.
Furthermore, if there is a preceding declaration of the entity in the same
scope in which the bound was specified, an omitted array bound is taken to
be the same as in that earlier declaration, and similarly for the definition
of a static data member of a class.

\pnum
\begin{example}
\indextext{example!subscripting}%
\indextext{example!array}%
\begin{codeblock}
float fa[17], *afp[17];
\end{codeblock}

declares an array of
\tcode{float}
numbers and an array of
pointers to
\tcode{float}
numbers.
\indextext{declarator!multidimensional array}%
For another example,

\begin{codeblock}
static int x3d[3][5][7];
\end{codeblock}

declares a static three-dimensional array of integers,
with rank $3 \times 5 \times 7$.
In complete detail,
\tcode{x3d}
is an array of three items;
each item is an array of five arrays;
each of the latter arrays is an array of seven
integers.
Any of the expressions
\tcode{x3d},
\tcode{x3d[i]},
\tcode{x3d[i][j]},
\tcode{x3d[i][j][k]}
can reasonably appear in an expression. Finally,
\begin{codeblock}
extern int x[10];
struct S {
  static int y[10];
};

int x[];                      // OK: bound is 10
int S::y[];                   // OK: bound is 10

void f() {
  extern int x[];
  int i = sizeof(x);          // error: incomplete object type
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
conversions affecting expressions of array type are described in~\ref{conv.array}.
Objects of array types cannot be modified, see~\ref{basic.lval}.
\end{note}

\pnum
\begin{note}
Except where it has been declared for a class (\ref{over.sub}),
the subscript operator
\tcode{[]}
is interpreted
in such a way that
\tcode{E1[E2]}
is identical to
\tcode{*((E1)+(E2))}.
Because of the conversion rules
that apply to
\tcode{+},
if
\tcode{E1}
is an array and
\tcode{E2}
an integer,
then
\tcode{E1[E2]}
refers to the
\tcode{E2}-th
member of
\tcode{E1}.
Therefore,
despite its asymmetric
appearance, subscripting is a commutative operation.

\pnum
A consistent rule is followed for
\indextext{array!multidimensional}%
multidimensional arrays.
If
\tcode{E}
is an
\textit{n}-dimensional
array
of rank
$i \times j \times \ldots \times k$,
then
\tcode{E}
appearing in an expression
that is subject to the array-to-pointer conversion~(\ref{conv.array})
is converted to
a pointer to an $(n-1)$-dimensional
array with rank
$j \times \ldots \times k$.
If the
\tcode{*}
operator, either explicitly
or implicitly as a result of subscripting,
is applied to this pointer,
the result is the pointed-to $(n-1)$-dimensional array,
which itself is immediately converted into a pointer.

\pnum
\begin{example}
consider

\begin{codeblock}
int x[3][5];
\end{codeblock}

Here
\tcode{x}
is a $3 \times 5$ array of integers.
When
\tcode{x}
appears in an expression, it is converted
to a pointer to (the first of three) five-membered arrays of integers.
In the expression
\tcode{x[i]}
which is equivalent to
\tcode{*(x+i)},
\tcode{x}
is first converted to a pointer as described;
then
\tcode{x+i}
is converted to the type of
\tcode{x},
which involves multiplying
\tcode{i}
by the
length of the object to which the pointer points,
namely five integer objects.
The results are added and indirection applied to
yield an array (of five integers), which in turn is converted to
a pointer to the first of the integers.
If there is another subscript the same argument applies
again; this time the result is an integer.
\end{example}
\end{note}

\pnum
\begin{note}
It follows from all this that arrays in \Cpp are stored
row-wise (last subscript varies fastest)
\indextext{array!storage~of}%
and that the first subscript in the declaration helps determine
the amount of storage consumed by an array
but plays no other part in subscript calculations.
\end{note}

\rSec2[dcl.fct]{Functions}%
\indextext{declarator!function|(}

\pnum
\indextext{type!function}%
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{D1 (} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt\br
\hspace*{\bnfindentinc}ref-qualifier\opt exception-specification\opt attribute-specifier-seq\opt
\end{ncsimplebnf}

and the type of the contained
\grammarterm{declarator-id}
in the declaration
\tcode{T}
\tcode{D1}
is
``\grammarterm{derived-declarator-type-list}
\tcode{T}'',
the type of the
\grammarterm{declarator-id}
in
\tcode{D}
is
``\grammarterm{derived-declarator-type-list}
\tcode{noexcept}\opt
function of
(\grammarterm{parameter-declaration-clause} )
\grammarterm{cv-qualifier-seq\opt} \grammarterm{ref-qualifier\opt}
returning \tcode{T}'',
where the optional \tcode{noexcept} is present
if and only if
the \grammarterm{exception-specification} is non-throwing.
The optional \grammarterm{attribute-specifier-seq}
appertains to the function type.

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{D1 (} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt\br
\hspace*{\bnfindentinc}ref-qualifier\opt exception-specification\opt attribute-specifier-seq\opt trailing-return-type
\end{ncsimplebnf}

and the type of the contained
\grammarterm{declarator-id}
in the declaration
\tcode{T}
\tcode{D1}
is
``\grammarterm{derived-declarator-type-list} \tcode{T}'',
\tcode{T} shall be the single \grammarterm{type-specifier} \tcode{auto}.
The type of the
\grammarterm{declarator-id}
in
\tcode{D}
is
``\grammarterm{derived-declarator-type-list}
\tcode{noexcept}\opt
function of
(\grammarterm{parameter-declaration-clause})
\grammarterm{cv-qualifier-seq}\opt \grammarterm{ref-qualifier}\opt
returning \tcode{U}'',
where \tcode{U} is the type specified by
the \grammarterm{trailing-return-type}, and
where the optional \tcode{noexcept} is present if and only if
the \grammarterm{exception-specification} is non-throwing.
The optional \grammarterm{attribute-specifier-seq}
appertains to the function type.

\pnum
\indextext{type!function}%
A type of either form is a \term{function type}.\footnote{As indicated by syntax, cv-qualifiers are a significant component in function return types.}

\indextext{declaration!function}%
\begin{bnf}
\nontermdef{parameter-declaration-clause}\br
parameter-declaration-list\opt{} \terminal{...}\opt\br
    parameter-declaration-list \terminal{, ...}
\end{bnf}

\begin{bnf}
\nontermdef{parameter-declaration-list}\br
    parameter-declaration\br
    parameter-declaration-list \terminal{,} parameter-declaration
\end{bnf}

\begin{bnf}
\nontermdef{parameter-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq declarator\br
    attribute-specifier-seq\opt decl-specifier-seq declarator \terminal{=} initializer-clause\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt{} \terminal{=} initializer-clause
\end{bnf}

The optional \grammarterm{attribute-specifier-seq} in a \grammarterm{parameter-declaration}
appertains to the parameter.

\pnum
\indextext{declaration!parameter}%
The
\grammarterm{parameter-declaration-clause}
determines the arguments that can be specified, and their processing, when the function is called.
\begin{note}
\indextext{conversion!argument}%
the
\grammarterm{parameter-declaration-clause}
is used to convert the arguments specified on the function call;
see~\ref{expr.call}.
\end{note}
\indextext{argument~list!empty}%
If the
\grammarterm{parameter-declaration-clause}
is empty, the function takes no arguments.
A parameter list consisting of a single unnamed parameter of
non-dependent type \tcode{void} is equivalent to an empty parameter
list.
\indextext{parameter!\idxcode{void}}%
Except for this special case, a parameter shall not have type \term{cv}
\tcode{void}.
If the
\grammarterm{parameter-declaration-clause}
\indextext{argument~type!unknown}%
\indextext{\idxcode{...}|see{ellipsis}}%
\indextext{declaration!ellipsis~in function}%
\indextext{argument~list!variable}%
\indextext{parameter~list!variable}%
terminates with an ellipsis or a function parameter
pack~(\ref{temp.variadic}), the number of arguments shall be equal
to or greater than the number of parameters that do not have a default
argument and are not function parameter packs.
Where syntactically correct and where ``\tcode{...}'' is not
part of an \grammarterm{abstract-declarator},
``\tcode{, ...}''
is synonymous with
``\tcode{...}''.
\begin{example}
\indextext{example!ellipsis}%
\indextext{example!variable parameter~list}%
the declaration

\begin{codeblock}
int printf(const char*, ...);
\end{codeblock}

declares a function that can be called with varying numbers and types of arguments.

\begin{codeblock}
printf("hello world");
printf("a=%d b=%d", a, b);
\end{codeblock}

However, the first argument must be of a type
that can be converted to a
\tcode{const}
\tcode{char*}
\end{example}
\begin{note}
The standard header
\tcode{<cstdarg>}
\indextext{\idxhdr{cstdarg}}%
contains a mechanism for accessing arguments passed using the ellipsis
(see~\ref{expr.call} and~\ref{support.runtime}).
\end{note}

\pnum
\indextext{overloading}%
\indextext{type!function}%
A single name can be used for several different functions in a single scope;
this is function overloading (Clause~\ref{over}).
All declarations for a function shall agree exactly
in both the return type and the parameter-type-list.
The type of a function is determined using the following rules.
The type of each parameter (including function parameter packs) is
determined from its own
\grammarterm{decl-specifier-seq}
and
\grammarterm{declarator}.
After determining the type of each parameter, any parameter
\indextext{array!parameter~of~type}%
of type ``array of \tcode{T}'' or
\indextext{function!parameter~of~type}%
of function type \tcode{T}
is adjusted to be ``pointer to \tcode{T}''.
After producing the list of parameter types,
any top-level
\grammarterm{cv-qualifier}{s}
modifying a parameter type are deleted
when forming the function type.
The resulting list of transformed parameter types
and the presence or absence of the ellipsis or a function parameter pack
is the function's
\grammarterm{parameter-type-list}.
\begin{note} This transformation does not affect the types of the parameters.
For example, \tcode{int(*)(const int p, decltype(p)*)} and
\tcode{int(*)(int, const int*)} are identical types. \end{note}

\pnum
A function type with a \grammarterm{cv-qualifier-seq} or a
\grammarterm{ref-qualifier} (including a type named by
\grammarterm{typedef-name}~(\ref{dcl.typedef}, \ref{temp.param}))
shall appear only as:
\begin{itemize}
\item the function type for a non-static member function,

\item the function type to which a pointer to member refers,

\item the top-level function type of a function typedef declaration
or \grammarterm{alias-declaration},

\item the \grammarterm{type-id} in the default argument of a
\grammarterm{type-parameter}~(\ref{temp.param}), or

\item the \grammarterm{type-id} of a \grammarterm{template-argument} for a
\grammarterm{type-parameter}~(\ref{temp.arg.type}).
\end{itemize}
\begin{example}

\begin{codeblock}
typedef int FIC(int) const;
FIC f;              // ill-formed: does not declare a member function
struct S {
  FIC f;            // OK
};
FIC S::*pm = &S::f; // OK
\end{codeblock}
\end{example}

\pnum
The effect of a
\grammarterm{cv-qualifier-seq}
in a function declarator is not the same as
adding cv-qualification on top of the function type.
In the latter case, the cv-qualifiers are ignored.
\begin{note} a function type that has a \grammarterm{cv-qualifier-seq} is not a
cv-qualified type; there are no cv-qualified function types. \end{note}
\begin{example}

\begin{codeblock}
typedef void F();
struct S {
  const F f;        // OK: equivalent to: \tcode{void f();}
};
\end{codeblock}
\end{example}

\pnum
The return type, the parameter-type-list, the \grammarterm{ref-qualifier},
the \grammarterm{cv-qualifier-seq}, and
whether the function has a non-throwing \grammarterm{exception-specification},
but not the default arguments (\ref{dcl.fct.default})
or the exception specification (\ref{except.spec}),
are part of the function type.
\begin{note}
Function types are checked during the assignments and initializations of
pointers to functions, references to functions, and pointers to member functions.
\end{note}

\pnum
\begin{example}
\indextext{example!function declaration}%
the declaration

\begin{codeblock}
int fseek(FILE*, long, int);
\end{codeblock}

declares a function taking three arguments of the specified types,
and returning
\tcode{int}
(\ref{dcl.type}).
\end{example}

\pnum
\indextext{function~return~type|see{return~type}}%
\indextext{return~type}%
Functions shall not have a return type of type array or function,
although they may have a return type of type pointer or reference to such things.
There shall be no arrays of functions, although there can be arrays of pointers
to functions.

\pnum
Types shall not be defined in return or parameter types.
The type of a parameter or the return type for a function
definition shall not be an incomplete
(possibly cv-qualified) class type
in the context of the function definition
unless the function is
deleted~(\ref{dcl.fct.def.delete}).

\pnum
\indextext{typedef!function}%
A typedef of function type may be used to declare a function but shall not be
used to define a function (\ref{dcl.fct.def}).
\begin{example}

\begin{codeblock}
typedef void F();
F  fv;              // OK: equivalent to \tcode{void fv();}
F  fv { }           // ill-formed
void fv() { }       // OK: definition of \tcode{fv}
\end{codeblock}
\end{example}

\pnum
An identifier can optionally be provided as a parameter name;
if present in a function definition (\ref{dcl.fct.def}), it names a parameter.
\begin{note}
In particular, parameter names are also optional in function definitions
and names used for a parameter in different declarations and the definition
of a function need not be the same.
If a parameter name is present in a function declaration that is not a definition,
it cannot be used outside of
its function declarator because that is the extent of its potential scope~(\ref{basic.scope.proto}).
\end{note}

\pnum
\begin{example}
the declaration

\indextext{example!declaration}%
\begin{codeblock}
int i,
    *pi,
    f(),
    *fpi(int),
    (*pif)(const char*, const char*),
    (*fpif(int))(int);
\end{codeblock}

declares an integer
\tcode{i},
a pointer
\tcode{pi}
to an integer,
a function
\tcode{f}
taking no arguments and returning an integer,
a function
\tcode{fpi}
taking an integer argument and returning a pointer to an integer,
a pointer
\tcode{pif}
to a function which
takes two pointers to constant characters and returns an integer,
a function
\tcode{fpif}
taking an integer argument and returning a pointer to a function that takes an integer argument and returns an integer.
It is especially useful to compare
\tcode{fpi}
and
\tcode{pif}.
The binding of
\tcode{*fpi(int)}
is
\tcode{*(fpi(int))},
so the declaration suggests,
and the same construction in an expression
requires, the calling of a function
\tcode{fpi},
and then using indirection through the (pointer) result
to yield an integer.
In the declarator
\tcode{(*pif)(const char*, const char*)},
the extra parentheses are necessary to indicate that indirection through
a pointer to a function yields a function, which is then called.
\end{example}
\begin{note}
Typedefs and \grammarterm{trailing-return-type}{s} are sometimes convenient when the return type of a function is complex.
For example,
the function
\tcode{fpif}
above could have been declared

\begin{codeblock}
typedef int  IFUNC(int);
IFUNC*  fpif(int);
\end{codeblock}

or

\begin{codeblock}
auto fpif(int)->int(*)(int);
\end{codeblock}

A \grammarterm{trailing-return-type} is most useful for a type that would be more complicated to specify before the \grammarterm{declarator-id}:

\begin{codeblock}
template <class T, class U> auto add(T t, U u) -> decltype(t + u);
\end{codeblock}

rather than

\begin{codeblock}
template <class T, class U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);
\end{codeblock}
\end{note}

\pnum
A \term{non-template function} is a function that is not a function template
specialization. \begin{note} A function template is not a function. \end{note}

\pnum
A \grammarterm{declarator-id} or \grammarterm{abstract-declarator}
containing an ellipsis shall only
be used in a \grammarterm{parameter-declaration}. Such a
\grammarterm{parameter-declaration} is a parameter
pack~(\ref{temp.variadic}). When it is part of a
\grammarterm{parameter-declaration-clause}, the parameter pack is a
function parameter pack~(\ref{temp.variadic}). \begin{note}
Otherwise, the \grammarterm{parameter-declaration} is part of a
\grammarterm{template-parameter-list} and the parameter pack is a
template parameter pack; see~\ref{temp.param}. \end{note}
A function parameter pack is a pack expansion~(\ref{temp.variadic}).
\begin{example}

\begin{codeblock}
template<typename... T> void f(T (* ...t)(int, int));

int add(int, int);
float subtract(int, int);

void g() {
  f(add, subtract);
}
\end{codeblock}
\end{example}

\pnum
There is a syntactic ambiguity when an ellipsis occurs at the end
of a \grammarterm{parameter-declaration-clause} without a preceding
comma. In this case, the ellipsis is parsed as part of the
\grammarterm{abstract-declarator} if the type of the parameter either names
a template parameter pack that has not been expanded or contains \tcode{auto};
otherwise, it is
parsed as part of the \grammarterm{parameter-declaration-clause}.\footnote{One can explicitly disambiguate the parse either by
introducing a comma (so the ellipsis will be parsed as part of the
\grammarterm{parameter-declaration-clause}) or by introducing a name for the
parameter (so the ellipsis will be parsed as part of the
\grammarterm{declarator-id}).}%
\indextext{declarator!function|)}

\rSec2[dcl.fct.default]{Default arguments}%
\indextext{declaration!default argument|(}

\pnum
If an \grammarterm{initializer-clause}{} is specified in a
\grammarterm{parameter-declaration}{} this
\grammarterm{initializer-clause}{}
is used as a default argument.
Default arguments will be used in calls where trailing arguments are missing.

\pnum
\indextext{argument!example~of default}%
\begin{example}
the declaration

\begin{codeblock}
void point(int = 3, int = 4);
\end{codeblock}

declares a function that can be called with zero, one, or two arguments of type
\tcode{int}.
It can be called in any of these ways:

\begin{codeblock}
point(1,2);  point(1);  point();
\end{codeblock}

The last two calls are equivalent to
\tcode{point(1,4)}
and
\tcode{point(3,4)},
respectively.
\end{example}

\pnum
A default argument shall be specified only in the
\grammarterm{parameter-declaration-clause}
of a function declaration
or \grammarterm{lambda-declarator}
or in a
\grammarterm{template-parameter}
(\ref{temp.param});
in the latter case, the \grammarterm{initializer-clause} shall be an
\grammarterm{assignment-expression}.
A default argument shall not be specified for a parameter pack.
If it is specified in a
\grammarterm{parameter-declaration-clause},
it shall not occur within a
\grammarterm{declarator}
or
\grammarterm{abstract-declarator}
of a
\grammarterm{parameter-declaration}.\footnote{This means that default
arguments cannot appear,
for example, in declarations of pointers to functions,
references to functions, or
\tcode{typedef}
declarations.
}

\pnum
For non-template functions, default arguments can be added in later
declarations of a
function in the same scope.
Declarations in different
scopes have completely distinct sets of default arguments.
That
is, declarations in inner scopes do not acquire default
arguments from declarations in outer scopes, and vice versa.
In
a given function declaration, each parameter subsequent to a
parameter with a default argument shall have a default argument
supplied in this or a previous declaration
or shall be a function parameter pack.
A default argument
shall not be redefined by a later declaration (not even to the
same value).
\begin{example}

\begin{codeblock}
void g(int = 0, ...);           // OK, ellipsis is not a parameter so it can follow
                                // a parameter with a default argument
void f(int, int);
void f(int, int = 7);
void h() {
  f(3);                         // OK, calls \tcode{f(3, 7)}
  void f(int = 1, int);         // error: does not use default
                                // from surrounding scope
}
void m() {
  void f(int, int);             // has no defaults
  f(4);                         // error: wrong number of arguments
  void f(int, int = 5);         // OK
  f(4);                         // OK, calls \tcode{f(4, 5);}
  void f(int, int = 5);         // error: cannot redefine, even to
                                // same value
}
void n() {
  f(6);                         // OK, calls \tcode{f(6, 7)}
}
\end{codeblock}
\end{example}
For a given inline function defined in different translation units,
the accumulated sets of default arguments at the end of the
translation units shall be the same;
see~\ref{basic.def.odr}.
If a friend declaration specifies a default argument expression,
that declaration shall be a definition and shall be the only
declaration of the function or function template in the translation unit.

\pnum
\indextext{argument!type~checking~of default}%
\indextext{argument!binding~of default}%
\indextext{argument!evaluation~of default}%
The default argument has the
same semantic constraints as the initializer in a
declaration of a variable of the parameter type, using the
copy-initialization semantics (\ref{dcl.init}).
The names in the
default argument are bound, and the semantic constraints are checked,
at the point where the default argument appears.
Name lookup and checking of semantic constraints for default
arguments in function templates and in member functions of
class templates are performed as described in~\ref{temp.inst}.
\begin{example}
in the following code,
\indextext{argument!example~of default}%
\tcode{g}
will be called with the value
\tcode{f(2)}:

\begin{codeblock}
int a = 1;
int f(int);
int g(int x = f(a));            // default argument: \tcode{f(::a)}

void h() {
  a = 2;
  {
  int a = 3;
  g();                          // \tcode{g(f(::a))}
  }
}
\end{codeblock}
\end{example}
\begin{note}
In member function declarations,
names in default arguments are looked up
as described in~\ref{basic.lookup.unqual}.
Access checking applies to names in default arguments as
described in Clause~\ref{class.access}.
\end{note}

\pnum
Except for member functions of class templates, the
default arguments in a member function definition that appears
outside of the class definition
are added to the set of default arguments provided by the
member function declaration in the class definition;
the program is ill-formed if a default constructor~(\ref{class.ctor}),
copy or move constructor, or copy or move assignment operator~(\ref{class.copy})
is so declared.
Default arguments for a member function of a class template
shall be specified on the initial declaration of the member
function within the class template.
\begin{example}

\begin{codeblock}
class C {
  void f(int i = 3);
  void g(int i, int j = 99);
};

void C::f(int i = 3) {          // error: default argument already
}                               // specified in class scope
void C::g(int i = 88, int j) {  // in this translation unit,
}                               // \tcode{C::g} can be called with no argument
\end{codeblock}
\end{example}

\pnum
A local variable shall not appear as a potentially-evaluated expression
in a default argument.
\begin{example}

\begin{codeblock}
void f() {
  int i;
  extern void g(int x = i);          // error
  extern void h(int x = sizeof(i));  // OK
  // ...
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
The keyword
\tcode{this}
may not appear in a default argument of a member function;
see~\ref{expr.prim.general}.
\begin{example}

\begin{codeblock}
class A {
  void f(A* p = this) { }       // error
};
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{argument!evaluation~of default}%
A default argument is evaluated each time the function is called
with no argument for the corresponding parameter.
\indextext{argument!scope~of default}%
A parameter shall not appear as a potentially-evaluated expression
in a default argument.
\indextext{argument~and~name~hiding!default}%
Parameters of a function declared before a default argument
are in scope and can hide namespace and class member names.
\begin{example}

\begin{codeblock}
int a;
int f(int a, int b = a);            // error: parameter \tcode{a}
                                    // used as default argument
typedef int I;
int g(float I, int b = I(2));       // error: parameter \tcode{I} found
int h(int a, int b = sizeof(a));    // OK, unevaluated operand
\end{codeblock}
\end{example}
A non-static member shall not appear in a default argument unless it appears as
the \grammarterm{id-expression} of a class member access expression (\ref{expr.ref}) or
unless it is used to form a pointer to member (\ref{expr.unary.op}).
\begin{example}
the declaration of
\tcode{X::mem1()}
in the following example is ill-formed because no object is supplied for the
non-static member
\tcode{X::a}
used as an initializer.

\begin{codeblock}
int b;
class X {
  int a;
  int mem1(int i = a);          // error: non-static member \tcode{a}
                                // used as default argument
  int mem2(int i = b);          // OK;  use \tcode{X::b}
  static int b;
};
\end{codeblock}

The declaration of
\tcode{X::mem2()}
is meaningful, however, since no object is needed to access the static member
\tcode{X::b}.
Classes, objects, and members are described in Clause~\ref{class}.
\end{example}
A default argument is not part of the
type of a function.
\begin{example}

\begin{codeblock}
int f(int = 0);

void h() {
  int j = f(1);
  int k = f();                  // OK, means \tcode{f(0)}
}

int (*p1)(int) = &f;
int (*p2)() = &f;               // error: type mismatch
\end{codeblock}
\end{example}
When a declaration of a function is introduced by way of a
\grammarterm{using-declaration}
(\ref{namespace.udecl}), any default argument information associated
with the declaration is made known as well.
If the function is redeclared
thereafter in the namespace with additional default arguments,
the additional arguments are also known at any point following
the redeclaration where the
\grammarterm{using-declaration}
is in scope.

\pnum
\indextext{argument~and~virtual~function!default}%
A virtual function call (\ref{class.virtual}) uses the default
arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the
object.
An overriding function in a derived class does not
acquire default arguments from the function it overrides.
\begin{example}

\begin{codeblock}
struct A {
  virtual void f(int a = 7);
};
struct B : public A {
  void f(int a);
};
void m() {
  B* pb = new B;
  A* pa = pb;
  pa->f();          // OK, calls \tcode{pa->B::f(7)}
  pb->f();          // error: wrong number of arguments for \tcode{B::f()}
}
\end{codeblock}
\end{example}%
\indextext{declaration!default argument|)}%
\indextext{declarator!meaning~of|)}

\rSec1[dcl.fct.def]{Function definitions}%
\indextext{definition!function|(}

\rSec2[dcl.fct.def.general]{In general}

\pnum
\indextext{body!function}%
Function definitions have the form

\indextext{\idxgram{function-definition}}%
%
\begin{bnf}
\nontermdef{function-definition}\br
    attribute-specifier-seq\opt decl-specifier-seq\opt declarator virt-specifier-seq\opt function-body
\end{bnf}

\begin{bnf}
\nontermdef{function-body}\br
    ctor-initializer\opt compound-statement\br
    function-try-block\br
    \terminal{= default ;}\br
    \terminal{= delete ;}
\end{bnf}

Any informal reference to the body of a function should be interpreted as a reference to
the non-terminal \grammarterm{function-body}.
The optional \grammarterm{attribute-specifier-seq} in a \grammarterm{function-definition}
appertains to the function.
A \grammarterm{virt-specifier-seq} can be part of a \grammarterm{function-definition}
only if it is a \grammarterm{member-declaration}~(\ref{class.mem}).

\pnum
The
\grammarterm{declarator}
in a
\grammarterm{function-definition}
shall have the form

\begin{ncsimplebnf}
\terminal{D1} parameters-and-qualifiers trailing-return-type\opt
\end{ncsimplebnf}

as described in~\ref{dcl.fct}.
A function shall be defined only in namespace or class scope.

\pnum
\begin{example}
a simple example of a complete function definition is

\indextext{example!function definition}%
\begin{codeblock}
int max(int a, int b, int c) {
  int m = (a > b) ? a : b;
  return (m > c) ? m : c;
}
\end{codeblock}

Here
\tcode{int}
is the
\grammarterm{decl-specifier-seq};
\tcode{max(int}
\tcode{a,}
\tcode{int}
\tcode{b,}
\tcode{int}
\tcode{c)}
is the
\grammarterm{declarator};
\tcode{\{ /* ... */ \}}
is the
\grammarterm{function-body}.
\end{example}

\pnum
\indextext{initializer!base~class}%
\indextext{initializer!member}%
\indextext{definition!constructor}%
A
\grammarterm{ctor-initializer}
is used only in a constructor; see~\ref{class.ctor} and~\ref{class.init}.

\pnum
\begin{note}
A \grammarterm{cv-qualifier-seq} affects the type of \tcode{this}
in the body of a member function; see~\ref{dcl.ref}.
\end{note}

\pnum
\begin{note}
Unused parameters need not be named.
For example,

\indextext{example!unnamed parameter}%
\begin{codeblock}
void print(int a, int) {
  std::printf("a = %d\n",a);
}
\end{codeblock}
\end{note}

\pnum
In the \grammarterm{function-body}, a
\grammarterm{function-local predefined variable} denotes a block-scope object of static
storage duration that is implicitly defined (see~\ref{basic.scope.block}).

\pnum
The function-local predefined variable \tcode{__func__} is
defined as if a definition of the form

\begin{codeblock}
static const char __func__[] = "@\grammarterm{function-name}@";
\end{codeblock}

had been provided, where \grammarterm{function-name} is an \impldef{string resulting
from \tcode{__func__}} string. It is unspecified whether such a variable has an address
distinct from that of any other object in the program.\footnote{Implementations are
permitted to provide additional predefined variables with names that are reserved to the
implementation~(\ref{lex.name}). If a predefined variable is not
odr-used~(\ref{basic.def.odr}), its string value need not be present in the program image.}

\begin{example}
\begin{codeblock}
struct S {
  S() : s(__func__) { }             // OK
  const char* s;
};
void f(const char* s = __func__);  // error: \tcode{__func__} is undeclared
\end{codeblock}
\end{example}

\rSec2[dcl.fct.def.default]{Explicitly-defaulted functions}%
\indextext{definition!function!explicitly-defaulted}

\pnum
A function definition of the form:

\begin{ncbnf}
    attribute-specifier-seq\opt decl-specifier-seq\opt declarator virt-specifier-seq\opt{} \terminal{ = default ;}
\end{ncbnf}

is called an \grammarterm{explicitly-defaulted} definition.
A function that is explicitly defaulted shall

\begin{itemize}
\item be a special member function,

\item have the same declared function type (except for possibly differing
\grammarterm{ref-qualifier}{s} and except that in the case of a copy constructor or
copy assignment operator, the parameter type may be ``reference to non-const \tcode{T}'',
where \tcode{T} is the name of the member function's class) as if it had been implicitly
declared, and

\item not have default arguments.
\end{itemize}

\pnum
An explicitly-defaulted function that is not defined as deleted may be declared
\tcode{constexpr} only if it would have been implicitly declared as
\tcode{constexpr}. If
a function is explicitly defaulted on its first declaration,

\begin{itemize}
\item it is implicitly considered to be \tcode{constexpr} if the implicit
declaration would be, and,
\item it has the same exception specification
as if it had been implicitly declared~(\ref{except.spec}).
\end{itemize}

\pnum
If a function that is explicitly defaulted is declared with an
\grammarterm{exception-specification} that is not compatible~(\ref{except.spec})
with the exception specification of the implicit declaration, then

\begin{itemize}
\item if the function is explicitly defaulted on its first declaration, it is defined as deleted;
\item otherwise, the program is ill-formed.
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
struct S {
  constexpr S() = default;                  // ill-formed: implicit \tcode{S()} is not \tcode{constexpr}
  S(int a = 0) = default;                   // ill-formed: default argument
  void operator=(const S&) = default;       // ill-formed: non-matching return type
  ~S() throw(int) = default;                // deleted: exception specification does not match
private:
  int i;
  S(S&);                                    // OK: private copy constructor
};
S::S(S&) = default;                         // OK: defines copy constructor
\end{codeblock}
\end{example}

\pnum
Explicitly-defaulted functions and implicitly-declared functions are collectively
called \defn{defaulted} functions, and the implementation
shall provide implicit definitions
for them~(\ref{class.ctor}
\ref{class.dtor}, \ref{class.copy}), which might mean defining them as deleted.
A function is
\defn{user-provided} if it is user-declared and not explicitly
defaulted or deleted on its first declaration. A user-provided explicitly-defaulted function
(i.e., explicitly defaulted after its first declaration)
is defined at the point where it is explicitly defaulted; if such a function is implicitly
defined as deleted, the program is ill-formed.
\begin{note}
Declaring a function as defaulted after its first declaration can provide
efficient execution and concise
definition while enabling a stable binary interface to an evolving code
base.\end{note}

\pnum
\begin{example}

\begin{codeblock}
struct trivial {
  trivial() = default;
  trivial(const trivial&) = default;
  trivial(trivial&&) = default;
  trivial& operator=(const trivial&) = default;
  trivial& operator=(trivial&&) = default;
  ~trivial() = default;
};

struct nontrivial1 {
  nontrivial1();
};
nontrivial1::nontrivial1() = default;           // not first declaration
\end{codeblock}
\end{example}

\rSec2[dcl.fct.def.delete]{Deleted definitions}%
\indextext{definition!function!deleted}

\pnum
A function definition of the form:

\begin{ncbnf}
    attribute-specifier-seq\opt decl-specifier-seq\opt declarator virt-specifier-seq\opt{} \terminal{ = delete ;}
\end{ncbnf}

is called a \term{deleted definition}. A function with a
deleted definition is also called a \term{deleted function}.

\pnum
A program that refers to a deleted function implicitly or explicitly, other
than to declare it, is ill-formed. \begin{note} This includes calling the function
implicitly or explicitly and forming a pointer or pointer-to-member to the
function. It applies even for references in expressions that are not
potentially-evaluated. If a function is overloaded, it is referenced only if the
function is selected by overload resolution. The implicit
odr-use~(\ref{basic.def.odr}) of a virtual function does not, by itself,
constitute a reference. \end{note}

\pnum
\begin{example} One can enforce non-default initialization and non-integral
initialization with

\begin{codeblock}
struct onlydouble {
  onlydouble() = delete;              // OK, but redundant
  onlydouble(std::intmax_t) = delete;
  onlydouble(double);
};
\end{codeblock}

\end{example}

\begin{example} One can prevent use of a
class in certain \grammarterm{new-expression}{s} by using deleted definitions
of a user-declared \tcode{operator new} for that class.

\begin{codeblock}
struct sometype {
  void* operator new(std::size_t) = delete;
  void* operator new[](std::size_t) = delete;
};
sometype* p = new sometype;     // error, deleted class \tcode{operator new}
sometype* q = new sometype[3];  // error, deleted class \tcode{operator new[]}
\end{codeblock}
\end{example}

\begin{example} One can make a class uncopyable, i.e. move-only, by using deleted
definitions of the copy constructor and copy assignment operator, and then
providing defaulted definitions of the move constructor and move assignment operator.

\begin{codeblock}
struct moveonly {
  moveonly() = default;
  moveonly(const moveonly&) = delete;
  moveonly(moveonly&&) = default;
  moveonly& operator=(const moveonly&) = delete;
  moveonly& operator=(moveonly&&) = default;
  ~moveonly() = default;
};
moveonly* p;
moveonly q(*p); // error, deleted copy constructor
\end{codeblock}
\end{example}

\pnum
A deleted function is implicitly an inline function~(\ref{dcl.fct.spec}). \begin{note} The
one-definition rule~(\ref{basic.def.odr}) applies to deleted definitions. \end{note}
A deleted definition of a function shall be the first declaration of the function or,
for an explicit specialization of a function template, the first declaration of that
specialization.
\begin{example}
\begin{codeblock}
struct sometype {
  sometype();
};
sometype::sometype() = delete;      // ill-formed; not first declaration
\end{codeblock}
\end{example}%
\indextext{definition!function|)}

\rSec1[dcl.init]{Initializers}%
\indextext{initialization|(}

\pnum
A declarator can specify an initial value for the
identifier being declared.
The identifier designates a variable being initialized.
The process of initialization described in the
remainder of~\ref{dcl.init}
applies also to initializations
specified by other syntactic contexts, such as the initialization
of function parameters with argument expressions (\ref{expr.call}) or
the initialization of return values (\ref{stmt.return}).

\begin{bnf}
\nontermdef{initializer}\br
    brace-or-equal-initializer\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{brace-or-equal-initializer}\br
    \terminal{=} initializer-clause\br
    braced-init-list
\end{bnf}

\begin{bnf}
\nontermdef{initializer-clause}\br
    assignment-expression\br
    braced-init-list
\end{bnf}

\begin{bnf}
\nontermdef{initializer-list}\br
    initializer-clause \terminal{...}\opt\br
    initializer-list \terminal{,} initializer-clause \terminal{...}\opt
\end{bnf}

\begin{bnf}
\nontermdef{braced-init-list}\br
    \terminal{\{} initializer-list \terminal{,\opt} \terminal{\}}\br
    \terminal{\{} \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{expr-or-braced-init-list}\br
    expression\br
    braced-init-list
\end{bnf}

\pnum
Except for objects declared with the \tcode{constexpr} specifier, for which see~\ref{dcl.constexpr},
an \grammarterm{initializer} in the definition of a variable can consist of
arbitrary
\indextext{initialization!automatic object}%
\indextext{initialization!static object@\tcode{static} object}%
expressions involving literals and previously declared
variables and functions,
regardless of the variable's storage duration.
\begin{example}

\begin{codeblock}
int f(int);
int a = 2;
int b = f(a);
int c(b);
\end{codeblock}
\end{example}

\pnum
\begin{note}
Default arguments are more restricted; see~\ref{dcl.fct.default}.

\pnum
The order of initialization of variables with static storage duration is described in~\ref{basic.start}
and~\ref{stmt.dcl}.
\end{note}

\pnum
A declaration of a block-scope variable with external or internal
linkage that has an \grammarterm{initializer} is ill-formed.

\pnum
\indextext{initialization!static object@\tcode{static} object}%
\indextext{initialization!default}%
\indextext{variable!indeterminate uninitialized}%
\indextext{initialization!zero-initialization}%
\indextext{zero-initialization}%
To
\grammarterm{zero-initialize}
an object or reference of type
\tcode{T}
means:

\begin{itemize}
\item
if
\tcode{T}
is a scalar type (\ref{basic.types}), the
object
is initialized to the value obtained by converting the integer literal \tcode{0}
(zero) to
\tcode{T};\footnote{As specified in~\ref{conv.ptr}, converting an integer
literal whose value is
\tcode{0}
to a pointer type results in a null pointer value.
}

\item
if
\tcode{T}
is a (possibly cv-qualified) non-union class type,
each non-static data member and each
base-class subobject is zero-initialized and padding is initialized to zero bits;

\item
if
\tcode{T}
is a (possibly cv-qualified) union type,
the
object's first non-static named
data member
is zero-initialized and padding is initialized to zero bits;

\item
if
\tcode{T}
is an array type,
each element is zero-initialized;
\item
if
\tcode{T}
is a reference type, no initialization is performed.
\end{itemize}

\pnum
\indextext{default-initialization}%
To
\grammarterm{default-initialize}
an object of type
\tcode{T}
means:

\begin{itemize}
\item
If
\tcode{T}
is a (possibly cv-qualified) class type (Clause~\ref{class}),
constructors are considered. The applicable constructors are
enumerated~(\ref{over.match.ctor}), and the best one for the
\grammarterm{initializer} \tcode{()} is chosen through
overload resolution~(\ref{over.match}). The constructor thus selected
is called, with an empty argument list, to initialize the object.

\item
If
\tcode{T}
is an array type, each element is default-initialized.

\item
Otherwise,
no initialization is performed.
\end{itemize}

If a program calls for the default initialization of an object of a
const-qualified type \tcode{T}, \tcode{T} shall be a class type with a user-provided default constructor.

\pnum
\indextext{value-initialization}%
To
\grammarterm{value-initialize}
an object of type
\tcode{T}
means:

\begin{itemize}
\item
if
\tcode{T}
is a (possibly cv-qualified) class type (Clause~\ref{class}) with
either no default constructor~(\ref{class.ctor}) or a default
constructor that is user-provided or deleted, then the object is default-initialized;

\item
if
\tcode{T}
is a (possibly cv-qualified) class type without a
user-provided or deleted default constructor,
then the object is zero-initialized and the semantic constraints for
default-initialization are checked, and if \tcode{T} has a
non-trivial default constructor, the object is default-initialized;

\item
if
\tcode{T}
is an array type, then each element is value-initialized;

\item
otherwise, the object is zero-initialized.
\end{itemize}

An object that is value-initialized is deemed to be constructed and thus subject to
provisions of this International Standard applying to ``constructed'' objects, objects
``for which the constructor has completed,'' etc., even if no constructor is invoked
for the object's initialization.

\pnum
A program that calls for default-initialization
or value-initialization
of an entity
of reference type is ill-formed.

\pnum
\begin{note} Every
object of static storage duration is
zero-initialized at program startup before any other initialization
takes place.
In some cases, additional initialization is done later.
\end{note}

\pnum
An object whose initializer is an empty set of parentheses, i.e.,
\tcode{()},
shall be
value-initialized.

\indextext{ambiguity!function declaration}%
\begin{note}
Since
\tcode{()}
is not permitted by the syntax for
\grammarterm{initializer},

\begin{codeblock}
X a();
\end{codeblock}

is not the declaration of an object of class
\tcode{X},
but the declaration of a function taking no argument and returning an
\tcode{X}.
The form
\tcode{()}
is permitted in certain other initialization contexts (\ref{expr.new},
\ref{expr.type.conv}, \ref{class.base.init}).
\end{note}

\pnum
\indextext{value!indeterminate}%
\indextext{indeterminate~value}%
If no initializer is specified for an object, the object is default-initialized.
When storage for an object with automatic or dynamic storage duration
is obtained, the object has an \term{indeterminate value}, and if
no initialization is performed for the object, that object retains an
indeterminate value until that value is replaced~(\ref{expr.ass}).
\begin{note} Objects with static or thread storage duration are zero-initialized,
see~\ref{basic.start.static}. \end{note}
If an indeterminate value is produced by an evaluation, the behavior is
undefined except in the following cases:

\begin{itemize}
\item
If an indeterminate value of unsigned narrow character
type~(\ref{basic.fundamental}) is produced by the evaluation of:
\begin{itemize}
\item the second or third operand of a conditional expression~(\ref{expr.cond}),
\item the right operand of a comma expression~(\ref{expr.comma}),
\item the operand of a cast or conversion to an unsigned narrow character
type~(\ref{conv.integral}, \ref{expr.type.conv}, \ref{expr.static.cast},
\ref{expr.cast}), or
\item a discarded-value expression (Clause~\ref{expr}),
\end{itemize}
then the result of the operation is an indeterminate value.

\item
If an indeterminate value of unsigned narrow character
type is produced by the evaluation of the right
operand of a simple assignment operator~(\ref{expr.ass}) whose first operand
is an lvalue of unsigned narrow character type, an indeterminate value replaces
the value of the object referred to by the left operand.

\item
If an indeterminate value of unsigned narrow character type is produced by the
evaluation of the initialization expression when initializing an object of
unsigned narrow character type, that object is initialized to an indeterminate
value.
\end{itemize}
\begin{example}
\begin{codeblock}
  int f(bool b) {
    unsigned char c;
    unsigned char d = c; // OK, \tcode{d} has an indeterminate value
    int e = d;           // undefined behavior
    return b ? d : 0;    // undefined behavior if \tcode{b} is \tcode{true}
  }
\end{codeblock}
\end{example}

\pnum
\indextext{initialization!class~member}%
An initializer for a static member is in the scope of the member's class.
\begin{example}

\begin{codeblock}
int a;

struct X {
  static int a;
  static int b;
};

int X::a = 1;
int X::b = a;       // \tcode{X::b = X::a}
\end{codeblock}
\end{example}

\pnum
If the entity being initialized does not have class type, the
\grammarterm{expression-list} in a
parenthesized initializer shall be a single expression.

\pnum
\indextext{initialization!copy}%
\indextext{initialization!direct}%
The initialization that occurs in the \tcode{=} form of a
\grammarterm{brace-or-equal-initializer} or
\grammarterm{condition} (\ref{stmt.select}),
as well as in argument passing, function return,
throwing an exception (\ref{except.throw}),
handling an exception (\ref{except.handle}),
and aggregate member initialization~(\ref{dcl.init.aggr}),
is called
\defn{copy-initialization}.
\begin{note} Copy-initialization may invoke a move~(\ref{class.copy}). \end{note}

\pnum
The initialization that occurs in the forms

\begin{codeblock}
T x(a);
T x{a};
\end{codeblock}

as well as in
\tcode{new}
expressions~(\ref{expr.new}),
\tcode{static_cast}
expressions~(\ref{expr.static.cast}),
functional notation type conversions~(\ref{expr.type.conv}),
\grammarterm{mem-initializer}{s}~(\ref{class.base.init}), and
the \grammarterm{braced-init-list} form of a \grammarterm{condition}
is called
\grammarterm{direct-initialization}.

\pnum
The semantics of initializers are as follows.
The
\indextext{type!destination}%
\term{destination type}
is the type of the object or reference being initialized and the
\term{source type}
is the type of the initializer expression.
If the initializer is not a single (possibly parenthesized) expression, the
source type is not defined.

\begin{itemize}
\item
If the initializer is a (non-parenthesized) \grammarterm{braced-init-list}, the object or reference
is list-initialized~(\ref{dcl.init.list}).
\item
If the destination type is a reference type, see~\ref{dcl.init.ref}.
\item
If the destination type is an array of characters,
an array of \tcode{char16_t},
an array of \tcode{char32_t},
or an array of
\tcode{wchar_t},
and the initializer is a string literal, see~\ref{dcl.init.string}.
\item If the initializer is \tcode{()}, the object is value-initialized.
\item
Otherwise, if the destination type is an array, the program is ill-formed.
\item
If the destination type is a (possibly cv-qualified) class type:

\begin{itemize}
\item
If the initialization is direct-initialization,
or if it is copy-initialization where the cv-unqualified version of the source
type is the same class as, or a derived class of, the class of the destination,
constructors are considered.
The applicable constructors
are enumerated (\ref{over.match.ctor}), and the best one is chosen
through overload resolution (\ref{over.match}).
The constructor so selected
is called to initialize the object, with the initializer
expression or \grammarterm{expression-list} as its argument(s).
If no constructor applies, or the overload resolution is
ambiguous, the initialization is ill-formed.
\item
Otherwise (i.e., for the remaining copy-initialization cases),
user-defined conversion sequences that can convert from the
source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in~\ref{over.match.copy}, and the best one is chosen through overload
resolution (\ref{over.match}).  If the conversion cannot be done or
is ambiguous, the initialization is ill-formed.  The function
selected is called with the initializer expression as its
argument; if the function is a constructor, the call initializes
a temporary of the cv-unqualified version of the
destination type.  The temporary is a prvalue. The result of the call
(which is the temporary for the constructor case) is then used
to direct-initialize, according to the rules above, the object
that is the destination of the copy-initialization.  In certain
cases, an implementation is permitted to eliminate the copying
inherent in this direct-initialization by constructing the
intermediate result directly into the object being initialized;
see~\ref{class.temporary}, \ref{class.copy}.
\end{itemize}

\item
Otherwise, if the source type
is a (possibly cv-qualified) class type, conversion functions are
considered.
The applicable conversion functions are enumerated
(\ref{over.match.conv}), and the best one is chosen through overload
resolution (\ref{over.match}).
The user-defined conversion so selected
is called to convert the initializer expression into the
object being initialized.
If the conversion cannot be done or is
ambiguous, the initialization is ill-formed.
\item
Otherwise, the initial value of the object being initialized is
the (possibly converted) value of the initializer expression.
Standard conversions (Clause~\ref{conv}) will be used, if necessary,
to convert the initializer expression to the cv-unqualified version of
the destination type;
no user-defined conversions are considered.
If the conversion cannot
be done, the initialization is ill-formed.
When initializing a bit-field with a value that it cannot represent, the
resulting value of the bit-field is
\impldef{value of bit-field that cannot represent!initializer}.
\indextext{initialization!\idxcode{const}}%
\begin{note}
An expression of type
``\nonterminal{cv1} \tcode{T}''
can initialize an object of type
``\nonterminal{cv2} \tcode{T}''
independently of
the cv-qualifiers
\nonterminal{cv1}
and \nonterminal{cv2}.

\begin{codeblock}
int a;
const int b = a;
int c = b;
\end{codeblock}
\end{note}
\end{itemize}

\pnum
An \grammarterm{initializer-clause} followed by an ellipsis is a
pack expansion~(\ref{temp.variadic}).

\rSec2[dcl.init.aggr]{Aggregates}%
\indextext{aggregate}%
\indextext{initialization!aggregate}%
\indextext{aggregate~initialization}%
\indextext{initialization!array}%
\indextext{initialization!class~object}%
\indextext{class~object~initialization|see{constructor}}%
\indextext{\idxcode{\{\}}!initializer list}

\pnum
An \defn{aggregate} is an array or a class (Clause~\ref{class}) with
\begin{itemize}
\item
no user-provided constructors~(\ref{class.ctor})
(including those inherited~(\ref{namespace.udecl}) from a base class),
\item
no private or protected non-static data members (Clause~\ref{class.access}),
\item
no virtual functions~(\ref{class.virtual}), and
\item
no virtual, private, or protected base classes~(\ref{class.mi}).
\end{itemize}
\begin{note}
Aggregate initialization does not allow accessing
protected and private base class' members or constructors.
\end{note}

\pnum
\indextext{aggregate!elements}%
The \term{elements} of an aggregate are:
\begin{itemize}
\item
for an array, the array elements in increasing subscript order, or
\item
for a class, the direct base classes in declaration order
followed by the direct members in declaration order.
\end{itemize}

\pnum
When an aggregate is initialized by an initializer list
as specified in~\ref{dcl.init.list},
the elements of the initializer list are taken as initializers
for the elements of the aggregate, in order.
Each element is copy-initialized
from the corresponding \grammarterm{initializer-clause}.
If the \grammarterm{initializer-clause} is an expression and
a narrowing conversion~(\ref{dcl.init.list}) is required
to convert the expression, the program is ill-formed.
\begin{note} If an \grammarterm{initializer-clause} is itself an initializer list,
the element is list-initialized, which will result in a recursive application
of the rules in this section if the element is an aggregate. \end{note}
\begin{example}
\begin{codeblock}
struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a = { 1, { 2, 3 } };
\end{codeblock}
initializes
\tcode{a.x}
with 1,
\tcode{a.b.i}
with 2,
\tcode{a.b.j}
with 3.

\begin{codeblock}
struct base1 { int b1, b2 = 42; };
struct base2 {
  base2() {
    b3 = 42;
  }
  int b3;
};
struct derived : base1, base2 {
  int d;
};

derived d1{{1, 2}, {}, 4};
derived d2{{}, {}, 4};
\end{codeblock}
initializes
\tcode{d1.b1} with 1,
\tcode{d1.b2} with 2,
\tcode{d1.b3} with 42,
\tcode{d1.d} with 4, and
\tcode{d2.b1} with 0,
\tcode{d2.b2} with 42,
\tcode{d2.b3} with 42,
\tcode{d2.d} with 4.
\end{example}

\pnum
An aggregate that is a class can also be initialized with a single
expression not enclosed in braces, as described in~\ref{dcl.init}.

\pnum
An array of unknown size initialized with a
brace-enclosed
\grammarterm{initializer-list}
containing
\tcode{n}
\grammarterm{initializer-clause}{s},
where
\tcode{n}
shall be greater than zero, is defined as having
\tcode{n}
elements (\ref{dcl.array}).
\begin{example}

\begin{codeblock}
int x[] = { 1, 3, 5 };
\end{codeblock}

declares and initializes
\tcode{x}
as a one-dimensional array that has three elements
since no size was specified and there are three initializers.
\end{example}
An empty initializer list
\tcode{\{\}}
shall not be used as the \grammarterm{initializer-clause }
for an array of unknown bound.\footnote{The syntax provides for empty
\grammarterm{initializer-list}{s},
but nonetheless \Cpp does not have zero length arrays.}

\pnum
Static data members and anonymous bit-fields are not considered
members of the class for purposes of aggregate initialization.
\begin{example}

\begin{codeblock}
struct A {
  int i;
  static int s;
  int j;
  int :17;
  int k;
} a = { 1, 2, 3 };
\end{codeblock}

Here, the second initializer 2 initializes
\tcode{a.j}
and not the static data member
\tcode{A::s}, and the third initializer 3 initializes \tcode{a.k}
and not the anonymous bit-field before it.
\end{example}

\pnum
An
\grammarterm{initializer-list}
is ill-formed if the number of
\grammarterm{initializer-clause}{s} 
exceeds the number of members or elements to initialize.
\begin{example}

\begin{codeblock}
char cv[4] = { 'a', 's', 'd', 'f', 0 };     // error
\end{codeblock}

is ill-formed.
\end{example}

\pnum
If there are fewer \grammarterm{initializer-clause}{s} in the list than there
are elements in the aggregate, then each element not explicitly initialized
shall be initialized from its default member initializer~(\ref{class.mem}) or,
if there is no default member initializer, from an empty
initializer list~(\ref{dcl.init.list}).
\begin{example}

\begin{codeblock}
struct S { int a; const char* b; int c; int d = b[a]; };
S ss = { 1, "asdf" };
\end{codeblock}

initializes
\tcode{ss.a}
with 1,
\tcode{ss.b}
with \tcode{"asdf"},
\tcode{ss.c}
with the value of an expression of the form
\tcode{int\{\}}
(that is, \tcode{0}), and \tcode{ss.d} with the value of \tcode{ss.b[ss.a]}
(that is, \tcode{'s'}), and in

\begin{codeblock}
struct X { int i, j, k = 42; };
X a[] = { 1, 2, 3, 4, 5, 6 };
X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };
\end{codeblock}

\tcode{a} and \tcode{b} have the same value
\end{example}

\pnum
If a reference member is initialized from its default member initializer
and a potentially-evaluated subexpression thereof is an aggregate
initialization that would use that default member initializer,
the program is ill-formed.
\begin{example}
\begin{codeblock}
  struct A;
  extern A a;
  struct A {
    const A& a1 { A{a,a} };   // OK
    const A& a2 { A{} };      // error
  };
  A a{a,a};                   // OK
\end{codeblock}
\end{example}

\pnum
If an aggregate class \tcode{C} contains a subaggregate element
\tcode{e} that has no elements for purposes of aggregate initialization,
the \grammarterm{initializer-clause} for \tcode{e} shall not be
omitted from an \grammarterm{initializer-list} for an object of type
\tcode{C} unless the \grammarterm{initializer-clause}{s} for all
elements of \tcode{C} following \tcode{e} are also omitted.
\begin{example}

\begin{codeblock}
struct S { } s;
struct A {
  S s1;
  int i1;
  S s2;
  int i2;
  S s3;
  int i3;
} a = {
  { },      // Required initialization
  0,
  s,        // Required initialization
  0
};          // Initialization not required for \tcode{A::s3} because \tcode{A::i3} is also not initialized
\end{codeblock}
\end{example}

\pnum
If an incomplete or empty
\grammarterm{initializer-list}
leaves a member of reference type uninitialized, the program is ill-formed.

\pnum
When initializing a multi-dimensional array,
the
\grammarterm{initializer-clause}{s}
initialize the elements with the last (rightmost) index of the array
varying the fastest (\ref{dcl.array}).
\begin{example}

\begin{codeblock}
int x[2][2] = { 3, 1, 4, 2 };
\end{codeblock}

initializes
\tcode{x[0][0]}
to
\tcode{3},
\tcode{x[0][1]}
to
\tcode{1},
\tcode{x[1][0]}
to
\tcode{4},
and
\tcode{x[1][1]}
to
\tcode{2}.
On the other hand,

\begin{codeblock}
float y[4][3] = {
  { 1 }, { 2 }, { 3 }, { 4 }
};
\end{codeblock}

initializes the first column of
\tcode{y}
(regarded as a two-dimensional array)
and leaves the rest zero.
\end{example}

\pnum
Braces can be elided in an
\grammarterm{initializer-list}
as follows.
If the
\grammarterm{initializer-list}
begins with a left brace,
then the succeeding comma-separated list of
\grammarterm{initializer-clause}{s}
initializes the elements of a subaggregate;
it is erroneous for there to be more
\grammarterm{initializer-clause}{s}
than elements.
If, however, the
\grammarterm{initializer-list}
for a subaggregate does not begin with a left brace,
then only enough
\grammarterm{initializer-clause}{s}
from the list are taken to initialize the elements of the subaggregate;
any remaining
\grammarterm{initializer-clause}{s}
are left to initialize the next element of the aggregate
of which the current subaggregate is an element.
\begin{example}

\begin{codeblock}
float y[4][3] = {
  { 1, 3, 5 },
  { 2, 4, 6 },
  { 3, 5, 7 },
};
\end{codeblock}

is a completely-braced initialization:
1, 3, and 5 initialize the first row of the array
\tcode{y[0]},
namely
\tcode{y[0][0]},
\tcode{y[0][1]},
and
\tcode{y[0][2]}.
Likewise the next two lines initialize
\tcode{y[1]}
and
\tcode{y[2]}.
The initializer ends early and therefore
\tcode{y[3]}s
elements are initialized as if explicitly initialized with an
expression of the form
\tcode{float()},
that is, are initialized with
\tcode{0.0}.
In the following example, braces in the
\grammarterm{initializer-list}
are elided;
however the
\grammarterm{initializer-list}
has the same effect as the completely-braced
\grammarterm{initializer-list}
of the above example,

\begin{codeblock}
float y[4][3] = {
  1, 3, 5, 2, 4, 6, 3, 5, 7
};
\end{codeblock}

The initializer for
\tcode{y}
begins with a left brace, but the one for
\tcode{y[0]}
does not,
therefore three elements from the list are used.
Likewise the next three are taken successively for
\tcode{y[1]}
and
\tcode{y[2]}.
\end{example}

\pnum
All implicit type conversions (Clause~\ref{conv}) are considered when
initializing the element with an \grammarterm{assignment-expression}.
If the
\grammarterm{assignment-expression}
can initialize an element, the element is initialized.
Otherwise, if the element is itself a subaggregate,
brace elision is assumed and the
\grammarterm{assignment-expression}
is considered for the initialization of the first element of the subaggregate.
\begin{note} As specified above, brace elision cannot apply to
subaggregates with no elements for purposes of aggregate initialization; an
\grammarterm{initializer-clause} for the entire subobject is
required.\end{note}

\begin{example}

\begin{codeblock}
struct A {
  int i;
  operator int();
};
struct B {
  A a1, a2;
  int z;
};
A a;
B b = { 4, a, a };
\end{codeblock}

Braces are elided around the
\grammarterm{initializer-clause}
for
\tcode{b.a1.i}.
\tcode{b.a1.i}
is initialized with 4,
\tcode{b.a2}
is initialized with
\tcode{a},
\tcode{b.z}
is initialized with whatever
\tcode{a.operator int()}
returns.
\end{example}

\pnum
\indextext{initialization!array~of class~objects}%
\begin{note}
An aggregate array or an aggregate class may contain elements of a
class type with a user-provided constructor (\ref{class.ctor}).
Initialization of these aggregate objects is described in~\ref{class.expl.init}.
\end{note}

\pnum
\begin{note}
Whether the initialization of aggregates with static storage duration
is static or dynamic is specified
in~\ref{basic.start.static}, \ref{basic.start.dynamic}, and~\ref{stmt.dcl}.
\end{note}

\pnum
\indextext{initialization!\idxcode{union}}%
When a union is initialized with a brace-enclosed initializer,
the braces shall only contain an
\grammarterm{initializer-clause}
for the first non-static data member of the union.
\begin{example}

\begin{codeblock}
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1;                        // error
u d = { 0, "asdf" };            // error
u e = { "asdf" };               // error
\end{codeblock}
\end{example}

\pnum
\begin{note}
As described above,
the braces around the
\grammarterm{initializer-clause}
for a union member can be omitted if the
union is a member of another aggregate.
\end{note}

\rSec2[dcl.init.string]{Character arrays}%
\indextext{initialization!character array}

\pnum
An array of narrow character type~(\ref{basic.fundamental}),
\tcode{char16_t} array,
\tcode{char32_t} array,
or \tcode{wchar_t} array
can be initialized by a
narrow string literal, \tcode{char16_t} string literal, \tcode{char32_t} string
literal, or wide string literal,
respectively, or by an appropriately-typed string literal enclosed in
braces~(\ref{lex.string}).
\indextext{initialization!character~array}%
Successive
characters of the
value of the string literal
initialize the elements of the array.
\begin{example}

\begin{codeblock}
char msg[] = "Syntax error on line %s\n";
\end{codeblock}

shows a character array whose members are initialized
with a
\grammarterm{string-literal}.
Note that because
\tcode{'\textbackslash n'}
is a single character and
because a trailing
\tcode{'\textbackslash 0'}
is appended,
\tcode{sizeof(msg)}
is
\tcode{25}.
\end{example}

\pnum
There shall not be more initializers than there are array elements.
\begin{example}

\begin{codeblock}
char cv[4] = "asdf";            // error
\end{codeblock}

is ill-formed since there is no space for the implied trailing
\tcode{'\textbackslash 0'}.
\end{example}

\pnum
If there are fewer initializers than there are array elements, each element not
explicitly initialized shall be zero-initialized~(\ref{dcl.init}).

\rSec2[dcl.init.ref]{References}%
\indextext{initialization!reference}

\pnum
A variable whose declared type is
``reference to type \tcode{T}'' (\ref{dcl.ref})
shall be initialized.
\begin{example}

\begin{codeblock}
int g(int) noexcept;
void f() {
  int i;
  int& r = i;                   // \tcode{r} refers to \tcode{i}
  r = 1;                        // the value of \tcode{i} becomes \tcode{1}
  int* p = &r;                  // \tcode{p} points to \tcode{i}
  int& rr = r;                  // \tcode{rr} refers to what \tcode{r} refers to, that is, to \tcode{i}
  int (&rg)(int) = g;           // \tcode{rg} refers to the function \tcode{g}
  rg(i);                        // calls function \tcode{g}
  int a[3];
  int (&ra)[3] = a;             // \tcode{ra} refers to the array \tcode{a}
  ra[1] = i;                    // modifies \tcode{a[1]}
}
\end{codeblock}
\end{example}

\pnum
A reference cannot be changed to refer to another object after initialization.
\indextext{assignment!reference}%
\begin{note}
Assignment to a reference assigns to the object referred to by the reference (\ref{expr.ass}).
\end{note}
\indextext{argument~passing!reference~and}%
Argument passing (\ref{expr.call})
\indextext{\idxcode{return}!reference~and}%
and function value return (\ref{stmt.return}) are initializations.

\pnum
The initializer can be omitted for a reference only in a parameter declaration
(\ref{dcl.fct}), in the declaration of a function return type, in the declaration of
a class member within its class definition (\ref{class.mem}), and where the
\tcode{extern}
specifier is explicitly used.
\indextext{declaration!extern@\tcode{extern} reference}%
\begin{example}

\begin{codeblock}
int& r1;                        // error: initializer missing
extern int& r2;                 // OK
\end{codeblock}
\end{example}

\pnum
Given types ``\nonterminal{cv1} \tcode{T1}'' and ``\nonterminal{cv2} \tcode{T2}'',
``\nonterminal{cv1} \tcode{T1}'' is \nonterminal{reference-related} to
\indextext{reference-related}%
``\nonterminal{cv2} \tcode{T2}'' if
\tcode{T1} is the same type as \tcode{T2}, or
\tcode{T1} is a base class of \tcode{T2}.
``\nonterminal{cv1} \tcode{T1}'' is \nonterminal{reference-compatible}
\indextext{reference-compatible}%
with ``\nonterminal{cv2} \tcode{T2}'' if
\begin{itemize}
\item \tcode{T1} is reference-related to \tcode{T2}, or
\item T2 is ``\tcode{noexcept} function'' and T1 is ``function'',
where the function types are otherwise the same,
\end{itemize}
and
\textit{cv1}
is the same cv-qualification as, or greater cv-qualification than,
\textit{cv2}.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
\tcode{T1}
is a base class of
\tcode{T2},
a program that necessitates such a binding is ill-formed if
\tcode{T1}
is an inaccessible (Clause~\ref{class.access}) or ambiguous (\ref{class.member.lookup})
base class of
\tcode{T2}.

\pnum
A reference to type ``\cvqual{cv1} \tcode{T1}'' is initialized by
an expression of type ``\cvqual{cv2} \tcode{T2}'' as follows:%
\indextext{binding!reference}

\begin{itemize}
\item
If the reference is an lvalue reference and the initializer expression

\begin{itemize}
\item
is an lvalue (but is not a
bit-field), and
``\nonterminal{cv1} \tcode{T1}'' is reference-compatible with
``\nonterminal{cv2} \tcode{T2}'', or
\item
has a class type (i.e.,
\tcode{T2}
is a class type), where \tcode{T1} is not reference-related to \tcode{T2}, and can be converted
to an lvalue of type ``\nonterminal{cv3} \tcode{T3}'', where
``\nonterminal{cv1} \tcode{T1}'' is reference-compatible with
``\nonterminal{cv3} \tcode{T3}''\footnote{This requires a conversion
function~(\ref{class.conv.fct}) returning a reference type.}
(this conversion is selected by enumerating the applicable conversion
functions (\ref{over.match.ref}) and choosing the best one through overload
resolution (\ref{over.match})),
\end{itemize}
then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
\begin{note}
The usual lvalue-to-rvalue (\ref{conv.lval}), array-to-pointer
(\ref{conv.array}), and function-to-pointer (\ref{conv.func}) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
\end{note}

\begin{example}

\begin{codeblock}
double d = 2.0;
double& rd = d;                 // \tcode{rd} refers to \tcode{d}
const double& rcd = d;          // \tcode{rcd} refers to \tcode{d}

struct A { };
struct B : A { operator int&(); } b;
A& ra = b;                      // \tcode{ra} refers to \tcode{A} subobject in \tcode{b}
const A& rca = b;               // \tcode{rca} refers to \tcode{A} subobject in \tcode{b}
int& ir = B();                  // \tcode{ir} refers to the result of \tcode{B::operator int\&}
\end{codeblock}
\end{example}

\item
Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
\textit{cv1}
shall be
\tcode{const}), or the reference shall be an rvalue reference.
\begin{example}

\begin{codeblock}
double& rd2 = 2.0;              // error: not an lvalue and reference not \tcode{const}
int  i = 2;
double& rd3 = i;                // error: type mismatch and reference not \tcode{const}
\end{codeblock}
\end{example}

\begin{itemize}
\item If the initializer expression

\begin{itemize}
\item is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and
``\cvqual{cv1} \tcode{T1}'' is
reference-compatible with ``\cvqual{cv2} \tcode{T2}'', or

\item has a class type (i.e., \tcode{T2} is a class type), where \tcode{T1}
is not reference-related to \tcode{T2}, and can be converted to
an xvalue, class prvalue, or function lvalue of type ``\cvqual{cv3} \tcode{T3}'',
where ``\cvqual{cv1} \tcode{T1}'' is
reference-compatible with ``\cvqual{cv3} \tcode{T3}'' (see~\ref{over.match.ref}),

\end{itemize}

then the reference is bound to the value of the initializer expression in the first
case and to the result of the conversion in the second case (or, in either case, to
an appropriate base class subobject).

\begin{example}

\begin{codeblock}
struct A { };
struct B : A { } b;
extern B f();
const A& rca2 = f();                // bound to the \tcode{A} subobject of the \tcode{B} rvalue.
A&& rra = f();                      // same as above
struct X {
  operator B();
  operator int&();
} x;
const A& r = x;                     // bound to the \tcode{A} subobject of the result of the conversion
int i2 = 42;
int&& rri = static_cast<int&&>(i2); // bound directly to \tcode{i2}
B&& rrb = x;                        // bound directly to the result of \tcode{operator B}
\end{codeblock}
\end{example}

\item
Otherwise:
\begin{itemize}
\item
If \tcode{T1} or \tcode{T2} is a class type and
\tcode{T1} is not reference-related to \tcode{T2},
user-defined conversions are considered
using the rules for copy-initialization of an object of type 
``\nonterminal{cv1} \tcode{T1}'' by
user-defined conversion
(\ref{dcl.init}, \ref{over.match.copy}, \ref{over.match.conv});
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
For this direct-initialization, user-defined conversions are not considered.
\item
Otherwise,
a temporary of type ``\nonterminal{cv1} \tcode{T1}'' is created and
copy-initialized~(\ref{dcl.init}) from the initializer expression.
The reference is then bound to the temporary.
\end{itemize}

If
\tcode{T1}
is reference-related to
\tcode{T2}:
\begin{itemize}
\item
\textit{cv1}
shall be the same cv-qualification as, or greater cv-qualification than,
\textit{cv2}; and
\item
if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
\end{itemize}

\begin{example}
\begin{codeblock}
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &&banana1 = ConstBanana(); // ill-formed
  Banana &&banana2 = Enigma();      // ill-formed
  Banana &&banana3 = Alaska();      // ill-formed
}

const double& rcd2 = 2;         // \tcode{rcd2} refers to temporary with value \tcode{2.0}
double&& rrd = 2;               // \tcode{rrd} refers to temporary with value \tcode{2.0}
const volatile int cvi = 1;
const int& r2 = cvi;            // error: type qualifiers dropped
struct A { operator volatile int&(); } a;
const int& r3 = a;              // error: type qualifiers dropped
                                // from result of conversion function
double d2 = 1.0;
double&& rrd2 = d2;             // error: initializer is lvalue of related type
struct X { operator int&(); };
int&& rri2 = X();               // error: result of conversion function is lvalue of related type
int i3 = 2;
double&& rrd3 = i3;             // \tcode{rrd3} refers to temporary with value \tcode{2.0}
\end{codeblock}
\end{example}
\end{itemize}
\end{itemize}

In all cases except the last (i.e., creating and initializing a temporary from the
initializer expression), the reference is said to \defn{bind directly} to the
initializer expression.

\pnum
\begin{note}
\ref{class.temporary} describes the lifetime of temporaries bound to references.
\end{note}

\rSec2[dcl.init.list]{List-initialization}%
\indextext{initialization!list-initialization|(}

\pnum
\grammarterm{List-initialization} is initialization of an object or reference from a
\grammarterm{braced-init-list}. Such an initializer is called an \term{initializer
list}, and the comma-separated \grammarterm{initializer-clause}{s} of the list are
called the \term{elements} of the initializer list. An initializer list may be empty.
List-initialization can occur in direct-initialization or copy-initialization contexts;
list-initialization in a direct-initialization context is called
\grammarterm{direct-list-initialization} and list-initialization in a
copy-initialization context is called \grammarterm{copy-list-initialization}. \begin{note}
List-initialization can be used

\begin{itemize}
\item as the initializer in a variable definition~(\ref{dcl.init})
\item as the initializer in a \grammarterm{new-expression}~(\ref{expr.new})
\item in a return statement~(\ref{stmt.return})
\item as a \grammarterm{for-range-initializer}~(\ref{stmt.iter})
\item as a function argument~(\ref{expr.call})
\item as a subscript~(\ref{expr.sub})
\item as an argument to a constructor invocation~(\ref{dcl.init},~\ref{expr.type.conv})
\item as an initializer for a non-static data member~(\ref{class.mem})
\item in a \grammarterm{mem-initializer}~(\ref{class.base.init})
\item on the right-hand side of an assignment (\ref{expr.ass})
\end{itemize}

\begin{example}
\begin{codeblock}
int a = {1};
std::complex<double> z{1,2};
new std::vector<std::string>{"once", "upon", "a", "time"};  // 4 string elements
f( {"Nicholas","Annemarie"} );  // pass list of two elements
return { "Norah" };             // return list of one element
int* e {};                      // initialization to zero / null pointer
x = double{1};                  // explicitly construct a double 
std::map<std::string,int> anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
\end{codeblock}
\end{example} \end{note}

\pnum
A constructor is an \grammarterm{initializer-list constructor} if its first parameter is
of type \tcode{std::initializer_list<E>} or reference to possibly cv-qualified
\tcode{std::initializer_list<E>} for some type \tcode{E}, and either there are no other
parameters or else all other parameters have default arguments (\ref{dcl.fct.default}).
\begin{note} Initializer-list constructors are favored over other constructors in
list-initialization~(\ref{over.match.list}). Passing an initializer list as the argument
to the constructor template \tcode{template<class T> C(T)} of a class \tcode{C} does not
create an initializer-list constructor, because an initializer list argument causes the 
corresponding parameter to be a non-deduced context~(\ref{temp.deduct.call}). \end{note}
The template
\tcode{std::initializer_list} is not predefined; if the header
\tcode{<initializer_list>} is not included prior to a use of
\tcode{std::initializer_list} --- even an implicit use in which the type is not
named~(\ref{dcl.spec.auto}) --- the program is ill-formed.

\pnum
List-initialization of an object or reference of type \tcode{T} is defined as follows:
\begin{itemize}

\item If \tcode{T} is a class type and the initializer list has a single element
of type \cvqual{cv} \tcode{U},
where \tcode{U} is \tcode{T} or a class derived from \tcode{T},
the object is initialized from that element (by copy-initialization for
copy-list-initialization, or by direct-initialization for
direct-list-initialization).

\item Otherwise, if \tcode{T} is a character array and the initializer list has a
single element that is an appropriately-typed string literal~(\ref{dcl.init.string}),
initialization is performed as described in that section.

\item Otherwise, if \tcode{T} is an aggregate, aggregate initialization is
performed~(\ref{dcl.init.aggr}).

\begin{example}
\begin{codeblock}
double ad[] = { 1, 2.0 };           // OK
int ai[] = { 1, 2.0 };              // error: narrowing

struct S2 {
  int m1;
  double m2, m3;
};
S2 s21 = { 1, 2, 3.0 };             // OK
S2 s22 { 1.0, 2, 3 };               // error: narrowing
S2 s23 { };                         // OK: default to 0,0,0
\end{codeblock}
\end{example}

\item Otherwise, if the initializer list has no elements and \tcode{T} is a class type with a
default constructor, the object is value-initialized.

\item Otherwise, if \tcode{T} is a specialization of \tcode{std::initializer_list<E>},
a prvalue \tcode{initializer_list} object is constructed as described below and used to
initialize the object according to the rules for initialization of an object from a
class of the same type~(\ref{dcl.init}).

\item Otherwise, if \tcode{T} is a class type, constructors are considered.
The applicable constructors are enumerated and
the best one is chosen through overload resolution (\ref{over.match},~\ref{over.match.list}). If a narrowing
conversion (see below) is required to convert any of the arguments, the program is
ill-formed.

\begin{example}
\begin{codeblock}
struct S {
  S(std::initializer_list<double>); // \#1
  S(std::initializer_list<int>);    // \#2
  S();                              // \#3
  // ...
};
S s1 = { 1.0, 2.0, 3.0 };           // invoke \#1
S s2 = { 1, 2, 3 };                 // invoke \#2
S s3 = { };                         // invoke \#3
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
struct Map {
  Map(std::initializer_list<std::pair<std::string,int>>);
};
Map ship = {{"Sophie",14}, {"Surprise",28}};
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
struct S {
  // no initializer-list constructors
  S(int, double, double);           // \#1
  S();                              // \#2
  // ...
};
S s1 = { 1, 2, 3.0 };               // OK: invoke \#1
S s2 { 1.0, 2, 3 };                 // error: narrowing
S s3 { };                           // OK: invoke \#2
\end{codeblock}
\end{example}

\item Otherwise, if
the initializer list has a single element of type \tcode{E} and either
\tcode{T} is not a reference type or its referenced type is
reference-related to \tcode{E}, the object or reference is initialized
from that element (by copy-initialization for copy-list-initialization,
or by direct-initialization for direct-list-initialization);
if a narrowing conversion (see below) is required
to convert the element to \tcode{T}, the program is ill-formed.

\begin{example}
\begin{codeblock}
int x1 {2};                         // OK
int x2 {2.0};                       // error: narrowing
\end{codeblock}
\end{example}

\item Otherwise, if \tcode{T} is a reference type, a prvalue temporary of the type
referenced by \tcode{T} is copy-list-initialized or direct-list-initialized,
depending on the kind of initialization for the reference, and the reference is
bound to that temporary.
\begin{note} As usual, the binding will fail and the program is ill-formed if
the reference type is an lvalue reference to a non-const type. \end{note}

\begin{example}
\begin{codeblock}
struct S {
  S(std::initializer_list<double>); // \#1
  S(const std::string&);            // \#2
  // ...
};
const S& r1 = { 1, 2, 3.0 };        // OK: invoke \#1
const S& r2 { "Spinach" };          // OK: invoke \#2
S& r3 = { 1, 2, 3 };                // error: initializer is not an lvalue
const int& i1 = { 1 };              // OK
const int& i2 = { 1.1 };            // error: narrowing
const int (&iar)[2] = { 1, 2 };     // OK: \tcode{iar} is bound to temporary array
\end{codeblock}
\end{example}

\item Otherwise, if \tcode{T} is an enumeration
with a fixed underlying type~(\ref{dcl.enum}),
the \grammarterm{initializer-list} has a single element \tcode{v}, and
the initialization is direct-list-initialization,
the object is initialized with the value \tcode{T(v)}~(\ref{expr.type.conv});
if a narrowing conversion is required to convert \tcode{v}
to the underlying type of \tcode{T}, the program is ill-formed.

\begin{example}
\begin{codeblock}
enum byte : unsigned char { };
byte b { 42 };                      // OK
byte c = { 42 };                    // error
byte d = byte{ 42 };                // OK; same value as \tcode{b}
byte e { -1 };                      // error

struct A { byte b; };
A a1 = { { 42 } };                  // error
A a2 = { byte{ 42 } };              // OK

void f(byte);
f({ 42 });                          // error

enum class Handle : uint32_t { Invalid = 0 };
Handle h { 42 };                    // OK
\end{codeblock}
\end{example}

\item Otherwise, if the initializer list has no elements, the object is
value-initialized.

\begin{example}
\begin{codeblock}
int** pp {};                        // initialized to null pointer
\end{codeblock}
\end{example}

\item Otherwise, the program is ill-formed.

\begin{example}
\begin{codeblock}
struct A { int i; int j; };
A a1 { 1, 2 };                      // aggregate initialization 
A a2 { 1.2 };                       // error: narrowing
struct B {
  B(std::initializer_list<int>);
};
B b1 { 1, 2 };                      // creates \tcode{initializer_list<int>} and calls constructor
B b2 { 1, 2.0 };                    // error: narrowing
struct C {
  C(int i, double j);
};
C c1 = { 1, 2.2 };                  // calls constructor with arguments (1, 2.2) 
C c2 = { 1.1, 2 };                  // error: narrowing

int j { 1 };                        // initialize to 1
int k { };                          // initialize to 0
\end{codeblock}
\end{example}

\end{itemize}

\pnum
Within the \grammarterm{initializer-list} of a \grammarterm{braced-init-list},
the \grammarterm{initializer-clause}{s}, including any that result from pack
expansions~(\ref{temp.variadic}), are evaluated in the order in which they
appear. That is, every value computation and side effect associated with a
given \grammarterm{initializer-clause} is sequenced before every value
computation and side effect associated with any \grammarterm{initializer-clause}
that follows it in the comma-separated list of the \grammarterm{initializer-list}.
\begin{note} This evaluation ordering holds regardless of the semantics of the
initialization; for example, it applies when the elements of the
\grammarterm{initializer-list} are interpreted as arguments of a constructor
call, even though ordinarily there are no sequencing constraints on the
arguments of a call. \end{note}

\pnum
An object of type \tcode{std::initializer_list<E>} is constructed from
an initializer list as if the implementation allocated a temporary array of $N$
elements of type \tcode{const E}, where $N$ is the number of elements in the
initializer list. Each element of that array is copy-initialized with the
corresponding element of the initializer list, and the
\tcode{std::initializer_list<E>} object is constructed to refer to that array.
\begin{note} A constructor or conversion function selected for the copy shall be
accessible (Clause~\ref{class.access}) in the context of the initializer list.
\end{note}
If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.\begin{example}
\begin{codeblock}
struct X {
  X(std::initializer_list<double> v);
};
X x{ 1,2,3 };
\end{codeblock}

The initialization will be implemented in a way roughly equivalent to this:

\begin{codeblock}
const double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list<double>(__a, __a+3));
\end{codeblock}

assuming that the implementation can construct an \tcode{initializer_list} object with a pair of pointers. \end{example}

\pnum
The array has the same lifetime as any other temporary
object~(\ref{class.temporary}), except that initializing an
\tcode{initializer_list} object from the array extends the lifetime of
the array exactly like binding a reference to a temporary.
\begin{example}

\begin{codeblock}
typedef std::complex<double> cmplx;
std::vector<cmplx> v1 = { 1, 2, 3 };

void f() {
  std::vector<cmplx> v2{ 1, 2, 3 };
  std::initializer_list<int> i3 = { 1, 2, 3 };
}

struct A {
  std::initializer_list<int> i4;
  A() : i4{ 1, 2, 3 } {}  // ill-formed, would create a dangling reference
};
\end{codeblock}

For \tcode{v1} and \tcode{v2}, the \tcode{initializer_list} object
is a parameter in a function call, so the array created for
\tcode{\{ 1, 2, 3 \}} has full-expression lifetime.
For \tcode{i3}, the \tcode{initializer_list} object is a variable,
so the array persists for the lifetime of the variable.
For \tcode{i4}, the \tcode{initializer_list} object is initialized in
the constructor's \grammarterm{ctor-initializer} as if by binding
a temporary array to a reference member, so the program is
ill-formed~(\ref{class.base.init}).
\end{example}
\begin{note}
The implementation is free to allocate the array in read-only memory if an explicit array with the same initializer could be so allocated. \end{note}

\pnum
A
\indextext{narrowing conversion}%
\indextext{conversion!narrowing}%
\term{narrowing conversion} is an implicit conversion

\begin{itemize}
\item from a floating-point type to an integer type, or

\item from \tcode{long double} to \tcode{double} or \tcode{float}, or from
\tcode{double} to \tcode{float}, except where the source is a constant expression and
the actual value after conversion
is within the range of values that can be represented (even if it cannot be represented exactly),
or

\item from an integer type or unscoped enumeration type to a floating-point type, except
where the source is a constant expression and the actual value after conversion will fit
into the target type and will produce the original value when converted back to the
original type, or

\item from an integer type or unscoped enumeration type to an integer type that cannot
represent all the values of the original type, except where the source is a constant
expression whose value after integral promotions will fit into the target type.
\end{itemize}

\begin{note} As indicated above, such conversions are not allowed at the top level in
list-initializations.\end{note} \begin{example}

\begin{codeblock}
int x = 999;              // x is not a constant expression
const int y = 999;
const int z = 99;
char c1 = x;              // OK, though it might narrow (in this case, it does narrow)
char c2{x};               // error: might narrow
char c3{y};               // error: narrows (assuming \tcode{char} is 8 bits)
char c4{z};               // OK: no narrowing needed
unsigned char uc1 = {5};  // OK: no narrowing needed
unsigned char uc2 = {-1}; // error: narrows
unsigned int ui1 = {-1};  // error: narrows
signed int si1 =
  { (unsigned int)-1 };   // error: narrows
int ii = {2.0};           // error: narrows
float f1 { x };           // error: might narrow
float f2 { 7 };           // OK: 7 can be exactly represented as a float
int f(int);
int a[] =
  { 2, f(2), f(2.0) };    // OK: the double-to-int conversion is not at the top level
\end{codeblock}
\end{example}%
\indextext{initialization!list-initialization|)}%
\indextext{initialization|)}%
\indextext{declarator|)}
