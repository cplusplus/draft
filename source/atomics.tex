%!TEX root = std.tex
\rSec0[atomics]{Atomic operations library}

\rSec1[atomics.general]{General}

\pnum
This Clause describes components for fine-grained atomic access. This access is
provided via operations on atomic objects.

\pnum
The following subclauses describe atomics requirements and components for types
and operations, as summarized below.

\begin{libsumtab}{Atomics library summary}{tab:atomics.lib.summary}
\ref{atomics.order} & Order and Consistency   &
  \\
\ref{atomics.lockfree}  & Lock-free Property   &
  \\
\ref{atomics.types.generic} & Atomic Types   & \tcode{<atomic>}
  \\
\ref{atomics.types.operations}  & Operations on Atomic Types &
  \\
\ref{atomics.flag}  & Flag Type and Operations   &
  \\
\ref{atomics.fences}  & Fences   &
  \\
\end{libsumtab}

\rSec1[atomics.syn]{Header \tcode{<atomic>} synopsis}

\indexhdr{atomic}%
\begin{codeblock}
namespace std {
  // \ref{atomics.order}, order and consistency
  enum class memory_order : @\unspec@;
  template<class T>
    T kill_dependency(T y) noexcept;

  // \ref{atomics.lockfree}, lock-free property
  #define ATOMIC_BOOL_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR16_T_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR32_T_LOCK_FREE @\unspec@
  #define ATOMIC_WCHAR_T_LOCK_FREE @\unspec@
  #define ATOMIC_SHORT_LOCK_FREE @\unspec@
  #define ATOMIC_INT_LOCK_FREE @\unspec@
  #define ATOMIC_LONG_LOCK_FREE @\unspec@
  #define ATOMIC_LLONG_LOCK_FREE @\unspec@
  #define ATOMIC_POINTER_LOCK_FREE @\unspec@

  // \ref{atomics.types.generic}, atomic
  template<class T> struct atomic;
  // \ref{atomics.types.pointer}, partial specialization for pointers
  template<class T> struct atomic<T*>;

  // \ref{atomics.nonmembers}, non-member functions
  template<class T>
    bool atomic_is_lock_free(const volatile atomic<T>*) noexcept;
  template<class T>
    bool atomic_is_lock_free(const atomic<T>*) noexcept;
  template<class T>
    void atomic_init(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_init(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_store(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_store(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_store_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    void atomic_store_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_load(const volatile atomic<T>*) noexcept;
  template<class T>
    T atomic_load(const atomic<T>*) noexcept;
  template<class T>
    T atomic_load_explicit(const volatile atomic<T>*, memory_order) noexcept;
  template<class T>
    T atomic_load_explicit(const atomic<T>*, memory_order) noexcept;
  template<class T>
    T atomic_exchange(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_exchange(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_exchange_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_exchange_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak(volatile atomic<T>*,
                                      typename atomic<T>::value_type*,
                                      typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak(atomic<T>*,
                                      typename atomic<T>::value_type*,
                                      typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong(volatile atomic<T>*,
                                        typename atomic<T>::value_type*,
                                        typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong(atomic<T>*,
                                        typename atomic<T>::value_type*,
                                        typename atomic<T>::value_type) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak_explicit(volatile atomic<T>*,
                                               typename atomic<T>::value_type*,
                                               typename atomic<T>::value_type,
                                               memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_weak_explicit(atomic<T>*,
                                               typename atomic<T>::value_type*,
                                               typename atomic<T>::value_type,
                                               memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong_explicit(volatile atomic<T>*,
                                                 typename atomic<T>::value_type*,
                                                 typename atomic<T>::value_type,
                                                 memory_order, memory_order) noexcept;
  template<class T>
    bool atomic_compare_exchange_strong_explicit(atomic<T>*,
                                                 typename atomic<T>::value_type*,
                                                 typename atomic<T>::value_type,
                                                 memory_order, memory_order) noexcept;

  template<class T>
    T atomic_fetch_add(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_add(atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_add_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_add_explicit(atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_sub(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_sub(atomic<T>*, typename atomic<T>::difference_type) noexcept;
  template<class T>
    T atomic_fetch_sub_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_sub_explicit(atomic<T>*, typename atomic<T>::difference_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_and(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_and(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_and_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_and_explicit(atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_or(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_or(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_or_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_fetch_or_explicit(atomic<T>*, typename atomic<T>::value_type,
                               memory_order) noexcept;
  template<class T>
    T atomic_fetch_xor(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_xor(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_xor_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;
  template<class T>
    T atomic_fetch_xor_explicit(atomic<T>*, typename atomic<T>::value_type,
                                memory_order) noexcept;

  // \ref{atomics.types.operations}, initialization
  #define ATOMIC_VAR_INIT(value) @\seebelow@

  // \ref{atomics.alias}, type aliases
  using atomic_bool           = atomic<bool>;
  using atomic_char           = atomic<char>;
  using atomic_schar          = atomic<signed char>;
  using atomic_uchar          = atomic<unsigned char>;
  using atomic_short          = atomic<short>;
  using atomic_ushort         = atomic<unsigned short>;
  using atomic_int            = atomic<int>;
  using atomic_uint           = atomic<unsigned int>;
  using atomic_long           = atomic<long>;
  using atomic_ulong          = atomic<unsigned long>;
  using atomic_llong          = atomic<long long>;
  using atomic_ullong         = atomic<unsigned long long>;
  using atomic_char16_t       = atomic<char16_t>;
  using atomic_char32_t       = atomic<char32_t>;
  using atomic_wchar_t        = atomic<wchar_t>;

  using atomic_int8_t         = atomic<int8_t>;
  using atomic_uint8_t        = atomic<uint8_t>;
  using atomic_int16_t        = atomic<int16_t>;
  using atomic_uint16_t       = atomic<uint16_t>;
  using atomic_int32_t        = atomic<int32_t>;
  using atomic_uint32_t       = atomic<uint32_t>;
  using atomic_int64_t        = atomic<int64_t>;
  using atomic_uint64_t       = atomic<uint64_t>;

  using atomic_int_least8_t   = atomic<int_least8_t>;
  using atomic_uint_least8_t  = atomic<uint_least8_t>;
  using atomic_int_least16_t  = atomic<int_least16_t>;
  using atomic_uint_least16_t = atomic<uint_least16_t>;
  using atomic_int_least32_t  = atomic<int_least32_t>;
  using atomic_uint_least32_t = atomic<uint_least32_t>;
  using atomic_int_least64_t  = atomic<int_least64_t>;
  using atomic_uint_least64_t = atomic<uint_least64_t>;

  using atomic_int_fast8_t    = atomic<int_fast8_t>;
  using atomic_uint_fast8_t   = atomic<uint_fast8_t>;
  using atomic_int_fast16_t   = atomic<int_fast16_t>;
  using atomic_uint_fast16_t  = atomic<uint_fast16_t>;
  using atomic_int_fast32_t   = atomic<int_fast32_t>;
  using atomic_uint_fast32_t  = atomic<uint_fast32_t>;
  using atomic_int_fast64_t   = atomic<int_fast64_t>;
  using atomic_uint_fast64_t  = atomic<uint_fast64_t>;

  using atomic_intptr_t       = atomic<intptr_t>;
  using atomic_uintptr_t      = atomic<uintptr_t>;
  using atomic_size_t         = atomic<size_t>;
  using atomic_ptrdiff_t      = atomic<ptrdiff_t>;
  using atomic_intmax_t       = atomic<intmax_t>;
  using atomic_uintmax_t      = atomic<uintmax_t>;

  // \ref{atomics.flag}, flag type and operations
  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT @\seebelow@

  // \ref{atomics.fences}, fences
  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
\end{codeblock}

\rSec1[atomics.alias]{Type aliases}
\indexlibrary{\idxcode{atomic_bool}}%
\indexlibrary{\idxcode{atomic_char}}%
\indexlibrary{\idxcode{atomic_schar}}%
\indexlibrary{\idxcode{atomic_uchar}}%
\indexlibrary{\idxcode{atomic_short}}%
\indexlibrary{\idxcode{atomic_ushort}}%
\indexlibrary{\idxcode{atomic_int}}%
\indexlibrary{\idxcode{atomic_uint}}%
\indexlibrary{\idxcode{atomic_long}}%
\indexlibrary{\idxcode{atomic_ulong}}%
\indexlibrary{\idxcode{atomic_llong}}%
\indexlibrary{\idxcode{atomic_ullong}}%
\indexlibrary{\idxcode{atomic_char16_t}}%
\indexlibrary{\idxcode{atomic_char32_t}}%
\indexlibrary{\idxcode{atomic_wchar_t}}%
\indexlibrary{\idxcode{atomic_int8_t}}%
\indexlibrary{\idxcode{atomic_uint8_t}}%
\indexlibrary{\idxcode{atomic_int16_t}}%
\indexlibrary{\idxcode{atomic_uint16_t}}%
\indexlibrary{\idxcode{atomic_int32_t}}%
\indexlibrary{\idxcode{atomic_uint32_t}}%
\indexlibrary{\idxcode{atomic_int64_t}}%
\indexlibrary{\idxcode{atomic_uint64_t}}%
\indexlibrary{\idxcode{atomic_int_least8_t}}%
\indexlibrary{\idxcode{atomic_uint_least8_t}}%
\indexlibrary{\idxcode{atomic_int_least16_t}}%
\indexlibrary{\idxcode{atomic_uint_least16_t}}%
\indexlibrary{\idxcode{atomic_int_least32_t}}%
\indexlibrary{\idxcode{atomic_uint_least32_t}}%
\indexlibrary{\idxcode{atomic_int_least64_t}}%
\indexlibrary{\idxcode{atomic_uint_least64_t}}%
\indexlibrary{\idxcode{atomic_int_fast8_t}}%
\indexlibrary{\idxcode{atomic_uint_fast8_t}}%
\indexlibrary{\idxcode{atomic_int_fast16_t}}%
\indexlibrary{\idxcode{atomic_uint_fast16_t}}%
\indexlibrary{\idxcode{atomic_int_fast32_t}}%
\indexlibrary{\idxcode{atomic_uint_fast32_t}}%
\indexlibrary{\idxcode{atomic_int_fast64_t}}%
\indexlibrary{\idxcode{atomic_uint_fast64_t}}%
\indexlibrary{\idxcode{atomic_intptr_t}}%
\indexlibrary{\idxcode{atomic_uintptr_t}}%
\indexlibrary{\idxcode{atomic_size_t}}%
\indexlibrary{\idxcode{atomic_ptrdiff_t}}%
\indexlibrary{\idxcode{atomic_intmax_t}}%
\indexlibrary{\idxcode{atomic_uintmax_t}}%
\pnum
The type aliases \tcode{atomic_int$N$_t}, \tcode{atomic_uint$N$_t},
\tcode{atomic_intptr_t}, and \tcode{atomic_uintptr_t}
are defined if and only if
\tcode{int$N$_t}, \tcode{uint$N$_t},
\tcode{intptr_t}, and \tcode{uintptr_t}
are defined, respectively.

\rSec1[atomics.order]{Order and consistency}
\indexlibrary{memory_order}%
\indexlibrarymember{relaxed}{memory_order}%
\indexlibrarymember{consume}{memory_order}%
\indexlibrarymember{acquire}{memory_order}%
\indexlibrarymember{release}{memory_order}%
\indexlibrarymember{acq_rel}{memory_order}%
\indexlibrarymember{seq_cst}{memory_order}%
\indexlibrary{memory_order_relaxed}%
\indexlibrary{memory_order_consume}%
\indexlibrary{memory_order_acquire}%
\indexlibrary{memory_order_release}%
\indexlibrary{memory_order_acq_rel}%
\indexlibrary{memory_order_seq_cst}%

\begin{codeblock}
namespace std {
  enum class memory_order : @\unspec@ {
    relaxed, consume, acquire, release, acq_rel, seq_cst
  };
  inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
  inline constexpr memory_order memory_order_consume = memory_order::consume;
  inline constexpr memory_order memory_order_acquire = memory_order::acquire;
  inline constexpr memory_order memory_order_release = memory_order::release;
  inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
  inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
}
\end{codeblock}

\pnum
The enumeration \tcode{memory_order} specifies the detailed regular
(non-atomic) memory synchronization order as defined in
\ref{intro.multithread} and may provide for operation ordering. Its
enumerated values and their meanings are as follows:

\begin{itemize}
\item \tcode{memory_order::relaxed}: no operation orders memory.

\item \tcode{memory_order::release}, \tcode{memory_order::acq_rel}, and
\tcode{memory_order::seq_cst}: a store operation performs a release operation on the
affected memory location.

\item \tcode{memory_order::consume}: a load operation performs a consume operation on the
affected memory location.
\begin{note} Prefer \tcode{memory_order::acquire}, which provides stronger guarantees
than \tcode{memory_order::consume}. Implementations have found it infeasible
to provide performance better than that of \tcode{memory_order::acquire}.
Specification revisions are under consideration. \end{note}

\item \tcode{memory_order::acquire}, \tcode{memory_order::acq_rel}, and
\tcode{memory_order::seq_cst}: a load operation performs an acquire operation on the
affected memory location.
\end{itemize}

\begin{note} Atomic operations specifying \tcode{memory_order::relaxed} are relaxed
with respect to memory ordering. Implementations must still guarantee that any
given atomic access to a particular atomic object be indivisible with respect
to all other atomic accesses to that object. \end{note}

\pnum
An atomic operation \placeholder{A} that performs a release operation on an atomic
object \placeholder{M} synchronizes with an atomic operation \placeholder{B} that performs
an acquire operation on \placeholder{M} and takes its value from any side effect in the
release sequence headed by \placeholder{A}.

\pnum
There shall be a single total order \placeholder{S} on all \tcode{memory_order::seq_cst}
operations, consistent with the ``happens before'' order and modification orders for all
affected locations, such that each \tcode{memory_order::seq_cst} operation
\placeholder{B} that loads a
value from an atomic object \placeholder{M}
observes one of the following values:

\begin{itemize}
\item the result of the last modification \placeholder{A} of \placeholder{M} that precedes
\placeholder{B} in \placeholder{S}, if it exists, or

\item if \placeholder{A} exists, the result of some modification of \placeholder{M}
that is not
\tcode{memory_order::seq_cst} and that does not happen before \placeholder{A}, or

\item if \placeholder{A} does not exist, the result of some modification of \placeholder{M}
that is not
\tcode{memory_order::seq_cst}.
\end{itemize}

\begin{note} Although it is not explicitly required that \placeholder{S} include locks, it can
always be extended to an order that does include lock and unlock operations, since the
ordering between those is already included in the ``happens before'' ordering. \end{note}

\pnum
For an atomic operation \placeholder{B} that reads the value of an atomic object \placeholder{M},
if there is a \tcode{memory_order::seq_cst} fence \placeholder{X} sequenced before \placeholder{B},
then \placeholder{B} observes either the last \tcode{memory_order::seq_cst} modification of
\placeholder{M} preceding \placeholder{X} in the total order \placeholder{S} or a later modification of
\placeholder{M} in its modification order.

\pnum
For atomic operations \placeholder{A} and \placeholder{B} on an atomic object \placeholder{M}, where
\placeholder{A} modifies \placeholder{M} and \placeholder{B} takes its value, if there is a
\tcode{memory_order::seq_cst} fence \placeholder{X} such that \placeholder{A} is sequenced before
\placeholder{X} and \placeholder{B} follows \placeholder{X} in \placeholder{S}, then \placeholder{B} observes
either the effects of \placeholder{A} or a later modification of \placeholder{M} in its
modification order.

\pnum
For atomic operations \placeholder{A} and \placeholder{B} on an atomic object \placeholder{M}, where
\placeholder{A} modifies \placeholder{M} and \placeholder{B} takes its value, if there are
\tcode{memory_order::seq_cst} fences \placeholder{X} and \placeholder{Y} such that \placeholder{A} is
sequenced before \placeholder{X}, \placeholder{Y} is sequenced before \placeholder{B}, and \placeholder{X}
precedes \placeholder{Y} in \placeholder{S}, then \placeholder{B} observes either the effects of
\placeholder{A} or a later modification of \placeholder{M} in its modification order.

\pnum
For atomic modifications \placeholder{A} and \placeholder{B} of an atomic object \placeholder{M},
\placeholder{B} occurs later than \placeholder{A} in the modification order of \placeholder{M} if:

\begin{itemize}
\item there is a \tcode{memory_order::seq_cst} fence \placeholder{X} such that \placeholder{A}
is sequenced before \placeholder{X}, and \placeholder{X} precedes \placeholder{B} in \placeholder{S}, or
\item there is a \tcode{memory_order::seq_cst} fence \placeholder{Y} such that \placeholder{Y}
is sequenced before \placeholder{B}, and \placeholder{A} precedes \placeholder{Y} in \placeholder{S}, or
\item there are \tcode{memory_order::seq_cst} fences \placeholder{X} and \placeholder{Y} such that \placeholder{A}
is sequenced before \placeholder{X}, \placeholder{Y} is sequenced before \placeholder{B},
and \placeholder{X} precedes \placeholder{Y} in \placeholder{S}.
\end{itemize}


\pnum
\begin{note} \tcode{memory_order::seq_cst} ensures sequential consistency only for a
program that is free of data races and uses exclusively \tcode{memory_order::seq_cst}
operations. Any use of weaker ordering will invalidate this guarantee unless extreme
care is used. In particular, \tcode{memory_order::seq_cst} fences ensure a total order
only for the fences themselves. Fences cannot, in general, be used to restore sequential
consistency for atomic operations with weaker ordering specifications. \end{note}

\pnum
Implementations should ensure that no ``out-of-thin-air'' values are computed that
circularly depend on their own computation.

\begin{note} For example, with \tcode{x} and \tcode{y} initially zero,

\begin{codeblock}
// Thread 1:
r1 = y.load(memory_order::relaxed);
x.store(r1, memory_order::relaxed);
\end{codeblock}

\begin{codeblock}
// Thread 2:
r2 = x.load(memory_order::relaxed);
y.store(r2, memory_order::relaxed);
\end{codeblock}

should not produce \tcode{r1 == r2 == 42}, since the store of 42 to \tcode{y} is only
possible if the store to \tcode{x} stores \tcode{42}, which circularly depends on the
store to \tcode{y} storing \tcode{42}. Note that without this restriction, such an
execution is possible.
\end{note}

\pnum
\begin{note} The recommendation similarly disallows \tcode{r1 == r2 == 42} in the
following example, with \tcode{x} and \tcode{y} again initially zero:

\begin{codeblock}
// Thread 1:
r1 = x.load(memory_order::relaxed);
if (r1 == 42) y.store(42, memory_order::relaxed);
\end{codeblock}

\begin{codeblock}
// Thread 2:
r2 = y.load(memory_order::relaxed);
if (r2 == 42) x.store(42, memory_order::relaxed);
\end{codeblock}

\end{note}

\pnum
Atomic read-modify-write operations shall always read the last value
(in the modification order) written before the write associated with
the read-modify-write operation.

\pnum
Implementations should make atomic stores visible to atomic loads within a reasonable
amount of time.

\indexlibrary{\idxcode{kill_dependency}}%
\begin{itemdecl}
template<class T>
  T kill_dependency(T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The argument does not carry a dependency to the return
value\iref{intro.multithread}.

\pnum
\returns \tcode{y}.
\end{itemdescr}


\rSec1[atomics.lockfree]{Lock-free property}

\indexlibrary{\idxcode{ATOMIC_BOOL_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR16_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR32_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_WCHAR_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_SHORT_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_INT_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_LONG_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_LLONG_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_POINTER_LOCK_FREE}}%
\indeximpldef{values of various \tcode{ATOMIC_..._LOCK_FREE} macros}
\begin{codeblock}
#define ATOMIC_BOOL_LOCK_FREE @\unspec@
#define ATOMIC_CHAR_LOCK_FREE @\unspec@
#define ATOMIC_CHAR16_T_LOCK_FREE @\unspec@
#define ATOMIC_CHAR32_T_LOCK_FREE @\unspec@
#define ATOMIC_WCHAR_T_LOCK_FREE @\unspec@
#define ATOMIC_SHORT_LOCK_FREE @\unspec@
#define ATOMIC_INT_LOCK_FREE @\unspec@
#define ATOMIC_LONG_LOCK_FREE @\unspec@
#define ATOMIC_LLONG_LOCK_FREE @\unspec@
#define ATOMIC_POINTER_LOCK_FREE @\unspec@
\end{codeblock}

\pnum
The \tcode{ATOMIC_..._LOCK_FREE} macros indicate the lock-free property of the
corresponding atomic types, with the signed and unsigned variants grouped
together. The properties also apply to the corresponding (partial) specializations of the
\tcode{atomic} template. A value of 0 indicates that the types are never
lock-free. A value of 1 indicates that the types are sometimes lock-free. A
value of 2 indicates that the types are always lock-free.

\pnum
The function \tcode{atomic_is_lock_free}\iref{atomics.types.operations}
indicates whether the object is lock-free. In any given program execution, the
result of the lock-free query shall be consistent for all pointers of the same
type.

\pnum
Atomic operations that are not lock-free are considered to potentially
block\iref{intro.progress}.

\pnum
\begin{note} Operations that are lock-free should also be address-free. That is,
atomic operations on the same memory location via two different addresses will
communicate atomically. The implementation should not depend on any
per-process state. This restriction enables communication  by memory that is
mapped into a process more than once and by memory that is shared between two
processes. \end{note}

\rSec1[atomics.types.generic]{Class template \tcode{atomic}}

\indexlibrary{\idxcode{atomic}}%
\indexlibrarymember{value_type}{atomic}%
\begin{codeblock}
namespace std {
  template<class T> struct atomic {
    using value_type = T;
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order::seq_cst) noexcept;
    T load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T load(memory_order = memory_order::seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&, T, memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T&, T, memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{atomic}}%
\pnum
The template argument for
\tcode{T} shall be trivially copyable\iref{basic.types}. \begin{note} Type arguments that are
not also statically initializable may be difficult to use. \end{note}

\pnum
The specialization \tcode{atomic<bool>} is a standard-layout struct.

\pnum
\begin{note} The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. \end{note}

\rSec2[atomics.types.operations]{Operations on atomic types}

\pnum
\begin{note} Many operations are volatile-qualified. The ``volatile as device register''
semantics have not changed in the standard. This qualification means that volatility is
preserved when applying these operations to volatile objects. It does not mean that
operations on non-volatile objects become volatile. \end{note}

\indexlibrary{\idxcode{atomic}!constructor}%
\indexlibrary{\idxcode{atomic<T*>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{integral}>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{floating-point}>}!constructor}%
\begin{itemdecl}
atomic() noexcept = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Leaves the atomic object in an uninitialized state.
\begin{note}
These semantics ensure compatibility with C.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic}!constructor}%
\indexlibrary{\idxcode{atomic<T*>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{integral}>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{floating-point}>}!constructor}%
\begin{itemdecl}
constexpr atomic(T desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the object with the value \tcode{desired}.
Initialization is not an atomic operation\iref{intro.multithread}.
\begin{note} It is possible to have an access to an atomic object \tcode{A}
race with its construction, for example by communicating the address of the
just-constructed object \tcode{A} to another thread via
\tcode{memory_order::relaxed} operations on a suitable atomic pointer
variable, and then immediately accessing \tcode{A} in the receiving thread.
This results in undefined behavior. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{ATOMIC_VAR_INIT}}%
\begin{itemdecl}
#define ATOMIC_VAR_INIT(value) @\seebelow@
\end{itemdecl}

\begin{itemdescr}
\pnum
The macro expands to a token sequence suitable for
constant initialization of
an atomic variable of static storage duration of a type that is
initialization-compatible with \tcode{value}.
\begin{note} This operation may need to initialize locks. \end{note}
Concurrent access to the variable being initialized, even via an atomic operation,
constitutes a data race. \begin{example}
\begin{codeblock}
atomic<int> v = ATOMIC_VAR_INIT(5);
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{is_always_lock_free}{atomic}%
\indexlibrarymember{is_always_lock_free}{atomic<T*>}%
\indexlibrarymember{is_always_lock_free}{atomic<\placeholder{integral}>}%
\indexlibrarymember{is_always_lock_free}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{static} data member \tcode{is_always_lock_free} is \tcode{true}
if the atomic type's operations are always lock-free, and \tcode{false} otherwise.
\begin{note}
The value of \tcode{is_always_lock_free} is consistent with the value of
the corresponding \tcode{ATOMIC_..._LOCK_FREE} macro, if defined.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_is_lock_free}}%
\indexlibrarymember{is_lock_free}{atomic}%
\indexlibrarymember{is_lock_free}{atomic<T*>}%
\indexlibrarymember{is_lock_free}{atomic<\placeholder{integral}>}%
\indexlibrarymember{is_lock_free}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if the object's operations are lock-free, \tcode{false} otherwise.
\begin{note}
The return value of the \tcode{is_lock_free} member function
is consistent with the value of \tcode{is_always_lock_free} for the same type.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_store}}%
\indexlibrary{\idxcode{atomic_store_explicit}}%
\indexlibrarymember{store}{atomic}%
\indexlibrarymember{store}{atomic<T*>}%
\indexlibrarymember{store}{atomic<\placeholder{integral}>}%
\indexlibrarymember{store}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
void store(T desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order::consume},
\tcode{memory_order::acquire}, nor \tcode{memory_order::acq_rel}.

\pnum
\effects Atomically replaces the value pointed to by \tcode{this}
with the value of \tcode{desired}. Memory is affected according to the value of
\tcode{order}.
\end{itemdescr}

\indexlibrarymember{operator=}{atomic}%
\indexlibrarymember{operator=}{atomic<T*>}%
\indexlibrarymember{operator=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator=}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
T operator=(T desired) volatile noexcept;
T operator=(T desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{store(desired)}.

\pnum
\returns \tcode{desired}.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_load}}%
\indexlibrary{\idxcode{atomic_load_explicit}}%
\indexlibrarymember{load}{atomic}%
\indexlibrarymember{load}{atomic<T*>}%
\indexlibrarymember{load}{atomic<\placeholder{integral}>}%
\indexlibrarymember{load}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
T load(memory_order order = memory_order::seq_cst) const volatile noexcept;
T load(memory_order order = memory_order::seq_cst) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order::release} nor \tcode{memory_order::acq_rel}.

\pnum
\effects Memory is affected according to the value of \tcode{order}.

\pnum
\returns Atomically returns the value pointed to by \tcode{this}.
\end{itemdescr}

\indexlibrarymember{operator \placeholder{type}}{atomic}%
\indexlibrarymember{operator T*}{atomic<T*>}%
\indexlibrarymember{operator \placeholder{integral}}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator \placeholder{floating-point}}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
operator T() const volatile noexcept;
operator T() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return load();}
\end{itemdescr}


\indexlibrary{\idxcode{atomic_exchange}}%
\indexlibrary{\idxcode{atomic_exchange_explicit}}%
\indexlibrarymember{exchange}{atomic}%
\indexlibrarymember{exchange}{atomic<T*>}%
\indexlibrarymember{exchange}{atomic<\placeholder{integral}>}%
\indexlibrarymember{exchange}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
T exchange(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
T exchange(T desired, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically replaces the value pointed to by \tcode{this}
with \tcode{desired}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations\iref{intro.multithread}.

\pnum
\returns Atomically returns the value pointed to by \tcode{this} immediately before the effects.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_compare_exchange_weak}}%
\indexlibrary{\idxcode{atomic_compare_exchange_strong}}%
\indexlibrary{\idxcode{atomic_compare_exchange_weak_explicit}}%
\indexlibrary{\idxcode{atomic_compare_exchange_strong_explicit}}%
\indexlibrarymember{compare_exchange_weak}{atomic}%
\indexlibrarymember{compare_exchange_weak}{atomic<T*>}%
\indexlibrarymember{compare_exchange_weak}{atomic<\placeholder{integral}>}%
\indexlibrarymember{compare_exchange_weak}{atomic<\placeholder{floating-point}>}%
\indexlibrarymember{compare_exchange_strong}{atomic}%
\indexlibrarymember{compare_exchange_strong}{atomic<T*>}%
\indexlibrarymember{compare_exchange_strong}{atomic<\placeholder{integral}>}%
\indexlibrarymember{compare_exchange_strong}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
bool compare_exchange_weak(T& expected, T desired,
                           memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_weak(T& expected, T desired,
                           memory_order success, memory_order failure) noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order success, memory_order failure) noexcept;
bool compare_exchange_weak(T& expected, T desired,
                           memory_order order = memory_order::seq_cst) volatile noexcept;
bool compare_exchange_weak(T& expected, T desired,
                           memory_order order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order order = memory_order::seq_cst) volatile noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{failure} argument shall not be \tcode{memory_order::release} nor
\tcode{memory_order::acq_rel}.

\pnum
\effects Retrieves the value in \tcode{expected}. It then atomically
compares the contents of the memory pointed to by \tcode{this}
for equality with that previously retrieved from \tcode{expected},
and if true, replaces the contents of the memory pointed to
by \tcode{this} with that in \tcode{desired}.
If and only if the comparison is true, memory is affected according to the
value of \tcode{success}, and if the comparison is false, memory is affected according
to the value of \tcode{failure}. When only one \tcode{memory_order} argument is
supplied, the value of \tcode{success} is \tcode{order}, and the value of
\tcode{failure} is \tcode{order} except that a value of \tcode{memory_order::acq_rel}
shall be replaced by the value \tcode{memory_order::acquire} and a value of
\tcode{memory_order::release} shall be replaced by the value
\tcode{memory_order::relaxed}.
If and only if the comparison is false then, after the atomic operation,
the contents of the memory in \tcode{expected} are replaced by the value
read from the memory pointed to by \tcode{this} during the atomic comparison.
If the operation returns \tcode{true}, these
operations are atomic read-modify-write
operations\iref{intro.multithread} on the memory
pointed to by \tcode{this}.
Otherwise, these operations are atomic load operations on that memory.

\pnum
\returns The result of the comparison.

\pnum
\begin{note} For example, the effect of
\tcode{compare_exchange_strong} is
\begin{codeblock}
if (memcmp(this, &expected, sizeof(*this)) == 0)
  memcpy(this, &desired, sizeof(*this));
else
  memcpy(expected, this, sizeof(*this));
\end{codeblock}
\end{note}
\begin{example} The expected use of the compare-and-exchange operations is as follows. The
compare-and-exchange operations will update \tcode{expected} when another iteration of
the loop is needed.
\begin{codeblock}
expected = current.load();
do {
  desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));
\end{codeblock}
\end{example}
\begin{example} Because the expected value is updated only on failure,
code releasing the memory containing the \tcode{expected} value on success will work.
E.g. list head insertion will act atomically and would not introduce a
data race in the following code:
\begin{codeblock}
do {
  p->next = head; // make new list node point to the current head
} while (!head.compare_exchange_weak(p->next, p)); // try to insert
\end{codeblock}
\end{example}

\pnum
Implementations should ensure that weak compare-and-exchange operations do not
consistently return \tcode{false} unless either the atomic object has value
different from \tcode{expected} or there are concurrent modifications to the
atomic object.

\pnum
\remarks
A weak compare-and-exchange operation may fail spuriously. That is, even when
the contents of memory referred to by \tcode{expected} and \tcode{this} are
equal, it may return \tcode{false} and store back to \tcode{expected} the same memory
contents that were originally there.
\begin{note} This
spurious failure enables implementation of compare-and-exchange on a broader class of
machines, e.g., load-locked store-conditional machines. A
consequence of spurious failure is that nearly all uses of weak compare-and-exchange
will be in a loop.
When a compare-and-exchange is in a loop, the weak version will yield better performance
on some platforms. When a weak compare-and-exchange would require a loop and a strong one
would not, the strong one is preferable.
\end{note}

\pnum
\begin{note} The \tcode{memcpy} and \tcode{memcmp} semantics of the compare-and-exchange
operations may result in failed comparisons for values that compare equal with
\tcode{operator==} if the underlying type has padding bits, trap bits, or alternate
representations of the same value. Notably, floating-point \tcode{-0.} and \tcode{0.}
will compare not-equal and NaNs with the same payload will compare equal.\end{note}
\end{itemdescr}

\rSec2[atomics.types.int]{Specializations for integers}

\indexlibrary{\idxcode{atomic<\placeholder{integral}>}}%
\pnum
There are specializations of the \tcode{atomic}
template for the integral types
\tcode{char},
\tcode{signed char},
\tcode{unsigned char},
\tcode{short},
\tcode{unsigned short},
\tcode{int},
\tcode{unsigned int},
\tcode{long},
\tcode{unsigned long},
\tcode{long long},
\tcode{unsigned long long},
\tcode{char16_t},
\tcode{char32_t},
\tcode{wchar_t},
and any other types needed by the typedefs in the header \tcode{<cstdint>}.
For each such integral type \tcode{\placeholder{integral}}, the specialization
\tcode{atomic<\placeholder{integral}>} provides additional atomic operations appropriate to integral types.
\begin{note}
For the specialization \tcode{atomic<bool>}, see \ref{atomics.types.generic}.
\end{note}

\begin{codeblock}
namespace std {
  template<> struct atomic<@\placeholder{integral}@> {
    using value_type = @\placeholder{integral}@;
    using difference_type = value_type;
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ load(memory_order = memory_order::seq_cst) const volatile noexcept;
    @\placeholdernc{integral}@ load(memory_order = memory_order::seq_cst) const noexcept;
    operator @\placeholdernc{integral}@() const volatile noexcept;
    operator @\placeholdernc{integral}@() const noexcept;
    @\placeholdernc{integral}@ exchange(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ exchange(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&, @\placeholdernc{integral}@,
                                 memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_add(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_add(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_sub(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_sub(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_and(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_and(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_or(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_or(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_xor(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_xor(@\placeholdernc{integral}@, memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(@\placeholdernc{integral}@) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    @\placeholdernc{integral}@ operator=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator=(@\placeholdernc{integral}@) noexcept;

    @\placeholdernc{integral}@ operator++(int) volatile noexcept;
    @\placeholdernc{integral}@ operator++(int) noexcept;
    @\placeholdernc{integral}@ operator--(int) volatile noexcept;
    @\placeholdernc{integral}@ operator--(int) noexcept;
    @\placeholdernc{integral}@ operator++() volatile noexcept;
    @\placeholdernc{integral}@ operator++() noexcept;
    @\placeholdernc{integral}@ operator--() volatile noexcept;
    @\placeholdernc{integral}@ operator--() noexcept;
    @\placeholdernc{integral}@ operator+=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator+=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator-=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator-=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator&=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator&=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator|=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator|=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator^=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator^=(@\placeholdernc{integral}@) noexcept;
  };
}
\end{codeblock}

\pnum
The atomic integral specializations
are standard-layout structs.
They each have a trivial default constructor
and a trivial destructor.

\pnum
Descriptions are provided below only for members that differ from the primary template.

\pnum
The following operations perform arithmetic computations. The key, operator, and computation correspondence is:

\begin{floattable}
{Atomic arithmetic computations}{tab:atomic.arithmetic.computations}{lll|lll}
\hline
\hdstyle{\tcode{\placeholder{key}}}   &
  \hdstyle{Op}                        &
  \hdstyle{Computation}               &
\hdstyle{\tcode{\placeholder{key}}}   &
  \hdstyle{Op}                        &
  \hdstyle{Computation}  \\ \hline
\tcode{add}       &
  \tcode{+}       &
  addition        &
\tcode{sub}       &
  \tcode{-}       &
  subtraction     \\
\tcode{or}        &
  \tcode{|}       &
  bitwise inclusive or  &
\tcode{xor}       &
  \tcode{\caret}        &
  bitwise exclusive or  \\
\tcode{and}       &
  \tcode{\&}      &
  bitwise and     &&&\\\hline
\end{floattable}

\indexlibrary{\idxcode{atomic_fetch_add}}%
\indexlibrary{\idxcode{atomic_fetch_and}}%
\indexlibrary{\idxcode{atomic_fetch_or}}%
\indexlibrary{\idxcode{atomic_fetch_sub}}%
\indexlibrary{\idxcode{atomic_fetch_xor}}%
\indexlibrary{\idxcode{atomic_fetch_add_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_and_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_or_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_sub_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_xor_explicit}}%
\indexlibrarymember{fetch_add}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_and}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_or}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_sub}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_xor}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T fetch_@\placeholdernc{key}@(T operand, memory_order order = memory_order::seq_cst) volatile noexcept;
T fetch_@\placeholdernc{key}@(T operand, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically replaces the value pointed to by
\tcode{this} with the result of the computation applied to the
value pointed to by \tcode{this} and the given \tcode{operand}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations\iref{intro.multithread}.

\pnum
\returns Atomically, the value pointed to by \tcode{this} immediately before the effects.

\pnum
\indextext{signed integer representation!two's complement}%
\remarks For signed integer types, arithmetic is defined to use two's complement representation.
There are no undefined results.
\end{itemdescr}

\indexlibrarymember{operator+=}{atomic<T*>}%
\indexlibrarymember{operator-=}{atomic<T*>}%
\indexlibrarymember{operator+=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator-=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator\&=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator"|=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator\caret=}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T operator @\placeholder{op}@=(T operand) volatile noexcept;
T operator @\placeholder{op}@=(T operand) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_\placeholder{key}(operand) \placeholder{op} operand;}
\end{itemdescr}

\rSec2[atomics.types.float]{Specializations for floating-point types}

\indexlibrary{\idxcode{atomic<\placeholder{floating-point}>}}%
\pnum
There are specializations of the \tcode{atomic}
template for the floating-point types
\tcode{float},
\tcode{double}, and
\tcode{long double}.
For each such floating-point type \tcode{\placeholdernc{floating-point}},
the specialization \tcode{atomic<\placeholder{floating-point}>}
provides additional atomic operations appropriate to floating-point types.

\begin{codeblock}
namespace std {
  template<> struct atomic<@\placeholder{floating-point}@> {
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(@\placeholdernc{floating-point}@, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(@\placeholdernc{floating-point}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{floating-point}@ load(memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{floating-point}@ load(memory_order = memory_order_seq_cst) noexcept;
    operator @\placeholdernc{floating-point}@() volatile noexcept;
    operator @\placeholdernc{floating-point}@() noexcept;
    @\placeholdernc{floating-point}@ exchange(@\placeholdernc{floating-point}@,
                            memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{floating-point}@ exchange(@\placeholdernc{floating-point}@,
                            memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                               memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                                 memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{floating-point}@&, @\placeholdernc{floating-point}@,
                                 memory_order = memory_order_seq_cst) noexcept;

    @\placeholdernc{floating-point}@ fetch_add(@\placeholdernc{floating-point}@,
                             memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{floating-point}@ fetch_add(@\placeholdernc{floating-point}@,
                             memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{floating-point}@ fetch_sub(@\placeholdernc{floating-point}@,
                             memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{floating-point}@ fetch_sub(@\placeholdernc{floating-point}@,
                             memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(@\placeholder{floating-point}@) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    @\placeholdernc{floating-point}@ operator=(@\placeholder{floating-point}@) volatile noexcept;
    @\placeholdernc{floating-point}@ operator=(@\placeholder{floating-point}@) noexcept;

    @\placeholdernc{floating-point}@ operator+=(@\placeholder{floating-point}@) volatile noexcept;
    @\placeholdernc{floating-point}@ operator+=(@\placeholder{floating-point}@) noexcept;
    @\placeholdernc{floating-point}@ operator-=(@\placeholder{floating-point}@) volatile noexcept;
    @\placeholdernc{floating-point}@ operator-=(@\placeholder{floating-point}@) noexcept;
  };
}
\end{codeblock}

\pnum
The atomic floating-point specializations
are standard-layout structs.
They each have a trivial default constructor
and a trivial destructor.

\pnum
Descriptions are provided below only for members that differ from the primary template.

\pnum
The following operations perform arithmetic addition and subtraction computations.
The key, operator, and computation correspondence are identified in
Table~\ref{tab:atomic.arithmetic.computations}.

\indexlibrary{\idxcode{atomic_fetch_add}}%
\indexlibrary{\idxcode{atomic_fetch_sub}}%
\indexlibrary{\idxcode{atomic_fetch_add_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_sub_explicit}}%
\indexlibrarymember{fetch_add}{atomic<\placeholder{floating-point}>}%
\indexlibrarymember{fetch_sub}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
T A::fetch_@\placeholdernc{key}@(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
T A::fetch_@\placeholdernc{key}@(T operand, memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Atomically replaces the value pointed to by \tcode{this}
with the result of the computation applied to the value pointed
to by \tcode{this} and the given \tcode{operand}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations\iref{intro.multithread}.

\pnum
\returns
Atomically, the value pointed to by \tcode{this} immediately before the effects.

\pnum
\remarks
If the result is not a representable value for its type\iref{expr.pre}
the result is unspecified, but the operations otherwise have no undefined
behavior. Atomic arithmetic operations on \tcode{\placeholder{floating-point}}
should conform to the \tcode{std::numeric_limits<\placeholder{floating-point}>}
traits associated with the floating-point type\iref{limits.syn}.
The floating-point environment\iref{cfenv} for atomic arithmetic operations
on \tcode{\placeholder{floating-point}} may be different than the
calling thread's floating-point environment.
\end{itemdescr}

\indexlibrarymember{operator+=}{atomic<T*>}%
\indexlibrarymember{operator-=}{atomic<T*>}%
\indexlibrarymember{operator+=}{atomic<\placeholder{floating-point}>}%
\indexlibrarymember{operator-=}{atomic<\placeholder{floating-point}>}%
\begin{itemdecl}
T operator @\placeholder{op}@=(T operand) volatile noexcept;
T operator @\placeholder{op}@=(T operand) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return fetch_\placeholder{key}(operand) \placeholder{op} operand;}

\pnum
\remarks
If the result is not a representable value for its type\iref{expr.pre}
the result is unspecified, but the operations otherwise have no undefined
behavior. Atomic arithmetic operations on \tcode{\placeholder{floating-point}}
should conform to the \tcode{std::numeric_limits<\placeholder{floating-point}>}
traits associated with the floating-point type\iref{limits.syn}.
The floating-point environment\iref{cfenv} for atomic arithmetic operations
on \tcode{\placeholder{floating-point}} may be different than the
calling thread's floating-point environment.
\end{itemdescr}

\rSec2[atomics.types.pointer]{Partial specialization for pointers}
\indexlibrary{\idxcode{atomic<T*>}}%

\begin{codeblock}
namespace std {
  template<class T> struct atomic<T*> {
    using value_type = T*;
    using difference_type = ptrdiff_t;
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order::seq_cst) noexcept;
    T* load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order::seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order::seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order::seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{atomic<T*>}}%
\pnum
There is a partial specialization of the \tcode{atomic} class template for pointers.
Specializations of this partial specialization are standard-layout structs.
They each have a trivial default constructor and a trivial destructor.

\pnum
Descriptions are provided below only for members that differ from the primary template.

\pnum
The following operations perform pointer arithmetic. The key, operator,
and computation correspondence is:

\begin{floattable}
{Atomic pointer computations}{tab:atomic.pointer.computations}{lll|lll}
\hline
\tcode{Key}       &
  Op          &
  Computation     &
\tcode{Key}       &
  Op          &
  Computation     \\ \hline
\tcode{add}       &
  \tcode{+}       &
  addition        &
\tcode{sub}       &
  \tcode{-}       &
  subtraction     \\ \hline
\end{floattable}

\indexlibrary{\idxcode{atomic_fetch_add}}%
\indexlibrary{\idxcode{atomic_fetch_sub}}%
\indexlibrary{\idxcode{atomic_fetch_add_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_sub_explicit}}%
\indexlibrarymember{fetch_add}{atomic<T*>}%
\indexlibrarymember{fetch_sub}{atomic<T*>}%
\begin{itemdecl}
T* fetch_@\placeholdernc{key}@(ptrdiff_t operand, memory_order order = memory_order::seq_cst) volatile noexcept;
T* fetch_@\placeholdernc{key}@(ptrdiff_t operand, memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires T shall be an object type, otherwise the program is ill-formed.
\begin{note} Pointer arithmetic on \tcode{void*} or function pointers is ill-formed. \end{note}

\pnum
\effects Atomically replaces the value pointed to by
\tcode{this} with the result of the computation applied to the
value pointed to by \tcode{this} and the given \tcode{operand}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations\iref{intro.multithread}.

\pnum
\returns Atomically, the value pointed to by \tcode{this} immediately before the effects.

\pnum
\remarks The result may be an undefined address,
but the operations otherwise have no undefined behavior.
\end{itemdescr}

\indexlibrarymember{operator+=}{atomic<T*>}%
\indexlibrarymember{operator-=}{atomic<T*>}%
\begin{itemdecl}
T* operator @\placeholder{op}@=(ptrdiff_t operand) volatile noexcept;
T* operator @\placeholder{op}@=(ptrdiff_t operand) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_\placeholder{key}(operand) \placeholder{op} operand;}
\end{itemdescr}

\rSec2[atomics.types.memop]{Member operators common to integers and pointers to objects}

\indexlibrarymember{operator++}{atomic<T*>}%
\indexlibrarymember{operator++}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T operator++(int) volatile noexcept;
T operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_add(1);}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{atomic<T*>}%
\indexlibrarymember{operator\dcr}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T operator--(int) volatile noexcept;
T operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_sub(1);}
\end{itemdescr}

\indexlibrarymember{operator++}{atomic<T*>}%
\indexlibrarymember{operator++}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T operator++() volatile noexcept;
T operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_add(1) + 1;}
\end{itemdescr}

\indexlibrarymember{operator\dcr}{atomic<T*>}%
\indexlibrarymember{operator\dcr}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
T operator--() volatile noexcept;
T operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return fetch_sub(1) - 1;}
\end{itemdescr}


\rSec1[atomics.nonmembers]{Non-member functions}

\pnum
A non-member function template whose name matches the pattern
\tcode{atomic_\placeholder{f}} or the pattern \tcode{atomic_\placeholder{f}_explicit}
invokes the member function \tcode{\placeholder{f}}, with the value of the
first parameter as the object expression and the values of the remaining parameters
(if any) as the arguments of the member function call, in order. An argument
for a parameter of type \tcode{atomic<T>::value_type*} is dereferenced when
passed to the member function call.
If no such member function exists, the program is ill-formed.

\indexlibrary{\idxcode{atomic_init}}%
\begin{itemdecl}
template<class T>
  void atomic_init(volatile atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
template<class T>
  void atomic_init(atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Non-atomically
initializes \tcode{*object} with value \tcode{desired}. This function shall only be applied
to objects that have been default constructed, and then only once.
\begin{note}
These semantics ensure compatibility with C.
\end{note}
\begin{note}
Concurrent access from another thread, even via an atomic operation, constitutes
a data race.
\end{note}
\end{itemdescr}

\pnum
\begin{note}
The non-member functions enable programmers to write code that can be
compiled as either C or C++, for example in a shared header file.
\end{note}

\rSec1[atomics.flag]{Flag type and operations}

\begin{codeblock}
namespace std {
  struct atomic_flag {
    bool test_and_set(memory_order = memory_order::seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order::seq_cst) noexcept;
    void clear(memory_order = memory_order::seq_cst) volatile noexcept;
    void clear(memory_order = memory_order::seq_cst) noexcept;

    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
  };

  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;

  #define ATOMIC_FLAG_INIT @\seebelow@
}
\end{codeblock}

\pnum
The \tcode{atomic_flag} type provides the classic test-and-set functionality. It has two states, set and clear.

\pnum
Operations on an object of type \tcode{atomic_flag} shall be lock-free. \begin{note} Hence
the operations should also be address-free. \end{note}

\pnum
The \tcode{atomic_flag} type is a standard-layout struct.
It has a trivial default constructor and a trivial destructor.

\pnum
The macro \tcode{ATOMIC_FLAG_INIT} shall be defined in such a way that it can be used to initialize an object of type \tcode{atomic_flag} to the
clear state. The macro can be used in the form:
\begin{codeblock}
atomic_flag guard = ATOMIC_FLAG_INIT;
\end{codeblock}
It is unspecified whether the macro can be used in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
Unless initialized with \tcode{ATOMIC_FLAG_INIT}, it is unspecified whether an
\tcode{atomic_flag} object has an initial state of set or clear.

\indexlibrary{\idxcode{atomic_flag_test_and_set}}%
\indexlibrary{\idxcode{atomic_flag_test_and_set_explicit}}%
\indexlibrarymember{test_and_set}{atomic_flag}%
\begin{itemdecl}
bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order::seq_cst) volatile noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically sets the value pointed to by \tcode{object} or by \tcode{this} to \tcode{true}. Memory is affected according to the value of
\tcode{order}. These operations are atomic read-modify-write operations\iref{intro.multithread}.

\pnum
\returns Atomically, the value of the object immediately before the effects.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_flag_clear}}%
\indexlibrary{\idxcode{atomic_flag_clear_explicit}}%
\indexlibrarymember{clear}{atomic_flag}%
\begin{itemdecl}
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order::seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = memory_order::seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order::consume},
\tcode{memory_order::acquire}, nor \tcode{memory_order::acq_rel}.

\pnum
\effects Atomically sets the value pointed to by \tcode{object} or by \tcode{this} to
\tcode{false}. Memory is affected according to the value of \tcode{order}.
\end{itemdescr}

\rSec1[atomics.fences]{Fences}

\pnum
This subclause introduces synchronization primitives called \term{fences}. Fences can have
acquire semantics, release semantics, or both. A fence with acquire semantics is called
an \term{acquire fence}. A fence with release semantics is called a \term{release
fence}.

\pnum
A release fence \placeholder{A} synchronizes with an acquire fence \placeholder{B} if there exist
atomic operations \placeholder{X} and \placeholder{Y}, both operating on some atomic object
\placeholder{M}, such that \placeholder{A} is sequenced before \placeholder{X}, \placeholder{X} modifies
\placeholder{M}, \placeholder{Y} is sequenced before \placeholder{B}, and \placeholder{Y} reads the value
written by \placeholder{X} or a value written by any side effect in the hypothetical release
sequence \placeholder{X} would head if it were a release operation.

\pnum
A release fence \placeholder{A} synchronizes with an atomic operation \placeholder{B} that
performs an acquire operation on an atomic object \placeholder{M} if there exists an atomic
operation \placeholder{X} such that \placeholder{A} is sequenced before \placeholder{X}, \placeholder{X}
modifies \placeholder{M}, and \placeholder{B} reads the value written by \placeholder{X} or a value
written by any side effect in the hypothetical release sequence \placeholder{X} would head if
it were a release operation.

\pnum
An atomic operation \placeholder{A} that is a release operation on an atomic object
\placeholder{M} synchronizes with an acquire fence \placeholder{B} if there exists some atomic
operation \placeholder{X} on \placeholder{M} such that \placeholder{X} is sequenced before \placeholder{B}
and reads the value written by \placeholder{A} or a value written by any side effect in the
release sequence headed by \placeholder{A}.

\indexlibrary{\idxcode{atomic_thread_fence}}%
\begin{itemdecl}
extern "C" void atomic_thread_fence(memory_order order) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Depending on the value of \tcode{order}, this operation:

\begin{itemize}
\item has no effects, if \tcode{order == memory_order::relaxed};

\item is an acquire fence, if \tcode{order == memory_order::acquire} or \tcode{order == memory_order::consume};

\item is a release fence, if \tcode{order == memory_order::release};

\item is both an acquire fence and a release fence, if \tcode{order == memory_order::acq_rel};

\item is a sequentially consistent acquire and release fence, if \tcode{order == memory_order::seq_cst}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_signal_fence}}%
\begin{itemdecl}
extern "C" void atomic_signal_fence(memory_order order) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{atomic_thread_fence(order)}, except that
the resulting ordering constraints are established only between a thread and a
signal handler executed in the same thread.

\pnum
\begin{note}
\tcode{atomic_signal_fence} can be used to specify the order in which actions
performed by the thread become visible to the signal handler.
Compiler optimizations and reorderings of loads and stores are inhibited in
the same way as with \tcode{atomic_thread_fence}, but the hardware fence instructions
that \tcode{atomic_thread_fence} would have inserted are not emitted.
\end{note}
\end{itemdescr}
