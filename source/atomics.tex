%!TEX root = std.tex
\rSec0[atomics]{Atomic operations library}

\rSec1[atomics.general]{General}

\pnum
This Clause describes components for fine-grained atomic access. This access is
provided via operations on atomic objects.

\pnum
The following subclauses describe atomics requirements and components for types
and operations, as summarized below.

\begin{libsumtab}{Atomics library summary}{tab:atomics.lib.summary}
\ref{atomics.order} & Order and Consistency   &
  \\
\ref{atomics.lockfree}  & Lock-free Property   &
  \\
\ref{atomics.types.generic} & Atomic Types   & \tcode{<atomic>}
  \\
\ref{atomics.types.operations}  & Operations on Atomic Types &
  \\
\ref{atomics.flag}  & Flag Type and Operations   &
  \\
\ref{atomics.fences}  & Fences   &
  \\
\end{libsumtab}

\rSec1[atomics.syn]{Header \tcode{<atomic>} synopsis}

\indextext{\idxhdr{atomic}}%
\indexlibrary{\idxhdr{atomic}}%
\begin{codeblock}
namespace std {
  // \ref{atomics.order}, order and consistency
  enum memory_order;
  template <class T>
    T kill_dependency(T y) noexcept;

  // \ref{atomics.lockfree}, lock-free property
  #define ATOMIC_BOOL_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR16_T_LOCK_FREE @\unspec@
  #define ATOMIC_CHAR32_T_LOCK_FREE @\unspec@
  #define ATOMIC_WCHAR_T_LOCK_FREE @\unspec@
  #define ATOMIC_SHORT_LOCK_FREE @\unspec@
  #define ATOMIC_INT_LOCK_FREE @\unspec@
  #define ATOMIC_LONG_LOCK_FREE @\unspec@
  #define ATOMIC_LLONG_LOCK_FREE @\unspec@
  #define ATOMIC_POINTER_LOCK_FREE @\unspec@

  // \ref{atomics.types.generic}, generic types
  template<class T> struct atomic;
  template<> struct atomic<@\placeholder{integral}@>;
  template<class T> struct atomic<T*>;

  // \ref{atomics.types.operations.general}, general operations on atomic types
  // In the following declarations, \tcode{\placeholder{atomic-type}} is either \tcode{atomic<T>} or a named base class
  // for \tcode{T} from Table~\ref{tab:atomics.integral} or inferred from Table~\ref{tab:atomics.typedefs} or from \tcode{bool}. If it is \tcode{atomic<T>},
  // then the declaration is a template declaration prefixed with \tcode{template <class T>}.
  bool atomic_is_lock_free(const volatile @\placeholder{atomic-type}@*) noexcept;
  bool atomic_is_lock_free(const @\placeholder{atomic-type}@*) noexcept;
  void atomic_init(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  void atomic_init(@\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  void atomic_store(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  void atomic_store(@\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  void atomic_store_explicit(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T, memory_order) noexcept;
  void atomic_store_explicit(@\placeholder{atomic-type}@*@\itcorr[-1]@, T, memory_order) noexcept;
  T atomic_load(const volatile @\placeholder{atomic-type}@*) noexcept;
  T atomic_load(const @\placeholder{atomic-type}@*) noexcept;
  T atomic_load_explicit(const volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, memory_order) noexcept;
  T atomic_load_explicit(const @\placeholder{atomic-type}@*@\itcorr[-1]@, memory_order) noexcept;
  T atomic_exchange(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  T atomic_exchange(@\placeholder{atomic-type}@*@\itcorr[-1]@, T) noexcept;
  T atomic_exchange_explicit(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T, memory_order) noexcept;
  T atomic_exchange_explicit(@\placeholder{atomic-type}@*@\itcorr[-1]@, T, memory_order) noexcept;
  bool atomic_compare_exchange_weak(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T) noexcept;
  bool atomic_compare_exchange_weak(@\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T) noexcept;
  bool atomic_compare_exchange_strong(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T) noexcept;
  bool atomic_compare_exchange_strong(@\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T) noexcept;
  bool atomic_compare_exchange_weak_explicit(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T, 
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_weak_explicit(@\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(volatile @\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(@\placeholder{atomic-type}@*@\itcorr[-1]@, T*, T,
    memory_order, memory_order) noexcept;

  // \ref{atomics.types.operations.templ}, templated operations on atomic types
  template <class T>
    T atomic_fetch_add(volatile @atomic<T>@*, T) noexcept;
  template <class T>
    T atomic_fetch_add(@atomic<T>@*, T) noexcept;
  template <class T>
    T atomic_fetch_add_explicit(volatile atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_add_explicit(atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_sub(volatile atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_sub(atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_sub_explicit(volatile atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_sub_explicit(atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_and(volatile atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_and(atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_and_explicit(volatile atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_and_explicit(atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_or(volatile atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_or(atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_or_explicit(volatile atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_or_explicit(atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_xor(volatile atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_xor(atomic<T>*, T) noexcept;
  template <class T>
    T atomic_fetch_xor_explicit(volatile atomic<T>*, T, memory_order) noexcept;
  template <class T>
    T atomic_fetch_xor_explicit(atomic<T>*, T, memory_order) noexcept;

  // \ref{atomics.types.operations.arith}, arithmetic operations on atomic types
  // In the following declarations, \tcode{\placeholder{atomic-integral}} is either \tcode{atomic<T>} or a named base class
  // for \tcode{T} from Table~\ref{tab:atomics.integral} or inferred from Table~\ref{tab:atomics.typedefs}. If it is \tcode{atomic<T>}, then the declaration
  // is a template specialization declaration prefixed with \tcode{template <>}.
  @\placeholdernc{integral}@ atomic_fetch_add(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_add(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_add_explicit(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_add_explicit(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_sub(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_sub(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_sub_explicit(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_sub_explicit(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_and(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_and(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_and_explicit(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_and_explicit(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_or(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_or(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_or_explicit(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_or_explicit(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_xor(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_xor(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_xor_explicit(volatile @\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;
  @\placeholdernc{integral}@ atomic_fetch_xor_explicit(@\placeholder{atomic-integral}@*@\itcorr[-1]@, @\placeholdernc{integral}@, memory_order) noexcept;

  // \ref{atomics.types.operations.pointer}, partial specializations for pointers
  template <class T>
    T* atomic_fetch_add(volatile atomic<T*>*, ptrdiff_t) noexcept;
  template <class T>
    T* atomic_fetch_add(atomic<T*>*, ptrdiff_t) noexcept;
  template <class T>
    T* atomic_fetch_add_explicit(volatile atomic<T*>*, ptrdiff_t, memory_order) noexcept;
  template <class T>
    T* atomic_fetch_add_explicit(atomic<T*>*, ptrdiff_t, memory_order) noexcept;
  template <class T>
    T* atomic_fetch_sub(volatile atomic<T*>*, ptrdiff_t) noexcept;
  template <class T>
    T* atomic_fetch_sub(atomic<T*>*, ptrdiff_t) noexcept;
  template <class T>
    T* atomic_fetch_sub_explicit(volatile atomic<T*>*, ptrdiff_t, memory_order) noexcept;
  template <class T>
    T* atomic_fetch_sub_explicit(atomic<T*>*, ptrdiff_t, memory_order) noexcept;

  // \ref{atomics.types.operations.req}, initialization
  #define ATOMIC_VAR_INIT(value) @\seebelow@

  // \ref{atomics.flag}, flag type and operations
  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT @\seebelow@

  // \ref{atomics.fences}, fences
  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
\end{codeblock}

\rSec1[atomics.order]{Order and consistency}

\begin{codeblock}
namespace std {
  enum memory_order {
    memory_order_relaxed, memory_order_consume, memory_order_acquire, 
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
  };
}
\end{codeblock}

\pnum
The enumeration \tcode{memory_order} specifies the detailed regular
(non-atomic) memory synchronization order as defined in
\ref{intro.multithread} and may provide for operation ordering. Its
enumerated values and their meanings are as follows:

\begin{itemize}
\item \tcode{memory_order_relaxed}: no operation orders memory.

\item \tcode{memory_order_release}, \tcode{memory_order_acq_rel}, and
\tcode{memory_order_seq_cst}: a store operation performs a release operation on the
affected memory location.

\item \tcode{memory_order_consume}: a load operation performs a consume operation on the
affected memory location.
\begin{note} Prefer \tcode{memory_order_acquire}, which provides stronger guarantees
than \tcode{memory_order_consume}. Implementations have found it infeasible
to provide performance better than that of \tcode{memory_order_acquire}.
Specification revisions are under consideration. \end{note}

\item \tcode{memory_order_acquire}, \tcode{memory_order_acq_rel}, and
\tcode{memory_order_seq_cst}: a load operation performs an acquire operation on the
affected memory location.
\end{itemize}

\begin{note} Atomic operations specifying \tcode{memory_order_relaxed} are relaxed
with respect to memory ordering. Implementations must still guarantee that any
given atomic access to a particular atomic object be indivisible with respect
to all other atomic accesses to that object. \end{note}

\pnum
An atomic operation \placeholder{A} that performs a release operation on an atomic
object \placeholder{M} synchronizes with an atomic operation \placeholder{B} that performs
an acquire operation on \placeholder{M} and takes its value from any side effect in the
release sequence headed by \placeholder{A}.

\pnum
There shall be a single total order \placeholder{S} on all \tcode{memory_order_seq_cst}
operations, consistent with the ``happens before'' order and modification orders for all
affected locations, such that each \tcode{memory_order_seq_cst} operation
\placeholder{B} that loads a
value from an atomic object \placeholder{M}
observes one of the following values:

\begin{itemize}
\item the result of the last modification \placeholder{A} of \placeholder{M} that precedes
\placeholder{B} in \placeholder{S}, if it exists, or

\item if \placeholder{A} exists, the result of some modification of \placeholder{M}
that is not
\tcode{memory_order_seq_cst} and that does not happen before \placeholder{A}, or

\item if \placeholder{A} does not exist, the result of some modification of \placeholder{M}
that is not
\tcode{memory_order_seq_cst}.
\end{itemize}

\begin{note} Although it is not explicitly required that \placeholder{S} include locks, it can
always be extended to an order that does include lock and unlock operations, since the
ordering between those is already included in the ``happens before'' ordering. \end{note}

\pnum
For an atomic operation \placeholder{B} that reads the value of an atomic object \placeholder{M},
if there is a \tcode{memory_order_seq_cst} fence \placeholder{X} sequenced before \placeholder{B},
then \placeholder{B} observes either the last \tcode{memory_order_seq_cst} modification of
\placeholder{M} preceding \placeholder{X} in the total order \placeholder{S} or a later modification of
\placeholder{M} in its modification order.

\pnum
For atomic operations \placeholder{A} and \placeholder{B} on an atomic object \placeholder{M}, where
\placeholder{A} modifies \placeholder{M} and \placeholder{B} takes its value, if there is a
\tcode{memory_order_seq_cst} fence \placeholder{X} such that \placeholder{A} is sequenced before
\placeholder{X} and \placeholder{B} follows \placeholder{X} in \placeholder{S}, then \placeholder{B} observes
either the effects of \placeholder{A} or a later modification of \placeholder{M} in its
modification order.

\pnum
For atomic operations \placeholder{A} and \placeholder{B} on an atomic object \placeholder{M}, where
\placeholder{A} modifies \placeholder{M} and \placeholder{B} takes its value, if there are
\tcode{memory_order_seq_cst} fences \placeholder{X} and \placeholder{Y} such that \placeholder{A} is
sequenced before \placeholder{X}, \placeholder{Y} is sequenced before \placeholder{B}, and \placeholder{X}
precedes \placeholder{Y} in \placeholder{S}, then \placeholder{B} observes either the effects of
\placeholder{A} or a later modification of \placeholder{M} in its modification order.

\pnum
For atomic modifications \placeholder{A} and \placeholder{B} of an atomic object \placeholder{M},
\placeholder{B} occurs later than \placeholder{A} in the modification order of \placeholder{M} if:

\begin{itemize}
\item there is a \tcode{memory_order_seq_cst} fence \placeholder{X} such that \placeholder{A}
is sequenced before \placeholder{X}, and \placeholder{X} precedes \placeholder{B} in \placeholder{S}, or
\item there is a \tcode{memory_order_seq_cst} fence \placeholder{Y} such that \placeholder{Y}
is sequenced before \placeholder{B}, and \placeholder{A} precedes \placeholder{Y} in \placeholder{S}, or
\item there are \tcode{memory_order_seq_cst} fences \placeholder{X} and \placeholder{Y} such that \placeholder{A}
is sequenced before \placeholder{X}, \placeholder{Y} is sequenced before \placeholder{B},
and \placeholder{X} precedes \placeholder{Y} in \placeholder{S}.
\end{itemize}


\pnum
\begin{note} \tcode{memory_order_seq_cst} ensures sequential consistency only for a
program that is free of data races and uses exclusively \tcode{memory_order_seq_cst}
operations. Any use of weaker ordering will invalidate this guarantee unless extreme
care is used. In particular, \tcode{memory_order_seq_cst} fences ensure a total order
only for the fences themselves. Fences cannot, in general, be used to restore sequential
consistency for atomic operations with weaker ordering specifications. \end{note}

\pnum
Implementations should ensure that no ``out-of-thin-air'' values are computed that
circularly depend on their own computation.

\begin{note} For example, with \tcode{x} and \tcode{y} initially zero,

\begin{codeblock}
// Thread 1:
r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);
\end{codeblock}

\begin{codeblock}
// Thread 2:
r2 = x.load(memory_order_relaxed);
y.store(r2, memory_order_relaxed);
\end{codeblock}

should not produce \tcode{r1 == r2 == 42}, since the store of 42 to \tcode{y} is only
possible if the store to \tcode{x} stores \tcode{42}, which circularly depends on the
store to \tcode{y} storing \tcode{42}. Note that without this restriction, such an
execution is possible.
\end{note}

\pnum
\begin{note} The recommendation similarly disallows \tcode{r1 == r2 == 42} in the
following example, with \tcode{x} and \tcode{y} again initially zero:

\begin{codeblock}
// Thread 1:
r1 = x.load(memory_order_relaxed);
if (r1 == 42) y.store(42, memory_order_relaxed);
\end{codeblock}

\begin{codeblock}
// Thread 2:
r2 = y.load(memory_order_relaxed);
if (r2 == 42) x.store(42, memory_order_relaxed);
\end{codeblock}

\end{note}

\pnum
Atomic read-modify-write operations shall always read the last value
(in the modification order) written before the write associated with
the read-modify-write operation.

\pnum
Implementations should make atomic stores visible to atomic loads within a reasonable
amount of time.

\indexlibrary{\idxcode{kill_dependency}}%
\begin{itemdecl}
template <class T>
  T kill_dependency(T y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The argument does not carry a dependency to the return
value~(\ref{intro.multithread}).

\pnum
\returns \tcode{y}.
\end{itemdescr}


\rSec1[atomics.lockfree]{Lock-free property}

\indexlibrary{\idxcode{ATOMIC_BOOL_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR16_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_CHAR32_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_WCHAR_T_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_SHORT_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_INT_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_LONG_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_LLONG_LOCK_FREE}}%
\indexlibrary{\idxcode{ATOMIC_POINTER_LOCK_FREE}}%
\indeximpldef{values of various \tcode{ATOMIC_..._LOCK_FREE} macros}
\begin{codeblock}
#define ATOMIC_BOOL_LOCK_FREE @\unspec@
#define ATOMIC_CHAR_LOCK_FREE @\unspec@
#define ATOMIC_CHAR16_T_LOCK_FREE @\unspec@
#define ATOMIC_CHAR32_T_LOCK_FREE @\unspec@
#define ATOMIC_WCHAR_T_LOCK_FREE @\unspec@
#define ATOMIC_SHORT_LOCK_FREE @\unspec@
#define ATOMIC_INT_LOCK_FREE @\unspec@
#define ATOMIC_LONG_LOCK_FREE @\unspec@
#define ATOMIC_LLONG_LOCK_FREE @\unspec@
#define ATOMIC_POINTER_LOCK_FREE @\unspec@
\end{codeblock}

\pnum
The \tcode{ATOMIC_..._LOCK_FREE} macros indicate the lock-free property of the
corresponding atomic types, with the signed and unsigned variants grouped
together. The properties also apply to the corresponding (partial) specializations of the
\tcode{atomic} template. A value of 0 indicates that the types are never
lock-free. A value of 1 indicates that the types are sometimes lock-free. A
value of 2 indicates that the types are always lock-free.

\pnum
The function \tcode{atomic_is_lock_free}~(\ref{atomics.types.operations})
indicates whether the object is lock-free. In any given program execution, the
result of the lock-free query shall be consistent for all pointers of the same
type.

\pnum
Atomic operations that are not lock-free are considered to potentially
block~(\ref{intro.progress}).

\pnum
\begin{note} Operations that are lock-free should also be address-free. That is,
atomic operations on the same memory location via two different addresses will
communicate atomically. The implementation should not depend on any
per-process state. This restriction enables communication  by memory that is
mapped into a process more than once and by memory that is shared between two
processes. \end{note}

\rSec1[atomics.types.generic]{Atomic types}

\indexlibrary{\idxcode{atomic}}%
\indexlibrary{\idxcode{atomic<T*>}}%
\indexlibrary{\idxcode{atomic<\placeholder{integral}>}}%
\begin{codeblock}
namespace std {
  template <class T> struct atomic {
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };

  template <> struct atomic<@\placeholder{integral}@> {
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ load(memory_order = memory_order_seq_cst) const volatile noexcept;
    @\placeholdernc{integral}@ load(memory_order = memory_order_seq_cst) const noexcept;
    operator @\placeholdernc{integral}@() const volatile noexcept;
    operator @\placeholdernc{integral}@() const noexcept;
    @\placeholdernc{integral}@ exchange(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ exchange(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(@\placeholder{integral}@&,@\itcorr[-1]@ @\placeholdernc{integral}@,
                               memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_add(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_add(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_sub(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_sub(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_and(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_and(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_or(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_or(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;
    @\placeholdernc{integral}@ fetch_xor(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) volatile noexcept;
    @\placeholdernc{integral}@ fetch_xor(@\placeholdernc{integral}@, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(@\placeholdernc{integral}@) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    @\placeholdernc{integral}@ operator=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator=(@\placeholdernc{integral}@) noexcept;

    @\placeholdernc{integral}@ operator++(int) volatile noexcept;
    @\placeholdernc{integral}@ operator++(int) noexcept;
    @\placeholdernc{integral}@ operator--(int) volatile noexcept;
    @\placeholdernc{integral}@ operator--(int) noexcept;
    @\placeholdernc{integral}@ operator++() volatile noexcept;
    @\placeholdernc{integral}@ operator++() noexcept;
    @\placeholdernc{integral}@ operator--() volatile noexcept;
    @\placeholdernc{integral}@ operator--() noexcept;
    @\placeholdernc{integral}@ operator+=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator+=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator-=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator-=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator&=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator&=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator|=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator|=(@\placeholdernc{integral}@) noexcept;
    @\placeholdernc{integral}@ operator^=(@\placeholdernc{integral}@) volatile noexcept;
    @\placeholdernc{integral}@ operator^=(@\placeholdernc{integral}@) noexcept;
  };

  template <class T> struct atomic<T*> {
    static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{atomic}}%
\pnum
There is a generic class template \tcode{atomic<T>}. The type of the template argument
\tcode{T} shall be trivially copyable~(\ref{basic.types}). \begin{note} Type arguments that are
not also statically initializable may be difficult to use. \end{note}

\pnum
The semantics of the operations on specializations of \tcode{atomic} are defined
in~\ref{atomics.types.operations}.

\pnum
Specializations and instantiations of the \tcode{atomic} template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor.

\indexlibrary{\idxcode{atomic<\placeholder{integral}>}}%
\pnum
There shall be explicit specializations of the \tcode{atomic}
template for the integral types
\tcode{char},
\tcode{signed char},
\tcode{unsigned char},
\tcode{short},
\tcode{unsigned short},
\tcode{int},
\tcode{unsigned int},
\tcode{long},
\tcode{unsigned long},
\tcode{long long},
\tcode{unsigned long long},
\tcode{char16_t},
\tcode{char32_t},
\tcode{wchar_t},
and any other types needed by the typedefs in the header \tcode{<cstdint>}.
For each integral type \tcode{\placeholder{integral}}, the specialization
\tcode{atomic<\placeholder{integral}>} provides additional atomic operations appropriate to integral types.
There shall be a specialization \tcode{atomic<bool>} which provides the general
atomic operations as specified in \ref{atomics.types.operations.general}.

\pnum
The atomic integral specializations and the specialization \tcode{atomic<bool>}
shall be standard-layout structs. They shall each have a trivial default constructor
and a trivial destructor. They shall each support aggregate initialization
syntax.

\indexlibrary{\idxcode{atomic<T*>}}%
\pnum
There shall be pointer partial specializations of the \tcode{atomic} class template.
These specializations shall be standard-layout structs.
They shall each have a trivial default constructor and a trivial destructor.
They shall each support aggregate initialization syntax.

\indexlibrary{\idxcode{atomic_bool}}%
\pnum
There shall be named types corresponding to the integral specializations of
\tcode{atomic}, as specified in Table~\ref{tab:atomics.integral}, and a named type
\tcode{atomic_bool} corresponding to the specified \tcode{atomic<bool>}. Each named
type is either a typedef to the corresponding specialization or a base class of the
corresponding specialization. If it is a base class, it shall support the same
member functions as the corresponding specialization.

\indexlibrary{\idxcode{atomic_char}}%
\indexlibrary{\idxcode{atomic_schar}}%
\indexlibrary{\idxcode{atomic_uchar}}%
\indexlibrary{\idxcode{atomic_short}}%
\indexlibrary{\idxcode{atomic_ushort}}%
\indexlibrary{\idxcode{atomic_int}}%
\indexlibrary{\idxcode{atomic_uint}}%
\indexlibrary{\idxcode{atomic_long}}%
\indexlibrary{\idxcode{atomic_ulong}}%
\indexlibrary{\idxcode{atomic_llong}}%
\indexlibrary{\idxcode{atomic_ullong}}%
\indexlibrary{\idxcode{atomic_char16_t}}%
\indexlibrary{\idxcode{atomic_char32_t}}%
\indexlibrary{\idxcode{atomic_wchar_t}}%
\begin{floattablebase}
{Named atomic types}{tab:atomics.integral}{ll}{ht}
\hline
\textbf{Named atomic type} & \textbf{Corresponding non-atomic type} \\ \hline
\tcode{atomic_char}     & \tcode{char}                    \\
\tcode{atomic_schar}    & \tcode{signed char}             \\
\tcode{atomic_uchar}    & \tcode{unsigned char}           \\
\tcode{atomic_short}    & \tcode{short}                   \\
\tcode{atomic_ushort}   & \tcode{unsigned short}          \\
\tcode{atomic_int}      & \tcode{int}                     \\
\tcode{atomic_uint}     & \tcode{unsigned int}            \\
\tcode{atomic_long}     & \tcode{long}                    \\
\tcode{atomic_ulong}    & \tcode{unsigned long}           \\
\tcode{atomic_llong}    & \tcode{long long}               \\
\tcode{atomic_ullong}   & \tcode{unsigned long long}      \\
\tcode{atomic_char16_t} & \tcode{char16_t}                \\
\tcode{atomic_char32_t} & \tcode{char32_t}                \\
\tcode{atomic_wchar_t}  & \tcode{wchar_t}                 \\
\hline
\end{floattablebase}

\pnum
There shall be atomic typedefs corresponding to non-atomic typedefs as
specified in Table~\ref{tab:atomics.typedefs}.
\tcode{atomic_int$N$_t}, \tcode{atomic_uint$N$_t},
\tcode{atomic_intptr_t}, and \tcode{atomic_uintptr_t}
shall be defined if and only if
\tcode{int$N$_t}, \tcode{uint$N$_t},
\tcode{intptr_t}, and \tcode{uintptr_t}
are defined, respectively.

\indexlibrary{\idxcode{atomic_int8_t}}%
\indexlibrary{\idxcode{atomic_uint8_t}}%
\indexlibrary{\idxcode{atomic_int16_t}}%
\indexlibrary{\idxcode{atomic_uint16_t}}%
\indexlibrary{\idxcode{atomic_int32_t}}%
\indexlibrary{\idxcode{atomic_uint32_t}}%
\indexlibrary{\idxcode{atomic_int64_t}}%
\indexlibrary{\idxcode{atomic_uint64_t}}%
\indexlibrary{\idxcode{atomic_int_least8_t}}%
\indexlibrary{\idxcode{atomic_uint_least8_t}}%
\indexlibrary{\idxcode{atomic_int_least16_t}}%
\indexlibrary{\idxcode{atomic_uint_least16_t}}%
\indexlibrary{\idxcode{atomic_int_least32_t}}%
\indexlibrary{\idxcode{atomic_uint_least32_t}}%
\indexlibrary{\idxcode{atomic_int_least64_t}}%
\indexlibrary{\idxcode{atomic_uint_least64_t}}%
\indexlibrary{\idxcode{atomic_int_fast8_t}}%
\indexlibrary{\idxcode{atomic_uint_fast8_t}}%
\indexlibrary{\idxcode{atomic_int_fast16_t}}%
\indexlibrary{\idxcode{atomic_uint_fast16_t}}%
\indexlibrary{\idxcode{atomic_int_fast32_t}}%
\indexlibrary{\idxcode{atomic_uint_fast32_t}}%
\indexlibrary{\idxcode{atomic_int_fast64_t}}%
\indexlibrary{\idxcode{atomic_uint_fast64_t}}%
\indexlibrary{\idxcode{atomic_intptr_t}}%
\indexlibrary{\idxcode{atomic_uintptr_t}}%
\indexlibrary{\idxcode{atomic_size_t}}%
\indexlibrary{\idxcode{atomic_ptrdiff_t}}%
\indexlibrary{\idxcode{atomic_intmax_t}}%
\indexlibrary{\idxcode{atomic_uintmax_t}}%
\begin{floattablebase}
{Atomic typedefs}{tab:atomics.typedefs}{ll}{ht}
\hline
\textbf{Atomic typedef} & \textbf{Corresponding non-atomic typedef} \\ \hline
\tcode{atomic_int8_t}         & \tcode{int8_t}          \\
\tcode{atomic_uint8_t}        & \tcode{uint8_t}         \\
\tcode{atomic_int16_t}        & \tcode{int16_t}         \\
\tcode{atomic_uint16_t}       & \tcode{uint16_t}        \\
\tcode{atomic_int32_t}        & \tcode{int32_t}         \\
\tcode{atomic_uint32_t}       & \tcode{uint32_t}        \\
\tcode{atomic_int64_t}        & \tcode{int64_t}         \\
\tcode{atomic_uint64_t}       & \tcode{uint64_t}        \\
\tcode{atomic_int_least8_t}   & \tcode{int_least8_t}    \\
\tcode{atomic_uint_least8_t}  & \tcode{uint_least8_t}   \\
\tcode{atomic_int_least16_t}  & \tcode{int_least16_t}   \\
\tcode{atomic_uint_least16_t} & \tcode{uint_least16_t}  \\
\tcode{atomic_int_least32_t}  & \tcode{int_least32_t}   \\
\tcode{atomic_uint_least32_t} & \tcode{uint_least32_t}  \\
\tcode{atomic_int_least64_t}  & \tcode{int_least64_t}   \\
\tcode{atomic_uint_least64_t} & \tcode{uint_least64_t}  \\
\tcode{atomic_int_fast8_t}    & \tcode{int_fast8_t}     \\
\tcode{atomic_uint_fast8_t}   & \tcode{uint_fast8_t}    \\
\tcode{atomic_int_fast16_t}   & \tcode{int_fast16_t}    \\
\tcode{atomic_uint_fast16_t}  & \tcode{uint_fast16_t}   \\
\tcode{atomic_int_fast32_t}   & \tcode{int_fast32_t}    \\
\tcode{atomic_uint_fast32_t}  & \tcode{uint_fast32_t}   \\
\tcode{atomic_int_fast64_t}   & \tcode{int_fast64_t}    \\
\tcode{atomic_uint_fast64_t}  & \tcode{uint_fast64_t}   \\
\tcode{atomic_intptr_t}       & \tcode{intptr_t}        \\
\tcode{atomic_uintptr_t}      & \tcode{uintptr_t}       \\
\tcode{atomic_size_t}         & \tcode{size_t}          \\
\tcode{atomic_ptrdiff_t}      & \tcode{ptrdiff_t}       \\
\tcode{atomic_intmax_t}       & \tcode{intmax_t}        \\
\tcode{atomic_uintmax_t}      & \tcode{uintmax_t}       \\
\hline
\end{floattablebase}

\pnum
\begin{note} The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. \end{note}

\rSec1[atomics.types.operations]{Operations on atomic types}

\rSec2[atomics.types.operations.general]{General operations on atomic types}

\pnum
The implementation shall provide the functions and function templates identified as ``general operations
on atomic types'' in~\ref{atomics.syn}.

\pnum
In the declarations of these functions and function templates, the name
\tcode{\placeholder{atomic-type}} refers to either \tcode{atomic<T>} or to a named base class for \tcode{T}
from Table~\ref{tab:atomics.integral} or inferred from Table~\ref{tab:atomics.typedefs}.

\rSec2[atomics.types.operations.templ]{Templated operations on atomic types}

\pnum
The implementation shall declare but not define the
function templates identified as ``templated operations on atomic types'' in~\ref{atomics.syn}.

\rSec2[atomics.types.operations.arith]{Arithmetic operations on atomic types}

\pnum
The implementation shall provide the functions and function template specializations identified as ``arithmetic operations
on atomic types'' in~\ref{atomics.syn}.

\indexlibrary{\idxcode{atomic<\placeholder{integral}>}}%
\pnum
In the declarations of these functions and function template specializations,
the name \tcode{\placeholder{integral}} refers to an
integral type and the name \tcode{\placeholder{atomic-integral}} refers to either
\tcode{atomic<\placeholder{integral}>} or to a named base class for \tcode{\placeholder{integral}} from
Table~\ref{tab:atomics.integral} or inferred from Table~\ref{tab:atomics.typedefs}.

\rSec2[atomics.types.operations.pointer]{Operations on atomic pointer types}
\indexlibrary{\idxcode{atomic<T*>}}%

\pnum
The implementation shall provide the function template specializations
identified as ``partial specializations for pointers'' in~\ref{atomics.syn}.

\rSec2[atomics.types.operations.req]{Requirements for operations on atomic types}

\pnum
There are only a few kinds of operations on atomic types, though there are many
instances on those kinds. This section specifies each general kind. The specific
instances are defined in 
\ref{atomics.types.generic}, \ref{atomics.types.operations.general},
\ref{atomics.types.operations.arith}, and \ref{atomics.types.operations.pointer}.

\pnum
In the following operation definitions:

\begin{itemize}
\item an \placeholder{A} refers to one of the atomic types.
\item a \placeholder{C} refers to its corresponding non-atomic type.
\item an \placeholder{M} refers to type of the other argument for arithmetic operations. For
integral atomic types, \placeholder{M} is \placeholder{C}. For atomic address types, \placeholder{M} is
\tcode{ptrdiff_t}.
\item the non-member functions not ending in \tcode{_explicit} have the semantics of their
corresponding \tcode{_explicit} functions with \tcode{memory_order} arguments of
\tcode{memory_order_seq_cst}.
\end{itemize}

\pnum
\begin{note} Many operations are volatile-qualified. The ``volatile as device register''
semantics have not changed in the standard. This qualification means that volatility is
preserved when applying these operations to volatile objects. It does not mean that
operations on non-volatile objects become volatile. Thus, volatile qualified operations
on non-volatile objects may be merged under some conditions. \end{note}

\indexlibrary{\idxcode{atomic}!constructor}%
\indexlibrary{\idxcode{atomic<T*>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{integral}>}!constructor}%
\begin{itemdecl}
@\placeholdernc{A}@::@\placeholdernc{A}@() noexcept = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Leaves the atomic object in an uninitialized state.
\begin{note}
These semantics ensure compatibility with C.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic}!constructor}%
\indexlibrary{\idxcode{atomic<T*>}!constructor}%
\indexlibrary{\idxcode{atomic<\placeholder{integral}>}!constructor}%
\begin{itemdecl}
constexpr @\placeholdernc{A}@::@\placeholdernc{A}@(@\placeholdernc{C}@ desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the object with the value \tcode{desired}.
Initialization is not an atomic operation~(\ref{intro.multithread}).
\begin{note} It is possible to have an access to an atomic object \tcode{A}
race with its construction, for example by communicating the address of the
just-constructed object \tcode{A} to another thread via
\tcode{memory_order_relaxed} operations on a suitable atomic pointer
variable, and then immediately accessing \tcode{A} in the receiving thread.
This results in undefined behavior. \end{note}
\end{itemdescr}

\indexlibrary{\idxcode{ATOMIC_VAR_INIT}}%
\begin{itemdecl}
#define ATOMIC_VAR_INIT(value) @\seebelow@
\end{itemdecl}

\begin{itemdescr}
\pnum
The macro expands to a token sequence suitable for
constant initialization of
an atomic variable of static storage duration of a type that is
initialization-compatible with \tcode{value}.
\begin{note} This operation may need to initialize locks. \end{note}
Concurrent access to the variable being initialized, even via an atomic operation,
constitutes a data race. \begin{example}
\begin{codeblock}
atomic<int> v = ATOMIC_VAR_INIT(5);
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{is_always_lock_free}{atomic}%
\indexlibrarymember{is_always_lock_free}{atomic<T*>}%
\indexlibrarymember{is_always_lock_free}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
static constexpr bool is_always_lock_free = @\impdefx{whether a given \tcode{atomic} type's operations are always lock free}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{static} data member \tcode{is_always_lock_free} is \tcode{true}
if the atomic type's operations are always lock-free, and \tcode{false} otherwise.
\begin{note}
The value of \tcode{is_always_lock_free} is consistent with the value of
the corresponding \tcode{ATOMIC_..._LOCK_FREE} macro, if defined.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_is_lock_free}}%
\indexlibrarymember{is_lock_free}{atomic}%
\indexlibrarymember{is_lock_free}{atomic<T*>}%
\indexlibrarymember{is_lock_free}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
bool atomic_is_lock_free(const volatile @\placeholder{A}@*@\itcorr[-1]@ object) noexcept;
bool atomic_is_lock_free(const @\placeholder{A}@*@\itcorr[-1]@ object) noexcept;
bool @\placeholdernc{A}@::is_lock_free() const volatile noexcept;
bool @\placeholdernc{A}@::is_lock_free() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true} if the object's operations are lock-free, \tcode{false} otherwise.
\begin{note}
The return value of the \tcode{is_lock_free} member function
is consistent with the value of \tcode{is_always_lock_free} for the same type.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_init}}%
\begin{itemdecl}
void atomic_init(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
void atomic_init(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Non-atomically
initializes \tcode{*object} with value \tcode{desired}. This function shall only be applied
to objects that have been default constructed, and then only once.
\begin{note}
These semantics ensure compatibility with C.
\end{note}
\begin{note}
Concurrent access from another thread, even via an atomic operation, constitutes
a data race.
\end{note}

\end{itemdescr}

\indexlibrary{\idxcode{atomic_store}}%
\indexlibrary{\idxcode{atomic_store_explicit}}%
\indexlibrarymember{store}{atomic}%
\indexlibrarymember{store}{atomic<T*>}%
\indexlibrarymember{store}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
void atomic_store(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
void atomic_store(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
void atomic_store_explicit(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired, memory_order order) noexcept;
void atomic_store_explicit(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired, memory_order order) noexcept;
void @\placeholdernc{A}@::store(@\placeholdernc{C}@ desired, memory_order order = memory_order_seq_cst) volatile noexcept;
void @\placeholdernc{A}@::store(@\placeholdernc{C}@ desired, memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order_consume},
\tcode{memory_order_acquire}, nor \tcode{memory_order_acq_rel}.

\pnum
\effects Atomically replaces the value pointed to by \tcode{object} or by \tcode{this}
with the value of \tcode{desired}. Memory is affected according to the value of
\tcode{order}.
\end{itemdescr}

\indexlibrarymember{operator=}{atomic}%
\indexlibrarymember{operator=}{atomic<T*>}%
\indexlibrarymember{operator=}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator=(@\placeholdernc{C}@ desired) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator=(@\placeholdernc{C}@ desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{store(desired)}.

\pnum
\returns \tcode{desired}.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_load}}%
\indexlibrary{\idxcode{atomic_load_explicit}}%
\indexlibrarymember{load}{atomic}%
\indexlibrarymember{load}{atomic<T*>}%
\indexlibrarymember{load}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ atomic_load(const volatile @\placeholder{A}@*@\itcorr[-1]@ object) noexcept;
@\placeholdernc{C}@ atomic_load(const @\placeholder{A}@*@\itcorr[-1]@ object) noexcept;
@\placeholdernc{C}@ atomic_load_explicit(const volatile @\placeholder{A}@*@\itcorr[-1]@ object, memory_order) noexcept;
@\placeholdernc{C}@ atomic_load_explicit(const @\placeholder{A}@*@\itcorr[-1]@ object, memory_order) noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::load(memory_order order = memory_order_seq_cst) const volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::load(memory_order order = memory_order_seq_cst) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order_release} nor \tcode{memory_order_acq_rel}.

\pnum
\effects Memory is affected according to the value of \tcode{order}.

\pnum
\returns Atomically returns the value pointed to by \tcode{object} or by \tcode{this}.
\end{itemdescr}

\indexlibrarymember{operator \placeholder{type}}{atomic}%
\indexlibrarymember{operator T*}{atomic<T*>}%
\indexlibrarymember{operator \placeholder{integral}}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{A}@::operator @\placeholder{C}@() const volatile noexcept;
@\placeholdernc{A}@::operator @\placeholder{C}@() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{load()}.

\pnum
\returns The result of \tcode{load()}.
\end{itemdescr}


\indexlibrary{\idxcode{atomic_exchange}}%
\indexlibrary{\idxcode{atomic_exchange_explicit}}%
\indexlibrarymember{exchange}{atomic}%
\indexlibrarymember{exchange}{atomic<T*>}%
\indexlibrarymember{exchange}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ atomic_exchange(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
@\placeholdernc{C}@ atomic_exchange(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired) noexcept;
@\placeholdernc{C}@ atomic_exchange_explicit(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired, memory_order) noexcept;
@\placeholdernc{C}@ atomic_exchange_explicit(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{C}@ desired, memory_order) noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::exchange(@\placeholdernc{C}@ desired, memory_order order = memory_order_seq_cst) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::exchange(@\placeholdernc{C}@ desired, memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically replaces the value pointed to by \tcode{object} or by \tcode{this}
with \tcode{desired}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations~(\ref{intro.multithread}).

\pnum
\returns Atomically returns the value pointed to by \tcode{object} or by \tcode{this} immediately before the effects.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_compare_exchange_weak}}%
\indexlibrary{\idxcode{atomic_compare_exchange_strong}}%
\indexlibrary{\idxcode{atomic_compare_exchange_weak_explicit}}%
\indexlibrary{\idxcode{atomic_compare_exchange_strong_explicit}}%
\indexlibrarymember{compare_exchange_weak}{atomic}%
\indexlibrarymember{compare_exchange_weak}{atomic<T*>}%
\indexlibrarymember{compare_exchange_weak}{atomic<\placeholder{integral}>}%
\indexlibrarymember{compare_exchange_strong}{atomic}%
\indexlibrarymember{compare_exchange_strong}{atomic<T*>}%
\indexlibrarymember{compare_exchange_strong}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
bool atomic_compare_exchange_weak(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired) noexcept;
bool atomic_compare_exchange_weak(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired) noexcept;
bool atomic_compare_exchange_strong(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired) noexcept;
bool atomic_compare_exchange_strong(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired) noexcept;
bool atomic_compare_exchange_weak_explicit(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_weak_explicit(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholder{C}@*@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool @\placeholdernc{A}@::compare_exchange_weak(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) volatile noexcept;
bool @\placeholdernc{A}@::compare_exchange_weak(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool @\placeholdernc{A}@::compare_exchange_strong(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) volatile noexcept;
bool @\placeholdernc{A}@::compare_exchange_strong(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order success, memory_order failure) noexcept;
bool @\placeholdernc{A}@::compare_exchange_weak(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool @\placeholdernc{A}@::compare_exchange_weak(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order order = memory_order_seq_cst) noexcept;
bool @\placeholdernc{A}@::compare_exchange_strong(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool @\placeholdernc{A}@::compare_exchange_strong(@\placeholder{C}@&@\itcorr[-1]@ expected, @\placeholdernc{C}@ desired,
    memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{failure} argument shall not be \tcode{memory_order_release} nor
\tcode{memory_order_acq_rel}.

\pnum
\effects Retrieves the value in \tcode{expected}. It then atomically
compares the contents of the memory pointed to by \tcode{object} or by \tcode{this}
for equality with that previously retrieved from \tcode{expected},
and if true, replaces the contents of the memory pointed to
by \tcode{object} or by \tcode{this} with that in \tcode{desired}.
If and only if the comparison is true, memory is affected according to the
value of \tcode{success}, and if the comparison is false, memory is affected according
to the value of \tcode{failure}. When only one \tcode{memory_order} argument is
supplied, the value of \tcode{success} is \tcode{order}, and the value of
\tcode{failure} is \tcode{order} except that a value of \tcode{memory_order_acq_rel}
shall be replaced by the value \tcode{memory_order_acquire} and a value of
\tcode{memory_order_release} shall be replaced by the value
\tcode{memory_order_relaxed}.
If and only if the comparison is false then, after the atomic operation,
the contents of the memory in \tcode{expected} are replaced by the value
read from \tcode{object} or by \tcode{this} during the atomic comparison.
If the operation returns \tcode{true}, these
operations are atomic read-modify-write
operations~(\ref{intro.multithread}) on the memory
pointed to by \tcode{this} or \tcode{object}.
Otherwise, these operations are atomic load operations on that memory.

\pnum
\returns The result of the comparison.

\pnum
\begin{note} For example, the effect of
\tcode{atomic_compare_exchange_strong} is
\begin{codeblock}
if (memcmp(object, expected, sizeof(*object)) == 0)
  memcpy(object, &desired, sizeof(*object));
else
  memcpy(expected, object, sizeof(*object));
\end{codeblock}
\end{note}
\begin{example} The expected use of the compare-and-exchange operations is as follows. The
compare-and-exchange operations will update \tcode{expected} when another iteration of
the loop is needed.
\begin{codeblock}
expected = current.load();
do {
  desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));
\end{codeblock}
\end{example}
\begin{example} Because the expected value is updated only on failure,
code releasing the memory containing the \tcode{expected} value on success will work.
E.g. list head insertion will act atomically and would not introduce a
data race in the following code:
\begin{codeblock}
do {
  p->next = head; // make new list node point to the current head
} while (!head.compare_exchange_weak(p->next, p)); // try to insert
\end{codeblock}
\end{example}

\pnum
Implementations should ensure that weak compare-and-exchange operations do not
consistently return \tcode{false} unless either the atomic object has value
different from \tcode{expected} or there are concurrent modifications to the
atomic object.

\pnum
\remarks
A weak compare-and-exchange operation may fail spuriously. That is, even when
the contents of memory referred to by \tcode{expected} and \tcode{object} are
equal, it may return \tcode{false} and store back to \tcode{expected} the same memory
contents that were originally there.
\begin{note} This
spurious failure enables implementation of compare-and-exchange on a broader class of
machines, e.g., load-locked store-conditional machines. A
consequence of spurious failure is that nearly all uses of weak compare-and-exchange
will be in a loop.

When a compare-and-exchange is in a loop, the weak version will yield better performance
on some platforms. When a weak compare-and-exchange would require a loop and a strong one
would not, the strong one is preferable.
\end{note}

\pnum
\begin{note} The \tcode{memcpy} and \tcode{memcmp} semantics of the compare-and-exchange
operations may result in failed comparisons for values that compare equal with
\tcode{operator==} if the underlying type has padding bits, trap bits, or alternate
representations of the same value. Thus, \tcode{compare_exchange_strong} should be used
with extreme care. On the other hand, \tcode{compare_exchange_weak} should converge
rapidly. \end{note}
\end{itemdescr}

\pnum
The following operations perform arithmetic computations. The key, operator, and computation correspondence is:

\begin{floattable}
{Atomic arithmetic computations}{tab:atomic.arithmetic.computations}{lll|lll}
\hline
\tcode{Key}       &
  Op          &
  Computation     &
\tcode{Key}       &
  Op          &
  Computation     \\ \hline
\tcode{add}       &
  \tcode{+}       &
  addition        &
\tcode{sub}       &
  \tcode{-}       &
  subtraction     \\
\tcode{or}        &
  \tcode{|}       &
  bitwise inclusive or  &
\tcode{xor}       &
  \tcode{\caret}        &
  bitwise exclusive or  \\
\tcode{and}       &
  \tcode{\&}      &
  bitwise and     &&&\\\hline
\end{floattable}

\indexlibrary{\idxcode{atomic_fetch_add}}%
\indexlibrary{\idxcode{atomic_fetch_and}}%
\indexlibrary{\idxcode{atomic_fetch_or}}%
\indexlibrary{\idxcode{atomic_fetch_sub}}%
\indexlibrary{\idxcode{atomic_fetch_xor}}%
\indexlibrary{\idxcode{atomic_fetch_add_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_and_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_or_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_sub_explicit}}%
\indexlibrary{\idxcode{atomic_fetch_xor_explicit}}%
\indexlibrarymember{fetch_add}{atomic<T*>}%
\indexlibrarymember{fetch_sub}{atomic<T*>}%
\indexlibrarymember{fetch_add}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_and}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_or}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_sub}{atomic<\placeholder{integral}>}%
\indexlibrarymember{fetch_xor}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ atomic_fetch_@\placeholdernc{key}@(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{M}@ operand) noexcept;
@\placeholdernc{C}@ atomic_fetch_@\placeholdernc{key}@(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{M}@ operand) noexcept;
@\placeholdernc{C}@ atomic_fetch_@\placeholdernc{key}@_explicit(volatile @\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{M}@ operand, memory_order order) noexcept;
@\placeholdernc{C}@ atomic_fetch_@\placeholdernc{key}@_explicit(@\placeholder{A}@*@\itcorr[-1]@ object, @\placeholdernc{M}@ operand, memory_order order) noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::fetch_@\placeholdernc{key}@(@\placeholdernc{M}@ operand, memory_order order = memory_order_seq_cst) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::fetch_@\placeholdernc{key}@(@\placeholdernc{M}@ operand, memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically replaces the value pointed to by \tcode{object} or by
\tcode{this} with the result of the computation applied to the
value pointed to by \tcode{object} or by \tcode{this} and the given \tcode{operand}.
Memory is affected according to the value of \tcode{order}.
These operations are atomic read-modify-write operations~(\ref{intro.multithread}).

\pnum
\returns Atomically, the value pointed to by \tcode{object} or by \tcode{this} immediately before the effects.

\pnum
\indextext{signed integer representation!two's complement}%
\remarks For signed integer types, arithmetic is defined to use two's complement
representation. There are no undefined results. For address types, the result may be an
undefined address, but the operations otherwise have no undefined behavior.
\end{itemdescr}

\indexlibrarymember{operator+=}{atomic<T*>}%
\indexlibrarymember{operator-=}{atomic<T*>}%
\indexlibrarymember{operator+=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator-=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator\&=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator"|=}{atomic<\placeholder{integral}>}%
\indexlibrarymember{operator\^{}=}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator @\placeholder{op}@=(@\placeholdernc{M}@ operand) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator @\placeholder{op}@=(@\placeholdernc{M}@ operand) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{fetch_\placeholder{key}(operand)}.

\pnum
\returns \tcode{fetch_\placeholder{key}(operand) op operand}.
\end{itemdescr}

\indexlibrarymember{operator++}{atomic<T*>}%
\indexlibrarymember{operator++}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator++(int) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{fetch_add(1)}.
\end{itemdescr}

\indexlibrarymember{operator\dcr}{atomic<T*>}%
\indexlibrarymember{operator\dcr}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator--(int) volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{fetch_sub(1)}.
\end{itemdescr}

\indexlibrarymember{operator++}{atomic<T*>}%
\indexlibrarymember{operator++}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator++() volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{fetch_add(1)}.

\pnum
\returns \tcode{fetch_add(1) + 1}.
\end{itemdescr}

\indexlibrarymember{operator\dcr}{atomic<T*>}%
\indexlibrarymember{operator\dcr}{atomic<\placeholder{integral}>}%
\begin{itemdecl}
@\placeholdernc{C}@ @\placeholdernc{A}@::operator--() volatile noexcept;
@\placeholdernc{C}@ @\placeholdernc{A}@::operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{fetch_sub(1)}.

\pnum
\returns \tcode{fetch_sub(1) - 1}.
\end{itemdescr}

\rSec1[atomics.flag]{Flag type and operations}

\begin{codeblock}
namespace std {
  struct atomic_flag {
    bool test_and_set(memory_order = memory_order_seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
    void clear(memory_order = memory_order_seq_cst) volatile noexcept;
    void clear(memory_order = memory_order_seq_cst) noexcept;

    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
  };

  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;

  #define ATOMIC_FLAG_INIT @\seebelow@
}
\end{codeblock}

\pnum
The \tcode{atomic_flag} type provides the classic test-and-set functionality. It has two states, set and clear.

\pnum
Operations on an object of type \tcode{atomic_flag} shall be lock-free. \begin{note} Hence
the operations should also be address-free. No other type requires lock-free operations,
so the \tcode{atomic_flag} type is the minimum hardware-implemented type needed to
conform to this International Standard. The remaining types can be emulated with
\tcode{atomic_flag}, though with less than ideal properties. \end{note}

\pnum
The \tcode{atomic_flag} type shall be a standard-layout struct.
It shall have a trivial default constructor, a deleted copy constructor, a deleted copy assignment operator, and a trivial destructor.

\pnum
The macro \tcode{ATOMIC_FLAG_INIT} shall be defined in such a way that it can be used to initialize an object of type \tcode{atomic_flag} to the
clear state. The macro can be used in the form:
\begin{codeblock}
atomic_flag guard = ATOMIC_FLAG_INIT;
\end{codeblock}
It is unspecified whether the macro can be used in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
Unless initialized with \tcode{ATOMIC_FLAG_INIT}, it is unspecified whether an
\tcode{atomic_flag} object has an initial state of set or clear.

\indexlibrary{\idxcode{atomic_flag_test_and_set}}%
\indexlibrary{\idxcode{atomic_flag_test_and_set_explicit}}%
\indexlibrarymember{test_and_set}{atomic_flag}%
\begin{itemdecl}
bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) volatile noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Atomically sets the value pointed to by \tcode{object} or by \tcode{this} to \tcode{true}. Memory is affected according to the value of
\tcode{order}. These operations are atomic read-modify-write operations~(\ref{intro.multithread}).

\pnum
\returns Atomically, the value of the object immediately before the effects.
\end{itemdescr}

\indexlibrary{\idxcode{atomic_flag_clear}}%
\indexlibrary{\idxcode{atomic_flag_clear_explicit}}%
\indexlibrarymember{clear}{atomic_flag}%
\begin{itemdecl}
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{order} argument shall not be \tcode{memory_order_consume},
\tcode{memory_order_acquire}, nor \tcode{memory_order_acq_rel}.

\pnum
\effects Atomically sets the value pointed to by \tcode{object} or by \tcode{this} to
\tcode{false}. Memory is affected according to the value of \tcode{order}.
\end{itemdescr}

\rSec1[atomics.fences]{Fences}

\pnum
This section introduces synchronization primitives called \term{fences}. Fences can have
acquire semantics, release semantics, or both. A fence with acquire semantics is called
an \term{acquire fence}. A fence with release semantics is called a \term{release
fence}.

\pnum
A release fence \placeholder{A} synchronizes with an acquire fence \placeholder{B} if there exist
atomic operations \placeholder{X} and \placeholder{Y}, both operating on some atomic object
\placeholder{M}, such that \placeholder{A} is sequenced before \placeholder{X}, \placeholder{X} modifies
\placeholder{M}, \placeholder{Y} is sequenced before \placeholder{B}, and \placeholder{Y} reads the value
written by \placeholder{X} or a value written by any side effect in the hypothetical release
sequence \placeholder{X} would head if it were a release operation.

\pnum
A release fence \placeholder{A} synchronizes with an atomic operation \placeholder{B} that
performs an acquire operation on an atomic object \placeholder{M} if there exists an atomic
operation \placeholder{X} such that \placeholder{A} is sequenced before \placeholder{X}, \placeholder{X}
modifies \placeholder{M}, and \placeholder{B} reads the value written by \placeholder{X} or a value
written by any side effect in the hypothetical release sequence \placeholder{X} would head if
it were a release operation.

\pnum
An atomic operation \placeholder{A} that is a release operation on an atomic object
\placeholder{M} synchronizes with an acquire fence \placeholder{B} if there exists some atomic
operation \placeholder{X} on \placeholder{M} such that \placeholder{X} is sequenced before \placeholder{B}
and reads the value written by \placeholder{A} or a value written by any side effect in the
release sequence headed by \placeholder{A}.

\indexlibrary{\idxcode{atomic_thread_fence}}%
\begin{itemdecl}
extern "C" void atomic_thread_fence(memory_order order) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Depending on the value of \tcode{order}, this operation:

\begin{itemize}
\item has no effects, if \tcode{order == memory_order_relaxed};

\item is an acquire fence, if \tcode{order == memory_order_acquire || order ==
memory_order_consume};

\item is a release fence, if \tcode{order == memory_order_release};

\item is both an acquire fence and a release fence, if \tcode{order ==
memory_order_acq_rel};

\item is a sequentially consistent acquire and release fence, if \tcode{order == memory_order_seq_cst}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{atomic_signal_fence}}%
\begin{itemdecl}
extern "C" void atomic_signal_fence(memory_order order) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{atomic_thread_fence(order)}, except that
the resulting ordering constraints are established only between a thread and a
signal handler executed in the same thread.

\pnum
\realnote \tcode{atomic_signal_fence} can be used to specify the order in which actions
performed by the thread become visible to the signal handler.

\pnum
\realnote compiler optimizations and reorderings of loads and stores are inhibited in
the same way as with \tcode{atomic_thread_fence}, but the hardware fence instructions
that \tcode{atomic_thread_fence} would have inserted are not emitted.
\end{itemdescr}
