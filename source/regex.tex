%!TEX root = std.tex
\rSec0[re]{Regular expressions library}
\indextext{regular expression|(}

\rSec1[re.general]{General}


\pnum
This Clause describes components that \Cpp{} programs may use to
perform operations involving regular expression matching and
searching.

\pnum
The following subclauses describe a basic regular expression class template and its
traits that can handle char-like\iref{strings.general} template arguments,
two specializations of this class template that handle sequences of \tcode{char} and \keyword{wchar_t},
a class template that holds the
result of a regular expression match, a series of algorithms that allow a character
sequence to be operated upon by a regular expression,
and two iterator types for
enumerating regular expression matches, as summarized in \tref{re.summary}.

\begin{libsumtab}{Regular expressions library summary}{re.summary}
\ref{re.req}        &   Requirements                &                       \\ \rowsep
\ref{re.const}      &   Constants                   & \tcode{<regex>}       \\
\ref{re.badexp}     &   Exception type              &                       \\
\ref{re.traits}     &   Traits                      &                       \\
\ref{re.regex}      &   Regular expression template &                       \\
\ref{re.submatch}   &   Submatches                  &                       \\
\ref{re.results}    &   Match results               &                       \\
\ref{re.alg}        &   Algorithms                  &                       \\
\ref{re.iter}       &   Iterators                   &                       \\ \rowsep
\ref{re.grammar}    &   Grammar                     &                       \\
\end{libsumtab}

\rSec1[re.req]{Requirements}

\pnum
This subclause defines requirements on classes representing regular
expression traits.
\begin{note}
The class template
\tcode{regex_traits}, defined in \ref{re.traits},
meets these requirements.
\end{note}

\pnum
The class template \tcode{basic_regex}, defined in
\ref{re.regex}, needs a set of related types and
functions to complete the definition of its semantics. These types
and functions are provided as a set of member \grammarterm{typedef-name}{s} and functions
in the template parameter \tcode{traits} used by the \tcode{basic_regex} class
template. This subclause defines the semantics of these
members.

\pnum
To specialize class template \tcode{basic_regex} for a character
container \tcode{CharT} and its related regular
expression traits class \tcode{Traits}, use \tcode{basic_regex<CharT, Traits>}.

\pnum
\indextext{regular expression traits!requirements}%
\indextext{requirements!regular expression traits}%
\indextext{regular expression!requirements}%
\indextext{locale}%
In \tref{re.req} \tcode{X} denotes a traits class
defining types and functions for the character container
type \tcode{charT}; \tcode{u} is an object of
type \tcode{X}; \tcode{v} is an object of type \tcode{const
X}; \tcode{p} is a value of type \tcode{const charT*}; \tcode{I1}
and \tcode{I2} are input iterators\iref{input.iterators};
\tcode{F1} and \tcode{F2} are forward iterators\iref{forward.iterators};
\tcode{c} is a value of type \tcode{const charT};
\tcode{s} is an object of type \tcode{X::string_type};
\tcode{cs} is an object of type \tcode{const X::string_type};
\tcode{b} is a value of  type \tcode{bool};
\tcode{I} is a value of type \tcode{int};
\tcode{cl} is an object of type \tcode{X::char_class_type},
and \tcode{loc} is an object of type \tcode{X::locale_type}.

\begin{libreqtab3}
  {Regular expression traits class requirements}
  {re.req}
\\ \topline
\lhdr{Expression} & \chdr{Return type} & \rhdr{Assertion/note pre-/post-condition } \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression} & \chdr{Return type} & \rhdr{Assertion/note pre-/post-condition } \\ \capsep
\endhead
%%
\tcode{X::char_type}
  & \tcode{charT}
  & The character container type used in the implementation of class
    template \tcode{basic_regex}.
  \\ \rowsep
\tcode{X::string_type}
  & \tcode{basic_string<charT>}
  &
  \\ \rowsep
\tcode{X::locale_type}
  & A copy constructible type
  & A type that represents the locale used by the traits class. \indextext{locale}
 \\ \rowsep
\tcode{X::char_class_type}
 & A bitmask type\iref{bitmask.types}.
 & A bitmask type representing a particular character classification.
 \\ \rowsep
\tcode{X::length(p)}
  & \tcode{size_t}
  & Yields the smallest \tcode{i} such that \tcode{p[i] == 0}. Complexity is
    linear in \tcode{i}.
  \\ \rowsep
\tcode{v.translate(c)}
  & \tcode{X::char_type}
  & Returns a character such that for any character \tcode{d} that is to
    be considered equivalent to \tcode{c} then \tcode{v.translate(c) == v.translate(d)}.
  \\ \rowsep
\tcode{v.translate_nocase(c)}
  & \tcode{X::char_type}
  & For all characters \tcode{C} that are to be considered equivalent
    to \tcode{c} when comparisons are to be performed without regard to
  case, then \tcode{v.translate_nocase(c) == v.translate_nocase(C)}.
  \\ \rowsep
\tcode{v.transform(F1, F2)}
  & \tcode{X::string_type}
  & Returns a sort key for the character sequence designated by the
    iterator range \range{F1}{F2} such that if the character sequence
  \range{G1}{G2} sorts before the character sequence \range{H1}{H2}
  then \tcode{v.transform(G1, G2) < v.transform(H1, H2)}.
  \\ \rowsep
\tcode{v.transform_primary(F1, F2)}
  & \tcode{X::string_type}
  & Returns a sort key for the character sequence designated by the
    iterator range \range{F1}{F2} such that if the character sequence
  \range{G1}{G2} sorts before the character sequence \range{H1}{H2}
  when character case is not considered
  then \tcode{v.transform_primary(G1, G2) < v.transform_primary(H1, H2)}.
   \indextext{regular expression traits!\idxcode{transform_primary}}%
   \indextext{transform_primary@\tcode{transform_primary}!regular expression traits}%
  \\ \rowsep
\tcode{v.lookup_collatename(F1, F2)}
  & \tcode{X::string_type}
  & Returns a sequence of characters that represents the collating element
    consisting of the character sequence designated by the iterator range
  \range{F1}{F2}. Returns an empty string if the character sequence is not
  a valid collating element.
  \\ \rowsep
\tcode{v.lookup_classname(F1, F2, b)}
  & \tcode{X::char_class_type}
  &  Converts the character sequence designated by the iterator range
   \range{F1}{F2} into a value of a bitmask type that can
    subsequently be passed to \tcode{isctype}. Values returned from
    \tcode{lookup_classname} can be bitwise \logop{OR}'ed together; the
    resulting value represents membership in either of the
    corresponding character classes.
  If \tcode{b} is \tcode{true}, the returned bitmask is suitable for
  matching characters without regard to their case.
  Returns \tcode{0} if the character
    sequence is not the name of a character class recognized by
    \tcode{X}.  The value returned shall be independent of the case of
    the characters in the sequence.
  \\ \rowsep
\tcode{v.isctype(c, cl)}
  & \tcode{bool}
  & Returns \tcode{true} if character \tcode{c} is a member of
    one of the character classes designated by \tcode{cl},
    \tcode{false} otherwise.
  \\ \rowsep
\tcode{v.value(c, I)}
  & \tcode{int}
  & Returns the value represented by the digit \textit{c} in base
    \textit{I} if the character \textit{c} is a valid digit in base \textit{I};
  otherwise returns \tcode{-1}.
\begin{tailnote}
The value of \textit{I} will only
  be 8, 10, or 16.
\end{tailnote}
  \\ \rowsep
\tcode{u.imbue(loc)}
  & \tcode{X::locale_type}
  & Imbues \tcode{u} with the locale \tcode{loc} and returns the previous locale
    used by \tcode{u} if any. \indextext{locale}%
  \\ \rowsep
\tcode{v.getloc()}
  & \tcode{X::locale_type}
  & Returns the current locale used by \tcode{v}, if any. \indextext{locale}%
  \\
\end{libreqtab3}

\pnum
\begin{note}
Class template \tcode{regex_traits} meets the requirements for a
regular expression traits class when it is specialized for
\tcode{char} or \keyword{wchar_t}.  This class template is described in
the header \libheader{regex}, and is described in \ref{re.traits}.
\end{note}

\rSec1[re.syn]{Header \tcode{<regex>} synopsis}

\indexheader{regex}%
\indexlibraryglobal{basic_regex}%
\indexlibraryglobal{regex}%
\indexlibraryglobal{wregex}%
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}
#include <initializer_list>     // see \ref{initializer.list.syn}

namespace std {
  // \ref{re.const}, regex constants
  namespace regex_constants {
    using syntax_option_type = @\placeholder{T1}@;
    using match_flag_type = @\placeholder{T2}@;
    using error_type = @\placeholder{T3}@;
  }

  // \ref{re.badexp}, class \tcode{regex_error}
  class regex_error;

  // \ref{re.traits}, class template \tcode{regex_traits}
  template<class charT> struct regex_traits;

  // \ref{re.regex}, class template \tcode{basic_regex}
  template<class charT, class traits = regex_traits<charT>> class basic_regex;

  using regex  = basic_regex<char>;
  using wregex = basic_regex<wchar_t>;

  // \ref{re.regex.swap}, \tcode{basic_regex} swap
  template<class charT, class traits>
    void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2);

  // \ref{re.submatch}, class template \tcode{sub_match}
  template<class BidirectionalIterator>
    class sub_match;

  using csub_match  = sub_match<const char*>;
  using wcsub_match = sub_match<const wchar_t*>;
  using ssub_match  = sub_match<string::const_iterator>;
  using wssub_match = sub_match<wstring::const_iterator>;

  // \ref{re.submatch.op}, \tcode{sub_match} non-member operators
  template<class BiIter>
    bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
  template<class BiIter>
    auto operator<=>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

  template<class BiIter, class ST, class SA>
    bool operator==(
      const sub_match<BiIter>& lhs,
      const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template<class BiIter, class ST, class SA>
    auto operator<=>(
      const sub_match<BiIter>& lhs,
      const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

  template<class BiIter>
    bool operator==(const sub_match<BiIter>& lhs,
                    const typename iterator_traits<BiIter>::value_type* rhs);
  template<class BiIter>
    auto operator<=>(const sub_match<BiIter>& lhs,
                     const typename iterator_traits<BiIter>::value_type* rhs);

  template<class BiIter>
    bool operator==(const sub_match<BiIter>& lhs,
                    const typename iterator_traits<BiIter>::value_type& rhs);
  template<class BiIter>
    auto operator<=>(const sub_match<BiIter>& lhs,
                     const typename iterator_traits<BiIter>::value_type& rhs);

  template<class charT, class ST, class BiIter>
    basic_ostream<charT, ST>&
      operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);

  // \ref{re.results}, class template \tcode{match_results}
  template<class BidirectionalIterator,
           class Allocator = allocator<sub_match<BidirectionalIterator>>>
    class match_results;

  using cmatch  = match_results<const char*>;
  using wcmatch = match_results<const wchar_t*>;
  using smatch  = match_results<string::const_iterator>;
  using wsmatch = match_results<wstring::const_iterator>;

  // \tcode{match_results} comparisons
  template<class BidirectionalIterator, class Allocator>
    bool operator==(const match_results<BidirectionalIterator, Allocator>& m1,
                    const match_results<BidirectionalIterator, Allocator>& m2);

  // \ref{re.results.swap}, \tcode{match_results} swap
  template<class BidirectionalIterator, class Allocator>
    void swap(match_results<BidirectionalIterator, Allocator>& m1,
              match_results<BidirectionalIterator, Allocator>& m2);

  // \ref{re.alg.match}, function template \tcode{regex_match}
  template<class BidirectionalIterator, class Allocator, class charT, class traits>
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     match_results<BidirectionalIterator, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class BidirectionalIterator, class charT, class traits>
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class charT, class Allocator, class traits>
    bool regex_match(const charT* str, match_results<const charT*, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class Allocator, class charT, class traits>
    bool regex_match(const basic_string<charT, ST, SA>& s,
                     match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                   Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class Allocator, class charT, class traits>
    bool regex_match(const basic_string<charT, ST, SA>&&,
                     match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                   Allocator>&,
                     const basic_regex<charT, traits>&,
                     regex_constants::match_flag_type = regex_constants::match_default) = delete;
  template<class charT, class traits>
    bool regex_match(const charT* str,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class charT, class traits>
    bool regex_match(const basic_string<charT, ST, SA>& s,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags = regex_constants::match_default);

  // \ref{re.alg.search}, function template \tcode{regex_search}
  template<class BidirectionalIterator, class Allocator, class charT, class traits>
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      match_results<BidirectionalIterator, Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class BidirectionalIterator, class charT, class traits>
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class charT, class Allocator, class traits>
    bool regex_search(const charT* str,
                      match_results<const charT*, Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class charT, class traits>
    bool regex_search(const charT* str,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class charT, class traits>
    bool regex_search(const basic_string<charT, ST, SA>& s,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class Allocator, class charT, class traits>
    bool regex_search(const basic_string<charT, ST, SA>& s,
                      match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                    Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class ST, class SA, class Allocator, class charT, class traits>
    bool regex_search(const basic_string<charT, ST, SA>&&,
                      match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                    Allocator>&,
                      const basic_regex<charT, traits>&,
                      regex_constants::match_flag_type
                        = regex_constants::match_default) = delete;

  // \ref{re.alg.replace}, function template \tcode{regex_replace}
  template<class OutputIterator, class BidirectionalIterator,
            class traits, class charT, class ST, class SA>
    OutputIterator
      regex_replace(OutputIterator out,
                    BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex<charT, traits>& e,
                    const basic_string<charT, ST, SA>& fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class OutputIterator, class BidirectionalIterator, class traits, class charT>
    OutputIterator
      regex_replace(OutputIterator out,
                    BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex<charT, traits>& e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class traits, class charT, class ST, class SA, class FST, class FSA>
    basic_string<charT, ST, SA>
      regex_replace(const basic_string<charT, ST, SA>& s,
                    const basic_regex<charT, traits>& e,
                    const basic_string<charT, FST, FSA>& fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class traits, class charT, class ST, class SA>
    basic_string<charT, ST, SA>
      regex_replace(const basic_string<charT, ST, SA>& s,
                    const basic_regex<charT, traits>& e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class traits, class charT, class ST, class SA>
    basic_string<charT>
      regex_replace(const charT* s,
                    const basic_regex<charT, traits>& e,
                    const basic_string<charT, ST, SA>& fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
  template<class traits, class charT>
    basic_string<charT>
      regex_replace(const charT* s,
                    const basic_regex<charT, traits>& e,
                    const charT* fmt,
                    regex_constants::match_flag_type flags = regex_constants::match_default);

  // \ref{re.regiter}, class template \tcode{regex_iterator}
  template<class BidirectionalIterator,
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT>>
    class regex_iterator;

  using cregex_iterator  = regex_iterator<const char*>;
  using wcregex_iterator = regex_iterator<const wchar_t*>;
  using sregex_iterator  = regex_iterator<string::const_iterator>;
  using wsregex_iterator = regex_iterator<wstring::const_iterator>;

  // \ref{re.tokiter}, class template \tcode{regex_token_iterator}
  template<class BidirectionalIterator,
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT>>
    class regex_token_iterator;

  using cregex_token_iterator  = regex_token_iterator<const char*>;
  using wcregex_token_iterator = regex_token_iterator<const wchar_t*>;
  using sregex_token_iterator  = regex_token_iterator<string::const_iterator>;
  using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;

  namespace pmr {
    template<class BidirectionalIterator>
      using match_results =
        std::match_results<BidirectionalIterator,
                           polymorphic_allocator<sub_match<BidirectionalIterator>>>;

    using cmatch  = match_results<const char*>;
    using wcmatch = match_results<const wchar_t*>;
    using smatch  = match_results<string::const_iterator>;
    using wsmatch = match_results<wstring::const_iterator>;
  }
}
\end{codeblock}

\rSec1[re.const]{Namespace \tcode{std::regex_constants}}

\rSec2[re.const.general]{General}

\pnum
\indexlibraryglobal{regex_constants}%
The namespace \tcode{std::regex_constants} holds
symbolic constants used by the regular expression library.  This
namespace provides three types, \tcode{syntax_option_type},
\tcode{match_flag_type}, and \tcode{error_type}, along with several
constants of these types.

\rSec2[re.synopt]{Bitmask type \tcode{syntax_option_type}}
\indexlibraryglobal{syntax_option_type}%
\indexlibrarymember{regex_constants}{syntax_option_type}%
\begin{codeblock}
namespace std::regex_constants {
  using syntax_option_type = @\textit{T1}@;
  inline constexpr syntax_option_type icase = @\unspec@;
  inline constexpr syntax_option_type nosubs = @\unspec@;
  inline constexpr syntax_option_type optimize = @\unspec@;
  inline constexpr syntax_option_type collate = @\unspec@;
  inline constexpr syntax_option_type ECMAScript = @\unspec@;
  inline constexpr syntax_option_type basic = @\unspec@;
  inline constexpr syntax_option_type extended = @\unspec@;
  inline constexpr syntax_option_type awk = @\unspec@;
  inline constexpr syntax_option_type grep = @\unspec@;
  inline constexpr syntax_option_type egrep = @\unspec@;
  inline constexpr syntax_option_type multiline = @\unspec@;
}
\end{codeblock}

\pnum
\indexlibraryglobal{syntax_option_type}%
\indexlibrarymember{syntax_option_type}{icase}%
\indexlibrarymember{syntax_option_type}{nosubs}%
\indexlibrarymember{syntax_option_type}{optimize}%
\indexlibrarymember{syntax_option_type}{collate}%
\indexlibrarymember{syntax_option_type}{ECMAScript}%
\indexlibrarymember{syntax_option_type}{basic}%
\indexlibrarymember{syntax_option_type}{extended}%
\indexlibrarymember{syntax_option_type}{awk}%
\indexlibrarymember{syntax_option_type}{grep}%
\indexlibrarymember{syntax_option_type}{egrep}%
The type \tcode{syntax_option_type} is an \impldef{type of \tcode{syntax_option_type}} bitmask
type\iref{bitmask.types}. Setting its elements has the effects listed in
\tref{re.synopt}.  A valid value of type
\tcode{syntax_option_type} shall have at most one of the grammar elements
\tcode{ECMAScript}, \tcode{basic}, \tcode{extended}, \tcode{awk}, \tcode{grep}, \tcode{egrep}, set.
If no grammar element is set, the default grammar is \tcode{ECMAScript}.

\begin{libefftab}
  {\tcode{syntax_option_type} effects}
  {re.synopt}
%
\tcode{icase} &
Specifies that matching of regular expressions against a character
container sequence shall be performed without regard to case.
\indexlibrarymember{syntax_option_type}{icase}%
\\ \rowsep
%
\tcode{nosubs} &
Specifies that no sub-expressions shall be considered to be marked, so that
when a regular expression is matched against a
character container sequence, no sub-expression matches shall be
stored in the supplied \tcode{match_results} object.
\indexlibrarymember{syntax_option_type}{nosubs}%
\\ \rowsep
%
\tcode{optimize} &
Specifies that the regular expression engine should pay more attention
to the speed with which regular expressions are matched, and less to
the speed with which regular expression objects are
constructed. Otherwise it has no detectable effect on the program
output.
\indexlibrarymember{syntax_option_type}{optimize}%
\\ \rowsep
%
\tcode{collate} &
Specifies that character ranges of the form \tcode{"[a-b]"} shall be locale
sensitive.%
\indexlibrarymember{syntax_option_type}{collate}%
\indextext{locale}%
\\ \rowsep
%
\tcode{ECMAScript} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by ECMAScript in ECMA-262, as modified in~\ref{re.grammar}.
\newline \xref ECMA-262 15.10
\indextext{ECMAScript}%
\indexlibrarymember{syntax_option_type}{ECMAScript}%
\\ \rowsep
%
\tcode{basic} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by basic regular expressions in POSIX.
\newline \xref POSIX, Base Definitions and Headers, Section 9.3
\indextext{POSIX!regular expressions}%
\indexlibrarymember{syntax_option_type}{basic}%
\\ \rowsep
%
\tcode{extended} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by extended regular expressions in POSIX.
\newline \xref POSIX, Base Definitions and Headers, Section 9.4
\indextext{POSIX!extended regular expressions}%
\indexlibrarymember{syntax_option_type}{extended}%
\\ \rowsep
%
\tcode{awk} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility awk in POSIX.
\indexlibrarymember{syntax_option_type}{awk}%
\\ \rowsep
%
\tcode{grep} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility grep in POSIX.
\indexlibrarymember{syntax_option_type}{grep}%
\\ \rowsep
%
\tcode{egrep} &
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility grep when given the -E
option in POSIX.
\indexlibrarymember{syntax_option_type}{egrep}%
\\ \rowsep
%
\tcode{multiline} &
Specifies that \tcode{\caret} shall match the beginning of a line and
\tcode{\$} shall match the end of a line,
if the \tcode{ECMAScript} engine is selected.
\indexlibrarymember{syntax_option_type}{multiline}%
\\
%
\end{libefftab}

\rSec2[re.matchflag]{Bitmask type \tcode{match_flag_type}}

\indexlibraryglobal{match_flag_type}%
\indexlibrarymember{regex_constants}{match_flag_type}%
\indexlibraryglobal{match_default}%
\indexlibraryglobal{match_not_bol}%
\indexlibraryglobal{match_not_eol}%
\indexlibraryglobal{match_not_bow}%
\indexlibraryglobal{match_not_eow}%
\indexlibraryglobal{match_any}%
\indexlibraryglobal{match_not_null}%
\indexlibraryglobal{match_continuous}%
\indexlibraryglobal{match_prev_avail}%
\indexlibraryglobal{format_default}%
\indexlibraryglobal{format_sed}%
\indexlibraryglobal{format_no_copy}%
\indexlibraryglobal{format_first_only}%
\begin{codeblock}
namespace std::regex_constants {
  using match_flag_type = @\textit{T2}@;
  inline constexpr match_flag_type match_default = {};
  inline constexpr match_flag_type match_not_bol = @\unspec@;
  inline constexpr match_flag_type match_not_eol = @\unspec@;
  inline constexpr match_flag_type match_not_bow = @\unspec@;
  inline constexpr match_flag_type match_not_eow = @\unspec@;
  inline constexpr match_flag_type match_any = @\unspec@;
  inline constexpr match_flag_type match_not_null = @\unspec@;
  inline constexpr match_flag_type match_continuous = @\unspec@;
  inline constexpr match_flag_type match_prev_avail = @\unspec@;
  inline constexpr match_flag_type format_default = {};
  inline constexpr match_flag_type format_sed = @\unspec@;
  inline constexpr match_flag_type format_no_copy = @\unspec@;
  inline constexpr match_flag_type format_first_only = @\unspec@;
}
\end{codeblock}

\pnum
\indexlibraryglobal{match_flag_type}%
The type \tcode{match_flag_type} is an
\impldef{type of \tcode{regex_constants::match_flag_type}} bitmask type\iref{bitmask.types}.
The constants of that type, except for \tcode{match_default} and
\tcode{format_default}, are bitmask elements. The \tcode{match_default} and
\tcode{format_default} constants are empty bitmasks.
Matching a regular expression against a sequence of characters
\range{first}{last} proceeds according to the rules of the grammar specified for the regular
expression object, modified according to the effects listed in \tref{re.matchflag} for
any bitmask elements set.

\begin{longlibefftab}
  {\tcode{regex_constants::match_flag_type} effects when obtaining a match against a
     character container sequence \range{first}{last}.}
  {re.matchflag}
%
\indexlibraryglobal{match_not_bol}%
\tcode{match_not_bol} &
The first character in the sequence \range{first}{last} shall be treated
as though it is not at the beginning of a line, so the character
\verb|^| in the regular expression shall not match \range{first}{first}.
\\ \rowsep
%
\indexlibraryglobal{match_not_eol}%
\tcode{match_not_eol} &
The last character in the sequence \range{first}{last} shall be treated
as though it is not at the end of a line, so the character
\verb|"$"| in the regular expression shall not match \range{last}{last}.
\\ \rowsep
%
\indexlibraryglobal{match_not_bow}%
\tcode{match_not_bow} &
The expression \verb|"\\b"| shall not match the
sub-sequence \range{first}{first}.
\\ \rowsep
%
\indexlibraryglobal{match_not_eow}%
\tcode{match_not_eow} &
The expression \verb|"\\b"| shall not match the
sub-sequence \range{last}{last}.
\\ \rowsep
%
\indexlibraryglobal{match_any}%
\tcode{match_any} &
If more than one match is possible then any match is an
acceptable result.
\\ \rowsep
%
\indexlibraryglobal{match_not_null}%
\tcode{match_not_null} &
The expression shall not match an empty
sequence.
\\ \rowsep
%
\indexlibraryglobal{match_continuous}%
\tcode{match_continuous} &
The expression shall only match a sub-sequence that begins at
\tcode{first}.
\\ \rowsep
%
\indexlibraryglobal{match_prev_avail}%
\tcode{match_prev_avail} &
\verb!--first! is a valid iterator position. When this flag is
set the flags \tcode{match_not_bol} and \tcode{match_not_bow} shall be ignored by the
regular expression algorithms\iref{re.alg} and iterators\iref{re.iter}.
\\ \rowsep
%
\indexlibraryglobal{format_default}%
\tcode{format_default} &
When a regular expression match is to be replaced by a
new string, the new string shall be constructed using the rules used by
the ECMAScript replace function in ECMA-262,
part 15.5.4.11 String.prototype.replace. In
addition, during search and replace operations all non-overlapping
occurrences of the regular expression shall be located and replaced, and
sections of the input that did not match the expression shall be copied
unchanged to the output string.
\\ \rowsep
%
\indexlibraryglobal{format_sed}%
\tcode{format_sed} &
When a regular expression match is to be replaced by a
new string, the new string shall be constructed using the rules used by
the sed utility in POSIX.
\\ \rowsep
%
\indexlibraryglobal{format_no_copy}%
\tcode{format_no_copy} &
During a search and replace operation, sections of
the character container sequence being searched that do not match the
regular expression shall not be copied to the output string. \\ \rowsep
%
\indexlibraryglobal{format_first_only}%
\tcode{format_first_only} &
When specified during a search and replace operation, only the
first occurrence of the regular expression shall be replaced.
\\
\end{longlibefftab}

\rSec2[re.err]{Implementation-defined \tcode{error_type}}
\indexlibraryglobal{error_type}%
\indexlibrarymember{regex_constants}{error_type}%
\begin{codeblock}
namespace std::regex_constants {
  using error_type = @\textit{T3}@;
  inline constexpr error_type error_collate = @\unspec@;
  inline constexpr error_type error_ctype = @\unspec@;
  inline constexpr error_type error_escape = @\unspec@;
  inline constexpr error_type error_backref = @\unspec@;
  inline constexpr error_type error_brack = @\unspec@;
  inline constexpr error_type error_paren = @\unspec@;
  inline constexpr error_type error_brace = @\unspec@;
  inline constexpr error_type error_badbrace = @\unspec@;
  inline constexpr error_type error_range = @\unspec@;
  inline constexpr error_type error_space = @\unspec@;
  inline constexpr error_type error_badrepeat = @\unspec@;
  inline constexpr error_type error_complexity = @\unspec@;
  inline constexpr error_type error_stack = @\unspec@;
}
\end{codeblock}

\pnum
\indexlibraryglobal{error_type}%
\indexlibrarymember{regex_constants}{error_type}%
The type \tcode{error_type} is an \impldef{type of
\tcode{regex_constants::error_type}} enumerated type\iref{enumerated.types}.
Values of type \tcode{error_type} represent the error
conditions described in \tref{re.err}:

\begin{longliberrtab}
  {\tcode{error_type} values in the C locale}
  {re.err}
\tcode{error_collate}
&
The expression contains an invalid collating element name.  \\ \rowsep
%
\tcode{error_ctype}
&
The expression contains an invalid character class name.  \\ \rowsep
%
\tcode{error_escape}
&
The expression contains an invalid escaped character, or a trailing
escape.  \\ \rowsep
%
\tcode{error_backref}
&
The expression contains an invalid back reference.  \\ \rowsep
%
\tcode{error_brack}
&
The expression contains mismatched \verb|[| and \verb|]|.  \\ \rowsep
%
\tcode{error_paren}
&
The expression contains mismatched \verb|(| and \verb|)|.  \\ \rowsep
%
\tcode{error_brace}
&
The expression contains mismatched \verb|{| and \verb|}| \\ \rowsep
%
\tcode{error_badbrace}
&
The expression contains an invalid range in a \verb|{}| expression.  \\
\rowsep
%
\tcode{error_range}
&
The expression contains an invalid character range, such as
\verb|[b-a]| in most encodings.  \\ \rowsep
%
\tcode{error_space}
&
There is insufficient memory to convert the expression into a finite
state machine.  \\ \rowsep
%
\tcode{error_badrepeat}
&
One of \verb|*?+{| is not preceded by a valid regular expression.  \\ \rowsep
%
\tcode{error_complexity}
&
The complexity of an attempted match against a regular expression
exceeds a pre-set level.  \\ \rowsep
%
\tcode{error_stack}
&
There is insufficient memory to determine whether the regular
expression matches the specified character sequence.  \\
%
\end{longliberrtab}

\rSec1[re.badexp]{Class \tcode{regex_error}}
\indexlibraryglobal{regex_error}%
\begin{codeblock}
class regex_error : public runtime_error {
public:
  explicit regex_error(regex_constants::error_type ecode);
  regex_constants::error_type code() const;
};
\end{codeblock}

\pnum
The class \tcode{regex_error} defines the type of objects thrown as
exceptions to report errors from the regular expression library.

\indexlibraryctor{regex_error}%
\begin{itemdecl}
regex_error(regex_constants::error_type ecode);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{ecode == code()}.
\end{itemdescr}

\indexlibraryglobal{error_type}%
\indexlibrarymember{regex_constants}{error_type}%
\begin{itemdecl}
regex_constants::error_type code() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The error code that was passed to the constructor.
\end{itemdescr}

\rSec1[re.traits]{Class template \tcode{regex_traits}}
\indexlibraryglobal{regex_traits}%
\begin{codeblock}
namespace std {
  template<class charT>
    struct regex_traits {
      using char_type       = charT;
      using string_type     = basic_string<char_type>;
      using locale_type     = locale;
      using char_class_type = @\placeholdernc{bitmask_type}@;

      regex_traits();
      static size_t length(const char_type* p);
      charT translate(charT c) const;
      charT translate_nocase(charT c) const;
      template<class ForwardIterator>
        string_type transform(ForwardIterator first, ForwardIterator last) const;
      template<class ForwardIterator>
        string_type transform_primary(
          ForwardIterator first, ForwardIterator last) const;
      template<class ForwardIterator>
        string_type lookup_collatename(
          ForwardIterator first, ForwardIterator last) const;
      template<class ForwardIterator>
        char_class_type lookup_classname(
          ForwardIterator first, ForwardIterator last, bool icase = false) const;
      bool isctype(charT c, char_class_type f) const;
      int value(charT ch, int radix) const;
      locale_type imbue(locale_type l);
      locale_type getloc() const;
    };
}
\end{codeblock}

\pnum
\indextext{regular expression traits!requirements}%
\indextext{requirements!regular expression traits}%
The specializations \tcode{regex_traits<char>} and
\tcode{regex_traits<wchar_t>} meet the
requirements for a regular expression traits class\iref{re.req}.

\indexlibrarymember{regex_traits}{char_class_type}%
\begin{itemdecl}
using char_class_type = @\textit{bitmask_type}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type \tcode{char_class_type} is used to represent a character
classification and is capable of holding an implementation specific
set returned by \tcode{lookup_classname}.
\end{itemdescr}

\indexlibrarymember{length}{regex_traits}%
\begin{itemdecl}
static size_t length(const char_type* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{char_traits<charT>::length(p)}.
\end{itemdescr}

\indexlibrarymember{regex_traits}{translate}%
\begin{itemdecl}
charT translate(charT c) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{c}.
\end{itemdescr}

\indexlibrarymember{regex_traits}{translate_nocase}%
\begin{itemdecl}
charT translate_nocase(charT c) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{use_facet<ctype<charT>>(getloc()).tolower(c)}.
\end{itemdescr}

\indexlibrarymember{regex_traits}{transform}%
\begin{itemdecl}
template<class ForwardIterator>
  string_type transform(ForwardIterator first, ForwardIterator last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
string_type str(first, last);
return use_facet<collate<charT>>(
  getloc()).transform(str.data(), str.data() + str.length());
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{regex_traits}{transform_primary}%
\begin{itemdecl}
template<class ForwardIterator>
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If
\begin{codeblock}
typeid(use_facet<collate<charT>>) == typeid(collate_byname<charT>)
\end{codeblock}
and the form of the sort key returned
by \tcode{collate_byname<charT>::transform(first, last)} is known and
can be converted into a primary sort key then returns that key,
otherwise returns an empty string.
\end{itemdescr}

\indexlibrarymember{regex_traits}{lookup_collatename}%
\begin{itemdecl}
template<class ForwardIterator>
  string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A sequence of one or more characters that
represents the collating element consisting of the character
sequence designated by the iterator range \range{first}{last}.
Returns an empty string if the character sequence is not a
valid collating element.
\end{itemdescr}

\indexlibrarymember{regex_traits}{lookup_classname}%
\begin{itemdecl}
template<class ForwardIterator>
  char_class_type lookup_classname(
    ForwardIterator first, ForwardIterator last, bool icase = false) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An unspecified value that represents
the character classification named by the character sequence
designated by the iterator range \range{first}{last}.
If the parameter \tcode{icase} is \tcode{true} then the returned mask identifies the
character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being
matched.
\begin{footnote}
For example, if the parameter \tcode{icase} is \tcode{true} then
\tcode{[[:lower:]]} is the same as \tcode{[[:alpha:]]}.
\end{footnote}
The value
returned shall be independent of the case of the characters in
the character sequence. If the name
is not recognized then returns \tcode{char_class_type()}.

\pnum
\remarks
For \tcode{regex_traits<char>}, at least the narrow character names
in \tref{re.traits.classnames} shall be recognized.
For \tcode{regex_traits<wchar_t>}, at least the wide character names
in \tref{re.traits.classnames} shall be recognized.
\end{itemdescr}

\indexlibrarymember{regex_traits}{isctype}%
\begin{itemdecl}
bool isctype(charT c, char_class_type f) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines if the character \tcode{c} is a member of the character
classification represented by \tcode{f}.

\pnum
\returns
Given the following function declaration:
\begin{codeblock}
// for exposition only
template<class C>
  ctype_base::mask convert(typename regex_traits<C>::char_class_type f);
\end{codeblock}
that returns a value in which each \tcode{ctype_base::mask} value corresponding to
a value in \tcode{f} named in \tref{re.traits.classnames} is set, then the
result is determined as if by:
\begin{codeblock}
ctype_base::mask m = convert<charT>(f);
const ctype<charT>& ct = use_facet<ctype<charT>>(getloc());
if (ct.is(m, c)) {
  return true;
} else if (c == ct.widen('_')) {
  charT w[1] = { ct.widen('w') };
  char_class_type x = lookup_classname(w, w+1);
  return (f&x) == x;
} else {
  return false;
}
\end{codeblock}
\begin{example}
\begin{codeblock}
regex_traits<char> t;
string d("d");
string u("upper");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert<char>(f);  // \tcode{m == ctype_base::digit|ctype_base::upper}
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
regex_traits<char> t;
string w("w");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f);  // returns \tcode{true}
t.isctype('_', f);  // returns \tcode{true}
t.isctype(' ', f);  // returns \tcode{false}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibrarymember{value}{regex_traits}%
\begin{itemdecl}
int value(charT ch, int radix) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
The value of \tcode{radix} is 8, 10, or 16.

\pnum
\returns
The value represented by the digit \tcode{ch} in base
\tcode{radix} if the character \tcode{ch} is a valid digit in base
\tcode{radix}; otherwise returns \tcode{-1}.
\end{itemdescr}

\indexlibraryglobal{locale}%
\indexlibraryglobal{imbue}%
\begin{itemdecl}
locale_type imbue(locale_type loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Imbues \keyword{this} with a copy of the
locale \tcode{loc}.
\begin{note}
Calling \tcode{imbue} with a
different locale than the one currently in use invalidates all cached
data held by \tcode{*this}.
\end{note}

\pnum
\ensures
\tcode{getloc() == loc}.

\pnum
\returns
If no locale has been previously imbued then a copy of the
global locale in effect at the time of construction of \tcode{*this},
otherwise a copy of the last argument passed to \tcode{imbue}.
\end{itemdescr}

\indexlibraryglobal{locale}%
\indexlibraryglobal{getloc}%
\begin{itemdecl}
locale_type getloc() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If no locale has been imbued then a copy of the global locale
in effect at the time of construction of \tcode{*this}, otherwise a copy of
the last argument passed to \tcode{imbue}.
\end{itemdescr}

\begin{floattable}{Character class names and corresponding \tcode{ctype} masks}{re.traits.classnames}{lll}
\topline
\lhdr{Narrow character name} & \chdr{Wide character name} & \rhdr{Corresponding \tcode{ctype_base::mask} value} \\\capsep
\tcode{"alnum"}  & \tcode{L"alnum"}  & \tcode{ctype_base::alnum}  \\ \rowsep
\tcode{"alpha"}  & \tcode{L"alpha"}  & \tcode{ctype_base::alpha}  \\ \rowsep
\tcode{"blank"}  & \tcode{L"blank"}  & \tcode{ctype_base::blank}  \\ \rowsep
\tcode{"cntrl"}  & \tcode{L"cntrl"}  & \tcode{ctype_base::cntrl}  \\ \rowsep
\tcode{"digit"}  & \tcode{L"digit"}  & \tcode{ctype_base::digit}  \\ \rowsep
\tcode{"d"}      & \tcode{L"d"}      & \tcode{ctype_base::digit}  \\ \rowsep
\tcode{"graph"}  & \tcode{L"graph"}  & \tcode{ctype_base::graph}  \\ \rowsep
\tcode{"lower"}  & \tcode{L"lower"}  & \tcode{ctype_base::lower}  \\ \rowsep
\tcode{"print"}  & \tcode{L"print"}  & \tcode{ctype_base::print}  \\ \rowsep
\tcode{"punct"}  & \tcode{L"punct"}  & \tcode{ctype_base::punct}  \\ \rowsep
\tcode{"space"}  & \tcode{L"space"}  & \tcode{ctype_base::space}  \\ \rowsep
\tcode{"s"}      & \tcode{L"s"}      & \tcode{ctype_base::space}  \\ \rowsep
\tcode{"upper"}  & \tcode{L"upper"}  & \tcode{ctype_base::upper}  \\ \rowsep
\tcode{"w"}      & \tcode{L"w"}      & \tcode{ctype_base::alnum}  \\ \rowsep
\tcode{"xdigit"} & \tcode{L"xdigit"} & \tcode{ctype_base::xdigit} \\
\end{floattable}

\rSec1[re.regex]{Class template \tcode{basic_regex}}

\rSec2[re.regex.general]{General}
\indexlibraryglobal{basic_regex}%

\pnum
For a char-like type \tcode{charT}, specializations of class
template \tcode{basic_regex} represent regular expressions constructed
from character sequences of \tcode{charT} characters.  In the rest
of~\ref{re.regex}, \tcode{charT} denotes a given char-like
type. Storage for a regular expression is allocated and freed as
necessary by the member functions of class \tcode{basic_regex}.

\pnum
Objects of type specialization of \tcode{basic_regex} are responsible for
converting the sequence of \tcode{charT} objects to an internal
representation. It is not specified what form this representation
takes, nor how it is accessed by algorithms that operate on regular
expressions.
\begin{note}
Implementations will typically declare
some function templates as friends of \tcode{basic_regex} to achieve
this.
\end{note}

\pnum
\indexlibraryglobal{regex_error}%
The functions described in \ref{re.regex} report errors by throwing
exceptions of type \tcode{regex_error}.

\indexlibraryglobal{basic_regex}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = regex_traits<charT>>
    class basic_regex {
    public:
      // types
      using value_type  =          charT;
      using traits_type =          traits;
      using string_type = typename traits::string_type;
      using flag_type   =          regex_constants::syntax_option_type;
      using locale_type = typename traits::locale_type;

      // \ref{re.synopt}, constants
      static constexpr flag_type icase = regex_constants::icase;
      static constexpr flag_type nosubs = regex_constants::nosubs;
      static constexpr flag_type optimize = regex_constants::optimize;
      static constexpr flag_type collate = regex_constants::collate;
      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
      static constexpr flag_type basic = regex_constants::basic;
      static constexpr flag_type extended = regex_constants::extended;
      static constexpr flag_type awk = regex_constants::awk;
      static constexpr flag_type grep = regex_constants::grep;
      static constexpr flag_type egrep = regex_constants::egrep;
      static constexpr flag_type multiline = regex_constants::multiline;

      // \ref{re.regex.construct}, construct/copy/destroy
      basic_regex();
      explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);
      basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
      basic_regex(const basic_regex&);
      basic_regex(basic_regex&&) noexcept;
      template<class ST, class SA>
        explicit basic_regex(const basic_string<charT, ST, SA>& s,
                             flag_type f = regex_constants::ECMAScript);
      template<class ForwardIterator>
        basic_regex(ForwardIterator first, ForwardIterator last,
                    flag_type f = regex_constants::ECMAScript);
      basic_regex(initializer_list<charT> il, flag_type f = regex_constants::ECMAScript);

      ~basic_regex();

      // \ref{re.regex.assign}, assign
      basic_regex& operator=(const basic_regex& e);
      basic_regex& operator=(basic_regex&& e) noexcept;
      basic_regex& operator=(const charT* p);
      basic_regex& operator=(initializer_list<charT> il);
      template<class ST, class SA>
        basic_regex& operator=(const basic_string<charT, ST, SA>& s);

      basic_regex& assign(const basic_regex& e);
      basic_regex& assign(basic_regex&& e) noexcept;
      basic_regex& assign(const charT* p, flag_type f = regex_constants::ECMAScript);
      basic_regex& assign(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
      template<class ST, class SA>
        basic_regex& assign(const basic_string<charT, ST, SA>& s,
                            flag_type f = regex_constants::ECMAScript);
      template<class InputIterator>
        basic_regex& assign(InputIterator first, InputIterator last,
                            flag_type f = regex_constants::ECMAScript);
      basic_regex& assign(initializer_list<charT>,
                          flag_type f = regex_constants::ECMAScript);

      // \ref{re.regex.operations}, const operations
      unsigned mark_count() const;
      flag_type flags() const;

      // \ref{re.regex.locale}, locale
      locale_type imbue(locale_type loc);
      locale_type getloc() const;

      // \ref{re.regex.swap}, swap
      void swap(basic_regex&);
    };

  template<class ForwardIterator>
    basic_regex(ForwardIterator, ForwardIterator,
                regex_constants::syntax_option_type = regex_constants::ECMAScript)
      -> basic_regex<typename iterator_traits<ForwardIterator>::value_type>;
}
\end{codeblock}

\rSec2[re.regex.construct]{Constructors}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
basic_regex();
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} does not match any character sequence.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{p}{p + char_traits<charT>::length(p)} is a valid range.

\pnum
\effects
The object's internal finite state machine
is constructed from the regular expression contained in
the sequence of characters
\range{p}{p + char_traits<charT>::\brk{}length(p)}, and
interpreted according to the flags \tcode{f}.

\pnum
\ensures
\tcode{flags()} returns \tcode{f}.
\tcode{mark_count()} returns the number of marked sub-expressions
within the expression.

\pnum
\throws
\tcode{regex_error} if
\range{p}{p + char_traits<charT>::length(p)} is not a valid regular expression.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{p}{p + len} is a valid range.

\pnum
\effects
The object's internal finite state machine
is constructed from the regular expression contained in
the sequence of characters \range{p}{p + len}, and
interpreted according the flags specified in \tcode{f}.

\pnum
\ensures
\tcode{flags()} returns \tcode{f}.
\tcode{mark_count()} returns the number of marked sub-expressions
within the expression.

\pnum
\throws
\tcode{regex_error} if \range{p}{p + len} is not a valid regular expression.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
basic_regex(const basic_regex& e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{flags()} and \tcode{mark_count()} return
\tcode{e.flags()} and \tcode{e.mark_count()}, respectively.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
basic_regex(basic_regex&& e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{flags()} and \tcode{mark_count()} return the values that
\tcode{e.flags()} and \tcode{e.mark_count()}, respectively, had before construction.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
template<class ST, class SA>
  explicit basic_regex(const basic_string<charT, ST, SA>& s,
                       flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The object's internal finite state machine
is constructed from the regular expression contained in
the string \tcode{s}, and
interpreted according to the flags specified in \tcode{f}.

\pnum
\ensures
\tcode{flags()} returns \tcode{f}.
\tcode{mark_count()} returns the number of marked sub-expressions
within the expression.

\pnum
\throws
\tcode{regex_error} if \tcode{s} is not a valid regular expression.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
template<class ForwardIterator>
  basic_regex(ForwardIterator first, ForwardIterator last,
              flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The object's internal finite state machine
is constructed from the regular expression contained in
the sequence of characters \range{first}{last}, and
interpreted according to the flags specified in \tcode{f}.

\pnum
\ensures
\tcode{flags()} returns \tcode{f}.
\tcode{mark_count()} returns the number of marked sub-expressions
within the expression.

\pnum
\throws
\tcode{regex_error} if the sequence \range{first}{last} is not a
valid regular expression.
\end{itemdescr}

\indexlibraryctor{basic_regex}%
\begin{itemdecl}
basic_regex(initializer_list<charT> il, flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Same as \tcode{basic_regex(il.begin(), il.end(), f)}.
\end{itemdescr}

\rSec2[re.regex.assign]{Assignment}

\indexlibrarymember{basic_regex}{operator=}%
\begin{itemdecl}
basic_regex& operator=(const basic_regex& e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{flags()} and \tcode{mark_count()} return
\tcode{e.flags()} and \tcode{e.mark_count()}, respectively.
\end{itemdescr}

\indexlibrarymember{basic_regex}{operator=}%
\begin{itemdecl}
basic_regex& operator=(basic_regex&& e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{flags()} and \tcode{mark_count()} return the values that
\tcode{e.flags()} and \tcode{e.mark_count()}, respectively, had before assignment.
\tcode{e} is in a valid state with unspecified value.
\end{itemdescr}

\indexlibrarymember{basic_regex}{operator=}%
\begin{itemdecl}
basic_regex& operator=(const charT* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(p);}
\end{itemdescr}

\indexlibrarymember{basic_regex}{operator=}%
\begin{itemdecl}
basic_regex& operator=(initializer_list<charT> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(il.begin(), il.end());}
\end{itemdescr}

\indexlibrarymember{basic_regex}{operator=}%
\begin{itemdecl}
template<class ST, class SA>
  basic_regex& operator=(const basic_string<charT, ST, SA>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(s);}
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
basic_regex& assign(const basic_regex& e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *this = e;}
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
basic_regex& assign(basic_regex&& e) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *this = std::move(e);}
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
basic_regex& assign(const charT* p, flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(string_type(p), f);}
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
basic_regex& assign(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(string_type(p, len), f);}
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
template<class ST, class SA>
  basic_regex& assign(const basic_string<charT, ST, SA>& s,
                      flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns the regular expression contained in the string
\tcode{s}, interpreted according the flags specified in \tcode{f}.
If an exception is thrown, \tcode{*this} is unchanged.

\pnum
\ensures
If no exception is thrown,
\tcode{flags()} returns \tcode{f} and \tcode{mark_count()}
returns the number of marked sub-expressions within the expression.

\pnum
\returns
\tcode{*this}.

\pnum
\throws
\tcode{regex_error} if \tcode{s} is not a valid regular expression.
\end{itemdescr}

\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
template<class InputIterator>
  basic_regex& assign(InputIterator first, InputIterator last,
                      flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(string_type(first, last), f);}
\end{itemdescr}

\indexlibrarymember{assign}{basic_regex}%
\begin{itemdecl}
basic_regex& assign(initializer_list<charT> il,
                    flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return assign(il.begin(), il.end(), f);}
\end{itemdescr}


\rSec2[re.regex.operations]{Constant operations}

\indexlibrarymember{mark_count}{basic_regex}%
\begin{itemdecl}
unsigned mark_count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns the number of marked sub-expressions within the
regular expression.
\end{itemdescr}

\indexlibrarymember{flag_type}{basic_regex}%
\begin{itemdecl}
flag_type flags() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns a copy of the regular expression syntax flags that
were passed to the object's constructor or to the last call
to \tcode{assign}.
\end{itemdescr}

\rSec2[re.regex.locale]{Locale}%
\indexlibraryglobal{locale}

\indexlibrarymember{imbue}{basic_regex}%
\begin{itemdecl}
locale_type imbue(locale_type loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns the result of \tcode{traits_inst.imbue(loc)} where
\tcode{traits_inst} is a (default-initialized) instance of the template
type argument \tcode{traits} stored within the object.  After a call
to \tcode{imbue} the \tcode{basic_regex} object does not match any
character sequence.
\end{itemdescr}

\indexlibrarymember{getloc}{basic_regex}%
\begin{itemdecl}
locale_type getloc() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Returns the result of \tcode{traits_inst.getloc()} where
\tcode{traits_inst} is a (default-initialized) instance of the template
parameter \tcode{traits} stored within the object.
\end{itemdescr}

\rSec2[re.regex.swap]{Swap}
\indexlibrarymember{basic_regex}{swap}%

\indexlibrarymember{swap}{basic_regex}%
\begin{itemdecl}
void swap(basic_regex& e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Swaps the contents of the two regular expressions.

\pnum
\ensures
\tcode{*this} contains the regular expression
that was in \tcode{e}, \tcode{e} contains the regular expression that
was in \tcode{*this}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\rSec2[re.regex.nonmemb]{Non-member functions}

\indexlibrarymember{basic_regex}{swap}%
\begin{itemdecl}
template<class charT, class traits>
  void swap(basic_regex<charT, traits>& lhs, basic_regex<charT, traits>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{lhs.swap(rhs)}.
\end{itemdescr}

\rSec1[re.submatch]{Class template \tcode{sub_match}}

\rSec2[re.submatch.general]{General}
\pnum
\indexlibraryglobal{sub_match}%
Class template \tcode{sub_match} denotes the sequence of characters matched
by a particular marked sub-expression.

\begin{codeblock}
namespace std {
  template<class BidirectionalIterator>
    class sub_match : public pair<BidirectionalIterator, BidirectionalIterator> {
    public:
      using value_type      =
              typename iterator_traits<BidirectionalIterator>::value_type;
      using difference_type =
              typename iterator_traits<BidirectionalIterator>::difference_type;
      using iterator        = BidirectionalIterator;
      using string_type     = basic_string<value_type>;

      bool matched;

      constexpr sub_match();

      difference_type length() const;
      operator string_type() const;
      string_type str() const;

      int compare(const sub_match& s) const;
      int compare(const string_type& s) const;
      int compare(const value_type* s) const;
    };
}
\end{codeblock}


\rSec2[re.submatch.members]{Members}

\indexlibraryctor{sub_match}%
\begin{itemdecl}
constexpr sub_match();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value-initializes the \tcode{pair} base class subobject and the member
\tcode{matched}.
\end{itemdescr}

\indexlibrarymember{sub_match}{length}%
\begin{itemdecl}
difference_type length() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{matched ?\ distance(first, second) :\ 0}.
\end{itemdescr}

\indexlibrarymember{operator basic_string}{sub_match}%
\begin{itemdecl}
operator string_type() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{matched ?\ string_type(first, second) :\ string_type()}.
\end{itemdescr}

\indexlibrarymember{sub_match}{str}%
\begin{itemdecl}
string_type str() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{matched ?\ string_type(first, second) :\ string_type()}.
\end{itemdescr}

\indexlibrarymember{sub_match}{compare}%
\begin{itemdecl}
int compare(const sub_match& s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{str().compare(s.str())}.
\end{itemdescr}

\indexlibrarymember{sub_match}{compare}%
\begin{itemdecl}
int compare(const string_type& s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{str().compare(s)}.
\end{itemdescr}

\indexlibrarymember{sub_match}{compare}%
\begin{itemdecl}
int compare(const value_type* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{str().compare(s)}.
\end{itemdescr}

\rSec2[re.submatch.op]{Non-member operators}

\pnum
Let \tcode{\placeholdernc{SM-CAT}(I)} be
\begin{codeblock}
compare_three_way_result_t<basic_string<typename iterator_traits<I>::value_type>>
\end{codeblock}

\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template<class BiIter>
  bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

\indexlibrarymember{sub_match}{operator<=>}%
\begin{itemdecl}
template<class BiIter>
  auto operator<=>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{static_cast<\placeholdernc{SM-CAT}(BiIter)>(lhs.compare(rhs) <=> 0)}.
\end{itemdescr}

\indexlibrarymember{operator==}{sub_match}%
\begin{itemdecl}
template<class BiIter, class ST, class SA>
  bool operator==(
      const sub_match<BiIter>& lhs,
      const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size())) == 0
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator<=>}{sub_match}%
\begin{itemdecl}
template<class BiIter, class ST, class SA>
  auto operator<=>(
      const sub_match<BiIter>& lhs,
      const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
static_cast<@\placeholdernc{SM-CAT}@(BiIter)>(lhs.compare(
    typename sub_match<BiIter>::string_type(rhs.data(), rhs.size()))
      <=> 0
    )
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template<class BiIter>
  bool operator==(const sub_match<BiIter>& lhs,
                  const typename iterator_traits<BiIter>::value_type* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

\indexlibrarymember{sub_match}{operator<=>}%
\begin{itemdecl}
template<class BiIter>
  auto operator<=>(const sub_match<BiIter>& lhs,
                   const typename iterator_traits<BiIter>::value_type* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{static_cast<\placeholdernc{SM-CAT}(BiIter)>(lhs.compare(rhs) <=> 0)}.
\end{itemdescr}

\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template<class BiIter>
  bool operator==(const sub_match<BiIter>& lhs,
                  const typename iterator_traits<BiIter>::value_type& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) == 0}.
\end{itemdescr}

\indexlibrarymember{sub_match}{operator<=>}%
\begin{itemdecl}
template<class BiIter>
  auto operator<=>(const sub_match<BiIter>& lhs,
                   const typename iterator_traits<BiIter>::value_type& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
static_cast<@\placeholdernc{SM-CAT}@(BiIter)>(lhs.compare(
    typename sub_match<BiIter>::string_type(1, rhs))
      <=> 0
    )
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{basic_ostream}%
\indexlibrarymember{sub_match}{operator<<}%
\begin{itemdecl}
template<class charT, class ST, class BiIter>
  basic_ostream<charT, ST>&
    operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{os << m.str()}.
\end{itemdescr}

\rSec1[re.results]{Class template \tcode{match_results}}

\rSec2[re.results.general]{General}
\pnum
\indexlibraryglobal{match_results}%
Class template \tcode{match_results} denotes a collection of character
sequences representing the result of a regular expression
match. Storage for the collection is allocated and freed as necessary
by the member functions of class template \tcode{match_results}.

\pnum
\indextext{requirements!container}%
\indextext{requirements!sequence}%
The class template \tcode{match_results} meets the requirements of an
allocator-aware container and of a sequence container
(\ref{container.requirements.general}, \ref{sequence.reqmts})
except that only
copy assignment,
move assignment, and
operations defined for const-qualified sequence containers
are supported and
that the semantics of the comparison operator functions are different from those
required for a container.

\pnum
A default-constructed \tcode{match_results} object has no fully established result state. A
match result is \defn{ready} when, as a consequence of a completed regular expression match
modifying such an object, its result state becomes fully established. The effects of calling
most member functions from a \tcode{match_results} object that is not ready are undefined.

\pnum
\indexlibrarymember{match_results}{matched}%
The \tcode{sub_match} object stored at index 0 represents sub-expression 0,
i.e., the whole match. In this case the \tcode{sub_match} member
\tcode{matched} is always \tcode{true}. The \tcode{sub_match}
object stored at index \tcode{n} denotes what matched the marked
sub-expression \tcode{n} within the matched expression. If the
sub-expression \tcode{n} participated in a regular expression
match then the \tcode{sub_match} member \tcode{matched} evaluates to \tcode{true}, and
members \tcode{first} and \tcode{second} denote the range of characters
\range{first}{second} which formed that
match. Otherwise \tcode{matched} is \tcode{false}, and members \tcode{first}
and \tcode{second} point to the end of the sequence
that was searched.
\begin{note}
The \tcode{sub_match} objects representing
different sub-expressions that did not participate in a regular expression
match need not be distinct.
\end{note}

\begin{codeblock}
namespace std {
  template<class BidirectionalIterator,
           class Allocator = allocator<sub_match<BidirectionalIterator>>>
    class match_results {
    public:
      using value_type      = sub_match<BidirectionalIterator>;
      using const_reference = const value_type&;
      using reference       = value_type&;
      using const_iterator  = @{\impdef}@;
      using iterator        = const_iterator;
      using difference_type =
              typename iterator_traits<BidirectionalIterator>::difference_type;
      using size_type       = typename allocator_traits<Allocator>::size_type;
      using allocator_type  = Allocator;
      using char_type       =
              typename iterator_traits<BidirectionalIterator>::value_type;
      using string_type     = basic_string<char_type>;

      // \ref{re.results.const}, construct/copy/destroy
      match_results() : match_results(Allocator()) {}
      explicit match_results(const Allocator&);
      match_results(const match_results& m);
      match_results(match_results&& m) noexcept;
      match_results& operator=(const match_results& m);
      match_results& operator=(match_results&& m);
      ~match_results();

      // \ref{re.results.state}, state
      bool ready() const;

      // \ref{re.results.size}, size
      size_type size() const;
      size_type max_size() const;
      [[nodiscard]] bool empty() const;

      // \ref{re.results.acc}, element access
      difference_type length(size_type sub = 0) const;
      difference_type position(size_type sub = 0) const;
      string_type str(size_type sub = 0) const;
      const_reference operator[](size_type n) const;

      const_reference prefix() const;
      const_reference suffix() const;
      const_iterator begin() const;
      const_iterator end() const;
      const_iterator cbegin() const;
      const_iterator cend() const;

      // \ref{re.results.form}, format
      template<class OutputIter>
        OutputIter
          format(OutputIter out,
                 const char_type* fmt_first, const char_type* fmt_last,
                 regex_constants::match_flag_type flags = regex_constants::format_default) const;
      template<class OutputIter, class ST, class SA>
        OutputIter
          format(OutputIter out,
                 const basic_string<char_type, ST, SA>& fmt,
                 regex_constants::match_flag_type flags = regex_constants::format_default) const;
      template<class ST, class SA>
        basic_string<char_type, ST, SA>
          format(const basic_string<char_type, ST, SA>& fmt,
                 regex_constants::match_flag_type flags = regex_constants::format_default) const;
      string_type
        format(const char_type* fmt,
               regex_constants::match_flag_type flags = regex_constants::format_default) const;

      // \ref{re.results.all}, allocator
      allocator_type get_allocator() const;

      // \ref{re.results.swap}, swap
      void swap(match_results& that);
    };
}
\end{codeblock}

\rSec2[re.results.const]{Constructors}

\indexlibraryctor{match_results}%
\begin{itemdecl}
explicit match_results(const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{ready()} returns \tcode{false}.
\tcode{size()} returns \tcode{0}.
\end{itemdescr}

\indexlibraryctor{match_results}%
\begin{itemdecl}
match_results(match_results&& m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The stored \tcode{Allocator} value is move constructed from \tcode{m.get_allocator()}.

\pnum
\ensures
As specified in \tref{re.results.const}.
\end{itemdescr}

\indexlibrarymember{match_results}{operator=}%
\begin{itemdecl}
match_results& operator=(const match_results& m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
As specified in \tref{re.results.const}.
\end{itemdescr}

\indexlibrarymember{match_results}{operator=}%
\begin{itemdecl}
match_results& operator=(match_results&& m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
As specified in \tref{re.results.const}.
\end{itemdescr}

\begin{libefftabvalue}
  {\tcode{match_results} assignment operator effects}
  {re.results.const}
\tcode{ready()}         & \tcode{m.ready()}       \\ \rowsep
\tcode{size()}          & \tcode{m.size()}        \\ \rowsep
\tcode{str(n)}          & \tcode{m.str(n)} for all integers \tcode{n < m.size()} \\ \rowsep
\tcode{prefix()}        & \tcode{m.prefix()} \\ \rowsep
\tcode{suffix()}        & \tcode{m.suffix()} \\ \rowsep
\tcode{(*this)[n]}      & \tcode{m[n]} for all integers \tcode{n < m.size()} \\ \rowsep
\tcode{length(n)}       & \tcode{m.length(n)} for all integers \tcode{n < m.size()} \\ \rowsep
\tcode{position(n)}     & \tcode{m.position(n)} for all integers \tcode{n < m.size()} \\
\end{libefftabvalue}

\rSec2[re.results.state]{State}

\indexlibrarymember{match_results}{ready}%
\begin{itemdecl}
bool ready() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{*this} has a fully established result state, otherwise
\tcode{false}.
\end{itemdescr}

\rSec2[re.results.size]{Size}

\indexlibrarymember{match_results}{size}%
\begin{itemdecl}
size_type size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
One plus the number of marked sub-expressions in the
regular expression that was matched if \tcode{*this} represents the
result of a successful match.  Otherwise returns \tcode{0}.
\begin{note}
The state of a \tcode{match_results} object can be modified
only by passing that object to \tcode{regex_match} or \tcode{regex_search}.
Subclauses~\ref{re.alg.match} and~\ref{re.alg.search} specify the
effects of those algorithms on their \tcode{match_results} arguments.
\end{note}
\end{itemdescr}

\indexlibrarymember{match_results}{max_size}%
\begin{itemdecl}
size_type max_size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The maximum number of \tcode{sub_match} elements that can be
stored in \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{match_results}{empty}%
\begin{itemdecl}
[[nodiscard]] bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{size() == 0}.
\end{itemdescr}

\rSec2[re.results.acc]{Element access}

\indexlibrarymember{length}{match_results}%
\begin{itemdecl}
difference_type length(size_type sub = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
\tcode{(*this)[sub].length()}.
\end{itemdescr}

\indexlibrarymember{position}{match_results}%
\begin{itemdecl}
difference_type position(size_type sub = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
The distance from the start of the target sequence
to \tcode{(*this)[sub].first}.
\end{itemdescr}

\indexlibrarymember{match_results}{str}%
\begin{itemdecl}
string_type str(size_type sub = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
\tcode{string_type((*this)[sub])}.
\end{itemdescr}

\indexlibrarymember{match_results}{operator[]}%
\begin{itemdecl}
const_reference operator[](size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
A reference to the \tcode{sub_match} object representing the
character sequence that matched marked sub-expression \tcode{n}. If \tcode{n == 0}
then returns a reference to a \tcode{sub_match} object representing the
character sequence that matched the whole regular expression. If
\tcode{n >= size()} then returns a \tcode{sub_match} object representing an
unmatched sub-expression.
\end{itemdescr}

\indexlibrarymember{match_results}{prefix}%
\begin{itemdecl}
const_reference prefix() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
A reference to the \tcode{sub_match} object representing the
character sequence from the start of the string being
matched/searched to the start of the match found.
\end{itemdescr}

\indexlibrarymember{match_results}{suffix}%
\begin{itemdecl}
const_reference suffix() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\returns
A reference to the \tcode{sub_match} object representing the
character sequence from the end of the match found to the end of the
string being matched/searched.
\end{itemdescr}

\indexlibrarymember{match_results}{begin}%
\begin{itemdecl}
const_iterator begin() const;
const_iterator cbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A starting iterator that enumerates over all the
sub-expressions stored in \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{match_results}{end}%
\begin{itemdecl}
const_iterator end() const;
const_iterator cend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A terminating iterator that enumerates over all the
sub-expressions stored in \tcode{*this}.
\end{itemdescr}

\rSec2[re.results.form]{Formatting}

\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
template<class OutputIter>
  OutputIter format(
      OutputIter out,
      const char_type* fmt_first, const char_type* fmt_last,
      regex_constants::match_flag_type flags = regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true} and \tcode{OutputIter} meets the requirements for a
\oldconcept{OutputIterator}\iref{output.iterators}.

\pnum
\effects
Copies the character sequence \range{fmt_first}{fmt_last} to
OutputIter \tcode{out}.  Replaces each format specifier or escape
sequence in the copied range with either the character(s) it represents or
the sequence of characters within \tcode{*this} to which it refers.
The bitmasks specified in \tcode{flags} determine which format
specifiers and escape sequences are recognized.

\pnum
\returns
\tcode{out}.
\end{itemdescr}

\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
template<class OutputIter, class ST, class SA>
  OutputIter format(
      OutputIter out,
      const basic_string<char_type, ST, SA>& fmt,
      regex_constants::match_flag_type flags = regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return format(out, fmt.data(), fmt.data() + fmt.size(), flags);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
template<class ST, class SA>
  basic_string<char_type, ST, SA> format(
      const basic_string<char_type, ST, SA>& fmt,
      regex_constants::match_flag_type flags = regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\effects
Constructs an empty string \tcode{result} of type \tcode{basic_string<char_type, ST, SA>} and
calls:
\begin{codeblock}
format(back_inserter(result), fmt, flags);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
string_type format(
    const char_type* fmt,
    regex_constants::match_flag_type flags = regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{ready() == true}.

\pnum
\effects
Constructs an empty string \tcode{result} of type \tcode{string_type} and
calls:
\begin{codeblock}
format(back_inserter(result), fmt, fmt + char_traits<char_type>::length(fmt), flags);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\rSec2[re.results.all]{Allocator}%

\indexlibrarymember{get_allocator}{match_results}%
\begin{itemdecl}
allocator_type get_allocator() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A copy of the Allocator that was passed to the object's constructor or, if that
allocator has been replaced, a copy of the most recent replacement.
\end{itemdescr}

\rSec2[re.results.swap]{Swap}

\indexlibrarymember{match_results}{swap}%
\begin{itemdecl}
void swap(match_results& that);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Swaps the contents of the two sequences.

\pnum
\ensures
\tcode{*this} contains the sequence of matched
sub-expressions that were in \tcode{that}, \tcode{that} contains the
sequence of matched sub-expressions that were in \tcode{*this}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrarymember{match_results}{swap}%
\begin{itemdecl}
template<class BidirectionalIterator, class Allocator>
  void swap(match_results<BidirectionalIterator, Allocator>& m1,
            match_results<BidirectionalIterator, Allocator>& m2);
\end{itemdecl}

\pnum
\effects
As if by \tcode{m1.swap(m2)}.

\rSec2[re.results.nonmember]{Non-member functions}

\indexlibrarymember{operator==}{match_results}%
\begin{itemdecl}
template<class BidirectionalIterator, class Allocator>
bool operator==(const match_results<BidirectionalIterator, Allocator>& m1,
                const match_results<BidirectionalIterator, Allocator>& m2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if neither match result is ready, \tcode{false} if one match result is ready and the
other is not. If both match results are ready, returns \tcode{true} only if:
\begin{itemize}
\item
\tcode{m1.empty() \&\& m2.empty()}, or

\item
\tcode{!m1.empty() \&\& !m2.empty()}, and the following conditions are satisfied:
\begin{itemize}
\item
\tcode{m1.prefix() == m2.prefix()},

\item
\tcode{m1.size() == m2.size() \&\& equal(m1.begin(), m1.end(), m2.begin())}, and

\item
\tcode{m1.suffix() == m2.suffix()}.
\end{itemize}
\end{itemize}
\begin{note}
The algorithm \tcode{equal} is defined in \ref{algorithms}.
\end{note}
\end{itemdescr}

\rSec1[re.alg]{Regular expression algorithms}

\rSec2[re.except]{Exceptions}
\pnum
The algorithms described in subclause~\ref{re.alg} may throw an exception
of type \tcode{regex_error}. If such an exception \tcode{e} is thrown,
\tcode{e.code()} shall return either \tcode{regex_constants::error_complexity}
or \tcode{regex_constants::error_stack}.

\rSec2[re.alg.match]{\tcode{regex_match}}
\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class BidirectionalIterator, class Allocator, class charT, class traits>
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   match_results<BidirectionalIterator, Allocator>& m,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{BidirectionalIterator} meets the
\oldconcept{BidirectionalIterator} requirements\iref{bidirectional.iterators}.

\pnum
\effects
Determines whether there is a match between the
regular expression \tcode{e}, and all of the character
sequence \range{first}{last}. The parameter \tcode{flags} is
used to control how the expression is matched against the character
sequence. When determining if there is a match, only potential matches
that match the entire character sequence are considered.
Returns \tcode{true} if such a match exists, \tcode{false}
otherwise.
\begin{example}
\begin{codeblock}
std::regex re("Get|GetValue");
std::cmatch m;
regex_search("GetValue", m, re);        // returns \tcode{true}, and \tcode{m[0]} contains \tcode{"Get"}
regex_match ("GetValue", m, re);        // returns \tcode{true}, and \tcode{m[0]} contains \tcode{"GetValue"}
regex_search("GetValues", m, re);       // returns \tcode{true}, and \tcode{m[0]} contains \tcode{"Get"}
regex_match ("GetValues", m, re);       // returns \tcode{false}
\end{codeblock}
\end{example}

\pnum
\ensures
\tcode{m.ready() == true} in all cases.
If the function returns \tcode{false}, then the effect
on parameter \tcode{m} is unspecified except that \tcode{m.size()}
returns \tcode{0} and \tcode{m.empty()} returns \tcode{true}.
Otherwise the effects on parameter \tcode{m} are given in
\tref{re.alg.match}.
\end{itemdescr}

\begin{longlibefftabvalue}
  {Effects of \tcode{regex_match} algorithm}
  {re.alg.match}
\tcode{m.size()}
&
\tcode{1 + e.mark_count()}
\\ \rowsep
\tcode{m.empty()}
&
\tcode{false}
\\ \rowsep
\tcode{m.prefix().first}
&
\tcode{first}
\\ \rowsep
\tcode{m.prefix().second}
&
\tcode{first}
\\ \rowsep
\tcode{m.prefix().matched}
&
\tcode{false}
\\ \rowsep
\tcode{m.suffix().first}
&
\tcode{last}
\\ \rowsep
\tcode{m.suffix().second}
&
\tcode{last}
\\ \rowsep
\tcode{m.suffix().matched}
&
\tcode{false}
\\ \rowsep
\tcode{m[0].first}
&
\tcode{first}
\\ \rowsep
\tcode{m[0].second}
&
\tcode{last}
\\ \rowsep
\tcode{m[0].matched}
&
\tcode{true}
\\ \rowsep
\tcode{m[n].first}
&
For all integers \tcode{0 < n < m.size()}, the start of the sequence that matched
sub-expression \tcode{n}. Alternatively, if sub-expression \tcode{n} did not participate
in the match, then \tcode{last}.
\\ \rowsep
\tcode{m[n].second}
&
For all integers \tcode{0 < n < m.size()}, the end of the sequence that matched
sub-expression \tcode{n}. Alternatively, if sub-expression \tcode{n} did not participate
in the match, then \tcode{last}.
\\ \rowsep
\tcode{m[n].matched}
&
For all integers \tcode{0 < n < m.size()}, \tcode{true} if sub-expression \tcode{n} participated in
the match, \tcode{false} otherwise.
\\
\end{longlibefftabvalue}

\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class BidirectionalIterator, class charT, class traits>
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves ``as if'' by constructing an instance of
\tcode{match_results<BidirectionalIterator> what}, and then
returning the result of
\tcode{regex_match(first, last, what, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class charT, class Allocator, class traits>
  bool regex_match(const charT* str,
                   match_results<const charT*, Allocator>& m,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_match(str, str + char_traits<charT>::length(str), m, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class ST, class SA, class Allocator, class charT, class traits>
  bool regex_match(const basic_string<charT, ST, SA>& s,
                   match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                 Allocator>& m,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_match(s.begin(), s.end(), m, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class charT, class traits>
  bool regex_match(const charT* str,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_match(str, str + char_traits<charT>::length(str), e, flags)}
\end{itemdescr}

\indexlibraryglobal{regex_match}%
\begin{itemdecl}
template<class ST, class SA, class charT, class traits>
  bool regex_match(const basic_string<charT, ST, SA>& s,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_match(s.begin(), s.end(), e, flags)}.
\end{itemdescr}

\rSec2[re.alg.search]{\tcode{regex_search}}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class BidirectionalIterator, class Allocator, class charT, class traits>
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    match_results<BidirectionalIterator, Allocator>& m,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{BidirectionalIterator} meets the
\oldconcept{BidirectionalIterator} requirements\iref{bidirectional.iterators}.

\pnum
\effects
Determines whether there is some sub-sequence within \range{first}{last} that matches
the regular expression \tcode{e}. The parameter \tcode{flags} is used to control how the
expression is matched against the character sequence. Returns \tcode{true} if such a sequence
exists, \tcode{false} otherwise.

\pnum
\ensures
\tcode{m.ready() == true} in all cases.
If the function returns \tcode{false}, then the effect
on parameter \tcode{m} is unspecified except that \tcode{m.size()}
returns \tcode{0} and \tcode{m.empty()} returns \tcode{true}.  Otherwise
the effects on parameter \tcode{m} are given in \tref{re.alg.search}.
\end{itemdescr}

\begin{longlibefftabvalue}
  {Effects of \tcode{regex_search} algorithm}
  {re.alg.search}
\tcode{m.size()}
&
\tcode{1 + e.mark_count()}
\\ \rowsep
\tcode{m.empty()}
&
\tcode{false}
\\ \rowsep
\tcode{m.prefix().first}
&
\tcode{first}
\\ \rowsep
\tcode{m.prefix().second}
&
\tcode{m[0].first}
\\ \rowsep
\tcode{m.prefix().matched}
&
\tcode{m.prefix().first != m.prefix().second}
\\ \rowsep
\tcode{m.suffix().first}
&
\tcode{m[0].second}
\\ \rowsep
\tcode{m.suffix().second}
&
\tcode{last}
\\ \rowsep
\tcode{m.suffix().matched}
&
\tcode{m.suffix().first != m.suffix().second}
\\ \rowsep
\tcode{m[0].first}
&
The start of the sequence of characters that matched the regular expression
\\ \rowsep
\tcode{m[0].second}
&
The end of the sequence of characters that matched the regular expression
\\ \rowsep
\tcode{m[0].matched}
&
\tcode{true}
\\ \rowsep
\tcode{m[n].first}
&
For all integers \tcode{0 < n < m.size()}, the start of the sequence that
matched sub-expression \tcode{n}. Alternatively, if sub-expression \tcode{n}
did not participate in the match, then \tcode{last}.
\\ \rowsep
\tcode{m[n].second}
&
For all integers \tcode{0 < n < m.size()}, the end of the sequence that matched
sub-expression \tcode{n}. Alternatively, if sub-expression \tcode{n} did not
participate in the match, then \tcode{last}.
\\ \rowsep
\tcode{m[n].matched}
&
For all integers \tcode{0 < n < m.size()}, \tcode{true} if sub-expression \tcode{n}
participated in the match, \tcode{false} otherwise.
\\
\end{longlibefftabvalue}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class charT, class Allocator, class traits>
  bool regex_search(const charT* str, match_results<const charT*, Allocator>& m,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_search(str, str + char_traits<charT>::length(str), m, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class ST, class SA, class Allocator, class charT, class traits>
  bool regex_search(const basic_string<charT, ST, SA>& s,
                    match_results<typename basic_string<charT, ST, SA>::const_iterator,
                                  Allocator>& m,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_search(s.begin(), s.end(), m, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class BidirectionalIterator, class charT, class traits>
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves ``as if'' by constructing an object \tcode{what}
of type \tcode{match_results<Bidirectional\-Iterator>} and returning
\tcode{regex_search(first, last, what, e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class charT, class traits>
  bool regex_search(const charT* str,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_search(str, str + char_traits<charT>::length(str), e, flags)}.
\end{itemdescr}

\indexlibraryglobal{regex_search}%
\begin{itemdecl}
template<class ST, class SA, class charT, class traits>
  bool regex_search(const basic_string<charT, ST, SA>& s,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{regex_search(s.begin(), s.end(), e, flags)}.
\end{itemdescr}

\rSec2[re.alg.replace]{\tcode{regex_replace}}

\indexlibraryglobal{regex_replace}%
\begin{itemdecl}
template<class OutputIterator, class BidirectionalIterator,
          class traits, class charT, class ST, class SA>
  OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, ST, SA>& fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
template<class OutputIterator, class BidirectionalIterator, class traits, class charT>
  OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\indexlibraryglobal{format_no_copy}%
\indexlibraryglobal{format_first_only}%
\effects
Constructs a \tcode{regex_iterator} object \tcode{i}
as if by
\begin{codeblock}
regex_iterator<BidirectionalIterator, charT, traits> i(first, last, e, flags)
\end{codeblock}
and uses \tcode{i} to enumerate through all
of the matches \tcode{m} of type \tcode{match_results<BidirectionalIterator>}
that occur within the sequence \range{first}{last}.
If no such
matches are found and
\tcode{!(flags \& regex_constants::format_no_copy)}, then calls
\begin{codeblock}
out = copy(first, last, out)
\end{codeblock}
If any matches are found then, for each such match:
\begin{itemize}
\item
If \tcode{!(flags \& regex_constants::format_no_copy)}, calls
\begin{codeblock}
out = copy(m.prefix().first, m.prefix().second, out)
\end{codeblock}
\item
Then calls
\begin{codeblock}
out = m.format(out, fmt, flags)
\end{codeblock}
for the first form of the function and
\begin{codeblock}
out = m.format(out, fmt, fmt + char_traits<charT>::length(fmt), flags)
\end{codeblock}
for the second.
\end{itemize}
Finally, if such a match
is found and \tcode{!(flags \& regex_constants::format_no_copy)},
calls
\begin{codeblock}
out = copy(last_m.suffix().first, last_m.suffix().second, out)
\end{codeblock}
where \tcode{last_m} is a copy of the last match
found. If \tcode{flags \& regex_constants::format_first_only}
is nonzero, then only the first match found is replaced.

\pnum
\returns
\tcode{out}.
\end{itemdescr}

\indexlibraryglobal{regex_replace}%
\begin{itemdecl}
template<class traits, class charT, class ST, class SA, class FST, class FSA>
  basic_string<charT, ST, SA>
    regex_replace(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, FST, FSA>& fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT, class ST, class SA>
  basic_string<charT, ST, SA>
    regex_replace(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty string \tcode{result} of
type \tcode{basic_string<charT, ST, SA>} and calls:
\begin{codeblock}
regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\indexlibraryglobal{regex_replace}%
\begin{itemdecl}
template<class traits, class charT, class ST, class SA>
  basic_string<charT>
    regex_replace(const charT* s,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, ST, SA>& fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT>
  basic_string<charT>
    regex_replace(const charT* s,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty string \tcode{result} of
type \tcode{basic_string<charT>} and calls:
\begin{codeblock}
regex_replace(back_inserter(result), s, s + char_traits<charT>::length(s), e, fmt, flags);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\rSec1[re.iter]{Regular expression iterators}

\rSec2[re.regiter]{Class template \tcode{regex_iterator}}

\rSec3[re.regiter.general]{General}
\pnum
\indexlibraryglobal{regex_iterator}%
\indexlibraryglobal{match_results}%
The class template \tcode{regex_iterator} is an iterator adaptor.
It represents a new view of an existing iterator sequence, by
enumerating all the occurrences of a regular expression within that
sequence. A \tcode{regex_iterator} uses  \tcode{regex_search} to find successive
regular expression matches within the sequence from which it was
constructed.  After the iterator is constructed, and every time \tcode{operator++} is
used, the iterator finds and stores a value of
\tcode{match_results<BidirectionalIterator>}. If the end of the sequence is
reached (\tcode{regex_search} returns \tcode{false}), the iterator becomes equal to
the end-of-sequence iterator value. The default constructor
constructs an end-of-sequence iterator object,
which is the only legitimate iterator to be used for the end
condition. The result of \tcode{operator*} on an end-of-sequence iterator is not
defined. For any other iterator value a const
\tcode{match_results<BidirectionalIterator>\&} is returned. The result of
\tcode{operator->} on an end-of-sequence iterator is not defined. For any other
iterator value a \tcode{const match_results<BidirectionalIterator>*} is
returned. It is impossible to store things into \tcode{regex_iterator}s. Two
end-of-sequence iterators are always equal. An end-of-sequence
iterator is not equal to a non-end-of-sequence iterator. Two
non-end-of-sequence iterators are equal when they are constructed from
the same arguments.

\begin{codeblock}
namespace std {
  template<class BidirectionalIterator,
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT>>
    class regex_iterator {
    public:
      using regex_type        = basic_regex<charT, traits>;
      using iterator_category = forward_iterator_tag;
      using value_type        = match_results<BidirectionalIterator>;
      using difference_type   = ptrdiff_t;
      using pointer           = const value_type*;
      using reference         = const value_type&;

      regex_iterator();
      regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type& re,
                     regex_constants::match_flag_type m = regex_constants::match_default);
      regex_iterator(BidirectionalIterator, BidirectionalIterator,
                     const regex_type&&,
                     regex_constants::match_flag_type = regex_constants::match_default) = delete;
      regex_iterator(const regex_iterator&);
      regex_iterator& operator=(const regex_iterator&);
      bool operator==(const regex_iterator&) const;
      const value_type& operator*() const;
      const value_type* operator->() const;
      regex_iterator& operator++();
      regex_iterator operator++(int);

    private:
      BidirectionalIterator                begin;               // \expos
      BidirectionalIterator                end;                 // \expos
      const regex_type*                    pregex;              // \expos
      regex_constants::match_flag_type     flags;               // \expos
      match_results<BidirectionalIterator> match;               // \expos
    };
}
\end{codeblock}

\pnum
An object of type \tcode{regex_iterator} that is not an end-of-sequence iterator
holds a \textit{zero-length match} if \tcode{match[0].matched == true} and
\tcode{match[0].first == match[0].second}.
\begin{note}
For
example, this can occur when the part of the regular expression that
matched consists only of an assertion (such as \verb|'^'|, \verb|'$'|,
\tcode{'$\backslash$b'}, \tcode{'$\backslash$B'}).
\end{note}

\rSec3[re.regiter.cnstr]{Constructors}

\indexlibraryctor{regex_iterator}%
\begin{itemdecl}
regex_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an end-of-sequence iterator.
\end{itemdescr}

\indexlibraryctor{regex_iterator}%
\begin{itemdecl}
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
               const regex_type& re,
               regex_constants::match_flag_type m = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{begin} and \tcode{end} to
\tcode{a} and \tcode{b}, respectively, sets
\tcode{pregex} to \tcode{addressof(re)}, sets \tcode{flags} to
\tcode{m}, then calls \tcode{regex_search(begin, end, match, *pregex, flags)}. If this
call returns \tcode{false} the constructor sets \tcode{*this} to the end-of-sequence
iterator.
\end{itemdescr}

\rSec3[re.regiter.comp]{Comparisons}

\indexlibrarymember{regex_iterator}{operator==}%
\begin{itemdecl}
bool operator==(const regex_iterator& right) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{*this} and \tcode{right} are both end-of-sequence
iterators or if the following conditions all hold:
\begin{itemize}
\item \tcode{begin == right.begin},
\item \tcode{end == right.end},
\item \tcode{pregex == right.pregex},
\item \tcode{flags == right.flags}, and
\item \tcode{match[0] == right.match[0]};
\end{itemize}
otherwise \tcode{false}.
\end{itemdescr}

\rSec3[re.regiter.deref]{Indirection}

\indexlibrarymember{regex_iterator}{operator*}%
\begin{itemdecl}
const value_type& operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{match}.
\end{itemdescr}

\indexlibrarymember{operator->}{regex_iterator}%
\begin{itemdecl}
const value_type* operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{addressof(match)}.
\end{itemdescr}

\rSec3[re.regiter.incr]{Increment}

\indexlibrarymember{regex_iterator}{operator++}%
\indexlibrary{\idxcode{regex_iterator}!increment}%
\begin{itemdecl}
regex_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a local variable \tcode{start} of type \tcode{BidirectionalIterator} and
initializes it with the value of \tcode{match[0].second}.

\pnum
If the iterator holds a zero-length match and \tcode{start == end} the operator
sets \tcode{*this} to the end-of-sequence iterator and returns \tcode{*this}.

\pnum
\indexlibraryglobal{match_not_null}%
\indexlibraryglobal{match_continuous}%
Otherwise, if the iterator holds a zero-length match, the operator calls:
\begin{codeblock}
regex_search(start, end, match, *pregex,
             flags | regex_constants::match_not_null | regex_constants::match_continuous)
\end{codeblock}
If the call returns \tcode{true} the operator
returns \tcode{*this}. Otherwise the operator increments \tcode{start} and continues as if
the most recent match was not a zero-length match.

\pnum
\indexlibraryglobal{match_prev_avail}%
If the most recent match was not a zero-length match, the operator sets
\tcode{flags} to \tcode{flags | regex_constants::match_prev_avail} and
calls \tcode{regex_search(start, end, match, *pregex, flags)}. If the call returns
\tcode{false} the iterator sets \tcode{*this} to the end-of-sequence iterator. The
iterator then returns \tcode{*this}.

\pnum
In all cases in which the call to \tcode{regex_search} returns \tcode{true},
\tcode{match.prefix().first} shall be equal to the previous value of
\tcode{match[0].second}, and for each index \tcode{i} in the half-open range
\tcode{[0, match.size())} for which \tcode{match[i].matched} is \tcode{true},
\tcode{match.position(i)}
shall return \tcode{distance(begin, match[i].\brk{}first)}.

\pnum
\begin{note}
This means that \tcode{match.position(i)} gives the
offset from the beginning of the target sequence, which is often not
the same as the offset from the sequence passed in the call
to \tcode{regex_search}.
\end{note}

\pnum
It is unspecified how the implementation makes these adjustments.

\pnum
\begin{note}
This means that a compiler can call an
implementation-specific search function, in which case a program-defined
specialization of \tcode{regex_search} will not be
called.
\end{note}
\end{itemdescr}

\indexlibrarymember{regex_iterator}{operator++}%
\begin{itemdecl}
regex_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
regex_iterator tmp = *this;
++(*this);
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec2[re.tokiter]{Class template \tcode{regex_token_iterator}}

\rSec3[re.tokiter.general]{General}

\pnum
\indexlibraryglobal{regex_token_iterator}%
The class template \tcode{regex_token_iterator} is an iterator adaptor; that
is to say it represents a new view of an existing iterator sequence,
by enumerating all the occurrences of a regular expression within that
sequence, and presenting one or more sub-expressions for each match
found. Each position enumerated by the iterator is a \tcode{sub_match} class
template instance that represents what matched a particular sub-expression
within the regular expression.

\pnum
When class \tcode{regex_token_iterator} is used to enumerate a
single sub-expression with index -1 the iterator performs field
splitting: that is to say it enumerates one sub-expression for each section of
the character container sequence that does not match the regular
expression specified.

\pnum
\indexlibraryglobal{match_results}%
After it is constructed, the iterator finds and stores a value
\tcode{regex_iterator<BidirectionalIterator> position}
and sets the internal count \tcode{N} to zero. It also maintains a sequence
\tcode{subs} which contains a list of the sub-expressions which will be
enumerated. Every time \tcode{operator++} is used
the count \tcode{N} is incremented; if \tcode{N} exceeds or equals \tcode{subs.size()},
then the iterator increments member \tcode{position}
and sets count \tcode{N} to zero.

\pnum
If the end of sequence is reached (\tcode{position} is equal to the end of
sequence iterator), the iterator becomes equal to the end-of-sequence
iterator value, unless the sub-expression being enumerated has index -1,
in which case the iterator enumerates one last sub-expression that contains
all the characters from the end of the last regular expression match to the
end of the input sequence being enumerated, provided that this would not be an
empty sub-expression.

\pnum
\indexlibrary{\idxcode{regex_token_iterator}!end-of-sequence}%
The default constructor constructs
an end-of-sequence iterator object, which is the only legitimate
iterator to be used for the end condition. The result of \tcode{operator*} on
an end-of-sequence iterator is not defined. For any other iterator value a
\tcode{const sub_match<BidirectionalIterator>\&} is returned.
The result of \tcode{operator->} on an end-of-sequence iterator
is not defined. For any other iterator value a \tcode{const
sub_match<BidirectionalIterator>*} is returned.

\pnum
\indexlibrarymember{regex_token_iterator}{operator==}%
It is impossible to store things
into \tcode{regex_token_iterator}s. Two end-of-sequence iterators are always
equal. An end-of-sequence iterator is not equal to a
non-end-of-sequence iterator. Two non-end-of-sequence iterators are
equal when they are constructed from the same arguments.

\begin{codeblock}
namespace std {
  template<class BidirectionalIterator,
            class charT = typename iterator_traits<BidirectionalIterator>::value_type,
            class traits = regex_traits<charT>>
    class regex_token_iterator {
    public:
      using regex_type        = basic_regex<charT, traits>;
      using iterator_category = forward_iterator_tag;
      using value_type        = sub_match<BidirectionalIterator>;
      using difference_type   = ptrdiff_t;
      using pointer           = const value_type*;
      using reference         = const value_type&;

      regex_token_iterator();
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type& re,
                           int submatch = 0,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default);
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type& re,
                           const vector<int>& submatches,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default);
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type& re,
                           initializer_list<int> submatches,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default);
      template<size_t N>
        regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                             const regex_type& re,
                             const int (&submatches)[N],
                             regex_constants::match_flag_type m =
                               regex_constants::match_default);
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type&& re,
                           int submatch = 0,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default) = delete;
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type&& re,
                           const vector<int>& submatches,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default) = delete;
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type&& re,
                           initializer_list<int> submatches,
                           regex_constants::match_flag_type m =
                             regex_constants::match_default) = delete;
      template<size_t N>
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                           const regex_type&& re,
                           const int (&submatches)[N],
                           regex_constants::match_flag_type m =
                             regex_constants::match_default) = delete;
      regex_token_iterator(const regex_token_iterator&);
      regex_token_iterator& operator=(const regex_token_iterator&);
      bool operator==(const regex_token_iterator&) const;
      const value_type& operator*() const;
      const value_type* operator->() const;
      regex_token_iterator& operator++();
      regex_token_iterator operator++(int);

    private:
      using position_iterator =
        regex_iterator<BidirectionalIterator, charT, traits>;   // \expos
      position_iterator position;                               // \expos
      const value_type* result;                                 // \expos
      value_type suffix;                                        // \expos
      size_t N;                                                 // \expos
      vector<int> subs;                                         // \expos
    };
}
\end{codeblock}

\pnum
A \textit{suffix iterator} is a \tcode{regex_token_iterator} object
that points to a final sequence of characters at
the end of the target sequence. In a suffix iterator the
member \tcode{result} holds a pointer to the data
member \tcode{suffix}, the value of the member \tcode{suffix.match}
is \tcode{true}, \tcode{suffix.first} points to the beginning of the
final sequence, and \tcode{suffix.second} points to the end of the
final sequence.

\pnum
\begin{note}
For a suffix iterator, data
member \tcode{suffix.first} is the same as the end of the last match
found, and \tcode{suffix\brk.second} is the same as the end of the target
sequence.
\end{note}

\pnum
The \textit{current match} is \tcode{(*position).prefix()} if \tcode{subs[N] == -1}, or
\tcode{(*position)[subs[N]]} for any other value of \tcode{subs[N]}.

\rSec3[re.tokiter.cnstr]{Constructors}

\indexlibraryctor{regex_token_iterator}%
\begin{itemdecl}
regex_token_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs the end-of-sequence iterator.
\end{itemdescr}

\indexlibraryctor{regex_token_iterator}%
\begin{itemdecl}
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type& re,
                     int submatch = 0,
                     regex_constants::match_flag_type m = regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type& re,
                     const vector<int>& submatches,
                     regex_constants::match_flag_type m = regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type& re,
                     initializer_list<int> submatches,
                     regex_constants::match_flag_type m = regex_constants::match_default);

template<size_t N>
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                       const regex_type& re,
                       const int (&submatches)[N],
                       regex_constants::match_flag_type m = regex_constants::match_default);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
Each of the initialization values of \tcode{submatches} is \tcode{>= -1}.

\pnum
\effects
The first constructor initializes the member \tcode{subs} to hold the single
value \tcode{submatch}.
The second, third, and fourth constructors
initialize the member \tcode{subs} to hold a copy of the sequence of integer values
pointed to by the iterator range
\range{begin(submatches)}{end(submatches)}.

\pnum
Each constructor then sets \tcode{N} to 0, and \tcode{position} to
\tcode{position_iterator(a, b, re, m)}. If \tcode{position} is not an
end-of-sequence iterator the constructor sets \tcode{result} to the
address of the current match. Otherwise if any of the values stored
in \tcode{subs} is equal to -1 the constructor sets \tcode{*this} to a suffix
iterator that points to the range \range{a}{b}, otherwise the constructor
sets \tcode{*this} to an end-of-sequence iterator.
\end{itemdescr}

\rSec3[re.tokiter.comp]{Comparisons}

\indexlibrarymember{regex_token_iterator}{operator==}%
\begin{itemdecl}
bool operator==(const regex_token_iterator& right) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{*this} and \tcode{right} are both end-of-sequence iterators,
or if \tcode{*this} and \tcode{right} are both suffix iterators and \tcode{suffix == right.suffix};
otherwise returns \tcode{false} if \tcode{*this} or \tcode{right} is an end-of-sequence
iterator or a suffix iterator. Otherwise returns \tcode{true} if \tcode{position == right.position},
\tcode{N == right.N}, and \tcode{subs == right.subs}. Otherwise returns \tcode{false}.
\end{itemdescr}

\rSec3[re.tokiter.deref]{Indirection}

\indexlibrarymember{regex_token_iterator}{operator*}%
\begin{itemdecl}
const value_type& operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*result}.
\end{itemdescr}

\indexlibrarymember{operator->}{regex_token_iterator}%
\begin{itemdecl}
const value_type* operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{result}.
\end{itemdescr}


\rSec3[re.tokiter.incr]{Increment}

\indexlibrarymember{regex_token_iterator}{operator++}%
\begin{itemdecl}
regex_token_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a local variable \tcode{prev} of
type \tcode{position_iterator}, initialized with the value
of \tcode{position}.

\pnum
If \tcode{*this} is a suffix iterator, sets \tcode{*this} to an
end-of-sequence iterator.

\pnum
Otherwise, if \tcode{N + 1 < subs.size()}, increments \tcode{N} and
sets \tcode{result} to the address of the current match.

\pnum
Otherwise, sets \tcode{N} to 0 and
increments \tcode{position}. If \tcode{position} is not an
end-of-sequence iterator the operator sets \tcode{result} to the
address of the current match.

\pnum
Otherwise, if any of the values stored in \tcode{subs} is equal to -1 and
\tcode{prev->suffix().length()} is not 0 the operator sets \tcode{*this} to a
suffix iterator that points to the range \range{prev->suffix().first}{prev->suffix().second}.

\pnum
Otherwise, sets \tcode{*this} to an end-of-sequence iterator.

\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrarymember{regex_token_iterator}{operator++}%
\begin{itemdecl}
regex_token_iterator& operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a copy \tcode{tmp} of \tcode{*this}, then calls \tcode{++(*this)}.

\pnum
\returns
\tcode{tmp}.
\end{itemdescr}

\rSec1[re.grammar]{Modified ECMAScript regular expression grammar}
\indextext{regular expression!grammar}%
\indextext{grammar!regular expression}%

\pnum
\indexlibraryglobal{basic_regex}%
\indextext{ECMAScript}%
The regular expression grammar recognized by
\tcode{basic_regex} objects constructed with the ECMAScript
flag is that specified by ECMA-262, except as specified below.

\pnum
\indexlibraryglobal{locale}%
\indextext{regular expression traits}%
Objects of type specialization of \tcode{basic_regex} store within themselves a
default-constructed instance of their \tcode{traits} template parameter, henceforth
referred to as \tcode{traits_inst}. This \tcode{traits_inst} object is used to support localization
of the regular expression; \tcode{basic_regex} member functions shall not call
any locale dependent C or \Cpp{} API, including the formatted string input functions.
Instead they shall call the appropriate traits member function to achieve the required effect.

\pnum
The following productions within the ECMAScript grammar are modified as follows:

\begin{ncrebnf}
\renontermdef{ClassAtom}\br
  \terminal{-}\br
  ClassAtomNoDash\br
  ClassAtomExClass\br
  ClassAtomCollatingElement\br
  ClassAtomEquivalence
\end{ncrebnf}

\begin{ncrebnf}
\renontermdef{IdentityEscape}\br
  SourceCharacter \textnormal{\textbf{but not}} \terminal{c}
\end{ncrebnf}

\pnum
The following new productions are then added:

\begin{ncrebnf}
\renontermdef{ClassAtomExClass}\br
  \terminal{[:} ClassName \terminal{:]}
\end{ncrebnf}

\begin{ncrebnf}
\renontermdef{ClassAtomCollatingElement}\br
  \terminal{[.} ClassName \terminal{.]}
\end{ncrebnf}

\begin{ncrebnf}
\renontermdef{ClassAtomEquivalence}\br
  \terminal{[=} ClassName \terminal{=]}
\end{ncrebnf}

\begin{ncrebnf}
\renontermdef{ClassName}\br
  ClassNameCharacter\br
  ClassNameCharacter ClassName
\end{ncrebnf}

\begin{ncrebnf}
\renontermdef{ClassNameCharacter}\br
  SourceCharacter \textnormal{\textbf{but not one of}} \terminal{.} \textnormal{\textbf{or}} \terminal{=} \textnormal{\textbf{or}} \terminal{:}
\end{ncrebnf}

\pnum
The productions \regrammarterm{ClassAtomExClass}, \regrammarterm{ClassAtomCollatingElement}
and \regrammarterm{ClassAtomEquivalence} provide functionality
equivalent to that of the same features in regular expressions in POSIX.

\pnum
The regular expression grammar may be modified by
any \tcode{regex_constants::syntax_option_type} flags specified when
constructing an object of type specialization of \tcode{basic_regex}
according to the rules in \tref{re.synopt}.

\pnum
A \regrammarterm{ClassName} production, when used in \regrammarterm{ClassAtomExClass},
is not valid if \tcode{traits_inst.lookup_classname} returns zero for
that name.  The names recognized as valid \regrammarterm{ClassName}s are
determined by the type of the traits class, but at least the following
names shall be recognized:
\tcode{alnum}, \tcode{alpha}, \tcode{blank}, \tcode{cntrl}, \tcode{digit},
\tcode{graph}, \tcode{lower}, \tcode{print}, \tcode{punct}, \tcode{space},
\tcode{upper}, \tcode{xdigit}, \tcode{d}, \tcode{s}, \tcode{w}.
In addition the following expressions shall be equivalent:

\begin{codeblock}
\d @\textnormal{and}@ [[:digit:]]

\D @\textnormal{and}@ [^[:digit:]]

\s @\textnormal{and}@ [[:space:]]

\S @\textnormal{and}@ [^[:space:]]

\w @\textnormal{and}@ [_[:alnum:]]

\W @\textnormal{and}@ [^_[:alnum:]]
\end{codeblock}

\pnum
\indexlibrary{regular expression traits!\idxcode{lookup_collatename}}%
\indexlibrary{\idxcode{lookup_collatename}!regular expression traits}%
A \regrammarterm{ClassName} production when used in
a \regrammarterm{ClassAtomCollatingElement} production is not valid
if the value returned by \tcode{traits_inst.lookup_collatename} for
that name is an empty string.

\pnum
\indexlibrary{regular expression traits!\idxcode{isctype}}%
\indexlibrary{\idxcode{isctype}!regular expression traits}%
\indexlibrary{regular expression traits!\idxcode{lookup_classname}}%
\indexlibrary{\idxcode{lookup_classname}!regular expression traits}%
The results from multiple calls
to \tcode{traits_inst.lookup_classname} can be bitwise \logop{OR}'ed
together and subsequently passed to \tcode{traits_inst.isctype}.

\pnum
A \regrammarterm{ClassName} production when used in
a \regrammarterm{ClassAtomEquivalence} production is not valid if the value
returned by \tcode{traits_inst.lookup_collatename} for that name is an
empty string or if the value returned by \tcode{traits_inst\brk.transform_primary}
for the result of the call to \tcode{traits_inst.lookup_collatename}
is an empty string.

\pnum
\indexlibraryglobal{regex_error}%
When the sequence of characters being transformed to a finite state
machine contains an invalid class name the translator shall throw an
exception object of type \tcode{regex_error}.

\pnum
\indexlibraryglobal{regex_error}%
If the \textit{CV} of a \textit{UnicodeEscapeSequence} is greater than the largest
value that can be held in an object of type \tcode{charT} the translator shall
throw an exception object of type \tcode{regex_error}.
\begin{note}
This means that values of the form \tcode{"uxxxx"} that do not fit in
a character are invalid.
\end{note}

\pnum
Where the regular expression grammar requires the conversion of a sequence of characters
to an integral value, this is accomplished by calling \tcode{traits_inst.value}.

\pnum
\indexlibraryglobal{match_flag_type}%
The behavior of the internal finite state machine representation when used to match a
sequence of characters is as described in ECMA-262.
The behavior is modified according
to any \tcode{match_flag_type} flags\iref{re.matchflag} specified when using the regular expression
object in one of the regular expression algorithms\iref{re.alg}. The behavior is also
localized by interaction with the traits class template parameter as follows:
\begin{itemize}
\item During matching of a regular expression finite state machine
against a sequence of characters, two characters \tcode{c}
and \tcode{d} are compared using the following rules:
\begin{itemize}
\item if \tcode{(flags() \& regex_constants::icase)} the two characters are equal
if \tcode{traits_inst.trans\-late_nocase(c) == traits_inst.translate_nocase(d)};
\item otherwise, if \tcode{flags() \& regex_constants::collate} the
two characters are equal if
\tcode{traits_inst\brk.translate(c) == traits_inst\brk.translate(d)};
\indexlibrarymember{syntax_option_type}{collate}%
\item otherwise, the two characters are equal if \tcode{c == d}.
\end{itemize}

\item During matching of a regular expression finite state machine
against a sequence of characters, comparison of a collating element
range \tcode{c1-c2} against a character \tcode{c} is
conducted as follows: if \tcode{flags() \& regex_constants::collate}
is \tcode{false} then the character \tcode{c} is matched if \tcode{c1
<= c \&\& c <= c2}, otherwise \tcode{c} is matched in
accordance with the following algorithm:

\begin{codeblock}
string_type str1 = string_type(1,
  flags() & icase ?
    traits_inst.translate_nocase(c1) : traits_inst.translate(c1));
string_type str2 = string_type(1,
  flags() & icase ?
    traits_inst.translate_nocase(c2) : traits_inst.translate(c2));
string_type str = string_type(1,
  flags() & icase ?
    traits_inst.translate_nocase(c) : traits_inst.translate(c));
return traits_inst.transform(str1.begin(), str1.end())
      <= traits_inst.transform(str.begin(), str.end())
  && traits_inst.transform(str.begin(), str.end())
      <= traits_inst.transform(str2.begin(), str2.end());
\end{codeblock}

\item During matching of a regular expression finite state machine against a sequence of
characters, testing whether a collating element is a member of a primary equivalence
class is conducted by first converting the collating element and the equivalence
class to sort keys using \tcode{traits::transform_primary}, and then comparing the sort
keys for equality.
\indextext{regular expression traits!\idxcode{transform_primary}}%
\indextext{transform_primary@\tcode{transform_primary}!regular expression traits}%

\item During matching of a regular expression finite state machine against a sequence
of characters, a character \tcode{c} is a member of a character class designated by an
iterator range \range{first}{last} if
\tcode{traits_inst.isctype(c, traits_inst.lookup_classname(first, last, flags() \& icase))} is \tcode{true}.
\end{itemize}
\xref ECMA-262 15.10
\indextext{regular expression|)}
