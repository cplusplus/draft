%!TEX root = std.tex
\normannex{depr}{Compatibility features}

\pnum
This Clause describes features of the \Cpp{} Standard that are specified for compatibility with
existing implementations.

\pnum
These are deprecated features, where
\term{deprecated}
is defined as:
Normative for the current edition of this International Standard,
but having been identified as a candidate for removal from future revisions.
An implementation may declare library names and entities described in this Clause with the
\tcode{deprecated} attribute\iref{dcl.attr.deprecated}.

\rSec1[depr.static_constexpr]{Redeclaration of \tcode{static constexpr} data members}

\pnum
For compatibility with prior \Cpp{} International Standards, a \tcode{constexpr}
static data member may be redundantly redeclared outside the class with no initializer.
This usage is deprecated.
\begin{example}
\begin{codeblock}
struct A {
  static constexpr int n = 5;  // definition (declaration in \CppXIV{})
};

constexpr int A::n;  // redundant declaration (definition in \CppXIV{})
\end{codeblock}
\end{example}

\rSec1[depr.impldec]{Implicit declaration of copy functions}

\pnum
The implicit definition of a copy constructor
as defaulted
is deprecated if the class has a
user-declared copy assignment operator or a user-declared destructor. The implicit
definition of a copy assignment operator
as defaulted is deprecated if the class has a user-declared
copy constructor or a user-declared destructor~(\ref{class.dtor}, \ref{class.copy}).
In a future revision of this International Standard, these implicit definitions
could become deleted\iref{dcl.fct.def}.

\rSec1[depr.except.spec]{Deprecated exception specifications}

\pnum
The \grammarterm{noexcept-specifier} \tcode{throw()} is deprecated.

\rSec1[depr.cpp.headers]{\Cpp{} standard library headers}

\pnum
For compatibility with prior \Cpp{} International Standards,
the \Cpp{} standard library provides headers
\tcode{<ccomplex>}\iref{depr.ccomplex.syn},
\tcode{<cstdalign>}\iref{depr.cstdalign.syn},
\tcode{<cstdbool>}\iref{depr.cstdbool.syn},
and \tcode{<ctgmath>}\iref{depr.ctgmath.syn}.
The use of these headers is deprecated.

\rSec2[depr.ccomplex.syn]{Header \tcode{<ccomplex>} synopsis}
\indexhdr{ccomplex}%

\begin{codeblock}
#include <complex>
\end{codeblock}

\pnum
The header \tcode{<ccomplex>}
behaves as if it simply includes the header
\tcode{<complex>}\iref{complex.syn}.

\rSec2[depr.cstdalign.syn]{Header \tcode{<cstdalign>} synopsis}

\indexlibrary{\idxcode{__alignas_is_defined}}%
\indexhdr{cstdalign}%
\begin{codeblock}
#define @\xname{alignas_is_defined}@ 1
\end{codeblock}

\pnum
\indexhdr{cstdalign}%
\indexhdr{stdalign.h}%
The contents of the header \tcode{<cstdalign>} are the same as the C
standard library header \tcode{<stdalign.h>}, with the following changes:
The header \tcode{<cstdalign>} and the header \tcode{<stdalign.h>} shall not
define a macro named \tcode{alignas}.

\xref ISO C 7.15

\rSec2[depr.cstdbool.syn]{Header \tcode{<cstdbool>} synopsis}

\indexhdr{cstdbool}%
\indexlibrary{\idxcode{__bool_true_false_are_defined}}%
\begin{codeblock}
#define @\xname{bool_true_false_are_defined}@ 1
\end{codeblock}

\pnum
\indexhdr{stdbool.h}%
The contents of the header \tcode{<cstdbool>} are the same as the C
standard library header \tcode{<stdbool.h>}, with the following changes:
The header \tcode{<cstdbool>} and the header \tcode{<stdbool.h>} shall not
define macros named \tcode{bool}, \tcode{true}, or \tcode{false}.

\xref ISO C 7.18

\rSec2[depr.ctgmath.syn]{Header \tcode{<ctgmath>} synopsis}

\indexhdr{ctgmath}%
\begin{codeblock}
#include <complex>
#include <cmath>
\end{codeblock}

\pnum
The header \tcode{<ctgmath>} simply includes the headers
\tcode{<complex>}\iref{complex.syn}
and \tcode{<cmath>}\iref{cmath.syn}.

\pnum
\begin{note} The overloads provided in C by type-generic macros are already
provided in \tcode{<complex>} and \tcode{<cmath>} by ``sufficient'' additional
overloads.\end{note}

\rSec1[depr.c.headers]{C standard library headers}

\pnum
For compatibility with the
\indextext{library!C standard}%
C standard library, the \Cpp{} standard library provides
the \defnx{C headers}{headers!C library} shown in Table~\ref{tab:future.c.headers}.

\begin{floattable}{C headers}{tab:future.c.headers}
{lllll}
\topline

\tcode{<assert.h>}			&
\tcode{<inttypes.h>}		&
\tcode{<signal.h>}			&
\tcode{<stdio.h>}			  &
\tcode{<wchar.h>}			  \\

\tcode{<complex.h>}			&
\tcode{<iso646.h>}			&
\tcode{<stdalign.h>}    &
\tcode{<stdlib.h>}			&
\tcode{<wctype.h>}			\\

\tcode{<ctype.h>}			  &
\tcode{<limits.h>}			&
\tcode{<stdarg.h>}			&
\tcode{<string.h>}			& \\

\tcode{<errno.h>}			  &
\tcode{<locale.h>}			&
\tcode{<stdbool.h>}			&
\tcode{<tgmath.h>}			& \\

\tcode{<fenv.h>}			  &
\tcode{<math.h>}			  &
\tcode{<stddef.h>}			&
\tcode{<time.h>}				& \\

\tcode{<float.h>}			  &
\tcode{<setjmp.h>}			&
\tcode{<stdint.h>}			&
\tcode{<uchar.h>}			  & \\

\end{floattable}

\pnum
The header \tcode{<complex.h>} behaves as if it simply includes the header \tcode{<ccomplex>}.
The header \tcode{<tgmath.h>} behaves as if it simply includes the header \tcode{<ctgmath>}.

\pnum
Every other C header, each of
which has a name of the form
\indextext{header!C}%
\tcode{name.h},
behaves as if each name placed in the standard library namespace by
the corresponding
\tcode{c\textit{name}}
header is placed within
the global namespace scope,
except for the functions described in \ref{sf.cmath},
the declaration of \tcode{std::byte}\iref{cstddef.syn}, and
the functions and function templates described in \ref{support.types.byteops}.
It is unspecified whether these names are first declared or defined within
namespace scope\iref{basic.scope.namespace} of the namespace
\tcode{std} and are then injected into the global namespace scope by
explicit \grammarterm{using-declaration}{s}\iref{namespace.udecl}.
\indextext{namespace}%

\pnum
\begin{example}
The header
\indexhdr{cstdlib}%
\indexhdr{stdlib.h}%
\tcode{<cstdlib>} assuredly
provides its declarations and definitions within the namespace
\tcode{std}. It may also provide these names within the
global namespace.
The header
\tcode{<stdlib.h>}
assuredly provides the same declarations and definitions within
the global namespace,
much as in the C Standard. It may also provide these names within
the namespace \tcode{std}.
\end{example}

\rSec1[depr.relops]{Relational operators}

\pnum
The header \tcode{<utility>}
\indexhdr{utility}%
has the following additions:

\begin{codeblock}
namespace std::rel_ops {
  template<class T> bool operator!=(const T&, const T&);
  template<class T> bool operator> (const T&, const T&);
  template<class T> bool operator<=(const T&, const T&);
  template<class T> bool operator>=(const T&, const T&);
}
\end{codeblock}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\indexlibrary{\idxcode{operator"!=}}%
\begin{itemdecl}
template<class T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{EqualityComparable} (Table~\ref{tab:equalitycomparable}).

\pnum
\returns
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}}%
\begin{itemdecl}
template<class T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}}%
\begin{itemdecl}
template<class T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}}%
\begin{itemdecl}
template<class T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (Table~\ref{tab:lessthancomparable}).

\pnum
\returns
\tcode{!(x < y)}.
\end{itemdescr}

\rSec1[depr.str.strstreams]{\tcode{char*} streams}

\pnum
The header
\indexhdr{strstream}%
\tcode{<strstream>}
defines three types that associate stream buffers with
character array objects and assist reading and writing such objects.

\rSec2[depr.strstreambuf]{Class \tcode{strstreambuf}}

\indexlibrary{\idxcode{strstreambuf}}%
\begin{codeblock}
namespace std {
  class strstreambuf : public basic_streambuf<char> {
  public:
    explicit strstreambuf(streamsize alsize_arg = 0);
    strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
    strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
    strstreambuf(const char* gnext_arg, streamsize n);

    strstreambuf(signed char* gnext_arg, streamsize n,
                 signed char* pbeg_arg = nullptr);
    strstreambuf(const signed char* gnext_arg, streamsize n);
    strstreambuf(unsigned char* gnext_arg, streamsize n,
                 unsigned char* pbeg_arg = nullptr);
    strstreambuf(const unsigned char* gnext_arg, streamsize n);

    virtual ~strstreambuf();

    void  freeze(bool freezefl = true);
    char* str();
    int   pcount();

  protected:
    int_type overflow (int_type c = EOF) override;
    int_type pbackfail(int_type c = EOF) override;
    int_type underflow() override;
    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    streambuf* setbuf(char* s, streamsize n) override;

  private:
    using strstate = T1;              // \expos
    static const strstate allocated;  // \expos
    static const strstate constant;   // \expos
    static const strstate dynamic;    // \expos
    static const strstate frozen;     // \expos
    strstate strmode;                 // \expos
    streamsize alsize;                // \expos
    void* (*palloc)(size_t);          // \expos
    void (*pfree)(void*);             // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstreambuf}
associates the input sequence, and possibly the output sequence, with an object of some
\textit{character}
array type, whose elements store arbitrary values.
The array object has several attributes.

\pnum
\begin{note}
For the sake of exposition, these are represented as elements of a bitmask type
(indicated here as \tcode{T1}) called \tcode{strstate}.
The elements are:
\begin{itemize}
\item
\tcode{allocated}, set when a dynamic array object has been
allocated, and hence should be freed by the destructor for the
\tcode{strstreambuf} object;
\item
\tcode{constant}, set when the array object has
\tcode{const} elements, so the output sequence cannot be written;
\item
\tcode{dynamic}, set when the array object is allocated
(or reallocated)
as necessary to hold a character sequence that can change in length;
\item
\tcode{frozen}, set when the program has requested that the
array object not be altered, reallocated, or freed.
\end{itemize}
\end{note}

\pnum
\begin{note}
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{strstate strmode}, the attributes of the array object
associated with the \tcode{strstreambuf} object;
\item
\tcode{int alsize}, the suggested minimum size for a
dynamic array object;
\item
\tcode{void* (*palloc)(size_t)}, points to the function
to call to allocate a dynamic array object;
\item
\tcode{void (*pfree)(void*)}, points to the function to
call to free a dynamic array object.
\end{itemize}
\end{note}

\pnum
Each object of class
\tcode{strstreambuf}
has a
\term{seekable area},
delimited by the pointers \tcode{seeklow} and \tcode{seekhigh}.
If \tcode{gnext} is a null pointer, the seekable area is undefined.
Otherwise, \tcode{seeklow} equals \tcode{gbeg} and
\tcode{seekhigh} is either \tcode{pend},
if \tcode{pend} is not a null pointer, or \tcode{gend}.

\rSec3[depr.strstreambuf.cons]{\tcode{strstreambuf} constructors}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
explicit strstreambuf(streamsize alsize_arg = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf.effects}.
\end{itemdescr}

\begin{libtab2}{\tcode{strstreambuf(streamsize)} effects}{tab:future.strstreambuf.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}		\\
\tcode{alsize}	&	\tcode{alsize_arg}	\\
\tcode{palloc}	&	a null pointer		\\
\tcode{pfree}	&	a null pointer		\\
\end{libtab2}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf1.effects}.

\begin{libtab2}{\tcode{strstreambuf(void* (*)(size_t), void (*)(void*))} effects}
{tab:future.strstreambuf1.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}			\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	\tcode{palloc_arg}		\\
\tcode{pfree}	&	\tcode{pfree_arg}		\\
\end{libtab2}
\end{itemdescr}

\indextext{unspecified}%
\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
strstreambuf(signed char* gnext_arg, streamsize n,
             signed char* pbeg_arg = nullptr);
strstreambuf(unsigned char* gnext_arg, streamsize n,
             unsigned char* pbeg_arg = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf2.effects}.

\begin{libtab2}{\tcode{strstreambuf(charT*, streamsize, charT*)} effects}
{tab:future.strstreambuf2.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	0						\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	a null pointer			\\
\tcode{pfree}	&	a null pointer			\\
\end{libtab2}

\pnum
\tcode{gnext_arg} shall point to the first element of an array
object whose number of elements \tcode{N} is determined as follows:
\begin{itemize}
\item
If
\tcode{n > 0},
\tcode{N} is \tcode{n}.
\item
If
\tcode{n == 0},
\tcode{N} is
\tcode{std::strlen(gnext_arg)}.
\indexlibrary{\idxcode{strlen}}%
\item
If
\tcode{n < 0},
\tcode{N} is
\tcode{INT_MAX}.\footnote{The function signature
\indexlibrary{\idxcode{strlen}}%
\tcode{strlen(const char*)}
is declared in
\indexhdr{cstring}%
\tcode{<cstring>}\iref{cstring.syn}.
The macro
\tcode{INT_MAX}
is defined in
\indexhdr{climits}%
\tcode{<climits>}\iref{climits.syn}.}
\end{itemize}

\pnum
If \tcode{pbeg_arg} is a null pointer, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, gnext_arg + N);
\end{codeblock}

\pnum
Otherwise, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, pbeg_arg);
setp(pbeg_arg,  pbeg_arg + N);
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(const char* gnext_arg, streamsize n);
strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(const unsigned char* gnext_arg, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves the same as
\tcode{strstreambuf((char*)gnext_arg,n)},
except that the constructor also sets \tcode{constant} in \tcode{strmode}.
\end{itemdescr}

\indexlibrary{\idxcode{strstreambuf}!destructor}%
\begin{itemdecl}
virtual ~strstreambuf();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstreambuf}.
The function frees the dynamically allocated array object only if
\tcode{(strmode \& allocated) != 0}
and
\tcode{(strmode \& frozen) == 0}.~(\ref{depr.strstreambuf.virtuals} describes how a dynamically allocated array object is freed.)
\end{itemdescr}

\rSec3[depr.strstreambuf.members]{Member functions}

\indexlibrarymember{freeze}{strstreambuf}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{strmode \& dynamic} is nonzero, alters the
freeze status of the dynamic array object as follows:
\begin{itemize}
\item
If \tcode{freezefl} is
\tcode{true},
the function sets \tcode{frozen} in \tcode{strmode}.
\item
Otherwise, it clears \tcode{frozen} in \tcode{strmode}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{str}{strstreambuf}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{freeze()},
then returns the beginning pointer for the input sequence, \tcode{gbeg}.

\pnum
\remarks
The return value can be a null pointer.
\end{itemdescr}

\indexlibrarymember{pcount}{strstreambuf}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the next pointer for the output sequence, \tcode{pnext}, is
a null pointer, returns zero.
Otherwise, returns the current
effective length of the array object as the next pointer minus the beginning
pointer for the output sequence, \tcode{pnext - pbeg}.
\end{itemdescr}

\rSec3[depr.strstreambuf.virtuals]{\tcode{strstreambuf} overridden virtual functions}

\indexlibrarymember{overflow}{strstreambuf}%
\begin{itemdecl}
int_type overflow(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Appends the character designated by \tcode{c} to the output
sequence, if possible, in one of two ways:
\begin{itemize}
\item
If
\tcode{c != EOF}
and if either the output sequence has a write position available or
the function makes a write position available
(as described below),
assigns \tcode{c} to
\tcode{*pnext++}.

Returns
\tcode{(unsigned char)c}.

\item
If
\tcode{c == EOF},
there is no character to append.

Returns a value other than \tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of write positions available as a
result of any call.

\pnum
To make a write position available, the function reallocates
(or initially allocates)
an array object with a sufficient number of elements
\tcode{n} to hold the current array object (if any),
plus at least one additional write position.
How many additional write positions are made
available is otherwise unspecified.%
\indextext{unspecified}%
\footnote{An implementation should consider \tcode{alsize} in making this
decision.}
If \tcode{palloc} is not a null pointer, the function calls
\tcode{(*palloc)(n)}
to allocate the new dynamic array object.
Otherwise, it evaluates the expression
\tcode{new charT[n]}.
In either case, if the allocation fails, the function returns
\tcode{EOF}.
Otherwise, it sets \tcode{allocated} in \tcode{strmode}.

\pnum
To free a previously existing dynamic array object whose first
element address is \tcode{p}:
If \tcode{pfree} is not a null pointer,
the function calls
\tcode{(*pfree)(p)}.
Otherwise, it evaluates the expression \tcode{delete[]p}.

\pnum
If
\tcode{(strmode \& dynamic) == 0},
or if
\tcode{(strmode \& frozen) != 0},
the function cannot extend the array (reallocate it with greater length) to make a write position available.
\end{itemdescr}

\indexlibrarymember{pbackfail}{strstreambuf}%
\begin{itemdecl}
int_type pbackfail(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
Puts back the character designated by \tcode{c} to the input
sequence, if possible, in one of three ways:
\begin{itemize}
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{(char)c == gnext[-1]},
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns \tcode{c}.
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{strmode \& constant} is zero,
assigns \tcode{c} to
\tcode{*\dcr{}gnext}.

Returns
\tcode{c}.
\item
If
\tcode{c == EOF}
and if the input sequence has a putback position available,
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns a value other than
\tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.
\indextext{unspecified}%
The function can alter the number of putback
positions available as a result of any call.
\end{itemdescr}

\indexlibrarymember{underflow}{strstreambuf}%
\begin{itemdecl}
int_type underflow() override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads a character from the
\term{input sequence},
if possible, without moving the stream position past it, as follows:
\begin{itemize}
\item
If the input sequence has a read position available, the function
signals success by returning
\tcode{(unsigned char)\brk*gnext}.
\item
Otherwise, if
the current write next pointer \tcode{pnext} is not a null pointer and
is greater than the current read end pointer \tcode{gend},
makes a
\term{read position}
available by
assigning to \tcode{gend} a value greater than \tcode{gnext} and
no greater than \tcode{pnext}.

Returns \tcode{(unsigned char)*gnext}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of read positions available as a
result of any call.
\end{itemdescr}

\indexlibrarymember{seekoff}{strstreambuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, seekdir way, openmode which = in | out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, as indicated in Table~\ref{tab:future.seekoff.positioning}.

\begin{libtab2}{\tcode{seekoff} positioning}{tab:future.seekoff.positioning}
{p{2.5in}l}{Conditions}{Result}
\tcode{(which \& ios::in) != 0}	&
 positions the input sequence	\\ \rowsep
\tcode{(which \& ios::out) != 0}	&
 positions the output sequence	\\ \rowsep
\tcode{(which \& (ios::in |}\br
\tcode{ios::out)) == (ios::in |}\br
\tcode{ios::out))} and\br
\tcode{way ==} either\br
\tcode{ios::beg} or\br
\tcode{ios::end}			&
 positions both the input and the output sequences	\\ \rowsep
Otherwise	&
 the positioning operation fails.	\\
\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} as indicated in
Table~\ref{tab:future.newoff.values}.

\begin{libtab2}{\tcode{newoff} values}{tab:future.newoff.values}
{p{2.0in}p{2.0in}}{Condition}{\tcode{newoff} Value}
\tcode{way == ios::beg}	&
 0	\\ \rowsep
\tcode{way == ios::cur}	&
 the next pointer minus the beginning pointer (\tcode{xnext - xbeg}).	\\ \rowsep
\tcode{way == ios::end}	&
 \tcode{seekhigh} minus the beginning pointer (\tcode{seekhigh - xbeg}).	\\
\end{libtab2}

\pnum
If \tcode{(newoff + off) < (seeklow - xbeg)}
or \tcode{(seekhigh - xbeg) < (newoff + off)},
the positioning operation fails.
Otherwise, the function assigns
\tcode{xbeg + newoff + off}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset
\tcode{newoff} (of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{seekpos}{strstreambuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp, ios_base::openmode which
                  = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, to correspond to the
stream position stored in \tcode{sp}
(as described below).
\begin{itemize}
\item
If
\tcode{(which \& ios::in) != 0},
positions the input sequence.
\item
If
\tcode{(which \& ios::out) != 0},
positions the output sequence.
\item
If the function positions neither sequence, the positioning operation fails.
\end{itemize}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} from
\tcode{sp.offset()}:
\begin{itemize}
\item
If \tcode{newoff} is an invalid stream position,
has a negative value, or
has a value greater than (\tcode{seekhigh - seeklow}),
the positioning operation fails
\item
Otherwise, the function
adds \tcode{newoff} to the beginning pointer \tcode{xbeg} and
stores the result in the next pointer \tcode{xnext}.
\end{itemize}

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset \tcode{newoff}
(of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{setbuf}{strstreambuf}%
\begin{itemdecl}
streambuf<char>* setbuf(char* s, streamsize n) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Implementation defined, except that
\tcode{setbuf(0, 0)}
has no effect.%
\end{itemdescr}

\rSec2[depr.istrstream]{Class \tcode{istrstream}}

\indexlibrary{\idxcode{istrstream}}%
\begin{codeblock}
namespace std {
  class istrstream : public basic_istream<char> {
  public:
    explicit istrstream(const char* s);
    explicit istrstream(char* s);
    istrstream(const char* s, streamsize n);
    istrstream(char* s, streamsize n);
    virtual ~istrstream();

    strstreambuf* rdbuf() const;
    char* str();
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{istrstream}
supports the reading of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.istrstream.cons]{\tcode{istrstream} constructors}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
explicit istrstream(const char* s);
explicit istrstream(char* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,0)}.
\tcode{s} shall designate the first element of an \ntbs{}.%
\indextext{NTBS}
\end{itemdescr}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
istrstream(const char* s, streamsize n);
istrstream(char* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,n)}.
\tcode{s} shall designate the first element of an array whose length is
\tcode{n} elements, and \tcode{n} shall be greater than zero.
\end{itemdescr}

\rSec3[depr.istrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{istrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<strstreambuf*>(\&sb)}.
\end{itemdescr}

\indexlibrarymember{str}{istrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\rSec2[depr.ostrstream]{Class \tcode{ostrstream}}

\indexlibrary{\idxcode{ostrstream}}%
\begin{codeblock}
namespace std {
  class ostrstream : public basic_ostream<char> {
  public:
    ostrstream();
    ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
    virtual ~ostrstream();

    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    char* str();
    int pcount() const;
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{ostrstream}
supports the writing of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.ostrstream.cons]{\tcode{ostrstream} constructors}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf()}.
\end{itemdescr}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)},
and initializing \tcode{sb} with one of two constructors:

\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.

The constructor is
\tcode{strstreambuf(s, n, s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements that
contains an \ntbs{} whose first element is designated by \tcode{s}.
\indextext{NTBS}%
The constructor is
\tcode{strstreambuf(s, n, s + std::strlen(s))}.\footnote{The function signature
\indexlibrary{\idxcode{strlen}}%
\tcode{strlen(const char*)}
is declared in
\indexhdr{cstring}%
\tcode{<cstring>}\iref{cstring.syn}.}
\end{itemize}
\end{itemdescr}

\rSec3[depr.ostrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{ostrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{(strstreambuf*)\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{ostrstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{ostrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{ostrstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec2[depr.strstream]{Class \tcode{strstream}}

\indexlibrary{\idxcode{strstream}}%
\begin{codeblock}
namespace std {
  class strstream
    : public basic_iostream<char> {
  public:
    // types
    using char_type = char;
    using int_type  = char_traits<char>::int_type;
    using pos_type  = char_traits<char>::pos_type;
    using off_type  = char_traits<char>::off_type;

    // constructors/destructor
    strstream();
    strstream(char* s, int n,
              ios_base::openmode mode = ios_base::in|ios_base::out);
    virtual ~strstream();

    // members
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    int pcount() const;
    char* str();

  private:
  strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstream}
supports reading and writing from objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.strstream.cons]{\tcode{strstream} constructors}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}.
\end{itemdescr}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream(char* s, int n,
          ios_base::openmode mode = ios_base::in|ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}
and initializing \tcode{sb} with one of the two constructors:
\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.
The constructor is
\tcode{strstreambuf(s,n,s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall
designate the first element of an array of \tcode{n} elements that contains
an \ntbs{} whose first element is designated by \tcode{s}.
The constructor is
\tcode{strstreambuf(s,n,s + std::strlen(s))}.
\indexlibrary{\idxcode{strstream}!destructor}%
\end{itemize}
\end{itemdescr}

\rSec3[depr.strstream.dest]{\tcode{strstream} destructor}

\indexlibrary{\idxcode{strstream}!destructor}%
\begin{itemdecl}
virtual ~strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstream}.
\end{itemdescr}

\rSec3[depr.strstream.oper]{\tcode{strstream} operations}

\indexlibrarymember{rdbuf}{strstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{strstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{strstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{strstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec1[depr.uncaught]{\tcode{uncaught_exception}}

\pnum
The header
\indexhdr{exception}%
\tcode{<exception>} has the following addition:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  bool uncaught_exception() noexcept;
}
\end{codeblock}

\indexlibrary{\idxcode{uncaught_exception}}%
\begin{itemdecl}
bool uncaught_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{uncaught_exceptions() > 0}.
\end{itemdescr}

\rSec1[depr.func.adaptor.binding]{Old adaptable function bindings}

\rSec2[depr.weak.result_type]{Weak result types}

\pnum
A call wrapper\iref{func.def} may have a \defn{weak result type}.
If it does, the type of its member type \tcode{result_type}
is based on the type \tcode{T} of the wrapper's target object:
\begin{itemize}
\item if \tcode{T} is a pointer to function type,
\tcode{result_type} shall be a synonym for the return type of \tcode{T};
\item if \tcode{T} is a pointer to member function,
\tcode{result_type} shall be a synonym for the return type of \tcode{T};
\item if \tcode{T} is a class type
and the \grammarterm{qualified-id} \tcode{T::result_type} is valid and denotes a type\iref{temp.deduct},
then \tcode{result_type} shall be a synonym for \tcode{T::result_type};
\item otherwise \tcode{result_type} shall not be defined.
\end{itemize}

\rSec2[depr.func.adaptor.typedefs]{Typedefs to support function binders}

\pnum
To enable old function adaptors to manipulate function objects
that take one or two arguments,
many of the function objects in this document
correspondingly provide \grammarterm{typedef-name}{s}
\tcode{argument_type} and \tcode{result_type}
for function objects that take one argument and
\tcode{first_argument_type}, \tcode{second_argument_type}, and \tcode{result_type}
for function objects that take two arguments.

\pnum
The following member names are defined in addition to names specified in \ref{function.objects}:

\indexlibrarymember{result_type}{owner_less}%
\indexlibrarymember{first_argument_type}{owner_less}%
\indexlibrarymember{second_argument_type}{owner_less}%
\indexlibrarymember{result_type}{owner_less}%
\indexlibrarymember{first_argument_type}{owner_less}%
\indexlibrarymember{second_argument_type}{owner_less}%
\indexlibrarymember{result_type}{plus}%
\indexlibrarymember{first_argument_type}{plus}%
\indexlibrarymember{second_argument_type}{plus}%
\indexlibrarymember{result_type}{minus}%
\indexlibrarymember{first_argument_type}{minus}%
\indexlibrarymember{second_argument_type}{minus}%
\indexlibrarymember{result_type}{multiplies}%
\indexlibrarymember{first_argument_type}{multiplies}%
\indexlibrarymember{second_argument_type}{multiplies}%
\indexlibrarymember{result_type}{divides}%
\indexlibrarymember{first_argument_type}{divides}%
\indexlibrarymember{second_argument_type}{divides}%
\indexlibrarymember{result_type}{modulus}%
\indexlibrarymember{first_argument_type}{modulus}%
\indexlibrarymember{second_argument_type}{modulus}%
\indexlibrarymember{result_type}{negate}%
\indexlibrarymember{argument_type}{negate}%
\indexlibrarymember{result_type}{equal_to}%
\indexlibrarymember{first_argument_type}{equal_to}%
\indexlibrarymember{second_argument_type}{equal_to}%
\indexlibrarymember{result_type}{not_equal_to}%
\indexlibrarymember{first_argument_type}{not_equal_to}%
\indexlibrarymember{second_argument_type}{not_equal_to}%
\indexlibrarymember{result_type}{greater}%
\indexlibrarymember{first_argument_type}{greater}%
\indexlibrarymember{second_argument_type}{greater}%
\indexlibrarymember{result_type}{less}%
\indexlibrarymember{first_argument_type}{less}%
\indexlibrarymember{second_argument_type}{less}%
\indexlibrarymember{result_type}{greater_equal}%
\indexlibrarymember{first_argument_type}{greater_equal}%
\indexlibrarymember{second_argument_type}{greater_equal}%
\indexlibrarymember{result_type}{less_equal}%
\indexlibrarymember{first_argument_type}{less_equal}%
\indexlibrarymember{second_argument_type}{less_equal}%
\indexlibrarymember{result_type}{logical_and}%
\indexlibrarymember{first_argument_type}{logical_and}%
\indexlibrarymember{second_argument_type}{logical_and}%
\indexlibrarymember{result_type}{logical_or}%
\indexlibrarymember{first_argument_type}{logical_or}%
\indexlibrarymember{second_argument_type}{logical_or}%
\indexlibrarymember{result_type}{logical_not}%
\indexlibrarymember{argument_type}{logical_not}%
\indexlibrarymember{result_type}{bit_and}%
\indexlibrarymember{first_argument_type}{bit_and}%
\indexlibrarymember{second_argument_type}{bit_and}%
\indexlibrarymember{result_type}{bit_or}%
\indexlibrarymember{first_argument_type}{bit_or}%
\indexlibrarymember{second_argument_type}{bit_or}%
\indexlibrarymember{result_type}{bit_xor}%
\indexlibrarymember{first_argument_type}{bit_xor}%
\indexlibrarymember{second_argument_type}{bit_xor}%
\indexlibrarymember{result_type}{bit_not}%
\indexlibrarymember{argument_type}{bit_not}%
\indexlibrarymember{result_type}{function}%
\indexlibrarymember{argument_type}{function}%
\indexlibrarymember{first_argument_type}{function}%
\indexlibrarymember{second_argument_type}{function}%
\begin{codeblock}
namespace std {
  template<class T> struct owner_less<shared_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = shared_ptr<T>;
    using second_argument_type = shared_ptr<T>;
  };

  template<class T> struct owner_less<weak_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = weak_ptr<T>;
    using second_argument_type = weak_ptr<T>;
  };

  template<class T> class reference_wrapper {
  public:
    using result_type          = @\seebelow@; // not always defined
    using argument_type        = @\seebelow@; // not always defined
    using first_argument_type  = @\seebelow@; // not always defined
    using second_argument_type = @\seebelow@; // not always defined
  };

  template<class T> struct plus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct minus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct multiplies {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct divides {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct modulus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct negate {
    using argument_type = T;
    using result_type   = T;
  };

  template<class T> struct equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct not_equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct greater {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct less {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct greater_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct less_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_not {
    using argument_type = T;
    using result_type   = bool;
  };

  template<class T> struct bit_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_xor {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_not {
    using argument_type = T;
    using result_type   = T;
  };

  template<class R, class T1> class function<R(T1)> {
  public:
    using argument_type = T1;
  };

  template<class R, class T1, class T2> class function<R(T1, T2)> {
  public:
    using first_argument_type  = T1;
    using second_argument_type = T2;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{reference_wrapper}!weak result type}%
\pnum
\tcode{reference_wrapper<T>} has a weak result type\iref{depr.weak.result_type}.
If \tcode{T} is a function type,
\tcode{result_type} shall be a synonym for the return type of \tcode{T}.

\indexlibrarymember{argument_type}{reference_wrapper}%
\pnum
The template specialization \tcode{reference_wrapper<T>}
shall define a nested type named \tcode{argument_type}
as a synonym for \tcode{T1}
only if the type \tcode{T} is any of the following:
\begin{itemize}
\item a function type or a pointer to function type taking one argument of type \tcode{T1}
\item a pointer to member function \tcode{R T0::f()} \cv{} (where \cv{} represents the member function's cv-qualifiers); the type \tcode{T1} is \cv{}~\tcode{T0*}
\item a class type where the \grammarterm{qualified-id} \tcode{T::argument_type}
is valid and denotes a type\iref{temp.deduct};
the type \tcode{T1} is \tcode{T::argument_type}.
\end{itemize}

\indexlibrarymember{first_argument_type}{reference_wrapper}%
\indexlibrarymember{second_argument_type}{reference_wrapper}%
\pnum
The template instantiation \tcode{reference_wrapper<T>}
shall define two nested types
named \tcode{first_argument_type} and \tcode{second_argument_type}
as synonyms for \tcode{T1} and \tcode{T2}, respectively,
only if the type \tcode{T} is any of the following:
\begin{itemize}
\item a function type or a pointer to function type taking two arguments of types \tcode{T1} and \tcode{T2}
\item a pointer to member function \tcode{R T0::f(T2)} \cv{} (where \cv{} represents the member function's cv-qualifiers); the type \tcode{T1} is \cv{}~\tcode{T0*}
\item a class type where the \grammarterm{qualified-id}{s}
\tcode{T::first_argument_type} and \tcode{T::second_argument_type}
are both valid and both denote types\iref{temp.deduct};
the type \tcode{T1} is \tcode{T::first_argument_type} and
the type \tcode{T2} is \tcode{T::second_argument_type}.
\end{itemize}

\indexlibrarymember{result_type}{hash}%
\indexlibrarymember{argument_type}{hash}%
\pnum
All enabled specializations \tcode{hash<Key>} of \tcode{hash}\iref{unord.hash}
provide two nested types, \tcode{result_type} and \tcode{argument_type},
which shall be synonyms for \tcode{size_t} and \tcode{Key}, respectively.

\indexlibrary{\idxcode{bind}!weak result type}%
\pnum
The forwarding call wrapper \tcode{g}
returned by a call to \tcode{bind(f, bound_args...)}\iref{func.bind.bind}
shall have a weak result type\iref{depr.weak.result_type}.

\pnum
The forwarding call wrapper \tcode{g}
returned by a call to \tcode{bind<R>(f, bound_args...)}\iref{func.bind.bind}
shall have a nested type \tcode{result_type} defined as a synonym for \tcode{R}.

\indexlibrarymember{result_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall have a nested type \tcode{result_type}
that is a synonym for
the return type of \tcode{pm}
when \tcode{pm} is a pointer to member function.

\indexlibrarymember{result_type}{mem_fn}%
\indexlibrarymember{argument_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall define two nested types
named \tcode{argument_type} and \tcode{result_type}
as synonyms for \cv{}~\tcode{T*} and \tcode{Ret}, respectively,
when \tcode{pm} is a pointer to member function
with cv-qualifier \cv{}
and taking no arguments,
where \tcode{Ret} is \tcode{pm}{'s} return type.

\indexlibrarymember{result_type}{mem_fn}%
\indexlibrarymember{first_argument_type}{mem_fn}%
\indexlibrarymember{second_argument_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall define three nested types
named \tcode{first_argument_type}, \tcode{second_argument_type}, and \tcode{result_type}
as synonyms for \cv{}~\tcode{T*}, \tcode{T1}, and \tcode{Ret}, respectively,
when \tcode{pm} is a pointer to member function
with cv-qualifier \cv{}
and taking one argument of type \tcode{T1},
where \tcode{Ret} is \tcode{pm}{'s} return type.

\pnum
The following member names are defined in addition to names specified in \ref{containers}:

\indexlibrarymember{result_type}{map::value_compare}%
\indexlibrarymember{first_argument_type}{map::value_compare}%
\indexlibrarymember{second_argument_type}{map::value_compare}%
\indexlibrarymember{result_type}{multimap::value_compare}%
\indexlibrarymember{first_argument_type}{multimap::value_compare}%
\indexlibrarymember{second_argument_type}{multimap::value_compare}%
\begin{codeblock}
namespace std {
  template<class Key, class T, class Compare, class Allocator>
  class map<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };

  template<class Key, class T, class Compare, class Allocator>
  class multimap<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };
}
\end{codeblock}

\rSec2[depr.negators]{Negators}

\pnum
The header
\indexhdr{functional}%
\tcode{<functional>} has the following additions:

\indexlibrary{\idxcode{unary_negate}}%
\indexlibrary{\idxcode{not1}}%
\indexlibrary{\idxcode{binary_negate}}%
\indexlibrary{\idxcode{not2}}%
\begin{codeblock}
namespace std {
  template<class Predicate> class unary_negate;
  template<class Predicate>
    constexpr unary_negate<Predicate> not1(const Predicate&);
  template<class Predicate> class binary_negate;
  template<class Predicate>
    constexpr binary_negate<Predicate> not2(const Predicate&);
}
\end{codeblock}

\pnum
Negators \tcode{not1} and \tcode{not2}
take a unary and a binary predicate, respectively,
and return their logical negations\iref{expr.unary.op}.

\indexlibrary{\idxcode{unary_negate}}%
\indexlibrarymember{argument_type}{unary_negate}%
\indexlibrarymember{result_type}{unary_negate}%
\begin{codeblock}
template<class Predicate>
class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::argument_type& x) const;
  using argument_type = typename Predicate::argument_type;
  using result_type   = bool;
};
\end{codeblock}

\indexlibrarymember{operator()}{unary_negate}%
\begin{itemdecl}
constexpr bool operator()(const typename Predicate::argument_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!pred(x)}.
\end{itemdescr}

\indexlibrary{\idxcode{not1}}%
\begin{itemdecl}
template<class Predicate>
   constexpr unary_negate<Predicate> not1(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{unary_negate<Predicate>(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{binary_negate}}%
\indexlibrarymember{first_argument_type}{binary_negate}%
\indexlibrarymember{second_argument_type}{binary_negate}%
\indexlibrarymember{result_type}{binary_negate}%
\begin{codeblock}
template<class Predicate>
class binary_negate {
public:
  constexpr explicit binary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::first_argument_type& x,
                            const typename Predicate::second_argument_type& y) const;
  using first_argument_type  = typename Predicate::first_argument_type;
  using second_argument_type = typename Predicate::second_argument_type;
  using result_type          = bool;

};
\end{codeblock}

\indexlibrarymember{operator()}{binary_negate}%
\begin{itemdecl}
constexpr bool operator()(const typename Predicate::first_argument_type& x,
                          const typename Predicate::second_argument_type& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!pred(x,y)}.
\end{itemdescr}

\indexlibrary{\idxcode{not2}}%
\begin{itemdecl}
template<class Predicate>
  constexpr binary_negate<Predicate> not2(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{binary_negate<Predicate>(pred)}.
\end{itemdescr}

\rSec1[depr.default.allocator]{The default allocator}

\pnum
The following members and explicit class template specialization are defined in
addition to those specified in \ref{default.allocator}:

\indexlibrary{\idxcode{allocator}}%
\begin{codeblock}
namespace std {
  // specialization for \tcode{void}
  template<> class allocator<void> {
  public:
    using value_type    = void;
    using pointer       = void*;
    using const_pointer = const void*;
    // reference-to-\tcode{void} members are impossible.

    template<class U> struct rebind { using other = allocator<U>; };
  };

  template<class T> class allocator {
   public:
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&;
    using const_reference = const T&;
    template<class U> struct rebind { using other = allocator<U>; };

    T* address(T& x) const noexcept;
    const T* address(const T& x) const noexcept;

    T* allocate(size_t n, const void* hint);

    template<class U, class... Args>
      void construct(U* p, Args&&... args);
    template<class U>
      void destroy(U* p);

    size_t max_size() const noexcept;
  };
}
\end{codeblock}

\indexlibrarymember{address}{allocator}%
\begin{itemdecl}
T* address(T& x) const noexcept;
const T* address(const T& x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{addressof(x)}.
\end{itemdescr}

\indexlibrarymember{allocate}{allocator}%
\begin{itemdecl}
T* allocate(size_t n, const void* hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the initial element of an array of storage of size \tcode{n}
\tcode{* sizeof(T)}, aligned appropriately for objects of type \tcode{T}.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported\iref{basic.align}.

\pnum
\remarks
The storage is obtained by calling \tcode{::operator new(std::size_t)}\iref{new.delete},
but it is unspecified when or how often this function is called.

\pnum
\throws
\tcode{bad_alloc} if the storage cannot be obtained.
\end{itemdescr}

\indexlibrarymember{construct}{allocator}%
\begin{itemdecl}
template<class U, class... Args>
  void construct(U* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by: \tcode{::new((void *)p) U(std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibrarymember{destroy}{allocator}%
\begin{itemdecl}
template<class U>
  void destroy(U* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{p->\~{}U()}.
\end{itemdescr}

\indexlibrarymember{max_size}{allocator}%
\begin{itemdecl}
size_t max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The largest value \textit{N} for which the call \tcode{allocate(N, 0)}
might succeed.
\end{itemdescr}

\rSec1[depr.storage.iterator]{Raw storage iterator}

\pnum
The header
\indexhdr{memory}%
\tcode{<memory>} has the following addition:

\indexlibrary{\idxcode{raw_storage_iterator}}%
\begin{codeblock}
namespace std {
  template<class OutputIterator, class T>
  class raw_storage_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator& operator*();
    raw_storage_iterator& operator=(const T& element);
    raw_storage_iterator& operator=(T&& element);
    raw_storage_iterator& operator++();
    raw_storage_iterator  operator++(int);
    OutputIterator base() const;
  };
}
\end{codeblock}

\pnum
\tcode{raw_storage_iterator} is provided to enable algorithms to store their
results into uninitialized memory. The template parameter
\tcode{OutputIterator} is required to have its \tcode{operator*} return an
object for which \tcode{operator\&} is defined and returns a pointer to
\tcode{T}, and is also required to satisfy the requirements of an output
iterator\iref{output.iterators}.

\indexlibrary{\idxcode{raw_storage_iterator}!constructor}%
\begin{itemdecl}
explicit raw_storage_iterator(OutputIterator x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the iterator to point to the same value to which \tcode{x} points.
\end{itemdescr}

\indexlibrarymember{operator*}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrarymember{operator=}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator=(const T& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{T} shall be \tcode{CopyConstructible}.

\pnum
\effects
Constructs a value from \tcode{element} at the location to which the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrarymember{operator=}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator=(T&& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{T} shall be \tcode{MoveConstructible}.

\pnum
\effects
Constructs a value from \tcode{std::move(element)} at the location to which
the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrarymember{operator++}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Pre-increment:  advances the iterator and returns a reference to the updated iterator.
\end{itemdescr}

\indexlibrarymember{operator++}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Post-increment:  advances the iterator and returns the old value of the iterator.
\end{itemdescr}

\indexlibrarymember{base}{raw_storage_iterator}%
\begin{itemdecl}
OutputIterator base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator of type \tcode{OutputIterator} that points to the same value as
\tcode{*this} points to.
\end{itemdescr}

\rSec1[depr.temporary.buffer]{Temporary buffers}

\pnum
The header
\indexhdr{memory}%
\tcode{<memory>} has the following additions:

\begin{codeblock}
namespace std {
  template<class T>
    pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
  template<class T>
    void return_temporary_buffer(T* p);
}
\end{codeblock}

\indexlibrary{\idxcode{get_temporary_buffer}}%
\begin{itemdecl}
template<class T>
  pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Obtains a pointer to uninitialized, contiguous storage for $N$ adjacent
objects of type \tcode{T}, for some non-negative number $N$.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported\iref{basic.align}.

\pnum
\remarks
Calling \tcode{get_temporary_buffer} with a positive number \tcode{n} is
a non-binding request to return storage for \tcode{n} objects of type \tcode{T}.
In this case, an implementation is permitted to return instead storage for
a non-negative number $N$ of such objects,
where \tcode{$N$ != n} (including \tcode{$N$ == 0}).
\begin{note} The request is non-binding to allow latitude for
implementation-specific optimizations of its memory management. \end{note}

\pnum
\returns
If \tcode{n <= 0} or if no storage could be obtained,
returns a pair \tcode{P} such that
\tcode{P.first} is a null pointer value and \tcode{P.second == 0};
otherwise returns a pair \tcode{P} such that
\tcode{P.first} refers to the address of the uninitialized storage and
\tcode{P.second} refers to its capacity $N$ (in the units of \tcode{sizeof(T)}).
\end{itemdescr}

\indexlibrary{\idxcode{return_temporary_buffer}}%
\begin{itemdecl}
template<class T> void return_temporary_buffer(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Deallocates the storage referenced by \tcode{p}.

\pnum
\requires
\tcode{p} shall be a pointer value returned by an earlier call to
\tcode{get_temporary_buffer} that has not been invalidated by
an intervening call to \tcode{return_temporary_buffer(T*)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec1[depr.meta.types]{Deprecated type traits}

\pnum
The header
\indexhdr{type_traits}%
\tcode{<type_traits>} has the following addition:

\indexlibrary{\idxcode{is_literal_type}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_literal_type;
  template<class T> constexpr bool is_literal_type_v = is_literal_type<T>::value;

  template<class> struct result_of;    // not defined
  template<class Fn, class... ArgTypes> struct result_of<Fn(ArgTypes...)>;
  template<class T> using result_of_t = typename result_of<T>::type;

  template<class T> struct is_pod;
  template<class T> inline constexpr bool is_pod_v = is_pod<T>::value;
}
\end{codeblock}

\pnum
The behavior of a program that adds specializations for
any of the templates defined in this subclause is undefined,
unless explicitly permitted by the specification of the corresponding template.

\begin{itemdecl}
template<class T> struct is_literal_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{remove_all_extents_t<T>} shall be a complete type or \cv{}~\tcode{void}.

\pnum
\tcode{is_literal_type<T>} is a \tcode{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of \tcode{true_type}
if \tcode{T} is a literal type\iref{basic.types}, and
\tcode{false_type} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<class Fn, class... ArgTypes> struct result_of<Fn(ArgTypes...)>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Fn} and all types in the parameter pack \tcode{ArgTypes} shall be complete types,
\cv{}~\tcode{void}, or arrays of unknown bound.

\pnum
The partial specialization \tcode{result_of<Fn(ArgTypes...)>} is a
\tcode{TransformationTrait}\iref{meta.rqmts} whose member typedef \tcode{type} is defined
if and only if \tcode{invoke_result<Fn, ArgTypes...>::type}\iref{func.invoke} is defined.
If \tcode{type} is defined, it names the same type as \tcode{invoke_result_t<Fn, ArgTypes...>}.
\end{itemdescr}

\begin{itemdecl}
template<class T> struct is_pod;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{remove_all_extents_t<T>} shall be a complete type or \cv{} \tcode{void}.

\pnum
\tcode{is_pod<T>} is a \tcode{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of \tcode{true_type}
if \tcode{T} is a POD type,
and \tcode{false_type} otherwise.
\indextext{POD}%
A POD class is a class that is both a trivial class and a standard-layout class,
and has no non-static data members of type non-POD class (or array thereof).
A POD type is a scalar type, a POD class, an array of such a type,
or a cv-qualified version of one of these types.

\pnum
\begin{note}
It is unspecified whether a closure type\iref{expr.prim.lambda.closure} is a POD type.
\end{note}
\end{itemdescr}

\rSec1[depr.iterator.primitives]{Deprecated iterator primitives}

\rSec2[depr.iterator.basic]{Basic iterator}

\pnum
The header
\indexhdr{iterator}%
\tcode{<iterator>} has the following addition:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
           class Pointer = T*, class Reference = T&>
  struct iterator {
    using iterator_category = Category;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = Pointer;
    using reference         = Reference;
  };
}
\end{codeblock}

\pnum
The
\tcode{iterator}
template may be used as a base class to ease the definition of required types
for new iterators.

\pnum
\begin{note} If the new iterator type is a class template, then these aliases
will not be visible from within the iterator class's template definition, but
only to callers of that class.\end{note}

\pnum
\begin{example}
If a \Cpp{} program wants to define a bidirectional iterator for some data
structure containing \tcode{double} and such that it works on a large memory
model of the implementation, it can do so with:

\begin{codeblock}
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // code implementing \tcode{++}, etc.
};
\end{codeblock}
\end{example}

\rSec1[depr.util.smartptr.shared.obs]{Deprecated \tcode{shared_ptr} observers}

\pnum
The following member is defined in addition to those members specified
in \ref{util.smartptr.shared}:

\indexlibrary{\idxcode{shared_ptr}}%
\begin{codeblock}
namespace std {
  template<class T> class shared_ptr {
  public:
    bool unique() const noexcept;
  };
}
\end{codeblock}

\indexlibrarymember{unique}{shared_ptr}%
\begin{itemdecl}
bool unique() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{use_count() == 1}.
\end{itemdescr}

\rSec1[depr.util.smartptr.shared.atomic]{Deprecated \tcode{shared_ptr} atomic access}

\pnum
The header \tcode{<memory>} has the following additions:

\indexlibrary{\idxcode{shared_ptr}}%
\begin{codeblock}
namespace std {
  template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);

  template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
  template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

  template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
  template<class T>
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
}
\end{codeblock}

\pnum
Concurrent access to a \tcode{shared_ptr} object from multiple threads does not
introduce a data race if the access is done exclusively via the functions in
this subclause and the instance is passed as their first argument.

\pnum
The meaning of the arguments of type \tcode{memory_order} is explained in~\ref{atomics.order}.

\indexlibrarymember{atomic_is_lock_free}{shared_ptr}%
\begin{itemdecl}
template<class T> bool atomic_is_lock_free(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{true} if atomic access to \tcode{*p} is lock-free, \tcode{false} otherwise.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_load_explicit(p, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_release} or \tcode{memory_order_acq_rel}.

\pnum
\returns \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects As if by \tcode{atomic_store_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_acquire} or \tcode{memory_order_acq_rel}.

\pnum
\effects As if by \tcode{p->swap(r)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_exchange_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects As if by \tcode{p->swap(r)}.

\pnum
\returns The previous value of \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.

\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_weak_explicit(p, v, w, memory_order_seq_cst, memory_order_seq_cst)
\end{codeblock}

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_strong}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_strong_explicit(p, v, w, memory_order_seq_cst, memory_order_seq_cst)
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak_explicit}{shared_ptr}%
\indexlibrarymember{atomic_compare_exchange_strong_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
template<class T>
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.
The \tcode{failure} argument shall not be \tcode{memory_order_release} nor
\tcode{memory_order_acq_rel}.

\pnum
\effects If \tcode{*p} is equivalent to \tcode{*v}, assigns \tcode{w} to
\tcode{*p} and has synchronization semantics corresponding to the value of
\tcode{success}, otherwise assigns \tcode{*p} to \tcode{*v} and has
synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns \tcode{true} if \tcode{*p} was equivalent to \tcode{*v}, \tcode{false} otherwise.

\pnum
\throws Nothing.

\pnum
\remarks Two \tcode{shared_ptr} objects are equivalent if they store the same
pointer value and share ownership.
The weak form may fail spuriously. See~\ref{atomics.types.operations}.
\end{itemdescr}

\rSec1[depr.locale.stdcvt]{Deprecated standard code conversion facets}

\pnum
\indexhdr{codecvt}%
The header \tcode{<codecvt>} provides code conversion facets for various character encodings.

\rSec2[depr.codecvt.syn]{Header \tcode{<codecvt>} synopsis}

\indexlibrary{\idxcode{codecvt_mode}}%
\indexlibrary{\idxcode{codecvt_utf8}}%
\indexlibrary{\idxcode{codecvt_utf16}}%
\indexlibrary{\idxcode{codecvt_utf8_utf16}}%
\begin{codeblock}
namespace std {
  enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
  };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8(size_t refs = 0);
      ~codecvt_utf8();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf16(size_t refs = 0);
      ~codecvt_utf16();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8_utf16(size_t refs = 0);
      ~codecvt_utf8_utf16();
    };
}
\end{codeblock}

\rSec2[depr.locale.stdcvt.req]{Requirements}

\pnum
For each of the three code conversion facets \tcode{codecvt_utf8},
\tcode{codecvt_utf16}, and \tcode{codecvt_utf8_utf16}:
\begin{itemize}
\item
  \tcode{Elem} is the wide-character type, such as
  \tcode{wchar_t}, \tcode{char16_t}, or \tcode{char32_t}.
\item
  \tcode{Maxcode} is the largest wide-character code that the facet
  will read or write without reporting a conversion error.
\item
  If \tcode{(Mode \& consume_header)}, the facet shall consume an
  initial header sequence, if present, when reading a multibyte sequence
  to determine the endianness of the subsequent multibyte sequence to be read.
\item
  If \tcode{(Mode \& generate_header)}, the facet shall generate an
  initial header sequence when writing a multibyte sequence to advertise
  the endianness of the subsequent multibyte sequence to be written.
\item
  If \tcode{(Mode \& little_endian)}, the facet shall generate a
  multibyte sequence in little-endian order,
  as opposed to the default big-endian order.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8}\indexlibrary{\idxcode{codecvt_utf8}}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UCS2 or UCS4 (depending on the size of \tcode{Elem})
  within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf16}\indexlibrary{\idxcode{codecvt_utf16}}:
\begin{itemize}
\item
  The facet shall convert between UTF-16 multibyte sequences
  and UCS2 or UCS4 (depending on the size of \tcode{Elem})
  within the program.
\item
  Multibyte sequences shall be read or written
  according to the \tcode{Mode} flag, as set out above.
\item
  The multibyte sequences may be written only as a binary file.
  Attempting to write to a text file produces undefined behavior.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8_utf16}\indexlibrary{\idxcode{codecvt_utf8_utf16}}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UTF-16 (one or two 16-bit codes) within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\xref ISO/IEC 10646-1:1993.

\rSec1[depr.conversions]{Deprecated convenience conversion interfaces}

\pnum
The header \tcode{<locale>} has the following additions:

\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class Wide_alloc = allocator<Elem>,
           class Byte_alloc = allocator<char>>
    class wstring_convert;

  template<class Codecvt, class Elem = wchar_t,
           class Tr = char_traits<Elem>>
    class wbuffer_convert;
}
\end{codeblock}

\rSec2[depr.conversions.string]{Class template \tcode{wstring_convert}}

\pnum
Class template \tcode{wstring_convert} performs conversions between a wide
string and a byte string. It lets you specify a code conversion facet
(like class template \tcode{codecvt}) to perform the conversions, without
affecting any streams or locales. \begin{example} If you want to use the code
conversion facet \tcode{codecvt_utf8} to output to \tcode{cout} a UTF-8
multibyte sequence corresponding to a wide string, but you don't want to
alter the locale for \tcode{cout}, you can write something like:
\begin{codeblock}
wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout << mbstring;
\end{codeblock}
\end{example}

\indexlibrary{\idxcode{wstring_convert}}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class Wide_alloc = allocator<Elem>,
           class Byte_alloc = allocator<char>>
    class wstring_convert {
    public:
      using byte_string = basic_string<char, char_traits<char>, Byte_alloc>;
      using wide_string = basic_string<Elem, char_traits<Elem>, Wide_alloc>;
      using state_type  = typename Codecvt::state_type;
      using int_type    = typename wide_string::traits_type::int_type;

      explicit wstring_convert(Codecvt* pcvt = new Codecvt);
      wstring_convert(Codecvt* pcvt, state_type state);
      explicit wstring_convert(const byte_string& byte_err,
                               const wide_string& wide_err = wide_string());
      ~wstring_convert();

      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;

      wide_string from_bytes(char byte);
      wide_string from_bytes(const char* ptr);
      wide_string from_bytes(const byte_string& str);
      wide_string from_bytes(const char* first, const char* last);

      byte_string to_bytes(Elem wchar);
      byte_string to_bytes(const Elem* wptr);
      byte_string to_bytes(const wide_string& wstr);
      byte_string to_bytes(const Elem* first, const Elem* last);

      size_t converted() const noexcept;
      state_type state() const;

    private:
      byte_string byte_err_string;  // \expos
      wide_string wide_err_string;  // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
      size_t cvtcount;              // \expos
    };
}
\end{codeblock}

\pnum
The class template describes an object that controls conversions between wide
string objects of class \tcode{basic_string<Elem, char_traits<Elem>,
Wide_alloc>} and byte string objects of class \tcode{basic_string<char,
char_traits<char>, Byte_alloc>}. The class template defines the types
\tcode{wide_string} and \tcode{byte_string} as synonyms for these two types.
Conversion between a sequence of \tcode{Elem} values (stored in a
\tcode{wide_string} object) and multibyte sequences (stored in a
\tcode{byte_string} object) is performed by an object of class
\tcode{Codecvt}, which meets the
requirements of the standard code-conversion facet \tcode{codecvt<Elem,
char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{byte_err_string} --- a byte string to display on errors
\item \tcode{wide_err_string} --- a wide string to display on errors
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wstring_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\item \tcode{cvtcount} --- a conversion count
\end{itemize}

\indexlibrarymember{byte_string}{wstring_convert}%
\begin{itemdecl}
using byte_string = basic_string<char, char_traits<char>, Byte_alloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<char, char_traits<char>, Byte_alloc>}.
\end{itemdescr}

\indexlibrarymember{converted}{wstring_convert}%
\begin{itemdecl}
size_t converted() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cvtcount}.
\end{itemdescr}

\indexlibrarymember{from_bytes}{wstring_convert}%
\begin{itemdecl}
wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char* first, const char* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{byte} to a
wide string. The second member function shall convert the null-terminated
sequence beginning at \tcode{ptr} to a wide string. The third member function
shall convert the sequence stored in \tcode{str} to a wide string. The fourth member
function shall convert the sequence defined by the range \range{first}{last} to a
wide string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.

\item The number of input elements successfully converted shall be stored in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the
member function shall return the wide-error string.
Otherwise, the member function throws an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{int_type}{wstring_convert}%
\begin{itemdecl}
using int_type = typename wide_string::traits_type::int_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{wide_string::traits_type::int_type}.
\end{itemdescr}

\indexlibrarymember{state}{wstring_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
returns \tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{state_type}{wstring_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibrarymember{to_bytes}{wstring_convert}%
\begin{itemdecl}
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem* first, const Elem* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{wchar} to a byte string.
The second member function shall convert the null-terminated sequence beginning at \tcode{wptr} to
a byte string. The third member function shall convert the sequence stored in \tcode{wstr} to a
byte string. The fourth member function shall convert the sequence defined by the
range \range{first}{last} to a byte string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be
set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.
\item The number of input elements successfully converted shall be stored
in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the
member function shall return the byte-error string.
Otherwise, the member function shall throw an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{wide_string}{wstring_convert}%
\begin{itemdecl}
using wide_string = basic_string<Elem, char_traits<Elem>, Wide_alloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<Elem,
char_traits<Elem>, Wide_alloc>}.
\end{itemdescr}

\indexlibrary{\idxcode{wstring_convert}!constructor}%
\begin{itemdecl}
explicit wstring_convert(Codecvt* pcvt = new Codecvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string& byte_err,
    const wide_string& wide_err = wide_string());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For the first and second constructors, \tcode{pcvt != nullptr}.

\pnum
\effects
The first constructor shall store \tcode{pcvt} in \tcode{cvtptr} and
default values in \tcode{cvtstate}, \tcode{byte_err_string}, and
\tcode{wide_err_string}.
The second constructor shall store \tcode{pcvt} in \tcode{cvtptr},
\tcode{state} in \tcode{cvtstate}, and default values in
\tcode{byte_err_string} and \tcode{wide_err_string}; moreover the
stored state shall be retained between calls to \tcode{from_bytes} and
\tcode{to_bytes}.
The third constructor shall store \tcode{new Codecvt} in \tcode{cvtptr},
\tcode{state_type()} in \tcode{cvtstate}, \tcode{byte_err}
in \tcode{byte_err_string}, and \tcode{wide_err} in
\tcode{wide_err_string}.
\end{itemdescr}

\indexlibrary{\idxcode{wstring_convert}!destructor}%
\begin{itemdecl}
~wstring_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}

\rSec2[depr.conversions.buffer]{Class template \tcode{wbuffer_convert}}

\pnum
Class template \tcode{wbuffer_convert} looks like a wide stream buffer, but
performs all its I/O through an underlying byte stream buffer that you
specify when you construct it. Like class template \tcode{wstring_convert}, it
lets you specify a code conversion facet to perform the conversions,
without affecting any streams or locales.

\indexlibrary{\idxcode{wbuffer_convert}}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
    class wbuffer_convert : public basic_streambuf<Elem, Tr> {
    public:
      using state_type = typename Codecvt::state_type;

      explicit wbuffer_convert(streambuf* bytebuf = nullptr,
                               Codecvt* pcvt = new Codecvt,
                               state_type state = state_type());

      ~wbuffer_convert();

      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const;
      streambuf* rdbuf(streambuf* bytebuf);

      state_type state() const;

    private:
      streambuf* bufptr;            // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
  };
}
\end{codeblock}

\pnum
The class template describes a stream buffer that controls the
transmission of elements of type \tcode{Elem}, whose character traits are
described by the class \tcode{Tr}, to and from a byte stream buffer of type
\tcode{streambuf}. Conversion between a sequence of \tcode{Elem} values and
multibyte sequences is performed by an object of class
\tcode{Codecvt}, which shall meet the requirements
of the standard code-conversion facet \tcode{codecvt<Elem, char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{bufptr} --- a pointer to its underlying byte stream buffer
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wbuffer_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\end{itemize}

\indexlibrarymember{state}{wbuffer_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf(streambuf* bytebuf);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Stores \tcode{bytebuf} in \tcode{bufptr}.

\pnum
\returns The previous value of \tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{state_type}{wbuffer_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibrary{\idxcode{wbuffer_convert}!constructor}%
\begin{itemdecl}
explicit wbuffer_convert(
    streambuf* bytebuf = nullptr,
    Codecvt* pcvt = new Codecvt,
    state_type state = state_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pcvt != nullptr}.

\pnum
\effects The constructor constructs a stream buffer object, initializes
\tcode{bufptr} to \tcode{bytebuf}, initializes \tcode{cvtptr}
to \tcode{pcvt}, and initializes \tcode{cvtstate} to \tcode{state}.
\end{itemdescr}

\indexlibrary{\idxcode{wbuffer_convert}!destructor}%
\begin{itemdecl}
~wbuffer_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}
