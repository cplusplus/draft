%!TEX root = std.tex
\normannex{depr}{Compatibility features}

\pnum
This Clause describes features of the \Cpp Standard that are specified for compatibility with
existing implementations.

\pnum
These are deprecated features, where
\term{deprecated}
is defined as:
Normative for the current edition of the Standard,
but having been identified as a candidate for removal from future revisions.
An implementation may declare library names and entities described in this section with the
\tcode{deprecated} attribute~(\ref{dcl.attr.deprecated}).

\rSec1[depr.static_constexpr]{Redeclaration of \tcode{static constexpr} data members}

\pnum
For compatibility with prior \Cpp{} International Standards, a \tcode{constexpr}
static data member may be redundantly redeclared outside the class with no initializer.
This usage is deprecated.
\begin{example}
\begin{codeblock}
struct A {
  static constexpr int n = 5;  // definition (declaration in \CppXIV)
};

constexpr int A::n;  // redundant declaration (definition in \CppXIV)
\end{codeblock}
\end{example}

\rSec1[depr.impldec]{Implicit declaration of copy functions}

\pnum
The implicit definition of a copy constructor
as defaulted
is deprecated if the class has a
user-declared copy assignment operator or a user-declared destructor. The implicit
definition of a copy assignment operator
as defaulted is deprecated if the class has a user-declared
copy constructor or a user-declared destructor (\ref{class.dtor},~\ref{class.copy}).
In a future revision of this International Standard, these implicit definitions
could become deleted~(\ref{dcl.fct.def}).

\rSec1[depr.except.spec]{Dynamic exception specifications}

\pnum
The use of \grammarterm{dynamic-exception-specification}{s} is deprecated.

\rSec1[depr.c.headers]{C standard library headers}

\pnum
For compatibility with the 
\indextext{library!C standard}%
C standard library, the \Cpp standard library provides
the 26 \textit{C headers}, as shown in Table~\ref{tab:future.c.headers}.

\begin{floattable}{C headers}{tab:future.c.headers}
{lllll}
\topline

\tcode{<assert.h>}			&
\tcode{<inttypes.h>}		&
\tcode{<signal.h>}			&
\tcode{<stdio.h>}			  &
\tcode{<wchar.h>}			  \\

\tcode{<complex.h>}			&
\tcode{<iso646.h>}			&
\tcode{<stdalign.h>}    &
\tcode{<stdlib.h>}			&
\tcode{<wctype.h>}			\\

\tcode{<ctype.h>}			  &
\tcode{<limits.h>}			&
\tcode{<stdarg.h>}			&
\tcode{<string.h>}			& \\

\tcode{<errno.h>}			  &
\tcode{<locale.h>}			&
\tcode{<stdbool.h>}			&
\tcode{<tgmath.h>}			& \\

\tcode{<fenv.h>}			  &
\tcode{<math.h>}			  &
\tcode{<stddef.h>}			&
\tcode{<time.h>}				& \\

\tcode{<float.h>}			  &
\tcode{<setjmp.h>}			&
\tcode{<stdint.h>}			&
\tcode{<uchar.h>}			  & \\

\end{floattable}

\pnum
The header <complex.h> behaves as if it simply includes the header <ccomplex>.

\pnum
The use of any of the \Cpp headers
\tcode{<ccomplex>},
\tcode{<cstdalign>},
\tcode{<cstdbool>},
or \tcode{<ctgmath>}
is deprecated.

\pnum
The header \tcode{<complex.h>} behaves as if it simply includes the header \tcode{<ccomplex>}.

\pnum
Except for the functions declared in \ref{sf.cmath}, every other C header, each of
which has a name of the form
\indextext{header!C}%
\tcode{name.h},
behaves as if each name placed in the standard library namespace by
the corresponding
\tcode{c\textit{name}}
header is placed within
the global namespace scope. It is unspecified whether these names are first declared or defined within
namespace scope~(\ref{basic.scope.namespace}) of the namespace
\tcode{std} and are then injected into the global namespace scope by
explicit \grammarterm{using-declaration}{s}~(\ref{namespace.udecl}).
\indextext{namespace}%

\pnum
\begin{example}
The header
\indexlibrary{\idxhdr{cstdlib}}%
\indexlibrary{\idxhdr{stdlib.h}}%
\tcode{<cstdlib>} assuredly
provides its declarations and definitions within the namespace
\tcode{std}. It may also provide these names within the
global namespace.
The header
\tcode{<stdlib.h>}
assuredly provides the same declarations and definitions within
the global namespace,
much as in the C Standard. It may also provide these names within
the namespace \tcode{std}.
\end{example}

\rSec1[depr.str.strstreams]{\tcode{char*} streams}

\pnum
The header
\indexlibrary{\idxhdr{strstream}}%
\tcode{<strstream>}
defines three types that associate stream buffers with
character array objects and assist reading and writing such objects.

\rSec2[depr.strstreambuf]{Class \tcode{strstreambuf}}

\indexlibrary{\idxcode{strstreambuf}}%
\begin{codeblock}
namespace std {
  class strstreambuf : public basic_streambuf<char> {
  public:
    explicit strstreambuf(streamsize alsize_arg = 0);
    strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
    strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
    strstreambuf(const char* gnext_arg, streamsize n);

    strstreambuf(signed char* gnext_arg, streamsize n,
                 signed char* pbeg_arg = 0);
    strstreambuf(const signed char* gnext_arg, streamsize n);
    strstreambuf(unsigned char* gnext_arg, streamsize n,
                 unsigned char* pbeg_arg = 0);
    strstreambuf(const unsigned char* gnext_arg, streamsize n);

    virtual ~strstreambuf();

    void  freeze(bool freezefl = true);
    char* str();
    int   pcount();

  protected:
    int_type overflow (int_type c = EOF) override;
    int_type pbackfail(int_type c = EOF) override;
    int_type underflow() override;
    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    streambuf* setbuf(char* s, streamsize n) override;

  private:
    using strstate = T1;              // \expos
    static const strstate allocated;  // \expos
    static const strstate constant;   // \expos
    static const strstate dynamic;    // \expos
    static const strstate frozen;     // \expos
    strstate strmode;                 // \expos
    streamsize alsize;                // \expos
    void* (*palloc)(size_t);          // \expos
    void (*pfree)(void*);             // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstreambuf}
associates the input sequence, and possibly the output sequence, with an object of some
\textit{character}
array type, whose elements store arbitrary values.
The array object has several attributes.

\pnum
\begin{note}
For the sake of exposition, these are represented as elements of a bitmask type
(indicated here as \tcode{T1}) called \tcode{strstate}.
The elements are:
\begin{itemize}
\item
\tcode{allocated}, set when a dynamic array object has been
allocated, and hence should be freed by the destructor for the
\tcode{strstreambuf} object;
\item
\tcode{constant}, set when the array object has
\tcode{const} elements, so the output sequence cannot be written;
\item
\tcode{dynamic}, set when the array object is allocated
(or reallocated)
as necessary to hold a character sequence that can change in length;
\item
\tcode{frozen}, set when the program has requested that the
array object not be altered, reallocated, or freed.
\end{itemize}
\end{note}

\pnum
\begin{note}
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{strstate strmode}, the attributes of the array object
associated with the \tcode{strstreambuf} object;
\item
\tcode{int alsize}, the suggested minimum size for a
dynamic array object;
\item
\tcode{void* (*palloc)(size_t)}, points to the function
to call to allocate a dynamic array object;
\item
\tcode{void (*pfree)(void*)}, points to the function to
call to free a dynamic array object.
\end{itemize}
\end{note}

\pnum
Each object of class
\tcode{strstreambuf}
has a
\term{seekable area},
delimited by the pointers \tcode{seeklow} and \tcode{seekhigh}.
If \tcode{gnext} is a null pointer, the seekable area is undefined.
Otherwise, \tcode{seeklow} equals \tcode{gbeg} and
\tcode{seekhigh} is either \tcode{pend},
if \tcode{pend} is not a null pointer, or \tcode{gend}.

\rSec3[depr.strstreambuf.cons]{\tcode{strstreambuf} constructors}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
explicit strstreambuf(streamsize alsize_arg = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf.effects}.
\end{itemdescr}

\begin{libtab2}{\tcode{strstreambuf(streamsize)} effects}{tab:future.strstreambuf.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}		\\
\tcode{alsize}	&	\tcode{alsize_arg}	\\
\tcode{palloc}	&	a null pointer		\\
\tcode{pfree}	&	a null pointer		\\
\end{libtab2}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf1.effects}.

\begin{libtab2}{\tcode{strstreambuf(void* (*)(size_t), void (*)(void*))} effects}
{tab:future.strstreambuf1.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}			\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	\tcode{palloc_arg}		\\
\tcode{pfree}	&	\tcode{pfree_arg}		\\
\end{libtab2}
\end{itemdescr}

\indextext{unspecified}%
\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
strstreambuf(signed char* gnext_arg, streamsize n,
             signed char* pbeg_arg = 0);
strstreambuf(unsigned char* gnext_arg, streamsize n,
             unsigned char* pbeg_arg = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in Table~\ref{tab:future.strstreambuf2.effects}.

\begin{libtab2}{\tcode{strstreambuf(charT*, streamsize, charT*)} effects}
{tab:future.strstreambuf2.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	0						\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	a null pointer			\\
\tcode{pfree}	&	a null pointer			\\
\end{libtab2}

\pnum
\tcode{gnext_arg} shall point to the first element of an array
object whose number of elements \tcode{N} is determined as follows:
\begin{itemize}
\item
If
\tcode{n > 0},
\tcode{N} is \tcode{n}.
\item
If
\tcode{n == 0},
\tcode{N} is
\tcode{std::strlen(gnext_arg)}.
\indexlibrary{\idxcode{strlen}}%
\item
If
\tcode{n < 0},
\tcode{N} is
\tcode{INT_MAX}.\footnote{The function signature
\tcode{strlen(const char*)}
is declared in
\tcode{<cstring>}
\indexlibrary{\idxcode{strlen}}%
\indexlibrary{\idxhdr{cstring}}%
(\ref{cstring.syn}).
The macro
\tcode{INT_MAX}
is defined in
\tcode{<climits>}\indexlibrary{\idxhdr{climits}} (\ref{climits.syn}).}
\end{itemize}

\pnum
If \tcode{pbeg_arg} is a null pointer, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, gnext_arg + N);
\end{codeblock}

\pnum
Otherwise, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, pbeg_arg);
setp(pbeg_arg,  pbeg_arg + N);
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(const char* gnext_arg, streamsize n);
strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(const unsigned char* gnext_arg, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves the same as
\tcode{strstreambuf((char*)gnext_arg,n)},
except that the constructor also sets \tcode{constant} in \tcode{strmode}.
\end{itemdescr}

\indexlibrary{\idxcode{strstreambuf}!destructor}%
\begin{itemdecl}
virtual ~strstreambuf();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstreambuf}.
The function frees the dynamically allocated array object only if
\tcode{strmode \& allocated != 0}
and
\tcode{strmode \& frozen == 0}.~(\ref{depr.strstreambuf.virtuals} describes how a dynamically allocated array object is freed.)
\end{itemdescr}

\rSec3[depr.strstreambuf.members]{Member functions}

\indexlibrarymember{freeze}{strstreambuf}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{strmode} \& \tcode{dynamic} is non-zero, alters the
freeze status of the dynamic array object as follows:
\begin{itemize}
\item
If \tcode{freezefl} is
\tcode{true},
the function sets \tcode{frozen} in \tcode{strmode}.
\item
Otherwise, it clears \tcode{frozen} in \tcode{strmode}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{str}{strstreambuf}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{freeze()},
then returns the beginning pointer for the input sequence, \tcode{gbeg}.

\pnum
\remarks
The return value can be a null pointer.
\end{itemdescr}

\indexlibrarymember{pcount}{strstreambuf}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the next pointer for the output sequence, \tcode{pnext}, is
a null pointer, returns zero.
Otherwise, returns the current
effective length of the array object as the next pointer minus the beginning
pointer for the output sequence, \tcode{pnext} - \tcode{pbeg}.
\end{itemdescr}

\rSec3[depr.strstreambuf.virtuals]{\tcode{strstreambuf} overridden virtual functions}

\indexlibrarymember{overflow}{strstreambuf}%
\begin{itemdecl}
int_type overflow(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Appends the character designated by \tcode{c} to the output
sequence, if possible, in one of two ways:
\begin{itemize}
\item
If
\tcode{c != EOF}
and if either the output sequence has a write position available or
the function makes a write position available
(as described below),
assigns \tcode{c} to
\tcode{*pnext++}.

Returns
\tcode{(unsigned char)c}.

\item
If
\tcode{c == EOF},
there is no character to append.

Returns a value other than \tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of write positions available as a
result of any call.

\pnum
To make a write position available, the function reallocates
(or initially allocates)
an array object with a sufficient number of elements
\tcode{n} to hold the current array object (if any),
plus at least one additional write position.
How many additional write positions are made
available is otherwise unspecified.%
\indextext{unspecified}%
\footnote{An implementation should consider \tcode{alsize} in making this
decision.}
If \tcode{palloc} is not a null pointer, the function calls
\tcode{(*palloc)(n)}
to allocate the new dynamic array object.
Otherwise, it evaluates the expression
\tcode{new charT[n]}.
In either case, if the allocation fails, the function returns
\tcode{EOF}.
Otherwise, it sets \tcode{allocated} in \tcode{strmode}.

\pnum
To free a previously existing dynamic array object whose first
element address is \tcode{p}:
If \tcode{pfree} is not a null pointer,
the function calls
\tcode{(*pfree)(p)}.
Otherwise, it evaluates the expression \tcode{delete[]p}.

\pnum
If
\tcode{strmode \& dynamic == 0},
or if
\tcode{strmode \& frozen != 0},
the function cannot extend the array (reallocate it with greater length) to make a write position available.
\end{itemdescr}

\indexlibrarymember{pbackfail}{strstreambuf}%
\begin{itemdecl}
int_type pbackfail(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
Puts back the character designated by \tcode{c} to the input
sequence, if possible, in one of three ways:
\begin{itemize}
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{(char)c == gnext[-1]},
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns \tcode{c}.
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{strmode} \& \tcode{constant} is zero,
assigns \tcode{c} to
\tcode{*\dcr{}gnext}.

Returns
\tcode{c}.
\item
If
\tcode{c == EOF}
and if the input sequence has a putback position available,
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns a value other than
\tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.
\indextext{unspecified}%
The function can alter the number of putback
positions available as a result of any call.
\end{itemdescr}

\indexlibrarymember{underflow}{strstreambuf}%
\begin{itemdecl}
int_type underflow() override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads a character from the
\term{input sequence},
if possible, without moving the stream position past it, as follows:
\begin{itemize}
\item
If the input sequence has a read position available, the function
signals success by returning
\tcode{(unsigned char)\brk*gnext}.
\item
Otherwise, if
the current write next pointer \tcode{pnext} is not a null pointer and
is greater than the current read end pointer \tcode{gend},
makes a
\term{read position}
available by
assigning to \tcode{gend} a value greater than \tcode{gnext} and
no greater than \tcode{pnext}.

Returns \tcode{(unsigned char)*gnext}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of read positions available as a
result of any call.
\end{itemdescr}

\indexlibrarymember{seekoff}{strstreambuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, seekdir way, openmode which = in | out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, as indicated in Table~\ref{tab:future.seekoff.positioning}.

\begin{libtab2}{\tcode{seekoff} positioning}{tab:future.seekoff.positioning}
{p{2.5in}l}{Conditions}{Result}
\tcode{(which \& ios::in) != 0}	&
 positions the input sequence	\\ \rowsep
\tcode{(which \& ios::out) != 0}	&
 positions the output sequence	\\ \rowsep
\tcode{(which \& (ios::in |}\br
\tcode{ios::out)) == (ios::in |}\br
\tcode{ios::out))} and\br
\tcode{way ==} either\br
\tcode{ios::beg} or\br
\tcode{ios::end}			&
 positions both the input and the output sequences	\\ \rowsep
Otherwise	&
 the positioning operation fails.	\\
\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} as indicated in
Table~\ref{tab:future.newoff.values}.

\begin{libtab2}{\tcode{newoff} values}{tab:future.newoff.values}
{p{2.0in}p{2.0in}}{Condition}{\tcode{newoff} Value}
\tcode{way == ios::beg}	&
 0	\\ \rowsep
\tcode{way == ios::cur}	&
 the next pointer minus the beginning pointer (\tcode{xnext - xbeg}).	\\ \rowsep
\tcode{way == ios::end}	&
 \tcode{seekhigh} minus the beginning pointer (\tcode{seekhigh - xbeg}).	\\
\end{libtab2}

\pnum
If \tcode{(newoff + off) < (seeklow - xbeg)}
or \tcode{(seekhigh - xbeg) < (newoff + off)},
the positioning operation fails.
Otherwise, the function assigns
\tcode{xbeg + newoff + off}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset
\tcode{newoff} (of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{seekpos}{strstreambuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp, ios_base::openmode which
                  = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, to correspond to the
stream position stored in \tcode{sp}
(as described below).
\begin{itemize}
\item
If
\tcode{(which \& ios::in) != 0},
positions the input sequence.
\item
If
\tcode{(which \& ios::out) != 0},
positions the output sequence.
\item
If the function positions neither sequence, the positioning operation fails.
\end{itemize}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} from
\tcode{sp.offset()}:
\begin{itemize}
\item
If \tcode{newoff} is an invalid stream position,
has a negative value, or
has a value greater than (\tcode{seekhigh} - \tcode{seeklow}),
the positioning operation fails
\item
Otherwise, the function
adds \tcode{newoff} to the beginning pointer \tcode{xbeg} and
stores the result in the next pointer \tcode{xnext}.
\end{itemize}

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset \tcode{newoff}
(of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{setbuf}{strstreambuf}%
\begin{itemdecl}
streambuf<char>* setbuf(char* s, streamsize n) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Implementation defined, except that
\tcode{setbuf(0, 0)}
has no effect.%
\end{itemdescr}

\rSec2[depr.istrstream]{Class \tcode{istrstream}}

\indexlibrary{\idxcode{istrstream}}%
\begin{codeblock}
namespace std {
  class istrstream : public basic_istream<char> {
  public:
    explicit istrstream(const char* s);
    explicit istrstream(char* s);
    istrstream(const char* s, streamsize n);
    istrstream(char* s, streamsize n);
    virtual ~istrstream();

    strstreambuf* rdbuf() const;
    char* str();
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{istrstream}
supports the reading of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.istrstream.cons]{\tcode{istrstream} constructors}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
explicit istrstream(const char* s);
explicit istrstream(char* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,0)}.
\tcode{s} shall designate the first element of an \ntbs.%
\indextext{NTBS}
\end{itemdescr}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
istrstream(const char* s, streamsize n);
istrstream(char* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,n)}.
\tcode{s} shall designate the first element of an array whose length is
\tcode{n} elements, and \tcode{n} shall be greater than zero.
\end{itemdescr}

\rSec3[depr.istrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{istrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<strstreambuf*>(\&sb)}.
\end{itemdescr}

\indexlibrarymember{str}{istrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\rSec2[depr.ostrstream]{Class \tcode{ostrstream}}

\indexlibrary{\idxcode{ostrstream}}%
\begin{codeblock}
namespace std {
  class ostrstream : public basic_ostream<char> {
  public:
    ostrstream();
    ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
    virtual ~ostrstream();

    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    char* str();
    int pcount() const;
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{ostrstream}
supports the writing of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.ostrstream.cons]{\tcode{ostrstream} constructors}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf()}.
\end{itemdescr}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)},
and initializing \tcode{sb} with one of two constructors:

\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.

The constructor is
\tcode{strstreambuf(s, n, s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements that
contains an \ntbs whose first element is designated by \tcode{s}.
\indextext{NTBS}%
The constructor is
\tcode{strstreambuf(s, n, s + std::strlen(s))}.\footnote{The function signature
\tcode{strlen(const char*)}
is declared in
\tcode{<cstring>}
\indexlibrary{\idxcode{strlen}}%
\indexlibrary{\idxhdr{cstring}}%
(\ref{cstring.syn}).}
\end{itemize}
\end{itemdescr}

\rSec3[depr.ostrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{ostrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{(strstreambuf*)\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{ostrstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{ostrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{ostrstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec2[depr.strstream]{Class \tcode{strstream}}

\indexlibrary{\idxcode{strstream}}%
\begin{codeblock}
namespace std {
  class strstream
    : public basic_iostream<char> {
  public:
    // Types
    using char_type = char;
    using int_type  = char_traits<char>::int_type;
    using pos_type  = char_traits<char>::pos_type;
    using off_type  = char_traits<char>::off_type;

    // constructors/destructor
    strstream();
    strstream(char* s, int n,
              ios_base::openmode mode = ios_base::in|ios_base::out);
    virtual ~strstream();

    // Members:
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    int pcount() const;
    char* str();

  private:
  strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstream}
supports reading and writing from objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.strstream.cons]{\tcode{strstream} constructors}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}.
\end{itemdescr}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream(char* s, int n,
          ios_base::openmode mode = ios_base::in|ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}
and initializing \tcode{sb} with one of the two constructors:
\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.
The constructor is
\tcode{strstreambuf(s,n,s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall
designate the first element of an array of \tcode{n} elements that contains
an \ntbs whose first element is designated by \tcode{s}.
The constructor is
\tcode{strstreambuf(s,n,s + std::strlen(s))}.
\indexlibrary{\idxcode{strstream}!destructor}%
\end{itemize}
\end{itemdescr}

\rSec3[depr.strstream.dest]{\tcode{strstream} destructor}

\indexlibrary{\idxcode{strstream}!destructor}%
\begin{itemdecl}
virtual ~strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstream}.
\end{itemdescr}

\rSec3[depr.strstream.oper]{\tcode{strstream} operations}

\indexlibrarymember{rdbuf}{strstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{strstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{strstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{strstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec1[exception.unexpected]{Violating \grammarterm{exception-specification}{s}}

\pnum
The header
\indexlibrary{\idxhdr{exception}}%
\tcode{<exception>} has the following additions:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  using unexpected_handler = void (*)();
  unexpected_handler get_unexpected() noexcept;
  unexpected_handler set_unexpected(unexpected_handler f) noexcept;
  [[noreturn]] void unexpected();
}
\end{codeblock}


\rSec2[unexpected.handler]{Type \tcode{unexpected_handler}}

\indexlibrary{\idxcode{unexpected_handler}}%
\begin{itemdecl}
using unexpected_handler = void (*)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{unexpected()}
when a function attempts to throw an exception not listed in its
\grammarterm{dynamic-exception-specification}.

\pnum
\required
An
\tcode{unexpected_handler}
shall not return.
See also~\ref{except.unexpected}.

\pnum
\default
The implementation's default \tcode{unexpected_handler} calls
\tcode{std::terminate()}.
\indexlibrary{\idxcode{terminate}}
\end{itemdescr}

\rSec2[set.unexpected]{\tcode{set_unexpected}}

\indexlibrary{\idxcode{set_unexpected}}%
\begin{itemdecl}
unexpected_handler set_unexpected(unexpected_handler f) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{f} as the current
\tcode{unexpected_handler}.

\pnum
\remarks It is unspecified whether a null pointer value designates the default
\tcode{unexpected_handler}.

\pnum
\returns
The previous \tcode{unexpected_handler}.
\end{itemdescr}

\rSec2[get.unexpected]{\tcode{get_unexpected}}

\indexlibrary{\idxcode{get_unexpected}}%
\begin{itemdecl}
unexpected_handler get_unexpected() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The current \tcode{unexpected_handler}.
\begin{note} This may be a null pointer value. \end{note}
\end{itemdescr}

\rSec2[unexpected]{\tcode{unexpected}}

\indexlibrary{\idxcode{unexpected}}%
\begin{itemdecl}
[[noreturn]] void unexpected();
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
Called by the implementation when a function exits via an exception not allowed by its
\grammarterm{exception-specification}~(\ref{except.unexpected}).
May also be called directly by the program.

\pnum
\effects
Calls an \tcode{unexpected_handler} function. It is unspecified which
\tcode{unexpected_handler} function will be called if an exception is active
during a call to \tcode{set_unexpected}.
Otherwise calls the current \tcode{unexpected_handler} function.
\begin{note} A default \tcode{unexpected_handler} is always considered a callable handler in
this context. \end{note}
\end{itemdescr}

\rSec1[depr.uncaught]{\tcode{uncaught_exception}}

\pnum
The header
\indexlibrary{\idxhdr{exception}}%
\tcode{<exception>} has the following addition:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  bool uncaught_exception() noexcept;
}
\end{codeblock}

\indexlibrary{\idxcode{uncaught_exception}}%
\begin{itemdecl}
bool uncaught_exception() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{uncaught_exceptions() > 0}.
\end{itemdescr}

\rSec1[depr.func.adaptor.binding]{Old adaptable function bindings}

\rSec2[depr.weak.result_type]{Weak result types}

\pnum
A call wrapper~(\ref{func.def}) may have a \defn{weak result type}.
If it does, the type of its member type \tcode{result_type}
is based on the type \tcode{T} of the wrapper's target object:
\begin{itemize}
\item if \tcode{T} is a pointer to function type,
\tcode{result_type} shall be a synonym for the return type of \tcode{T};
\item if \tcode{T} is a pointer to member function,
\tcode{result_type} shall be a synonym for the return type of \tcode{T};
\item if \tcode{T} is a class type
and the \grammarterm{qualified-id} \tcode{T::result_type} is valid and denotes a type~(\ref{temp.deduct}),
then \tcode{result_type} shall be a synonym for \tcode{T::result_type};
\item otherwise \tcode{result_type} shall not be defined.
\end{itemize}

\rSec2[depr.func.adaptor.typedefs]{Typedefs to support function binders}

\pnum
To enable old function adaptors to manipulate function objects
that take one or two arguments,
many of the function objects in this standard
correspondingly provide \grammarterm{typedef-name}{s}
\tcode{argument_type} and \tcode{result_type}
for function objects that take one argument and
\tcode{first_argument_type}, \tcode{second_argument_type}, and \tcode{result_type}
for function objects that take two arguments.

\pnum
The following member names are defined in addition to names specified in Clause~\ref{function.objects}:

\indexlibrarymember{result_type}{owner_less}%
\indexlibrarymember{first_argument_type}{owner_less}%
\indexlibrarymember{second_argument_type}{owner_less}%
\indexlibrarymember{result_type}{owner_less}%
\indexlibrarymember{first_argument_type}{owner_less}%
\indexlibrarymember{second_argument_type}{owner_less}%
\indexlibrarymember{result_type}{plus}%
\indexlibrarymember{first_argument_type}{plus}%
\indexlibrarymember{second_argument_type}{plus}%
\indexlibrarymember{result_type}{minus}%
\indexlibrarymember{first_argument_type}{minus}%
\indexlibrarymember{second_argument_type}{minus}%
\indexlibrarymember{result_type}{multiplies}%
\indexlibrarymember{first_argument_type}{multiplies}%
\indexlibrarymember{second_argument_type}{multiplies}%
\indexlibrarymember{result_type}{divides}%
\indexlibrarymember{first_argument_type}{divides}%
\indexlibrarymember{second_argument_type}{divides}%
\indexlibrarymember{result_type}{modulus}%
\indexlibrarymember{first_argument_type}{modulus}%
\indexlibrarymember{second_argument_type}{modulus}%
\indexlibrarymember{result_type}{negate}%
\indexlibrarymember{argument_type}{negate}%
\indexlibrarymember{result_type}{equal_to}%
\indexlibrarymember{first_argument_type}{equal_to}%
\indexlibrarymember{second_argument_type}{equal_to}%
\indexlibrarymember{result_type}{not_equal_to}%
\indexlibrarymember{first_argument_type}{not_equal_to}%
\indexlibrarymember{second_argument_type}{not_equal_to}%
\indexlibrarymember{result_type}{greater}%
\indexlibrarymember{first_argument_type}{greater}%
\indexlibrarymember{second_argument_type}{greater}%
\indexlibrarymember{result_type}{less}%
\indexlibrarymember{first_argument_type}{less}%
\indexlibrarymember{second_argument_type}{less}%
\indexlibrarymember{result_type}{greater_equal}%
\indexlibrarymember{first_argument_type}{greater_equal}%
\indexlibrarymember{second_argument_type}{greater_equal}%
\indexlibrarymember{result_type}{less_equal}%
\indexlibrarymember{first_argument_type}{less_equal}%
\indexlibrarymember{second_argument_type}{less_equal}%
\indexlibrarymember{result_type}{logical_and}%
\indexlibrarymember{first_argument_type}{logical_and}%
\indexlibrarymember{second_argument_type}{logical_and}%
\indexlibrarymember{result_type}{logical_or}%
\indexlibrarymember{first_argument_type}{logical_or}%
\indexlibrarymember{second_argument_type}{logical_or}%
\indexlibrarymember{result_type}{logical_not}%
\indexlibrarymember{argument_type}{logical_not}%
\indexlibrarymember{result_type}{bit_and}%
\indexlibrarymember{first_argument_type}{bit_and}%
\indexlibrarymember{second_argument_type}{bit_and}%
\indexlibrarymember{result_type}{bit_or}%
\indexlibrarymember{first_argument_type}{bit_or}%
\indexlibrarymember{second_argument_type}{bit_or}%
\indexlibrarymember{result_type}{bit_xor}%
\indexlibrarymember{first_argument_type}{bit_xor}%
\indexlibrarymember{second_argument_type}{bit_xor}%
\indexlibrarymember{result_type}{bit_not}%
\indexlibrarymember{argument_type}{bit_not}%
\indexlibrarymember{result_type}{function}%
\indexlibrarymember{argument_type}{function}%
\indexlibrarymember{first_argument_type}{function}%
\indexlibrarymember{second_argument_type}{function}%
\begin{codeblock}
namespace std {
  template<class T> struct owner_less<shared_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = shared_ptr<T>;
    using second_argument_type = shared_ptr<T>;
  };

  template<class T> struct owner_less<weak_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = weak_ptr<T>;
    using second_argument_type = weak_ptr<T>;
  };

  template <class T> class reference_wrapper {
  public :
    using result_type          = @\seebelow@; // not always defined
    using argument_type        = @\seebelow@; // not always defined
    using first_argument_type  = @\seebelow@; // not always defined
    using second_argument_type = @\seebelow@; // not always defined
  };

  template <class T> struct plus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct minus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct multiplies {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct divides {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct modulus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct negate {
    using argument_type = T;
    using result_type   = T;
  };

  template <class T> struct equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct not_equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct greater {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct less {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct greater_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct less_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct logical_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct logical_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template <class T> struct logical_not {
    using argument_type = T;
    using result_type   = bool;
  };

  template <class T> struct bit_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct bit_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct bit_xor {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template <class T> struct bit_not {
    using argument_type = T;
    using result_type   = T;
  };

  template<class R, class T1>
  class function<R(T1)> {
  public:
    using argument_type = T1;
  };

  template<class R, class T1, class T2>
  class function<R(T1, T2)> {
  public:
    using first_argument_type  = T1;
    using second_argument_type = T2;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{reference_wrapper}!weak result type}%
\pnum
\tcode{reference_wrapper<T>} has a weak result type~(\ref{depr.weak.result_type}).
If \tcode{T} is a function type,
\tcode{result_type} shall be a synonym for the return type of \tcode{T}.

\indexlibrarymember{argument_type}{reference_wrapper}%
\pnum
The template specialization \tcode{reference_wrapper<T>}
shall define a nested type named \tcode{argument_type}
as a synonym for \tcode{T1}
only if the type \tcode{T} is any of the following:
\begin{itemize}
\item a function type or a pointer to function type taking one argument of type \tcode{T1}
% FIXME: Should this be R T0::f() ?
\item a pointer to member function \tcode{R T0::f} \cv{} (where \cv{} represents the member function's cv-qualifiers); the type \tcode{T1} is \cv{} \tcode{T0*}
\item a class type where the \grammarterm{qualified-id} \tcode{T::argument_type}
is valid and denotes a type~(\ref{temp.deduct});
the type \tcode{T1} is \tcode{T::argument_type}.
\end{itemize}

\indexlibrarymember{first_argument_type}{reference_wrapper}%
\indexlibrarymember{second_argument_type}{reference_wrapper}%
\pnum
The template instantiation \tcode{reference_wrapper<T>}
shall define two nested types
named \tcode{first_argument_type} and \tcode{second_argument_type}
as synonyms for \tcode{T1} and \tcode{T2}, respectively,
only if the type \tcode{T} is any of the following:
\begin{itemize}
\item a function type or a pointer to function type taking two arguments of types \tcode{T1} and \tcode{T2}
\item a pointer to member function \tcode{R T0::f(T2)} \cv{} (where \cv{} represents the member function's cv-qualifiers); the type \tcode{T1} is \cv{} \tcode{T0*}
\item a class type where the \grammarterm{qualified-id}{s}
\tcode{T::first_argument_type} and \tcode{T::second_argument_type}
are both valid and both denote types~(\ref{temp.deduct});
the type \tcode{T1} is \tcode{T::first_argument_type} and
the type \tcode{T2} is \tcode{T::second_argument_type}.
\end{itemize}

\indexlibrarymember{result_type}{hash}%
\indexlibrarymember{argument_type}{hash}%
\pnum
For all object types \tcode{Key} for which there exists a specialization \tcode{hash<Key>},
and for all enumeration types~(\ref{dcl.enum}) \tcode{Key},
the instantiation \tcode{hash<Key>} shall provide two nested types,
\tcode{result_type} and \tcode{argument_type},
which shall be synonyms for \tcode{size_t} and \tcode{Key}, respectively.

\indexlibrary{\idxcode{bind}!weak result type}%
\pnum
The forwarding call wrapper \tcode{g}
returned by a call to \tcode{bind(f, bound_args...)}~(\ref{func.bind.bind})
shall have a weak result type~(\ref{depr.weak.result_type}).

\pnum
The forwarding call wrapper \tcode{g}
returned by a call to \tcode{bind<R>(f, bound_args...)}~(\ref{func.bind.bind})
shall have a nested type \tcode{result_type} defined as a synonym for \tcode{R}.

\indexlibrarymember{result_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall have a nested type \tcode{result_type}
that is a synonym for
the return type of \tcode{pm}
when \tcode{pm} is a pointer to member function.

\indexlibrarymember{result_type}{mem_fn}%
\indexlibrarymember{argument_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall define two nested types
named \tcode{argument_type} and \tcode{result_type}
as synonyms for \cv{} \tcode{T*} and \tcode{Ret}, respectively,
when \tcode{pm} is a pointer to member function
with cv-qualifier \cv{}
and taking no arguments,
where \tcode{Ret} is \tcode{pm}{'s} return type.

\indexlibrarymember{result_type}{mem_fn}%
\indexlibrarymember{first_argument_type}{mem_fn}%
\indexlibrarymember{second_argument_type}{mem_fn}%
\pnum
The simple call wrapper
returned from a call to \tcode{mem_fn(pm)}
shall define three nested types
named \tcode{first_argument_type}, \tcode{second_argument_type}, and \tcode{result_type}
as synonyms for \cv{} \tcode{T*}, \tcode{T1}, and \tcode{Ret}, respectively,
when \tcode{pm} is a pointer to member function
with cv-qualifier \cv{}
and taking one argument of type \tcode{T1},
where \tcode{Ret} is \tcode{pm}{'s} return type.

\pnum
The following member names are defined in addition to names specified in Clause~\ref{containers}:

\indexlibrarymember{result_type}{map::value_compare}%
\indexlibrarymember{first_argument_type}{map::value_compare}%
\indexlibrarymember{second_argument_type}{map::value_compare}%
\indexlibrarymember{result_type}{multimap::value_compare}%
\indexlibrarymember{first_argument_type}{multimap::value_compare}%
\indexlibrarymember{second_argument_type}{multimap::value_compare}%
\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare, class Allocator>
  class map<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };

  template <class Key, class T, class Compare, class Allocator>
  class multimap<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };
}
\end{codeblock}

\rSec2[depr.negators]{Negators}

\pnum
The header
\indexlibrary{\idxhdr{functional}}%
\tcode{<functional>} has the following additions:

\indexlibrary{\idxcode{unary_negate}}%
\indexlibrary{\idxcode{not1}}%
\indexlibrary{\idxcode{binary_negate}}%
\indexlibrary{\idxcode{not2}}%
\begin{codeblock}
namespace std {
  template <class Predicate> class unary_negate;
  template <class Predicate>
    constexpr unary_negate<Predicate> not1(const Predicate&);
  template <class Predicate> class binary_negate;
  template <class Predicate>
    constexpr binary_negate<Predicate> not2(const Predicate&);
}
\end{codeblock}

\pnum
Negators \tcode{not1} and \tcode{not2}
take a unary and a binary predicate, respectively,
and return their logical negations~(\ref{expr.unary.op}).

\indexlibrary{\idxcode{unary_negate}}%
\indexlibrarymember{argument_type}{unary_negate}%
\indexlibrarymember{result_type}{unary_negate}%
\begin{codeblock}
template <class Predicate>
class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::argument_type& x) const;
  using argument_type = typename Predicate::argument_type;
  using result_type   = bool;
};
\end{codeblock}

\indexlibrarymember{operator()}{unary_negate}%
\begin{itemdecl}
constexpr bool operator()(const typename Predicate::argument_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!pred(x)}.
\end{itemdescr}

\indexlibrary{\idxcode{not1}}%
\begin{itemdecl}
template <class Predicate>
   constexpr unary_negate<Predicate> not1(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{unary_negate<Predicate>(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{binary_negate}}%
\indexlibrarymember{first_argument_type}{binary_negate}%
\indexlibrarymember{second_argument_type}{binary_negate}%
\indexlibrarymember{result_type}{binary_negate}%
\begin{codeblock}
template <class Predicate>
class binary_negate {
public:
  constexpr explicit binary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::first_argument_type& x,
                            const typename Predicate::second_argument_type& y) const;
  using first_argument_type  = typename Predicate::first_argument_type;
  using second_argument_type = typename Predicate::second_argument_type;
  using result_type          = bool;

};
\end{codeblock}

\indexlibrarymember{operator()}{binary_negate}%
\begin{itemdecl}
constexpr bool operator()(const typename Predicate::first_argument_type& x,
                          const typename Predicate::second_argument_type& y) const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{!pred(x,y)}.
\end{itemdescr}

\indexlibrary{\idxcode{not2}}%
\begin{itemdecl}
template <class Predicate>
  constexpr binary_negate<Predicate> not2(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{binary_negate<Predicate>(pred)}.
\end{itemdescr}

\rSec1[depr.default.allocator]{The default allocator}

\pnum
The following members and explicit class template specialization are defined in
addition to those specified in \ref{default.allocator}:

\indexlibrary{\idxcode{allocator}}%
\begin{codeblock}
namespace std {
  // specialize for \tcode{void}:
  template <> class allocator<void> {
  public:
    using value_type    = void;
    using pointer       = void*;
    using const_pointer = const void*;
    // reference-to-\tcode{void} members are impossible.

    template <class U> struct rebind { using other = allocator<U>; };
  };

  template <class T> class allocator {
   public:
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&;
    using const_reference = const T&;
    template <class U> struct rebind { using other = allocator<U>; };

    T* address(T& x) const noexcept;
    const T* address(const T& x) const noexcept;

    T* allocate(size_t n, const void* hint);

    template<class U, class... Args>
      void construct(U* p, Args&&... args);
    template <class U>
      void destroy(U* p);

    size_t max_size() const noexcept;
  };
}
\end{codeblock}

\indexlibrarymember{address}{allocator}%
\begin{itemdecl}
T* address(T& x) const noexcept;
const T* address(const T& x) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The actual address of the object referenced by \tcode{x}, even in the presence of an
overloaded operator\&.
\end{itemdescr}

\indexlibrarymember{allocate}{allocator}%
\begin{itemdecl}
T* allocate(size_t n, const void* hint);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the initial element of an array of storage of size \tcode{n}
\tcode{* sizeof(T)}, aligned appropriately for objects of type \tcode{T}.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported~(\ref{basic.align}).

\pnum
\remarks
the storage is obtained by calling \tcode{::operator new(std::size_t)}~(\ref{new.delete}),
but it is unspecified when or how often this function is called.

\pnum
\throws
\tcode{bad_alloc} if the storage cannot be obtained.
\end{itemdescr}

\indexlibrarymember{construct}{allocator}%
\begin{itemdecl}
template <class U, class... Args>
  void construct(U* p, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by: \tcode{::new((void *)p) U(std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibrarymember{destroy}{allocator}%
\begin{itemdecl}
template <class U>
  void destroy(U* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{p->\~{}U()}.
\end{itemdescr}

\indexlibrarymember{max_size}{allocator}%
\begin{itemdecl}
size_t max_size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The largest value \textit{N} for which the call \tcode{allocate(N, 0)}
might succeed.
\end{itemdescr}

\rSec1[depr.storage.iterator]{Raw storage iterator}

\pnum
The header
\indexlibrary{\idxhdr{memory}}%
\tcode{<memory>} has the following addition:

\indexlibrary{\idxcode{raw_storage_iterator}}%
\begin{codeblock}
namespace std {
  template <class OutputIterator, class T>
  class raw_storage_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator& operator*();
    raw_storage_iterator& operator=(const T& element);
    raw_storage_iterator& operator=(T&& element);
    raw_storage_iterator& operator++();
    raw_storage_iterator  operator++(int);
    OutputIterator base() const;
  };
}
\end{codeblock}

\pnum
\tcode{raw_storage_iterator} is provided to enable algorithms to store their
results into uninitialized memory. The template parameter
\tcode{OutputIterator} is required to have its \tcode{operator*} return an
object for which \tcode{operator\&} is defined and returns a pointer to
\tcode{T}, and is also required to satisfy the requirements of an output
iterator~(\ref{output.iterators}).

\indexlibrary{\idxcode{raw_storage_iterator}!constructor}%
\begin{itemdecl}
explicit raw_storage_iterator(OutputIterator x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the iterator to point to the same value to which \tcode{x} points.
\end{itemdescr}

\indexlibrarymember{operator*}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrarymember{operator=}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator=(const T& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{T} shall be \tcode{CopyConstructible}.

\pnum
\effects
Constructs a value from \tcode{element} at the location to which the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrarymember{operator=}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator=(T&& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{T} shall be \tcode{MoveConstructible}.

\pnum
\effects
Constructs a value from \tcode{std::move(element)} at the location to which
the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrarymember{operator++}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Pre-increment:  advances the iterator and returns a reference to the updated iterator.
\end{itemdescr}

\indexlibrarymember{operator++}{raw_storage_iterator}%
\begin{itemdecl}
raw_storage_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Post-increment:  advances the iterator and returns the old value of the iterator.
\end{itemdescr}

\indexlibrarymember{base}{raw_storage_iterator}%
\begin{itemdecl}
OutputIterator base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An iterator of type \tcode{OutputIterator} that points to the same value as
\tcode{*this} points to.
\end{itemdescr}

\rSec1[depr.temporary.buffer]{Temporary buffers}

\pnum
The header
\indexlibrary{\idxhdr{memory}}%
\tcode{<memory>} has the following additions:

\begin{codeblock}
namespace std {
  template <class T>
    pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
  template <class T>
    void return_temporary_buffer(T* p);
}
\end{codeblock}

\indexlibrary{\idxcode{get_temporary_buffer}}%
\begin{itemdecl}
template <class T>
  pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Obtains a pointer to uninitialized, contiguous storage for $N$ adjacent
objects of type \tcode{T}, for some non-negative number $N$.
It is \impldef{support for over-aligned types} whether over-aligned types are
supported~(\ref{basic.align}).

\pnum
\remarks
Calling \tcode{get_temporary_buffer} with a positive number \tcode{n} is
a non-binding request to return storage for \tcode{n} objects of type \tcode{T}.
In this case, an implementation is permitted to return instead storage for
a non-negative number $N$ of such objects,
where \tcode{$N$ != n} (including \tcode{$N$ == 0}).
\begin{note} The request is non-binding to allow latitude for
implementation-specific optimizations of its memory management. \end{note}

\pnum
\returns
If \tcode{n <= 0} or if no storage could be obtained,
returns a pair \tcode{P} such that
\tcode{P.first} is a null pointer value and \tcode{P.second == 0};
otherwise returns a pair \tcode{P} such that
\tcode{P.first} refers to the address of the uninitialized storage and
\tcode{P.second} refers to its capacity $N$ (in the units of \tcode{sizeof(T)}).
\end{itemdescr}

\indexlibrary{\idxcode{return_temporary_buffer}}%
\begin{itemdecl}
template <class T> void return_temporary_buffer(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Deallocates the storage referenced by \tcode{p}.

\pnum
\requires
\tcode{p} shall be a pointer value returned by an earlier call to
\tcode{get_temporary_buffer} that has not been invalidated by
an intervening call to \tcode{return_temporary_buffer(T*)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec1[depr.meta.types]{Deprecated Type Traits}

\pnum
The header
\indexlibrary{\idxhdr{type_traits}}%
\tcode{<type_traits>} has the following addition:

\indexlibrary{\idxcode{is_literal_type}}%
\begin{codeblock}
namespace std {
  template <class T> struct is_literal_type;

  template <class T> constexpr bool is_literal_type_v = is_literal_type<T>::value;
}
\end{codeblock}

\pnum
\requires
\tcode{remove_all_extents_t<T>} shall be a complete type or (possibly
cv-qualified) \tcode{void}.

\pnum
\effects
\tcode{is_literal_type} has a base-characteristic of \tcode{true_type} if
\tcode{T} is a literal type~(\ref{basic.types}), and a base-characteristic of
\tcode{false_type} otherwise.

\rSec1[depr.iterator.primitives]{Deprecated Iterator primitives}

\rSec2[depr.iterator.basic]{Basic iterator}

\pnum
The header
\indexlibrary{\idxhdr{iterator}}%
\tcode{<iterator>} has the following addition:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
    class Pointer = T*, class Reference = T&>
  struct iterator {
    using iterator_category = Category;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = Pointer;
    using reference         = Reference;
  };
}
\end{codeblock}

\pnum
The
\tcode{iterator}
template may be used as a base class to ease the definition of required types
for new iterators.

\pnum
\begin{note} If the new iterator type is a class template, then these aliases
will not be visible from within the iterator class's template definition, but
only to callers of that class.\end{note}
 
\pnum
\begin{example}
If a \Cpp program wants to define a bidirectional iterator for some data
structure containing \tcode{double} and such that it works on a large memory
model of the implementation, it can do so with:

\begin{codeblock}
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // code implementing \tcode{++}, etc.
};
\end{codeblock}
\end{example}
