%!TEX root = std.tex
\normannex{depr}{Compatibility features}

\pnum
This Clause describes features of the \Cpp{} Standard that are specified for compatibility with
existing implementations.

\pnum
These are deprecated features, where
\term{deprecated}
is defined as:
Normative for the current edition of this International Standard,
but having been identified as a candidate for removal from future revisions.
An implementation may declare library names and entities described in this Clause with the
\tcode{deprecated} attribute\iref{dcl.attr.deprecated}.

\rSec1[depr.static_constexpr]{Redeclaration of \tcode{static constexpr} data members}

\pnum
For compatibility with prior \Cpp{} International Standards, a \tcode{constexpr}
static data member may be redundantly redeclared outside the class with no initializer.
This usage is deprecated.
\begin{example}
\begin{codeblock}
struct A {
  static constexpr int n = 5;  // definition (declaration in \CppXIV{})
};

constexpr int A::n;  // redundant declaration (definition in \CppXIV{})
\end{codeblock}
\end{example}

\rSec1[depr.impldec]{Implicit declaration of copy functions}

\pnum
The implicit definition of a copy constructor
as defaulted
is deprecated if the class has a
user-declared copy assignment operator or a user-declared destructor. The implicit
definition of a copy assignment operator
as defaulted is deprecated if the class has a user-declared
copy constructor or a user-declared destructor~(\ref{class.dtor}, \ref{class.copy}).
In a future revision of this International Standard, these implicit definitions
could become deleted\iref{dcl.fct.def}.

\rSec1[depr.c.headers]{C standard library headers}

\pnum
For compatibility with the
\indextext{library!C standard}%
C standard library, the \Cpp{} standard library provides
the \defnx{C headers}{headers!C library} shown in \tref{future.c.headers}.

\begin{floattable}{C headers}{tab:future.c.headers}
{lllll}
\topline

\tcode{<assert.h>}			&
\tcode{<inttypes.h>}		&
\tcode{<signal.h>}			&
\tcode{<stdio.h>}			  &
\tcode{<wchar.h>}			  \\

\tcode{<complex.h>}			&
\tcode{<iso646.h>}			&
\tcode{<stdalign.h>}    &
\tcode{<stdlib.h>}			&
\tcode{<wctype.h>}			\\

\tcode{<ctype.h>}			  &
\tcode{<limits.h>}			&
\tcode{<stdarg.h>}			&
\tcode{<string.h>}			& \\

\tcode{<errno.h>}			  &
\tcode{<locale.h>}			&
\tcode{<stdbool.h>}			&
\tcode{<tgmath.h>}			& \\

\tcode{<fenv.h>}			  &
\tcode{<math.h>}			  &
\tcode{<stddef.h>}			&
\tcode{<time.h>}				& \\

\tcode{<float.h>}			  &
\tcode{<setjmp.h>}			&
\tcode{<stdint.h>}			&
\tcode{<uchar.h>}			  & \\

\end{floattable}

\pnum
The header \tcode{<complex.h>} behaves as if it simply includes the header \tcode{<complex>}\iref{complex.syn}.
The header \tcode{<tgmath.h>} behaves as if it simply includes the headers \tcode{<complex>}\iref{complex.syn}
and \tcode{<cmath>}\iref{cmath.syn}.

\pnum
Every other C header, each of
which has a name of the form
\indextext{header!C}%
\tcode{name.h},
behaves as if each name placed in the standard library namespace by
the corresponding
\tcode{c\textit{name}}
header is placed within
the global namespace scope,
except for the functions described in \ref{sf.cmath},
the declaration of \tcode{std::byte}\iref{cstddef.syn}, and
the functions and function templates described in \ref{support.types.byteops}.
It is unspecified whether these names are first declared or defined within
namespace scope\iref{basic.scope.namespace} of the namespace
\tcode{std} and are then injected into the global namespace scope by
explicit \grammarterm{using-declaration}{s}\iref{namespace.udecl}.
\indextext{namespace}%

\pnum
\begin{example}
The header
\indexhdr{cstdlib}%
\indexhdr{stdlib.h}%
\tcode{<cstdlib>} assuredly
provides its declarations and definitions within the namespace
\tcode{std}. It may also provide these names within the
global namespace.
The header
\tcode{<stdlib.h>}
assuredly provides the same declarations and definitions within
the global namespace,
much as in the C Standard. It may also provide these names within
the namespace \tcode{std}.
\end{example}

\rSec1[depr.relops]{Relational operators}

\pnum
The header \tcode{<utility>}
\indexhdr{utility}%
has the following additions:

\begin{codeblock}
namespace std::rel_ops {
  template<class T> bool operator!=(const T&, const T&);
  template<class T> bool operator> (const T&, const T&);
  template<class T> bool operator<=(const T&, const T&);
  template<class T> bool operator>=(const T&, const T&);
}
\end{codeblock}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\indexlibrary{\idxcode{operator"!=}}%
\begin{itemdecl}
template<class T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{EqualityComparable} (\tref{equalitycomparable}).

\pnum
\returns
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}}%
\begin{itemdecl}
template<class T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\tref{lessthancomparable}).

\pnum
\returns
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}}%
\begin{itemdecl}
template<class T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\tref{lessthancomparable}).

\pnum
\returns
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}}%
\begin{itemdecl}
template<class T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\tref{lessthancomparable}).

\pnum
\returns
\tcode{!(x < y)}.
\end{itemdescr}

\rSec1[depr.str.strstreams]{\tcode{char*} streams}

\rSec2[depr.strstream.syn]{Header \tcode{<strstream>} synopsis}

\pnum
The header
\indexhdr{strstream}%
\tcode{<strstream>}
defines types that associate stream buffers with
character array objects and assist reading and writing such objects.

\begin{codeblock}
namespace std {
  class strstreambuf;
  class istrstream;
  class ostrstream;
  class strstream;
}
\end{codeblock}

\rSec2[depr.strstreambuf]{Class \tcode{strstreambuf}}

\indexlibrary{\idxcode{strstreambuf}}%
\begin{codeblock}
namespace std {
  class strstreambuf : public basic_streambuf<char> {
  public:
    explicit strstreambuf(streamsize alsize_arg = 0);
    strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
    strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
    strstreambuf(const char* gnext_arg, streamsize n);

    strstreambuf(signed char* gnext_arg, streamsize n,
                 signed char* pbeg_arg = nullptr);
    strstreambuf(const signed char* gnext_arg, streamsize n);
    strstreambuf(unsigned char* gnext_arg, streamsize n,
                 unsigned char* pbeg_arg = nullptr);
    strstreambuf(const unsigned char* gnext_arg, streamsize n);

    virtual ~strstreambuf();

    void  freeze(bool freezefl = true);
    char* str();
    int   pcount();

  protected:
    int_type overflow (int_type c = EOF) override;
    int_type pbackfail(int_type c = EOF) override;
    int_type underflow() override;
    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    streambuf* setbuf(char* s, streamsize n) override;

  private:
    using strstate = T1;              // \expos
    static const strstate allocated;  // \expos
    static const strstate constant;   // \expos
    static const strstate dynamic;    // \expos
    static const strstate frozen;     // \expos
    strstate strmode;                 // \expos
    streamsize alsize;                // \expos
    void* (*palloc)(size_t);          // \expos
    void (*pfree)(void*);             // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstreambuf}
associates the input sequence, and possibly the output sequence, with an object of some
\textit{character}
array type, whose elements store arbitrary values.
The array object has several attributes.

\pnum
\begin{note}
For the sake of exposition, these are represented as elements of a bitmask type
(indicated here as \tcode{T1}) called \tcode{strstate}.
The elements are:
\begin{itemize}
\item
\tcode{allocated}, set when a dynamic array object has been
allocated, and hence should be freed by the destructor for the
\tcode{strstreambuf} object;
\item
\tcode{constant}, set when the array object has
\tcode{const} elements, so the output sequence cannot be written;
\item
\tcode{dynamic}, set when the array object is allocated
(or reallocated)
as necessary to hold a character sequence that can change in length;
\item
\tcode{frozen}, set when the program has requested that the
array object not be altered, reallocated, or freed.
\end{itemize}
\end{note}

\pnum
\begin{note}
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{strstate strmode}, the attributes of the array object
associated with the \tcode{strstreambuf} object;
\item
\tcode{int alsize}, the suggested minimum size for a
dynamic array object;
\item
\tcode{void* (*palloc)(size_t)}, points to the function
to call to allocate a dynamic array object;
\item
\tcode{void (*pfree)(void*)}, points to the function to
call to free a dynamic array object.
\end{itemize}
\end{note}

\pnum
Each object of class
\tcode{strstreambuf}
has a
\term{seekable area},
delimited by the pointers \tcode{seeklow} and \tcode{seekhigh}.
If \tcode{gnext} is a null pointer, the seekable area is undefined.
Otherwise, \tcode{seeklow} equals \tcode{gbeg} and
\tcode{seekhigh} is either \tcode{pend},
if \tcode{pend} is not a null pointer, or \tcode{gend}.

\rSec3[depr.strstreambuf.cons]{\tcode{strstreambuf} constructors}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
explicit strstreambuf(streamsize alsize_arg = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in \tref{future.strstreambuf.effects}.
\end{itemdescr}

\begin{libtab2}{\tcode{strstreambuf(streamsize)} effects}{tab:future.strstreambuf.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}		\\
\tcode{alsize}	&	\tcode{alsize_arg}	\\
\tcode{palloc}	&	a null pointer		\\
\tcode{pfree}	&	a null pointer		\\
\end{libtab2}

\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in \tref{future.strstreambuf1.effects}.

\begin{libtab2}{\tcode{strstreambuf(void* (*)(size_t), void (*)(void*))} effects}
{tab:future.strstreambuf1.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}			\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	\tcode{palloc_arg}		\\
\tcode{pfree}	&	\tcode{pfree_arg}		\\
\end{libtab2}
\end{itemdescr}

\indextext{unspecified}%
\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
strstreambuf(signed char* gnext_arg, streamsize n,
             signed char* pbeg_arg = nullptr);
strstreambuf(unsigned char* gnext_arg, streamsize n,
             unsigned char* pbeg_arg = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstreambuf},
initializing the base class with
\tcode{streambuf()}.
The postconditions of this function are indicated in \tref{future.strstreambuf2.effects}.

\begin{libtab2}{\tcode{strstreambuf(charT*, streamsize, charT*)} effects}
{tab:future.strstreambuf2.effects}
{ll}
{Element}{Value}
\tcode{strmode}	&	0						\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	a null pointer			\\
\tcode{pfree}	&	a null pointer			\\
\end{libtab2}

\pnum
\tcode{gnext_arg} shall point to the first element of an array
object whose number of elements \tcode{N} is determined as follows:
\begin{itemize}
\item
If
\tcode{n > 0},
\tcode{N} is \tcode{n}.
\item
If
\tcode{n == 0},
\tcode{N} is
\tcode{std::strlen(gnext_arg)}.
\indexlibrary{\idxcode{strlen}}%
\item
If
\tcode{n < 0},
\tcode{N} is
\tcode{INT_MAX}.\footnote{The function signature
\indexlibrary{\idxcode{strlen}}%
\tcode{strlen(const char*)}
is declared in
\indexhdr{cstring}%
\tcode{<cstring>}\iref{cstring.syn}.
The macro
\tcode{INT_MAX}
is defined in
\indexhdr{climits}%
\tcode{<climits>}\iref{climits.syn}.}
\end{itemize}

\pnum
If \tcode{pbeg_arg} is a null pointer, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, gnext_arg + N);
\end{codeblock}

\pnum
Otherwise, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, pbeg_arg);
setp(pbeg_arg,  pbeg_arg + N);
\end{codeblock}
\end{itemdescr}


\indexlibrary{\idxcode{strstreambuf}!constructor}%
\begin{itemdecl}
strstreambuf(const char* gnext_arg, streamsize n);
strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(const unsigned char* gnext_arg, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves the same as
\tcode{strstreambuf((char*)gnext_arg,n)},
except that the constructor also sets \tcode{constant} in \tcode{strmode}.
\end{itemdescr}

\indexlibrary{\idxcode{strstreambuf}!destructor}%
\begin{itemdecl}
virtual ~strstreambuf();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstreambuf}.
The function frees the dynamically allocated array object only if
\tcode{(strmode \& allocated) != 0}
and
\tcode{(strmode \& frozen) == 0}.~(\ref{depr.strstreambuf.virtuals} describes how a dynamically allocated array object is freed.)
\end{itemdescr}

\rSec3[depr.strstreambuf.members]{Member functions}

\indexlibrarymember{freeze}{strstreambuf}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{strmode \& dynamic} is nonzero, alters the
freeze status of the dynamic array object as follows:
\begin{itemize}
\item
If \tcode{freezefl} is
\tcode{true},
the function sets \tcode{frozen} in \tcode{strmode}.
\item
Otherwise, it clears \tcode{frozen} in \tcode{strmode}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{str}{strstreambuf}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{freeze()},
then returns the beginning pointer for the input sequence, \tcode{gbeg}.

\pnum
\remarks
The return value can be a null pointer.
\end{itemdescr}

\indexlibrarymember{pcount}{strstreambuf}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the next pointer for the output sequence, \tcode{pnext}, is
a null pointer, returns zero.
Otherwise, returns the current
effective length of the array object as the next pointer minus the beginning
pointer for the output sequence, \tcode{pnext - pbeg}.
\end{itemdescr}

\rSec3[depr.strstreambuf.virtuals]{\tcode{strstreambuf} overridden virtual functions}

\indexlibrarymember{overflow}{strstreambuf}%
\begin{itemdecl}
int_type overflow(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Appends the character designated by \tcode{c} to the output
sequence, if possible, in one of two ways:
\begin{itemize}
\item
If
\tcode{c != EOF}
and if either the output sequence has a write position available or
the function makes a write position available
(as described below),
assigns \tcode{c} to
\tcode{*pnext++}.

Returns
\tcode{(unsigned char)c}.

\item
If
\tcode{c == EOF},
there is no character to append.

Returns a value other than \tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of write positions available as a
result of any call.

\pnum
To make a write position available, the function reallocates
(or initially allocates)
an array object with a sufficient number of elements
\tcode{n} to hold the current array object (if any),
plus at least one additional write position.
How many additional write positions are made
available is otherwise unspecified.%
\indextext{unspecified}%
\footnote{An implementation should consider \tcode{alsize} in making this
decision.}
If \tcode{palloc} is not a null pointer, the function calls
\tcode{(*palloc)(n)}
to allocate the new dynamic array object.
Otherwise, it evaluates the expression
\tcode{new charT[n]}.
In either case, if the allocation fails, the function returns
\tcode{EOF}.
Otherwise, it sets \tcode{allocated} in \tcode{strmode}.

\pnum
To free a previously existing dynamic array object whose first
element address is \tcode{p}:
If \tcode{pfree} is not a null pointer,
the function calls
\tcode{(*pfree)(p)}.
Otherwise, it evaluates the expression \tcode{delete[]p}.

\pnum
If
\tcode{(strmode \& dynamic) == 0},
or if
\tcode{(strmode \& frozen) != 0},
the function cannot extend the array (reallocate it with greater length) to make a write position available.
\end{itemdescr}

\indexlibrarymember{pbackfail}{strstreambuf}%
\begin{itemdecl}
int_type pbackfail(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
Puts back the character designated by \tcode{c} to the input
sequence, if possible, in one of three ways:
\begin{itemize}
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{(char)c == gnext[-1]},
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns \tcode{c}.
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{strmode \& constant} is zero,
assigns \tcode{c} to
\tcode{*\dcr{}gnext}.

Returns
\tcode{c}.
\item
If
\tcode{c == EOF}
and if the input sequence has a putback position available,
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns a value other than
\tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.
\indextext{unspecified}%
The function can alter the number of putback
positions available as a result of any call.
\end{itemdescr}

\indexlibrarymember{underflow}{strstreambuf}%
\begin{itemdecl}
int_type underflow() override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads a character from the
\term{input sequence},
if possible, without moving the stream position past it, as follows:
\begin{itemize}
\item
If the input sequence has a read position available, the function
signals success by returning
\tcode{(unsigned char)\brk*gnext}.
\item
Otherwise, if
the current write next pointer \tcode{pnext} is not a null pointer and
is greater than the current read end pointer \tcode{gend},
makes a
\term{read position}
available by
assigning to \tcode{gend} a value greater than \tcode{gnext} and
no greater than \tcode{pnext}.

Returns \tcode{(unsigned char)*gnext}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of read positions available as a
result of any call.
\end{itemdescr}

\indexlibrarymember{seekoff}{strstreambuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, seekdir way, openmode which = in | out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, as indicated in \tref{future.seekoff.positioning}.

\begin{libtab2}{\tcode{seekoff} positioning}{tab:future.seekoff.positioning}
{p{2.5in}l}{Conditions}{Result}
\tcode{(which \& ios::in) != 0}	&
 positions the input sequence	\\ \rowsep
\tcode{(which \& ios::out) != 0}	&
 positions the output sequence	\\ \rowsep
\tcode{(which \& (ios::in |}\br
\tcode{ios::out)) == (ios::in |}\br
\tcode{ios::out))} and\br
\tcode{way ==} either\br
\tcode{ios::beg} or\br
\tcode{ios::end}			&
 positions both the input and the output sequences	\\ \rowsep
Otherwise	&
 the positioning operation fails.	\\
\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} as indicated in
\tref{future.newoff.values}.

\begin{libtab2}{\tcode{newoff} values}{tab:future.newoff.values}
{p{2.0in}p{2.0in}}{Condition}{\tcode{newoff} Value}
\tcode{way == ios::beg}	&
 0	\\ \rowsep
\tcode{way == ios::cur}	&
 the next pointer minus the beginning pointer (\tcode{xnext - xbeg}).	\\ \rowsep
\tcode{way == ios::end}	&
 \tcode{seekhigh} minus the beginning pointer (\tcode{seekhigh - xbeg}).	\\
\end{libtab2}

\pnum
If \tcode{(newoff + off) < (seeklow - xbeg)}
or \tcode{(seekhigh - xbeg) < (newoff + off)},
the positioning operation fails.
Otherwise, the function assigns
\tcode{xbeg + newoff + off}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset
\tcode{newoff} (of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{seekpos}{strstreambuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp, ios_base::openmode which
                  = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, to correspond to the
stream position stored in \tcode{sp}
(as described below).
\begin{itemize}
\item
If
\tcode{(which \& ios::in) != 0},
positions the input sequence.
\item
If
\tcode{(which \& ios::out) != 0},
positions the output sequence.
\item
If the function positions neither sequence, the positioning operation fails.
\end{itemize}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} from
\tcode{sp.offset()}:
\begin{itemize}
\item
If \tcode{newoff} is an invalid stream position,
has a negative value, or
has a value greater than (\tcode{seekhigh - seeklow}),
the positioning operation fails
\item
Otherwise, the function
adds \tcode{newoff} to the beginning pointer \tcode{xbeg} and
stores the result in the next pointer \tcode{xnext}.
\end{itemize}

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset \tcode{newoff}
(of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{setbuf}{strstreambuf}%
\begin{itemdecl}
streambuf<char>* setbuf(char* s, streamsize n) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Implementation defined, except that
\tcode{setbuf(0, 0)}
has no effect.%
\end{itemdescr}

\rSec2[depr.istrstream]{Class \tcode{istrstream}}

\indexlibrary{\idxcode{istrstream}}%
\begin{codeblock}
namespace std {
  class istrstream : public basic_istream<char> {
  public:
    explicit istrstream(const char* s);
    explicit istrstream(char* s);
    istrstream(const char* s, streamsize n);
    istrstream(char* s, streamsize n);
    virtual ~istrstream();

    strstreambuf* rdbuf() const;
    char* str();
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{istrstream}
supports the reading of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.istrstream.cons]{\tcode{istrstream} constructors}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
explicit istrstream(const char* s);
explicit istrstream(char* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,0)}.
\tcode{s} shall designate the first element of an \ntbs{}.%
\indextext{NTBS}
\end{itemdescr}

\indexlibrary{\idxcode{istrstream}!constructor}%
\begin{itemdecl}
istrstream(const char* s, streamsize n);
istrstream(char* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{istrstream},
initializing the base class with
\tcode{istream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf(s,n)}.
\tcode{s} shall designate the first element of an array whose length is
\tcode{n} elements, and \tcode{n} shall be greater than zero.
\end{itemdescr}

\rSec3[depr.istrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{istrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<strstreambuf*>(\&sb)}.
\end{itemdescr}

\indexlibrarymember{str}{istrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\rSec2[depr.ostrstream]{Class \tcode{ostrstream}}

\indexlibrary{\idxcode{ostrstream}}%
\begin{codeblock}
namespace std {
  class ostrstream : public basic_ostream<char> {
  public:
    ostrstream();
    ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
    virtual ~ostrstream();

    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    char* str();
    int pcount() const;
  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{ostrstream}
supports the writing of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.ostrstream.cons]{\tcode{ostrstream} constructors}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)}
and initializing \tcode{sb} with
\tcode{strstreambuf()}.
\end{itemdescr}

\indexlibrary{\idxcode{ostrstream}!constructor}%
\begin{itemdecl}
ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{ostrstream},
initializing the base class with
\tcode{ostream(\&sb)},
and initializing \tcode{sb} with one of two constructors:

\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.

The constructor is
\tcode{strstreambuf(s, n, s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements that
contains an \ntbs{} whose first element is designated by \tcode{s}.
\indextext{NTBS}%
The constructor is
\tcode{strstreambuf(s, n, s + std::strlen(s))}.\footnote{The function signature
\indexlibrary{\idxcode{strlen}}%
\tcode{strlen(const char*)}
is declared in
\indexhdr{cstring}%
\tcode{<cstring>}\iref{cstring.syn}.}
\end{itemize}
\end{itemdescr}

\rSec3[depr.ostrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{ostrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{(strstreambuf*)\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{ostrstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{ostrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{ostrstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec2[depr.strstream]{Class \tcode{strstream}}

\indexlibrary{\idxcode{strstream}}%
\begin{codeblock}
namespace std {
  class strstream
    : public basic_iostream<char> {
  public:
    // types
    using char_type = char;
    using int_type  = char_traits<char>::int_type;
    using pos_type  = char_traits<char>::pos_type;
    using off_type  = char_traits<char>::off_type;

    // constructors/destructor
    strstream();
    strstream(char* s, int n,
              ios_base::openmode mode = ios_base::in|ios_base::out);
    virtual ~strstream();

    // members
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    int pcount() const;
    char* str();

  private:
    strstreambuf sb;  // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstream}
supports reading and writing from objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.strstream.cons]{\tcode{strstream} constructors}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}.
\end{itemdescr}

\indexlibrary{\idxcode{strstream}!constructor}%
\begin{itemdecl}
strstream(char* s, int n,
          ios_base::openmode mode = ios_base::in|ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{strstream},
initializing the base class with
\tcode{iostream(\&sb)}
and initializing \tcode{sb} with one of the two constructors:
\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.
The constructor is
\tcode{strstreambuf(s,n,s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall
designate the first element of an array of \tcode{n} elements that contains
an \ntbs{} whose first element is designated by \tcode{s}.
The constructor is
\tcode{strstreambuf(s,n,s + std::strlen(s))}.
\indexlibrary{\idxcode{strstream}!destructor}%
\end{itemize}
\end{itemdescr}

\rSec3[depr.strstream.dest]{\tcode{strstream} destructor}

\indexlibrary{\idxcode{strstream}!destructor}%
\begin{itemdecl}
virtual ~strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstream}.
\end{itemdescr}

\rSec3[depr.strstream.oper]{\tcode{strstream} operations}

\indexlibrarymember{rdbuf}{strstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{strstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{strstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{strstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec1[depr.meta.types]{Deprecated type traits}

\pnum
The header
\indexhdr{type_traits}%
\tcode{<type_traits>} has the following addition:

\indexlibrary{\idxcode{is_literal_type}}%
\begin{codeblock}
namespace std {
  template<class T> struct is_pod;
  template<class T> inline constexpr bool is_pod_v = is_pod<T>::value;
}
\end{codeblock}

\pnum
The behavior of a program that adds specializations for
any of the templates defined in this subclause is undefined,
unless explicitly permitted by the specification of the corresponding template.

\begin{itemdecl}
template<class T> struct is_pod;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{remove_all_extents_t<T>} shall be a complete type or \cv{} \tcode{void}.

\pnum
\tcode{is_pod<T>} is a \tcode{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of \tcode{true_type}
if \tcode{T} is a POD type,
and \tcode{false_type} otherwise.
\indextext{POD}%
A POD class is a class that is both a trivial class and a standard-layout class,
and has no non-static data members of type non-POD class (or array thereof).
A POD type is a scalar type, a POD class, an array of such a type,
or a cv-qualified version of one of these types.

\pnum
\begin{note}
It is unspecified whether a closure type\iref{expr.prim.lambda.closure} is a POD type.
\end{note}
\end{itemdescr}

\rSec1[depr.iterator.primitives]{Deprecated iterator primitives}

\rSec2[depr.iterator.basic]{Basic iterator}

\pnum
The header
\indexhdr{iterator}%
\tcode{<iterator>} has the following addition:

\indexlibrary{\idxcode{iterator}}%
\begin{codeblock}
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
           class Pointer = T*, class Reference = T&>
  struct iterator {
    using iterator_category = Category;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = Pointer;
    using reference         = Reference;
  };
}
\end{codeblock}

\pnum
The
\tcode{iterator}
template may be used as a base class to ease the definition of required types
for new iterators.

\pnum
\begin{note} If the new iterator type is a class template, then these aliases
will not be visible from within the iterator class's template definition, but
only to callers of that class.\end{note}

\pnum
\begin{example}
If a \Cpp{} program wants to define a bidirectional iterator for some data
structure containing \tcode{double} and such that it works on a large memory
model of the implementation, it can do so with:

\begin{codeblock}
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // code implementing \tcode{++}, etc.
};
\end{codeblock}
\end{example}

\rSec1[depr.util.smartptr.shared.atomic]{Deprecated \tcode{shared_ptr} atomic access}

\pnum
The header \tcode{<memory>} has the following additions:

\indexlibrary{\idxcode{shared_ptr}}%
\begin{codeblock}
namespace std {
  template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);

  template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
  template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

  template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
  template<class T>
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
}
\end{codeblock}

\pnum
Concurrent access to a \tcode{shared_ptr} object from multiple threads does not
introduce a data race if the access is done exclusively via the functions in
this subclause and the instance is passed as their first argument.

\pnum
The meaning of the arguments of type \tcode{memory_order} is explained in~\ref{atomics.order}.

\indexlibrarymember{atomic_is_lock_free}{shared_ptr}%
\begin{itemdecl}
template<class T> bool atomic_is_lock_free(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{true} if atomic access to \tcode{*p} is lock-free, \tcode{false} otherwise.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_load_explicit(p, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_release} or \tcode{memory_order_acq_rel}.

\pnum
\returns \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects As if by \tcode{atomic_store_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order_acquire} or \tcode{memory_order_acq_rel}.

\pnum
\effects As if by \tcode{p->swap(r)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns \tcode{atomic_exchange_explicit(p, r, memory_order_seq_cst)}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects As if by \tcode{p->swap(r)}.

\pnum
\returns The previous value of \tcode{*p}.

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.

\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_weak_explicit(p, v, w, memory_order_seq_cst, memory_order_seq_cst)
\end{codeblock}

\pnum
\throws Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_strong}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_strong_explicit(p, v, w, memory_order_seq_cst, memory_order_seq_cst)
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak_explicit}{shared_ptr}%
\indexlibrarymember{atomic_compare_exchange_strong_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
template<class T>
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.
The \tcode{failure} argument shall not be \tcode{memory_order_release} nor
\tcode{memory_order_acq_rel}.

\pnum
\effects If \tcode{*p} is equivalent to \tcode{*v}, assigns \tcode{w} to
\tcode{*p} and has synchronization semantics corresponding to the value of
\tcode{success}, otherwise assigns \tcode{*p} to \tcode{*v} and has
synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns \tcode{true} if \tcode{*p} was equivalent to \tcode{*v}, \tcode{false} otherwise.

\pnum
\throws Nothing.

\pnum
\remarks Two \tcode{shared_ptr} objects are equivalent if they store the same
pointer value and share ownership.
The weak form may fail spuriously. See~\ref{atomics.types.operations}.
\end{itemdescr}

\rSec1[depr.string.capacity]{Deprecated \tcode{basic_string} capacity}

\pnum
The following member is declared in addition to those members specified
in \ref{string.capacity}:

\indexlibrary{\idxcode{basic_string}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>,
           class Allocator = allocator<charT>>
  class basic_string {
  public:
    void reserve();
  };
}
\end{codeblock}

\indexlibrarymember{reserve}{basic_string}%
\begin{itemdecl}
void reserve();
\end{itemdecl}

\begin{itemdescr}
\pnum\effects
After this call, \tcode{capacity()} has an unspecified value
greater than or equal to \tcode{size()}.
\begin{note} This is a non-binding shrink to fit request. \end{note}
\end{itemdescr}

\rSec1[depr.locale.stdcvt]{Deprecated standard code conversion facets}

\pnum
\indexhdr{codecvt}%
The header \tcode{<codecvt>} provides code conversion facets for various character encodings.

\rSec2[depr.codecvt.syn]{Header \tcode{<codecvt>} synopsis}

\indexlibrary{\idxcode{codecvt_mode}}%
\indexlibrary{\idxcode{codecvt_utf8}}%
\indexlibrary{\idxcode{codecvt_utf16}}%
\indexlibrary{\idxcode{codecvt_utf8_utf16}}%
\begin{codeblock}
namespace std {
  enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
  };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8(size_t refs = 0);
      ~codecvt_utf8();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf16(size_t refs = 0);
      ~codecvt_utf16();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8_utf16(size_t refs = 0);
      ~codecvt_utf8_utf16();
    };
}
\end{codeblock}

\rSec2[depr.locale.stdcvt.req]{Requirements}

\pnum
For each of the three code conversion facets \tcode{codecvt_utf8},
\tcode{codecvt_utf16}, and \tcode{codecvt_utf8_utf16}:
\begin{itemize}
\item
  \tcode{Elem} is the wide-character type, such as
  \tcode{wchar_t}, \tcode{char16_t}, or \tcode{char32_t}.
\item
  \tcode{Maxcode} is the largest wide-character code that the facet
  will read or write without reporting a conversion error.
\item
  If \tcode{(Mode \& consume_header)}, the facet shall consume an
  initial header sequence, if present, when reading a multibyte sequence
  to determine the endianness of the subsequent multibyte sequence to be read.
\item
  If \tcode{(Mode \& generate_header)}, the facet shall generate an
  initial header sequence when writing a multibyte sequence to advertise
  the endianness of the subsequent multibyte sequence to be written.
\item
  If \tcode{(Mode \& little_endian)}, the facet shall generate a
  multibyte sequence in little-endian order,
  as opposed to the default big-endian order.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8}\indexlibrary{\idxcode{codecvt_utf8}}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UCS2 or UCS4 (depending on the size of \tcode{Elem})
  within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf16}\indexlibrary{\idxcode{codecvt_utf16}}:
\begin{itemize}
\item
  The facet shall convert between UTF-16 multibyte sequences
  and UCS2 or UCS4 (depending on the size of \tcode{Elem})
  within the program.
\item
  Multibyte sequences shall be read or written
  according to the \tcode{Mode} flag, as set out above.
\item
  The multibyte sequences may be written only as a binary file.
  Attempting to write to a text file produces undefined behavior.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8_utf16}\indexlibrary{\idxcode{codecvt_utf8_utf16}}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UTF-16 (one or two 16-bit codes) within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\xref ISO/IEC 10646-1:1993.

\rSec1[depr.conversions]{Deprecated convenience conversion interfaces}

\pnum
The header \tcode{<locale>} has the following additions:

\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class Wide_alloc = allocator<Elem>,
           class Byte_alloc = allocator<char>>
    class wstring_convert;

  template<class Codecvt, class Elem = wchar_t,
           class Tr = char_traits<Elem>>
    class wbuffer_convert;
}
\end{codeblock}

\rSec2[depr.conversions.string]{Class template \tcode{wstring_convert}}

\pnum
Class template \tcode{wstring_convert} performs conversions between a wide
string and a byte string. It lets you specify a code conversion facet
(like class template \tcode{codecvt}) to perform the conversions, without
affecting any streams or locales. \begin{example} If you want to use the code
conversion facet \tcode{codecvt_utf8} to output to \tcode{cout} a UTF-8
multibyte sequence corresponding to a wide string, but you don't want to
alter the locale for \tcode{cout}, you can write something like:
\begin{codeblock}
wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout << mbstring;
\end{codeblock}
\end{example}

\indexlibrary{\idxcode{wstring_convert}}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class Wide_alloc = allocator<Elem>,
           class Byte_alloc = allocator<char>>
    class wstring_convert {
    public:
      using byte_string = basic_string<char, char_traits<char>, Byte_alloc>;
      using wide_string = basic_string<Elem, char_traits<Elem>, Wide_alloc>;
      using state_type  = typename Codecvt::state_type;
      using int_type    = typename wide_string::traits_type::int_type;

      explicit wstring_convert(Codecvt* pcvt = new Codecvt);
      wstring_convert(Codecvt* pcvt, state_type state);
      explicit wstring_convert(const byte_string& byte_err,
                               const wide_string& wide_err = wide_string());
      ~wstring_convert();

      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;

      wide_string from_bytes(char byte);
      wide_string from_bytes(const char* ptr);
      wide_string from_bytes(const byte_string& str);
      wide_string from_bytes(const char* first, const char* last);

      byte_string to_bytes(Elem wchar);
      byte_string to_bytes(const Elem* wptr);
      byte_string to_bytes(const wide_string& wstr);
      byte_string to_bytes(const Elem* first, const Elem* last);

      size_t converted() const noexcept;
      state_type state() const;

    private:
      byte_string byte_err_string;  // \expos
      wide_string wide_err_string;  // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
      size_t cvtcount;              // \expos
    };
}
\end{codeblock}

\pnum
The class template describes an object that controls conversions between wide
string objects of class \tcode{basic_string<Elem, char_traits<Elem>,
Wide_alloc>} and byte string objects of class \tcode{basic_string<char,
char_traits<char>, Byte_alloc>}. The class template defines the types
\tcode{wide_string} and \tcode{byte_string} as synonyms for these two types.
Conversion between a sequence of \tcode{Elem} values (stored in a
\tcode{wide_string} object) and multibyte sequences (stored in a
\tcode{byte_string} object) is performed by an object of class
\tcode{Codecvt}, which meets the
requirements of the standard code-conversion facet \tcode{codecvt<Elem,
char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{byte_err_string} --- a byte string to display on errors
\item \tcode{wide_err_string} --- a wide string to display on errors
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wstring_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\item \tcode{cvtcount} --- a conversion count
\end{itemize}

\indexlibrarymember{byte_string}{wstring_convert}%
\begin{itemdecl}
using byte_string = basic_string<char, char_traits<char>, Byte_alloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<char, char_traits<char>, Byte_alloc>}.
\end{itemdescr}

\indexlibrarymember{converted}{wstring_convert}%
\begin{itemdecl}
size_t converted() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cvtcount}.
\end{itemdescr}

\indexlibrarymember{from_bytes}{wstring_convert}%
\begin{itemdecl}
wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char* first, const char* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{byte} to a
wide string. The second member function shall convert the null-terminated
sequence beginning at \tcode{ptr} to a wide string. The third member function
shall convert the sequence stored in \tcode{str} to a wide string. The fourth member
function shall convert the sequence defined by the range \range{first}{last} to a
wide string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.

\item The number of input elements successfully converted shall be stored in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the
member function shall return the wide-error string.
Otherwise, the member function throws an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{int_type}{wstring_convert}%
\begin{itemdecl}
using int_type = typename wide_string::traits_type::int_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{wide_string::traits_type::int_type}.
\end{itemdescr}

\indexlibrarymember{state}{wstring_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
returns \tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{state_type}{wstring_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibrarymember{to_bytes}{wstring_convert}%
\begin{itemdecl}
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem* first, const Elem* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{wchar} to a byte string.
The second member function shall convert the null-terminated sequence beginning at \tcode{wptr} to
a byte string. The third member function shall convert the sequence stored in \tcode{wstr} to a
byte string. The fourth member function shall convert the sequence defined by the
range \range{first}{last} to a byte string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be
set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.
\item The number of input elements successfully converted shall be stored
in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the
member function shall return the byte-error string.
Otherwise, the member function shall throw an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{wide_string}{wstring_convert}%
\begin{itemdecl}
using wide_string = basic_string<Elem, char_traits<Elem>, Wide_alloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<Elem,
char_traits<Elem>, Wide_alloc>}.
\end{itemdescr}

\indexlibrary{\idxcode{wstring_convert}!constructor}%
\begin{itemdecl}
explicit wstring_convert(Codecvt* pcvt = new Codecvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string& byte_err,
    const wide_string& wide_err = wide_string());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For the first and second constructors, \tcode{pcvt != nullptr}.

\pnum
\effects
The first constructor shall store \tcode{pcvt} in \tcode{cvtptr} and
default values in \tcode{cvtstate}, \tcode{byte_err_string}, and
\tcode{wide_err_string}.
The second constructor shall store \tcode{pcvt} in \tcode{cvtptr},
\tcode{state} in \tcode{cvtstate}, and default values in
\tcode{byte_err_string} and \tcode{wide_err_string}; moreover the
stored state shall be retained between calls to \tcode{from_bytes} and
\tcode{to_bytes}.
The third constructor shall store \tcode{new Codecvt} in \tcode{cvtptr},
\tcode{state_type()} in \tcode{cvtstate}, \tcode{byte_err}
in \tcode{byte_err_string}, and \tcode{wide_err} in
\tcode{wide_err_string}.
\end{itemdescr}

\indexlibrary{\idxcode{wstring_convert}!destructor}%
\begin{itemdecl}
~wstring_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}

\rSec2[depr.conversions.buffer]{Class template \tcode{wbuffer_convert}}

\pnum
Class template \tcode{wbuffer_convert} looks like a wide stream buffer, but
performs all its I/O through an underlying byte stream buffer that you
specify when you construct it. Like class template \tcode{wstring_convert}, it
lets you specify a code conversion facet to perform the conversions,
without affecting any streams or locales.

\indexlibrary{\idxcode{wbuffer_convert}}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
    class wbuffer_convert : public basic_streambuf<Elem, Tr> {
    public:
      using state_type = typename Codecvt::state_type;

      explicit wbuffer_convert(streambuf* bytebuf = nullptr,
                               Codecvt* pcvt = new Codecvt,
                               state_type state = state_type());

      ~wbuffer_convert();

      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const;
      streambuf* rdbuf(streambuf* bytebuf);

      state_type state() const;

    private:
      streambuf* bufptr;            // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
  };
}
\end{codeblock}

\pnum
The class template describes a stream buffer that controls the
transmission of elements of type \tcode{Elem}, whose character traits are
described by the class \tcode{Tr}, to and from a byte stream buffer of type
\tcode{streambuf}. Conversion between a sequence of \tcode{Elem} values and
multibyte sequences is performed by an object of class
\tcode{Codecvt}, which shall satisfy the requirements
of the standard code-conversion facet \tcode{codecvt<Elem, char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{bufptr} --- a pointer to its underlying byte stream buffer
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wbuffer_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\end{itemize}

\indexlibrarymember{state}{wbuffer_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf(streambuf* bytebuf);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Stores \tcode{bytebuf} in \tcode{bufptr}.

\pnum
\returns The previous value of \tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{state_type}{wbuffer_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibrary{\idxcode{wbuffer_convert}!constructor}%
\begin{itemdecl}
explicit wbuffer_convert(
    streambuf* bytebuf = nullptr,
    Codecvt* pcvt = new Codecvt,
    state_type state = state_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pcvt != nullptr}.

\pnum
\effects The constructor constructs a stream buffer object, initializes
\tcode{bufptr} to \tcode{bytebuf}, initializes \tcode{cvtptr}
to \tcode{pcvt}, and initializes \tcode{cvtstate} to \tcode{state}.
\end{itemdescr}

\indexlibrary{\idxcode{wbuffer_convert}!destructor}%
\begin{itemdecl}
~wbuffer_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}
