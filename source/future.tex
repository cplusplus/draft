%!TEX root = std.tex
\normannex{depr}{Compatibility features}

\newcommand{\requires}{\Fundesc{Requires}}

\rSec1[depr.general]{General}

\pnum
This Annex describes features of the \Cpp{} Standard that are specified for compatibility with
existing implementations.

\pnum
These are deprecated features, where
\term{deprecated}
is defined as:
Normative for the current revision of \Cpp{},
but having been identified as a candidate for removal from future revisions.
An implementation may declare library names and entities described in this Clause with the
\tcode{deprecated} attribute\iref{dcl.attr.deprecated}.

\rSec1[depr.arith.conv.enum]{Arithmetic conversion on enumerations}

\pnum
The ability to apply the usual arithmetic conversions\iref{expr.arith.conv}
on operands where one is of enumeration type
and the other is of a different enumeration type
or a floating-point type
is deprecated.
\begin{note}
Three-way comparisons\iref{expr.spaceship} between such operands are ill-formed.
\end{note}
\begin{example}
\begin{codeblock}
enum E1 { e };
enum E2 { f };
bool b = e <= 3.7;              // deprecated
int k = f - e;                  // deprecated
auto cmp = e <=> f;             // error
\end{codeblock}
\end{example}

\rSec1[depr.capture.this]{Implicit capture of \tcode{*this} by reference}

\pnum
For compatibility with prior revisions of \Cpp{},
a \grammarterm{lambda-expression} with \grammarterm{capture-default}
\tcode{=}\iref{expr.prim.lambda.capture} may implicitly capture
\tcode{*this} by reference.
\begin{example}
\begin{codeblock}
struct X {
  int x;
  void foo(int n) {
    auto f = [=]() { x = n; };          // deprecated: \tcode{x} means \tcode{this->x}, not a copy thereof
    auto g = [=, this]() { x = n; };    // recommended replacement
  }
};
\end{codeblock}
\end{example}

\rSec1[depr.comma.subscript]{Comma operator in subscript expressions}

\pnum
A comma expression\iref{expr.comma}
appearing as the \grammarterm{expr-or-braced-init-list}
of a subscripting expression\iref{expr.sub} is deprecated.
\begin{note}
A parenthesized comma expression is not deprecated.
\end{note}
\begin{example}
\begin{codeblock}
void f(int *a, int b, int c) {
    a[b,c];                     // deprecated
    a[(b,c)];                   // OK
}
\end{codeblock}
\end{example}

\rSec1[depr.array.comp]{Array comparisons}

\pnum
Equality and relational comparisons (\ref{expr.eq}, \ref{expr.rel})
between two operands of array type
are deprecated.
\begin{note}
Three-way comparisons\iref{expr.spaceship} between such operands are ill-formed.
\end{note}
\begin{example}
\begin{codeblock}
int arr1[5];
int arr2[5];
bool same = arr1 == arr2;       // deprecated, same as \tcode{\&arr1[0] == \&arr2[0]},
                                // does not compare array contents
auto cmp = arr1 <=> arr2;       // error
\end{codeblock}
\end{example}

\rSec1[depr.volatile.type]{Deprecated \tcode{volatile} types}

\pnum
Postfix \tcode{++} and \tcode{--} expressions\iref{expr.post.incr} and
prefix \tcode{++} and \tcode{--} expressions\iref{expr.pre.incr}
of volatile-qualified arithmetic and pointer types are deprecated.

\begin{example}
\begin{codeblock}
volatile int velociraptor;
++velociraptor;                     // deprecated
\end{codeblock}
\end{example}


\pnum
Certain assignments
where the left operand is a volatile-qualified non-class type
are deprecated; see~\ref{expr.ass}.

\begin{example}
\begin{codeblock}
int neck, tail;
volatile int brachiosaur;
brachiosaur = neck;                 // OK
tail = brachiosaur;                 // OK
tail = brachiosaur = neck;          // deprecated
brachiosaur += neck;                // deprecated
brachiosaur = brachiosaur + neck;   // OK
\end{codeblock}
\end{example}


\pnum
A function type\iref{dcl.fct}
with a parameter with volatile-qualified type or
with a volatile-qualified return type is deprecated.

\begin{example}
\begin{codeblock}
volatile struct amber jurassic();                               // deprecated
void trex(volatile short left_arm, volatile short right_arm);   // deprecated
void fly(volatile struct pterosaur* pteranodon);                // OK
\end{codeblock}
\end{example}


\pnum
A structured binding\iref{dcl.struct.bind} of a volatile-qualified type
is deprecated.

\begin{example}
\begin{codeblock}
struct linhenykus { short forelimb; };
void park(linhenykus alvarezsauroid) {
  volatile auto [what_is_this] = alvarezsauroid;                // deprecated
  // ...
}
\end{codeblock}
\end{example}


\rSec1[depr.static.constexpr]{Redeclaration of \tcode{static constexpr} data members}

\pnum
For compatibility with prior revisions of \Cpp{}, a \keyword{constexpr}
static data member may be redundantly redeclared outside the class with no initializer.
This usage is deprecated.
\begin{example}
\begin{codeblock}
struct A {
  static constexpr int n = 5;   // definition (declaration in \CppXIV{})
};

constexpr int A::n;             // redundant declaration (definition in \CppXIV{})
\end{codeblock}
\end{example}

\rSec1[depr.local]{Non-local use of TU-local entities}

\pnum
A declaration of a non-TU-local entity that is an exposure\iref{basic.link}
is deprecated.
\begin{note}
Such a declaration in an importable module unit is ill-formed.
\end{note}
\begin{example}
\begin{codeblock}
namespace {
  struct A {
    void f() {}
  };
}
A h();                          // deprecated: not internal linkage
inline void g() {A().f();}      // deprecated: inline and not internal linkage
\end{codeblock}
\end{example}

\rSec1[depr.impldec]{Implicit declaration of copy functions}

\pnum
The implicit definition of a copy constructor\iref{class.copy.ctor}
as defaulted is deprecated if the class has
a user-declared copy assignment operator or
a user-declared destructor\iref{class.dtor}.
The implicit definition of a copy assignment operator\iref{class.copy.assign}
as defaulted is deprecated if the class has
a user-declared copy constructor or
a user-declared destructor.
It is possible that future versions of \Cpp{} will specify
that these implicit definitions are deleted\iref{dcl.fct.def.delete}.

\rSec1[depr.template.template]{\tcode{template} keyword before qualified names}

\pnum
The use of the keyword \keyword{template}
before the qualified name of a class or alias template
without a template argument list is deprecated.

\rSec1[depr.c.headers]{C headers}

\rSec2[depr.c.headers.general]{General}

\pnum
For compatibility with the
\indextext{library!C standard}%
C standard library, the \Cpp{} standard library provides
the \defnx{C headers}{headers!C library} shown in \tref{depr.c.headers}.

\begin{multicolfloattable}{C headers}{depr.c.headers}
{lllll}
\libheaderdef{assert.h} \\
\libheader{complex.h} \\
\libheaderdef{ctype.h} \\
\libheaderdef{errno.h} \\
\libheaderdef{fenv.h} \\
\libheaderdef{float.h} \\
\columnbreak
\libheaderdef{inttypes.h} \\
\libheader{iso646.h} \\
\libheaderdef{limits.h} \\
\libheaderdef{locale.h} \\
\libheaderdef{math.h} \\
\libheaderdef{setjmp.h} \\
\columnbreak
\libheaderdef{signal.h} \\
\libheader{stdalign.h} \\
\libheaderdef{stdarg.h} \\
\libheader{stdatomic.h} \\
\libheader{stdbool.h} \\
\libheaderdef{stddef.h} \\
\columnbreak
\libheaderdef{stdint.h} \\
\libheaderdef{stdio.h} \\
\libheaderdef{stdlib.h} \\
\libheaderdef{string.h} \\
\libheader{tgmath.h} \\
\libheaderdef{time.h} \\
\columnbreak
\libheaderdef{uchar.h} \\
\libheaderdef{wchar.h} \\
\libheaderdef{wctype.h} \\
\end{multicolfloattable}

\rSec2[depr.complex.h.syn]{Header \tcode{<complex.h>} synopsis}

\indexheader{complex.h}%
\begin{codeblock}
#include <complex>
\end{codeblock}

\pnum
The header \libheader{complex.h}
behaves as if it simply includes the header
\libheaderref{complex}.

\pnum
\begin{note}
Names introduced by \libheader{complex} in namespace \tcode{std}
are not placed into the global namespace scope by \libheader{complex.h}.
\end{note}

\rSec2[depr.iso646.h.syn]{Header \tcode{<iso646.h>} synopsis}

\indexheader{iso646.h}%
\pnum
The \Cpp{} header \libheader{iso646.h} is empty.
\begin{note}
\tcode{and},
\tcode{and_eq},
\tcode{bitand},
\tcode{bitor},
\tcode{compl},
\tcode{not_eq},
\tcode{not},
\tcode{or},
\tcode{or_eq},
\tcode{xor}, and
\tcode{xor_eq}
are keywords in \Cpp{}\iref{lex.key}.
\end{note}

\rSec2[depr.stdalign.h.syn]{Header \tcode{<stdalign.h>} synopsis}

\indexheader{stdalign.h}%
\indexlibraryglobal{__alignas_is_defined}%
\begin{codeblock}
#define @\xname{alignas_is_defined}@ 1
\end{codeblock}

\pnum
The contents of the \Cpp{} header \libheader{stdalign.h} are the same as the C
standard library header \libheader{stdalign.h}, with the following changes:
The header \libheader{stdalign.h} does not
define a macro named \tcode{alignas}.

\xrefc{7.15}

\rSec2[depr.stdbool.h.syn]{Header \tcode{<stdbool.h>} synopsis}

\indexheader{stdbool.h}%
\indexhdr{stdbool.h}%
\indexlibraryglobal{__bool_true_false_are_defined}%
\begin{codeblock}
#define @\xname{bool_true_false_are_defined}@ 1
\end{codeblock}

\pnum
The contents of the \Cpp{} header \libheader{stdbool.h} are the same as the C
standard library header \libheader{stdbool.h}, with the following changes:
The header \libheader{stdbool.h} does not
define macros named \tcode{bool}, \tcode{true}, or \tcode{false}.

\xrefc{7.18}

\rSec2[depr.tgmath.h.syn]{Header \tcode{<tgmath.h>} synopsis}

\indexheader{tgmath.h}%
\begin{codeblock}
#include <cmath>
#include <complex>
\end{codeblock}

\pnum
The header \libheader{tgmath.h}
behaves as if it simply includes the headers
\libheaderref{cmath} and
\libheaderref{complex}.

\pnum
\begin{note}
The overloads provided in C by type-generic macros
are already provided in \libheader{complex} and \libheader{cmath}
by ``sufficient'' additional overloads.
\end{note}

\pnum
\begin{note}
Names introduced by \libheader{cmath} or \libheader{complex}
in namespace \tcode{std}
are not placed into the global namespace scope by \libheader{tgmath.h}.
\end{note}

\rSec2[depr.c.headers.other]{Other C headers}

\pnum
Every C header
other than
\libdeprheaderref{complex.h},
\libdeprheaderref{iso646.h},
\libdeprheaderref{stdalign.h},\newline
\libheaderref{stdatomic.h},
\libdeprheaderref{stdbool.h}, and
\libdeprheaderref{tgmath.h},
each of
which has a name of the form
\indextext{header!C}%
\tcode{<\placeholder{name}.h>},
behaves as if each name placed in the standard library namespace by
the corresponding
\tcode{<c\placeholder{name}>}
header is placed within
the global namespace scope,
except for the functions described in \ref{sf.cmath},
the declaration of \tcode{std::byte}\iref{cstddef.syn}, and
the functions and function templates described in \ref{support.types.byteops}.
It is unspecified whether these names are first declared or defined within
namespace scope\iref{basic.scope.namespace} of the namespace
\tcode{std} and are then injected into the global namespace scope by
explicit \grammarterm{using-declaration}{s}\iref{namespace.udecl}.

\pnum
\begin{example}
The header \libheader{cstdlib} assuredly
provides its declarations and definitions within the namespace
\tcode{std}. It may also provide these names within the
global namespace.
The header \libheader{stdlib.h}
assuredly provides the same declarations and definitions within
the global namespace,
much as in the C Standard. It may also provide these names within
the namespace \tcode{std}.
\end{example}

\rSec1[depr.res.on.required]{Requires paragraph}

\pnum
In addition to the elements specified in \ref{structure.specifications},
descriptions of function semantics may also contain a \requires element
to denote the preconditions for calling a function.

\pnum
\indextext{restriction}%
Violation of any preconditions specified in a function's \requires element
results in undefined behavior
unless the function's \throws element
specifies throwing an exception when the precondition is violated.

\rSec1[depr.relops]{Relational operators}%
\indexlibraryglobal{rel_ops}%

\pnum
The header \libheaderref{utility} has the following additions:

\begin{codeblock}
namespace std::rel_ops {
  template<class T> bool operator!=(const T&, const T&);
  template<class T> bool operator> (const T&, const T&);
  template<class T> bool operator<=(const T&, const T&);
  template<class T> bool operator>=(const T&, const T&);
}
\end{codeblock}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\indexlibrary{\idxcode{operator"!=}}%
\begin{itemdecl}
template<class T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \oldconcept{EqualityComparable} (\tref{cpp17.equalitycomparable}).

\pnum
\returns
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibraryglobal{operator>}%
\begin{itemdecl}
template<class T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \oldconcept{LessThanComparable} (\tref{cpp17.lessthancomparable}).

\pnum
\returns
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}}%
\begin{itemdecl}
template<class T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \oldconcept{LessThanComparable} (\tref{cpp17.lessthancomparable}).

\pnum
\returns
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}}%
\begin{itemdecl}
template<class T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \oldconcept{LessThanComparable} (\tref{cpp17.lessthancomparable}).

\pnum
\returns
\tcode{!(x < y)}.
\end{itemdescr}

\rSec1[depr.str.strstreams]{\tcode{char*} streams}

\rSec2[depr.strstream.syn]{Header \tcode{<strstream>} synopsis}

\pnum
The header \libheaderdef{strstream}
defines types that associate stream buffers with
character array objects and assist reading and writing such objects.

\begin{codeblock}
namespace std {
  class strstreambuf;
  class istrstream;
  class ostrstream;
  class strstream;
}
\end{codeblock}

\rSec2[depr.strstreambuf]{Class \tcode{strstreambuf}}

\rSec3[depr.strstreambuf.general]{General}

\indexlibraryglobal{strstreambuf}%
\begin{codeblock}
namespace std {
  class strstreambuf : public basic_streambuf<char> {
  public:
    strstreambuf() : strstreambuf(0) {}
    explicit strstreambuf(streamsize alsize_arg);
    strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
    strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
    strstreambuf(const char* gnext_arg, streamsize n);

    strstreambuf(signed char* gnext_arg, streamsize n,
                 signed char* pbeg_arg = nullptr);
    strstreambuf(const signed char* gnext_arg, streamsize n);
    strstreambuf(unsigned char* gnext_arg, streamsize n,
                 unsigned char* pbeg_arg = nullptr);
    strstreambuf(const unsigned char* gnext_arg, streamsize n);

    virtual ~strstreambuf();

    void  freeze(bool freezefl = true);
    char* str();
    int   pcount();

  protected:
    int_type overflow (int_type c = EOF) override;
    int_type pbackfail(int_type c = EOF) override;
    int_type underflow() override;
    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which = ios_base::in | ios_base::out) override;
    streambuf* setbuf(char* s, streamsize n) override;

  private:
    using strstate = T1;                // \expos
    static const strstate allocated;    // \expos
    static const strstate constant;     // \expos
    static const strstate dynamic;      // \expos
    static const strstate frozen;       // \expos
    strstate strmode;                   // \expos
    streamsize alsize;                  // \expos
    void* (*palloc)(size_t);            // \expos
    void (*pfree)(void*);               // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstreambuf}
associates the input sequence, and possibly the output sequence, with an object of some
\textit{character}
array type, whose elements store arbitrary values.
The array object has several attributes.

\pnum
\begin{note}
For the sake of exposition, these are represented as elements of a bitmask type
(indicated here as \tcode{T1}) called \tcode{strstate}.
The elements are:
\begin{itemize}
\item
\tcode{allocated}, set when a dynamic array object has been
allocated, and hence will be freed by the destructor for the
\tcode{strstreambuf} object;
\item
\tcode{constant}, set when the array object has
\keyword{const} elements, so the output sequence cannot be written;
\item
\tcode{dynamic}, set when the array object is allocated
(or reallocated)
as necessary to hold a character sequence that can change in length;
\item
\tcode{frozen}, set when the program has requested that the
array object not be altered, reallocated, or freed.
\end{itemize}
\end{note}

\pnum
\begin{note}
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{strstate strmode}, the attributes of the array object
associated with the \tcode{strstreambuf} object;
\item
\tcode{int alsize}, the suggested minimum size for a
dynamic array object;
\item
\tcode{void* (*palloc)(size_t)}, points to the function
to call to allocate a dynamic array object;
\item
\tcode{void (*pfree)(void*)}, points to the function to
call to free a dynamic array object.
\end{itemize}
\end{note}

\pnum
Each object of class
\tcode{strstreambuf}
has a
\term{seekable area},
delimited by the pointers \tcode{seeklow} and \tcode{seekhigh}.
If \tcode{gnext} is a null pointer, the seekable area is undefined.
Otherwise, \tcode{seeklow} equals \tcode{gbeg} and
\tcode{seekhigh} is either \tcode{pend},
if \tcode{pend} is not a null pointer, or \tcode{gend}.

\rSec3[depr.strstreambuf.cons]{\tcode{strstreambuf} constructors}

\indexlibraryctor{strstreambuf}%
\begin{itemdecl}
explicit strstreambuf(streamsize alsize_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{streambuf()}.
The postconditions of this function are indicated in \tref{depr.strstreambuf.cons.sz}.
\end{itemdescr}

\begin{libtab2}{\tcode{strstreambuf(streamsize)} effects}{depr.strstreambuf.cons.sz}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}		\\
\tcode{alsize}	&	\tcode{alsize_arg}	\\
\tcode{palloc}	&	a null pointer		\\
\tcode{pfree}	&	a null pointer		\\
\end{libtab2}

\indexlibraryctor{strstreambuf}%
\begin{itemdecl}
strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{streambuf()}.
The postconditions of this function are indicated in \tref{depr.strstreambuf.cons.alloc}.

\begin{libtab2}{\tcode{strstreambuf(void* (*)(size_t), void (*)(void*))} effects}
{depr.strstreambuf.cons.alloc}
{ll}
{Element}{Value}
\tcode{strmode}	&	\tcode{dynamic}			\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	\tcode{palloc_arg}		\\
\tcode{pfree}	&	\tcode{pfree_arg}		\\
\end{libtab2}
\end{itemdescr}

\indextext{unspecified}%
\indexlibraryctor{strstreambuf}%
\begin{itemdecl}
strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = nullptr);
strstreambuf(signed char* gnext_arg, streamsize n,
             signed char* pbeg_arg = nullptr);
strstreambuf(unsigned char* gnext_arg, streamsize n,
             unsigned char* pbeg_arg = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{streambuf()}.
The postconditions of this function are indicated in \tref{depr.strstreambuf.cons.ptr}.

\begin{libtab2}{\tcode{strstreambuf(charT*, streamsize, charT*)} effects}
{depr.strstreambuf.cons.ptr}
{ll}
{Element}{Value}
\tcode{strmode}	&	0						\\
\tcode{alsize}	&	an unspecified value	\\
\tcode{palloc}	&	a null pointer			\\
\tcode{pfree}	&	a null pointer			\\
\end{libtab2}

\pnum
\tcode{gnext_arg} shall point to the first element of an array
object whose number of elements \tcode{N} is determined as follows:
\begin{itemize}
\item
If
\tcode{n > 0},
\tcode{N} is \tcode{n}.
\item
If
\tcode{n == 0},
\tcode{N} is
\tcode{std::strlen(gnext_arg)}.
\indexlibraryglobal{strlen}%
\item
If
\tcode{n < 0},
\tcode{N} is
\tcode{INT_MAX}.
\begin{footnote}
The function signature
\indexlibraryglobal{strlen}%
\tcode{strlen(const char*)}
is declared in \libheaderref{cstring}.
The macro \tcode{INT_MAX} is defined in \libheaderref{climits}.
\end{footnote}
\end{itemize}

\pnum
If \tcode{pbeg_arg} is a null pointer, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, gnext_arg + N);
\end{codeblock}

\pnum
Otherwise, the function executes:

\begin{codeblock}
setg(gnext_arg, gnext_arg, pbeg_arg);
setp(pbeg_arg,  pbeg_arg + N);
\end{codeblock}
\end{itemdescr}


\indexlibraryctor{strstreambuf}%
\begin{itemdecl}
strstreambuf(const char* gnext_arg, streamsize n);
strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(const unsigned char* gnext_arg, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves the same as
\tcode{strstreambuf((char*)gnext_arg,n)},
except that the constructor also sets \tcode{constant} in \tcode{strmode}.
\end{itemdescr}

\indexlibrarydtor{strstreambuf}%
\begin{itemdecl}
virtual ~strstreambuf();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstreambuf}.
The function frees the dynamically allocated array object only if
\tcode{(strmode \& allocated) != 0}
and
\tcode{(strmode \& frozen) == 0}.~(\ref{depr.strstreambuf.virtuals} describes how a dynamically allocated array object is freed.)
\end{itemdescr}

\rSec3[depr.strstreambuf.members]{Member functions}

\indexlibrarymember{freeze}{strstreambuf}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{strmode \& dynamic} is nonzero, alters the
freeze status of the dynamic array object as follows:
\begin{itemize}
\item
If \tcode{freezefl} is
\tcode{true},
the function sets \tcode{frozen} in \tcode{strmode}.
\item
Otherwise, it clears \tcode{frozen} in \tcode{strmode}.
\end{itemize}
\end{itemdescr}

\indexlibrarymember{str}{strstreambuf}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{freeze()},
then returns the beginning pointer for the input sequence, \tcode{gbeg}.

\pnum
\remarks
The return value can be a null pointer.
\end{itemdescr}

\indexlibrarymember{pcount}{strstreambuf}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If the next pointer for the output sequence, \tcode{pnext}, is
a null pointer, returns zero.
Otherwise, returns the current
effective length of the array object as the next pointer minus the beginning
pointer for the output sequence, \tcode{pnext - pbeg}.
\end{itemdescr}

\rSec3[depr.strstreambuf.virtuals]{\tcode{strstreambuf} overridden virtual functions}

\indexlibrarymember{overflow}{strstreambuf}%
\begin{itemdecl}
int_type overflow(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Appends the character designated by \tcode{c} to the output
sequence, if possible, in one of two ways:
\begin{itemize}
\item
If
\tcode{c != EOF}
and if either the output sequence has a write position available or
the function makes a write position available
(as described below),
assigns \tcode{c} to
\tcode{*pnext++}.

Returns
\tcode{(unsigned char)c}.

\item
If
\tcode{c == EOF},
there is no character to append.

Returns a value other than \tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of write positions available as a
result of any call.

\pnum
To make a write position available, the function reallocates
(or initially allocates)
an array object with a sufficient number of elements
\tcode{n} to hold the current array object (if any),
plus at least one additional write position.
How many additional write positions are made
available is otherwise unspecified.%
\indextext{unspecified}%
If \tcode{palloc} is not a null pointer, the function calls
\tcode{(*palloc)(n)}
to allocate the new dynamic array object.
Otherwise, it evaluates the expression
\tcode{new charT[n]}.
In either case, if the allocation fails, the function returns
\tcode{EOF}.
Otherwise, it sets \tcode{allocated} in \tcode{strmode}.

\pnum
To free a previously existing dynamic array object whose first
element address is \tcode{p}:
If \tcode{pfree} is not a null pointer,
the function calls
\tcode{(*pfree)(p)}.
Otherwise, it evaluates the expression \tcode{delete[]p}.

\pnum
If
\tcode{(strmode \& dynamic) == 0},
or if
\tcode{(strmode \& frozen) != 0},
the function cannot extend the array (reallocate it with greater length) to make a write position available.

\pnum
\recommended
An implementation should consider \tcode{alsize} in making the
decision how many additional write positions to make available.
\end{itemdescr}

\indexlibrarymember{pbackfail}{strstreambuf}%
\begin{itemdecl}
int_type pbackfail(int_type c = EOF) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
Puts back the character designated by \tcode{c} to the input
sequence, if possible, in one of three ways:
\begin{itemize}
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{(char)c == gnext[-1]},
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns \tcode{c}.
\item
If
\tcode{c != EOF},
if the input sequence has a putback position available, and if
\tcode{strmode \& constant} is zero,
assigns \tcode{c} to
\tcode{*--gnext}.

Returns
\tcode{c}.
\item
If
\tcode{c == EOF}
and if the input sequence has a putback position available,
assigns
\tcode{gnext - 1}
to \tcode{gnext}.

Returns a value other than
\tcode{EOF}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.
\indextext{unspecified}%
The function can alter the number of putback
positions available as a result of any call.
\end{itemdescr}

\indexlibrarymember{underflow}{strstreambuf}%
\begin{itemdecl}
int_type underflow() override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reads a character from the
\term{input sequence},
if possible, without moving the stream position past it, as follows:
\begin{itemize}
\item
If the input sequence has a read position available, the function
signals success by returning
\tcode{(unsigned char)\brk*gnext}.
\item
Otherwise, if
the current write next pointer \tcode{pnext} is not a null pointer and
is greater than the current read end pointer \tcode{gend},
makes a
\term{read position}
available by
assigning to \tcode{gend} a value greater than \tcode{gnext} and
no greater than \tcode{pnext}.

Returns \tcode{(unsigned char)*gnext}.
\end{itemize}

\pnum
Returns
\tcode{EOF}
to indicate failure.

\pnum
\remarks
The function can alter the number of read positions available as a
result of any call.
\end{itemdescr}

\indexlibrarymember{seekoff}{strstreambuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, seekdir way, openmode which = in | out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, as indicated in \tref{depr.strstreambuf.seekoff.pos}.

\begin{libtab2}{\tcode{seekoff} positioning}{depr.strstreambuf.seekoff.pos}
{p{2.5in}l}{Conditions}{Result}
\tcode{(which \& ios::in) != 0}	&
 positions the input sequence	\\ \rowsep
\tcode{(which \& ios::out) != 0}	&
 positions the output sequence	\\ \rowsep
\tcode{(which \& (ios::in | ios::out)) ==}\br
\tcode{(ios::in | ios::out)} and either\br
\tcode{way == ios::beg} or \tcode{way == ios::end}			&
 positions both the input and the output sequences	\\ \rowsep
Otherwise	&
 the positioning operation fails.	\\
\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} as indicated in
\tref{depr.strstreambuf.seekoff.newoff}.

\begin{libtab2}{\tcode{newoff} values}{depr.strstreambuf.seekoff.newoff}
{p{2.0in}p{2.0in}}{Condition}{\tcode{newoff} Value}
\tcode{way == ios::beg}	&
 0	\\ \rowsep
\tcode{way == ios::cur}	&
 the next pointer minus the beginning pointer (\tcode{xnext - xbeg}).	\\ \rowsep
\tcode{way == ios::end}	&
 \tcode{seekhigh} minus the beginning pointer (\tcode{seekhigh - xbeg}).	\\
\end{libtab2}

\pnum
If \tcode{(newoff + off) < (seeklow - xbeg)}
or \tcode{(seekhigh - xbeg) < (newoff + off)},
the positioning operation fails.
Otherwise, the function assigns
\tcode{xbeg + newoff + off}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset
\tcode{newoff} (of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{seekpos}{strstreambuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp, ios_base::openmode which = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, to correspond to the
stream position stored in \tcode{sp}
(as described below).
\begin{itemize}
\item
If
\tcode{(which \& ios::in) != 0},
positions the input sequence.
\item
If
\tcode{(which \& ios::out) != 0},
positions the output sequence.
\item
If the function positions neither sequence, the positioning operation fails.
\end{itemize}

\pnum
For a sequence to be positioned, if its next pointer is a null pointer,
the positioning operation fails.
Otherwise, the function determines \tcode{newoff} from
\tcode{sp.offset()}:
\begin{itemize}
\item
If \tcode{newoff} is an invalid stream position,
has a negative value, or
has a value greater than (\tcode{seekhigh - seeklow}),
the positioning operation fails
\item
Otherwise, the function
adds \tcode{newoff} to the beginning pointer \tcode{xbeg} and
stores the result in the next pointer \tcode{xnext}.
\end{itemize}

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset \tcode{newoff}
(of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

\indexlibrarymember{setbuf}{strstreambuf}%
\begin{itemdecl}
streambuf<char>* setbuf(char* s, streamsize n) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behavior is \impldef{behavior of \tcode{strstreambuf::setbuf}},
except that
\tcode{setbuf(0, 0)}
has no effect.%
\end{itemdescr}

\rSec2[depr.istrstream]{Class \tcode{istrstream}}

\rSec3[depr.istrstream.general]{General}

\indexlibraryglobal{istrstream}%
\begin{codeblock}
namespace std {
  class istrstream : public basic_istream<char> {
  public:
    explicit istrstream(const char* s);
    explicit istrstream(char* s);
    istrstream(const char* s, streamsize n);
    istrstream(char* s, streamsize n);
    virtual ~istrstream();

    strstreambuf* rdbuf() const;
    char* str();
  private:
    strstreambuf sb;            // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{istrstream}
supports the reading of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.istrstream.cons]{\tcode{istrstream} constructors}

\indexlibraryctor{istrstream}%
\begin{itemdecl}
explicit istrstream(const char* s);
explicit istrstream(char* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{istream(\&sb)} and
\tcode{sb} with \tcode{strstreambuf(s, 0)}.
\tcode{s} shall designate the first element of an \ntbs{}.%
\indextext{NTBS@\ntbs{}}
\end{itemdescr}

\indexlibraryctor{istrstream}%
\begin{itemdecl}
istrstream(const char* s, streamsize n);
istrstream(char* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{istream(\&sb)}
and \tcode{sb} with \tcode{strstreambuf(s, n)}.
\tcode{s} shall designate the first element of an array whose length is
\tcode{n} elements, and \tcode{n} shall be greater than zero.
\end{itemdescr}

\rSec3[depr.istrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{istrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<strstreambuf*>(\&sb)}.
\end{itemdescr}

\indexlibrarymember{str}{istrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\rSec2[depr.ostrstream]{Class \tcode{ostrstream}}

\rSec3[depr.ostrstream.general]{General}

\indexlibraryglobal{ostrstream}%
\begin{codeblock}
namespace std {
  class ostrstream : public basic_ostream<char> {
  public:
    ostrstream();
    ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
    virtual ~ostrstream();

    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    char* str();
    int pcount() const;
  private:
    strstreambuf sb;            // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{ostrstream}
supports the writing of objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.ostrstream.cons]{\tcode{ostrstream} constructors}

\indexlibraryctor{ostrstream}%
\begin{itemdecl}
ostrstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{ostream(\&sb)} and
\tcode{sb} with \tcode{strstreambuf()}.
\end{itemdescr}

\indexlibraryctor{ostrstream}%
\begin{itemdecl}
ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{ostream(\&sb)},
and \tcode{sb} with one of two constructors:

\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.

The constructor is
\tcode{strstreambuf(s, n, s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements that
contains an \ntbs{} whose first element is designated by \tcode{s}.
\indextext{NTBS@\ntbs{}}%
The constructor is
\tcode{strstreambuf(s, n, s + std::strlen(s))}.
\begin{footnote}
The function signature
\indexlibraryglobal{strlen}%
\tcode{strlen(const char*)}
is declared in \libheaderref{cstring}.
\end{footnote}
\end{itemize}
\end{itemdescr}

\rSec3[depr.ostrstream.members]{Member functions}

\indexlibrarymember{rdbuf}{ostrstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{(strstreambuf*)\&sb}.
\end{itemdescr}

\indexlibrarymember{freeze}{ostrstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{ostrstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{ostrstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec2[depr.strstream]{Class \tcode{strstream}}

\rSec3[depr.strstream.general]{General}

\indexlibraryglobal{strstream}%
\begin{codeblock}
namespace std {
  class strstream
    : public basic_iostream<char> {
  public:
    // types
    using char_type = char;
    using int_type  = char_traits<char>::int_type;
    using pos_type  = char_traits<char>::pos_type;
    using off_type  = char_traits<char>::off_type;

    // constructors/destructor
    strstream();
    strstream(char* s, int n,
              ios_base::openmode mode = ios_base::in|ios_base::out);
    virtual ~strstream();

    // members
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    int pcount() const;
    char* str();

  private:
    strstreambuf sb;            // \expos
  };
}
\end{codeblock}

\pnum
The class
\tcode{strstream}
supports reading and writing from objects of class
\tcode{strstreambuf}.
It supplies a
\tcode{strstreambuf}
object to control the associated array object.
For the sake of exposition, the maintained data is presented here as:

\begin{itemize}
\item
\tcode{sb}, the \tcode{strstreambuf} object.
\end{itemize}

\rSec3[depr.strstream.cons]{\tcode{strstream} constructors}

\indexlibraryctor{strstream}%
\begin{itemdecl}
strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{iostream(\&sb)}.
\end{itemdescr}

\indexlibraryctor{strstream}%
\begin{itemdecl}
strstream(char* s, int n,
          ios_base::openmode mode = ios_base::in|ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with \tcode{iostream(\&sb)},
and \tcode{sb} with one of the two constructors:
\begin{itemize}
\item
If
\tcode{(mode \& app) == 0},
then \tcode{s} shall designate the first element of an array of \tcode{n} elements.
The constructor is
\tcode{strstreambuf(s,n,s)}.
\item
If
\tcode{(mode \& app) != 0},
then \tcode{s} shall
designate the first element of an array of \tcode{n} elements that contains
an \ntbs{} whose first element is designated by \tcode{s}.
The constructor is
\tcode{strstreambuf(s,n,s + std::strlen(s))}.
\indexlibrarydtor{strstream}%
\end{itemize}
\end{itemdescr}

\rSec3[depr.strstream.dest]{\tcode{strstream} destructor}

\indexlibrarydtor{strstream}%
\begin{itemdecl}
virtual ~strstream();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{strstream}.
\end{itemdescr}

\rSec3[depr.strstream.oper]{\tcode{strstream} operations}

\indexlibrarymember{rdbuf}{strstream}%
\begin{itemdecl}
strstreambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<strstreambuf*>(\&sb)}.
\end{itemdescr}

\indexlibrarymember{freeze}{strstream}%
\begin{itemdecl}
void freeze(bool freezefl = true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->freeze(freezefl)}.
\end{itemdescr}

\indexlibrarymember{str}{strstream}%
\begin{itemdecl}
char* str();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str()}.
\end{itemdescr}

\indexlibrarymember{pcount}{strstream}%
\begin{itemdecl}
int pcount() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->pcount()}.
\end{itemdescr}

\rSec1[depr.default.allocator]{The default allocator}

\pnum
The following member is defined in addition to those
specified in \ref{default.allocator}:

\begin{codeblock}
namespace std {
  template<class T> class allocator {
  public:
    using is_always_equal = true_type;
  };
}
\end{codeblock}

\rSec1[depr.mem.poly.allocator.mem]{Deprecated \tcode{polymorphic_allocator} member function}

\pnum
The following member is declared in addition to those members
specified in \ref{mem.poly.allocator.mem}:

\begin{codeblock}
namespace std::pmr {
  template<class Tp = byte>
  class polymorphic_allocator {
  public:
    template <class T>
      void destroy(T* p);
  };
}
\end{codeblock}

\indexlibrarymember{destroy}{polymorphic_allocator}%
\begin{itemdecl}
template<class T>
  void destroy(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by \tcode{p->\~T()}.
\end{itemdescr}

\rSec1[depr.meta.types]{Deprecated type traits}

\pnum
The header \libheaderrefx{type_traits}{meta.type.synop}
has the following addition:

\indexlibraryglobal{is_literal_type}%
\begin{codeblock}
namespace std {
  template<class T> struct is_pod;
  template<class T> inline constexpr bool is_pod_v = is_pod<T>::value;
}
\end{codeblock}

\pnum
The behavior of a program that adds specializations for
any of the templates defined in this subclause is undefined,
unless explicitly permitted by the specification of the corresponding template.

\begin{itemdecl}
template<class T> struct is_pod;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{remove_all_extents_t<T>} shall be a complete type or \cv{} \keyword{void}.

\pnum
\tcode{is_pod<T>} is a \oldconcept{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of \tcode{true_type}
if \tcode{T} is a POD type,
and \tcode{false_type} otherwise.
\indextext{POD}%
A POD class is a class that is both a trivial class and a standard-layout class,
and has no non-static data members of type non-POD class (or array thereof).
A POD type is a scalar type, a POD class, an array of such a type,
or a cv-qualified version of one of these types.

\pnum
\begin{note}
It is unspecified whether a closure type\iref{expr.prim.lambda.closure} is a POD type.
\end{note}
\end{itemdescr}

\rSec1[depr.tuple]{Tuple}

\pnum
The header \libheaderref{tuple} has the following additions:

\begin{codeblock}
namespace std {
  template<class T> class tuple_size<volatile T>;
  template<class T> class tuple_size<const volatile T>;

  template<size_t I, class T> class tuple_element<I, volatile T>;
  template<size_t I, class T> class tuple_element<I, const volatile T>;
}
\end{codeblock}

\begin{itemdecl}
template<class T> class tuple_size<volatile T>;
template<class T> class tuple_size<const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{TS} denote \tcode{tuple_size<T>} of the cv-unqualified type \tcode{T}.
If the expression \tcode{TS::value} is well-formed
when treated as an unevaluated operand,
then specializations of each of the two templates meet
the \oldconcept{TransformationTrait} requirements with a base characteristic of
\tcode{integral_constant<size_t, TS::value>}.
Otherwise, they have no member \tcode{value}.

\pnum
Access checking is performed as if
in a context unrelated to \tcode{TS} and \tcode{T}.
Only the validity of the immediate context of the expression is considered.

\pnum
In addition to being available via inclusion of the \libheaderref{tuple} header,
the two templates are available when any of the headers
\libheaderref{array},
\libheaderref{ranges}, or
\libheaderref{utility}
are included.
\end{itemdescr}

\begin{itemdecl}
template<size_t I, class T> class tuple_element<I, volatile T>;
template<size_t I, class T> class tuple_element<I, const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{TE} denote \tcode{tuple_element_t<I, T>}
of the cv-unqualified type \tcode{T}.
Then specializations of each of the two templates meet
the \oldconcept{TransformationTrait} requirements
with a member typedef \tcode{type} that names the following type:
\begin{itemize}
\item for the first specialization, \tcode{add_volatile_t<TE>}, and
\item for the second specialization, \tcode{add_cv_t<TE>}.
\end{itemize}

\pnum
In addition to being available via inclusion of the \libheaderref{tuple} header,
the two templates are available when any of the headers
\libheaderref{array},
\libheaderref{ranges}, or
\libheaderref{utility}
are included.
\end{itemdescr}

\rSec1[depr.variant]{Variant}

\pnum
The header \libheaderref{variant} has the following additions:

\begin{codeblock}
namespace std {
  template<class T> struct variant_size<volatile T>;
  template<class T> struct variant_size<const volatile T>;

  template<size_t I, class T> struct variant_alternative<I, volatile T>;
  template<size_t I, class T> struct variant_alternative<I, const volatile T>;
}
\end{codeblock}

\begin{itemdecl}
template<class T> class variant_size<volatile T>;
template<class T> class variant_size<const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VS} denote \tcode{variant_size<T>}
of the cv-unqualified type \tcode{T}.
Then specializations of each of the two templates meet
the \oldconcept{UnaryTypeTrait} requirements
with a base characteristic of \tcode{integral_constant<size_t, VS::value>}.
\end{itemdescr}

\begin{itemdecl}
template<size_t I, class T> class variant_alternative<I, volatile T>;
template<size_t I, class T> class variant_alternative<I, const volatile T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{VA} denote \tcode{variant_alternative<I, T>}
of the cv-unqualified type \tcode{T}.
Then specializations of each of the two templates meet
the \oldconcept{TransformationTrait} requirements
with a member typedef \tcode{type} that names the following type:
\begin{itemize}
\item for the first specialization, \tcode{add_volatile_t<VA::type>}, and
\item for the second specialization, \tcode{add_cv_t<VA::type>}.
\end{itemize}
\end{itemdescr}

\rSec1[depr.iterator]{Deprecated \tcode{iterator} class template}

\pnum
The header \libheaderrefx{iterator}{iterator.synopsis} has the following addition:

\indexlibraryglobal{iterator}%
\begin{codeblock}
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
           class Pointer = T*, class Reference = T&>
  struct iterator {
    using iterator_category = Category;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = Pointer;
    using reference         = Reference;
  };
}
\end{codeblock}

\pnum
The
\tcode{iterator}
template may be used as a base class to ease the definition of required types
for new iterators.

\pnum
\begin{note}
If the new iterator type is a class template, then these aliases
will not be visible from within the iterator class's template definition, but
only to callers of that class.
\end{note}

\pnum
\begin{example}
If a \Cpp{} program wants to define a bidirectional iterator for some data
structure containing \tcode{double} and such that it works on a large memory
model of the implementation, it can do so with:

\begin{codeblock}
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // code implementing \tcode{++}, etc.
};
\end{codeblock}
\end{example}

\rSec1[depr.move.iter.elem]{Deprecated \tcode{move_iterator} access}

\pnum
The following member is declared in addition to those members
specified in \ref{move.iter.elem}:

\begin{codeblock}
namespace std {
  template<class Iterator>
  class move_iterator {
  public:
    constexpr pointer operator->() const;
  };
}
\end{codeblock}

\indexlibrarymember{operator->}{move_iterator}%
\begin{itemdecl}
constexpr pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{current}.
\end{itemdescr}

\rSec1[depr.util.smartptr.shared.atomic]{Deprecated \tcode{shared_ptr} atomic access}

\pnum
The header \libheaderref{memory} has the following additions:

\indexlibraryglobal{shared_ptr}%
\begin{codeblock}
namespace std {
  template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);

  template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
  template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

  template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
  template<class T>
    shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

  template<class T>
    bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
  template<class T>
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
  template<class T>
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
      memory_order success, memory_order failure);
}
\end{codeblock}

\pnum
Concurrent access to a \tcode{shared_ptr} object from multiple threads does not
introduce a data race if the access is done exclusively via the functions in
this subclause and the instance is passed as their first argument.

\pnum
The meaning of the arguments of type \tcode{memory_order} is explained in~\ref{atomics.order}.

\indexlibrarymember{atomic_is_lock_free}{shared_ptr}%
\begin{itemdecl}
template<class T> bool atomic_is_lock_free(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns
\tcode{true} if atomic access to \tcode{*p} is lock-free, \tcode{false} otherwise.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load(const shared_ptr<T>* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns
\tcode{atomic_load_explicit(p, memory_order::seq_cst)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_load_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order::release} or \tcode{memory_order::acq_rel}.

\pnum
\returns
\tcode{*p}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects
As if by \tcode{atomic_store_explicit(p, r, memory_order::seq_cst)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_store_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T> void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\requires \tcode{mo} shall not be \tcode{memory_order::acquire} or \tcode{memory_order::acq_rel}.

\pnum
\effects
As if by \tcode{p->swap(r)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange}{shared_ptr}%
\begin{itemdecl}
template<class T> shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\returns
\tcode{atomic_exchange_explicit(p, r, memory_order::seq_cst)}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_exchange_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null.

\pnum
\effects
As if by \tcode{p->swap(r)}.

\pnum
\returns
The previous value of \tcode{*p}.

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.

\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_weak_explicit(p, v, w, memory_order::seq_cst, memory_order::seq_cst)
\end{codeblock}

\pnum
\throws
Nothing.
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_strong}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_strong(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
atomic_compare_exchange_strong_explicit(p, v, w, memory_order::seq_cst,
                                        memory_order::seq_cst)
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{atomic_compare_exchange_weak_explicit}{shared_ptr}%
\indexlibrarymember{atomic_compare_exchange_strong_explicit}{shared_ptr}%
\begin{itemdecl}
template<class T>
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
template<class T>
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
    memory_order success, memory_order failure);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{p} shall not be null and \tcode{v} shall not be null.
The \tcode{failure} argument shall not be \tcode{memory_order::release} nor
\tcode{memory_order::acq_rel}.

\pnum
\effects
If \tcode{*p} is equivalent to \tcode{*v}, assigns \tcode{w} to
\tcode{*p} and has synchronization semantics corresponding to the value of
\tcode{success}, otherwise assigns \tcode{*p} to \tcode{*v} and has
synchronization semantics corresponding to the value of \tcode{failure}.

\pnum
\returns
\tcode{true} if \tcode{*p} was equivalent to \tcode{*v}, \tcode{false} otherwise.

\pnum
\throws
Nothing.

\pnum
\remarks
Two \tcode{shared_ptr} objects are equivalent if they store the same
pointer value and share ownership.
The weak form may fail spuriously. See~\ref{atomics.types.operations}.
\end{itemdescr}

\rSec1[depr.string.capacity]{Deprecated \tcode{basic_string} capacity}

\pnum
The following member is declared in addition to those members specified
in \ref{string.capacity}:

\indexlibraryglobal{basic_string}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>,
           class Allocator = allocator<charT>>
  class basic_string {
  public:
    void reserve();
  };
}
\end{codeblock}

\indexlibrarymember{reserve}{basic_string}%
\begin{itemdecl}
void reserve();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
After this call, \tcode{capacity()} has an unspecified value
greater than or equal to \tcode{size()}.
\begin{note}
This is a non-binding shrink to fit request.
\end{note}
\end{itemdescr}

\rSec1[depr.locale.stdcvt]{Deprecated standard code conversion facets}

\rSec2[depr.locale.stdcvt.general]{General}

\pnum
The header \libheaderdef{codecvt} provides
code conversion facets for various character encodings.

\rSec2[depr.codecvt.syn]{Header \tcode{<codecvt>} synopsis}

\indexlibraryglobal{codecvt_mode}%
\indexlibraryglobal{codecvt_utf8}%
\indexlibraryglobal{codecvt_utf16}%
\indexlibraryglobal{codecvt_utf8_utf16}%
\begin{codeblock}
namespace std {
  enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
  };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8(size_t refs = 0);
      ~codecvt_utf8();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf16(size_t refs = 0);
      ~codecvt_utf16();
    };

  template<class Elem, unsigned long Maxcode = 0x10ffff, codecvt_mode Mode = (codecvt_mode)0>
    class codecvt_utf8_utf16 : public codecvt<Elem, char, mbstate_t> {
    public:
      explicit codecvt_utf8_utf16(size_t refs = 0);
      ~codecvt_utf8_utf16();
    };
}
\end{codeblock}

\rSec2[depr.locale.stdcvt.req]{Requirements}

\pnum
For each of the three code conversion facets \tcode{codecvt_utf8},
\tcode{codecvt_utf16}, and \tcode{codecvt_utf8_utf16}:
\begin{itemize}
\item
  \tcode{Elem} is the wide-character type, such as
  \keyword{wchar_t}, \keyword{char16_t}, or \keyword{char32_t}.
\item
  \tcode{Maxcode} is the largest wide-character code that the facet
  will read or write without reporting a conversion error.
\item
  If \tcode{(Mode \& consume_header)}, the facet shall consume an
  initial header sequence, if present, when reading a multibyte sequence
  to determine the endianness of the subsequent multibyte sequence to be read.
\item
  If \tcode{(Mode \& generate_header)}, the facet shall generate an
  initial header sequence when writing a multibyte sequence to advertise
  the endianness of the subsequent multibyte sequence to be written.
\item
  If \tcode{(Mode \& little_endian)}, the facet shall generate a
  multibyte sequence in little-endian order,
  as opposed to the default big-endian order.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8}\indexlibraryglobal{codecvt_utf8}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UCS-2 or UTF-32 (depending on the size of \tcode{Elem})
  within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf16}\indexlibraryglobal{codecvt_utf16}:
\begin{itemize}
\item
  The facet shall convert between UTF-16 multibyte sequences
  and UCS-2 or UTF-32 (depending on the size of \tcode{Elem})
  within the program.
\item
  Multibyte sequences shall be read or written
  according to the \tcode{Mode} flag, as set out above.
\item
  The multibyte sequences may be written only as a binary file.
  Attempting to write to a text file produces undefined behavior.
\end{itemize}

\pnum
For the facet \tcode{codecvt_utf8_utf16}\indexlibraryglobal{codecvt_utf8_utf16}:
\begin{itemize}
\item
  The facet shall convert between UTF-8 multibyte sequences
  and UTF-16 (one or two 16-bit codes) within the program.
\item
  Endianness shall not affect how multibyte sequences are read or written.
\item
  The multibyte sequences may be written as either a text or a binary file.
\end{itemize}

\pnum
The encoding forms UTF-8, UTF-16, and UTF-32 are specified in ISO/IEC 10646.
The encoding form UCS-2 is specified in ISO/IEC 10646:2003.
\begin{footnote}
Cancelled and replaced by ISO/IEC 10646:2017.
\end{footnote}

\rSec1[depr.conversions]{Deprecated convenience conversion interfaces}

\rSec2[depr.conversions.general]{General}

\pnum
The header \libheaderref{locale} has the following additions:

\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class WideAlloc = allocator<Elem>,
           class ByteAlloc = allocator<char>>
    class wstring_convert;

  template<class Codecvt, class Elem = wchar_t,
           class Tr = char_traits<Elem>>
    class wbuffer_convert;
}
\end{codeblock}

\rSec2[depr.conversions.string]{Class template \tcode{wstring_convert}}

\pnum
Class template \tcode{wstring_convert} performs conversions between a wide
string and a byte string. It lets you specify a code conversion facet
(like class template \tcode{codecvt}) to perform the conversions, without
affecting any streams or locales.
\begin{example}
If you want to use the code
conversion facet \tcode{codecvt_utf8} to output to \tcode{cout} a UTF-8
multibyte sequence corresponding to a wide string, but you don't want to
alter the locale for \tcode{cout}, you can write something like:
\begin{codeblock}
wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout << mbstring;
\end{codeblock}
\end{example}

\indexlibraryglobal{wstring_convert}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t,
           class WideAlloc = allocator<Elem>,
           class ByteAlloc = allocator<char>>
    class wstring_convert {
    public:
      using byte_string = basic_string<char, char_traits<char>, ByteAlloc>;
      using wide_string = basic_string<Elem, char_traits<Elem>, WideAlloc>;
      using state_type  = typename Codecvt::state_type;
      using int_type    = typename wide_string::traits_type::int_type;

      wstring_convert() : wstring_convert(new Codecvt) {}
      explicit wstring_convert(Codecvt* pcvt);
      wstring_convert(Codecvt* pcvt, state_type state);
      explicit wstring_convert(const byte_string& byte_err,
                               const wide_string& wide_err = wide_string());
      ~wstring_convert();

      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;

      wide_string from_bytes(char byte);
      wide_string from_bytes(const char* ptr);
      wide_string from_bytes(const byte_string& str);
      wide_string from_bytes(const char* first, const char* last);

      byte_string to_bytes(Elem wchar);
      byte_string to_bytes(const Elem* wptr);
      byte_string to_bytes(const wide_string& wstr);
      byte_string to_bytes(const Elem* first, const Elem* last);

      size_t converted() const noexcept;
      state_type state() const;

    private:
      byte_string byte_err_string;  // \expos
      wide_string wide_err_string;  // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
      size_t cvtcount;              // \expos
    };
}
\end{codeblock}

\pnum
The class template describes an object that controls conversions between wide
string objects of class \tcode{basic_string<Elem, char_traits<Elem>,
WideAlloc>} and byte string objects of class \tcode{basic_string<char,
char_traits<char>, ByteAlloc>}. The class template defines the types
\tcode{wide_string} and \tcode{byte_string} as synonyms for these two types.
Conversion between a sequence of \tcode{Elem} values (stored in a
\tcode{wide_string} object) and multibyte sequences (stored in a
\tcode{byte_string} object) is performed by an object of class
\tcode{Codecvt}, which meets the
requirements of the standard code-conversion facet \tcode{codecvt<Elem,
char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{byte_err_string} --- a byte string to display on errors
\item \tcode{wide_err_string} --- a wide string to display on errors
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wstring_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\item \tcode{cvtcount} --- a conversion count
\end{itemize}

\indexlibrarymember{byte_string}{wstring_convert}%
\begin{itemdecl}
using byte_string = basic_string<char, char_traits<char>, ByteAlloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<char, char_traits<char>, ByteAlloc>}.
\end{itemdescr}

\indexlibrarymember{converted}{wstring_convert}%
\begin{itemdecl}
size_t converted() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{cvtcount}.
\end{itemdescr}

\indexlibrarymember{from_bytes}{wstring_convert}%
\begin{itemdecl}
wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char* first, const char* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{byte} to a
wide string. The second member function shall convert the null-terminated
sequence beginning at \tcode{ptr} to a wide string. The third member function
shall convert the sequence stored in \tcode{str} to a wide string. The fourth member
function shall convert the sequence defined by the range \range{first}{last} to a
wide string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.

\item The number of input elements successfully converted shall be stored in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the
member function shall return the wide-error string.
Otherwise, the member function throws an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{int_type}{wstring_convert}%
\begin{itemdecl}
using int_type = typename wide_string::traits_type::int_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{wide_string::traits_type::int_type}.
\end{itemdescr}

\indexlibrarymember{state}{wstring_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{state_type}{wstring_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibrarymember{to_bytes}{wstring_convert}%
\begin{itemdecl}
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem* first, const Elem* last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The first member function shall convert the single-element sequence \tcode{wchar} to a byte string.
The second member function shall convert the null-terminated sequence beginning at \tcode{wptr} to
a byte string. The third member function shall convert the sequence stored in \tcode{wstr} to a
byte string. The fourth member function shall convert the sequence defined by the
range \range{first}{last} to a byte string.

\pnum
In all cases:

\begin{itemize}
\item If the \tcode{cvtstate} object was not constructed with an explicit value, it
shall be
set to its default value (the initial conversion state) before the
conversion begins. Otherwise it shall be left unchanged.
\item The number of input elements successfully converted shall be stored
in \tcode{cvtcount}.
\end{itemize}

\pnum
\returns
If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the
member function shall return the byte-error string.
Otherwise, the member function shall throw an object of class \tcode{range_error}.
\end{itemdescr}

\indexlibrarymember{wide_string}{wstring_convert}%
\begin{itemdecl}
using wide_string = basic_string<Elem, char_traits<Elem>, WideAlloc>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{basic_string<Elem,
char_traits<Elem>, WideAlloc>}.
\end{itemdescr}

\indexlibraryctor{wstring_convert}%
\begin{itemdecl}
explicit wstring_convert(Codecvt* pcvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string& byte_err,
    const wide_string& wide_err = wide_string());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For the first and second constructors, \tcode{pcvt != nullptr}.

\pnum
\effects
The first constructor shall store \tcode{pcvt} in \tcode{cvtptr} and
default values in \tcode{cvtstate}, \tcode{byte_err_string}, and
\tcode{wide_err_string}.
The second constructor shall store \tcode{pcvt} in \tcode{cvtptr},
\tcode{state} in \tcode{cvtstate}, and default values in
\tcode{byte_err_string} and \tcode{wide_err_string}; moreover the
stored state shall be retained between calls to \tcode{from_bytes} and
\tcode{to_bytes}.
The third constructor shall store \tcode{new Codecvt} in \tcode{cvtptr},
\tcode{state_type()} in \tcode{cvtstate}, \tcode{byte_err}
in \tcode{byte_err_string}, and \tcode{wide_err} in
\tcode{wide_err_string}.
\end{itemdescr}

\indexlibrarydtor{wstring_convert}%
\begin{itemdecl}
~wstring_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}

\rSec2[depr.conversions.buffer]{Class template \tcode{wbuffer_convert}}

\pnum
Class template \tcode{wbuffer_convert} looks like a wide stream buffer, but
performs all its I/O through an underlying byte stream buffer that you
specify when you construct it. Like class template \tcode{wstring_convert}, it
lets you specify a code conversion facet to perform the conversions,
without affecting any streams or locales.

\indexlibraryglobal{wbuffer_convert}%
\begin{codeblock}
namespace std {
  template<class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
    class wbuffer_convert : public basic_streambuf<Elem, Tr> {
    public:
      using state_type = typename Codecvt::state_type;

      wbuffer_convert() : wbuffer_convert(nullptr) {}
      explicit wbuffer_convert(streambuf* bytebuf,
                               Codecvt* pcvt = new Codecvt,
                               state_type state = state_type());

      ~wbuffer_convert();

      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const;
      streambuf* rdbuf(streambuf* bytebuf);

      state_type state() const;

    private:
      streambuf* bufptr;            // \expos
      Codecvt* cvtptr;              // \expos
      state_type cvtstate;          // \expos
  };
}
\end{codeblock}

\pnum
The class template describes a stream buffer that controls the
transmission of elements of type \tcode{Elem}, whose character traits are
described by the class \tcode{Tr}, to and from a byte stream buffer of type
\tcode{streambuf}. Conversion between a sequence of \tcode{Elem} values and
multibyte sequences is performed by an object of class
\tcode{Codecvt}, which shall meet the requirements
of the standard code-conversion facet \tcode{codecvt<Elem, char, mbstate_t>}.

\pnum
An object of this class template stores:

\begin{itemize}
\item \tcode{bufptr} --- a pointer to its underlying byte stream buffer
\item \tcode{cvtptr} --- a pointer to the allocated conversion object
(which is freed when the \tcode{wbuffer_convert} object is destroyed)
\item \tcode{cvtstate} --- a conversion state object
\end{itemize}

\indexlibrarymember{state}{wbuffer_convert}%
\begin{itemdecl}
state_type state() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{cvtstate}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{wbuffer_convert}%
\begin{itemdecl}
streambuf* rdbuf(streambuf* bytebuf);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Stores \tcode{bytebuf} in \tcode{bufptr}.

\pnum
\returns
The previous value of \tcode{bufptr}.
\end{itemdescr}

\indexlibrarymember{state_type}{wbuffer_convert}%
\begin{itemdecl}
using state_type = typename Codecvt::state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type shall be a synonym for \tcode{Codecvt::state_type}.
\end{itemdescr}

\indexlibraryctor{wbuffer_convert}%
\begin{itemdecl}
explicit wbuffer_convert(
    streambuf* bytebuf,
    Codecvt* pcvt = new Codecvt,
    state_type state = state_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pcvt != nullptr}.

\pnum
\effects
The constructor constructs a stream buffer object, initializes
\tcode{bufptr} to \tcode{bytebuf}, initializes \tcode{cvtptr}
to \tcode{pcvt}, and initializes \tcode{cvtstate} to \tcode{state}.
\end{itemdescr}

\indexlibrarydtor{wbuffer_convert}%
\begin{itemdecl}
~wbuffer_convert();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The destructor shall delete \tcode{cvtptr}.
\end{itemdescr}

\rSec1[depr.locale.category]{Deprecated locale category facets}

\pnum
The \tcode{ctype} locale category includes the following facets
as if they were specified
in table \tref{locale.category.facets} of \ref{locale.category}.

\begin{codeblock}
codecvt<char16_t, char, mbstate_t>
codecvt<char32_t, char, mbstate_t>
\end{codeblock}

\pnum
The \tcode{ctype} locale category includes the following facets
as if they were specified
in table \tref{locale.spec} of \ref{locale.category}.

\begin{codeblock}
codecvt_byname<char16_t, char, mbstate_t>
codecvt_byname<char32_t, char, mbstate_t>
\end{codeblock}

\pnum
The following class template specializations are required
in addition to those specified in~\ref{locale.codecvt}.
The specialization \tcode{codecvt<char16_t, char, mbstate_t>}
converts between the UTF-16 and UTF-8 encoding forms, and
the specialization \tcode{codecvt<char32_t, char, mbstate_t>}
converts between the UTF-32 and UTF-8 encoding forms.

\rSec1[depr.fs.path.factory]{Deprecated filesystem path factory functions}

\indexlibraryglobal{u8path}%
\begin{itemdecl}
template<class Source>
  path u8path(const Source& source);
template<class InputIterator>
  path u8path(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The \tcode{source} and \range{first}{last}
  sequences are UTF-8 encoded. The value type of \tcode{Source}
  and \tcode{InputIterator} is \tcode{char} or \keyword{char8_t}.
  \tcode{Source} meets the requirements specified in \ref{fs.path.req}.

\pnum
\returns
\begin{itemize}
\item If \tcode{value_type} is \tcode{char} and the current native
      narrow encoding\iref{fs.path.type.cvt} is UTF-8,
      return \tcode{path(source)} or \tcode{path(first, last)};
      otherwise,
\item if \tcode{value_type} is \keyword{wchar_t} and the
      native wide encoding is UTF-16, or
      if \tcode{value_type} is \keyword{char16_t} or \keyword{char32_t},
      convert \tcode{source} or \range{first}{last}
      to a temporary, \tcode{tmp}, of type \tcode{string_type} and
      return \tcode{path(tmp)};
      otherwise,
\item convert \tcode{source} or \range{first}{last}
      to a temporary, \tcode{tmp}, of type \tcode{u32string} and
      return \tcode{path(tmp)}.
\end{itemize}

\pnum
\remarks
Argument format conversion\iref{fs.path.fmt.cvt} applies to the
  arguments for these functions. How Unicode encoding conversions are performed is
  unspecified.

\pnum
\begin{example}
A string is to be read from a database that is encoded in UTF-8, and used
    to create a directory using the native encoding for filenames:
\begin{codeblock}
namespace fs = std::filesystem;
std::string utf8_string = read_utf8_data();
fs::create_directory(fs::u8path(utf8_string));
\end{codeblock}

For POSIX-based operating systems with the native narrow encoding set
    to UTF-8, no encoding or type conversion occurs.

For POSIX-based operating systems with the native narrow encoding not
    set to UTF-8, a conversion to UTF-32 occurs, followed by a conversion to the
    current native narrow encoding. Some Unicode characters may have no native character
    set representation.

For Windows-based operating systems a conversion from UTF-8 to
    UTF-16 occurs.
\end{example}
\begin{note}
The example above is representative of
a historical use of \tcode{filesystem::u8path}.
To indicate a UTF-8 encoding,
passing a \tcode{std::u8string} to \tcode{path}'s constructor is preferred
as it is consistent with \tcode{path}'s handling of other encodings.
\end{note}
\end{itemdescr}

\rSec1[depr.atomics]{Deprecated atomic operations}

\rSec2[depr.atomics.general]{General}

\pnum
The header \libheaderrefx{atomic}{atomics.syn} has the following additions.

\begin{codeblock}
namespace std {
  template<class T>
    void atomic_init(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    void atomic_init(atomic<T>*, typename atomic<T>::value_type) noexcept;

  #define ATOMIC_VAR_INIT(value) @\seebelow@

  #define ATOMIC_FLAG_INIT @\seebelow@
}
\end{codeblock}

\rSec2[depr.atomics.volatile]{Volatile access}

\pnum
If an atomic specialization has one of the following overloads,
then that overload participates in overload resolution
even if \tcode{atomic<T>::is_always_lock_free} is \tcode{false}:
\begin{codeblock}
void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
T operator=(T desired) volatile noexcept;
T load(memory_order order = memory_order::seq_cst) const volatile noexcept;
operator T() const volatile noexcept;
T exchange(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
bool compare_exchange_weak(T& expected, T desired,
                           memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_weak(T& expected, T desired,
                           memory_order order = memory_order::seq_cst) volatile noexcept;
bool compare_exchange_strong(T& expected, T desired,
                             memory_order order = memory_order::seq_cst) volatile noexcept;
T fetch_@\placeholdernc{key}@(T operand, memory_order order = memory_order::seq_cst) volatile noexcept;
T operator @\placeholdernc{op}@=(T operand) volatile noexcept;
T* fetch_@\placeholdernc{key}@(ptrdiff_t operand, memory_order order = memory_order::seq_cst) volatile noexcept;
\end{codeblock}

\rSec2[depr.atomics.nonmembers]{Non-member functions}

\indexlibraryglobal{atomic_init}%
\begin{itemdecl}
template<class T>
  void atomic_init(volatile atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
template<class T>
  void atomic_init(atomic<T>* object, typename atomic<T>::value_type desired) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{atomic_store_explicit(object, desired, memory_order::relaxed);}
\end{itemdescr}

\rSec2[depr.atomics.types.operations]{Operations on atomic types}

\indexlibraryglobal{ATOMIC_VAR_INIT}%
\begin{itemdecl}
#define ATOMIC_VAR_INIT(value) @\seebelow@
\end{itemdecl}

\begin{itemdescr}
\pnum
The macro expands to a token sequence suitable for constant initialization of
an atomic variable of static storage duration of a type that
is initialization-compatible with \tcode{value}.
\begin{note}
This operation possibly needs to initialize locks.
\end{note}
Concurrent access to the variable being initialized,
even via an atomic operation,
constitutes a data race.
\begin{example}
\begin{codeblock}
atomic<int> v = ATOMIC_VAR_INIT(5);
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec2[depr.atomics.flag]{Flag type and operations}

\indexlibraryglobal{ATOMIC_FLAG_INIT}%
\begin{itemdecl}
#define ATOMIC_FLAG_INIT @\seebelow@
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks
The macro \tcode{ATOMIC_FLAG_INIT} is defined in such a way that
it can be used to initialize an object of type \tcode{atomic_flag}
to the clear state.
The macro can be used in the form:
\begin{codeblock}
atomic_flag guard = ATOMIC_FLAG_INIT;
\end{codeblock}
It is unspecified whether the macro can be used
in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
\end{itemdescr}
