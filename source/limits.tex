%!TEX root = std.tex
\infannex{implimits}{Implementation quantities}

\pnum
Implementations can exhibit limitations for various quantities;
some possibilities are presented in the following list.
The bracketed number following each quantity is
a potential minimum value for that quantity.
\begin{itemize}
\item%
Nesting levels of compound statements\iref{stmt.block},
iteration control structures\iref{stmt.iter},
and selection control structures\iref{stmt.select} [256].
\item%
Nesting levels of conditional inclusion\iref{cpp.cond} [256].
\item%
Pointer\iref{dcl.ptr},
pointer-to-member\iref{dcl.mptr},
array\iref{dcl.array}, and
function\iref{dcl.fct}
declarators (in any combination)
modifying a type in a declaration [256].
\item%
Nesting levels of parenthesized expressions\iref{expr.prim.paren} within a full-expression [256].
\item%
Number of
characters in an internal identifier\iref{lex.name}
or macro name\iref{cpp.replace} [1\,024].
\item%
Number of
characters in an external identifier\iref{lex.name,basic.link} [1\,024].
\item%
External identifiers\iref{basic.link} in one translation unit [65\,536].
\item%
Identifiers with block scope declared in one block\iref{basic.scope.block} [1\,024].
\item%
Structured bindings\iref{dcl.struct.bind} introduced in one declaration [256].
\item%
Macro identifiers\iref{cpp.replace} simultaneously defined in one
translation
unit [65\,536].
\item%
Parameters in one function definition\iref{dcl.fct.def.general} [256].
\item%
Arguments in one function call\iref{expr.call} [256].
\item%
Parameters in one macro definition\iref{cpp.replace} [256].
\item%
Arguments in one macro invocation\iref{cpp.replace} [256].
\item%
Characters in one logical source line\iref{lex.phases} [65\,536].
\item%
Characters in a \grammarterm{string-literal}\iref{lex.string}
(after concatenation\iref{lex.phases}) [65\,536].
\item%
Size of an object\iref{intro.object} [262\,144].
\item%
Nesting levels for
\tcode{\#include}
files\iref{cpp.include} [256].
\item%
Case labels for a
\keyword{switch}
statement\iref{stmt.switch} (excluding those for any nested
\keyword{switch}
statements)
[16\,384].
\item%
Non-static data members (including inherited ones) in a single class\iref{class.mem} [16\,384].
\item%
Lambda-captures in one \grammarterm{lambda-expression}\iref{expr.prim.lambda.capture} [256].
\item%
Enumeration constants in a single enumeration\iref{dcl.enum} [4\,096].
\item%
Levels of nested class definitions\iref{class.nest}
in a single
\grammarterm{member-specification}
[256].
\item%
Functions registered by
\tcode{atexit()}\iref{support.start.term} [32].
\item%
Functions registered by
\tcode{at_quick_exit()}\iref{support.start.term} [32].
\item%
Direct and indirect base classes\iref{class.derived} [16\,384].
\item%
Direct base classes for a single class\iref{class.derived} [1\,024].
\item%
Class members declared in a single \grammarterm{member-specification}
(including member functions)\iref{class.mem} [4\,096].
\item%
Final overriding virtual functions in a class,
accessible or not\iref{class.virtual} [16\,384].
\item%
Direct and indirect virtual bases of a class\iref{class.mi} [1\,024].
\item%
Static data members of a class\iref{class.static.data} [1\,024].
\item%
Friend declarations in a class\iref{class.friend} [4\,096].
\item%
Access control declarations in a class\iref{class.access.spec} [4\,096].
\item%
Member initializers in a constructor definition\iref{class.base.init} [6\,144].
\item%
\grammarterm{initializer-clause}{s} in one \grammarterm{braced-init-list}\iref{dcl.init} [16\,384].
\item%
Scope qualifications of one identifier\iref{expr.prim.id.qual} [256].
\item%
Nested \grammarterm{linkage-specification}s\iref{dcl.link} [1\,024].
\item%
Recursive constexpr function invocations\iref{dcl.constexpr} [512].
\item%
Full-expressions evaluated within a core constant expression\iref{expr.const} [1\,048\,576].
\item%
Template parameters in a template declaration\iref{temp.param} [1\,024].
\item%
Recursively nested template instantiations\iref{temp.inst}, including substitution
during template argument deduction\iref{temp.deduct} [1\,024].
\item%
Handlers per try block\iref{except.handle} [256].
\item%
Number of placeholders\iref{func.bind.place} [10].
\item%
Number of hazard-protectable possibly-reclaimable objects\iref{saferecl.hp.general} [256].

\end{itemize}
