%!TEX root = std.tex
\rSec0[cpp]{Preprocessing directives}%
\indextext{preprocessing directive|(}

\indextext{compiler control line|see{preprocessing directive}}%
\indextext{control line|see{preprocessing directive}}%
\indextext{directive, preprocessing|see{preprocessing directive}}

\gramSec[gram.cpp]{Preprocessing directives}

\rSec1[cpp.pre]{Preamble}

\begin{bnf}
\nontermdef{preprocessing-file}\br
    \opt{group}\br
    module-file
\end{bnf}

\begin{bnf}
\nontermdef{module-file}\br
    \opt{pp-global-module-fragment} pp-module \opt{group} \opt{pp-private-module-fragment}
\end{bnf}

\begin{bnf}
\nontermdef{pp-global-module-fragment}\br
    \keyword{module} \terminal{;} new-line \opt{group}
\end{bnf}

\begin{bnf}
\nontermdef{pp-private-module-fragment}\br
    \keyword{module} \terminal{:} \keyword{private} \terminal{;} new-line \opt{group}
\end{bnf}

\begin{bnf}
\nontermdef{group}\br
    group-part\br
    group group-part
\end{bnf}

\begin{bnf}
\nontermdef{group-part}\br
    control-line\br
    if-section\br
    text-line\br
    \terminal{\#} conditionally-supported-directive
\end{bnf}

\begin{bnf}
\nontermdef{control-line}\br
    \terminal{\# include} pp-tokens new-line\br
    pp-import\br
    \terminal{\# embed \ } pp-tokens new-line\br
    \terminal{\# define } identifier replacement-list new-line\br
    \terminal{\# define } identifier lparen \opt{identifier-list} \terminal{)} replacement-list new-line\br
    \terminal{\# define } identifier lparen \terminal{... )} replacement-list new-line\br
    \terminal{\# define } identifier lparen identifier-list \terminal{, ... )} replacement-list new-line\br
    \terminal{\# undef \ } identifier new-line\br
    \terminal{\# line \ \ } pp-tokens new-line\br
    \terminal{\# error \ } \opt{pp-tokens} new-line\br
    \terminal{\# warning} \opt{pp-tokens} new-line\br
    \terminal{\# pragma } \opt{pp-tokens} new-line\br
    \terminal{\# }new-line
\end{bnf}

\begin{bnf}
\nontermdef{if-section}\br
    if-group \opt{elif-groups} \opt{else-group} endif-line
\end{bnf}

\begin{bnf}
\nontermdef{if-group}\br
    \terminal{\# if \ \ \ \ } constant-expression new-line \opt{group}\br
    \terminal{\# ifdef \ } identifier new-line \opt{group}\br
    \terminal{\# ifndef } identifier new-line \opt{group}
\end{bnf}

\begin{bnf}
\nontermdef{elif-groups}\br
    elif-group \opt{elif-groups}
\end{bnf}

\begin{bnf}
\nontermdef{elif-group}\br
    \terminal{\# elif \ \ \ } constant-expression new-line \opt{group}\br
    \terminal{\# elifdef } identifier new-line \opt{group}\br
    \terminal{\# elifndef} identifier new-line \opt{group}
\end{bnf}

\begin{bnf}
\nontermdef{else-group}\br
    \terminal{\# else \ \ } new-line \opt{group}
\end{bnf}

\begin{bnf}
\nontermdef{endif-line}\br
    \terminal{\# endif \ } new-line
\end{bnf}

\begin{bnf}
\nontermdef{text-line}\br
    \opt{pp-tokens} new-line
\end{bnf}

\begin{bnf}
\nontermdef{conditionally-supported-directive}\br
    pp-tokens new-line
\end{bnf}

\begin{bnf}
\nontermdef{lparen}\br
    \descr{a \terminal{(} character not immediately preceded by whitespace}
\end{bnf}

\begin{bnf}
\nontermdef{identifier-list}\br
    identifier\br
    identifier-list \terminal{,} identifier
\end{bnf}

\begin{bnf}
\nontermdef{replacement-list}\br
    \opt{pp-tokens}
\end{bnf}

\begin{bnf}
\nontermdef{pp-tokens}\br
    preprocessing-token \opt{pp-tokens}
\end{bnf}

\begin{bnf}
\nontermdef{embed-parameter-seq}\br
    embed-parameter \opt{embed-parameter-seq}
\end{bnf}

\begin{bnf}
\nontermdef{embed-parameter}\br
    embed-standard-parameter\br
    embed-prefixed-parameter
\end{bnf}

\begin{bnf}
\nontermdef{embed-standard-parameter}\br
    \terminal{limit} \terminal{(} pp-balanced-token-seq \terminal{)}\br
    \terminal{prefix} \terminal{(} \opt{pp-balanced-token-seq} \terminal{)}\br
    \terminal{suffix} \terminal{(} \opt{pp-balanced-token-seq} \terminal{)}\br
    \terminal{if_empty} \terminal{(} \opt{pp-balanced-token-seq} \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{embed-prefixed-parameter}\br
    identifier :: identifier\br
    identifier :: identifier \terminal{(} \opt{pp-balanced-token-seq} \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{pp-balanced-token-seq}\br
    pp-balanced-token \opt{pp-balanced-token-seq}
\end{bnf}

\begin{bnf}
\nontermdef{pp-balanced-token}\br
    \terminal{(} \opt{pp-balanced-token-seq} \terminal{)}\br
    \terminal{[} \opt{pp-balanced-token-seq} \terminal{]}\br
    \terminal{\{} \opt{pp-balanced-token-seq} \terminal{\}}\br
    \textnormal{any} pp-token \textnormal{except:}\br
    \bnfindent\textnormal{parenthesis (\unicode{0028}{left parenthesis} and \unicode{0029}{right parenthesis}),}\br
    \bnfindent\textnormal{bracket (\unicode{005b}{left square bracket} and \unicode{005d}{right square bracket}), or}\br
    \bnfindent\textnormal{brace (\unicode{007b}{left curly bracket} and \unicode{007d}{right curly bracket}).}
\end{bnf}

\begin{bnf}
\nontermdef{new-line}\br
    \descr{the new-line character}
\end{bnf}

\pnum
A \defn{preprocessing directive} consists of a sequence of preprocessing tokens
that satisfies the following constraints:
At the start of translation phase 4,
the first preprocessing token in the sequence,
referred to as a \defnadj{directive-introducing}{token},
begins with the first character in the source file
(optionally after whitespace containing no new-line characters) or
follows whitespace containing at least one new-line character,
and is

\begin{itemize}
\item
a \tcode{\#} preprocessing token, or

\item
an \keyword{import} preprocessing token
immediately followed on the same logical source line by a
\grammarterm{header-name},
\tcode{<},
\grammarterm{identifier},
\grammarterm{string-literal}, or
\tcode{:}
preprocessing token, or

\item
a \keyword{module} preprocessing token
immediately followed on the same logical source line by an
\grammarterm{identifier},
\tcode{:}, or
\tcode{;}
preprocessing token, or

\item
an \keyword{export} preprocessing token
immediately followed on the same logical source line by
one of the two preceding forms.
\end{itemize}

The last preprocessing token in the sequence is the first preprocessing token within the sequence that
is immediately followed by whitespace containing a new-line character.
\begin{footnote}
Thus,
preprocessing directives are commonly called ``lines''.
These ``lines'' have no other syntactic significance,
as all whitespace is equivalent except in certain situations
during preprocessing (see the
\tcode{\#}
character string literal creation operator in~\ref{cpp.stringize}, for example).
\end{footnote}
\begin{note}
A new-line character ends the preprocessing directive even if it occurs
within what would otherwise be an invocation of a function-like macro.
\end{note}

\begin{example}
\begin{codeblock}
#                       // preprocessing directive
module ;                // preprocessing directive
export module leftpad;  // preprocessing directive
import <string>;        // preprocessing directive
export import "squee";  // preprocessing directive
import rightpad;        // preprocessing directive
import :part;           // preprocessing directive

module                  // not a preprocessing directive
;                       // not a preprocessing directive

export                  // not a preprocessing directive
import                  // not a preprocessing directive
foo;                    // not a preprocessing directive

export                  // not a preprocessing directive
import foo;             // preprocessing directive (ill-formed at phase 7)

import ::               // not a preprocessing directive
import ->               // not a preprocessing directive
\end{codeblock}
\end{example}

\pnum
A sequence of preprocessing tokens is only a \grammarterm{text-line}
if it does not begin with a directive-introducing token.
\begin{example}
\begin{codeblock}
using module = int;
module i;               // not a \grammarterm{text-line} and not a \grammarterm{control-line}
int foo() {
  return i;
}
\end{codeblock}
The example is not a valid \grammarterm{preprocessing-file}.
\end{example}
A sequence of preprocessing tokens is only a \grammarterm{conditionally-supported-directive}
if it does not begin with any of the directive names
appearing after a \tcode{\#} in the syntax.
A \grammarterm{conditionally-supported-directive} is
conditionally-supported with
\impldef{additional supported forms of preprocessing directive}
semantics.

\pnum
Any \grammarterm{embed-prefixed-parameter} is conditionally-supported,
with \impldef{supported forms of \#embed prefix parameters} semantics.

\pnum
At the start of phase 4 of translation,
the \grammarterm{group} of a \grammarterm{pp-global-module-fragment} shall
contain neither a \grammarterm{text-line} nor a \grammarterm{pp-import}.

\pnum
When in a group that is skipped\iref{cpp.cond}, the directive
syntax is relaxed to allow any sequence of preprocessing tokens to occur between
the directive name and the following new-line character.

\pnum
The only whitespace characters that shall appear
between preprocessing tokens
within a preprocessing directive
(from just after the directive-introducing token
through just before the terminating new-line character)
are space and horizontal-tab
(including spaces that have replaced comments
or possibly other whitespace characters
in translation phase 3).

\pnum
The implementation can
process and skip sections of source files conditionally,
include other source files,
import macros from header units,
and replace macros.
These capabilities are called
\defn{preprocessing},
because conceptually they occur
before translation of the resulting translation unit.

\pnum
The preprocessing tokens within a preprocessing directive
are not subject to macro expansion unless otherwise stated.

\begin{example}
In:
\begin{codeblock}
#define EMPTY
EMPTY   #   include <file.h>
\end{codeblock}
the sequence of preprocessing tokens on the second line is \textit{not}
a preprocessing directive, because it does not begin with a \tcode{\#} at the start of
translation phase 4, even though it will do so after the macro \tcode{EMPTY}
has been replaced.
\end{example}

\rSec1[cpp.cond]{Conditional inclusion}%
\indextext{preprocessing directive!conditional inclusion}%
\indextext{inclusion!conditional|see{preprocessing directive, conditional inclusion}}

\indextext{\idxcode{defined}}%
\begin{bnf}
\nontermdef{defined-macro-expression}\br
    \terminal{defined} identifier\br
    \terminal{defined (} identifier \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{h-preprocessing-token}\br
    \textnormal{any \grammarterm{preprocessing-token} other than \terminal{>}}
\end{bnf}

\begin{bnf}
\nontermdef{h-pp-tokens}\br
    h-preprocessing-token \opt{h-pp-tokens}
\end{bnf}

\begin{bnf}
\nontermdef{header-name-tokens}\br
    string-literal\br
    \terminal{<} h-pp-tokens \terminal{>}
\end{bnf}

\indextext{\idxxname{has_include}}%
\begin{bnf}
\nontermdef{has-include-expression}\br
    \terminal{\xname{has_include}} \terminal{(} header-name \terminal{)}\br
    \terminal{\xname{has_include}} \terminal{(} header-name-tokens \terminal{)}
\end{bnf}

\indextext{\idxxname{has_embed}}%
\begin{bnf}
\nontermdef{has-embed-expression}\br
    \terminal{\xname{has_embed}} \terminal{(} pp-balanced-token-seq \terminal{)}
\end{bnf}

\indextext{\idxxname{has_cpp_attribute}}%
\begin{bnf}
\nontermdef{has-attribute-expression}\br
    \terminal{\xname{has_cpp_attribute} (} pp-tokens \terminal{)}
\end{bnf}

\pnum
The expression that controls conditional inclusion
shall be an integral constant expression except that
identifiers
(including those lexically identical to keywords)
are interpreted as described below
\begin{footnote}
Because the controlling constant expression is evaluated
during translation phase 4,
all identifiers either are or are not macro names ---
there simply are no keywords, enumeration constants, etc.
\end{footnote}
and it may contain zero or more
\grammarterm{defined-macro-expression}{s},
\grammarterm{has-include-expression}{s},
\grammarterm{has-attribute-expression}{s},
and/or \grammarterm{has-embed-expression}{s}
as unary operator expressions.

\pnum
A \grammarterm{defined-macro-expression} evaluates to \tcode{1}
if the identifier is currently defined
as a macro name
(that is, if it is predefined
or if it has one or more active macro definitions\iref{cpp.import},
for example because
it has been the subject of a
\tcode{\#define}
preprocessing directive
without an intervening
\tcode{\#undef}
directive with the same subject identifier), \tcode{0} if it is not.

\pnum
The second form of \grammarterm{has-include-expression}
is considered only if the first form does not match,
in which case the preprocessing tokens are processed just as in normal text.

\pnum
The header or source file identified by
the parenthesized preprocessing token sequence
in each contained \grammarterm{has-include-expression}
is searched for as if that preprocessing token sequence
were the \grammarterm{pp-tokens} in a \tcode{\#include} directive,
except that no further macro expansion is performed.
If such a directive would not satisfy the syntactic requirements
of a \tcode{\#include} directive, the program is ill-formed.
The \grammarterm{has-include-expression} evaluates
to \tcode{1} if the search for the source file succeeds, and
to \tcode{0} if the search fails.

\pnum
The parenthesized \grammarterm{pp-balanced-token-seq} in each contained
\grammarterm{has-embed-expression} is processed as if that
\grammarterm{pp-balanced-token-seq} were the \grammarterm{pp-tokens} in the
third form of a \tcode{\#embed} directive\iref{cpp.embed}.
If such a directive would not satisfy the syntactic requirements of a
\tcode{\#embed} directive, the program is ill-formed.
The \grammarterm{has-embed-expression} evaluates to:
\begin{itemize}
\item
\mname{STDC_EMBED_FOUND} if the search for the resource succeeds,
all the given \grammarterm{embed-parameter}s in the \grammarterm{embed-parameter-seq}
are supported, and the resource is not empty.
\item
Otherwise, \mname{STDC_EMBED_EMPTY} if the search for the resource succeeds,
all the given \grammarterm{embed-parameter}s in the \grammarterm{embed-parameter-seq}
are supported, and the resource is empty.
\item
Otherwise, \mname{STDC_EMBED_NOT_FOUND}.
\end{itemize}
\begin{note}
An unrecognized \grammarterm{embed-parameter} in an \grammarterm{has-embed-expression}
is not ill-formed and is instead treated as not supported.
\end{note}

\pnum
Each \grammarterm{has-attribute-expression} is replaced by
a non-zero \grammarterm{pp-number}
matching the form of an \grammarterm{integer-literal}
if the implementation supports an attribute
with the name specified by interpreting
the \grammarterm{pp-tokens}, after macro expansion,
as an \grammarterm{attribute-token},
and by \tcode{0} otherwise.
The program is ill-formed if the \grammarterm{pp-tokens}
do not match the form of an \grammarterm{attribute-token}.

\pnum
For an attribute specified in this document,
it is \impldef{value of \grammarterm{has-attribute-expression}
for standard attributes}
whether the value of the \grammarterm{has-attribute-expression}
is \tcode{0} or is given by \tref{cpp.cond.ha}.
For other attributes recognized by the implementation,
the value is
\impldef{value of \grammarterm{has-attribute-expression}
for non-standard attributes}.
\begin{note}
It is expected
that the availability of an attribute can be detected by any non-zero result.
\end{note}

\begin{floattable}{\xname{has_cpp_attribute} values}{cpp.cond.ha}
{ll}
\topline
\lhdr{Attribute} & \rhdr{Value} \\ \rowsep
\tcode{assume}                & \tcode{202207L} \\
\tcode{deprecated}            & \tcode{201309L} \\
\tcode{fallthrough}           & \tcode{201603L} \\
\tcode{likely}                & \tcode{201803L} \\
\tcode{maybe_unused}          & \tcode{201603L} \\
\tcode{no_unique_address}     & \tcode{201803L} \\
\tcode{nodiscard}             & \tcode{201907L} \\
\tcode{noreturn}              & \tcode{200809L} \\
\tcode{unlikely}              & \tcode{201803L} \\
\end{floattable}

\pnum
The
\tcode{\#ifdef}, \tcode{\#ifndef}, \tcode{\#elifdef}, and \tcode{\#elifndef}
directives, and
the \tcode{defined} conditional inclusion operator,
shall treat \xname{has_include}, \xname{has_embed}, and \xname{has_cpp_attribute}
as if they were the names of defined macros.
The identifiers \xname{has_include}, \xname{has_embed}, and \xname{has_cpp_attribute}
shall not appear in any context not mentioned in this subclause.

\pnum
Each preprocessing token that remains (in the list of preprocessing tokens that
will become the controlling expression)
after all macro replacements have occurred
shall be in the lexical form of a token\iref{lex.token}.

\pnum
Preprocessing directives of the forms
\begin{ncsimplebnf}
\indextext{\idxcode{\#if}}%
\terminal{\# if \ \ \ \ } constant-expression new-line \opt{group}\br
\indextext{\idxcode{\#elif}}%
\terminal{\# elif \ \ } constant-expression new-line \opt{group}
\end{ncsimplebnf}
check whether the controlling constant expression evaluates to nonzero.

\pnum
Prior to evaluation,
macro invocations in the list of preprocessing tokens
that will become the controlling constant expression
are replaced
(except for those macro names modified by the
\tcode{defined}
unary operator),
just as in normal text.
If the preprocessing token
\tcode{defined}
is generated as a result of this replacement process
or use of the
\tcode{defined}
unary operator does not match one of the two specified forms
prior to macro replacement,
the behavior is undefined.

\pnum
After all replacements due to macro expansion and
evaluations of
\grammarterm{defined-macro-expression}s,
\grammarterm{has-include-expression}s,
\grammarterm{has-embed-expression}s, and
\grammarterm{has-attribute-expression}s
have been performed,
all remaining identifiers and keywords,
except for
\tcode{true}
and
\tcode{false},
are replaced with the \grammarterm{pp-number}
\tcode{0},
and then each preprocessing token is converted into a token.
\begin{note}
An alternative
token\iref{lex.digraph} is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not subject to this replacement.
\end{note}

\pnum
The resulting tokens comprise the controlling constant expression
which is evaluated according to the rules of~\ref{expr.const}
using arithmetic that has at least the ranges specified
in~\ref{support.limits}. For the purposes of this token conversion and evaluation
all signed and unsigned integer types
act as if they have the same representation as, respectively,
\tcode{intmax_t} or \tcode{uintmax_t}\iref{cstdint.syn}.
\begin{note}
Thus on an
implementation where \tcode{std::numeric_limits<int>::max()} is \tcode{0x7FFF}
and \tcode{std::numeric_limits<unsigned int>::max()} is \tcode{0xFFFF},
the integer literal \tcode{0x8000} is signed and positive within a \tcode{\#if}
expression even though it is unsigned in translation phase
7\iref{lex.phases}.
\end{note}
This includes interpreting \grammarterm{character-literal}s
according to the rules in \ref{lex.ccon}.
\begin{note}
The associated character encodings of literals are the same
in \tcode{\#if} and \tcode{\#elif} directives and in any expression.
\end{note}
Each subexpression with type
\tcode{bool}
is subjected to integral promotion before processing continues.

\pnum
Preprocessing directives of the forms
\begin{ncsimplebnf}
\terminal{\# ifdef \ \ } identifier new-line \opt{group}\br
\indextext{\idxcode{\#ifdef}}%
\terminal{\# ifndef \ } identifier new-line \opt{group}\br
\indextext{\idxcode{\#ifndef}}%
\terminal{\# elifdef } identifier new-line \opt{group}\br
\indextext{\idxcode{\#elifdef}}%
\terminal{\# elifndef} identifier new-line \opt{group}
\indextext{\idxcode{\#elifndef}}%
\end{ncsimplebnf}
check whether the identifier is or is not currently defined as a macro name.
Their conditions are equivalent to
\tcode{\#if} \tcode{defined} \grammarterm{identifier},
\tcode{\#if} \tcode{!defined} \grammarterm{identifier},
\tcode{\#elif} \tcode{defined} \grammarterm{identifier}, and
\tcode{\#elif} \tcode{!defined} \grammarterm{identifier},
respectively.

\pnum
Each directive's condition is checked in order.
If it evaluates to false (zero),
the group that it controls is skipped:
directives are processed only through the name that determines
the directive in order to keep track of the level
of nested conditionals;
the rest of the directives' preprocessing tokens are ignored,
as are the other preprocessing tokens in the group.
Only the first group
whose control condition evaluates to true (nonzero) is processed;
any following groups are skipped and their controlling directives
are processed as if they were in a group that is skipped.
If none of the conditions evaluates to true,
and there is a
\tcode{\#else}
\indextext{\idxcode{\#else}}%
directive,
the group controlled by the
\tcode{\#else}
is processed; lacking a
\tcode{\#else}
directive, all the groups until the
\tcode{\#endif}
\indextext{\idxcode{\#endif}}%
are skipped.%
\begin{footnote}
As indicated by the syntax,
a preprocessing token cannot follow a
\tcode{\#else}
or
\tcode{\#endif}
directive before the terminating new-line character.
However,
comments can appear anywhere in a source file,
including within a preprocessing directive.
\end{footnote}

\pnum
\begin{example}
This demonstrates a way to include a library \tcode{optional} facility
only if it is available:

\begin{codeblock}
#if __has_include(<optional>)
#  include <optional>
#  if __cpp_lib_optional >= 201603
#    define have_optional 1
#  endif
#elif __has_include(<experimental/optional>)
#  include <experimental/optional>
#  if __cpp_lib_experimental_optional >= 201411
#    define have_optional 1
#    define experimental_optional 1
#  endif
#endif
#ifndef have_optional
#  define have_optional 0
#endif
\end{codeblock}
\end{example}

\pnum
\begin{example}
This demonstrates a way to use the attribute \tcode{[[acme::deprecated]]}
only if it is available.
\begin{codeblock}
#if __has_cpp_attribute(acme::deprecated)
#  define ATTR_DEPRECATED(msg) [[acme::deprecated(msg)]]
#else
#  define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#endif
ATTR_DEPRECATED("This function is deprecated") void anvil();
\end{codeblock}
\end{example}

\rSec1[cpp.include]{Source file inclusion}
\indextext{preprocessing directive!header inclusion}
\indextext{preprocessing directive!source-file inclusion}
\indextext{inclusion!source file|see{preprocessing directive, source-file inclusion}}%
\indextext{\idxcode{\#include}}%

\pnum
A
\tcode{\#include}
directive shall identify a header or source file
that can be processed by the implementation.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# include <} h-char-sequence \terminal{>} new-line
\end{ncsimplebnf}
searches a sequence of
\impldef{sequence of places searched for a header}
places
for a header identified uniquely by the specified sequence
between the
\tcode{<}
and
\tcode{>}
delimiters,
and causes the replacement of that
directive by the entire contents of the header.
How the places are specified
or the header identified
is \impldef{search locations for \tcode{<>} header}.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# include "} q-char-sequence \terminal{"} new-line
\end{ncsimplebnf}
causes the replacement of that
directive by the entire contents of the
source file identified by the specified sequence between the
\tcode{"}
delimiters.
The named source file is searched for in an
\impldef{manner of search for included source file}
manner.
If this search is not supported,
or if the search fails,
the directive is reprocessed as if it read
\begin{ncsimplebnf}
\terminal{\# include <} h-char-sequence \terminal{>} new-line
\end{ncsimplebnf}
with the identical contained sequence (including
\tcode{>}
characters, if any) from the original directive.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# include} pp-tokens new-line
\end{ncsimplebnf}
(that does not match one of the two previous forms) is permitted.
The preprocessing tokens after
\tcode{include}
in the directive are processed just as in normal text
(i.e., each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens).
If the directive resulting after all replacements does not match
one of the two previous forms, the behavior is
undefined.
\begin{note}
Adjacent \grammarterm{string-literal}s are not concatenated into
a single \grammarterm{string-literal}
(see the translation phases in~\ref{lex.phases});
thus, an expansion that results in two \grammarterm{string-literal}s is an
invalid directive.
\end{note}
The method by which a sequence of preprocessing tokens between a
\tcode{<}
and a
\tcode{>}
preprocessing token pair or a pair of
\tcode{"}
characters is combined into a single header name
preprocessing token is \impldef{search locations for \tcode{""""} header}.

\pnum
The implementation shall provide unique mappings for
sequences consisting of one or more
\grammarterm{nondigit}{s} or \grammarterm{digit}{s}\iref{lex.name}
followed by a period
(\tcode{.})
and a single
\grammarterm{nondigit}.
The first character shall not be a \grammarterm{digit}.
The implementation may ignore distinctions of alphabetical case.

\pnum
A
\tcode{\#include}
preprocessing directive may appear
in a source file that has been read because of a
\tcode{\#include}
directive in another file,
up to an \impldef{nesting limit for \tcode{\#include} directives} nesting limit.

\pnum
If the header identified by the \grammarterm{header-name}
denotes an importable header\iref{module.import},
it is
\impldef{whether source file inclusion of importable header
is replaced with \tcode{import} directive}
whether the \tcode{\#include} preprocessing directive
is instead replaced by an \tcode{import} directive\iref{cpp.import} of the form
\begin{ncbnf}
\terminal{import} header-name \terminal{;} new-line
\end{ncbnf}

\pnum
\begin{note}
An implementation can provide a mechanism for making arbitrary
source files available to the \tcode{< >} search.
However, using the \tcode{< >} form for headers provided
with the implementation and the \tcode{" "} form for sources
outside the control of the implementation
achieves wider portability. For instance:

\begin{codeblock}
#include <stdio.h>
#include <unistd.h>
#include "usefullib.h"
#include "myprog.h"
\end{codeblock}

\end{note}

\pnum
\begin{example}
This illustrates macro-replaced
\tcode{\#include}
directives:

\begin{codeblock}
#if VERSION == 1
    #define INCFILE  "vers1.h"
#elif VERSION == 2
    #define INCFILE  "vers2.h"  // and so on
#else
    #define INCFILE  "versN.h"
#endif
#include INCFILE
\end{codeblock}
\end{example}

\rSec1[cpp.embed]{Resource inclusion}
\indextext{preprocessing directive!embed a resource}
\indextext{\idxcode{\#embed}}%

\rSec2[cpp.embed.gen]{General}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# embed <} h-char-sequence \terminal{>} \opt{pp-tokens} new-line
\end{ncsimplebnf}
searches a sequence of
\impldef{sequence of places searched for an embedded resource}
places for a resource identified uniquely by the specified sequence between
the \tcode{<} and \tcode{>} delimiters.
How the places are specified or the resource identified is
\impldef{search locations for embedded resources specified with \tcode{<>}}.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# embed "} q-char-sequence \terminal{"} \opt{pp-tokens} new-line
\end{ncsimplebnf}
searches for a resource identified by the specified sequence between the
\tcode{"} delimiters.
The named resource is searched for in an
\impldef{manner of search for named resource}
manner.
If this search is not supported, or if the search fails, the directive is
reprocessed as if it read
\begin{ncsimplebnf}
\terminal{\# embed <} h-char-sequence \terminal{>} \opt{pp-tokens} new-line
\end{ncsimplebnf}
with the identical contained sequence (including \tcode{>} characters, if any)
from the original directive.

\pnum
\recommended A mechanism similar to, but distinct from, the
\impldef{sequence of places searched for a header}
search paths used for \tcode{\#include} \iref{cpp.include}
is encouraged.

\pnum
Either form of the \tcode{\#embed} directive processes the
\grammarterm{pp-tokens}, if present, just as in normal text.
The \grammarterm{pp-tokens} shall then have the form
\grammarterm{embed-parameter-seq}.

\pnum
A resource is a source of data accessible from the translation environment.
A resource has an \defn{implementation-resource-width}, which is the
\impldef{size in bits of a resource}
size in bits of the resource.
If the implementation-resource-width is not an integral multiple of
\libmacro{CHAR_BIT}, the program is ill-formed.
Let \defn{implementation-resource-count} be
implementation-resource-width divided by \libmacro{CHAR_BIT}.
Every resource also has a \defn{resource-count}, which is

\begin{itemize}
\item
  the value as computed from the optionally-provided \tcode{limit}
  \grammarterm{embed-parameter}\iref{cpp.embed.param.limit}, if present;
\item
  otherwise, the implementation-resource-count.
\end{itemize}

A resource is empty if the resource-count is zero.

\pnum
\begin{example}
\begin{codeblock}
// ill-formed if the implementation-resource-width is 6 bits
#embed "6_bits.bin"
\end{codeblock}
\end{example}

\pnum
The \tcode{\#embed} directive is replaced by a comma-delimited list of integer
literals of type \tcode{int}, unless otherwise modified by embed
parameters\iref{cpp.embed.param}.

\pnum
The integer literals in the comma-delimited list correspond to
resource-count consecutive calls to \tcode{std::fgetc} \iref{cstdio.syn}
from the resource, as a binary file.
If any call to \tcode{std::fgetc} returns \tcode{EOF}, the program is
ill-formed.

\pnum
\recommended The value of each integer literal should closely represent
the bit stream of the resource unmodified.
This can require an implementation to consider potential differences between
translation and execution environments, as well as any other applicable
sources of mismatch.

\begin{example}
\begin{codeblock}
#include <cstring>
#include <cstddef>
#include <fstream>
#include <vector>
#include <cassert>

int main() {
  // If the file is the same as the resource in the translation environment, no assert in this program should fail.
  constexpr unsigned char d[] = {
#embed <data.dat>
  };
  const std::vector<unsigned char> vec_d = {
#embed <data.dat>
  };

  constexpr std::size_t expected_size = sizeof(d);

  // same file in execution environment as was embedded
  std::ifstream f_source("data.dat", std::ios::binary | std::ios::in);
  unsigned char runtime_d[expected_size];
  char* ifstream_ptr = reinterpret_cast<char*>(runtime_d);
  assert(!f_source.read(ifstream_ptr, expected_size));
  std::size_t ifstream_size = f_source.gcount();
  assert (ifstream_size == expected_size);
  int is_same = std::memcmp(&d[0], ifstream_ptr, ifstream_size);
  assert(is_same == 0);
  int is_same_vec = std::memcmp(vec_d.data(), ifstream_ptr, ifstream_size);
  assert(is_same_vec == 0);
}
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
int i = {
#embed "i.dat"
};  // well-formed if \tcode{i.dat} produces a single value
int i2 =
#embed "i.dat"
;   // also well-formed if \tcode{i.dat} produces a single value
struct s {
  double a, b, c;
  struct { double e, f, g; } x;
  double h, i, j;
};
s x = {
// well-formed if the directive produces nine or fewer values
#embed "s.dat"
};
\end{codeblock}
\end{example}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# embed} pp-tokens new-line
\end{ncsimplebnf}
(that does not match one of the two previous forms) is permitted.
The preprocessing tokens after \tcode{embed} in the directive are processed
just as in normal text (i.e., each identifier currently defined as a macro
name is replaced by its replacement list of preprocessing tokens).
The directive resulting after all replacements of the third form shall match
one of the two previous forms.
\begin{note}
Adjacent \grammarterm{string-literal}{s} are not concatenated into a single
\grammarterm{string-literal} (see the translation phases in \iref{lex.phases});
thus, an expansion that results in two \grammarterm{string-literal}{s} is an
invalid directive.
\end{note}

Any further processing as in normal text described for the two previous
forms is not performed.
\begin{note}
That is, processing as in normal text happens once and only once for the entire
directive.
\end{note}

\begin{example}
If the directive matches the third form, the whole directive is replaced.
If the directive matches the first two forms, everything after the name is
replaced.

\begin{codeblock}
#define prefix(ARG) suffix(ARG)
#define THE_ADDITION "teehee"
#define THE_RESOURCE ":3c"
#embed ":3c"        prefix(THE_ADDITION)
#embed THE_RESOURCE prefix(THE_ADDITION)
\end{codeblock}

is equivalent to:

\begin{codeblock}
#embed ":3c" suffix("teehee")
#embed ":3c" suffix("teehee")
\end{codeblock}
\end{example}

\pnum
The method by which a sequence of preprocessing tokens between a \tcode{<} and
a \tcode{>} preprocessing token pair or a pair of \tcode{"} characters is
combined into a single resource name preprocessing token is
\impldef{search locations for \tcode{""""} resource}.

\rSec2[cpp.embed.param]{Embed parameters}
\rSec3[cpp.embed.param.limit]{limit parameter}
\pnum
An \grammarterm{embed-parameter} of the form
\tcode{limit (} \grammarterm{pp-balanced-token-seq} \tcode{)}
specifies the
maximum possible number of elements in the comma-delimited list.
It shall appear at most once in the \grammarterm{embed-parameter-seq}.
The token \tcode{defined} shall not appear in the
\grammarterm{constant-expression}.

\pnum
The \grammarterm{pp-balanced-token-seq} is evaluated as a
\grammarterm{constant-expression} using the rules as described in conditional
inclusion\iref{cpp.cond}, but without being processed as in normal text an
additional time.

\begin{example}
\begin{codeblock}
#undef DATA_LIMIT
#if __has_embed(<data.dat> limit(DATA_LIMIT))
#endif
\end{codeblock}

is equivalent to:

\begin{codeblock}
#if __has_embed(<data.dat> limit(0))
#endif
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
#embed <data.dat> limit(__has_include("a.h"))

#if __has_embed(<data.dat> limit(__has_include("a.h")))
// ill-formed: \tcode{__has_include}\iref{cpp.cond} cannot appear here
#endif
\end{codeblock}
\end{example}

\pnum
The \grammarterm{constant-expression} shall be an integral constant expression
whose value is greater than or equal to zero.
The resource-count\iref{cpp.embed.gen} becomes
implementation-resource-count, if the value of the
\grammarterm{constant-expression} is greater than
implementation-resource-count; otherwise, the value of the
\grammarterm{constant-expression}.
\begin{example}
\begin{codeblock}
constexpr unsigned char sound_signature[] = {
  // a hypothetical resource capable of expanding to four or more elements
#embed <sdk/jump.wav> limit(2+2)
};

static_assert(sizeof(sound_signature) == 4);    // OK
\end{codeblock}
\end{example}

\rSec3[cpp.embed.param.prefix]{prefix parameter}
\pnum
An \grammarterm{embed-parameter} of the form
\begin{ncsimplebnf}
\terminal{prefix (} \opt{pp-balanced-token-seq} \terminal{)}
\end{ncsimplebnf}
shall appear at most once in the \grammarterm{embed-parameter-seq}.

\pnum
If the resource is empty, this \grammarterm{embed-parameter} is ignored.
Otherwise, the \grammarterm{pp-balanced-token-seq} is placed immediately
before the comma-delimited list of integral literals.

\rSec3[cpp.embed.param.suffix]{suffix parameter}
\pnum
An \grammarterm{embed-parameter} of the form
\begin{ncsimplebnf}
\terminal{suffix (} \opt{pp-balanced-token-seq} \terminal{)}
\end{ncsimplebnf}
shall appear at most once in the \grammarterm{embed-parameter-seq}.

\pnum
If the resource is empty, this \grammarterm{embed-parameter} is ignored.
Otherwise, the \grammarterm{pp-balanced-token-seq} is placed immediately after
the comma-delimited list of the integral constant expressions.

\begin{example}
\begin{codeblock}
constexpr unsigned char whl[] = {
#embed "ches.glsl" \
  prefix(0xEF, 0xBB, 0xBF, ) /* a sequence of bytes */ \
  suffix(,)
  0
};
// always null-terminated, contains the sequence if not empty
constexpr bool is_empty = sizeof(whl) == 1 && whl[0] == '\0';
constexpr bool is_not_empty = sizeof(whl) >= 4
  && whl[sizeof(whl) - 1] == '\0'
  && whl[0] == '\xEF' && whl[1] == '\xBB' && whl[2] == '\xBF';
static_assert(is_empty || is_not_empty);
\end{codeblock}
\end{example}

\rSec3[cpp.embed.param.if.empty]{\tcode{if_empty} parameter}
\pnum
An embed-parameter of the form
\begin{ncsimplebnf}
\terminal{if_empty (} \opt{pp-balanced-token-seq} \terminal{)}
\end{ncsimplebnf}
shall appear at most once in the \grammarterm{embed-parameter-seq}.

\pnum
If the resource is not empty, this \grammarterm{embed-parameter} is ignored.
Otherwise, the \tcode{\#embed} directive is replaced by the
\grammarterm{pp-balanced-token-seq}.

\begin{example}
\tcode{limit(0)} affects when a resource is considered empty.
Therefore, the following program:

\begin{codeblock}
#embed </owo/uwurandom> \
  if_empty(42203) limit(0)
\end{codeblock}
expands to
\begin{codeblock}
42203
\end{codeblock}
\end{example}

\begin{example}
This resource is considered empty due to the \tcode{limit(0)} \grammarterm{embed-parameter},
always, including in \tcode{__has_embed} clauses.

\begin{codeblock}
int infinity_zero () {
#if __has_embed(</owo/uwurandom> limit(0) prefix(some tokens)) == __STDC_EMBED_EMPTY__
  // if \tcode{</owo/uwurandom>} exists, this conditional inclusion branch is taken and the function returns \tcode{0}.
  return 0;
#else
  // otherwise, the resource does not exist
#error "The resource does not exist"
#endif
}
\end{codeblock}
\end{example}

\rSec1[cpp.module]{Module directive}
\indextext{preprocessing directive!module}%

\begin{bnf}
\nontermdef{pp-module}\br
    \opt{\keyword{export}} \keyword{module} \opt{pp-tokens} \terminal{;} new-line
\end{bnf}

\pnum
A \grammarterm{pp-module} shall not
appear in a context where \tcode{module}
or (if it is the first preprocessing token of the \grammarterm{pp-module}) \tcode{export}
is an identifier defined as an object-like macro.

\pnum
The \grammarterm{pp-tokens}, if any, of a \grammarterm{pp-module}
shall be of the form:
\begin{ncsimplebnf}
pp-module-name \opt{pp-module-partition} \opt{pp-tokens}
\end{ncsimplebnf}
where the \grammarterm{pp-tokens} (if any) shall not begin with
a \tcode{(} preprocessing token and
the grammar non-terminals are defined as:
\begin{ncbnf}
\nontermdef{pp-module-name}\br
    \opt{pp-module-name-qualifier} identifier
\end{ncbnf}
\begin{ncbnf}
\nontermdef{pp-module-partition}\br
    \terminal{:} \opt{pp-module-name-qualifier} identifier
\end{ncbnf}
\begin{ncbnf}
\nontermdef{pp-module-name-qualifier}\br
    identifier \terminal{.}\br
    pp-module-name-qualifier identifier \terminal{.}
\end{ncbnf}
No \grammarterm{identifier} in
the \grammarterm{pp-module-name} or \grammarterm{pp-module-partition}
shall currently be defined as an object-like macro.

\pnum
Any preprocessing tokens after the \tcode{module} preprocessing token
in the \tcode{module} directive are processed just as in normal text.
\begin{note}
Each identifier currently defined as a macro name
is replaced by its replacement list of preprocessing tokens.
\end{note}

\pnum
The \tcode{module} and \tcode{export} (if it exists) preprocessing tokens
are replaced by the \grammarterm{module-keyword} and
\grammarterm{export-keyword} preprocessing tokens respectively.
\begin{note}
This makes the line no longer a directive
so it is not removed at the end of phase 4.
\end{note}

\rSec1[cpp.import]{Header unit importation}
\indextext{header unit!preprocessing}%
\indextext{preprocessing directive!import}%
\indextext{macro!import|(}%

\begin{bnf}
\nontermdef{pp-import}\br
    \opt{\keyword{export}} \keyword{import} header-name \opt{pp-tokens} \terminal{;} new-line\br
    \opt{\keyword{export}} \keyword{import} header-name-tokens \opt{pp-tokens} \terminal{;} new-line\br
    \opt{\keyword{export}} \keyword{import} pp-tokens \terminal{;} new-line
\end{bnf}

\pnum
A \grammarterm{pp-import} shall not
appear in a context where \tcode{import}
or (if it is the first preprocessing token of the \grammarterm{pp-import}) \tcode{export}
is an identifier defined as an object-like macro.

\pnum
The preprocessing tokens after the \tcode{import} preprocessing token
in the \tcode{import} \grammarterm{control-line}
are processed just as in normal text
(i.e., each identifier currently defined as a macro name
is replaced by its replacement list of preprocessing tokens).
\begin{note}
An \tcode{import} directive
matching the first two forms of a \grammarterm{pp-import}
instructs the preprocessor to import macros
from the header unit\iref{module.import}
denoted by the \grammarterm{header-name},
as described below.
\end{note}
\indextext{point of!macro import|see{macro, point of import}}%
The \defnx{point of macro import}{macro!point of import} for the
first two forms of \grammarterm{pp-import} is
immediately after the \grammarterm{new-line} terminating
the \grammarterm{pp-import}.
The last form of \grammarterm{pp-import} is only considered
if the first two forms did not match, and
does not have a point of macro import.

\pnum
If a \grammarterm{pp-import} is produced by source file inclusion
(including by the rewrite produced
when a \tcode{\#include} directive names an importable header)
while processing the \grammarterm{group} of a \grammarterm{module-file},
the program is ill-formed.

\pnum
In all three forms of \grammarterm{pp-import},
the \tcode{import} and \tcode{export} (if it exists) preprocessing tokens
are replaced by the \grammarterm{import-keyword} and
\grammarterm{export-keyword} preprocessing tokens respectively.
\begin{note}
This makes the line no longer a directive
so it is not removed at the end of phase 4.
\end{note}
Additionally, in the second form of \grammarterm{pp-import},
a \grammarterm{header-name} token is formed as if
the \grammarterm{header-name-tokens}
were the \grammarterm{pp-tokens} of a \tcode{\#include} directive.
The \grammarterm{header-name-tokens} are replaced by
the \grammarterm{header-name} token.
\begin{note}
This ensures that imports are treated consistently by
the preprocessor and later phases of translation.
\end{note}

\pnum
Each \tcode{\#define} directive encountered when preprocessing
each translation unit in a program results in a distinct
\defnx{macro definition}{macro!definition}.
\begin{note}
A predefined macro name\iref{cpp.predefined}
is not introduced by a \tcode{\#define} directive.
Implementations providing mechanisms to predefine additional macros
are encouraged to not treat them
as being introduced by a \tcode{\#define} directive.
\end{note}
Each macro definition has at most one point of definition in
each translation unit and at most one point of undefinition, as follows:
\begin{itemize}
\item
\indextext{point of!macro definition|see{macro, point of definition}}%
The \defnx{point of definition}{macro!point of definition}
of a macro definition within a translation unit $T$ is
\begin{itemize}
\item
if the \tcode{\#define} directive of the macro definition occurs within $T$,
the point at which that directive occurs, or otherwise,
\item
if the macro name is not lexically identical to a keyword\iref{lex.key}
or to the \grammarterm{identifier}{s} \tcode{module} or \tcode{import},
the first point of macro import in $T$ of a header unit
containing a point of definition for the macro definition, if any.
\end{itemize}
In the latter case, the macro is said
to be \defnx{imported}{macro!import} from the header unit.

\item
\indextext{point of!macro undefinition|see{macro, point of undefinition}}%
The \defnx{point of undefinition}{macro!point of undefinition}
of a macro definition within a translation unit
is the first point at which a \tcode{\#undef} directive naming the macro occurs
after its point of definition, or the first point
of macro import of a header unit containing a point of undefinition for the
macro definition, whichever (if any) occurs first.
\end{itemize}

\pnum
\indextext{active macro definition|see{macro, active}}%
A macro definition is \defnx{active}{macro!active} at a source location
if it has a point of definition in that translation unit preceding the location,
and does not have a point of undefinition in that translation unit preceding
the location.

\pnum
If a macro would be replaced or redefined, and multiple macro definitions
are active for that macro name, the active macro definitions shall all be
valid redefinitions of the same macro\iref{cpp.replace}.
\begin{note}
The relative order of \grammarterm{pp-import}{s} has no bearing on whether a
particular macro definition is active.
\end{note}

\pnum
\begin{example}
\begin{codeblocktu}{Importable header \tcode{"a.h"}}
#define X 123   // \#1
#define Y 45    // \#2
#define Z a     // \#3
#undef X        // point of undefinition of \#1 in \tcode{"a.h"}
\end{codeblocktu}

\begin{codeblocktu}{Importable header \tcode{"b.h"}}
import "a.h";   // point of definition of \#1, \#2, and \#3, point of undefinition of \#1 in \tcode{"b.h"}
#define X 456   // OK, \#1 is not active
#define Y 6     // error: \#2 is active
\end{codeblocktu}

\begin{codeblocktu}{Importable header \tcode{"c.h"}}
#define Y 45    // \#4
#define Z c     // \#5
\end{codeblocktu}

\begin{codeblocktu}{Importable header \tcode{"d.h"}}
import "c.h";   // point of definition of \#4 and \#5 in \tcode{"d.h"}
\end{codeblocktu}

\begin{codeblocktu}{Importable header \tcode{"e.h"}}
import "a.h";   // point of definition of \#1, \#2, and \#3, point of undefinition of \#1 in \tcode{"e.h"}
import "d.h";   // point of definition of \#4 and \#5 in \tcode{"e.h"}
int a = Y;      // OK, active macro definitions \#2 and \#4 are valid redefinitions
int c = Z;      // error: active macro definitions \#3 and \#5 are not valid redefinitions of \tcode{Z}
\end{codeblocktu}

\begin{codeblocktu}{Module unit \tcode{f}}
export module f;
export import "a.h";

int a = Y;      // OK
\end{codeblocktu}

\begin{codeblocktu}{Translation unit \tcode{\#1}}
import f;
int x = Y;      // error: \tcode{Y} is neither a defined macro nor a declared name
\end{codeblocktu}
\end{example}
\indextext{macro!import|)}

\rSec1[cpp.replace]{Macro replacement}%

\rSec2[cpp.replace.general]{General}%
\indextext{macro!replacement|(}%
\indextext{replacement!macro|see{macro, replacement}}%
\indextext{preprocessing directive!macro replacement|see{macro, replacement}}

\pnum
\indextext{macro!replacement list}%
Two replacement lists are identical if and only if
the preprocessing tokens in both have
the same number, ordering, spelling, and whitespace separation,
where all whitespace separations are considered identical.

\pnum
An identifier currently defined as an
\indextext{macro!object-like}%
object-like macro (see below) may be redefined by another
\tcode{\#define}
preprocessing directive provided that the second definition is an
object-like macro definition and the two replacement lists
are identical, otherwise the program is ill-formed.
Likewise, an identifier currently defined as a
\indextext{macro!function-like}%
function-like macro (see below) may be redefined by another
\tcode{\#define}
preprocessing directive provided that the second definition is a
function-like macro definition that has the same number and spelling
of parameters,
and the two replacement lists are identical,
otherwise the program is ill-formed.

\pnum
\begin{example}
The following sequence is valid:
\begin{codeblock}
#define OBJ_LIKE      (1-1)
#define OBJ_LIKE      @\tcode{/* whitespace */ (1-1) /* other */}@
#define FUNC_LIKE(a)   ( a )
#define FUNC_LIKE( a )(     @\tcode{/* note the whitespace */ \textbackslash}@
                a @\tcode{/* other stuff on this line}@
                  @\tcode{*/}@ )
\end{codeblock}
But the following redefinitions are invalid:
\begin{codeblock}
#define OBJ_LIKE    (0)         // different token sequence
#define OBJ_LIKE    (1 - 1)     // different whitespace
#define FUNC_LIKE(b) ( a )      // different parameter usage
#define FUNC_LIKE(b) ( b )      // different parameter spelling
\end{codeblock}
\end{example}

\pnum
\indextext{macro!replacement list}%
There shall be whitespace between the identifier and the replacement list
in the definition of an object-like macro.

\pnum
If the \grammarterm{identifier-list} in the macro definition does not end with
an ellipsis, the number of arguments (including those arguments consisting
of no preprocessing tokens)
in an invocation of a function-like macro shall
equal the number of parameters in the macro definition.
Otherwise, there shall be at least as many arguments in the invocation as there are
parameters in the macro definition (excluding the \tcode{...}). There
shall exist a
\tcode{)}
preprocessing token that terminates the invocation.

\pnum
\indextext{__va_args__@\mname{VA_ARGS}}%
\indextext{__va_opt__@\mname{VA_OPT}}%
The identifiers \mname{VA_ARGS} and \mname{VA_OPT}
shall occur only in the \grammarterm{replacement-list}
of a function-like macro that uses the ellipsis notation in the parameters.

\pnum
A parameter identifier in a function-like macro
shall be uniquely declared within its scope.

\pnum
The identifier immediately following the
\tcode{define}
is called the
\indextext{name!macro|see{macro, name}}%
\defnx{macro name}{macro!name}.
There is one name space for macro names.
Any whitespace characters preceding or following the
replacement list of preprocessing tokens are not considered
part of the replacement list for either form of macro.

\pnum
If a
\indextext{\#\#0 operator@\tcode{\#} operator}
\tcode{\#}
preprocessing token,
followed by an identifier,
occurs lexically
at the point at which a preprocessing directive can begin,
the identifier is not subject to macro replacement.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# define} identifier replacement-list new-line
\indextext{\idxcode{\#define}}%
\end{ncsimplebnf}
defines an
\defnadj{object-like}{macro} that
causes each subsequent instance of the macro name
\begin{footnote}
Since, by macro-replacement time,
all \grammarterm{character-literal}s and \grammarterm{string-literal}s are preprocessing tokens,
not sequences possibly containing identifier-like subsequences
(see \ref{lex.phases}, translation phases),
they are never scanned for macro names or parameters.
\end{footnote}
to be replaced by the replacement list of preprocessing tokens
that constitute the remainder of the directive.
\begin{footnote}
An alternative token\iref{lex.digraph} is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not possible to define a macro
whose name is the same as that of an alternative token.
\end{footnote}
The replacement list is then rescanned for more macro names as
specified below.

\pnum
\begin{example}
The simplest use of this facility is to define a ``manifest constant'',
as in
\begin{codeblock}
#define TABSIZE 100
int table[TABSIZE];
\end{codeblock}
\end{example}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# define} identifier lparen \opt{identifier-list} \terminal{)} replacement-list new-line\br
\terminal{\# define} identifier lparen \terminal{...} \terminal{)} replacement-list new-line\br
\terminal{\# define} identifier lparen identifier-list \terminal{, ...} \terminal{)} replacement-list new-line
\end{ncsimplebnf}
defines a \defnadj{function-like}{macro}
with parameters, whose use is
similar syntactically to a function call.
The parameters
\indextext{parameter!macro}%
are specified by the optional list of identifiers.
Each subsequent instance of the function-like macro name followed by a
\tcode{(}
as the next preprocessing token
introduces the sequence of preprocessing tokens that is replaced
by the replacement list in the definition
(an invocation of the macro).
\indextext{invocation!macro}%
The replaced sequence of preprocessing tokens is terminated by the matching
\tcode{)}
preprocessing token, skipping intervening matched pairs of left and
right parenthesis preprocessing tokens.
Within the sequence of preprocessing tokens making up an invocation
of a function-like macro,
new-line is considered a normal whitespace character.

\pnum
\indextext{macro!function-like!arguments}%
The sequence of preprocessing tokens
bounded by the outside-most matching parentheses
forms the list of arguments for the function-like macro.
The individual arguments within the list
are separated by comma preprocessing tokens,
but comma preprocessing tokens between matching
inner parentheses do not separate arguments.
If there are sequences of preprocessing tokens within the list of
arguments that would otherwise act as preprocessing directives,
\begin{footnote}
A \grammarterm{conditionally-supported-directive} is a preprocessing directive regardless of whether the implementation supports it.
\end{footnote}
the behavior is undefined.

\pnum
\begin{example}
The following defines a function-like
macro whose value is the maximum of its arguments.
It has the disadvantages of evaluating one or the other of its arguments
a second time
(including
\indextext{side effects}%
side effects)
and generating more code than a function if invoked several times.
It also cannot have its address taken,
as it has none.

\begin{codeblock}
#define max(a, b) ((a) > (b) ? (a) : (b))
\end{codeblock}

The parentheses ensure that the arguments and
the resulting expression are bound properly.
\end{example}

\pnum
\indextext{macro!function-like!arguments}%
If there is a \tcode{...} immediately preceding the \tcode{)} in the
function-like macro
definition, then the trailing arguments (if any), including any separating comma preprocessing
tokens, are merged to form a single item: the \defn{variable arguments}. The number of
arguments so combined is such that, following merger, the number of arguments is
either equal to or
one more than the number of parameters in the macro definition (excluding the
\tcode{...}).

\rSec2[cpp.subst]{Argument substitution}%
\indextext{macro!argument substitution}%
\indextext{argument substitution|see{macro, argument substitution}}%

\indextext{__va_opt__@\mname{VA_OPT}}%
\begin{bnf}
\nontermdef{va-opt-replacement}\br
    \terminal{\mname{VA_OPT} (} \opt{pp-tokens} \terminal{)}
\end{bnf}

\pnum
After the arguments for the invocation of a function-like macro have
been identified, argument substitution takes place.
For each parameter in the replacement list that is neither
preceded by a \tcode{\#} or \tcode{\#\#} preprocessing token nor
followed by a \tcode{\#\#} preprocessing token, the preprocessing tokens
naming the parameter are replaced by a preprocessing token sequence determined as follows:
\begin{itemize}
\item
  If the parameter is of the form \grammarterm{va-opt-replacement},
  the replacement preprocessing tokens are the
  preprocessing token sequence for the corresponding argument,
  as specified below.
\item
  Otherwise, the replacement preprocessing tokens are the
  preprocessing tokens of corresponding argument after all
  macros contained therein have been expanded. The argument's
  preprocessing tokens are completely macro replaced before
  being substituted as if they formed the rest of the preprocessing
  translation unit with no other preprocessing tokens being available.
\end{itemize}
\begin{example}
\begin{codeblock}
#define LPAREN() (
#define G(Q) 42
#define F(R, X, ...)  __VA_OPT__(G R X) )
int x = F(LPAREN(), 0, <:-);    // replaced by \tcode{int x = 42;}
\end{codeblock}
\end{example}

\pnum
\indextext{__va_args__@\mname{VA_ARGS}}%
An identifier \mname{VA_ARGS} that occurs in the replacement list
shall be treated as if it were a parameter, and the variable arguments shall form
the preprocessing tokens used to replace it.

\pnum
\begin{example}
\begin{codeblock}
#define debug(...) fprintf(stderr, @\mname{VA_ARGS}@)
#define showlist(...) puts(#@\mname{VA_ARGS}@)
#define report(test, ...) ((test) ? puts(#test) : printf(@\mname{VA_ARGS}@))
debug("Flag");
debug("X = %d\n", x);
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);
\end{codeblock}
results in
\begin{codeblock}
fprintf(stderr, "Flag");
fprintf(stderr, "X = %d\n", x);
puts("The first, second, and third items.");
((x>y) ? puts("x>y") : printf("x is %d but y is %d", x, y));
\end{codeblock}
\end{example}

\pnum
\indextext{__va_opt__@\mname{VA_OPT}}%
The identifier \mname{VA_OPT}
shall always occur as part of the preprocessing token sequence
\grammarterm{va-opt-replacement};
its closing \tcode{)} is determined by skipping
intervening pairs of matching left and right parentheses
in its \grammarterm{pp-tokens}.
The \grammarterm{pp-tokens} of a \grammarterm{va-opt-replacement}
shall not contain \mname{VA_OPT}.
If the \grammarterm{pp-tokens} would be ill-formed
as the replacement list of the current function-like macro,
the program is ill-formed.
A \grammarterm{va-opt-replacement} is treated as if it were a parameter,
and the preprocessing token sequence for the corresponding
argument is defined as follows.
If the substitution of \mname{VA_ARGS} as neither an operand
of \tcode{\#} nor \tcode{\#\#} consists of no preprocessing tokens,
the argument consists of
a single placemarker preprocessing token\iref{cpp.concat,cpp.rescan}.
Otherwise, the argument consists of
the results of the expansion of the contained \grammarterm{pp-tokens}
as the replacement list of the current function-like macro
before removal of placemarker tokens, rescanning, and further replacement.
\begin{note}
The placemarker tokens are removed before stringization\iref{cpp.stringize},
and can be removed by rescanning and further replacement\iref{cpp.rescan}.
\end{note}
\begin{example}
\begin{codeblock}
#define F(...)           f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...)        f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP

F(a, b, c)          // replaced by \tcode{f(0, a, b, c)}
F()                 // replaced by \tcode{f(0)}
F(EMP)              // replaced by \tcode{f(0)}

G(a, b, c)          // replaced by \tcode{f(0, a, b, c)}
G(a, )              // replaced by \tcode{f(0, a)}
G(a)                // replaced by \tcode{f(0, a)}

SDEF(foo);          // replaced by \tcode{S foo;}
SDEF(bar, 1, 2);    // replaced by \tcode{S bar = \{ 1, 2 \};}

#define H1(X, ...) X __VA_OPT__(##) __VA_ARGS__ // error: \tcode{\#\#} may not appear at
                                                // the beginning of a replacement list\iref{cpp.concat}

#define H2(X, Y, ...) __VA_OPT__(X ## Y,) __VA_ARGS__
H2(a, b, c, d)      // replaced by \tcode{ab, c, d}

#define H3(X, ...) #__VA_OPT__(X##X X##X)
H3(, 0)             // replaced by \tcode{""}

#define H4(X, ...) __VA_OPT__(a X ## X) ## b
H4(, 1)             // replaced by \tcode{a b}

#define H5A(...) __VA_OPT__()@\tcode{/**/}@__VA_OPT__()
#define H5B(X) a ## X ## b
#define H5C(X) H5B(X)
H5C(H5A())          // replaced by \tcode{ab}
\end{codeblock}
\end{example}

\rSec2[cpp.stringize]{The \tcode{\#} operator}%
\indextext{\#\#0 operator@\tcode{\#} operator}%
\indextext{stringize|see{\tcode{\#} operator}}

\pnum
Each
\tcode{\#}
preprocessing token in the replacement list for a function-like
macro shall be followed by a parameter as the next preprocessing
token in the replacement list.

\pnum
A \defn{character string literal} is a \grammarterm{string-literal} with no prefix.
If, in the replacement list, a parameter is immediately
preceded by a
\tcode{\#}
preprocessing token,
both are replaced by a single character string literal preprocessing token that
contains the spelling of the preprocessing token sequence for the
corresponding argument (excluding placemarker tokens).
Let the \defn{stringizing argument} be the preprocessing token sequence
for the corresponding argument with placemarker tokens removed.
Each occurrence of whitespace between the stringizing argument's preprocessing
tokens becomes a single space character in the character string literal.
Whitespace before the first preprocessing token and after the last
preprocessing token comprising the stringizing argument is deleted.
Otherwise, the original spelling of each preprocessing token in the
stringizing argument is retained in the character string literal,
except for special handling for producing the spelling of
\grammarterm{string-literal}s and \grammarterm{character-literal}s:
a
\tcode{\textbackslash}
character is inserted before each
\tcode{"}
and
\tcode{\textbackslash}
character of a \grammarterm{character-literal} or \grammarterm{string-literal}
(including the delimiting
\tcode{"}
characters).
If the replacement that results is not a valid character string literal,
the behavior is undefined. The character string literal corresponding to
an empty stringizing argument is \tcode{""}.
The order of evaluation of
\tcode{\#}
and
\tcode{\#\#}
operators is unspecified.

\rSec2[cpp.concat]{The \tcode{\#\#} operator}%
\indextext{\#\#1 operator@\tcode{\#\#} operator}%
\indextext{concatenation!macro argument|see{\tcode{\#\#} operator}}

\pnum
A
\tcode{\#\#}
preprocessing token shall not occur at the beginning or
at the end of a replacement list for either form
of macro definition.

\pnum
If, in the replacement list of a function-like macro, a parameter is
immediately preceded or followed by a
\tcode{\#\#}
preprocessing token, the parameter is replaced by the
corresponding argument's preprocessing token sequence; however, if an argument consists of no preprocessing tokens, the parameter is
replaced by a placemarker preprocessing token instead.
\begin{footnote}
Placemarker preprocessing tokens do not appear in the syntax
because they are temporary entities that exist only within translation phase 4.
\end{footnote}

\pnum
For both object-like and function-like macro invocations, before the
replacement list is reexamined for more macro names to replace,
each instance of a
\tcode{\#\#}
preprocessing token in the replacement list
(not from an argument) is deleted and the
preceding preprocessing token is concatenated
with the following preprocessing token.
Placemarker preprocessing tokens are handled specially: concatenation
of two placemarkers results in a single placemarker preprocessing token, and
concatenation of a placemarker with a non-placemarker preprocessing token results
in the non-placemarker preprocessing token.
\begin{note}
Concatenation can form
a \grammarterm{universal-character-name}\iref{lex.charset}.
\end{note}
If the result is not a valid preprocessing token,
the behavior is undefined.
The resulting preprocessing token is available for further macro replacement.
The order of evaluation of
\tcode{\#\#}
operators is unspecified.

\pnum
\begin{example}
The sequence
\begin{codeblock}
#define str(s)      # s
#define xstr(s)     str(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", @\textbackslash@
               x ## s, x ## t)
#define INCFILE(n)  vers ## n
#define glue(a, b)  a ## b
#define xglue(a, b) glue(a, b)
#define HIGHLOW     "hello"
#define LOW         LOW ", world"

debug(1, 2);
fputs(str(strncmp("abc@\textbackslash@0d", "abc", '@\textbackslash@4')        // this goes away
    == 0) str(: @\atsign\textbackslash@n), s);
#include xstr(INCFILE(2).h)
glue(HIGH, LOW);
xglue(HIGH, LOW)
\end{codeblock}
results in
\begin{codeblock}
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(@\textbackslash@"abc@\textbackslash\textbackslash@0d@\textbackslash@", @\textbackslash@"abc@\textbackslash@", '@\textbackslash\textbackslash@4') == 0" ": @\atsign\textbackslash@n", s);
#include "vers2.h"      @\textrm{(\textit{after macro replacement, before file access})}@
"hello";
"hello" ", world"
\end{codeblock}
or, after concatenation of the character string literals,
\begin{codeblock}
printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(@\textbackslash@"abc@\textbackslash\textbackslash@0d@\textbackslash@", @\textbackslash@"abc@\textbackslash@", '@\textbackslash\textbackslash@4') == 0: @\atsign\textbackslash@n", s);
#include "vers2.h"      @\textrm{(\textit{after macro replacement, before file access})}@
"hello";
"hello, world"
\end{codeblock}

Space around the \tcode{\#} and \tcode{\#\#} preprocessing tokens in the macro definition
is optional.
\end{example}

\pnum
\begin{example}
In the following fragment:

\begin{codeblock}
#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y);          // equivalent to \tcode{char p[] = "x \#\# y";}
\end{codeblock}

The expansion produces, at various stages:

\begin{codeblock}
join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
mkstr(x ## y)
"x ## y"
\end{codeblock}

In other words, expanding \tcode{hash_hash} produces a new preprocessing token,
consisting of two adjacent sharp signs, but this new preprocessing token is not the
\tcode{\#\#} operator.
\end{example}

\pnum
\begin{example}
To illustrate the rules for placemarker preprocessing tokens, the sequence
\begin{codeblock}
#define t(x,y,z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),
  t(10,,), t(,11,), t(,,12), t(,,) };
\end{codeblock}
results in
\begin{codeblock}
int j[] = { 123, 45, 67, 89,
  10, 11, 12, };
\end{codeblock}
\end{example}

\rSec2[cpp.rescan]{Rescanning and further replacement}%
\indextext{macro!rescanning and replacement}%
\indextext{rescanning and replacement|see{macro, rescanning and replacement}}

\pnum
After all parameters in the replacement list have been substituted and \tcode{\#} and \tcode{\#\#} processing has taken
place, all placemarker preprocessing tokens are removed. Then
the resulting preprocessing token sequence is rescanned, along with all
subsequent preprocessing tokens of the source file, for more macro names
to replace.

\pnum
\begin{example}
The sequence
\begin{codeblock}
#define x       3
#define f(a)    f(x * (a))
#undef  x
#define x       2
#define g       f
#define z       z[0]
#define h       g(~
#define m(a)    a(w)
#define w       0,1
#define t(a)    a
#define p()     int
#define q(x)    x
#define r(x,y)  x ## y
#define str(x)  # x

f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m
    (f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };
\end{codeblock}
results in
\begin{codeblock}
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };
\end{codeblock}
\end{example}

\pnum
If the name of the macro being replaced is found during this scan of
the replacement list
(not including the rest of the source file's preprocessing tokens),
it is not replaced.
Furthermore,
if any nested replacements encounter the name of the macro being replaced,
it is not replaced.
These nonreplaced macro name preprocessing tokens are no longer available
for further replacement even if they are later (re)examined in contexts
in which that macro name preprocessing token would otherwise have been
replaced.

\pnum
The resulting completely macro-replaced preprocessing token sequence
is not processed as a preprocessing directive even if it resembles one,
but all pragma unary operator expressions within it are then processed as
specified in~\ref{cpp.pragma.op} below.

\rSec2[cpp.scope]{Scope of macro definitions}%
\indextext{macro!scope of definition}%
\indextext{scope!macro definition|see{macro, scope of definition}}

\pnum
A macro definition lasts
(independent of block structure)
until a corresponding
\tcode{\#undef}
directive is encountered or
(if none is encountered)
until the end of the translation unit.
Macro definitions have no significance after translation phase 4.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# undef} identifier new-line
\indextext{\idxcode{\#undef}}%
\end{ncsimplebnf}
causes the specified identifier no longer to be defined as a macro name.
It is ignored if the specified identifier is not currently defined as
a macro name.

\indextext{macro!replacement|)}

\rSec1[cpp.line]{Line control}%
\indextext{preprocessing directive!line control}%
\indextext{\idxcode{\#line}|see{preprocessing directive, line control}}

\pnum
The \grammarterm{string-literal} of a
\tcode{\#line}
directive, if present,
shall be a character string literal.

\pnum
The
\defn{line number}
of the current source line is
the line number of the current physical source line,
i.e., it is one greater than
the number of new-line characters read or introduced
in translation phase 1\iref{lex.phases}
while processing the source file to the current preprocessing token.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# line} digit-sequence new-line
\end{ncsimplebnf}
causes the implementation to behave as if
the following sequence of source lines begins with a
source line that has a line number as specified
by the digit sequence (interpreted as a decimal integer).
If the digit sequence specifies zero
or a number greater than 2147483647,
the behavior is undefined.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# line} digit-sequence \terminal{"} \opt{s-char-sequence} \terminal{"} new-line
\end{ncsimplebnf}
sets the presumed line number similarly and changes the
presumed name of the source file to be the contents
of the character string literal.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# line} pp-tokens new-line
\end{ncsimplebnf}
(that does not match one of the two previous forms)
is permitted.
The preprocessing tokens after
\tcode{line}
on the directive are processed just as in normal text
(each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens).
If the directive resulting after all replacements does not match
one of the two previous forms, the behavior is undefined;
otherwise, the result is processed as appropriate.

\rSec1[cpp.error]{Diagnostic directives}%
\indextext{preprocessing directive!error}%
\indextext{preprocessing directive!diagnostic}%
\indextext{preprocessing directive!warning}%
\indextext{\idxcode{\#error}|see{preprocessing directive, error}}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# error} \opt{pp-tokens} new-line
\end{ncsimplebnf}
renders the program ill-formed.
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# warning} \opt{pp-tokens} new-line
\end{ncsimplebnf}
requires the implementation to produce at least one diagnostic message
for the preprocessing translation unit\iref{intro.compliance.general}.
\recommended
Any diagnostic message caused by either of these directives
should include the specified sequence of preprocessing tokens.

\rSec1[cpp.pragma]{Pragma directive}%
\indextext{preprocessing directive!pragma}%
\indextext{\idxcode{\#pragma}|see{preprocessing directive, pragma}}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\# pragma} \opt{pp-tokens} new-line
\end{ncsimplebnf}
causes the implementation to behave
in an \impldef{\tcode{\#pragma}} manner.
The behavior may cause translation to fail or cause the translator or
the resulting program to behave in a non-conforming manner.
Any pragma that is not recognized by the implementation is ignored.

\rSec1[cpp.null]{Null directive}%
\indextext{preprocessing directive!null}

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
\terminal{\#} new-line
\end{ncsimplebnf}
has no effect.

\rSec1[cpp.predefined]{Predefined macro names}
\indextext{macro!predefined}%
\indextext{name!predefined macro|see{macro, predefined}}

\pnum
The following macro names shall be defined by the implementation:

\begin{description}

\item
\indextext{\idxxname{cplusplus}}%
\xname{cplusplus}\\
The integer literal \tcode{\cppver}.
\begin{note}
Future revisions of this document will
replace the value of this macro with a greater value.
\end{note}

\item The names listed in \tref{cpp.predefined.ft}.\\
The macros defined in \tref{cpp.predefined.ft} shall be defined to
the corresponding integer literal.
\begin{note}
Future revisions of this document might replace
the values of these macros with greater values.
\end{note}

\item
\indextext{__date__@\mname{DATE}}%
\mname{DATE}\\
The date of translation of the source file:
a character string literal of the form
\tcode{"Mmm~dd~yyyy"},
where the names of the months are the same as those generated
by the
\tcode{asctime}
function,
and the first character of
\tcode{dd}
is a space character if the value is less than 10.
If the date of translation is not available,
an \impldef{text of \mname{DATE} when date of translation is not available} valid date
shall be supplied.

\item
\indextext{__file__@\mname{FILE}}%
\mname{FILE}\\
The presumed name of the current source file (a character string
literal).
\begin{footnote}
The presumed source file name can be changed by the \tcode{\#line} directive.
\end{footnote}

\item
\indextext{__line__@\mname{LINE}}%
\mname{LINE}\\
The presumed line number (within the current source file) of the current source line
(an integer literal).
\begin{footnote}
The presumed line number can be changed by the \tcode{\#line} directive.
\end{footnote}

\item
\indextext{stdc__embed_not_found__@\mname{STDC_EMBED_NOT_FOUND}}%
\indextext{stdc__embed_found__@\mname{STDC_EMBED_FOUND}}%
\indextext{stdc__embed_empty__@\mname{STDC_EMBED_EMPTY}}%
\mname{STDC_EMBED_NOT_FOUND}, \mname{STDC_EMBED_FOUND}, and \mname{STDC_EMBED_EMPTY}\\
The integer literals \tcode{0}, \tcode{1}, and \tcode{2}, respectively.
\begin{note}
These represent values replaced from \grammarterm{has-embed-expression}{s}\iref{cpp.cond}.
\end{note}

\item
\indextext{__stdc_hosted__@\mname{STDC_HOSTED}}%
\indextext{implementation!hosted}%
\indextext{implementation!freestanding}%
\mname{STDC_HOSTED}\\
The integer literal \tcode{1}
if the implementation is a hosted implementation or
the integer literal \tcode{0}
if it is a freestanding implementation\iref{intro.compliance}.

\item
\indextext{__stdcpp_default_new_alignment__@\mname{STDCPP_DEFAULT_NEW_ALIGNMENT}}%
\mname{STDCPP_DEFAULT_NEW_ALIGNMENT}\\
An integer literal of type \tcode{std::size_t}
whose value is the alignment guaranteed
by a call to \tcode{operator new(std::size_t)}
or \tcode{operator new[](std::size_t)}.
\begin{note}
Larger alignments will be passed to
\tcode{operator new(std::size_t, std::align_val_t)}, etc.\iref{expr.new}.
\end{note}

\item
\indextext{__stdcpp_float16_t__@\mname{STDCPP_FLOAT16_T}}%
\mname{STDCPP_FLOAT16_T}\\
Defined as the integer literal \tcode{1}
if and only if the implementation supports
the \IsoFloatUndated{} floating-point interchange format binary16
as an extended floating-point type\iref{basic.extended.fp}.

\item
\indextext{__stdcpp_float32_t__@\mname{STDCPP_FLOAT32_T}}%
\mname{STDCPP_FLOAT32_T}\\
Defined as the integer literal \tcode{1}
if and only if the implementation supports
the \IsoFloatUndated{} floating-point interchange format binary32
as an extended floating-point type.

\item
\indextext{__stdcpp_float64_t__@\mname{STDCPP_FLOAT64_T}}%
\mname{STDCPP_FLOAT64_T}\\
Defined as the integer literal \tcode{1}
if and only if the implementation supports
the \IsoFloatUndated{} floating-point interchange format binary64
as an extended floating-point type.

\item
\indextext{__stdcpp_float128_t__@\mname{STDCPP_FLOAT128_T}}%
\mname{STDCPP_FLOAT128_T}\\
Defined as the integer literal \tcode{1}
if and only if the implementation supports
the \IsoFloatUndated{} floating-point interchange format binary128
as an extended floating-point type.

\item
\indextext{__stdcpp_bfloat16_t__@\mname{STDCPP_BFLOAT16_T}}%
\mname{STDCPP_BFLOAT16_T}\\
Defined as the integer literal \tcode{1}
if and only if the implementation supports an extended floating-point type
with the properties of the \grammarterm{typedef-name} \tcode{std::bfloat16_t}
as described in \ref{basic.extended.fp}.

\item
\indextext{__time__@\mname{TIME}}%
\mname{TIME}\\
The time of translation of the source file:
a character string literal of the form
\tcode{"hh:mm:ss"}
as in the time generated by the
\tcode{asctime}
function.
If the time of translation is not available,
an \impldef{text of \mname{TIME} when time of translation is not available} valid time shall be supplied.
\end{description}

\indextext{macro!feature-test}%
\indextext{feature-test macro|see{macro, feature-test}}%
\begin{LongTable}{Feature-test macros}{cpp.predefined.ft}{ll}
\\ \topline
\lhdr{Macro name} & \rhdr{Value} \\ \capsep
\endfirsthead
\continuedcaption \\
\hline
\lhdr{Name} & \rhdr{Value} \\ \capsep
\endhead
\defnxname{cpp_aggregate_bases}                   & \tcode{201603L} \\ \rowsep
\defnxname{cpp_aggregate_nsdmi}                   & \tcode{201304L} \\ \rowsep
\defnxname{cpp_aggregate_paren_init}              & \tcode{201902L} \\ \rowsep
\defnxname{cpp_alias_templates}                   & \tcode{200704L} \\ \rowsep
\defnxname{cpp_aligned_new}                       & \tcode{201606L} \\ \rowsep
\defnxname{cpp_attributes}                        & \tcode{200809L} \\ \rowsep
\defnxname{cpp_auto_cast}                         & \tcode{202110L} \\ \rowsep
\defnxname{cpp_binary_literals}                   & \tcode{201304L} \\ \rowsep
\defnxname{cpp_capture_star_this}                 & \tcode{201603L} \\ \rowsep
\defnxname{cpp_char8_t}                           & \tcode{202207L} \\ \rowsep
\defnxname{cpp_concepts}                          & \tcode{202002L} \\ \rowsep
\defnxname{cpp_conditional_explicit}              & \tcode{201806L} \\ \rowsep
\defnxname{cpp_constexpr}                         & \tcode{202406L} \\ \rowsep
\defnxname{cpp_constexpr_dynamic_alloc}           & \tcode{201907L} \\ \rowsep
\defnxname{cpp_constexpr_exceptions}              & \tcode{202411L} \\ \rowsep
\defnxname{cpp_constexpr_in_decltype}             & \tcode{201711L} \\ \rowsep
\defnxname{cpp_consteval}                         & \tcode{202211L} \\ \rowsep
\defnxname{cpp_constinit}                         & \tcode{201907L} \\ \rowsep
\defnxname{cpp_contracts}                         & \tcode{202502L} \\ \rowsep
\defnxname{cpp_decltype}                          & \tcode{200707L} \\ \rowsep
\defnxname{cpp_decltype_auto}                     & \tcode{201304L} \\ \rowsep
\defnxname{cpp_deduction_guides}                  & \tcode{201907L} \\ \rowsep
\defnxname{cpp_delegating_constructors}           & \tcode{200604L} \\ \rowsep
\defnxname{cpp_deleted_function}                  & \tcode{202403L} \\ \rowsep
\defnxname{cpp_designated_initializers}           & \tcode{201707L} \\ \rowsep
\defnxname{cpp_enumerator_attributes}             & \tcode{201411L} \\ \rowsep
\defnxname{cpp_explicit_this_parameter}           & \tcode{202110L} \\ \rowsep
\defnxname{cpp_fold_expressions}                  & \tcode{201603L} \\ \rowsep
\defnxname{cpp_generic_lambdas}                   & \tcode{201707L} \\ \rowsep
\defnxname{cpp_guaranteed_copy_elision}           & \tcode{201606L} \\ \rowsep
\defnxname{cpp_hex_float}                         & \tcode{201603L} \\ \rowsep
\defnxname{cpp_if_consteval}                      & \tcode{202106L} \\ \rowsep
\defnxname{cpp_if_constexpr}                      & \tcode{201606L} \\ \rowsep
\defnxname{cpp_impl_coroutine}                    & \tcode{201902L} \\ \rowsep
\defnxname{cpp_impl_destroying_delete}            & \tcode{201806L} \\ \rowsep
\defnxname{cpp_impl_three_way_comparison}         & \tcode{201907L} \\ \rowsep
\defnxname{cpp_implicit_move}                     & \tcode{202207L} \\ \rowsep
\defnxname{cpp_inheriting_constructors}           & \tcode{201511L} \\ \rowsep
\defnxname{cpp_init_captures}                     & \tcode{201803L} \\ \rowsep
\defnxname{cpp_initializer_lists}                 & \tcode{200806L} \\ \rowsep
\defnxname{cpp_inline_variables}                  & \tcode{201606L} \\ \rowsep
\defnxname{cpp_lambdas}                           & \tcode{200907L} \\ \rowsep
\defnxname{cpp_modules}                           & \tcode{201907L} \\ \rowsep
\defnxname{cpp_multidimensional_subscript}        & \tcode{202211L} \\ \rowsep
\defnxname{cpp_named_character_escapes}           & \tcode{202207L} \\ \rowsep
\defnxname{cpp_namespace_attributes}              & \tcode{201411L} \\ \rowsep
\defnxname{cpp_noexcept_function_type}            & \tcode{201510L} \\ \rowsep
\defnxname{cpp_nontype_template_args}             & \tcode{201911L} \\ \rowsep
\defnxname{cpp_nontype_template_parameter_auto}   & \tcode{201606L} \\ \rowsep
\defnxname{cpp_nsdmi}                             & \tcode{200809L} \\ \rowsep
\defnxname{cpp_pack_indexing}                     & \tcode{202311L} \\ \rowsep
\defnxname{cpp_placeholder_variables}             & \tcode{202306L} \\ \rowsep
\defnxname{cpp_pp_embed}                          & \tcode{202502L} \\ \rowsep
\defnxname{cpp_range_based_for}                   & \tcode{202211L} \\ \rowsep
\defnxname{cpp_raw_strings}                       & \tcode{200710L} \\ \rowsep
\defnxname{cpp_ref_qualifiers}                    & \tcode{200710L} \\ \rowsep
\defnxname{cpp_return_type_deduction}             & \tcode{201304L} \\ \rowsep
\defnxname{cpp_rvalue_references}                 & \tcode{200610L} \\ \rowsep
\defnxname{cpp_size_t_suffix}                     & \tcode{202011L} \\ \rowsep
\defnxname{cpp_sized_deallocation}                & \tcode{201309L} \\ \rowsep
\defnxname{cpp_static_assert}                     & \tcode{202306L} \\ \rowsep
\defnxname{cpp_static_call_operator}              & \tcode{202207L} \\ \rowsep
\defnxname{cpp_structured_bindings}               & \tcode{202411L} \\ \rowsep
\defnxname{cpp_template_parameters}               & \tcode{202502L} \\ \rowsep
\defnxname{cpp_template_template_args}            & \tcode{201611L} \\ \rowsep
\defnxname{cpp_threadsafe_static_init}            & \tcode{200806L} \\ \rowsep
\defnxname{cpp_trivial_relocatability}            & \tcode{202502L} \\ \rowsep
\defnxname{cpp_trivial_union}                     & \tcode{202502L} \\ \rowsep
\defnxname{cpp_unicode_characters}                & \tcode{200704L} \\ \rowsep
\defnxname{cpp_unicode_literals}                  & \tcode{200710L} \\ \rowsep
\defnxname{cpp_user_defined_literals}             & \tcode{200809L} \\ \rowsep
\defnxname{cpp_using_enum}                        & \tcode{201907L} \\ \rowsep
\defnxname{cpp_variable_templates}                & \tcode{201304L} \\ \rowsep
\defnxname{cpp_variadic_friend}                   & \tcode{202403L} \\ \rowsep
\defnxname{cpp_variadic_templates}                & \tcode{200704L} \\ \rowsep
\defnxname{cpp_variadic_using}                    & \tcode{201611L} \\
\end{LongTable}

\pnum
The following macro names are conditionally defined by the implementation:

\begin{description}
\item
\indextext{__stdc__@\mname{STDC}}%
\mname{STDC}\\
Whether \mname{STDC} is predefined and if so, what its value is,
are \impldef{definition and meaning of \mname{STDC}}.

\item
\indextext{__stdc_mb_might_neq_wc__@\mname{STDC_MB_MIGHT_NEQ_WC}}%
\mname{STDC_MB_MIGHT_NEQ_WC}\\
The integer literal \tcode{1}, intended to indicate that, in the encoding for
\keyword{wchar_t}, a member of the basic character set need not have a code value equal to
its value when used as the lone character in an ordinary character literal.

\item
\indextext{__stdc_version__@\mname{STDC_VERSION}}%
\mname{STDC_VERSION}\\
Whether \mname{STDC_VERSION} is predefined and if so, what its value is,
are \impldef{definition and meaning of \mname{STDC_VERSION}}.

\item
\indextext{__stdc_iso_10646__@\mname{STDC_ISO_10646}}%
\mname{STDC_ISO_10646}\\
An integer literal of the form \tcode{yyyymmL}
(for example, \tcode{199712L}).
Whether \mname{STDC_ISO_10646} is predefined and
if so, what its value is,
are \impldef{presence and value of \mname{STDC_ISO_10646}}.

\item
\indextext{__stdcpp_threads__@\mname{STDCPP_THREADS}}%
\mname{STDCPP_THREADS}\\
Defined, and has the value integer literal 1, if and only if a program
can have more than one thread of execution\iref{intro.multithread}.

\end{description}

\pnum
The values of the predefined macros
(except for
\mname{FILE}
and
\mname{LINE})
remain constant throughout the translation unit.

\pnum
If any of the pre-defined macro names in this subclause,
or the identifier
\tcode{defined},
is the subject of a
\tcode{\#define}
or a
\tcode{\#undef}
preprocessing directive,
the behavior is undefined.
Any other predefined macro names shall begin with a
leading underscore followed by an uppercase letter or a second
underscore.

\rSec1[cpp.pragma.op]{Pragma operator}%
\indextext{macro!pragma operator}%
\indextext{operator!pragma|see{macro, pragma operator}}

\pnum
A unary operator expression of the form:
\begin{ncbnf}
\terminal{_Pragma} \terminal{(} string-literal \terminal{)}
\end{ncbnf}
is processed as follows: The \grammarterm{string-literal} is \defnx{destringized}{destringization}
by deleting the \tcode{L} prefix, if present, deleting the leading and trailing
double-quotes, replacing each escape sequence \tcode{\textbackslash"} by a double-quote, and
replacing each escape sequence \tcode{\textbackslash\textbackslash} by a single
backslash. The resulting sequence of characters is processed through translation phase 3
to produce preprocessing tokens that are executed as if they were the
\grammarterm{pp-tokens} in a pragma directive. The original four preprocessing
tokens in the unary operator expression are removed.

\pnum
\begin{example}
\begin{codeblock}
#pragma listing on "..\listing.dir"
\end{codeblock}
can also be expressed as:
\begin{codeblock}
_Pragma ( "listing on \"..\\listing.dir\"" )
\end{codeblock}
The latter form is processed in the same way whether it appears literally
as shown, or results from macro replacement, as in:
\begin{codeblock}
#define LISTING(x) PRAGMA(listing on #x)
#define PRAGMA(x) _Pragma(#x)

LISTING( ..\listing.dir )
\end{codeblock}
\end{example}
\indextext{preprocessing directive|)}
