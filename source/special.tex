%!TEX root = std.tex
\rSec0[special]{Special member functions}

\gramSec[gram.special]{Special member functions}

\indextext{\idxcode{X(X\&)}|see{constructor, copy}}%
\indextext{~@\tcode{\~}|see{destructor}}%
\indextext{assignment!copy|see{assignment operator, copy}}%
\indextext{assignment!move|see{assignment operator, move}}%
\indextext{implicitly-declared default constructor|see{constructor, default}}

\pnum
\indextext{constructor!default}%
\indextext{constructor!copy}%
\indextext{constructor!move}%
\indextext{assignment operator!copy}%
\indextext{assignment operator!move}%
The default constructor\iref{class.ctor},
copy constructor and copy assignment operator\iref{class.copy},
move constructor and move assignment operator\iref{class.copy},
and destructor\iref{class.dtor} are
\term{special member functions}.
\begin{note} The implementation will implicitly declare these member functions for some class
types when the program does not explicitly declare them.
The implementation will implicitly define them
if they are odr-used\iref{basic.def.odr} or
needed for constant evaluation\iref{expr.const}.
See~\ref{class.ctor}, \ref{class.dtor} and~\ref{class.copy}. \end{note}
An implicitly-declared special member function is declared at the closing
\tcode{\}} of the \grammarterm{class-specifier}.
Programs shall not define implicitly-declared special member functions.

\pnum
Programs may explicitly refer to implicitly-declared special member functions.
\begin{example}
A program may explicitly call, take the address of, or form a pointer to member
to an implicitly-declared special member function.

\begin{codeblock}
struct A { };                   // implicitly declared \tcode{A::operator=}
struct B : A {
  B& operator=(const B &);
};
B& B::operator=(const B& s) {
  this->A::operator=(s);        // well-formed
  return *this;
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
The special member functions affect the way objects of class type are created,
copied, moved, and destroyed, and how values can be converted to values of other types.
Often such special member functions are called implicitly.
\end{note}

\pnum
\indextext{access control!member function and}%
Special member functions obey the usual access rules\iref{class.access}.
\begin{example}
Declaring a constructor protected
ensures that only derived classes and friends can create objects using it.
\end{example}

\pnum
For a class, its non-static data members, its non-virtual direct base classes,
and, if the class is not abstract\iref{class.abstract}, its virtual base
classes are called its \term{potentially constructed subobjects}.

\rSec1[class.ctor]{Constructors}%
\indextext{constructor}%
\indextext{special member function|see{constructor}}%

\pnum
Constructors do not have names.
In a declaration of a constructor, the \grammarterm{declarator} is a
function declarator\iref{dcl.fct} of the form

\begin{ncbnf}
ptr-declarator \terminal{(} parameter-declaration-clause \terminal{)} \opt{noexcept-specifier} \opt{attribute-specifier-seq}
\end{ncbnf}

where the \grammarterm{ptr-declarator} consists solely of an
\grammarterm{id-expression}, an optional \grammarterm{attribute-specifier-seq},
and optional surrounding parentheses, and the \grammarterm{id-expression} has
one of the following forms:

\begin{itemize}
\item
in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class but is not a friend
declaration\iref{class.friend}, the \grammarterm{id-expression} is the
injected-class-name\iref{class} of the immediately-enclosing class;

\item
in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class template but is not a friend
declaration, the \grammarterm{id-expression} is a \grammarterm{class-name} that
names the current instantiation\iref{temp.dep.type} of the
immediately-enclosing class template; or

\item
in a declaration at namespace scope or in a friend declaration, the
\grammarterm{id-expression} is a \grammarterm{qualified-id} that names a
constructor\iref{class.qual}.
\end{itemize}

The \grammarterm{class-name} shall not be a \grammarterm{typedef-name}. In a constructor
declaration, each \grammarterm{decl-specifier} in the optional
\grammarterm{decl-specifier-seq} shall be \tcode{friend}, \tcode{inline},
\tcode{explicit}, or \tcode{constexpr}.
\begin{example}

\begin{codeblock}
struct S {
  S();              // declares the constructor
};

S::S() { }          // defines the constructor
\end{codeblock}
\end{example}

\pnum
A constructor is used to initialize objects of its class type.
Because constructors do not have names, they are never found during
name lookup; however an explicit type conversion using the functional
notation\iref{expr.type.conv} will cause a constructor to be called to
initialize an object.
\begin{note}
For initialization of objects of class type see~\ref{class.init}.
\end{note}

\pnum
\indextext{\idxcode{const}!constructor and}%
\indextext{\idxcode{volatile}!constructor and}%
A constructor can be invoked for a
\tcode{const},
\tcode{volatile}
or
\tcode{const}
\tcode{volatile}
object.
\indextext{restriction!constructor}%
\tcode{const}
and
\tcode{volatile}
semantics\iref{dcl.type.cv} are not applied on an object under construction.
They come into effect when the constructor for the
most derived object\iref{intro.object} ends.

\pnum
\indextext{constructor!inheritance of}%
\indextext{constructor!non-trivial}%
A
\defnx{default}{constructor!default}
constructor for a class
\tcode{X}
is a constructor of class
\tcode{X}
for which
each parameter
that is not a function parameter pack
has a default argument
(including the case of a constructor with no parameters).
\indextext{implicitly-declared default constructor}%
If there is no user-declared constructor for class
\tcode{X},
a non-explicit constructor having no parameters is implicitly declared
as defaulted\iref{dcl.fct.def}.
An implicitly-declared default constructor is an
inline public member of its class.

\pnum
A defaulted default constructor for class \tcode{X} is defined as deleted if:

\begin{itemize}
\item \tcode{X} is a union that has a variant member
with a non-trivial default constructor and
no variant member of \tcode{X} has a default member initializer,

\item \tcode{X} is a non-union class that has a variant member \tcode{M}
with a non-trivial default constructor and
no variant member of the anonymous union containing \tcode{M}
has a default member initializer,

\item any non-static data member with no default member initializer\iref{class.mem} is
of reference type,

\item any non-variant non-static data member of const-qualified type (or array
thereof) with no \grammarterm{brace-or-equal-initializer} does not have a user-provided default constructor,

\item \tcode{X} is a union and all of its variant members are of const-qualified
type (or array thereof),

\item \tcode{X} is a non-union class and all members of any anonymous union member are
of const-qualified type (or array thereof),

\item any potentially constructed subobject, except for a non-static data member
with a \grammarterm{brace-or-equal-initializer}, has
class type \tcode{M} (or array thereof) and either \tcode{M}
has no default constructor or overload resolution\iref{over.match}
as applied to find \tcode{M}'s corresponding
constructor results in an ambiguity or in a function that is deleted or
inaccessible from the defaulted default constructor, or

\item any potentially constructed subobject has a type
with a destructor that is deleted or inaccessible from the defaulted default
constructor.
\end{itemize}

\pnum
A default constructor is
\defnx{trivial}{constructor!default!trivial}
if it is not user-provided and if:

\begin{itemize}
\item
its class has no virtual functions\iref{class.virtual} and no virtual base
classes\iref{class.mi}, and

\item no non-static data member of its class has
a default member initializer\iref{class.mem}, and

\item
all the direct base classes of its class have trivial default constructors, and

\item
for all the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial default constructor.
\end{itemize}

Otherwise, the default constructor is
\defnx{non-trivial}{constructor!default!non-trivial}.

\pnum
A default constructor
that is defaulted and not defined as deleted
is
\defnx{implicitly defined}{constructor!implicitly defined}
when it is odr-used\iref{basic.def.odr}
to create an object of its class type\iref{intro.object},
when it is needed for constant evaluation\iref{expr.const}, or
when it is explicitly defaulted after its first declaration.
The implicitly-defined default constructor performs the set of
initializations of the class that would be performed by a user-written default
constructor for that class with no
\grammarterm{ctor-initializer}\iref{class.base.init} and an empty
\grammarterm{compound-statement}.
If that user-written default constructor would be ill-formed,
the program is ill-formed.
If that user-written default constructor would satisfy the requirements
of a constexpr constructor\iref{dcl.constexpr}, the implicitly-defined
default constructor is \tcode{constexpr}.
Before the defaulted default constructor for a class is
implicitly defined,
all the non-user-provided default constructors for its base classes and
its non-static data members shall have been implicitly defined.
\begin{note}
An implicitly-declared default constructor has an
exception specification\iref{except.spec}.
An explicitly-defaulted definition might have an
implicit exception specification, see~\ref{dcl.fct.def}.
\end{note}

\pnum
\indextext{constructor!implicitly called}%
Default constructors are called implicitly to create class objects of static, thread,
or automatic storage duration~(\ref{basic.stc.static}, \ref{basic.stc.thread}, \ref{basic.stc.auto}) defined
without an initializer\iref{dcl.init},
are called to create class objects of dynamic storage duration\iref{basic.stc.dynamic} created by a
\grammarterm{new-expression}
in which the
\grammarterm{new-initializer}
is omitted\iref{expr.new}, or
are called when the explicit type conversion syntax\iref{expr.type.conv} is
used.
A program is ill-formed if the default constructor for an object
is implicitly used and the constructor is not accessible\iref{class.access}.

\pnum
\begin{note}
\indextext{order of execution!base class constructor}%
\indextext{order of execution!member constructor}%
\ref{class.base.init} describes the order in which constructors for base
classes and non-static data members are called and
describes how arguments can be specified for the calls to these constructors.
\end{note}

\pnum
\indextext{restriction!constructor}%
A
\tcode{return}
statement in the body of a constructor shall not specify a return value.
\indextext{constructor!address of}%
The address of a constructor shall not be taken.

\pnum
\indextext{object!unnamed}%
\indextext{constructor!explicit call}%
A functional notation type conversion\iref{expr.type.conv} can be used
to create new objects of its type.
\begin{note}
The syntax looks like an explicit call of the constructor.
\end{note}
\begin{example}
\indextext{example!constructor}%

\begin{codeblock}
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );
\end{codeblock}
\end{example}

\pnum
An object created in this way is unnamed.
\begin{note}
\ref{class.temporary} describes the lifetime of temporary objects.
\end{note}
\begin{note}
Explicit constructor calls do not yield lvalues, see~\ref{basic.lval}.
\end{note}

\pnum
\begin{note}
\indextext{member function!constructor and}%
Some language constructs have special semantics when used during construction;
see~\ref{class.base.init} and~\ref{class.cdtor}.
\end{note}

\pnum
During the construction of an object,
if the value of the object or any of its subobjects is
accessed through a glvalue that is not obtained, directly or indirectly, from
the constructor's
\tcode{this}
pointer, the value of the object or subobject thus obtained is unspecified.
\begin{example}

\begin{codeblock}
struct C;
void no_opt(C*);

struct C {
  int c;
  C() : c(0) { no_opt(this); }
};

const C cobj;

void no_opt(C* cptr) {
  int i = cobj.c * 100;         // value of \tcode{cobj.c} is unspecified
  cptr->c = 1;
  cout << cobj.c * 100          // value of \tcode{cobj.c} is unspecified
       << '\n';
}

extern struct D d;
struct D {
  D(int a) : a(a), b(d.a) {}
  int a, b;
};
D d = D(1);                     // value of \tcode{d.b} is unspecified
\end{codeblock}
\end{example}

\rSec1[class.temporary]{Temporary objects}

\pnum
\indextext{object temporary|see{temporary}}%
\indextext{temporary}%
\indextext{optimization of temporary|see{temporary, elimination of}}%
\indextext{temporary!elimination of}%
\indextext{temporary!implementation-defined generation of}%
Temporary objects are created
\begin{itemize}
\item
when a prvalue is materialized so that it can be used as a glvalue\iref{conv.rval},
\item
when needed by the implementation to pass or return an object of trivially-copyable type (see below),
and
\item
when throwing an exception\iref{except.throw}.
\begin{note}
The lifetime of exception objects is described in~\ref{except.throw}.
\end{note}
\end{itemize}
Even when the creation of the temporary object is
unevaluated\iref{expr.prop},
all the semantic restrictions shall be respected as if the temporary object
had been created and later destroyed.
\begin{note}
This includes accessibility\iref{class.access} and whether it is deleted,
for the constructor selected and for the destructor. However, in the special
case of the operand of a
\grammarterm{decltype-specifier}\iref{expr.call}, no temporary is introduced,
so the foregoing does not apply to such a prvalue.
\end{note}

\pnum
The materialization of a temporary object is generally
delayed as long as possible
in order to avoid creating unnecessary temporary objects.
\begin{note}
Temporary objects are materialized:
\begin{itemize}
\item
when binding a reference to a prvalue~(\ref{dcl.init.ref}, \ref{expr.type.conv},
\ref{expr.dynamic.cast}, \ref{expr.static.cast}, \ref{expr.const.cast}, \ref{expr.cast}),
\item
when performing member access on a class prvalue~(\ref{expr.ref}, \ref{expr.mptr.oper}),
\item
when performing an array-to-pointer conversion or subscripting on an array prvalue~(\ref{conv.array}, \ref{expr.sub}),
\item
when initializing an object of type \tcode{std::initializer_list<T>} from a \grammarterm{braced-init-list}\iref{dcl.init.list},
\item
for certain unevaluated operands~(\ref{expr.typeid}, \ref{expr.sizeof}), and
\item
when a prvalue appears as a discarded-value expression\iref{expr.prop}.
\end{itemize}
\end{note}
\begin{example} Consider the following code:
\begin{codeblock}
class X {
public:
  X(int);
  X(const X&);
  X& operator=(const X&);
  ~X();
};

class Y {
public:
  Y(int);
  Y(Y&&);
  ~Y();
};

X f(X);
Y g(Y);

void h() {
  X a(1);
  X b = f(X(2));
  Y c = g(Y(3));
  a = f(a);
}
\end{codeblock}

\indextext{class object copy|see{constructor, copy}}%
\indextext{constructor!copy}%
\tcode{X(2)} is constructed in the space used to hold \tcode{f()}'s argument and
\tcode{Y(3)} is constructed in the space used to hold \tcode{g()}'s argument.
Likewise,
\tcode{f()}'s result is constructed directly in \tcode{b} and
\tcode{g()}'s result is constructed directly in \tcode{c}.
On the other hand, the expression
\tcode{a = f(a)}
requires a temporary for
the result of \tcode{f(a)},
which is materialized so that the reference parameter
of \tcode{A::operator=(const A\&)} can bind to it.
\end{example}

\pnum
When an object of class type \tcode{X}
is passed to or returned from a function,
if each copy constructor, move constructor, and destructor of \tcode{X}
is either trivial or deleted,
and \tcode{X}
has at least one non-deleted copy or move constructor,
implementations are permitted
to create a temporary object
to hold the function parameter or result object.
The temporary object is constructed
from the function argument or return value, respectively,
and the function's parameter or return object
is initialized as if by
using the non-deleted trivial constructor to copy the temporary
(even if that constructor is inaccessible
or would not be selected by overload resolution
to perform a copy or move of the object).
\begin{note}
This latitude is granted to allow objects of class type to be passed to or returned from functions in registers.
\end{note}

\pnum
\indextext{temporary!constructor for}%
\indextext{temporary!destructor for}%
\indextext{temporary!destruction of}%
When an implementation introduces a temporary object of a class that has a
non-trivial constructor~(\ref{class.ctor}, \ref{class.copy}), it shall ensure that
a constructor is called for the temporary object.
Similarly, the destructor shall be called for a temporary with a non-trivial
destructor\iref{class.dtor}.
Temporary objects are destroyed as the last step
in evaluating
the full-expression\iref{intro.execution}
that (lexically) contains the point where
they were created.
This is true even if that evaluation ends in throwing an exception.
The
\indextext{value computation}%
value computations and
\indextext{side effects}%
side effects of destroying a temporary object
are associated only with the full-expression, not with any specific
subexpression.

\pnum
\indextext{initializer!temporary and declarator}%
\indextext{temporary!order of destruction of}%
There are three contexts in which temporaries are destroyed at a different
point than the end of the full-expression.
The first context is when a default constructor is called to initialize
an element of an array with no corresponding initializer\iref{dcl.init}.
The second context is when a copy constructor is called to copy an element of
an array while the entire array is copied~(\ref{expr.prim.lambda.capture}, \ref{class.copy}).
In either case, if the constructor has one or more default arguments,
the destruction of every temporary created in a default argument is
sequenced before the construction of the next array element, if any.

\pnum
The third context is when a reference is bound to a
temporary object.\footnote{The same rules apply to initialization of an
  \tcode{initializer_list} object\iref{dcl.init.list} with its
  underlying temporary array.}
The temporary object to which the reference is bound or the temporary object
that is the complete object of a subobject to which the reference is bound
persists for the lifetime of the reference if the glvalue
to which the reference is bound
was obtained through one of the following:
\begin{itemize}
\item
  a temporary materialization conversion\iref{conv.rval},
\item
  \tcode{(} \grammarterm{expression} \tcode{)},
  where \grammarterm{expression} is one of these expressions,
\item
  subscripting\iref{expr.sub} of an array operand,
  where that operand is one of these expressions,
\item
  a class member access\iref{expr.ref} using the \tcode{.} operator
  where the left operand is one of these expressions and
  the right operand designates a non-static data member of non-reference type,
\item
  a pointer-to-member operation\iref{expr.mptr.oper} using the \tcode{.*} operator
  where the left operand is one of these expressions and
  the right operand is a pointer to data member of non-reference type,
\item
  a
  \begin{itemize}
  \item \tcode{const_cast}\iref{expr.const.cast},
  \item \tcode{static_cast}\iref{expr.static.cast},
  \item \tcode{dynamic_cast}\iref{expr.dynamic.cast}, or
  \item \tcode{reinterpret_cast}\iref{expr.reinterpret.cast}
  \end{itemize}
  converting, without a user-defined conversion,
  a glvalue operand that is one of these expressions
  to a glvalue that refers
  to the object designated by the operand, or
  to its complete object or a subobject thereof,
\item
  a conditional expression\iref{expr.cond} that is a glvalue
  where the second or third operand is one of these expressions, or
\item
  a comma expression\iref{expr.comma} that is a glvalue
  where the right operand is one of these expressions.
\end{itemize}
\begin{example}
\begin{codeblock}
template<typename T> using id = T;

int&& a = id<int[3]>{1, 2, 3}[i];          // temporary array has same lifetime as \tcode{a}
const int& b = static_cast<const int&>(0); // temporary \tcode{int} has same lifetime as \tcode{b}
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);
                                           // exactly one of the two temporaries is lifetime-extended
\end{codeblock}
\end{example}
\begin{note}
An explicit type conversion~(\ref{expr.type.conv}, \ref{expr.cast})
is interpreted as
a sequence of elementary casts,
covered above.
\begin{example}
\begin{codeblock}
const int& x = (const int&)1;  // temporary for value 1 has same lifetime as x
\end{codeblock}
\end{example}
\end{note}
\begin{note}
If a temporary object has a reference member initialized by another temporary object,
lifetime extension applies recursively to such a member's initializer.
\begin{example}
\begin{codeblock}
struct S {
  const int& m;
};
const S& s = S{1};             // both \tcode{S} and \tcode{int} temporaries have lifetime of \tcode{s}
\end{codeblock}
\end{example}
\end{note}

The exceptions to this lifetime rule are:
\begin{itemize}
\item A temporary object bound to a reference parameter in a function call\iref{expr.call}
persists until the completion of the full-expression containing the call.

\item The lifetime of a temporary bound to the returned value in a function return statement\iref{stmt.return} is not extended; the temporary is destroyed at the end of the full-expression in the return statement.

\item A temporary bound to a reference in a \grammarterm{new-initializer}\iref{expr.new} persists until the completion of the full-expression containing the \grammarterm{new-initializer}.
\begin{note} This may introduce a dangling reference. \end{note}
\begin{example}
\begin{codeblock}
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} };      // creates dangling reference
\end{codeblock}
\end{example}
\end{itemize}

\pnum
The destruction of a temporary whose lifetime is not extended by being
bound to a reference is sequenced before the destruction of every
temporary which is constructed earlier in the same full-expression.
If the lifetime of two or more temporaries to which references are bound ends
at the same point,
these temporaries are destroyed at that point in the reverse order of the
completion of their construction.
In addition, the destruction of temporaries bound to references shall
take into account the ordering of destruction of objects with static, thread, or
automatic storage duration~(\ref{basic.stc.static}, \ref{basic.stc.thread}, \ref{basic.stc.auto});
that is, if
\tcode{obj1}
is an object with the same storage duration as the temporary and
created before the temporary is created
the temporary shall be destroyed before
\tcode{obj1}
is destroyed;
if
\tcode{obj2}
is an object with the same storage duration as the temporary and
created after the temporary is created
the temporary shall be destroyed after
\tcode{obj2}
is destroyed.

\pnum
\begin{example}
\begin{codeblock}
struct S {
  S();
  S(int);
  friend S operator+(const S&, const S&);
  ~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
\end{codeblock}

the expression
\tcode{S(16) + S(23)}
creates three temporaries:
a first temporary
\tcode{T1}
to hold the result of the expression
\tcode{S(16)},
a second temporary
\tcode{T2}
to hold the result of the expression
\tcode{S(23)},
and a third temporary
\tcode{T3}
to hold the result of the addition of these two expressions.
The temporary
\tcode{T3}
is then bound to the reference
\tcode{cr}.
It is unspecified whether
\tcode{T1}
or
\tcode{T2}
is created first.
On an implementation where
\tcode{T1}
is created before
\tcode{T2},
\tcode{T2}
shall be destroyed before
\tcode{T1}.
The temporaries
\tcode{T1}
and
\tcode{T2}
are bound to the reference parameters of
\tcode{operator+};
these temporaries are destroyed at the end of the full-expression
containing the call to
\tcode{operator+}.
The temporary
\tcode{T3}
bound to the reference
\tcode{cr}
is destroyed at the end of
\tcode{cr}'s
lifetime, that is, at the end of the program.
In addition, the order in which
\tcode{T3}
is destroyed takes into account the destruction order of other objects with
static storage duration.
That is, because
\tcode{obj1}
is constructed before
\tcode{T3},
and
\tcode{T3}
is constructed before
\tcode{obj2},
\tcode{obj2}
shall be destroyed before
\tcode{T3},
and
\tcode{T3}
shall be destroyed before
\tcode{obj1}.
\end{example}

\rSec1[class.conv]{Conversions}

\pnum
\indextext{conversion!class}%
\indextext{constructor, conversion by|see{conversion, user-defined}}%
\indextext{conversion function|see{conversion, user-defined}}%
\indextext{conversion!implicit}%
Type conversions of class objects can be specified by constructors and
by conversion functions.
These conversions are called
\defnx{user-defined conversions}{conversion!user-defined}
and are used for implicit type conversions\iref{conv},
for initialization\iref{dcl.init},
and for explicit type conversions~(\ref{expr.cast}, \ref{expr.static.cast}).

\pnum
User-defined conversions are applied only where they are unambiguous~(\ref{class.member.lookup}, \ref{class.conv.fct}).
Conversions obey the access control rules\iref{class.access}.
Access control is applied after ambiguity resolution\iref{basic.lookup}.

\pnum
\begin{note}
See~\ref{over.match} for a discussion of the use of conversions in function calls
as well as examples below.
\end{note}

\pnum
\indextext{conversion!implicit user-defined}%
At most one user-defined conversion (constructor or conversion function)
is implicitly applied to a single value.
\begin{example}
\begin{codeblock}
struct X {
  operator int();
};

struct Y {
  operator X();
};

Y a;
int b = a;          // error, \tcode{a.operator X().operator int()} not tried
int c = X(a);       // OK: \tcode{a.operator X().operator int()}
\end{codeblock}
\end{example}

\pnum
User-defined conversions are used implicitly only if they are unambiguous.
\indextext{name hiding!user-defined conversion and}%
A conversion function in a derived class does not hide a conversion function
in a base class unless the two functions convert to the same type.
Function overload resolution\iref{over.match.best} selects the best
conversion function to perform the conversion.
\begin{example}
\begin{codeblock}
struct X {
  operator int();
};

struct Y : X {
    operator char();
};

void f(Y& a) {
  if (a) {          // ill-formed: \tcode{X::operator int()} or \tcode{Y::operator char()}
  }
}
\end{codeblock}
\end{example}

\rSec2[class.conv.ctor]{Conversion by constructor}%
\indextext{conversion!user-defined}%

\pnum
A constructor declared without the
\grammarterm{function-specifier}
\tcode{explicit}
specifies a conversion from
the types of its parameters (if any)
to the type of its class.
Such a constructor is called a
\defnx{converting constructor}{constructor!converting}.
\begin{example}

\indextext{Jessie}%
\begin{codeblock}
struct X {
    X(int);
    X(const char*, int =0);
    X(int, int);
};

void f(X arg) {
  X a = 1;          // \tcode{a = X(1)}
  X b = "Jessie";   // \tcode{b = X("Jessie",0)}
  a = 2;            // \tcode{a = X(2)}
  f(3);             // \tcode{f(X(3))}
  f({1, 2});        // \tcode{f(X(1,2))}
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
An explicit constructor constructs objects just like non-explicit
constructors, but does so only where the direct-initialization syntax\iref{dcl.init}
or where casts~(\ref{expr.static.cast}, \ref{expr.cast}) are explicitly
used; see also~\ref{over.match.copy}.
A default constructor may be an explicit constructor; such a constructor
will be used to perform default-initialization
or value-initialization\iref{dcl.init}.
\begin{example}
\begin{codeblock}
struct Z {
  explicit Z();
  explicit Z(int);
  explicit Z(int, int);
};

Z a;                            // OK: default-initialization performed
Z b{};                          // OK: direct initialization syntax used
Z c = {};                       // error: copy-list-initialization
Z a1 = 1;                       // error: no implicit conversion
Z a3 = Z(1);                    // OK: direct initialization syntax used
Z a2(1);                        // OK: direct initialization syntax used
Z* p = new Z(1);                // OK: direct initialization syntax used
Z a4 = (Z)1;                    // OK: explicit cast used
Z a5 = static_cast<Z>(1);       // OK: explicit cast used
Z a6 = { 3, 4 };                // error: no implicit conversion
\end{codeblock}
\end{example}
\end{note}

\pnum
A
non-explicit
copy/move constructor\iref{class.copy} is a converting constructor.
\begin{note}
An implicitly-declared copy/move constructor is not an explicit constructor;
it may be called for implicit type conversions.
\end{note}

\rSec2[class.conv.fct]{Conversion functions}%
\indextext{function!conversion}%
\indextext{fundamental type conversion|see{conversion, user-defined}}%
\indextext{conversion!user-defined}%

\pnum
A member function of a class \tcode{X} having no parameters with a name of the form

\begin{bnf}
\nontermdef{conversion-function-id}\br
    \terminal{operator} conversion-type-id
\end{bnf}

\begin{bnf}
\nontermdef{conversion-type-id}\br
    type-specifier-seq \opt{conversion-declarator}
\end{bnf}

\begin{bnf}
\nontermdef{conversion-declarator}\br
    ptr-operator \opt{conversion-declarator}
\end{bnf}

specifies a conversion from
\tcode{X}
to the type specified by the
\grammarterm{conversion-type-id}.
Such functions are called \defnx{conversion functions}{conversion function}.
A \grammarterm{decl-specifier} in the \grammarterm{decl-specifier-seq}
of a conversion function (if any) shall be neither
a \grammarterm{defining-type-specifier} nor \tcode{static}.
\indextext{conversion!type of}%
The type of the conversion function\iref{dcl.fct} is
``function taking no parameter returning
\grammarterm{conversion-type-id}''.
A conversion function is never used to convert a (possibly cv-qualified) object
to the (possibly cv-qualified) same object type (or a reference to it),
to a (possibly cv-qualified) base class of that type (or a reference to it),
or to (possibly cv-qualified) void.\footnote{These conversions are considered
as standard conversions for the purposes of overload resolution~(\ref{over.best.ics}, \ref{over.ics.ref}) and therefore initialization\iref{dcl.init} and explicit casts\iref{expr.static.cast}. A conversion to \tcode{void} does not invoke any conversion function\iref{expr.static.cast}.
Even though never directly called to perform a conversion,
such conversion functions can be declared and can potentially
be reached through a call to a virtual conversion function in a base class.}
\begin{example}
\begin{codeblock}
struct X {
  operator int();
  operator auto() -> short;     // error: trailing return type
};

void f(X a) {
  int i = int(a);
  i = (int)a;
  i = a;
}
\end{codeblock}
In all three cases the value assigned will be converted by
\tcode{X::operator int()}.
\end{example}

\pnum
A conversion function may be explicit\iref{dcl.fct.spec}, in which case it is only considered as a user-defined conversion for direct-initialization\iref{dcl.init}. Otherwise, user-defined conversions are not restricted to use in assignments and initializations.
\begin{example}
\begin{codeblock}
class Y { };
struct Z {
  explicit operator Y() const;
};

void h(Z z) {
  Y y1(z);          // OK: direct-initialization
  Y y2 = z;         // ill-formed: copy-initialization
  Y y3 = (Y)z;      // OK: cast notation
}

void g(X a, X b) {
  int i = (a) ? 1+a : 0;
  int j = (a&&b) ? a+b : i;
  if (a) {
  }
}
\end{codeblock}
\end{example}

\pnum
The
\grammarterm{conversion-type-id}
shall not represent a function type nor an array type.
The
\grammarterm{conversion-type-id}
in a
\grammarterm{conversion-function-id}
is the longest sequence of
tokens that could possibly form a \grammarterm{conversion-type-id}.
\begin{note}
This prevents ambiguities between the declarator operator \tcode{*} and its expression
counterparts.
\begin{example}
\begin{codeblock}
&ac.operator int*i; // syntax error:
                    // parsed as: \tcode{\&(ac.operator int *)i}
                    // not as: \tcode{\&(ac.operator int)*i}
\end{codeblock}
The \tcode{*} is the pointer declarator and not the multiplication operator.
\end{example}
This rule also prevents ambiguities for attributes.
\begin{example}
\begin{codeblock}
operator int [[noreturn]] ();   // error: \tcode{noreturn} attribute applied to a type
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{conversion!inheritance of user-defined}%
Conversion functions are inherited.

\pnum
\indextext{conversion!virtual user-defined}%
Conversion functions can be virtual.

\pnum
\indextext{conversion!deduced return type of user-defined}%
A conversion function template shall not have a
deduced return type\iref{dcl.spec.auto}.
\begin{example}
\begin{codeblock}
struct S {
  operator auto() const { return 10; }      // OK
  template<class T>
  operator auto() const { return 1.2; }     // error: conversion function template
};
\end{codeblock}
\end{example}

\rSec1[class.dtor]{Destructors}%
\indextext{destructor}%
\indextext{special member function|see{destructor}}%

\pnum
In a declaration of a destructor, the \grammarterm{declarator} is a
function declarator\iref{dcl.fct} of the form

\begin{ncbnf}
ptr-declarator \terminal{(} parameter-declaration-clause \terminal{)} \opt{noexcept-specifier} \opt{attribute-specifier-seq}
\end{ncbnf}

where the \grammarterm{ptr-declarator} consists solely of an
\grammarterm{id-expression}, an optional \grammarterm{attribute-specifier-seq},
and optional surrounding parentheses, and the \grammarterm{id-expression} has
one of the following forms:

\begin{itemize}
\item
in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class but is not a friend
declaration\iref{class.friend}, the \grammarterm{id-expression} is
\tcode{\~}\grammarterm{class-name} and the \grammarterm{class-name} is the
injected-class-name\iref{class} of the immediately-enclosing class;

\item
in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class template but is not a friend
declaration, the \grammarterm{id-expression} is
\tcode{\~}\grammarterm{class-name} and the \grammarterm{class-name} names the
current instantiation\iref{temp.dep.type} of the immediately-enclosing class template; or

\item
in a declaration at namespace scope or in a friend declaration, the
\grammarterm{id-expression} is \grammarterm{nested-name-specifier}
\tcode{\~}\grammarterm{class-name} and the \grammarterm{class-name} names the
same class as the \grammarterm{nested-name-specifier}.
\end{itemize}

The \grammarterm{class-name} shall not be a \grammarterm{typedef-name}. A
destructor shall take no arguments\iref{dcl.fct}.
Each \grammarterm{decl-specifier} of the \grammarterm{decl-specifier-seq}
of a destructor declaration (if any) shall be \tcode{friend}, \tcode{inline}, or
\tcode{virtual}.

\pnum
A destructor is used to destroy objects of its class type.
\indextext{restriction!destructor}%
The address of a destructor shall not be taken.
\indextext{\idxcode{const}!destructor and}%
\indextext{\idxcode{volatile}!destructor and}%
A destructor can be invoked for a
\tcode{const},
\tcode{volatile}
or
\tcode{const}
\tcode{volatile}
object.
\tcode{const}
and
\tcode{volatile}
semantics\iref{dcl.type.cv} are not applied on an object under destruction.
They stop being in effect when the destructor for the
most derived object\iref{intro.object} starts.

\pnum
\begin{note}
A declaration of a destructor that does not have a \grammarterm{noexcept-specifier}
has the same exception specification as if had been implicitly declared\iref{except.spec}.
\end{note}

\pnum
\indextext{generated destructor|see{destructor, default}}%
\indextext{destructor!default}%
If a class has no user-declared
destructor, a destructor is implicitly
declared as defaulted\iref{dcl.fct.def}.
An implicitly-declared destructor is an
inline public member of its class.

\pnum
A defaulted destructor for a class
  \tcode{X} is defined as deleted if:
\begin{itemize}
\item \tcode{X} is a union-like class that has a variant
  member with a non-trivial destructor,

\item any potentially constructed subobject has class type
  \tcode{M} (or array thereof) and
  \tcode{M} has a deleted destructor or a destructor
  that is inaccessible from the defaulted destructor,

\item or, for a virtual destructor, lookup of the non-array deallocation
  function results in an ambiguity or in a function that is deleted or
  inaccessible from the defaulted destructor.
\end{itemize}

\pnum
A destructor is trivial if it is not user-provided and if:

\begin{itemize}
\item the destructor is not \tcode{virtual},

\item all of the direct base classes of its class have trivial destructors, and

\item for all of the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial destructor.
\end{itemize}

Otherwise, the destructor is
\defnx{non-trivial}{destructor!non-trivial}.

\pnum
A destructor
that is defaulted and not defined as deleted
is
\defnx{implicitly defined}{destructor!implicitly defined}
when it is odr-used\iref{basic.def.odr}
or when it is explicitly defaulted after its first declaration.

\pnum
Before the
defaulted destructor for a class is implicitly defined, all the non-user-provided
destructors for its base classes and its non-static data members shall have been
implicitly defined.

\pnum
\indextext{order of execution!destructor}%
\indextext{order of execution!base class destructor}%
\indextext{order of execution!member destructor}%
After executing the body of the destructor and destroying
any automatic objects allocated within the body, a
destructor for class
\tcode{X}
calls the destructors for
\tcode{X}'s
direct non-variant non-static data members, the destructors for
\tcode{X}'s
non-virtual direct base classes and, if
\tcode{X}
is the type of the most derived class\iref{class.base.init},
its destructor calls the destructors for
\tcode{X}'s
virtual base classes.
All destructors are called as if they were referenced with a qualified name,
that is, ignoring any possible virtual overriding destructors in more
derived classes.
Bases and members are destroyed in the reverse order of the completion of
their constructor (see~\ref{class.base.init}).
A
\tcode{return}
statement\iref{stmt.return} in a destructor might not directly return to the
caller; before transferring control to the caller, the destructors for the
members and bases are called.
\indextext{order of execution!destructor and array}%
Destructors for elements of an array are called in reverse order of their
construction (see~\ref{class.init}).

\pnum
\indextext{destructor!virtual}%
\indextext{destructor!pure virtual}%
A destructor can be declared
\tcode{virtual}\iref{class.virtual}
or pure
\tcode{virtual}\iref{class.abstract};
if any objects of that class or any derived class are created in the program,
the destructor shall be defined.
If a class has a base class with a virtual destructor, its  destructor
(whether user- or implicitly-declared) is virtual.

\pnum
\begin{note}
\indextext{member function!destructor and}%
Some language constructs have special semantics when used during destruction;
see~\ref{class.cdtor}.
\end{note}

\pnum
\indextext{destructor!implicit call}%
\indextext{destructor!program termination and}%
A destructor is invoked implicitly

\begin{itemize}

\item for a constructed object with static storage duration\iref{basic.stc.static} at program termination\iref{basic.start.term},

\item for a constructed object with thread storage duration\iref{basic.stc.thread} at thread exit,

\item for a constructed object with automatic storage duration\iref{basic.stc.auto} when the block in which an object is created exits\iref{stmt.dcl},

\item for a constructed temporary object when its lifetime ends~(\ref{conv.rval}, \ref{class.temporary}).
\end{itemize}

\indextext{\idxcode{delete}!destructor and}%
\indextext{destructor!explicit call}%
In each case, the context of the invocation is the context of the construction of
the object. A destructor is also invoked implicitly through use of a
\grammarterm{delete-expression}\iref{expr.delete} for a constructed object allocated
by a \grammarterm{new-expression}\iref{expr.new}; the context of the invocation is the
\grammarterm{delete-expression}.
\begin{note} An array of class type contains several subobjects for each of which
the destructor is invoked. \end{note}
A destructor can also be invoked explicitly. A destructor is \term{potentially invoked}
if it is invoked or as specified in~\ref{expr.new}, \ref{class.base.init},
and~\ref{except.throw}.
A program is ill-formed if a destructor that is potentially invoked is deleted
or not accessible from the context of the invocation.

\pnum
At the point of definition of a virtual destructor (including an implicit
definition\iref{class.copy}), the non-array deallocation function is
determined as if for the expression \tcode{delete this} appearing in a
non-virtual destructor of the destructor's class (see~\ref{expr.delete}).
If the lookup fails or if the deallocation function has
a deleted definition\iref{dcl.fct.def}, the program is ill-formed.
\begin{note}
This assures that a deallocation function corresponding to the dynamic type of an
object is available for the
\grammarterm{delete-expression}\iref{class.free}.
\end{note}

\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor is specified by a
\tcode{\~{}}
followed by a
\grammarterm{type-name} or \grammarterm{decltype-specifier}
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions\iref{class.mfct};
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type (including when
the destructor is invoked via a null pointer value), the program has
undefined behavior.
\begin{note} Invoking \tcode{delete} on a null pointer does not call the
destructor; see \ref{expr.delete}. \end{note}
\begin{example}

\begin{codeblock}
struct B {
  virtual ~B() { }
};
struct D : B {
  ~D() { }
};

D D_object;
typedef B B_alias;
B* B_ptr = &D_object;

void f() {
  D_object.B::~B();             // calls \tcode{B}'s destructor
  B_ptr->~B();                  // calls \tcode{D}'s destructor
  B_ptr->~B_alias();            // calls \tcode{D}'s destructor
  B_ptr->B_alias::~B();         // calls \tcode{B}'s destructor
  B_ptr->B_alias::~B_alias();   // calls \tcode{B}'s destructor
}
\end{codeblock}
\end{example}
\begin{note}
An explicit destructor call must always be written using
a member access operator\iref{expr.ref} or a \grammarterm{qualified-id}\iref{expr.prim};
in particular, the
\grammarterm{unary-expression}
\tcode{\~{}X()}
in a member function is not an explicit destructor call\iref{expr.unary.op}.
\end{note}

\pnum
\begin{note}
\indextext{object!destructor and placement of}%
Explicit calls of destructors are rarely needed.
One use of such calls is for objects placed at specific
addresses using a placement
\grammarterm{new-expression}.
Such use of explicit placement and destruction of objects can be necessary
to cope with dedicated hardware resources and for writing memory management
facilities.
For example,
\indextext{example!explicit destructor call}%
\begin{codeblock}
void* operator new(std::size_t, void* p) { return p; }
struct X {
  X(int);
  ~X();
};
void f(X* p);

void g() {                      // rare, specialized use:
  char* buf = new char[sizeof(X)];
  X* p = new(buf) X(222);       // use \tcode{buf[]} and initialize
  f(p);
  p->X::~X();                   // cleanup
}
\end{codeblock}
\end{note}

\pnum
Once a destructor is invoked for an object, the object no longer exists;
the behavior is undefined if the destructor is invoked
for an object whose lifetime has ended\iref{basic.life}.
\begin{example}
If the destructor for an automatic object is explicitly invoked,
and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undefined.
\end{example}

\pnum
\begin{note}
\indextext{fundamental type!destructor and}%
The notation for explicit call of a destructor can be used for any scalar type
name\iref{expr.pseudo}.
Allowing this makes it possible to write code without having to know if a
destructor exists for a given type.
For example:
\begin{codeblock}
typedef int I;
I* p;
p->I::~I();
\end{codeblock}
\end{note}

\rSec1[class.free]{Free store}%
\indextext{free store}%

\pnum
\indextext{\idxcode{new}!type of}
Any allocation function for a class
\tcode{T}
is a static member (even if not explicitly declared
\tcode{static}).

\pnum
\begin{example}
\begin{codeblock}
class Arena;
struct B {
  void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};

Arena*  ap;
void foo(int i) {
  new (ap) D1;      // calls \tcode{B::operator new(std::size_t, Arena*)}
  new D1[i];        // calls \tcode{::operator new[](std::size_t)}
  new D1;           // ill-formed: \tcode{::operator new(std::size_t)} hidden
}
\end{codeblock}
\end{example}

\pnum
\indextext{\idxcode{delete}}%
When an object is deleted with a
\grammarterm{delete-expression}\iref{expr.delete},
a deallocation function
\indextext{function!deallocation}%
(\tcode{operator delete()}
\indextext{\idxcode{operator delete}}%
for non-array objects or
\tcode{operator delete[]()}
\indextext{\idxcode{operator delete}}%
for arrays) is (implicitly) called to reclaim the storage occupied by
the object\iref{basic.stc.dynamic.deallocation}.

\pnum
Class-specific deallocation function lookup is a part of general deallocation
function lookup\iref{expr.delete} and occurs as follows.
If the \grammarterm{delete-expression}
is used to deallocate a class object whose static type has a virtual
destructor, the deallocation function is the one selected at the point
of definition of the dynamic type's virtual
destructor\iref{class.dtor}.\footnote{A similar provision is not needed for
the array version of \tcode{operator} \tcode{delete} because~\ref{expr.delete}
requires that in this situation, the static type of the object to be deleted be
the same as its dynamic type.
}
Otherwise, if the
\grammarterm{delete-expression}
is used to deallocate an object of class
\tcode{T}
or array thereof, the static and dynamic types of the object shall be
identical and the deallocation function's name is looked up in the scope of
\tcode{T}.
If this lookup fails to find the name, general deallocation function
lookup\iref{expr.delete} continues.
If the result of the lookup is ambiguous or inaccessible, or if the lookup
selects a placement deallocation function, the program is ill-formed.

\pnum
\indextext{\idxcode{delete}!type of}%
Any deallocation function for a class
\tcode{X}
is a static member (even if not explicitly declared
\tcode{static}).
\indextext{example!\idxcode{delete}}%
\begin{example}

\begin{codeblock}
class X {
  void operator delete(void*);
  void operator delete[](void*, std::size_t);
};

class Y {
  void operator delete(void*, std::size_t);
  void operator delete[](void*);
};
\end{codeblock}
\end{example}

\pnum
Since member allocation and deallocation functions are
\tcode{static}
they cannot be virtual.
\begin{note}
\indextext{example!destructor and \tcode{delete}}%
\indextext{example!scope of \tcode{delete}}%
However, when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an object of class type,
because the deallocation function actually called is looked up in the scope of
the class that is the dynamic type of the object,
if the destructor is virtual, the effect is the same.
For example,
\begin{codeblock}
struct B {
  virtual ~B();
  void operator delete(void*, std::size_t);
};

struct D : B {
  void operator delete(void*);
};

void f() {
  B* bp = new D;
  delete bp;        // 1: uses \tcode{D::operator delete(void*)}
}
\end{codeblock}
Here, storage for the non-array object of class
\tcode{D}
is deallocated by
\tcode{D::operator delete()},
due to the virtual destructor.
\end{note}
\begin{note}
Virtual destructors have no effect on the deallocation function actually
called when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an array of objects of class type.
For example,
\begin{codeblock}
struct B {
  virtual ~B();
  void operator delete[](void*, std::size_t);
};

struct D : B {
  void operator delete[](void*, std::size_t);
};

void f(int i) {
  D* dp = new D[i];
  delete [] dp;     // uses \tcode{D::operator delete[](void*, std::size_t)}
  B* bp = new D[i];
  delete[] bp;      // undefined behavior
}
\end{codeblock}
\end{note}

\pnum
Access to the deallocation function is checked statically.
Hence, even though a different one might actually be executed,
the statically visible deallocation function is required to be accessible.
\begin{example}
For the call on line ``// 1'' above,
if
\tcode{B::operator delete()}
had been private, the delete expression would have been ill-formed.
\end{example}

\pnum
\begin{note}
If a deallocation function has no explicit \grammarterm{noexcept-specifier}, it
has a non-throwing exception specification\iref{except.spec}.
\end{note}

\rSec1[class.init]{Initialization}%
\indextext{initialization!class object|(}%
\indextext{initialization!default constructor and}%
\indextext{initialization!constructor and}

\pnum
When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
\tcode{()},
the object is initialized as specified in~\ref{dcl.init}.

\pnum
An object of class type (or array thereof) can be explicitly initialized;
see~\ref{class.expl.init} and~\ref{class.base.init}.

\pnum
\indextext{order of execution!constructor and array}%
When an array of class objects is initialized
(either explicitly or implicitly) and the elements are initialized by constructor,
the constructor shall be called for each element of the array,
following the subscript order; see~\ref{dcl.array}.
\begin{note}
Destructors for the array elements are called in reverse order of their
construction.
\end{note}

\rSec2[class.expl.init]{Explicit initialization}%
\indextext{initialization!explicit}%
\indextext{initialization!constructor and}%

\pnum
An object of class type can be initialized with a parenthesized
\grammarterm{expression-list},
where the
\grammarterm{expression-list}
is construed as an argument list for a constructor
that is called to initialize the object.
Alternatively, a single
\grammarterm{assignment-expression}
can be specified as an
\grammarterm{initializer}
using the
\tcode{=}
form of initialization.
Either direct-initialization semantics or copy-initialization semantics apply;
see~\ref{dcl.init}.
\indextext{example!constructor and initialization}%
\begin{example}
\begin{codeblock}
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   // initialize by a call of \tcode{complex(double)}
complex b = a;                  // initialize by a copy of \tcode{a}
complex c = complex(1,2);       // construct \tcode{complex(1,2)} using \tcode{complex(double,double)},
                                // copy/move it into \tcode{c}
complex d = sqrt(b,c);          // call \tcode{sqrt(complex,complex)} and copy/move the result into \tcode{d}
complex e;                      // initialize by a call of \tcode{complex()}
complex f = 3;                  // construct \tcode{complex(3)} using \tcode{complex(double)}, copy/move it into \tcode{f}
complex g = { 1, 2 };           // initialize by a call of \tcode{complex(double, double)}
\end{codeblock}
\end{example}
\begin{note}
\indextext{initialization!overloaded assignment and}%
Overloading of the assignment operator\iref{over.ass}
has no effect on initialization.
\end{note}

\pnum
\indextext{initialization!array of class objects}%
\indextext{constructor!array of class objects and}%
An object of class type can also be initialized by a
\grammarterm{braced-init-list}. List-initialization semantics apply;
see~\ref{dcl.init} and~\ref{dcl.init.list}. \begin{example}

\begin{codeblock}
complex v[6] = { 1, complex(1,2), complex(), 2 };
\end{codeblock}

Here,
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{v[0]}
and
\tcode{v[3]},
\tcode{complex::complex(\brk{}double, double)}
is called for the initialization of
\tcode{v[1]},
\tcode{complex::complex()}
is called for the initialization
\tcode{v[2]},
\tcode{v[4]},
and
\tcode{v[5]}.
For another example,

\begin{codeblock}
struct X {
  int i;
  float f;
  complex c;
} x = { 99, 88.8, 77.7 };
\end{codeblock}

Here,
\tcode{x.i}
is initialized with 99,
\tcode{x.f}
is initialized with 88.8, and
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{x.c}.
\end{example}
\begin{note}
Braces can be elided in the
\grammarterm{initializer-list}
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see~\ref{dcl.init.aggr}.
\end{note}

\pnum
\begin{note}
If
\tcode{T}
is a class type with no default constructor,
any declaration of an object of type
\tcode{T}
(or array thereof) is ill-formed if no
\grammarterm{initializer}
is explicitly specified (see~\ref{class.init} and~\ref{dcl.init}).
\end{note}

\pnum
\begin{note}
\indextext{order of execution!constructor and \tcode{static} objects}%
The order in which objects with static or thread storage duration
are initialized is described in~\ref{basic.start.dynamic} and~\ref{stmt.dcl}.
\end{note}

\rSec2[class.base.init]{Initializing bases and members}%
\indextext{initialization!base class}%
\indextext{initialization!member}

\pnum
In the definition of a constructor for a class,
initializers for direct and virtual base class subobjects and
non-static data members can be specified by a
\grammarterm{ctor-initializer},
which has the form

\begin{bnf}
\nontermdef{ctor-initializer}\br
    \terminal{:} mem-initializer-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-list}\br
    mem-initializer \opt{\terminal{...}}\br
    mem-initializer-list \terminal{,} mem-initializer \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer}\br
    mem-initializer-id \terminal{(} \opt{expression-list} \terminal{)}\br
    mem-initializer-id braced-init-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-id}\br
    class-or-decltype\br
    identifier
\end{bnf}

\pnum
In a \grammarterm{mem-initializer-id} an initial unqualified
\grammarterm{identifier} is looked up in the scope of the constructor's class
and, if not found in that scope, it is looked up in the scope containing the
constructor's definition.
\begin{note}
If the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
\grammarterm{mem-initializer-id}
naming the member or base class and composed of a single identifier
refers to the class member.
A
\grammarterm{mem-initializer-id}
for the hidden base class may be specified using a qualified name.
\end{note}
Unless the
\grammarterm{mem-initializer-id}
names the constructor's class,
a non-static data member of the constructor's class, or
a direct or virtual base of that class,
the
\grammarterm{mem-initializer}
is ill-formed.

\pnum
A
\grammarterm{mem-initializer-list}
can initialize a base class using any \grammarterm{class-or-decltype} that denotes that base class type.
\begin{example}

\begin{codeblock}
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }          // mem-initializer for base \tcode{A}
\end{codeblock}
\end{example}

\pnum
If a
\grammarterm{mem-initializer-id}
is ambiguous because it designates both a direct non-virtual base class and
an inherited virtual base class, the
\grammarterm{mem-initializer}
is ill-formed.
\begin{example}

\begin{codeblock}
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 // ill-formed: which \tcode{A}?
\end{codeblock}
\end{example}

\pnum
A
\grammarterm{ctor-initializer}
may initialize a variant member of the
constructor's class.
If a
\grammarterm{ctor-initializer}
specifies more than one
\grammarterm{mem-initializer}
for the same member or for the same base class,
the
\grammarterm{ctor-initializer}
is ill-formed.

\pnum
A \grammarterm{mem-initializer-list} can delegate to another
constructor of the constructor's class using any
\grammarterm{class-or-decltype} that denotes the constructor's class itself. If a
\grammarterm{mem-initializer-id} designates the constructor's class,
it shall be the only \grammarterm{mem-initializer}; the constructor
is a \term{delegating constructor}, and the constructor selected by the
\grammarterm{mem-initializer} is the \term{target constructor}.
The target constructor is selected by overload resolution.
Once the target constructor returns, the body of the delegating constructor
is executed. If a constructor delegates to itself directly or indirectly,
the program is ill-formed, no diagnostic required. \begin{example}

\begin{codeblock}
struct C {
  C( int ) { }                  // \#1: non-delegating constructor
  C(): C(42) { }                // \#2: delegates to \#1
  C( char c ) : C(42.0) { }     // \#3: ill-formed due to recursion with \#4
  C( double d ) : C('a') { }    // \#4: ill-formed due to recursion with \#3
};
\end{codeblock}
\end{example}

\pnum
\indextext{initialization!base class}%
\indextext{initialization!member object}%
The
\grammarterm{expression-list}
or \grammarterm{braced-init-list}
in a
\grammarterm{mem-initializer}
is used to initialize the
designated subobject (or, in the case of a delegating constructor, the complete class object)
according to the initialization rules of~\ref{dcl.init} for direct-initialization.
\begin{example}
\begin{codeblock}
struct B1 { B1(int); @\commentellip@ };
struct B2 { B2(int); @\commentellip@ };
struct D : B1, B2 {
  D(int);
  B1 b;
  const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { @\commentellip@ }
D d(10);
\end{codeblock}
\end{example}
\begin{note}
The initialization
performed by each \grammarterm{mem-initializer}
constitutes a full-expres\-sion\iref{intro.execution}.
Any expression in
a
\grammarterm{mem-initializer}
is evaluated as part of the full-expression that performs the initialization.
\end{note}
A \grammarterm{mem-initializer} where the \grammarterm{mem-initializer-id} denotes
a virtual base class is ignored during execution of a constructor of any class that is
not the most derived class.

\pnum
A temporary expression bound to a reference member in a \grammarterm{mem-initializer}
is ill-formed.
\begin{example}
\begin{codeblock}
struct A {
  A() : v(42) { }   // error
  const int& v;
};
\end{codeblock}
\end{example}

\pnum
In a non-delegating constructor, if
a given potentially constructed subobject is not designated by a
\grammarterm{mem-initializer-id}
(including the case where there is no
\grammarterm{mem-initializer-list}
because the constructor has no
\grammarterm{ctor-initializer}),
then

\begin{itemize}
\item if the entity is a non-static data member that has
a default member initializer\iref{class.mem} and either

\begin{itemize}
\item the constructor's class is a union\iref{class.union}, and no other variant
member of that union is designated by a \grammarterm{mem-initializer-id} or

\item the constructor's class is not a union, and, if the entity is a member of an
anonymous union, no other member of that union is designated by a
\grammarterm{mem-initializer-id},
\end{itemize}

the entity is initialized from its default member initializer
as specified in~\ref{dcl.init};

\item otherwise, if the entity is an anonymous union or a variant member\iref{class.union.anon}, no initialization is performed;

\item otherwise, the entity is default-initialized\iref{dcl.init}.
\end{itemize}

\begin{note} An abstract class\iref{class.abstract} is never a most derived
class, thus its constructors never initialize virtual base classes, therefore the
corresponding \grammarterm{mem-initializer}{s} may be omitted. \end{note}
An attempt to initialize more than one non-static data member of a union renders the
program ill-formed.
\indextext{initialization!const member}%
\indextext{initialization!reference member}%
\begin{note}
After the call to a constructor for class
\tcode{X}
for an object with automatic or dynamic storage duration
has completed, if
the constructor was not invoked as part of value-initialization and
a member of
\tcode{X}
is neither initialized nor
given a value
during execution of the \grammarterm{compound-statement} of the body of the constructor,
the member has an indeterminate value.
\end{note}
\begin{example}
\begin{codeblock}
struct A {
  A();
};

struct B {
  B(int);
};

struct C {
  C() { }               // initializes members as follows:
  A a;                  // OK: calls \tcode{A::A()}
  const B b;            // error: \tcode{B} has no default constructor
  int i;                // OK: \tcode{i} has indeterminate value
  int j = 5;            // OK: \tcode{j} has the value \tcode{5}
};
\end{codeblock}
\end{example}

\pnum
If a given non-static data member has both a default member initializer
and a \grammarterm{mem-initializer}, the initialization specified by the
\grammarterm{mem-initializer} is performed, and the non-static data member's
default member initializer is ignored.
\begin{example} Given
% The comment below is misrendered with an overly large space before 'effects'
% if left to listings (see NB US-26 (C++17 CD)) (possibly due to the ff
% ligature), so we fix it up manually.
\begin{codeblock}
struct A {
  int i = /* some integer expression with side effects */ ;
  A(int arg) : i(arg) { }
  // ...
};
\end{codeblock}

the \tcode{A(int)} constructor will simply initialize \tcode{i} to the value of
\tcode{arg}, and the
\indextext{side effects}%
side effects in \tcode{i}'s default member initializer
will not take place.
\end{example}

\pnum
A temporary expression bound to a reference member from a
default member initializer is ill-formed.
\begin{example}
\begin{codeblock}
struct A {
  A() = default;        // OK
  A(int v) : v(v) { }   // OK
  const int& v = 42;    // OK
};
A a1;                   // error: ill-formed binding of temporary to reference
A a2(1);                // OK, unfortunately
\end{codeblock}
\end{example}

\pnum
In a non-delegating constructor, the destructor for each potentially constructed
subobject of class type is potentially invoked\iref{class.dtor}.
\begin{note} This provision ensures that destructors can be called for fully-constructed
subobjects in case an exception is thrown\iref{except.ctor}. \end{note}

\pnum
In a non-delegating constructor, initialization
proceeds in the following order:
\begin{itemize}
\item
\indextext{initialization!order of virtual base class}%
First, and only for the constructor of the most derived class\iref{intro.object},
virtual base classes are initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where ``left-to-right'' is the order of appearance of the base classes
in the derived class
\grammarterm{base-specifier-list}.
\item
\indextext{initialization!order of base class}%
Then, direct base classes are initialized in declaration order
as they appear in the
\grammarterm{base-specifier-list}
(regardless of the order of the
\grammarterm{mem-initializer}{s}).
\item
\indextext{initialization!order of member}%
Then, non-static data members are initialized in the order
they were declared in the class definition
(again regardless of the order of the
\grammarterm{mem-initializer}{s}).
\item
Finally, the \grammarterm{compound-statement} of the constructor
body  is executed.
\end{itemize}

\begin{note}
The declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
struct V {
  V();
  V(int);
};

struct A : virtual V {
  A();
  A(int);
};

struct B : virtual V {
  B();
  B(int);
};

struct C : A, B, virtual V {
  C();
  C(int);
};

A::A(int i) : V(i) { @\commentellip@ }
B::B(int i) { @\commentellip@ }
C::C(int i) { @\commentellip@ }

V v(1);             // use \tcode{V(int)}
A a(2);             // use \tcode{V(int)}
B b(3);             // use \tcode{V()}
C c(4);             // use \tcode{V()}
\end{codeblock}
\end{example}

\pnum
\indextext{initializer!scope of member}%
Names in the
\grammarterm{expression-list}
or \grammarterm{braced-init-list}
of a
\grammarterm{mem-initializer}
are evaluated in the scope of the constructor for which the
\grammarterm{mem-initializer}
is specified.
\begin{example}

\begin{codeblock}
class X {
  int a;
  int b;
  int i;
  int j;
public:
  const int& r;
  X(int i): r(a), b(i), i(i), j(this->i) { }
};
\end{codeblock}

initializes
\tcode{X::r}
to refer to
\tcode{X::a},
initializes
\tcode{X::b}
with the value of the constructor parameter
\tcode{i},
initializes
\tcode{X::i}
with the value of the constructor parameter
\tcode{i},
and initializes
\tcode{X::j}
with the value of
\tcode{X::i};
this takes place each time an object of class
\tcode{X}
is created.
\end{example}
\begin{note}
Because the
\grammarterm{mem-initializer}
are evaluated in the scope of the constructor, the
\tcode{this}
pointer can be used in the
\grammarterm{expression-list}
of a
\grammarterm{mem-initializer}
to refer to the object being initialized.
\end{note}

\pnum
\indextext{initialization!member function call during}%
Member functions (including virtual member functions, \ref{class.virtual}) can be
called for an object under construction.
Similarly, an object under construction can be the operand of the
\tcode{typeid}
operator\iref{expr.typeid} or of a
\tcode{dynamic_cast}\iref{expr.dynamic.cast}.
However, if these operations are performed in a
\grammarterm{ctor-initializer}
(or in a function called directly or indirectly from a
\grammarterm{ctor-initializer})
before all the
\grammarterm{mem-initializer}{s}
for base classes have completed, the program has undefined behavior.
\begin{example}
\begin{codeblock}
class A {
public:
  A(int);
};

class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     // undefined: calls member function but base \tcode{A} not yet initialized
  j(f()) { }        // well-defined: bases are all initialized
};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;
public:
  D() : C(f()),     // undefined: calls member function but base \tcode{C} not yet initialized
  i(f()) { }        // well-defined: bases are all initialized
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
\ref{class.cdtor} describes the result of virtual function calls,
\tcode{typeid}
and
\tcode{dynamic_cast}s
during construction for the well-defined cases;
that is, describes the
\term{polymorphic behavior}
of an object under construction.
\end{note}

\pnum
\indextext{initializer!pack expansion}%
A \grammarterm{mem-initializer} followed by an ellipsis is
a pack expansion\iref{temp.variadic} that initializes the base
classes specified by a pack expansion in the \grammarterm{base-specifier-list}
for the class. \begin{example}

\begin{codeblock}
template<class... Mixins>
class X : public Mixins... {
public:
  X(const Mixins&... mixins) : Mixins(mixins)... { }
};
\end{codeblock}

\end{example}

\rSec2[class.inhctor.init]{Initialization by inherited constructor}%
\indextext{initialization!by inherited constructor}

\pnum
When a constructor for type \tcode{B} is invoked
to initialize an object of a different type \tcode{D}
(that is, when the constructor was inherited\iref{namespace.udecl}),
initialization proceeds as if a defaulted default constructor
were used to initialize the \tcode{D} object and
each base class subobject from which the constructor was inherited,
except that the \tcode{B} subobject is initialized
by the invocation of the inherited constructor.
The complete initialization is considered to be a single function call;
in particular, the initialization of the inherited constructor's parameters
is sequenced before the initialization of any part of the \tcode{D} object.
\begin{example}
\begin{codeblock}
struct B1 {
  B1(int, ...) { }
};

struct B2 {
  B2(double) { }
};

int get();

struct D1 : B1 {
  using B1::B1;     // inherits \tcode{B1(int, ...)}
  int x;
  int y = get();
};

void test() {
  D1 d(2, 3, 4);    // OK: \tcode{B1} is initialized by calling \tcode{B1(2, 3, 4)},
                    // then \tcode{d.x} is default-initialized (no initialization is performed),
                    // then \tcode{d.y} is initialized by calling \tcode{get()}
  D1 e;             // error: \tcode{D1} has a deleted default constructor
}

struct D2 : B2 {
  using B2::B2;
  B1 b;
};

D2 f(1.0);          // error: \tcode{B1} has a deleted default constructor

struct W { W(int); };
struct X : virtual W { using W::W; X() = delete; };
struct Y : X { using X::X; };
struct Z : Y, virtual W { using Y::Y; };
Z z(0);             // OK: initialization of \tcode{Y} does not invoke default constructor of \tcode{X}

template<class T> struct Log : T {
  using T::T;       // inherits all constructors from class \tcode{T}
  ~Log() { std::clog << "Destroying wrapper" << std::endl; }
};
\end{codeblock}
Class template \tcode{Log} wraps any class and forwards all of its constructors,
while writing a message to the standard log
whenever an object of class \tcode{Log} is destroyed.
\end{example}

\pnum
If the constructor was inherited from multiple base class subobjects
of type \tcode{B}, the program is ill-formed.
\begin{example}
\begin{codeblock}
struct A { A(int); };
struct B : A { using A::A; };

struct C1 : B { using B::B; };
struct C2 : B { using B::B; };

struct D1 : C1, C2 {
  using C1::C1;
  using C2::C2;
};

struct V1 : virtual B { using B::B; };
struct V2 : virtual B { using B::B; };

struct D2 : V1, V2 {
  using V1::V1;
  using V2::V2;
};

D1 d1(0);           // ill-formed: ambiguous
D2 d2(0);           // OK: initializes virtual \tcode{B} base class, which initializes the \tcode{A} base class
                    // then initializes the \tcode{V1} and \tcode{V2} base classes as if by a defaulted default constructor

struct M { M(); M(int); };
struct N : M { using M::M; };
struct O : M {};
struct P : N, O { using N::N; using O::O; };
P p(0);             // OK: use \tcode{M(0)} to initialize \tcode{N}{'s} base class,
                    // use \tcode{M()} to initialize \tcode{O}{'s} base class
\end{codeblock}
\end{example}

\pnum
When an object is initialized by an inherited constructor,
initialization of the object is complete
when the initialization of all subobjects is complete.%
\indextext{initialization!class object|)}

\rSec1[class.cdtor]{Construction and destruction}%
\indextext{construction|(}%
\indextext{destruction|(}%

\pnum
\indextext{construction!member access}%
\indextext{destruction!member access}%
For an object with a non-trivial constructor, referring to any non-static member
or base class of the object before the constructor begins execution results in
undefined behavior. For an object with a non-trivial destructor, referring to
any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior.
\begin{example}
\begin{codeblock}
struct X { int i; };
struct Y : X { Y(); };                  // non-trivial
struct A { int a; };
struct B : public A { int j; Y y; };    // non-trivial

extern B bobj;
B* pb = &bobj;                          // OK
int* p1 = &bobj.a;                      // undefined, refers to base class member
int* p2 = &bobj.y.i;                    // undefined, refers to member's member

A* pa = &bobj;                          // undefined, upcast to a base class type
B bobj;                                 // definition of \tcode{bobj}

extern X xobj;
int* p3 = &xobj.i;                      // OK, \tcode{X} is a trivial class
X xobj;
\end{codeblock}
For another example,
\begin{codeblock}
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() : p(&x.j) {   // undefined, \tcode{x} is not yet constructed
    }
};
\end{codeblock}
\end{example}

\pnum
\indextext{construction!pointer to member or base}%
\indextext{destruction!pointer to member or base}%
To explicitly or implicitly convert a pointer (a glvalue) referring to
an object of class
\tcode{X}
to a pointer (reference) to a direct or indirect base class
\tcode{B}
of
\tcode{X},
the construction of
\tcode{X}
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
\tcode{B}
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior.
To form a pointer to (or access the value of) a direct non-static member of
an object
\tcode{obj},
the construction of
\tcode{obj}
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior.
\begin{example}
\begin{codeblock}
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    // undefined: upcast from \tcode{E*} to \tcode{A*} might use path \tcode{E*} $\rightarrow$ \tcode{D*} $\rightarrow$ \tcode{A*}
                    // but \tcode{D} is not constructed

                    // ``\tcode{D((C*)this)}\!'' would be defined: \tcode{E*} $\rightarrow$ \tcode{C*} is defined because \tcode{E()} has started,
                    // and \tcode{C*} $\rightarrow$ \tcode{A*} is defined because \tcode{C} is fully constructed

  X(this) {}        // defined: upon construction of \tcode{X}, \tcode{C/B/D/A} sublattice is fully constructed
};
\end{codeblock}
\end{example}

\pnum
\indextext{virtual function call!constructor and}%
\indextext{virtual function call!destructor and}%
\indextext{construction!virtual function call}%
\indextext{destruction!virtual function call}%
Member functions, including virtual functions\iref{class.virtual}, can be called
during construction or destruction\iref{class.base.init}.
When a virtual function is called directly or indirectly from a constructor
or from a destructor,
including during the construction or destruction of the class's non-static data
members,
and the object to which the call applies is the object (call it \tcode{x}) under construction or
destruction,
the function called is the
final overrider in the constructor's or destructor's class and not one
overriding it in a more-derived class.
If the virtual function call uses an explicit class member access\iref{expr.ref}
and the object expression refers to
the complete object of \tcode{x} or one of that object's base class subobjects
but not \tcode{x} or one of its base class subobjects, the behavior
is undefined.
\begin{example}

\begin{codeblock}
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V*, A*);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  f();              // calls \tcode{V::f}, not \tcode{A::f}
  g();              // calls \tcode{B::g}, not \tcode{D::g}
  v->g();           // \tcode{v} is base of \tcode{B}, the call is well-defined, calls \tcode{B::g}
  a->f();           // undefined behavior, \tcode{a}'s type not a base of \tcode{B}
}
\end{codeblock}
\end{example}

\pnum
\indextext{construction!\idxcode{typeid} operator}%
\indextext{destruction!\idxcode{typeid} operator}%
\indextext{\idxcode{typeid}!construction and}%
\indextext{\idxcode{typeid}!destruction and}%
The
\tcode{typeid}
operator\iref{expr.typeid} can be used during construction or destruction\iref{class.base.init}.
When
\tcode{typeid}
is used in a constructor (including the
\grammarterm{mem-initializer} or default member initializer\iref{class.mem}
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
\tcode{typeid}
refers to the object under construction or destruction,
\tcode{typeid}
yields the
\tcode{std::type_info}
object representing the constructor or destructor's class.
If the operand of
\tcode{typeid}
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the behavior is undefined.

\pnum
\indextext{construction!dynamic cast and}%
\indextext{destruction!dynamic cast and}%
\indextext{cast!dynamic!construction and}%
\indextext{cast!dynamic!destruction and}%
\tcode{dynamic_cast}s\iref{expr.dynamic.cast} can be used during construction
or destruction\iref{class.base.init}. When a
\tcode{dynamic_cast}
is used in a constructor (including the
\grammarterm{mem-initializer} or default member initializer
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
\tcode{dynamic_cast}
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class.
If the operand of the
\tcode{dynamic_cast}
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
\tcode{dynamic_cast}
results in undefined behavior.
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);                // \tcode{type_info} for \tcode{B}
  typeid(*v);                   // well-defined: \tcode{*v} has type \tcode{V}, a base of \tcode{B} yields \tcode{type_info} for \tcode{B}
  typeid(*a);                   // undefined behavior: type \tcode{A} not a base of \tcode{B}
  dynamic_cast<B*>(v);          // well-defined: \tcode{v} of type \tcode{V*}, \tcode{V} base of \tcode{B} results in \tcode{B*}
  dynamic_cast<B*>(a);          // undefined behavior, \tcode{a} has type \tcode{A*}, \tcode{A} not a base of \tcode{B}
}
\end{codeblock}
\end{example}
\indextext{destruction|)}%
\indextext{construction|)}%

\rSec1[class.copy]{Copying and moving class objects}%

\pnum
A class object can be copied or moved in two ways:
by initialization~(\ref{class.ctor}, \ref{dcl.init}), including for function argument passing\iref{expr.call} and for function value return\iref{stmt.return};
and by assignment\iref{expr.ass}.
Conceptually, these two operations are implemented by a
copy/move constructor\iref{class.ctor}
and copy/move assignment operator\iref{over.ass}.

\pnum
\indextext{constructor!copy!inaccessible}%
\indextext{constructor!move!inaccessible}%
\indextext{assignment operator!copy!inaccessible}%
\indextext{assignment operator!move!inaccessible}%
A program is ill-formed if the copy/move constructor or the copy/move assignment
operator for an object is implicitly odr-used and the special member function
is not accessible\iref{class.access}.
\begin{note}
Copying/moving one object into another using the copy/move constructor or
the copy/move assignment operator does not change the layout or size of either
object.
\end{note}

\rSec2[class.copy.ctor]{Copy/move constructors}%

\pnum
\indextext{constructor!copy|(}%
\indextext{constructor!move|(}%
\indextext{copy!class object|see{constructor, copy}}%
\indextext{move!class object|see{constructor, move}}%
A non-template constructor for class
\tcode{X}
is
a
copy
constructor if its first parameter is of type
\tcode{X\&},
\tcode{const X\&},
\tcode{volatile X\&}
or
\tcode{const volatile X\&},
and either there are no other parameters
or else all other parameters have default arguments\iref{dcl.fct.default}.
\begin{example}
\tcode{X::X(const X\&)}
and
\tcode{X::X(X\&,int=1)}
are copy constructors.

\begin{codeblock}
struct X {
  X(int);
  X(const X&, int = 1);
};
X a(1);             // calls \tcode{X(int);}
X b(a, 0);          // calls \tcode{X(const X\&, int);}
X c = b;            // calls \tcode{X(const X\&, int);}
\end{codeblock}
\end{example}

\pnum
A non-template constructor for class \tcode{X} is a move constructor if its
first parameter is of type \tcode{X\&\&}, \tcode{const X\&\&},
\tcode{volatile X\&\&}, or \tcode{const volatile X\&\&}, and either there are
no other parameters or else all other parameters have default
arguments\iref{dcl.fct.default}.
\begin{example} \tcode{Y::Y(Y\&\&)} is a move constructor.
\begin{codeblock}
struct Y {
  Y(const Y&);
  Y(Y&&);
};
extern Y f(int);
Y d(f(1));          // calls \tcode{Y(Y\&\&)}
Y e = d;            // calls \tcode{Y(const Y\&)}
\end{codeblock}
\end{example}

\pnum
\begin{note}
All forms of copy/move constructor may be declared for a class.
\begin{example}

\begin{codeblock}
struct X {
  X(const X&);
  X(X&);            // OK
  X(X&&);
  X(const X&&);     // OK, but possibly not sensible
};
\end{codeblock}
\end{example}
\end{note}

\pnum
\begin{note}
If a class
\tcode{X}
only has a copy constructor with a parameter of type
\tcode{X\&},
an initializer of type
\tcode{const}
\tcode{X}
or
\tcode{volatile}
\tcode{X}
cannot initialize an object of type
(possibly
cv-qualified)
\tcode{X}.
\begin{example}

\begin{codeblock}
struct X {
  X();              // default constructor
  X(X&);            // copy constructor with a non-const parameter
};
const X cx;
X x = cx;           // error: \tcode{X::X(X\&)} cannot copy \tcode{cx} into \tcode{x}
\end{codeblock}
\end{example}
\end{note}

\pnum
A declaration of a constructor for a class
\tcode{X}
is ill-formed if its first parameter is of type (optionally cv-qualified)
\tcode{X}
and either there are no other parameters or else all other parameters have
default arguments.
A member function template is never instantiated to
produce such a constructor signature.
\begin{example}
\begin{codeblock}
struct S {
  template<typename T> S(T);
  S();
};

S g;

void h() {
  S a(g);           // does not instantiate the member template to produce \tcode{S::S<S>(S)};
                    // uses the implicitly declared copy constructor
}
\end{codeblock}
\end{example}

\pnum
If the class definition does not explicitly declare a copy constructor,
a non-explicit one is declared \defnx{implicitly}{constructor!copy!implicitly declared}.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
constructor is defined as deleted; otherwise, it is defined as
defaulted\iref{dcl.fct.def}.
The latter case is deprecated if the class has a user-declared copy assignment
operator or a user-declared destructor.

\pnum
The implicitly-declared copy constructor for a class
\tcode{X}
will have the form

\begin{codeblock}
X::X(const X&)
\end{codeblock}

if each potentially constructed subobject of a class type
\tcode{M}
(or array thereof)
has a copy constructor whose first parameter is of type
\tcode{const}
\tcode{M\&}
or
\tcode{const}
\tcode{volatile}
\tcode{M\&}.\footnote{This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
\tcode{volatile}
lvalue; see~\ref{diff.special}.}
Otherwise, the implicitly-declared copy constructor will have the form

\begin{codeblock}
X::X(X&)
\end{codeblock}

\pnum
\indextext{constructor!move!implicitly declared}%
If the definition of a class \tcode{X} does not explicitly declare
a move constructor, a non-explicit one will be
implicitly declared as defaulted if and only if

\begin{itemize}
\item
\tcode{X} does not have a user-declared copy constructor,

\item
\tcode{X} does not have a user-declared copy assignment operator,

\item
\tcode{X} does not have a user-declared move assignment operator, and

\item
\tcode{X} does not have a user-declared destructor.
\end{itemize}

\begin{note} When the move constructor is not implicitly declared or explicitly supplied,
expressions that otherwise would have invoked the move constructor may instead invoke
a copy constructor. \end{note}

\pnum
The implicitly-declared move constructor for class \tcode{X} will have the form
\begin{codeblock}
X::X(X&&)
\end{codeblock}

\pnum
An implicitly-declared copy/move constructor is an
inline public member of its class.
A defaulted copy/\brk{}move constructor for a class
  \tcode{X} is defined as deleted\iref{dcl.fct.def.delete} if \tcode{X} has:
\begin{itemize}
\item a potentially constructed subobject type
  \tcode{M} (or array thereof) that cannot be copied/moved because
  overload resolution\iref{over.match}, as applied to find
  \tcode{M}'s
  corresponding constructor, results in an ambiguity or
  a function that is deleted or inaccessible from the
  defaulted constructor,

\item a variant member whose corresponding constructor
  as selected by overload resolution is non-trivial,

\item any potentially constructed subobject of a type
  with a destructor that is deleted or inaccessible from the defaulted
  constructor, or,

\item for the copy constructor, a non-static data member of rvalue reference type.
\end{itemize}

A defaulted move constructor that is defined as deleted is ignored by overload
resolution~(\ref{over.match}, \ref{over.over}).
\begin{note}
A deleted move constructor would otherwise interfere with initialization from
an rvalue which can use the copy constructor instead.
\end{note}

\pnum
\indextext{constructor!copy!trivial}%
\indextext{constructor!move!trivial}%
A copy/move constructor for class
\tcode{X}
is
trivial
if it is not user-provided and if:

\begin{itemize}
\item
class
\tcode{X}
has no virtual functions\iref{class.virtual}
and no virtual base classes\iref{class.mi}, and

\item
the constructor selected to copy/move each direct base class subobject is trivial, and

\item
for each non-static data member of
\tcode{X}
that is of class type (or array thereof),
the constructor selected to copy/move that member is trivial;
\end{itemize}

\indextext{constructor!move!non-trivial}%
otherwise the copy/move constructor is
\defnx{non-trivial}{constructor!copy!nontrivial}.

\pnum
\indextext{constructor!copy!implicitly defined}%
\indextext{constructor!move!implicitly defined}%
A copy/move constructor
that is defaulted and not defined as deleted
is
\term{implicitly defined}
when it is odr-used\iref{basic.def.odr},
when it is needed for constant evaluation\iref{expr.const}, or
when it is explicitly defaulted after its first declaration.
\begin{note}
The copy/move constructor is implicitly defined even if the implementation elided
its odr-use~(\ref{basic.def.odr}, \ref{class.temporary}).
\end{note}
If the implicitly-defined constructor would satisfy the requirements of a
constexpr constructor\iref{dcl.constexpr}, the implicitly-defined
constructor is \tcode{constexpr}.

\pnum
Before the defaulted copy/move constructor for a class is
implicitly defined,
all non-user-provided copy/move constructors for its
potentially constructed subobjects
shall have been implicitly defined.
\begin{note}
An implicitly-declared copy/move constructor has an
implied exception specification\iref{except.spec}.
\end{note}

\pnum
The implicitly-defined copy/move constructor for a non-union class
\tcode{X}
performs a memberwise copy/move of its bases and members.
\begin{note} Default member initializers of non-static data members are ignored. See also the example in~\ref{class.base.init}. \end{note}
The order of initialization is the same as the order of initialization of bases
and members in a user-defined constructor (see~\ref{class.base.init}).
Let \tcode{x} be either the parameter of the constructor or, for the move constructor, an
xvalue referring to the parameter.
Each base or non-static data member
is copied/moved in the manner appropriate to its type:

\begin{itemize}
\item
if the member is an array, each element is
direct-initialized with the corresponding subobject of \tcode{x};

\item
if a member \tcode{m} has rvalue reference type \tcode{T\&\&}, it is direct-initialized with
\tcode{static_cast<T\&\&>(x.m)};

\item
otherwise, the base or member is direct-initialized with the corresponding base or member of \tcode{x}.
\end{itemize}

\indextext{initialization!virtual base class}%
Virtual base class subobjects shall be initialized only once by
the implicitly-defined copy/move constructor (see~\ref{class.base.init}).

\pnum
The implicitly-defined copy/move constructor for a union
\tcode{X} copies the object representation\iref{basic.types} of \tcode{X}.%
\indextext{constructor!move|)}%
\indextext{constructor!copy|)}


\rSec2[class.copy.assign]{Copy/move assignment operator}%

\pnum
\indextext{assignment operator!copy|(}%
\indextext{assignment operator!move|(}%
\indextext{special member function|see{assignment operator}}%
\indextext{copy!class object|see{assignment operator, copy}}%
\indextext{move!class object|see{assignment operator, move}}%
\indextext{operator!copy assignment|see{assignment operator, copy}}%
\indextext{operator!move assignment|see{assignment operator, move}}%
A user-declared \term{copy} assignment operator \tcode{X::operator=} is a
non-static non-template member function of class \tcode{X} with exactly one
parameter of type \tcode{X}, \tcode{X\&}, \tcode{const} \tcode{X\&},
\tcode{volatile} \tcode{X\&} or \tcode{const} \tcode{volatile}
\tcode{X\&}.\footnote{Because a template assignment operator or an assignment
operator taking an rvalue reference parameter is never a copy assignment
operator, the presence of such an assignment operator does not suppress the
implicit declaration of a copy assignment operator. Such assignment operators
participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.}
\begin{note}
An overloaded assignment operator must be declared to have only one parameter;
see~\ref{over.ass}.
\end{note}
\begin{note}
More than one form of copy assignment operator may be declared for a class.
\end{note}
\begin{note}
If a class
\tcode{X}
only has a copy assignment operator with a parameter of type
\tcode{X\&},
an expression of type const
\tcode{X}
cannot be assigned to an object of type
\tcode{X}.
\begin{example}

\begin{codeblock}
struct X {
  X();
  X& operator=(X&);
};
const X cx;
X x;
void f() {
  x = cx;           // error: \tcode{X::operator=(X\&)} cannot assign \tcode{cx} into \tcode{x}
}
\end{codeblock}
\end{example}
\end{note}

\pnum
If the class definition does not explicitly declare a copy assignment operator,
one is declared \defnx{implicitly}{assignment operator!copy!implicitly declared}.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
assignment operator is defined as deleted; otherwise, it is defined as
defaulted\iref{dcl.fct.def}.
The latter case is deprecated if the class has a user-declared copy constructor
or a user-declared destructor.
The implicitly-declared copy assignment operator for a class
\tcode{X}
will have the form

\begin{codeblock}
X& X::operator=(const X&)
\end{codeblock}

if

\begin{itemize}
\item
each direct base class
\tcode{B}
of
\tcode{X}
has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{B\&},
\tcode{const}
\tcode{volatile}
\tcode{B\&}
or
\tcode{B},
and
\item
for all the non-static data members of
\tcode{X}
that are of a class type
\tcode{M}
(or array thereof),
each such class type has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{M\&},
\tcode{const}
\tcode{volatile}
\tcode{M\&}
or
\tcode{M}.\footnote{This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
\tcode{volatile}
lvalue; see~\ref{diff.special}.}
\end{itemize}

Otherwise, the implicitly-declared copy
assignment operator
will have the form

\begin{codeblock}
X& X::operator=(X&)
\end{codeblock}

\pnum
A user-declared move assignment operator \tcode{X::operator=} is
a non-static non-template member function of class \tcode{X} with exactly
one parameter of type \tcode{X\&\&}, \tcode{const X\&\&}, \tcode{volatile X\&\&}, or
\tcode{const volatile X\&\&}. \begin{note} An overloaded assignment operator must be
declared to have only one parameter; see~\ref{over.ass}. \end{note}{}
\begin{note} More
than one form of move assignment operator may be declared for a class. \end{note}

\pnum
\indextext{assignment operator!move!implicitly declared}%
If the definition of a class \tcode{X} does not explicitly declare a
move assignment operator, one
will be implicitly declared as defaulted if and only if

\begin{itemize}
\item
\tcode{X} does not have a user-declared copy constructor,

\item
\tcode{X} does not have a user-declared move constructor,

\item
\tcode{X} does not have a user-declared copy assignment operator, and

\item
\tcode{X} does not have a user-declared destructor.
\end{itemize}

\begin{example} The class definition
\begin{codeblock}
struct S {
  int a;
  S& operator=(const S&) = default;
};
\end{codeblock}

will not have a default move assignment operator implicitly declared because the
copy assignment operator has been user-declared. The move assignment operator may
be explicitly defaulted.

\begin{codeblock}
struct S {
  int a;
  S& operator=(const S&) = default;
  S& operator=(S&&) = default;
};
\end{codeblock}
\end{example}

\pnum
The implicitly-declared move assignment operator for a class \tcode{X} will have the form
\begin{codeblock}
X& X::operator=(X&&);
\end{codeblock}

\pnum
The implicitly-declared copy/move assignment operator for class
\tcode{X}
has the return type
\tcode{X\&};
it returns the object for which the assignment operator is invoked, that is,
the object assigned to.
An implicitly-declared copy/move assignment operator is an
inline public member of its class.

\pnum
A defaulted copy/move assignment operator for
class \tcode{X} is defined as deleted if \tcode{X} has:
\begin{itemize}
\item a variant member with a non-trivial corresponding assignment operator and
  \tcode{X} is a union-like class, or

\item a non-static data member of \tcode{const} non-class
  type (or array thereof), or

\item a non-static data member of reference type, or

\item a direct non-static data member of class type \tcode{M}
  (or array thereof) or a direct base class \tcode{M}
  that cannot be copied/moved because overload resolution
 \iref{over.match}, as applied to find \tcode{M}'s corresponding
  assignment operator, results in an ambiguity or
  a function that is deleted or inaccessible from the
  defaulted assignment operator.
\end{itemize}

A defaulted move assignment operator that is defined as deleted is ignored by
overload resolution~(\ref{over.match}, \ref{over.over}).

\pnum
\indextext{assignment operator!copy!hidden}%
\indextext{assignment operator!move!hidden}%
Because a copy/move assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy/move assignment operator is always hidden
by the corresponding assignment operator of a derived class\iref{over.ass}.
A
\grammarterm{using-declaration}\iref{namespace.udecl} that brings in from a base class an assignment operator
with a parameter type that could be that of a
copy/move assignment operator for the
derived class is not considered an explicit declaration of such an
operator and does not suppress the implicit declaration of the derived class
operator;
the operator introduced by the
\grammarterm{using-declaration}
is hidden by the implicitly-declared operator in the derived
class.

\pnum
\indextext{assignment operator!copy!trivial}%
\indextext{assignment operator!move!trivial}%
A copy/move assignment operator for class
\tcode{X}
is
trivial
if it is not user-provided and if:

\begin{itemize}
\item
class
\tcode{X}
has no virtual functions\iref{class.virtual}
and no virtual base classes\iref{class.mi}, and

\item the assignment operator selected to copy/move each direct
base class subobject is trivial, and

\item
for each non-static data member of
\tcode{X}
that is of class type (or array thereof),
the assignment operator selected to copy/move that member is trivial;
\end{itemize}

\indextext{assignment operator!move!non-trivial}%
otherwise the copy/move assignment operator is
\defnx{non-trivial}{assignment operator!copy!non-trivial}.

\pnum
\indextext{assignment operator!copy!implicitly defined}%
\indextext{assignment operator!move!implicitly defined}%
A copy/move assignment operator for a class \tcode{X}
that is defaulted and not defined as deleted
is
\term{implicitly defined}
when it is odr-used\iref{basic.def.odr}
(e.g., when it is selected by overload resolution
to assign to an object of its class type),
when it is needed for constant evaluation\iref{expr.const}, or
when it is explicitly defaulted after its first declaration.
The implicitly-defined copy/move assignment operator is \tcode{constexpr} if
\begin{itemize}
\item
\tcode{X} is a literal type, and

\item
the assignment operator selected to copy/move each direct base class subobject
is a constexpr function, and

\item
for each non-static data member of \tcode{X} that is of class type (or array
thereof), the assignment operator selected to copy/move that member is a
constexpr function.
\end{itemize}

\pnum
Before the defaulted copy/move assignment operator for a class is
implicitly defined,
all non-user-provided copy/move assignment operators for
its direct base classes and
its non-static data members shall have been implicitly defined.
\begin{note}
An implicitly-declared copy/move assignment operator has an
implied exception specification\iref{except.spec}.
\end{note}

\pnum
The implicitly-defined copy/move assignment operator for a
non-union class \tcode{X} performs memberwise copy/move assignment of its subobjects. The direct
base classes of \tcode{X} are assigned first, in the order of their declaration in the
\grammarterm{base-specifier-list}, and then the immediate non-static data members of
\tcode{X} are assigned, in the order in which they were declared in the class
definition.
Let \tcode{x} be either the parameter of the function or, for the move operator, an
xvalue referring to the parameter.
Each subobject is assigned in the manner appropriate to its type:

\begin{itemize}
\item
if the subobject is of class type,
as if by a call to \tcode{operator=} with the subobject as the object expression
and the corresponding subobject of \tcode{x} as a single function argument
(as if by explicit qualification; that is,
ignoring any possible virtual overriding functions in more derived classes);
\item
if the subobject is an array, each element is assigned,
in the manner appropriate to the element type;
\item
if the subobject is of scalar type,
the built-in assignment operator is used.
\end{itemize}

\indextext{assignment operator!copy!virtual bases and}%
It is unspecified whether subobjects representing virtual base classes
are assigned more than once by the implicitly-defined copy/move assignment
operator.
\begin{example}

\begin{codeblock}
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
\end{codeblock}

It is unspecified whether the virtual base class subobject
\tcode{V}
is assigned twice by the implicitly-defined copy/move assignment operator for
\tcode{C}.
\end{example}

\pnum
The implicitly-defined copy assignment operator for a
union \tcode{X} copies the object representation\iref{basic.types} of \tcode{X}.%
\indextext{assignment operator!move|)}%
\indextext{assignment operator!copy|)}

\rSec2[class.copy.elision]{Copy/move elision}%

\pnum
\indextext{temporary!elimination of}%
\indextext{elision!copy constructor|see{constructor, copy, elision}}%
\indextext{elision!move constructor|see{constructor, move, elision}}%
\indextext{constructor!copy!elision}%
\indextext{constructor!move!elision}%
When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
\indextext{side effects}%
side effects.  In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object. If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization.\footnote{Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed.}
This elision of copy/move operations, called
\indexdefn{copy elision|see{constructor, copy, elision}}%
\indexdefn{elision!copy|see{constructor, copy, elision}}%
\indexdefn{constructor!copy!elision}\indexdefn{constructor!move!elision}\term{copy elision},
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):

\begin{itemize}
\item in a \tcode{return} statement in a function with a class return type,
when the \grammarterm{expression} is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the \grammarterm{exception-declaration} of a
\grammarterm{handler}\iref{except.handle})
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object

\item in a \grammarterm{throw-expression}\iref{expr.throw}, when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
\grammarterm{try-block} (if there is one), the copy/move operation from the
operand to the exception object\iref{except.throw} can be omitted by
constructing the automatic object directly into the exception object

\item when the \grammarterm{exception-declaration} of an
exception handler\iref{except} declares an object of the same
type (except for cv-qualification) as the exception
object\iref{except.throw}, the copy operation can be omitted by treating
the \grammarterm{exception-declaration} as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
\grammarterm{exception-declaration}.
\begin{note} There cannot be a move from the exception object because it is
always an lvalue.  \end{note}
\end{itemize}
Copy elision is required
where an expression is evaluated in a context
requiring a constant expression\iref{expr.const}
and in constant initialization\iref{basic.start.static}.
\begin{note}
Copy elision might not be performed
if the same expression
is evaluated in another context.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;          // well-formed, \tcode{a.p} points to \tcode{a}
constexpr A b = g();    // well-formed, \tcode{b.p} points to \tcode{b}

void g() {
  A c = g();            // well-formed, \tcode{c.p} may point to \tcode{c} or to an ephemeral temporary
}
\end{codeblock}
Here the criteria for elision can
eliminate
the copying of the local automatic object
\tcode{t}
into the result object for the function call
\tcode{f()},
which is the global object
\tcode{t2}.
Effectively, the construction of the local object
\tcode{t}
can be viewed as directly initializing the global
object
\tcode{t2},
and that object's destruction will occur at program
exit.
Adding a move constructor to \tcode{Thing} has the same effect, but it is the
move construction from the local automatic object to \tcode{t2} that is elided.
\end{example}

\pnum
In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
\begin{itemize}
\item If the \grammarterm{expression} in a \tcode{return} statement\iref{stmt.return}
is a (possibly parenthesized) \grammarterm{id-expression}
that names an object with automatic storage duration declared in the body
or \grammarterm{parameter-declaration-clause} of the innermost enclosing
function or \grammarterm{lambda-expression}, or

\item if the operand of a \grammarterm{throw-expression}\iref{expr.throw}
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
\grammarterm{try-block} (if there is one),
\end{itemize}
overload resolution to select the constructor
for the copy is first performed as if the object were designated by an
rvalue.
If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue.
\begin{note}
This two-stage overload resolution must be performed regardless
of whether copy elision will occur. It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&&);
private:
  Thing(const Thing&);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            // OK: \tcode{Thing(Thing\&\&)} used (or elided) to throw \tcode{t}
  return t;             // OK: \tcode{Thing(Thing\&\&)} used (or elided) to return \tcode{t}
}

Thing t2 = f(false);    // OK: no extra copy/move performed, \tcode{t2} constructed by call to \tcode{f}

struct Weird {
  Weird();
  Weird(Weird&);
};

Weird g() {
  Weird w;
  return w;             // OK: first overload resolution fails, second overload resolution selects \tcode{Weird(Weird\&)}
}
\end{codeblock}
\end{example}

\rSec1[class.compare]{Comparisons}%

\rSec2[class.compare.default]{Defaulted comparison operator functions}%

\pnum
A defaulted comparison operator function (\ref{expr.spaceship}, \ref{expr.rel}, \ref{expr.eq})
for some class \tcode{C}
shall be a non-template function
declared in the \grammarterm{member-specification} of \tcode{C}
that is
\begin{itemize}
\item a non-static member of \tcode{C} having one parameter of type \tcode{const C\&}, or
\item a friend of \tcode{C} having two parameters of type \tcode{const C\&}.
\end{itemize}

\rSec2[class.spaceship]{Three-way comparison}
\indextext{operator!three-way comparison!defaulted}%

\pnum
The direct base class subobjects of \tcode{C},
in the order of their declaration in the \grammarterm{base-specifier-list} of \tcode{C},
followed by the non-static data members of \tcode{C},
in the order of their declaration in the \grammarterm{member-specification} of \tcode{C},
form a list of subobjects.
In that list, any subobject of array type is recursively expanded
to the sequence of its elements, in the order of increasing subscript.
Let \tcode{x}$_i$ be an lvalue denoting the $i^\textrm{th}$ element
in the expanded list of subobjects for an object \tcode{x}
(of length $n$),
where \tcode{x}$_i$ is
formed by a sequence of
derived-to-base conversions\iref{over.best.ics},
class member access expressions\iref{expr.ref}, and
array subscript expressions\iref{expr.sub} applied to \tcode{x}.
The type of the expression \tcode{x}$_i$ \tcode{<=>} \tcode{x}$_i$
is denoted by \tcode{R}$_i$.
It is unspecified
whether virtual base class subobjects are compared more than once.

\pnum
If the declared return type
of a defaulted three-way comparison operator function
is \tcode{auto},
then the return type is deduced as
the common comparison type (see below) of
\tcode{R}$_0$, \tcode{R}$_1$, $\cdots$, \tcode{R}$_{n-1}$.
\begin{note}
Otherwise,
the program will be ill-formed
if the expression \tcode{x}$_i$ \tcode{<=>} \tcode{x}$_i$
is not implicitly convertible to the declared return type for any $i$.
\end{note}
If the return type is deduced as \tcode{void},
the operator function is defined as deleted.

\pnum
The return value \tcode{V} of type \tcode{R}
of the defaulted three-way comparison operator function
with parameters \tcode{x} and \tcode{y} of the same type
is determined by comparing corresponding elements
\tcode{x}$_i$ and \tcode{y}$_i$
in the expanded lists of subobjects for \tcode{x} and \tcode{y}
until the first index $i$
where \tcode{x}$_i$ \tcode{<=>} \tcode{y}$_i$
yields a result value \tcode{v}$_i$ where \tcode{v}$_i$\tcode{ != 0},
contextually converted to \tcode{bool}, yields \tcode{true};
\tcode{V} is \tcode{v}$_i$ converted to \tcode{R}.
If no such index exists, \tcode{V} is
\tcode{std::strong_ordering::equal} converted to \tcode{R}.

\pnum
The \defn{common comparison type} \tcode{U}
of a possibly-empty list of $n$ types
\tcode{T}$_0$, \tcode{T}$_1$, $\cdots$, \tcode{T}$_{n-1}$
is defined as follows:

\begin{itemize}
\item
If any \tcode{T}$_i$
is not a comparison category type\iref{cmp.categories},
\tcode{U} is \tcode{void}.

\item
Otherwise, if
at least one \tcode{T}$_i$ is \tcode{std::weak_equality}, or
at least one \tcode{T}$_i$ is \tcode{std::strong_equality} and
at least one \tcode{T}$_j$ is \tcode{std::partial_ordering} or
                              \tcode{std::weak_ordering},
\tcode{U} is \tcode{std::weak_equality}\iref{cmp.weakeq}.

\item
Otherwise, if at least one \tcode{T}$_i$ is \tcode{std::strong_equality},
\tcode{U} is \tcode{std::strong_equality}\iref{cmp.strongeq}.

\item
Otherwise, if at least one \tcode{T}$_i$ is \tcode{std::partial_ordering},
\tcode{U} is \tcode{std::partial_ordering}\iref{cmp.partialord}.

\item
Otherwise, if at least one \tcode{T}$_i$ is \tcode{std::weak_ordering},
\tcode{U} is \tcode{std::weak_ordering}\iref{cmp.weakord}.

\item
Otherwise, \tcode{U} is \tcode{std::strong_ordering}\iref{cmp.strongord}.
\begin{note}
In particular, this is the result when $n$ is 0.
\end{note}
\end{itemize}

\rSec2[class.rel.eq]{Other comparison operators}
\indextext{operator!relational!defaulted}%
\indextext{operator!equality!defaulted}%
\indextext{operator!inequality!defaulted}%

\pnum
A defaulted relational\iref{expr.rel} or equality\iref{expr.eq} operator function
for some operator \tcode{@}
shall have a declared return type \tcode{bool}.

\pnum
The operator function with parameters \tcode{x} and \tcode{y}
is defined as deleted if

\begin{itemize}
\item
overload resolution\iref{over.match},
as applied to \tcode{x <=> y}
(also considering synthesized candidates with reversed order of parameters\iref{over.match.oper}),
results in an ambiguity
or a function that is deleted or inaccessible from the operator function,
or

\item
the operator \tcode{@}
cannot be applied to the return type of \tcode{x <=> y} or \tcode{y <=> x}.
\end{itemize}

Otherwise, the operator function yields
\tcode{x <=> y @ 0}
if an \tcode{operator<=>}
with the original order of parameters was selected, or
\tcode{0 @ y <=> x}
otherwise.

\pnum
\begin{example}
\begin{codeblock}
struct C {
  friend std::strong_equality operator<=>(const C&, const C&);
  friend bool operator==(const C& x, const C& y) = default; // OK, returns \tcode{x <=> y == 0}
  bool operator<(const C&) = default;                       // OK, function is deleted
};
\end{codeblock}
\end{example}
