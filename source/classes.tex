%!TEX root = std.tex
\rSec0[class]{Classes}%
\indextext{class|(}

%gram: \rSec1[gram.class]{Classes}
%gram:

\indextext{class!member function|see{member function, class}}

\pnum
\indextext{\idxcode{\{\}}!class declaration}%
\indextext{\idxcode{\{\}}!class definition}%
\indextext{type!class~and}%
\indextext{object~class|see{also~class~object}}%
A class is a type.
\indextext{name~class|see{class~name}}%
Its name becomes a \grammarterm{class-name}~(\ref{class.name}) within its
scope.

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    simple-template-id
\end{bnf}

\grammarterm{Class-specifier}{s} and
\grammarterm{elaborated-type-specifier}{s}~(\ref{dcl.type.elab}) are used to
make \grammarterm{class-name}{s}. An object of a class consists of a
(possibly empty) sequence of members and base class objects.

\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} member-specification\opt \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{class-head}\br
    class-key attribute-specifier-seq\opt class-head-name class-virt-specifier\opt base-clause\opt\br
    class-key attribute-specifier-seq\opt base-clause\opt
\end{bnf}

\begin{bnf}
\nontermdef{class-head-name}\br
    nested-name-specifier\opt class-name
\end{bnf}

\begin{bnf}
\nontermdef{class-virt-specifier}\br
    \terminal{final}
\end{bnf}

\begin{bnf}
\nontermdef{class-key}\br
    \terminal{class}\br
    \terminal{struct}\br
    \terminal{union}
\end{bnf}

A \grammarterm{class-specifier} whose
\grammarterm{class-head} omits the
\grammarterm{class-head-name} defines an unnamed class. \enternote An unnamed class thus can't
be \tcode{final}. \exitnote

\pnum
A \grammarterm{class-name} is inserted into the scope in which it is
declared immediately after the \grammarterm{class-name} is seen. The
\grammarterm{class-name} is also inserted into the scope of the class
itself; this is known as the \grammarterm{injected-class-name}.
\indextext{\idxgram{injected-class-name}}%
For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
\indextext{definition!class}%
A \grammarterm{class-specifier} is commonly referred to as a class
definition.
\indextext{definition!class}%
A class is considered defined after the closing brace of its
\grammarterm{class-specifier} has been seen even though its member
functions are in general not yet defined.
The optional \grammarterm{attribute-specifier-seq} appertains to the class; the attributes in
the \grammarterm{attribute-specifier-seq} are thereafter considered attributes of the class
whenever it is named.

\pnum
If a class is marked with the \grammarterm{class-virt-specifier} \tcode{final} and it appears
as a \grammarterm{base-type-specifier} in a \grammarterm{base-clause}
(Clause~\ref{class.derived}), the program is ill-formed. Whenever a
\grammarterm{class-key} is followed by a \grammarterm{class-head-name}, the
\grammarterm{identifier} \tcode{final}, and a colon or left brace, \tcode{final} is
interpreted as a \grammarterm{class-virt-specifier}. \enterexample
\begin{codeblock}
struct A;
struct A final {};      // OK: definition of \tcode{struct A},
                        // not value-initialization of variable \tcode{final}

struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B final : C{};  // OK: definition of nested class \tcode{B},
                        // not declaration of a bit-field member \tcode{final}
};
\end{codeblock}
\exitexample

\pnum
Complete objects and member subobjects of class type shall have nonzero
size.\footnote{Base class subobjects are not so constrained.}
\enternote
Class objects can be assigned, passed as arguments to functions, and
returned by functions (except objects of classes for which copying or moving has
been restricted; see~\ref{class.copy}). Other plausible operators, such
as equality comparison, can be defined by the user; see~\ref{over.oper}.
\exitnote

\pnum
\indextext{\idxcode{struct}!\tcode{class}~versus}%
\indextext{structure}%
\indextext{\idxcode{union}!\tcode{class}~versus}%
A \term{union} is a class defined with the \grammarterm{class-key}
\tcode{union};
\indextext{access control!\idxcode{union} default member}%
it holds at most one data member at a time~(\ref{class.union}).
\enternote
Aggregates of class type are described in~\ref{dcl.init.aggr}.
\exitnote

\indextext{class!trivial}%
\indextext{trivial~class}%
\pnum
A \defn{trivially copyable class} is a class that:

\begin{itemize}
\item has no non-trivial copy constructors~(\ref{class.copy}),
\item has no non-trivial move constructors~(\ref{class.copy}),
\item has no non-trivial copy assignment operators~(\ref{over.ass},~\ref{class.copy}),
\item has no non-trivial move assignment operators~(\ref{over.ass},~\ref{class.copy}), and
\item has a trivial destructor~(\ref{class.dtor}).
\end{itemize}

A \term{trivial class} is a class that has a default
constructor~(\ref{class.ctor}), has no non-trivial default constructors, and is trivially copyable.
\enternote In particular, a trivially copyable or trivial class does not have
virtual functions or virtual base classes.\exitnote

\indextext{class!standard-layout}%
\indextext{standard-layout~class}%
\pnum
A \grammarterm{standard-layout class} is a class that:

\begin{itemize}
\item has no non-static data members of type non-standard-layout class
(or array of such types) or reference,

\item has no virtual functions~(\ref{class.virtual}) and no
virtual base classes~(\ref{class.mi}),

\item has the same access control (Clause~\ref{class.access})
for all non-static data members,

\item has no non-standard-layout base classes,

\item either has no non-static data members in the most derived class
and at most one base class with non-static data members, or has no base
classes with non-static data members, and

\item has no base classes of the same type as the first non-static
data member.\footnote{This ensures that two subobjects that have the
same class type and that
belong to the same most derived object are not allocated at the same
address~(\ref{expr.eq}).}
\end{itemize}

\indextext{struct!standard-layout}%
\indextext{standard-layout~struct}%
\indextext{union!standard-layout}%
\indextext{standard-layout~union}%
\pnum
A \grammarterm{standard-layout struct} is a standard-layout class
defined with the \grammarterm{class-key} \tcode{struct} or the
\grammarterm{class-key} \tcode{class}.
A \grammarterm{standard-layout union} is a standard-layout class
defined with the
\grammarterm{class-key} \tcode{union}.

\pnum
\enternote Standard-layout classes are useful for communicating with
code written in other programming languages. Their layout is specified
in~\ref{class.mem}.\exitnote

\pnum
\indextext{POD struct}\indextext{POD class}\indextext{POD union}%
A \term{POD struct}\footnote{The acronym POD stands for ``plain old data''.}
is a non-union class that is both a trivial class and a
standard-layout class, and has no non-static data members of type non-POD struct,
non-POD union (or array of such types). Similarly, a
\term{POD union} is a union that is both a trivial class and a standard-layout
class, and has no non-static data members of type non-POD struct, non-POD
union (or array of such types). A \term{POD class} is a
class that is either a POD struct or a POD union.

\enterexample
\begin{codeblock}
struct N {          // neither trivial nor standard-layout
  int i;
  int j;
  virtual ~N();
};

struct T {          // trivial but not standard-layout
  int i;
private: 
  int j;
};

struct SL {         // standard-layout but not trivial
  int i;
  int j;
  ~SL();
};

struct POD {        // both trivial and standard-layout
  int i;
  int j;
};
\end{codeblock}
\exitexample

\pnum
If a \grammarterm{class-head-name} contains a \grammarterm{nested-name-specifier},
the \grammarterm{class-specifier} shall refer to a class that was
previously declared directly in the class or namespace to which the
\grammarterm{nested-name-specifier} refers,
or in an element of the inline namespace set~(\ref{namespace.def}) of that namespace
(i.e., not merely inherited or
introduced by a \grammarterm{using-declaration}), and the
\grammarterm{class-specifier} shall appear in a namespace enclosing the
previous declaration.
In such cases, the \grammarterm{nested-name-specifier} of the
\grammarterm{class-head-name} of the
definition shall not begin with a \grammarterm{decltype-specifier}.

\rSec1[class.name]{Class names}
\indextext{definition!class~name~as type}%
\indextext{structure~tag|see{class~name}}%
\indextext{equivalence!type}%

\pnum
A class definition introduces a new type.
\enterexample

\begin{codeblock}
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
\end{codeblock}

declares three variables of three different types. This implies that

\begin{codeblock}
a1 = a2;                        // error: \tcode{Y} assigned to \tcode{X}
a1 = a3;                        // error: \tcode{int} assigned to \tcode{X}
\end{codeblock}

are type mismatches, and that

\begin{codeblock}
int f(X);
int f(Y);
\end{codeblock}

\indextext{overloading}%
declare an overloaded (Clause~\ref{over}) function \tcode{f()} and not
simply a single function \tcode{f()} twice. For the same reason,

\begin{codeblock}
struct S { int a; };
struct S { int a; };            // error, double definition
\end{codeblock}

is ill-formed because it defines \tcode{S} twice.
\exitexample

\pnum
\indextext{definition!scope~of class}%
\indextext{class~name!scope~of}%
A class declaration introduces the class name into the scope where
\indextext{name~hiding!class definition}%
it is declared and hides any
class, variable, function, or other declaration of that name in an
enclosing scope~(\ref{basic.scope}). If a class name is declared in a
scope where a variable, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
\grammarterm{elaborated-type-specifier}~(\ref{basic.lookup.elab}).
\enterexample

\begin{codeblock}
struct stat {
  // ...
};

stat gstat;                     // use plain \tcode{stat} to
                                // define variable

int stat(struct stat*);         // redeclare \tcode{stat} as function

void f() {
  struct stat* ps;              // \tcode{struct} prefix needed
                                // to name \tcode{struct stat}
  stat(ps);                     // call \tcode{stat()}
}
\end{codeblock}
\exitexample
\indextext{class~name!elaborated}%
\indextext{declaration!forward class}%
A \grammarterm{declaration} consisting solely of \grammarterm{class-key
identifier;} is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
\enterexample

\begin{codeblock}
struct s { int a; };

void g() {
  struct s;                     // hide global \tcode{struct s}
                                // with a block-scope declaration
  s* p;                         // refer to local \tcode{struct s}
  struct s { char* p; };        // define local \tcode{struct s}
  struct s;                     // redeclaration, has no effect
}
\end{codeblock}
\exitexample
\enternote
Such declarations allow definition of classes that refer to each other.
\indextext{example!friend}%
\enterexample

\begin{codeblock}
class Vector;

class Matrix {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};

class Vector {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};
\end{codeblock}

Declaration of \tcode{friend}s is described in~\ref{class.friend},
operator functions in~\ref{over.oper}.
\exitexample
\exitnote

\pnum
\indextext{class~name!elaborated}%
\indextext{elaborated~type~specifier|see{class name, elaborated}}%
\enternote
An \grammarterm{elaborated-type-specifier}~(\ref{dcl.type.elab}) can also
be used as a \grammarterm{type-specifier} as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
\exitnote
\enterexample

\begin{codeblock}
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   // global \tcode{s}
  p->a = s;                     // parameter \tcode{s}
}
\end{codeblock}
\exitexample

\pnum
\indextext{class~name!point~of declaration}%
\enternote
The declaration of a class name takes effect immediately after the
\grammarterm{identifier} is seen in the class definition or
\grammarterm{elaborated-type-specifier}. For example,

\begin{codeblock}
class A * A;
\end{codeblock}

first specifies \tcode{A} to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form \tcode{class} \tcode{A} must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
\exitnote

\pnum
\indextext{class~name!\idxcode{typedef}}%
A \grammarterm{typedef-name}~(\ref{dcl.typedef}) that names a class type,
or a cv-qualified version thereof, is also a \grammarterm{class-name}. If a
\grammarterm{typedef-name} that names a cv-qualified class type is used
where a \grammarterm{class-name} is required, the cv-qualifiers are
ignored. A \grammarterm{typedef-name} shall not be used as the
\grammarterm{identifier} in a \grammarterm{class-head}.

\rSec1[class.mem]{Class members}%
\indextext{declaration!member}%
\indextext{data~member|see{member}}

\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration member-specification\opt\br
    access-specifier \terminal{:} member-specification\opt
\end{bnf}

\begin{bnf}
\nontermdef{member-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq\opt member-declarator-list\opt \terminal{;}\br
    function-definition\br
    using-declaration\br
    static_assert-declaration\br
    template-declaration\br
    alias-declaration\br
    empty-declaration
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator}\br
    declarator virt-specifier-seq\opt pure-specifier\opt\br
    declarator brace-or-equal-initializer\opt\br
    identifier\opt attribute-specifier-seq\opt \terminal{:} constant-expression
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier-seq}\br
    virt-specifier\br
    virt-specifier-seq virt-specifier
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier}\br
    \terminal{override}\br
    \terminal{final}
\end{bnf}

\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{= 0}
\end{bnf}

\pnum
\indextext{definition!class}%
The \grammarterm{member-specification} in a class definition declares the
full set of members of the class; no member can be added elsewhere.
Members of a class are data members, member
functions~(\ref{class.mfct}), nested types, and enumerators. Data
members and member functions are static or non-static;
see~\ref{class.static}. Nested types are
classes~(\ref{class.name},~\ref{class.nest}) and
enumerations~(\ref{dcl.enum}) defined in the class, and arbitrary types
declared as members by use of a typedef declaration~(\ref{dcl.typedef}).
The enumerators of an unscoped enumeration~(\ref{dcl.enum}) defined in the class
are members of the class. Except when used to declare
friends~(\ref{class.friend}), to declare an unnamed bit-field~(\ref{class.bit}),
or to introduce the name of a member of a
base class into a derived
class~(\ref{namespace.udecl}), or when the declaration is an
\grammarterm{empty-declaration},
\grammarterm{member-declaration}{s} declare members of the class, and each
such \grammarterm{member-declaration} shall declare at least one member
name of the class. A member shall not be declared twice in the
\grammarterm{member-specification}, except that a nested class or member
class template can be declared and then later defined, and except that an
enumeration can be introduced with an \grammarterm{opaque-enum-declaration} and later
redeclared with an \grammarterm{enum-specifier}{}.

\pnum
\indextext{completely~defined}%
A class is considered a completely-defined object
type~(\ref{basic.types}) (or complete type) at the closing \tcode{\}} of
the \grammarterm{class-specifier}.
Within the class
\grammarterm{member-specification}, the class is regarded as complete
within function bodies, default arguments,
\grammarterm{using-declaration}{s} introducing inheriting
constructors~(\ref{class.inhctor}),
\grammarterm{exception-specification}{s}, and
\grammarterm{brace-or-equal-initializer}{s} for non-static data members
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
\grammarterm{member-specification}.

\pnum
\enternote
A single name can denote several function members provided their types
are sufficiently different (Clause~\ref{over}).
\exitnote

\pnum
A \grammarterm{brace-or-equal-initializer} shall appear only in the
declaration of a data member. (For static data members,
see~\ref{class.static.data}; for non-static data members,
see~\ref{class.base.init}).

\pnum
A member shall not be declared with the \tcode{extern}
or \tcode{register}
\nonterminal{storage-class-specifier}. Within a class definition, a member shall not be declared with the \tcode{thread_local} \nonterminal{storage-class-specifier} unless also declared \tcode{static}.

\pnum
The \grammarterm{decl-specifier-seq} may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the \grammarterm{decl-specifier-seq}
shall contain a \grammarterm{type-specifier} that is not a \grammarterm{cv-qualifier}.
The
\grammarterm{member-declarator-list} can be omitted only after a
\grammarterm{class-specifier} or an \grammarterm{enum-specifier} or in a
\tcode{friend} declaration~(\ref{class.friend}). A
\grammarterm{pure-specifier} shall be used only in the declaration of a
virtual function~(\ref{class.virtual}).

\pnum
The optional \grammarterm{attribute-specifier-seq} in a \grammarterm{member-declaration}
appertains to each of the entities declared by the \grammarterm{member-declarator}{s};
it shall not appear if the optional \grammarterm{member-declarator-list} is omitted.

\pnum
A \grammarterm{virt-specifier-seq} shall contain at most one of each
\grammarterm{virt-specifier}.
A \grammarterm{virt-specifier-seq}
shall appear only in the declaration of a virtual member
function~(\ref{class.virtual}).

\pnum
\indextext{class~object!member}%
Non-\tcode{static}~(\ref{class.static}) data members shall not have
incomplete types. In particular, a class \tcode{C} shall not contain a
non-static member of class \tcode{C}, but it can contain a pointer or
reference to an object of class \tcode{C}.

\pnum
\enternote
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\exitnote

\pnum
\enternote
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
\exitnote

\pnum
\indextext{example!class~definition}%
\enterexample
A simple example of a class definition is

\begin{codeblock}
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
\end{codeblock}

which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration

\begin{codeblock}
tnode s, *sp;
\end{codeblock}

declares \tcode{s} to be a \tcode{tnode} and \tcode{sp} to be a pointer
to a \tcode{tnode}. With these declarations, \tcode{sp->count} refers to
the \tcode{count} member of the object to which \tcode{sp} points;
\tcode{s.left} refers to the \tcode{left} subtree pointer of the object
\tcode{s}; and \tcode{s.right->tword[0]} refers to the initial character
of the \tcode{tword} member of the \tcode{right} subtree of \tcode{s}.
\exitexample

\pnum
\indextext{layout!class~object}%
Nonstatic data members of a (non-union) class
with the same access control (Clause~\ref{class.access})
are allocated so that later
members have higher addresses within a class object.
\indextext{allocation!unspecified}%
The order of allocation of non-static data members
with different access control
is unspecified (Clause~\ref{class.access}).
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions~(\ref{class.virtual}) and
virtual base classes~(\ref{class.mi}).

\pnum
If \tcode{T} is the name of a class, then each of the following shall
have a name different from \tcode{T}:

\begin{itemize}
\item every static data member of class \tcode{T};

\item every member function of class \tcode{T}
\enternote
This restriction does not apply to constructors, which do not have
names~(\ref{class.ctor})
\exitnote;

\item every member of class \tcode{T} that is itself a type;

\item every enumerator of every member of class \tcode{T} that is an
unscoped enumerated type; and

\item every member of every anonymous union that is a member of class
\tcode{T}.
\end{itemize}

\pnum
In addition, if class \tcode{T} has a user-declared
constructor~(\ref{class.ctor}), every non-static data member of class
\tcode{T} shall have a name different from \tcode{T}.

\pnum
Two standard-layout struct (Clause~\ref{class}) types are \defn{layout-compatible} if they
have the same number of non-static data members and corresponding
non-static data members (in declaration order) have layout-compatible
types~(\ref{basic.types}).

\pnum
Two standard-layout union (Clause~\ref{class}) types are \defn{layout-compatible} if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types~(\ref{basic.types}).

\pnum
If a standard-layout union contains two or more
standard-layout structs that share a common
initial sequence, and if the standard-layout union object currently contains one of
these standard-layout structs, it is permitted to inspect the common initial part of
any of them. Two standard-layout structs share a common initial sequence if
corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.

\pnum
If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member. Otherwise, its
address is the same as the address of its first base class subobject (if any).
\enternote
There might therefore be unnamed padding within a standard-layout struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
\exitnote

\rSec1[class.mfct]{Member functions}%
\indextext{member function!class}

\pnum
Functions declared in the definition of a class, excluding those
declared with a \tcode{friend} specifier~(\ref{class.friend}), are
called member functions of that class. A member function may be declared
\tcode{static} in which case it is a \term{static} member function
of its class~(\ref{class.static}); otherwise it is a
\grammarterm{non-static} member function of its
class~(\ref{class.mfct.non-static},~\ref{class.this}).

\pnum
\indextext{member function!inline}%
\indextext{definition!member~function}%
A member function may be defined~(\ref{dcl.fct.def}) in its class
definition, in which case it is an \term{inline} member
function~(\ref{dcl.fct.spec}), or it may be defined outside of its class
definition if it has already been declared but not defined in its class
definition. A member function definition that appears outside of the
class definition shall appear in a namespace scope enclosing the class
definition. Except for member function definitions that appear outside
of a class definition, and except for explicit specializations of member
functions of class templates and member function
templates~(\ref{temp.spec}) appearing outside of the class definition, a
member function shall not be redeclared.

\pnum
An \tcode{inline} member function (whether static or non-static) may
also be defined outside of its class definition provided either its
declaration in the class definition or its definition outside of the
class definition declares the function as \tcode{inline}.
\enternote
Member functions of a class in namespace scope have external linkage.
Member functions of a local class~(\ref{class.local}) have no linkage.
See~\ref{basic.link}.
\exitnote

\pnum
There shall be at most one definition of a non-inline member function in
a program; no diagnostic is required. There may be more than one
\tcode{inline} member function definition in a program.
See~\ref{basic.def.odr} and~\ref{dcl.fct.spec}.

\pnum
\indextext{operator!scope~resolution}%
If the definition of a member function is lexically outside its class
definition, the member function name shall be qualified by its class
name using the \tcode{::} operator.
\enternote
A name used in a member function definition (that is, in the
\grammarterm{parameter-declaration-clause} including the default
arguments~(\ref{dcl.fct.default}) or in the member function body) is looked up
as described in~\ref{basic.lookup}.
\exitnote
\enterexample

\begin{codeblock}
struct X {
  typedef int T;
  static T count;
  void f(T);
};
void X::f(T t = count) { }
\end{codeblock}

The member function \tcode{f} of class \tcode{X} is defined in global
scope; the notation \tcode{X::f} specifies that the function \tcode{f}
is a member of class \tcode{X} and in the scope of class \tcode{X}. In
the function definition, the parameter type \tcode{T} refers to the
typedef member \tcode{T} declared in class \tcode{X} and the default
argument \tcode{count} refers to the static data member \tcode{count}
declared in class \tcode{X}.
\exitexample

\pnum
A \tcode{static} local variable in a member function always refers to
the same object, whether or not the member function is \tcode{inline}.

\pnum
Previously declared member functions may be mentioned in \tcode{friend} declarations.

\pnum
\indextext{local~class!member~function~in}%
Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.

\pnum
\enternote
A member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see~\ref{dcl.fct}. For example,

\begin{codeblock}
typedef void fv(void);
typedef void fvc(void) const;
struct S {
  fv memfunc1;      // equivalent to: \tcode{void memfunc1(void);}
  void memfunc2();
  fvc memfunc3;     // equivalent to: \tcode{void memfunc3(void) const;}
};
fv  S::* pmfv1 = &S::memfunc1;
fv  S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
\end{codeblock}

Also see~\ref{temp.arg}.
\exitnote

\rSec2[class.mfct.non-static]{Nonstatic member functions}%
\indextext{member function!nonstatic}

\pnum
A \grammarterm{non-static} member function may be called for an object of
its class type, or for an object of a class derived
(Clause~\ref{class.derived}) from its class type, using the class member
access syntax~(\ref{expr.ref},~\ref{over.match.call}). A non-static
member function may also be called directly using the function call
syntax~(\ref{expr.call},~\ref{over.match.call}) from within
the body of a member function of its class or of a class derived from
its class.

\pnum
\indextext{member function!call undefined}%
If a non-static member function of a class \tcode{X} is called for an
object that is not of type \tcode{X}, or of a type derived from
\tcode{X}, the behavior is undefined.

\pnum
When an \grammarterm{id-expression}~(\ref{expr.prim}) that is not part of a
class member access syntax~(\ref{expr.ref}) and not used to form a
pointer to member~(\ref{expr.unary.op}) is used in
a member of class \tcode{X} in a context where \tcode{this} can be
used~(\ref{expr.prim.general}),
if name
lookup~(\ref{basic.lookup}) resolves the name in the
\grammarterm{id-expression} to a non-static non-type member of some class
\tcode{C},
and if either the \grammarterm{id-expression} is potentially evaluated or
\tcode{C} is \tcode{X} or a base class of \tcode{X},
the \grammarterm{id-expression} is transformed into a class
member access expression~(\ref{expr.ref}) using
\tcode{(*this)}~(\ref{class.this}) as the \grammarterm{postfix-expression}
to the left of the \tcode{.} operator.
\enternote
If \tcode{C} is not \tcode{X} or a base class of \tcode{X}, the class
member access expression is ill-formed.
\exitnote
Similarly during name lookup, when an
\grammarterm{unqualified-id}~(\ref{expr.prim}) used in the definition of a
member function for class \tcode{X} resolves to a \tcode{static} member,
an enumerator or a nested type of class \tcode{X} or of a base class of
\tcode{X}, the \grammarterm{unqualified-id} is transformed into a
\grammarterm{qualified-id}~(\ref{expr.prim}) in which the
\grammarterm{nested-name-specifier} names the class of the member function.
\indextext{example!member~function}%
\enterexample

\begin{codeblock}
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
  void set(const char*, tnode* l, tnode* r);
};

void tnode::set(const char* w, tnode* l, tnode* r) {
  count = strlen(w)+1;
  if (sizeof(tword)<=count)
      perror("tnode string too long");
  strcpy(tword,w);
  left = l;
  right = r;
}

void f(tnode n1, tnode n2) {
  n1.set("abc",&n2,0);
  n2.set("def",0,0);
}
\end{codeblock}

In the body of the member function \tcode{tnode::set}, the member names
\tcode{tword}, \tcode{count}, \tcode{left}, and \tcode{right} refer to
members of the object for which the function is called. Thus, in the
call \tcode{n1.set("abc",\&n2,0)}, \tcode{tword} refers to
\tcode{n1.tword}, and in the call \tcode{n2.set("def",0,0)}, it refers
to \tcode{n2.tword}. The functions \tcode{strlen}, \tcode{perror}, and
\tcode{strcpy} are not members of the class \tcode{tnode} and should be
declared elsewhere.\footnote{See, for example, \tcode{<cstring>}~(\ref{c.strings}).}
\exitexample

\pnum
A non-static member function may be declared \tcode{const},
\tcode{volatile}, or \tcode{const} \tcode{volatile}. These
\grammarterm{cv-qualifiers} affect the type of the \tcode{this}
pointer~(\ref{class.this}). They also affect the function
type~(\ref{dcl.fct}) of the member function; a member function declared
\tcode{const} is a \term{const} member function, a member function
declared \tcode{volatile} is a \term{volatile} member function and a
member function declared \tcode{const} \tcode{volatile} is a
\term{const volatile} member function.
\enterexample

\begin{codeblock}
struct X {
  void g() const;
  void h() const volatile;
};
\end{codeblock}

\tcode{X::g} is a \tcode{const} member function and \tcode{X::h} is a
\tcode{const} \tcode{volatile} member function.
\exitexample

\pnum
A non-static member function may be declared with a \grammarterm{ref-qualifier}~(\ref{dcl.fct}); see~\ref{over.match.funcs}.

\pnum
A non-static member function may be declared
\term{virtual}~(\ref{class.virtual}) or \term{pure virtual}~(\ref{class.abstract}).

\rSec2[class.this]{The \tcode{this} pointer}%
\indextext{\idxcode{this}}
\indextext{member function!\idxcode{this}}

\pnum
\indextext{this pointer@\tcode{this}~pointer|see{\tcode{this}}}%
In the body of a non-static~(\ref{class.mfct}) member function, the
keyword \tcode{this} is a prvalue expression whose value is the
address of the object for which the function is called.
\indextext{\idxcode{this}!type~of}%
The type of \tcode{this} in a member function of a class \tcode{X} is
\tcode{X*}.
\indextext{member function!\idxcode{const}}%
If the member function is declared \tcode{const}, the type of
\tcode{this} is \tcode{const} \tcode{X*},
\indextext{member function!\idxcode{volatile}}%
if the member function is declared \tcode{volatile}, the type of
\tcode{this} is \tcode{volatile} \tcode{X*}, and if the member function
is declared \tcode{const} \tcode{volatile}, the type of \tcode{this} is
\tcode{const} \tcode{volatile} \tcode{X*}.
\indextext{member function!\idxcode{const}}%
\enternote thus in a \tcode{const} member function, the object for which the function is
called is accessed through a \tcode{const} access path. \exitnote
\enterexample

\begin{codeblock}
struct s {
  int a;
  int f() const;
  int g() { return a++; }
  int h() const { return a++; } // error
};

int s::f() const { return a; }
\end{codeblock}

The \tcode{a++} in the body of \tcode{s::h} is ill-formed because it
tries to modify (a part of) the object for which \tcode{s::h()} is
called. This is not allowed in a \tcode{const} member function because
\tcode{this} is a pointer to \tcode{const}; that is, \tcode{*this} has
\tcode{const} type.
\exitexample

\pnum
Similarly, \tcode{volatile} semantics~(\ref{dcl.type.cv}) apply in
\tcode{volatile} member functions when accessing the object and its
non-static data members.

\pnum
A \grammarterm{cv-qualified} member function can be called on an
object-expression~(\ref{expr.ref}) only if the object-expression is as
cv-qualified or less-cv-qualified than the member function.
\enterexample

\begin{codeblock}
void k(s& x, const s& y) {
  x.f();
  x.g();
  y.f();
  y.g();                        // error
}
\end{codeblock}

The call \tcode{y.g()} is ill-formed because \tcode{y} is \tcode{const}
and \tcode{s::g()} is a non-\tcode{const} member function, that is,
\tcode{s::g()} is less-qualified than the object-expression \tcode{y}.
\exitexample

\pnum
\indextext{\idxcode{const}!constructor~and}%
\indextext{\idxcode{const}!destructor~and}%
\indextext{\idxcode{volatile}!constructor~and}%
\indextext{\idxcode{volatile}!destructor~and}%
Constructors~(\ref{class.ctor}) and destructors~(\ref{class.dtor}) shall
not be declared \tcode{const}, \tcode{volatile} or \tcode{const}
\tcode{volatile}. \enternote However, these functions can be invoked to
create and destroy objects with cv-qualified types,
see~(\ref{class.ctor}) and~(\ref{class.dtor}).
\exitnote

\rSec1[class.static]{Static members}%
\indextext{member!static}%
\indextext{member function!static}%

\pnum
A data or function member of a class may be declared \tcode{static} in a
class definition, in which case it is a \term{static member} of the class.

\pnum
A \tcode{static} member \tcode{s} of class \tcode{X} may be referred to
using the \grammarterm{qualified-id} expression \tcode{X::s}; it is not
necessary to use the class member access syntax~(\ref{expr.ref}) to
refer to a \tcode{static} member. A \tcode{static} member may be
referred to using the class member access syntax, in which case the
object expression is evaluated.
\enterexample

\begin{codeblock}
struct process {
  static void reschedule();
};
process& g();

void f() {
  process::reschedule();        // OK: no object necessary
  g().reschedule();             // \tcode{g()} is called
}
\end{codeblock}
\exitexample

\pnum
A \tcode{static} member may be referred to directly in the scope of its
class or in the scope of a class derived (Clause~\ref{class.derived})
from its class; in this case, the \tcode{static} member is referred to
as if a \grammarterm{qualified-id} expression was used, with the
\grammarterm{nested-name-specifier} of the \grammarterm{qualified-id} naming
the class scope from which the static member is referenced.
\enterexample

\begin{codeblock}
int g();
struct X {
  static int g();
};
struct Y : X {
  static int i;
};
int Y::i = g();                 // equivalent to \tcode{Y::g();}
\end{codeblock}
\exitexample

\pnum
If an \grammarterm{unqualified-id}~(\ref{expr.prim}) is used in the
definition of a \tcode{static} member following the member's
\grammarterm{declarator-id}, and name lookup~(\ref{basic.lookup.unqual})
finds that the \grammarterm{unqualified-id} refers to a \tcode{static}
member, enumerator, or nested type of the member's class (or of a base
class of the member's class), the \grammarterm{unqualified-id} is
transformed into a \grammarterm{qualified-id} expression in which the
\grammarterm{nested-name-specifier} names the class scope from which the
member is referenced.
\enternote
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\exitnote


\pnum
Static members obey the usual class member access rules
(Clause~\ref{class.access}). When used in the declaration of a class
member, the \tcode{static} specifier shall only be used in the member
declarations that appear within the \grammarterm{member-specification} of
the class definition.
\enternote
It cannot be specified in member declarations that appear in namespace scope.
\exitnote

\rSec2[class.static.mfct]{Static member functions}
\indextext{member function!static}%

\pnum
\enternote
The rules described in~\ref{class.mfct} apply to \tcode{static} member
functions.
\exitnote

\pnum
\enternote
A \tcode{static} member function does not have a \tcode{this}
pointer~(\ref{class.this}).
\exitnote
A \tcode{static} member function shall not be \tcode{virtual}. There
shall not be a \tcode{static} and a non-static member function with the
same name and the same parameter types~(\ref{over.load}). A
\tcode{static} member function shall not be declared \tcode{const},
\tcode{volatile}, or \tcode{const volatile}.

\rSec2[class.static.data]{Static data members}
\indextext{member~data!static}%

\pnum
A \tcode{static} data member is not part of the subobjects of a class. If a
\tcode{static} data member is declared \tcode{thread_local} there is one copy of
the member per thread. If a \tcode{static} data member is not declared
\tcode{thread_local} there is one copy of the data member that is shared by all
the objects of the class.

\pnum
\indextext{initialization!static member}%
\indextext{definition!static member}%
The declaration of a \tcode{static} data member in its class definition
is not a definition and may be of an incomplete type other than
cv-qualified \tcode{void}. The definition for a \tcode{static} data
member shall appear in a namespace scope enclosing the member's class
definition.
\indextext{operator~use!scope~resolution}%
In the definition at namespace scope, the name of the \tcode{static}
data member shall be qualified by its class name using the \tcode{::}
operator. The \grammarterm{initializer} expression in the definition of a
\tcode{static} data member is in the scope of its
class~(\ref{basic.scope.class}).
\indextext{example!static@\tcode{static} member}%
\enterexample

\begin{codeblock}
class process {
  static process* run_chain;
  static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
\end{codeblock}

The \tcode{static} data member \tcode{run_chain} of class
\tcode{process} is defined in global scope; the notation
\tcode{process\colcol{}run_chain} specifies that the member \tcode{run_chain}
is a member of class \tcode{process} and in the scope of class
\tcode{process}. In the \tcode{static} data member definition, the
\grammarterm{initializer} expression refers to the \tcode{static} data
member \tcode{running} of class \tcode{process}.
\exitexample

\enternote
Once the \tcode{static} data member has been defined, it exists even if
no objects of its class have been created.
\enterexample
in the example above, \tcode{run_chain} and \tcode{running} exist even
if no objects of class \tcode{process} are created by the program.
\exitexample
\exitnote

\pnum
If a non-volatile \tcode{const} \tcode{static} data member is
of integral or enumeration type,
its declaration in the class definition can specify a
\grammarterm{brace-or-equal-initializer} in which every
\grammarterm{initializer-clause} that is an \grammarterm{assignment-expression}
is a constant expression~(\ref{expr.const}). A \tcode{static} data member of
literal type can be declared in the class definition with the
\tcode{constexpr} specifier; if so, its declaration shall specify a
\grammarterm{brace-or-equal-initializer} in which every
\grammarterm{initializer-clause} that is an \grammarterm{assignment-expression}
is a constant expression. \enternote In both these cases,
the member may appear in constant expressions. \exitnote The
member shall still be defined in a namespace scope if
it is odr-used~(\ref{basic.def.odr}) in the program and the
namespace scope definition shall not contain an \grammarterm{initializer}.

\pnum
\enternote
There shall be exactly one definition of a \tcode{static} data member
that is odr-used~(\ref{basic.def.odr}) in a program; no diagnostic is required.
\exitnote
Unnamed classes and classes contained directly
or indirectly within unnamed classes shall not contain \tcode{static}
data members.

\pnum
\indextext{restriction!static@\tcode{static} member local~class}%
\tcode{Static} data members of a class in namespace scope have external
linkage~(\ref{basic.link}). A local class shall not have \tcode{static}
data members.

\pnum
\tcode{Static} data members are initialized and destroyed exactly like
non-local variables~(\ref{basic.start.init},~\ref{basic.start.term}).

\pnum
A \tcode{static} data member shall not be
\tcode{mutable}~(\ref{dcl.stc}).

\rSec1[class.union]{Unions}%
\indextext{\idxcode{union}}

\pnum
In a union, at most one of the non-static data members can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. \enternote One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence~(\ref{class.mem}), and if an object of this
standard-layout union type contains one of the standard-layout structs, it is permitted
to inspect the common initial sequence of any of standard-layout struct members;
see~\ref{class.mem}. \exitnote The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct. All non-static data members of a
union object have the same address.

\pnum
\indextext{member function!\idxcode{union}}%
\indextext{constructor!\idxcode{union}}%
\indextext{destructor!\idxcode{union}}%
A union can have member functions (including constructors and destructors),
\indextext{restriction!\idxcode{union}}%
but not virtual~(\ref{class.virtual}) functions. A union shall not have
base classes. A union shall not be used as a base class.
\indextext{restriction!\idxcode{union}}%
If a union contains a non-static data member of
reference type the program is ill-formed.
\enternote If any non-static data member of a union has a non-trivial
default constructor~(\ref{class.ctor}),
copy constructor~(\ref{class.copy}),
move constructor~(\ref{class.copy}),
copy assignment operator~(\ref{class.copy}),
move assignment operator~(\ref{class.copy}),
or destructor~(\ref{class.dtor}), the corresponding member function
of the union must be user-provided or it will
be implicitly deleted~(\ref{dcl.fct.def.delete}) for the union. \exitnote

\pnum
\enterexample Consider the following union:

\begin{codeblock}
union U {
  int i;
  float f;
  std::string s;
};
\end{codeblock}

Since \tcode{std::string}~(\ref{string.classes}) declares non-trivial versions of all of the special
member functions, \tcode{U} will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use \tcode{U}, some or all of these member functions
must be user-provided.\exitexample

\pnum
\enternote In general, one must use explicit destructor calls and placement
new operators to change the active member of a union. \exitnote
\enterexample
Consider an object \tcode{u} of a \tcode{union} type \tcode{U} having non-static data members
\tcode{m} of type \tcode{M} and \tcode{n} of type \tcode{N}. If \tcode{M} has a non-trivial
destructor and \tcode{N} has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of \tcode{u} can be safely switched from \tcode{m} to
\tcode{n} using the destructor and placement new operator as follows:

\begin{codeblock}
u.m.~M();
new (&u.n) N;
\end{codeblock}
\exitexample

\pnum
\indextext{\idxcode{union}!anonymous}%
A union of the form

\begin{ncbnftab}
\terminal{union} \terminal{\{} member-specification \terminal{\}} \terminal{;}
\end{ncbnftab}

is called an \defn{anonymous union}; it defines an unnamed object of unnamed
type. The \grammarterm{member-specification} of an anonymous union shall
only define non-static data members.
\enternote
Nested types, anonymous unions, and functions cannot be declared within an anonymous
union.
\exitnote
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
\indextext{initialization!\idxcode{union}}%
\enterexample

\begin{codeblock}
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
\end{codeblock}

Here \tcode{a} and \tcode{p} are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
\exitexample

\pnum
\indextext{\idxcode{union}!global anonymous}%
\indextext{scope!anonymous \tcode{union}~at namespace}%
Anonymous unions declared in a named namespace or in the global
namespace shall be declared \tcode{static}. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
\indextext{access~control!anonymous \tcode{union}}%
\indextext{restriction!anonymous \tcode{union}}%
An anonymous union shall not have \tcode{private} or \tcode{protected}
members (Clause~\ref{class.access}). An anonymous union shall not have
function members.

\pnum
A union for which objects, pointers, or references are declared is not an anonymous union.
\enterexample

\begin{codeblock}
void f() {
  union { int aa; char* p; } obj, *ptr = &obj;
  aa = 1;                         // error
  ptr->aa = 1;                    // OK
}
\end{codeblock}

The assignment to plain \tcode{aa} is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
\exitexample
\enternote
Initialization of unions with no user-declared constructors is described
in~(\ref{dcl.init.aggr}).
\exitnote

\pnum
A \term{union-like class} is a union or a class that has an anonymous union as a direct
member. A union-like class \tcode{X} has a set of \term{variant members}.
If \tcode{X} is a union, a non-static data member of \tcode{X} that is not an anonymous
union is a variant member of \tcode{X}. In addition, a non-static data member of an
anonymous union that is a member of \tcode{X} is also a variant member of \tcode{X}.
At most one variant member of a union may have a \grammarterm{brace-or-equal-initializer}.
\enterexample

\begin{codeblock}
union U {
  int x = 0;
  union { };
  union {
    int z;
    int y = 1; // error: initialization for second variant member of \tcode{U}
  };
};
\end{codeblock}

\exitexample

\rSec1[class.bit]{Bit-fields}%
\indextext{bit-field}

\pnum
A \grammarterm{member-declarator} of the form

\begin{ncbnftab}
identifier\opt  attribute-specifier-seq\opt \terminal{:} constant-expression
\end{ncbnftab}

\indextext{\idxcode{:}!field declaration}%
\indextext{declaration!bit-field}%
specifies a bit-field;
its length is set off from the bit-field name by a colon. The optional \grammarterm{attribute-specifier-seq} appertains to the entity being declared. The bit-field
attribute is not part of the type of the class member. The
\grammarterm{constant-expression} shall be an integral constant expression
with a value greater than or equal to zero. The
value of the integral constant expression may
be larger than the number of bits in the object
representation~(\ref{basic.types}) of the bit-field's type; in such
cases the extra bits are used as padding bits and do not participate in
the value representation~(\ref{basic.types}) of the bit-field.
\indextext{allocation!implementation~defined bit-field}%
Allocation of bit-fields within a class object is
\impldef{allocation of bit-fields within a class object}.
\indextext{bit-field!implementation~defined alignment~of}%
Alignment of bit-fields is \impldef{alignment of bit-fields within a class object}.
\indextext{layout!bit-field}%
Bit-fields are packed into some addressable allocation unit.
\enternote
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
\exitnote

\pnum
\indextext{bit-field!unnamed}%
A declaration for a bit-field that omits the \grammarterm{identifier}
declares an \grammarterm{unnamed} bit-field. Unnamed bit-fields are not
members and cannot be initialized.
\enternote
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
\exitnote
\indextext{bit-field!zero~width~of}%
\indextext{bit-field!alignment~of}%
As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the value of the
\grammarterm{constant-expression} be equal to zero.

\pnum
\indextext{bit-field!type~of}%
A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type~(\ref{basic.fundamental}).
\indextext{Boolean}%
A \tcode{bool} value can successfully be stored in a bit-field of any
nonzero size.
\indextext{bit-field!address~of}%
The address-of operator \tcode{\&} shall not be applied to a bit-field,
so there are no pointers to bit-fields.
\indextext{restriction!bit-field}%
\indextext{restriction!address~of bit-field}%
\indextext{restriction!pointer~to bit-field}%
A non-const reference shall not be bound to a
bit-field~(\ref{dcl.init.ref}).
\enternote
If the initializer for a reference of type \tcode{const} \tcode{T\&} is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See~\ref{dcl.init.ref}.
\exitnote

\pnum
If the value \tcode{true} or \tcode{false} is stored into a bit-field of
type \tcode{bool} of any size (including a one bit bit-field), the
original \tcode{bool} value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type~(\ref{dcl.enum}),
the original enumerator value and the value of the bit-field shall
compare equal.
\enterexample

\begin{codeblock}
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              // yields \tcode{true}
    { /* ... */ }
}
\end{codeblock}
\exitexample

\rSec1[class.nest]{Nested class declarations}%
\indextext{definition!nested~class}%
\indextext{class~local|see{local~class}}%
\indextext{class~nested|see{nested~class}}

\pnum
A class can be declared within another class. A class declared within
another is called a \grammarterm{nested} class. The name of a nested class
is local to its enclosing class.
\indextext{nested~class!scope~of}%
The nested class is in the scope of its enclosing class.
\enternote
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\exitnote

\indextext{example!nested~class}%
\enterexample

\begin{codeblock}
int x;
int y;

struct enclose {
  int x;
  static int s;

  struct inner {
    void f(int i) {
      int a = sizeof(x);        // OK: operand of sizeof is an unevaluated operand
      x = i;                    // error: assign to \tcode{enclose::x}
      s = i;                    // OK: assign to \tcode{enclose::s}
      ::x = i;                  // OK: assign to global \tcode{x}
      y = i;                    // OK: assign to global \tcode{y}
    }
    void g(enclose* p, int i) {
      p->x = i;                 // OK: assign to \tcode{enclose::x}
    }
  };
};

inner* p = 0;                   // error: \tcode{inner} not in scope
\end{codeblock}
\exitexample

\pnum
Member functions and static data members of a nested class can be
defined in a namespace scope enclosing the definition of their class.
\indextext{example!nested~class definition}%
\enterexample

\begin{codeblock}
struct enclose {
  struct inner {
    static int x;
    void f(int i);
  };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { /* ... */ }
\end{codeblock}
\exitexample

\pnum
If class \tcode{X} is defined in a namespace scope, a nested class
\tcode{Y} may be declared in class \tcode{X} and later defined in the
definition of class \tcode{X} or be later defined in a namespace scope
enclosing the definition of class \tcode{X}.
\indextext{example!nested~class forward~declaration}%
\enterexample

\begin{codeblock}
class E {
  class I1;                     // forward declaration of nested class
  class I2;
  class I1 { };                 // definition of nested class
};
class E::I2 { };                // definition of nested class
\end{codeblock}
\exitexample

\pnum
\indextext{friend~function!nested~class}%
Like a member function, a friend function~(\ref{class.friend}) defined
within a nested class is in the lexical scope of that class; it obeys
the same rules for name binding as a static member function of that
class~(\ref{class.static}), but it has no special access rights to
members of an enclosing class.

\rSec1[class.local]{Local class declarations}
\indextext{declaration!local~class}%
\indextext{definition!local~class}%

\pnum
A class can be declared within a function definition; such a class is
called a \grammarterm{local} class. The name of a local class is local to
its enclosing scope.
\indextext{local~class!scope~of}%
The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function.
Declarations in a local class
shall not odr-use~(\ref{basic.def.odr}) a variable with automatic storage
duration from an
enclosing scope.
\enterexample
\indextext{example!local~class}%
\begin{codeblock}
int x;
void f() {
  static int s ;
  int x;
  const int N = 5;
  extern int q();

  struct local {
    int g() { return x; }       // error: odr-use of automatic variable \tcode{x}
    int h() { return s; }       // OK
    int k() { return ::x; }     // OK
    int l() { return q(); }     // OK
    int m() { return N; }       // OK: not an odr-use
    int* n() { return &N; }     // error: odr-use of automatic variable \tcode{N}
  };
}

local* p = 0;                   // error: \tcode{local} not in scope
\end{codeblock}
\exitexample

\pnum
An enclosing function has no special access to members of the local
class; it obeys the usual access rules (Clause~\ref{class.access}).
\indextext{member function!local~class}%
Member functions of a local class shall be defined within their class
definition, if they are defined at all.

\pnum
\indextext{nested~class!local~class}%
If class \tcode{X} is a local class a nested class \tcode{Y} may be
declared in class \tcode{X} and later defined in the definition of class
\tcode{X} or be later defined in the same scope as the definition of
class \tcode{X}.
\indextext{restriction!local~class}%
A class nested within
a local class is a local class.

\pnum
A local class shall not have static data members.

\rSec1[class.nested.type]{Nested type names}
\indextext{type~name!nested}%
\indextext{type~name!nested!scope of}%

\pnum
Type names obey exactly the same scope rules as other names. In
particular, type names defined within a class definition cannot be used
outside their class without qualification.
\enterexample

\indextext{example!nested type~name}%
\begin{codeblock}
struct X {
  typedef int I;
  class Y { /* ... */ };
  I a;
};

I b;                            // error
Y c;                            // error
X::Y d;                         // OK
X::I e;                         // OK
\end{codeblock}
\exitexample%
\indextext{class|)}
