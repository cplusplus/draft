%!TEX root = std.tex
\rSec0[class]{Classes}%
\indextext{class|(}

\gramSec[gram.class]{Classes}

\indextext{class!member function|see{member function, class}}

\rSec1[class.pre]{Preamble}

\pnum
\indextext{\idxcode{\{\}}!class declaration}%
\indextext{\idxcode{\{\}}!class definition}%
\indextext{type!class and}%
\indextext{object class|see{class object}}%
A class is a type.
\indextext{name class|see{class name}}%
Its name becomes a \grammarterm{class-name}\iref{class.name} within its
scope.

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    simple-template-id
\end{bnf}

A \grammarterm{class-specifier} or
an \grammarterm{elaborated-type-specifier}\iref{dcl.type.elab} is used to
make a \grammarterm{class-name}. An object of a class consists of a
(possibly empty) sequence of members and base class objects.

\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} \opt{member-specification} \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{class-head}\br
    class-key \opt{attribute-specifier-seq} class-head-name \opt{class-property-specifier-seq} \opt{base-clause}\br
    class-key \opt{attribute-specifier-seq} \opt{base-clause}
\end{bnf}

\begin{bnf}
\nontermdef{class-head-name}\br
    \opt{nested-name-specifier} class-name
\end{bnf}

\begin{bnf}
\nontermdef{class-property-specifier-seq}\br
    class-property-specifier \opt{class-property-specifier-seq}
\end{bnf}

\begin{bnf}
\nontermdef{class-property-specifier}\br
    \keyword{final}\br
    \keyword{trivially_relocatable_if_eligible}\br
    \keyword{replaceable_if_eligible}
\end{bnf}

\begin{bnf}
\nontermdef{class-key}\br
    \keyword{class}\br
    \keyword{struct}\br
    \keyword{union}
\end{bnf}

A class declaration where the \grammarterm{class-name}
in the \grammarterm{class-head-name} is a \grammarterm{simple-template-id}
shall be an explicit specialization\iref{temp.expl.spec} or
a partial specialization\iref{temp.spec.partial}.
A \grammarterm{class-specifier} whose
\grammarterm{class-head} omits the
\grammarterm{class-head-name} defines an \defnadj{unnamed}{class}.
\begin{note}
An unnamed class thus can't
be \tcode{final}.
\end{note}
Otherwise, the \grammarterm{class-name} is an \grammarterm{identifier};
it is not looked up, and the \grammarterm{class-specifier} introduces it.

\pnum
\indextext{component name}%
The component name of the
\grammarterm{class-name} is also bound in the scope of the class (template)
itself; this is known as the \defn{injected-class-name}.
For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
A \grammarterm{class-specifier} is commonly referred to as a \defnx{class
definition}{definition!class}.
A class is considered defined after the closing brace of its
\grammarterm{class-specifier} has been seen even though its member
functions are in general not yet defined.
The optional \grammarterm{attribute-specifier-seq} appertains to the class; the attributes in
the \grammarterm{attribute-specifier-seq} are thereafter considered attributes of the class
whenever it is named.

\pnum
If a \grammarterm{class-head-name} contains a \grammarterm{nested-name-specifier},
the \grammarterm{class-specifier} shall not inhabit a class scope.
If its \grammarterm{class-name} is an \grammarterm{identifier},
the \grammarterm{class-specifier} shall correspond to
one or more declarations nominable in
the class, class template, or namespace to which the
\grammarterm{nested-name-specifier} refers;
they shall all have the same target scope, and the target scope of the
\grammarterm{class-specifier} is that scope.
\begin{example}
\begin{codeblock}
namespace N {
  template<class>
  struct A {
    struct B;
  };
}
using N::A;
template<class T> struct A<T>::B {};    // OK
template<> struct A<void> {};           // OK
\end{codeblock}
\end{example}

\pnum
\begin{note}
The \grammarterm{class-key} determines
whether the class is a union\iref{class.union} and
whether access is public or private by default\iref{class.access}.
A union holds the value of at most one data member at a time.
\end{note}

\pnum
Each \grammarterm{class-property-specifier} shall appear at most once
within a single \grammarterm{class-property-specifier-seq}.
Whenever a \grammarterm{class-key} is followed
by a \grammarterm{class-head-name},
the identifier \tcode{final}, \tcode{trivially_relocatable_if_eligible},
or \tcode{replaceable_if_eligible}, and a colon or left brace,
the identifier is interpreted as a \grammarterm{class-property-specifier}.
\begin{example}
\begin{codeblock}
struct A;
struct A final {};      // OK, definition of \tcode{struct A},
                        // not value-initialization of variable \tcode{final}

struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B trivially_relocatable_if_eligible : C{};
                        // OK, definition of nested class \tcode{B},
                        // not declaration of a bit-field member
                        // \tcode{trivially_relocatable_if_eligible}
};
\end{codeblock}
\end{example}

\pnum
If a class is marked with the \grammarterm{class-property-specifier}
\tcode{final} and that class appears as a \grammarterm{class-or-decltype}
in a \grammarterm{base-clause}\iref{class.derived}, the program is ill-formed.

\pnum
\begin{note}
Complete objects of class type have nonzero size.
Base class subobjects and
members declared with the \tcode{no_unique_address} attribute\iref{dcl.attr.nouniqueaddr}
are not so constrained.
\end{note}

\pnum
\begin{note}
Class objects can be assigned\iref{over.assign,class.copy.assign},
passed as arguments to functions\iref{dcl.init,class.copy.ctor}, and
returned by functions (except objects of classes for which copying or moving has
been restricted; see~\ref{dcl.fct.def.delete} and \ref{class.access}).
Other plausible operators, such as equality comparison,
can be defined by the user; see~\ref{over.oper}.
\end{note}

\rSec1[class.prop]{Properties of classes}

\pnum
A \defnadj{trivially copyable}{class} is a class:
\begin{itemize}
\item that has at least one eligible
copy constructor, move constructor,
copy assignment operator, or
move assignment operator\iref{special,class.copy.ctor,class.copy.assign},
\item where each eligible copy constructor, move constructor, copy assignment operator,
and move assignment operator is trivial, and
\item that has a trivial, non-deleted destructor\iref{class.dtor}.
\end{itemize}

\pnum
A class \tcode{C} is \defn{default-movable} if

\begin{itemize}
\item overload resolution for direct-initializing an object of type \tcode{C}
from an xvalue of type \tcode{C} selects a constructor that is a direct member
of \tcode{C} and is neither user-provided nor deleted,

\item overload resolution for assigning to an lvalue of type \tcode{C} from an
xvalue of type \tcode{C} selects an assignment operator function that is a
direct member of \tcode{C} and is neither user-provided nor deleted, and

\item \tcode{C} has a destructor that is neither user-provided nor deleted.
\end{itemize}

\pnum
A class is \defn{eligible for trivial relocation} unless it
\begin{itemize}
\item has any virtual base classes,
\item has a base class that is not a trivially relocatable class,
\item has a non-static data member of an object type that is not of a
trivially relocatable type, or

\item has a deleted destructor,
\end{itemize}
except that it is \impldef{whether an otherwise-eligible union having one or
more subobjects of polymorphic class type is eligible for trivial relocation}
whether an otherwise-eligible union having one or more subobjects of
polymorphic class type is eligible for trivial relocation.

\pnum
A class \tcode{C} is a \defnadj{trivially relocatable}{class}
if it is eligible for trivial relocation and
\begin{itemize}
\item has the \tcode{trivially_relocatable_if_eligible} \grammarterm{class-property-specifier},
\item is a union with no user-declared special member functions, or
\item is default-movable.
\end{itemize}

\pnum
\begin{note}
A class with const-qualified or reference non-static data members can be
trivially relocatable.
\end{note}

\pnum
A class \tcode{C} is \defn{eligible for replacement} unless
\begin{itemize}
\item it has a base class that is not a replaceable class,
\item it has a non-static data member that is not of a replaceable type,
\item overload resolution fails or selects a deleted constructor when
direct-initializing an object of type \tcode{C} from an xvalue of type
\tcode{C}\iref{dcl.init.general},

\item overload resolution fails or selects a deleted assignment operator
function when assigning to an lvalue of type \tcode{C} from an xvalue of type
\tcode{C} \iref{expr.assign,over.assign}), or

\item it has a deleted destructor.
\end{itemize}

\pnum
A class \tcode{C} is a \defnadj{replaceable}{class} if it is
eligible for replacement and
\begin{itemize}
\item has the \tcode{replaceable_if_eligible} \grammarterm{class-property-specifier},
\item is a union with no user-declared special member functions, or
\item is default-movable.
\end{itemize}

\pnum
\begin{note}
Accessibility of the special member functions is not considered when
establishing trivial relocatability or replaceability.
\end{note}

\pnum
\begin{note}
Not all trivially copyable classes are trivially relocatable or replaceable.
\end{note}

\pnum
A class \tcode{S} is a \defnadj{standard-layout}{class} if it:
\begin{itemize}
\item has no non-static data members of type non-standard-layout class
(or array of such types) or reference,

\item has no virtual functions\iref{class.virtual} and no
virtual base classes\iref{class.mi},

\item has the same access control\iref{class.access}
for all non-static data members,

\item has no non-standard-layout base classes,

\item has at most one base class subobject of any given type,

\item has all non-static data members and bit-fields in the class and
its base classes first declared in the same class, and

\item has no element of the set $M(\mathtt{S})$ of types
as a base class,
where for any type \tcode{X}, $M(\mathtt{X})$ is defined as follows.
\begin{footnote}

This ensures that two subobjects that have the same class type and that
belong to the same most derived object are not allocated at the same
address\iref{expr.eq}.
\end{footnote}
\begin{note}
$M(\mathtt{X})$ is the set of the types of all non-base-class subobjects
that can be at a zero offset in \tcode{X}.
\end{note}

\begin{itemize}
\item If \tcode{X} is a non-union class type with no non-static data members,
the set $M(\mathtt{X})$ is empty.

\item If \tcode{X} is a non-union class type with a non-static data
member of type $\mathtt{X}_0$
that is either of zero size or
is the first non-static data member of \tcode{X}
(where said member may be an anonymous union),
the set $M(\mathtt{X})$ consists of $\mathtt{X}_0$ and the elements of
$M(\mathtt{X}_0)$.

\item If \tcode{X} is a union type, the set $M(\mathtt{X})$ is
the union of all $M(\mathtt{U}_i)$ and the set containing all $\mathtt{U}_i$,
where each $\mathtt{U}_i$ is the type of the $i^\text{th}$ non-static data member
of \tcode{X}.

\item If \tcode{X} is an array type with element type $\mathtt{X}_e$,
the set $M(\mathtt{X})$ consists of $\mathtt{X}_e$
and the elements of $M(\mathtt{X}_e)$.

\item If \tcode{X} is a non-class, non-array type, the set $M(\mathtt{X})$ is empty.
\end{itemize}
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
struct B { int i; };            // standard-layout class
struct C : B { };               // standard-layout class
struct D : C { };               // standard-layout class
struct E : D { char : 4; };     // not a standard-layout class

struct Q {};
struct S : Q { };
struct T : Q { };
struct U : S, T { };            // not a standard-layout class
\end{codeblock}
\end{example}

\pnum
A \defnadj{standard-layout}{struct} is a standard-layout class
defined with the \grammarterm{class-key} \keyword{struct} or the
\grammarterm{class-key} \keyword{class}.
A \defnadj{standard-layout}{union} is a standard-layout class
defined with the
\grammarterm{class-key} \keyword{union}.

\pnum
\begin{note}
Standard-layout classes are useful for communicating with
code written in other programming languages. Their layout is specified
in~\ref{class.mem.general} and~\ref{expr.rel}.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
struct N {          // neither trivially copyable nor standard-layout
  int i;
  int j;
  virtual ~N();
};

struct T {          // trivially copyable but not standard-layout
  int i;
private:
  int j;
};

struct SL {         // standard-layout but not trivially copyable
  int i;
  int j;
  ~SL();
};

struct POD {        // both trivially copyable and standard-layout
  int i;
  int j;
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
Aggregates of class type are described in~\ref{dcl.init.aggr}.
\end{note}

\pnum
A class \tcode{S} is an \defnadj{implicit-lifetime}{class} if
\begin{itemize}
\item
it is an aggregate whose destructor is not user-provided or
\item
it has at least one trivial eligible constructor and
a trivial, non-deleted destructor.
\end{itemize}

\rSec1[class.name]{Class names}
\indextext{definition!class name as type}%
\indextext{structure tag|see{class name}}%
\indextext{equivalence!type}%

\pnum
A class definition introduces a new type.
\begin{example}
\begin{codeblock}
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
\end{codeblock}
declares three variables of three different types. This implies that
\begin{codeblock}
a1 = a2;                        // error: \tcode{Y} assigned to \tcode{X}
a1 = a3;                        // error: \tcode{int} assigned to \tcode{X}
\end{codeblock}
are type mismatches, and that
\begin{codeblock}
int f(X);
int f(Y);
\end{codeblock}
\indextext{overloading}%
declare overloads\iref{over} named \tcode{f} and not
simply a single function \tcode{f} twice. For the same reason,
\begin{codeblock}
struct S { int a; };
struct S { int a; };            // error: double definition
\end{codeblock}
is ill-formed because it defines \tcode{S} twice.
\end{example}

\pnum
\indextext{definition!scope of class}%
\begin{note}
It can be necessary to use an \grammarterm{elaborated-type-specifier}
to refer to a class
that belongs to a scope in which its name is also bound to
a variable, function, or enumerator\iref{basic.lookup.elab}.
\begin{example}
\begin{codeblock}
struct stat {
  // ...
};

stat gstat;                     // use plain \tcode{stat} to define variable

int stat(struct stat*);         // \tcode{stat} now also names a function

void f() {
  struct stat* ps;              // \keyword{struct} prefix needed to name \tcode{struct stat}
  stat(ps);                     // call \tcode{stat} function
}
\end{codeblock}
\end{example}
\indextext{class name!elaborated}%
\indextext{declaration!forward class}%
An \grammarterm{elaborated-type-specifier} can also be used to declare
an \grammarterm{identifier} as a \grammarterm{class-name}.
\begin{example}
\begin{codeblock}
struct s { int a; };

void g() {
  struct s;                     // hide global \tcode{struct s} with a block-scope declaration
  s* p;                         // refer to local \tcode{struct s}
  struct s { char* p; };        // define local \tcode{struct s}
  struct s;                     // redeclaration, has no effect
}
\end{codeblock}
\end{example}
Such declarations allow definition of classes that refer to each other.
\begin{example}
\begin{codeblock}
class Vector;

class Matrix {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};

class Vector {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};
\end{codeblock}
Declaration of friends is described in~\ref{class.friend},
operator functions in~\ref{over.oper}.
\end{example}
\end{note}

\pnum
\indextext{class name!elaborated}%
\indextext{elaborated type specifier|see{class name, elaborated}}%
\begin{note}
An \grammarterm{elaborated-type-specifier}\iref{dcl.type.elab} can also
be used as a \grammarterm{type-specifier} as part of a declaration. It
differs from a class declaration in that it can refer to
an existing class of the given name.
\end{note}
\begin{example}
\begin{codeblock}
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   // global \tcode{s}
  p->a = s;                     // parameter \tcode{s}
}
\end{codeblock}
\end{example}

\pnum
\indextext{class name!point of declaration}%
\begin{note}
The declaration of a class name takes effect immediately after the
\grammarterm{identifier} is seen in the class definition or
\grammarterm{elaborated-type-specifier}.
\begin{example}
\begin{codeblock}
class A * A;
\end{codeblock}
first specifies \tcode{A} to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form \keyword{class} \tcode{A} must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
\end{example}
\end{note}

\pnum
\indextext{class name!\idxcode{typedef}}%
A \grammarterm{simple-template-id} is only a \grammarterm{class-name}
if its \grammarterm{template-name} names a class template.

\rSec1[class.mem]{Class members}%

\rSec2[class.mem.general]{General}%
\indextext{declaration!member}%
\indextext{data member|see{member}}

\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration \opt{member-specification}\br
    access-specifier \terminal{:} \opt{member-specification}
\end{bnf}

\begin{bnf}
\nontermdef{member-declaration}\br
    \opt{attribute-specifier-seq} \opt{decl-specifier-seq} \opt{member-declarator-list} \terminal{;}\br
    function-definition\br
    friend-type-declaration\br
    using-declaration\br
    using-enum-declaration\br
    static_assert-declaration\br
    template-declaration\br
    explicit-specialization\br
    deduction-guide\br
    alias-declaration\br
    opaque-enum-declaration\br
    empty-declaration
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator}\br
    declarator \opt{virt-specifier-seq} \opt{function-contract-specifier-seq} \opt{pure-specifier}\br
    declarator requires-clause \opt{function-contract-specifier-seq}\br
    declarator brace-or-equal-initializer\br
    \opt{identifier} \opt{attribute-specifier-seq} \terminal{:} constant-expression \opt{brace-or-equal-initializer}
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier-seq}\br
    virt-specifier \opt{virt-specifier-seq}
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier}\br
    \keyword{override}\br
    \keyword{final}
\end{bnf}

\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{=} \terminal{0}
\end{bnf}

\begin{bnf}
\nontermdef{friend-type-declaration}\br
    \keyword{friend} friend-type-specifier-list \terminal{;}
\end{bnf}

\begin{bnf}
\nontermdef{friend-type-specifier-list}\br
    friend-type-specifier \opt{\terminal{...}}\br
    friend-type-specifier-list \terminal{,} friend-type-specifier \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
\nontermdef{friend-type-specifier}\br
    simple-type-specifier\br
    elaborated-type-specifier\br
    typename-specifier
\end{bnf}

\pnum
In the absence of a \grammarterm{virt-specifier-seq},
the token sequence \tcode{= 0} is treated as a \grammarterm{pure-specifier}
if the type of the \grammarterm{declarator-id}\iref{dcl.meaning.general}
is a function type, and
is otherwise treated as a \grammarterm{brace-or-equal-initializer}.
\begin{note}
If the member declaration acquires a function type through
template instantiation,
the program is ill-formed; see~\ref{temp.spec.general}.
\end{note}

\pnum
The optional \grammarterm{function-contract-specifier-seq}\iref{dcl.contract.func})
in a \grammarterm{member-declarator}
shall be present only if
the \grammarterm{declarator} declares a function.

\pnum
\indextext{definition!class}%
The \grammarterm{member-specification} in a class definition declares the
full set of members of the class; no member can be added elsewhere.
A \defnadj{direct}{member} of a class \tcode{X} is a member of \tcode{X}
that was first declared within the \grammarterm{member-specification} of \tcode{X},
including anonymous union members\iref{class.union.anon} and direct members thereof.
Members of a class are data members, member
functions\iref{class.mfct}, nested types, enumerators,
and member templates\iref{temp.mem} and specializations thereof.
\begin{note}
A specialization of a static data member template is a static data member.
A specialization of a member function template is a member function.
A specialization of a member class template is a nested class.
\end{note}

\pnum
A \grammarterm{member-declaration} does not declare new members of the class
if it is
\begin{itemize}
\item a friend declaration\iref{class.friend},
\item a \grammarterm{deduction-guide}\iref{temp.deduct.guide},
\item a \grammarterm{template-declaration} whose \grammarterm{declaration} is one of the above,
\item a \grammarterm{static_assert-declaration},
\item a \grammarterm{using-declaration}\iref{namespace.udecl}, or
\item an \grammarterm{empty-declaration}.
\end{itemize}
For any other \grammarterm{member-declaration},
each declared entity
that is not an unnamed bit-field\iref{class.bit}
is a member of the class,
and each such \grammarterm{member-declaration}
shall either
declare at least one member name of the class
or declare at least one unnamed bit-field.

\pnum
A \defn{data member} is a non-function member introduced by a
\grammarterm{member-declarator}.
A \defn{member function} is a member that is a function.
Nested types are classes\iref{class.name,class.nest} and
enumerations\iref{dcl.enum} declared in the class and arbitrary types
declared as members by use of a typedef declaration\iref{dcl.typedef}
or \grammarterm{alias-declaration}.
The enumerators of an unscoped enumeration\iref{dcl.enum} defined in the class
are members of the class.

\pnum
A data member or member function
may be declared \keyword{static} in its \grammarterm{member-declaration},
in which case it is a \defnadj{static}{member} (see~\ref{class.static})
(a \defnadj{static}{data member}\iref{class.static.data} or
\defnadj{static}{member function}\iref{class.static.mfct}, respectively)
of the class.
Any other data member or member function is a \defnadj{non-static}{member}
(a \defnadj{non-static}{data member} or
\defnadj{non-static}{member function}\iref{class.mfct.non.static}, respectively).
\begin{note}
A non-static data member of non-reference
type is a member subobject of a class object\iref{intro.object}.
\end{note}

\pnum
A member shall not be declared twice in the
\grammarterm{member-specification}, except that
\begin{itemize}
\item a nested class or member
class template can be declared and then later defined, and
\item an
enumeration can be introduced with an \grammarterm{opaque-enum-declaration} and later
redeclared with an \grammarterm{enum-specifier}{}.
\end{itemize}
\begin{note}
A single name can denote several member functions provided their types
are sufficiently different\iref{basic.scope.scope}.
\end{note}

\pnum
A redeclaration of a class member outside its class definition shall be
a definition,
an explicit specialization, or
an explicit instantiation\iref{temp.expl.spec,temp.explicit}.
The member shall not be a non-static data member.

\pnum
\indextext{completely defined}%
A \defn{complete-class context} of a class (template) is a
\begin{itemize}
\item function body\iref{dcl.fct.def.general},
\item default argument\iref{dcl.fct.default},
\item default template argument\iref{temp.param},
\item \grammarterm{noexcept-specifier}\iref{except.spec},
\item \grammarterm{function-contract-specifier}\iref{dcl.contract.func}, or
\item default member initializer
\end{itemize}
within the \grammarterm{member-specification} of the class or class template.
\begin{note}
A complete-class context of a nested class is also a complete-class
context of any enclosing class, if the nested class is defined within
the \grammarterm{member-specification} of the enclosing class.
\end{note}

\pnum
A class \tcode{C} is complete at a program point $P$
if the definition of \tcode{C} is reachable from $P$\iref{module.reach}
or if $P$ is in a complete-class context of \tcode{C}.
Otherwise, \tcode{C} is incomplete at $P$.

\pnum
If a \grammarterm{member-declaration} matches
the syntactic requirements of \grammarterm{friend-type-declaration},
it is a \grammarterm{friend-type-declaration}.

\pnum
In a \grammarterm{member-declarator},
an \tcode{=} immediately following the \grammarterm{declarator}
is interpreted as introducing a \grammarterm{pure-specifier}
if the \grammarterm{declarator-id} has function type,
otherwise it is interpreted as introducing
a \grammarterm{brace-or-equal-initializer}.
\begin{example}
\begin{codeblock}
struct S {
  using T = void();
  T * p = 0;        // OK, \grammarterm{brace-or-equal-initializer}
  virtual T f = 0;  // OK, \grammarterm{pure-specifier}
};
\end{codeblock}
\end{example}

\pnum
In a \grammarterm{member-declarator} for a bit-field,
the \grammarterm{constant-expression} is parsed as
the longest sequence of tokens
that could syntactically form a \grammarterm{constant-expression}.
\begin{example}
\begin{codeblock}
int a;
const int b = 0;
struct S {
  int x1 : 8 = 42;              // OK, \tcode{"= 42"} is \grammarterm{brace-or-equal-initializer}
  int x2 : 8 { 42 };            // OK, \tcode{"\{ 42 \}"} is \grammarterm{brace-or-equal-initializer}
  int y1 : true ? 8 : a = 42;   // OK, \grammarterm{brace-or-equal-initializer} is absent
  int y2 : true ? 8 : b = 42;   // error: cannot assign to \tcode{const int}
  int y3 : (true ? 8 : b) = 42; // OK, \tcode{"= 42"} is \grammarterm{brace-or-equal-initializer}
  int z : 1 || new int { 0 };   // OK, \grammarterm{brace-or-equal-initializer} is absent
};
\end{codeblock}
\end{example}

\pnum
A \grammarterm{brace-or-equal-initializer} shall appear only in the
declaration of a data member. (For static data members,
see~\ref{class.static.data}; for non-static data members,
see~\ref{class.base.init} and~\ref{dcl.init.aggr}).
A \grammarterm{brace-or-equal-initializer} for a non-static data member
\indextext{member!default initializer}%
specifies a \defn{default member initializer} for the member, and
shall not directly or indirectly cause the implicit definition of a
defaulted default constructor for the enclosing class or the
exception specification of that constructor.
An immediate invocation\iref{expr.const} that
is a potentially-evaluated subexpression\iref{intro.execution}
of a default member initializer
is neither evaluated nor checked for whether it
is a constant expression at the point where the subexpression appears.

\pnum
A member shall not be declared with the \keyword{extern}
\grammarterm{storage-class-specifier}. Within a class definition, a member shall not be declared with the \keyword{thread_local} \grammarterm{storage-class-specifier} unless also declared \keyword{static}.

\pnum
The \grammarterm{decl-specifier-seq} may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the \grammarterm{decl-specifier-seq}
shall contain a \grammarterm{type-specifier} that is not a \grammarterm{cv-qualifier}.
The
\grammarterm{member-declarator-list} can be omitted only after a
\grammarterm{class-specifier} or an \grammarterm{enum-specifier} or in a
friend declaration\iref{class.friend}. A
\grammarterm{pure-specifier} shall be used only in the declaration of a
virtual function\iref{class.virtual}
that is not a friend declaration.

\pnum
The optional \grammarterm{attribute-specifier-seq} in a \grammarterm{member-declaration}
appertains to each of the entities declared by the \grammarterm{member-declarator}{s};
it shall not appear if the optional \grammarterm{member-declarator-list} is omitted.

\pnum
A \grammarterm{virt-specifier-seq} shall contain at most one of each
\grammarterm{virt-specifier}.
A \grammarterm{virt-specifier-seq}
shall appear only in the first declaration of a virtual member
function\iref{class.virtual}.

\pnum
\indextext{class object!member}%
The type of a non-static data member shall not be an
incomplete type\iref{term.incomplete.type},
an abstract class type\iref{class.abstract},
or a (possibly multidimensional) array thereof.
\begin{note}
In particular, a class \tcode{C} cannot contain
a non-static member of class \tcode{C},
but it can contain a pointer or reference to an object of class \tcode{C}.
\end{note}

\pnum
\begin{note}
See~\ref{expr.prim.id} for restrictions on the use of non-static data
members and non-static member functions.
\end{note}

\pnum
\begin{note}
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
\end{note}

\pnum
\begin{example}
A simple example of a class definition is
\begin{codeblock}
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
\end{codeblock}
which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration
\begin{codeblock}
tnode s, *sp;
\end{codeblock}
declares \tcode{s} to be a \tcode{tnode} and \tcode{sp} to be a pointer
to a \tcode{tnode}. With these declarations, \tcode{sp->count} refers to
the \tcode{count} member of the object to which \tcode{sp} points;
\tcode{s.left} refers to the \tcode{left} subtree pointer of the object
\tcode{s}; and \tcode{s.right->tword[0]} refers to the initial character
of the \tcode{tword} member of the \tcode{right} subtree of \tcode{s}.
\end{example}

\pnum
\begin{note}
\indextext{layout!class object}%
Non-variant non-static data members of
non-zero size\iref{intro.object}
are allocated so that later
members have higher addresses within a class object\iref{expr.rel}.
Implementation alignment requirements can cause two adjacent members
not to be allocated immediately after each other; so can requirements
for space for managing virtual functions\iref{class.virtual} and
virtual base classes\iref{class.mi}.
\end{note}

\pnum
If \tcode{T} is the name of a class, then each of the following shall
have a name different from \tcode{T}:
\begin{itemize}
\item every static data member of class \tcode{T};

\item every member function of class \tcode{T};
\begin{note}
This restriction does not apply to constructors, which do not have
names\iref{class.ctor}.
\end{note}%

\item every member of class \tcode{T} that is itself a type;

\item every member template of class \tcode{T};

\item every enumerator of every member of class \tcode{T} that is an
unscoped enumeration type; and

\item every member of every anonymous union that is a member of class
\tcode{T}.
\end{itemize}

\pnum
In addition, if class \tcode{T} has a user-declared
constructor\iref{class.ctor}, every non-static data member of class
\tcode{T} shall have a name different from \tcode{T}.

\pnum
The \defn{common initial sequence} of two standard-layout struct\iref{class.prop}
types is the longest sequence of non-static data
members and bit-fields in declaration order, starting with the first
such entity in each of the structs, such that
\begin{itemize}
\item
corresponding entities
have layout-compatible types\iref{basic.types},
\item
corresponding entities have the same alignment requirements\iref{basic.align},
\item
if a \grammarterm{has-attribute-expression}\iref{cpp.cond}
is not \tcode{0} for the \tcode{no_unique_address} attribute,
then neither entity is declared with
the \tcode{no_unique_address} attribute\iref{dcl.attr.nouniqueaddr}, and
\item
either both entities are bit-fields with the same width
or neither is a bit-field.
\end{itemize}
\begin{example}
\begin{codeblock}
struct A { int a; char b; };
struct B { const int b1; volatile char b2; };
struct C { int c; unsigned : 0; char b; };
struct D { int d; char b : 4; };
struct E { unsigned int e; char b; };
\end{codeblock}
The common initial sequence of \tcode{A} and \tcode{B} comprises all members
of either class. The common initial sequence of \tcode{A} and \tcode{C} and
of \tcode{A} and \tcode{D} comprises the first member in each case.
The common initial sequence of \tcode{A} and \tcode{E} is empty.
\end{example}

\pnum
Two standard-layout struct\iref{class.prop} types are
\defnx{layout-compatible classes}{layout-compatible!class} if
their common initial sequence comprises all members and bit-fields of
both classes\iref{basic.types}.

\pnum
Two standard-layout unions are layout-compatible if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types\iref{term.layout.compatible.type}.

\pnum
In a standard-layout union with an active member\iref{class.union}
of struct type \tcode{T1}, it is permitted to read a non-static
data member \tcode{m} of another union member of struct type \tcode{T2}
provided \tcode{m} is part of the common initial sequence of \tcode{T1} and \tcode{T2};
the behavior is as if the corresponding member of \tcode{T1} were nominated.
\begin{example}
\begin{codeblock}
struct T1 { int a, b; };
struct T2 { int c; double d; };
union U { T1 t1; T2 t2; };
int f() {
  U u = { { 1, 2 } };   // active member is \tcode{t1}
  return u.t2.c;        // OK, as if \tcode{u.t1.a} were nominated
}
\end{codeblock}
\end{example}
\begin{note}
Reading a volatile object through a glvalue of non-volatile type has
undefined behavior\iref{dcl.type.cv}.
\end{note}

\pnum
If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member
if that member is not a bit-field. Its
address is also the same as the address of each of its base class subobjects.
\begin{note}
There can therefore be unnamed padding within a standard-layout struct object
inserted by an implementation, but
not at its beginning, as necessary to achieve appropriate alignment.
\end{note}
\begin{note}
The object and its first subobject are
pointer-interconvertible\iref{basic.compound,expr.static.cast}.
\end{note}

\rSec2[class.mfct]{Member functions}%
\indextext{member function!class}

\pnum
\indextext{member function!inline}%
\indextext{definition!member function}%
If a member function is attached to the global module and is defined\iref{dcl.fct.def} in its class definition,
it is inline\iref{dcl.inline}.
\begin{note}
A member function is also inline if it is declared
\keyword{inline}, \keyword{constexpr}, or \keyword{consteval}.
\end{note}

\pnum
\indextext{operator!scope resolution}%
\begin{example}
\begin{codeblock}
struct X {
  typedef int T;
  static T count;
  void f(T);
};
void X::f(T t = count) { }
\end{codeblock}

The definition of the member function \tcode{f} of class \tcode{X} inhabits the global
scope; the notation \tcode{X::f} indicates that the function \tcode{f}
is a member of class \tcode{X} and in the scope of class \tcode{X}. In
the function definition, the parameter type \tcode{T} refers to the
typedef member \tcode{T} declared in class \tcode{X} and the default
argument \tcode{count} refers to the static data member \tcode{count}
declared in class \tcode{X}.
\end{example}

\pnum
\indextext{local class!member function in}%
Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.

\pnum
\begin{note}
A member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see~\ref{dcl.fct} and \ref{temp.arg}.
\begin{example}
\begin{codeblock}
typedef void fv();
typedef void fvc() const;
struct S {
  fv memfunc1;      // equivalent to: \tcode{void memfunc1();}
  void memfunc2();
  fvc memfunc3;     // equivalent to: \tcode{void memfunc3() const;}
};
fv  S::* pmfv1 = &S::memfunc1;
fv  S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
\end{codeblock}
\end{example}
\end{note}

\rSec2[class.mfct.non.static]{Non-static member functions}%

\indextext{member function!non-static}

\pnum
A non-static member function may be called for an object of
its class type, or for an object of a class derived\iref{class.derived}
from its class type, using the class member
access syntax\iref{expr.ref,over.match.call}. A non-static
member function may also be called directly using the function call
syntax\iref{expr.call,over.match.call} from within
its class or a class derived from its class, or
a member thereof, as described below.

\pnum
\indextext{member function!const}%
\indextext{member function!volatile}%
\indextext{member function!const volatile}%
\begin{note}
An implicit object member function can be declared with
\grammarterm{cv-qualifier}{s}, which affect the type of the \keyword{this}
pointer\iref{expr.prim.this},
and/or a \grammarterm{ref-qualifier}\iref{dcl.fct};
both affect overload resolution\iref{over.match.funcs}.
\end{note}

\pnum
An implicit object member function may be declared
virtual\iref{class.virtual} or pure virtual\iref{class.abstract}.

\rSec2[special]{Special member functions}

\indextext{~@\tcode{\~}|see{destructor}}%
\indextext{assignment!copy|see{assignment operator, copy}}%
\indextext{assignment!move|see{assignment operator, move}}%
\indextext{implicitly-declared default constructor|see{constructor, default}}

\pnum
\indextext{constructor!default}%
\indextext{constructor!copy}%
\indextext{constructor!move}%
\indextext{assignment operator!copy}%
\indextext{assignment operator!move}%
Default constructors\iref{class.default.ctor},
copy constructors, move constructors\iref{class.copy.ctor},
copy assignment operators, move assignment operators\iref{class.copy.assign},
and prospective destructors\iref{class.dtor} are
\term{special member functions}.
\begin{note}
The implementation will implicitly declare these member functions for some class
types when the program does not explicitly declare them.
The implementation will implicitly define them
as needed\iref{dcl.fct.def.default}.
\end{note}
An implicitly-declared special member function is declared at the closing
\tcode{\}} of the \grammarterm{class-specifier}.
Programs shall not define implicitly-declared special member functions.

\pnum
Programs may explicitly refer to implicitly-declared special member functions.
\begin{example}
A program may explicitly call or form a pointer to member
to an implicitly-declared special member function.

\begin{codeblock}
struct A { };                   // implicitly declared \tcode{A::operator=}
struct B : A {
  B& operator=(const B &);
};
B& B::operator=(const B& s) {
  this->A::operator=(s);        // well-formed
  return *this;
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
The special member functions affect the way objects of class type are created,
copied, moved, and destroyed, and how values can be converted to values of other types.
Often such special member functions are called implicitly.
\end{note}

\pnum
\indextext{access control!member function and}%
Special member functions obey the usual access rules\iref{class.access}.
\begin{example}
Declaring a constructor protected
ensures that only derived classes and friends can create objects using it.
\end{example}

\pnum
Two special member functions are of the same kind if
\begin{itemize}
\item they are both default constructors,
\item they are both copy or move constructors
with the same first parameter type, or
\item they are both copy or move assignment operators
with the same first parameter type
and the same \grammarterm{cv-qualifier}s and \grammarterm{ref-qualifier}, if any.
\end{itemize}

\pnum
An \defnadj{eligible}{special member function} is a special member function for which:
\begin{itemize}
\item the function is not deleted,
\item the associated constraints\iref{temp.constr}, if any, are satisfied, and
\item no special member function of the same kind
whose associated constraints, if any, are satisfied
is more constrained\iref{temp.constr.order}.
\end{itemize}

\pnum
For a class, its non-static data members, its non-virtual direct base classes,
and, if the class is not abstract\iref{class.abstract}, its virtual base
classes are called its \term{potentially constructed subobjects}.

\rSec2[class.ctor]{Constructors}%

\rSec3[class.ctor.general]{General}%
\indextext{constructor}%
\indextext{special member function|see{constructor}}%

\pnum
A \grammarterm{declarator} declares a \defn{constructor} if it is a
function declarator\iref{dcl.fct} of the form
\begin{ncbnf}
ptr-declarator \terminal{(} parameter-declaration-clause \terminal{)} \opt{noexcept-specifier} \opt{attribute-specifier-seq}
\end{ncbnf}
where the \grammarterm{ptr-declarator} consists solely of an
\grammarterm{id-expression}, an optional \grammarterm{attribute-specifier-seq},
and optional surrounding parentheses, and the \grammarterm{id-expression} has
one of the following forms:
\begin{itemize}
\item
in a friend declaration\iref{class.friend},
the \grammarterm{id-expression} is a \grammarterm{qualified-id}
that names a constructor\iref{class.qual};
\item
otherwise, in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class or class template,
the \grammarterm{id-expression} is the
injected-class-name\iref{class.pre} of the immediately-enclosing entity;

\item
otherwise, the
\grammarterm{id-expression} is a \grammarterm{qualified-id}
whose \grammarterm{unqualified-id} is
the injected-class-name of its lookup context.
\end{itemize}
Constructors do not have names.
In a constructor declaration, each \grammarterm{decl-specifier} in the optional
\grammarterm{decl-specifier-seq} shall be
\keyword{friend},
\keyword{inline},
\keyword{constexpr},
\keyword{consteval}, or
an \grammarterm{explicit-specifier}.
\begin{example}
\begin{codeblock}
struct S {
  S();              // declares the constructor
};

S::S() { }          // defines the constructor
\end{codeblock}
\end{example}

\pnum
\indextext{constructor!explicit call}%
A constructor is used to initialize objects of its class type.
\begin{note}
Because constructors do not have names, they are never found during
unqualified name lookup; however an explicit type conversion using the functional
notation\iref{expr.type.conv} will cause a constructor to be called to
initialize an object.
The syntax looks like an explicit call of the constructor.
\end{note}
\begin{example}
\begin{codeblock}
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );
\end{codeblock}
\end{example}
\begin{note}
For initialization of objects of class type see~\ref{class.init}.
\end{note}

\pnum
\indextext{object!unnamed}%
An object created in this way is unnamed.
\begin{note}
\ref{class.temporary} describes the lifetime of temporary objects.
\end{note}
\begin{note}
Explicit constructor calls do not yield lvalues, see~\ref{basic.lval}.
\end{note}

\pnum
\begin{note}
\indextext{member function!constructor and}%
Some language constructs have special semantics when used during construction;
see~\ref{class.base.init} and~\ref{class.cdtor}.
\end{note}

\pnum
\indextext{\idxcode{const}!constructor and}%
\indextext{\idxcode{volatile}!constructor and}%
A constructor can be invoked for a
\keyword{const},
\tcode{volatile}
or
\keyword{const}
\tcode{volatile}
object.
\indextext{restriction!constructor}%
\keyword{const}
and
\tcode{volatile}
semantics\iref{dcl.type.cv} are not applied on an object under construction.
They come into effect when the constructor for the
most derived object\iref{intro.object} ends.

\pnum
\indextext{constructor!address of}%
The address of a constructor shall not be taken.
\indextext{restriction!constructor}%
\begin{note}
A \tcode{return} statement in the body of a constructor
cannot specify a return value\iref{stmt.return}.
\end{note}

\pnum
A constructor shall not be a coroutine.

\pnum
A constructor shall not have an explicit object parameter\iref{dcl.fct}.

\rSec3[class.default.ctor]{Default constructors}

\pnum
\indextext{constructor!inheritance of}%
\indextext{constructor!non-trivial}%
A \defnadj{default}{constructor} for a class \tcode{X}
is a constructor of class \tcode{X}
for which each parameter
that is not a function parameter pack
has a default argument
(including the case of a constructor with no parameters).
\indextext{implicitly-declared default constructor}%
If there is no user-declared constructor or constructor template for class
\tcode{X},
a non-explicit constructor having no parameters is implicitly declared
as defaulted\iref{dcl.fct.def}.
An implicitly-declared default constructor is an
inline public member of its class.

\pnum
A defaulted default constructor for class \tcode{X} is defined as deleted if
\begin{itemize}
\item any non-static data member with no default member initializer\iref{class.mem} is
of reference type,

\item \tcode{X} is a non-union class and
any non-variant non-static data member of const-qualified type
(or possibly multidimensional array thereof)
with no \grammarterm{brace-or-equal-initializer}
is not const-default-constructible\iref{dcl.init},

\item any non-variant potentially constructed subobject, except for a non-static data member
with a \grammarterm{brace-or-equal-initializer},
has class type \tcode{M} (or possibly multidimensional array thereof)
and overload resolution\iref{over.match}
as applied to find \tcode{M}'s corresponding constructor
does not result in a usable candidate\iref{over.match.general}, or

\item any potentially constructed subobject $S$ has
class type \tcode{M} (or possibly multidimensional array thereof),
\tcode{M} has
a destructor that is deleted or inaccessible from the defaulted default
constructor, and
either $S$ is non-variant or $S$ has a default member initializer.
\end{itemize}

\pnum
A default constructor for a class \tcode{X} is
\defnx{trivial}{constructor!default!trivial}
if it is not user-provided and if
\begin{itemize}
\item
\tcode{X} has no virtual functions\iref{class.virtual} and no virtual base
classes\iref{class.mi}, and

\item no non-static data member of \tcode{X} has
a default member initializer\iref{class.mem}, and

\item
all the direct base classes of \tcode{X} have trivial default constructors, and

\item
either \tcode{X} is a union or
for all the non-variant non-static data members of \tcode{X} that are of class
type (or array thereof), each such class has a trivial default constructor.
\end{itemize}

Otherwise, the default constructor is
\defnx{non-trivial}{constructor!default!non-trivial}.

\pnum
If a default constructor of a union-like class \tcode{X} is trivial,
then for each union \tcode{U}
that is either \tcode{X} or an anonymous union member of \tcode{X},
if the first variant member, if any, of \tcode{U}
has implicit-lifetime type\iref{basic.types.general},
the default constructor of \tcode{X} begins the lifetime of that member
if it is not the active member of its union.
\begin{note}
It is already the active member if \tcode{U} was value-initialized.
\end{note}
Otherwise,
an implicitly-defined\iref{dcl.fct.def.default} default constructor performs the set of
initializations of the class that would be performed by a user-written default
constructor for that class with no
\grammarterm{ctor-initializer}\iref{class.base.init} and an empty
\grammarterm{compound-statement}.
If that user-written default constructor would be ill-formed,
the program is ill-formed.
If that user-written default constructor would be constexpr-suitable\iref{dcl.constexpr},
the implicitly-defined
default constructor is \keyword{constexpr}.
Before the defaulted default constructor for a class is
implicitly defined,
all the non-user-provided default constructors for its base classes and
its non-static data members are implicitly defined.
\begin{note}
An implicitly-declared default constructor has an
exception specification\iref{except.spec}.
An explicitly-defaulted definition might have an
implicit exception specification, see~\ref{dcl.fct.def}.
\end{note}

\pnum
\begin{note}
\indextext{constructor!implicitly invoked}%
A default constructor is implicitly invoked to initialize
a class object when no initializer is specified\iref{dcl.init.general}.
Such a default constructor needs to be accessible\iref{class.access}.
\end{note}

\pnum
\begin{note}
\indextext{order of execution!base class constructor}%
\indextext{order of execution!member constructor}%
\ref{class.base.init} describes the order in which constructors for base
classes and non-static data members are called and
describes how arguments can be specified for the calls to these constructors.
\end{note}

\rSec3[class.copy.ctor]{Copy/move constructors}%

\pnum
\indextext{constructor!copy|(}%
\indextext{constructor!move|(}%
\indextext{copy!class object|see{constructor, copy}}%
\indextext{move!class object|see{constructor, move}}%
A non-template constructor for class
\tcode{X}
is
a
copy
constructor if its first parameter is of type
\tcode{X\&},
\tcode{const X\&},
\tcode{volatile X\&}
or
\tcode{const volatile X\&},
and either there are no other parameters
or else all other parameters have default arguments\iref{dcl.fct.default}.
\begin{example}
\tcode{X::X(const X\&)}
and
\tcode{X::X(X\&,int=1)}
are copy constructors.

\begin{codeblock}
struct X {
  X(int);
  X(const X&, int = 1);
};
X a(1);             // calls \tcode{X(int);}
X b(a, 0);          // calls \tcode{X(const X\&, int);}
X c = b;            // calls \tcode{X(const X\&, int);}
\end{codeblock}
\end{example}

\pnum
A non-template constructor for class \tcode{X} is a move constructor if its
first parameter is of type \tcode{X\&\&}, \tcode{const X\&\&},
\tcode{volatile X\&\&}, or \tcode{const volatile X\&\&}, and either there are
no other parameters or else all other parameters have default
arguments\iref{dcl.fct.default}.
\begin{example}
\tcode{Y::Y(Y\&\&)} is a move constructor.
\begin{codeblock}
struct Y {
  Y(const Y&);
  Y(Y&&);
};
extern Y f(int);
Y d(f(1));          // calls \tcode{Y(Y\&\&)}
Y e = d;            // calls \tcode{Y(const Y\&)}
\end{codeblock}
\end{example}

\pnum
\begin{note}
All forms of copy/move constructor can be declared for a class.
\begin{example}
\begin{codeblock}
struct X {
  X(const X&);
  X(X&);            // OK
  X(X&&);
  X(const X&&);     // OK, but possibly not sensible
};
\end{codeblock}
\end{example}
\end{note}

\pnum
\begin{note}
If a class
\tcode{X}
only has a copy constructor with a parameter of type
\tcode{X\&},
an initializer of type
\keyword{const}
\tcode{X}
or
\tcode{volatile}
\tcode{X}
cannot initialize an object of type
\cv{}~\tcode{X}.
\begin{example}
\begin{codeblock}
struct X {
  X();              // default constructor
  X(X&);            // copy constructor with a non-const parameter
};
const X cx;
X x = cx;           // error: \tcode{X::X(X\&)} cannot copy \tcode{cx} into \tcode{x}
\end{codeblock}
\end{example}
\end{note}

\pnum
A declaration of a constructor for a class
\tcode{X}
is ill-formed if its first parameter is of type
\cv{}~\tcode{X}
and either there are no other parameters or else all other parameters have
default arguments.
A member function template is never instantiated to
produce such a constructor signature.
\begin{example}
\begin{codeblock}
struct S {
  template<typename T> S(T);
  S();
};

S g;

void h() {
  S a(g);           // does not instantiate the member template to produce \tcode{S::S<S>(S)};
                    // uses the implicitly declared copy constructor
}
\end{codeblock}
\end{example}

\pnum
If the class definition does not explicitly declare a copy constructor,
a non-explicit one is declared \defnx{implicitly}{constructor!copy!implicitly declared}.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
constructor is defined as deleted; otherwise, it is
defaulted\iref{dcl.fct.def}.
The latter case is deprecated if the class has a user-declared copy assignment
operator or a user-declared destructor \iref{depr.impldec}.

\pnum
The implicitly-declared copy constructor for a class
\tcode{X}
will have the form
\begin{codeblock}
X::X(const X&)
\end{codeblock}
if each potentially constructed subobject of a class type
\tcode{M}
(or array thereof)
has a copy constructor whose first parameter is of type
\keyword{const}
\tcode{M\&}
or
\keyword{const}
\tcode{volatile}
\tcode{M\&}.
\begin{footnote}
This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
\tcode{volatile}
lvalue; see~\ref{diff.class}.
\end{footnote}
Otherwise, the implicitly-declared copy constructor will have the form
\begin{codeblock}
X::X(X&)
\end{codeblock}

\pnum
\indextext{constructor!move!implicitly declared}%
If the definition of a class \tcode{X} does not explicitly declare
a move constructor, a non-explicit one will be
implicitly declared as defaulted if and only if
\begin{itemize}
\item
\tcode{X} does not have a user-declared copy constructor,

\item
\tcode{X} does not have a user-declared copy assignment operator,

\item
\tcode{X} does not have a user-declared move assignment operator, and

\item
\tcode{X} does not have a user-declared destructor.
\end{itemize}

\begin{note}
When the move constructor is not implicitly declared or explicitly supplied,
expressions that otherwise would have invoked the move constructor might instead invoke
a copy constructor.
\end{note}

\pnum
The implicitly-declared move constructor for class \tcode{X} will have the form
\begin{codeblock}
X::X(X&&)
\end{codeblock}

\pnum
An implicitly-declared copy/move constructor is an
inline public member of its class.
A defaulted copy/\brk{}move constructor for a class
  \tcode{X} is defined as deleted\iref{dcl.fct.def.delete} if \tcode{X} has:
\begin{itemize}
\item a potentially constructed subobject of type
  \tcode{M} (or possibly multidimensional array thereof) for which
  overload resolution\iref{over.match}, as applied to find
  \tcode{M}'s corresponding constructor,
  either does not result in a usable candidate\iref{over.match.general} or,
  in the case of a variant member, selects a non-trivial function,

\item any potentially constructed subobject of
  class type \tcode{M} (or possibly multidimensional array thereof)
  where \tcode{M} has
  a destructor that is deleted or inaccessible from the defaulted
  constructor, or,

\item for the copy constructor, a non-static data member of rvalue reference type.
\end{itemize}

\begin{note}
A defaulted move constructor that is defined as deleted is ignored by overload
resolution\iref{over.match,over.over}.
Such a constructor would otherwise interfere with initialization from
an rvalue which can use the copy constructor instead.
\end{note}

\pnum
\indextext{constructor!copy!trivial}%
\indextext{constructor!move!trivial}%
A copy/move constructor for class
\tcode{X}
is
trivial
if it is not user-provided and if
\begin{itemize}
\item
class
\tcode{X}
has no virtual functions\iref{class.virtual}
and no virtual base classes\iref{class.mi}, and

\item
the constructor selected to copy/move each direct base class subobject is trivial, and

\item
for each non-static data member of
\tcode{X}
that is of class type (or array thereof),
the constructor selected to copy/move that member is trivial;
\end{itemize}

\indextext{constructor!move!non-trivial}%
otherwise the copy/move constructor is
\defnx{non-trivial}{constructor!copy!nontrivial}.

\pnum
\begin{note}
The copy/move constructor is implicitly defined even if the implementation elided
its odr-use\iref{term.odr.use,class.temporary}.
\end{note}
If an implicitly-defined\iref{dcl.fct.def.default} constructor would be constexpr-suitable\iref{dcl.constexpr},
the implicitly-defined
constructor is \keyword{constexpr}.

\pnum
Before the defaulted copy/move constructor for a class is
implicitly defined,
all non-user-provided copy/move constructors for its
potentially constructed subobjects
are implicitly defined.
\begin{note}
An implicitly-declared copy/move constructor has an
implied exception specification\iref{except.spec}.
\end{note}

\pnum
The implicitly-defined copy/move constructor for a non-union class
\tcode{X}
performs a memberwise copy/move of its bases and members.
\begin{note}
Default member initializers of non-static data members are ignored.
\end{note}
The order of initialization is the same as the order of initialization of bases
and members in a user-defined constructor (see~\ref{class.base.init}).
Let \tcode{x} be either the parameter of the constructor or, for the move constructor, an
xvalue referring to the parameter.
Each base or non-static data member
is copied/moved in the manner appropriate to its type:
\begin{itemize}
\item
if the member is an array, each element is
direct-initialized with the corresponding subobject of \tcode{x};

\item
if a member \tcode{m} has rvalue reference type \tcode{T\&\&}, it is direct-initialized with
\tcode{static_cast<T\&\&>(x.m)};

\item
otherwise, the base or member is direct-initialized with the corresponding base or member of \tcode{x}.
\end{itemize}

\indextext{initialization!virtual base class}%
Virtual base class subobjects shall be initialized only once by
the implicitly-defined copy/move constructor (see~\ref{class.base.init}).

\pnum
The implicitly-defined copy/move constructor for a union
\tcode{X} copies the object representation\iref{term.object.representation} of \tcode{X}.
For each object nested within\iref{intro.object}
the object that is the source of the copy,
a corresponding object $o$ nested within the destination
is identified (if the object is a subobject) or created (otherwise),
and the lifetime of $o$ begins before the copy is performed.
\indextext{constructor!move|)}
\indextext{constructor!copy|)}

\rSec2[class.copy.assign]{Copy/move assignment operator}%

\pnum
\indextext{assignment operator!copy|(}%
\indextext{assignment operator!move|(}%
\indextext{special member function|see{assignment operator}}%
\indextext{copy!class object|see{assignment operator, copy}}%
\indextext{move!class object|see{assignment operator, move}}%
\indextext{operator!copy assignment|see{assignment operator, copy}}%
\indextext{operator!move assignment|see{assignment operator, move}}%
A user-declared \term{copy} assignment operator \tcode{X::operator=} is a
non-static non-template member function of class \tcode{X} with exactly one
non-object parameter of type \tcode{X}, \tcode{X\&}, \tcode{const X\&},
\tcode{volatile X\&}, or \tcode{const volatile X\&}.
\begin{footnote}
Because
a template assignment operator or an assignment operator
taking an rvalue reference parameter is never a copy assignment operator,
the presence of such an assignment operator does not suppress the
implicit declaration of a copy assignment operator. Such assignment operators
participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.
\end{footnote}
\begin{note}
More than one form of copy assignment operator can be declared for a class.
\end{note}
\begin{note}
If a class
\tcode{X}
only has a copy assignment operator with a non-object parameter of type
\tcode{X\&},
an expression of type const
\tcode{X}
cannot be assigned to an object of type
\tcode{X}.
\begin{example}
\begin{codeblock}
struct X {
  X();
  X& operator=(X&);
};
const X cx;
X x;
void f() {
  x = cx;           // error: \tcode{X::operator=(X\&)} cannot assign \tcode{cx} into \tcode{x}
}
\end{codeblock}
\end{example}
\end{note}

\pnum
If the class definition does not explicitly declare a copy assignment operator,
one is declared \defnx{implicitly}{assignment operator!copy!implicitly declared}.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
assignment operator is defined as deleted; otherwise, it is
defaulted\iref{dcl.fct.def}.
The latter case is deprecated if the class has a user-declared copy constructor
or a user-declared destructor \iref{depr.impldec}.
The implicitly-declared copy assignment operator for a class
\tcode{X}
will have the form
\begin{codeblock}
X& X::operator=(const X&)
\end{codeblock}
if
\begin{itemize}
\item
each direct base class \tcode{B} of \tcode{X}
has a copy assignment operator whose non-object parameter is of type
\tcode{const B\&}, \tcode{const volatile B\&}, or \tcode{B}, and
\item
for all the non-static data members of \tcode{X}
that are of a class type \tcode{M} (or array thereof),
each such class type has a copy assignment operator whose non-object parameter is of type
\tcode{const M\&}, \tcode{const volatile M\&},
or \tcode{M}.
\begin{footnote}
This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
\tcode{volatile} lvalue; see~\ref{diff.class}.
\end{footnote}
\end{itemize}

Otherwise, the implicitly-declared copy assignment operator
will have the form
\begin{codeblock}
X& X::operator=(X&)
\end{codeblock}

\pnum
A user-declared move assignment operator \tcode{X::operator=} is
a non-static non-template member function of class \tcode{X} with exactly
one non-object parameter of type \tcode{X\&\&}, \tcode{const X\&\&}, \tcode{volatile X\&\&}, or
\tcode{const volatile X\&\&}.
\begin{note}
More than one form of move assignment operator can be declared for a class.
\end{note}

\pnum
\indextext{assignment operator!move!implicitly declared}%
If the definition of a class \tcode{X} does not explicitly declare a
move assignment operator, one
will be implicitly declared as defaulted if and only if
\begin{itemize}
\item
\tcode{X} does not have a user-declared copy constructor,

\item
\tcode{X} does not have a user-declared move constructor,

\item
\tcode{X} does not have a user-declared copy assignment operator, and

\item
\tcode{X} does not have a user-declared destructor.
\end{itemize}

\begin{example}
The class definition
\begin{codeblock}
struct S {
  int a;
  S& operator=(const S&) = default;
};
\end{codeblock}
will not have a default move assignment operator implicitly declared because the
copy assignment operator has been user-declared. The move assignment operator may
be explicitly defaulted.

\begin{codeblock}
struct S {
  int a;
  S& operator=(const S&) = default;
  S& operator=(S&&) = default;
};
\end{codeblock}
\end{example}

\pnum
The implicitly-declared move assignment operator for a class \tcode{X} will have the form
\begin{codeblock}
X& X::operator=(X&&)
\end{codeblock}

\pnum
The implicitly-declared copy/move assignment operator for class
\tcode{X}
has the return type
\tcode{X\&}.
An implicitly-declared copy/move assignment operator is an
inline public member of its class.

\pnum
A defaulted copy/move assignment operator for
class \tcode{X} is defined as deleted if \tcode{X} has:
\begin{itemize}
\item a non-static data member of \keyword{const} non-class
  type (or possibly multidimensional array thereof), or

\item a non-static data member of reference type, or

\item a direct non-static data member of class type \tcode{M}
  (or possibly multidimensional array thereof) or
  a direct base class \tcode{M}
  that cannot be copied/moved because overload resolution
 \iref{over.match}, as applied to find \tcode{M}'s corresponding
  assignment operator,
  either does not result in a usable candidate\iref{over.match.general} or,
  in the case of a variant member, selects a non-trivial function.
\end{itemize}

\begin{note}
A defaulted move assignment operator that is defined as deleted is ignored by
overload resolution\iref{over.match,over.over}.
\end{note}

\pnum
\indextext{assignment operator!copy!hidden}%
\indextext{assignment operator!move!hidden}%
Because a copy/move assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy/move assignment operator is always hidden
by the corresponding assignment operator of a derived class\iref{over.assign}.
\begin{note}
A \grammarterm{using-declaration} in a derived class \tcode{C}
that names an assignment operator from a base class
never suppresses the implicit declaration of
an assignment operator of \tcode{C},
even if the base class assignment operator would be
a copy or move assignment operator
if declared as a member of \tcode{C}.
\end{note}

\pnum
\indextext{assignment operator!copy!trivial}%
\indextext{assignment operator!move!trivial}%
A copy/move assignment operator for class
\tcode{X}
is
trivial
if it is not user-provided and if
\begin{itemize}
\item
class
\tcode{X}
has no virtual functions\iref{class.virtual}
and no virtual base classes\iref{class.mi}, and

\item the assignment operator selected to copy/move each direct
base class subobject is trivial, and

\item
for each non-static data member of
\tcode{X}
that is of class type (or array thereof),
the assignment operator selected to copy/move that member is trivial;
\end{itemize}
\indextext{assignment operator!move!non-trivial}%
otherwise the copy/move assignment operator is
\defnx{non-trivial}{assignment operator!copy!non-trivial}.

\pnum
An implicitly-defined\iref{dcl.fct.def.default} copy/move assignment operator is \keyword{constexpr}.

\pnum
Before the defaulted copy/move assignment operator for a class is
implicitly defined,
all non-user-provided copy/move assignment operators for
its direct base classes and
its non-static data members are implicitly defined.
\begin{note}
An implicitly-declared copy/move assignment operator has an
implied exception specification\iref{except.spec}.
\end{note}

\pnum
The implicitly-defined copy/move assignment operator for a
non-union class \tcode{X} performs memberwise copy/move assignment of its subobjects. The direct
base classes of \tcode{X} are assigned first, in the order of their declaration in the
\grammarterm{base-specifier-list}, and then the immediate non-static data members of
\tcode{X} are assigned, in the order in which they were declared in the class
definition.
Let \tcode{x} be either the parameter of the function or, for the move operator, an
xvalue referring to the parameter.
Each subobject is assigned in the manner appropriate to its type:
\begin{itemize}
\item
if the subobject is of class type,
as if by a call to \tcode{operator=} with the subobject as the object expression
and the corresponding subobject of \tcode{x} as a single function argument
(as if by explicit qualification; that is,
ignoring any possible virtual overriding functions in more derived classes);
\item
if the subobject is an array, each element is assigned,
in the manner appropriate to the element type;
\item
if the subobject is of scalar type,
the built-in assignment operator is used.
\end{itemize}

\indextext{assignment operator!copy!virtual bases and}%
It is unspecified whether subobjects representing virtual base classes
are assigned more than once by the implicitly-defined copy/move assignment
operator.
\begin{example}
\begin{codeblock}
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
\end{codeblock}

It is unspecified whether the virtual base class subobject
\tcode{V}
is assigned twice by the implicitly-defined copy/move assignment operator for
\tcode{C}.
\end{example}

\pnum
The implicitly-defined copy/move assignment operator for a
union \tcode{X} copies the object representation\iref{term.object.representation} of \tcode{X}.
If the source and destination of the assignment are not the same object, then
for each object nested within\iref{intro.object}
the object that is the source of the copy,
a corresponding object $o$ nested within the destination is created,
and the lifetime of $o$ begins before the copy is performed.

\pnum
The implicitly-defined copy/move assignment operator for a class
returns the object for which the assignment operator is invoked,
that is, the object assigned to.
\indextext{assignment operator!move|)}
\indextext{assignment operator!copy|)}

\rSec2[class.dtor]{Destructors}%
\indextext{destructor}%
\indextext{special member function|see{destructor}}%
\pnum
A declaration whose \grammarterm{declarator-id}
has an \grammarterm{unqualified-id} that begins with a \tcode{\~}
declares a \defnadj{prospective}{destructor};
its \grammarterm{declarator} shall be a function declarator\iref{dcl.fct} of the form
\begin{ncbnf}
ptr-declarator \terminal{(} parameter-declaration-clause \terminal{)} \opt{noexcept-specifier} \opt{attribute-specifier-seq}
\end{ncbnf}
where the \grammarterm{ptr-declarator} consists solely of an
\grammarterm{id-expression}, an optional \grammarterm{attribute-specifier-seq},
and optional surrounding parentheses, and the \grammarterm{id-expression} has
one of the following forms:
\begin{itemize}
\item
in a \grammarterm{member-declaration} that belongs to the
\grammarterm{member-specification} of a class or class template
but is not a friend
declaration\iref{class.friend}, the \grammarterm{id-expression} is
\tcode{\~}\grammarterm{class-name} and the \grammarterm{class-name} is the
injected-class-name\iref{class.pre} of the immediately-enclosing entity or

\item
otherwise, the
\grammarterm{id-expression} is \grammarterm{nested-name-specifier}
\tcode{\~}\grammarterm{class-name} and the \grammarterm{class-name}
is the injected-class-name of the
class nominated by the \grammarterm{nested-name-specifier}.
\end{itemize}

A prospective destructor shall take no arguments\iref{dcl.fct}.
Each \grammarterm{decl-specifier} of the \grammarterm{decl-specifier-seq}
of a prospective destructor declaration (if any)
shall be
\keyword{friend},
\keyword{inline},
\keyword{virtual}, or
\keyword{constexpr}.

\pnum
\indextext{generated destructor|see{destructor, default}}%
\indextext{destructor!default}%
If a class has no user-declared
prospective destructor,
a prospective destructor is implicitly
declared as defaulted\iref{dcl.fct.def}.
An implicitly-declared prospective destructor is an
inline public member of its class.

\pnum
An implicitly-declared prospective destructor for a class \tcode{X} will have the form
\begin{codeblock}
~X()
\end{codeblock}

\pnum
At the end of the definition of a class,
overload resolution is performed
among the prospective destructors declared in that class
with an empty argument list
to select the \defn{destructor} for the class,
also known as the \defnadj{selected}{destructor}.
The program is ill-formed if overload resolution fails.
Destructor selection does not constitute
a reference to,
or odr-use\iref{term.odr.use} of,
the selected destructor,
and in particular,
the selected destructor may be deleted\iref{dcl.fct.def.delete}.

\pnum
\indextext{destructor!address of}%
The address of a destructor shall not be taken.
\indextext{restriction!destructor}%
\begin{note}
A \tcode{return} statement in the body of a destructor
cannot specify a return value\iref{stmt.return}.
\end{note}
\indextext{\idxcode{const}!destructor and}%
\indextext{\idxcode{volatile}!destructor and}%
A destructor can be invoked for a
\keyword{const},
\tcode{volatile}
or
\keyword{const}
\tcode{volatile}
object.
\keyword{const}
and
\tcode{volatile}
semantics\iref{dcl.type.cv} are not applied on an object under destruction.
They stop being in effect when the destructor for the
most derived object\iref{intro.object} starts.

\pnum
\begin{note}
A declaration of a destructor that does not have a \grammarterm{noexcept-specifier}
has the same exception specification as if it had been implicitly declared\iref{except.spec}.
\end{note}

\pnum
A defaulted destructor for a class
  \tcode{X} is defined as deleted if
\begin{itemize}
\item \tcode{X} is a non-union class and
  any non-variant potentially constructed subobject has class type
  \tcode{M} (or possibly multidimensional array thereof) where
  \tcode{M} has a destructor that is deleted or
  is inaccessible from the defaulted destructor,

\item
  \tcode{X} is a union and
  \begin{itemize}
  \item
    overload resolution to select a constructor to
    default-initialize an object of type \tcode{X} either fails or
    selects a constructor that is either deleted or not trivial, or
  \item
    \tcode{X} has a variant member \tcode{V} of
    class type \tcode{M} (or possibly multi-dimensional array thereof)
    where \tcode{V} has a default member initializer and
    \tcode{M} has a destructor that is non-trivial, or,
  \end{itemize}

\item for a virtual destructor, lookup of the non-array deallocation
  function results in an ambiguity or in a function that is deleted or
  inaccessible from the defaulted destructor.
\end{itemize}

\pnum
A destructor for a class \tcode{X} is trivial if it is not user-provided and if
\begin{itemize}
\item the destructor is not virtual,

\item all of the direct base classes of \tcode{X} have trivial destructors, and

\item either \tcode{X} is a union or
for all of the non-variant non-static data members of \tcode{X} that are of class
type (or array thereof), each such class has a trivial destructor.
\end{itemize}

Otherwise, the destructor is
\defnx{non-trivial}{destructor!non-trivial}.

\pnum
A defaulted destructor is a constexpr destructor
if it is constexpr-suitable\iref{dcl.constexpr}.

\pnum
Before a
defaulted destructor for a class is implicitly defined, all the non-user-provided
destructors for its base classes and its non-static data members are
implicitly defined.

\pnum
\indextext{destructor!virtual}%
\indextext{destructor!pure virtual}%
A prospective destructor can be
declared \keyword{virtual}\iref{class.virtual}
and with a \grammarterm{pure-specifier}\iref{class.abstract}.
If the destructor of a class is virtual and
any objects of that class or any derived class are created in the program,
the destructor shall be defined.

\pnum
\begin{note}
\indextext{member function!destructor and}%
Some language constructs have special semantics when used during destruction;
see~\ref{class.cdtor}.
\end{note}

\pnum
\indextext{order of execution!destructor}%
\indextext{order of execution!base class destructor}%
\indextext{order of execution!member destructor}%
After executing the body of the destructor and destroying
any objects with automatic storage duration allocated within the body, a
destructor for class
\tcode{X}
calls the destructors for
\tcode{X}'s
direct non-variant non-static data members other than anonymous unions,
the destructors for
\tcode{X}'s
non-virtual direct base classes and, if
\tcode{X}
is the most derived class\iref{class.base.init},
its destructor calls the destructors for
\tcode{X}'s
virtual base classes.
All destructors are called as if they were referenced with a qualified name,
that is, ignoring any possible virtual overriding destructors in more
derived classes.
Bases and members are destroyed in the reverse order of the completion of
their constructor (see~\ref{class.base.init}).
\begin{note}
A
\tcode{return}
statement\iref{stmt.return} in a destructor might not directly return to the
caller; before transferring control to the caller, the destructors for the
members and bases are called.
\end{note}
\indextext{order of execution!destructor and array}%
Destructors for elements of an array are called in reverse order of their
construction (see~\ref{class.init}).

\pnum
\indextext{destructor!implicit call}%
\indextext{destructor!program termination and}%
A destructor is invoked implicitly
\begin{itemize}
\item for a constructed object with static storage duration\iref{basic.stc.static} at program termination\iref{basic.start.term},

\item for a constructed object with thread storage duration\iref{basic.stc.thread} at thread exit,

\item for a constructed object with automatic storage duration\iref{basic.stc.auto} when the block in which an object is created exits\iref{stmt.dcl},

\item for a constructed temporary object when its lifetime ends\iref{conv.rval,class.temporary}.
\end{itemize}

\indextext{\idxcode{delete}!destructor and}%
\indextext{destructor!explicit call}%
In each case, the context of the invocation is the context of the construction of
the object. A destructor may also be invoked implicitly through use of a
\grammarterm{delete-expression}\iref{expr.delete} for a constructed object allocated
by a \grammarterm{new-expression}\iref{expr.new}; the context of the invocation is the
\grammarterm{delete-expression}.
\begin{note}
An array of class type contains several subobjects for each of which
the destructor is invoked.
\end{note}
A destructor can also be invoked explicitly. A destructor is \term{potentially invoked}
if it is invoked or as specified in~\ref{expr.new},
\ref{stmt.return}, \ref{dcl.init.aggr},
\ref{class.base.init}, and~\ref{except.throw}.
A program is ill-formed if a destructor that is potentially invoked is deleted
or not accessible from the context of the invocation.

\pnum
At the point of definition of a virtual destructor (including an implicit
definition), the non-array deallocation function is
determined as if for the expression \tcode{delete this} appearing in a
non-virtual destructor of the destructor's class (see~\ref{expr.delete}).
If the lookup fails or if the deallocation function has
a deleted definition\iref{dcl.fct.def}, the program is ill-formed.
\begin{note}
This assures that a deallocation function corresponding to the dynamic type of an
object is available for the
\grammarterm{delete-expression}\iref{class.free}.
\end{note}

\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor is specified by a
\tcode{\~{}}
followed by a
\grammarterm{type-name} or \grammarterm{computed-type-specifier}
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions\iref{class.mfct};
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type (including when
the destructor is invoked via a null pointer value), the program has
undefined behavior.
\begin{note}
Invoking \keyword{delete} on a null pointer does not call the
destructor; see \ref{expr.delete}.
\end{note}
\begin{example}
\begin{codeblock}
struct B {
  virtual ~B() { }
};
struct D : B {
  ~D() { }
};

D D_object;
typedef B B_alias;
B* B_ptr = &D_object;

void f() {
  D_object.B::~B();             // calls \tcode{B}'s destructor
  B_ptr->~B();                  // calls \tcode{D}'s destructor
  B_ptr->~B_alias();            // calls \tcode{D}'s destructor
  B_ptr->B_alias::~B();         // calls \tcode{B}'s destructor
  B_ptr->B_alias::~B_alias();   // calls \tcode{B}'s destructor
}
\end{codeblock}
\end{example}
\begin{note}
An explicit destructor call must always be written using
a member access operator\iref{expr.ref} or a \grammarterm{qualified-id}\iref{expr.prim.id.qual};
in particular, the
\grammarterm{unary-expression}
\tcode{\~{}X()}
in a member function is not an explicit destructor call\iref{expr.unary.op}.
\end{note}

\pnum
\begin{note}
\indextext{object!destructor and placement of}%
Explicit calls of destructors are rarely needed.
One use of such calls is for objects placed at specific
addresses using a placement
\grammarterm{new-expression}.
Such use of explicit placement and destruction of objects can be necessary
to cope with dedicated hardware resources and for writing memory management
facilities.
\begin{example}
\begin{codeblock}
void* operator new(std::size_t, void* p) { return p; }
struct X {
  X(int);
  ~X();
};
void f(X* p);

void g() {                      // rare, specialized use:
  char* buf = new char[sizeof(X)];
  X* p = new(buf) X(222);       // use \tcode{buf[]} and initialize
  f(p);
  p->X::~X();                   // cleanup
}
\end{codeblock}
\end{example}
\end{note}

\pnum
Once a destructor is invoked for an object, the object's lifetime ends;
the behavior is undefined if the destructor is invoked
for an object whose lifetime has ended\iref{basic.life}.
\begin{example}
If the destructor for an object with automatic storage duration is explicitly invoked,
and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undefined.
\end{example}

\pnum
\begin{note}
\indextext{fundamental type!destructor and}%
The notation for explicit call of a destructor can be used for any scalar type
name\iref{expr.prim.id.dtor}.
Allowing this makes it possible to write code without having to know if a
destructor exists for a given type.
For example:
\begin{codeblock}
typedef int I;
I* p;
p->I::~I();
\end{codeblock}
\end{note}

\pnum
A destructor shall not be a coroutine.

\rSec2[class.conv]{Conversions}

\rSec3[class.conv.general]{General}

\pnum
\indextext{conversion!class}%
\indextext{constructor, conversion by|see{conversion, user-defined}}%
\indextext{conversion function|see{conversion, user-defined}}%
\indextext{conversion!implicit}%
Type conversions of class objects can be specified by constructors and
by conversion functions.
These conversions are called
\defnx{user-defined conversions}{conversion!user-defined}
and are used for implicit type conversions\iref{conv},
for initialization\iref{dcl.init},
and for explicit type conversions\iref{expr.type.conv,expr.cast,
expr.static.cast}.

\pnum
User-defined conversions are applied only where they are unambiguous\iref{class.member.lookup,class.conv.fct}.
Conversions obey the access control rules\iref{class.access}.
Access control is applied after ambiguity resolution\iref{basic.lookup}.

\pnum
\begin{note}
See~\ref{over.match} for a discussion of the use of conversions in function calls.
\end{note}

\pnum
\indextext{conversion!implicit user-defined}%
At most one user-defined conversion (constructor or conversion function)
is implicitly applied to a single value.
\begin{example}
\begin{codeblock}
struct X {
  operator int();
};

struct Y {
  operator X();
};

Y a;
int b = a;          // error: no viable conversion (\tcode{a.operator X().operator int()} not considered)
int c = X(a);       // OK, \tcode{a.operator X().operator int()}
\end{codeblock}
\end{example}

\rSec3[class.conv.ctor]{Conversion by constructor}%
\indextext{conversion!user-defined}%

\pnum
A constructor that is not explicit\iref{dcl.fct.spec}
specifies a conversion from
the types of its parameters (if any)
to the type of its class.
\begin{example}
\indextext{Jessie}%
\begin{codeblock}
struct X {
    X(int);
    X(const char*, int = 0);
    X(int, int);
};

void f(X arg) {
  X a = 1;          // \tcode{a = X(1)}
  X b = "Jessie";   // \tcode{b = X("Jessie",0)}
  a = 2;            // \tcode{a = X(2)}
  f(3);             // \tcode{f(X(3))}
  f({1, 2});        // \tcode{f(X(1,2))}
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
An explicit constructor constructs objects just like non-explicit
constructors, but does so only where the direct-initialization syntax\iref{dcl.init}
or where casts\iref{expr.static.cast,expr.cast} are explicitly
used; see also~\ref{over.match.copy}.
A default constructor can be an explicit constructor; such a constructor
will be used to perform default-initialization
or value-initialization\iref{dcl.init}.
\begin{example}
\begin{codeblock}
struct Z {
  explicit Z();
  explicit Z(int);
  explicit Z(int, int);
};

Z a;                            // OK, default-initialization performed
Z b{};                          // OK, direct initialization syntax used
Z c = {};                       // error: copy-list-initialization
Z a1 = 1;                       // error: no implicit conversion
Z a3 = Z(1);                    // OK, direct initialization syntax used
Z a2(1);                        // OK, direct initialization syntax used
Z* p = new Z(1);                // OK, direct initialization syntax used
Z a4 = (Z)1;                    // OK, explicit cast used
Z a5 = static_cast<Z>(1);       // OK, explicit cast used
Z a6 = { 3, 4 };                // error: no implicit conversion
\end{codeblock}
\end{example}
\end{note}

\rSec3[class.conv.fct]{Conversion functions}%
\indextext{function!conversion}%
\indextext{fundamental type conversion|see{conversion, user-defined}}%
\indextext{conversion!user-defined}%

\begin{bnf}
\nontermdef{conversion-function-id}\br
    \keyword{operator} conversion-type-id
\end{bnf}

\begin{bnf}
\nontermdef{conversion-type-id}\br
    type-specifier-seq \opt{conversion-declarator}
\end{bnf}

\begin{bnf}
\nontermdef{conversion-declarator}\br
    ptr-operator \opt{conversion-declarator}
\end{bnf}

\pnum
A declaration
whose \grammarterm{declarator-id} has
an \grammarterm{unqualified-id} that is a \grammarterm{conversion-function-id}
declares a \defnadj{conversion}{function};
its \grammarterm{declarator} shall be
a function declarator\iref{dcl.fct} of the form
\begin{ncsimplebnf}
noptr-declarator parameters-and-qualifiers
\end{ncsimplebnf}
where the \grammarterm{noptr-declarator} consists solely of
an \grammarterm{id-expression},
an optional \grammarterm{attribute-specifier-seq}, and
optional surrounding parentheses, and
the \grammarterm{id-expression} has one of the following forms:
\begin{itemize}
\item
in a \grammarterm{member-declaration} that belongs to
the \grammarterm{member-specification} of a class or class template
but is not a friend declaration\iref{class.friend},
the \grammarterm{id-expression} is a \grammarterm{conversion-function-id};
\item
otherwise, the \grammarterm{id-expression} is a \grammarterm{qualified-id}
whose \grammarterm{unqualified-id} is a \grammarterm{conversion-function-id}.
\end{itemize}

\pnum
A conversion function  shall have no non-object parameters and
shall be a non-static member function of a class or class template \tcode{X};
its declared return type is the \grammarterm{conversion-type-id} and
it specifies a conversion from \tcode{X} to
the type specified by the \grammarterm{conversion-type-id},
interpreted as a \grammarterm{type-id}\iref{dcl.name}.
A \grammarterm{decl-specifier} in the \grammarterm{decl-specifier-seq}
of a conversion function (if any) shall not be
a \grammarterm{defining-type-specifier}.

\pnum
\begin{note}
A conversion function is never invoked for
implicit or explicit conversions of an object
to the same object type (or a reference to it),
to a base class of that type (or a reference to it),
or to \cv{}~\keyword{void}.
Even though never directly called to perform a conversion,
such conversion functions can be declared and can potentially
be reached through a call to a virtual conversion function in a base class.
\end{note}
\begin{example}
\begin{codeblock}
struct X {
  operator int();
  operator auto() -> short;     // error: trailing return type
};

void f(X a) {
  int i = int(a);
  i = (int)a;
  i = a;
}
\end{codeblock}
In all three cases the value assigned will be converted by
\tcode{X::operator int()}.
\end{example}

\pnum
A conversion function may be explicit\iref{dcl.fct.spec}, in which case it is only considered as a user-defined conversion for direct-initialization\iref{dcl.init}. Otherwise, user-defined conversions are not restricted to use in assignments and initializations.
\begin{example}
\begin{codeblock}
class Y { };
struct Z {
  explicit operator Y() const;
};

void h(Z z) {
  Y y1(z);          // OK, direct-initialization
  Y y2 = z;         // error: no conversion function candidate for copy-initialization
  Y y3 = (Y)z;      // OK, cast notation
}

void g(X a, X b) {
  int i = (a) ? 1+a : 0;
  int j = (a&&b) ? a+b : i;
  if (a) {
  }
}
\end{codeblock}
\end{example}

\pnum
The
\grammarterm{conversion-type-id}
shall not represent a function type nor an array type.
The
\grammarterm{conversion-type-id}
in a
\grammarterm{conversion-function-id}
is the longest sequence of
tokens that could possibly form a \grammarterm{conversion-type-id}.
\begin{note}
This prevents ambiguities between the declarator operator \tcode{*} and its expression
counterparts.
\begin{example}
\begin{codeblock}
&ac.operator int*i; // syntax error:
                    // parsed as: \tcode{\&(ac.operator int *)i}
                    // not as: \tcode{\&(ac.operator int)*i}
\end{codeblock}
The \tcode{*} is the pointer declarator and not the multiplication operator.
\end{example}
This rule also prevents ambiguities for attributes.
\begin{example}
\begin{codeblock}
operator int [[noreturn]] ();   // error: \tcode{noreturn} attribute applied to a type
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{conversion!inheritance of user-defined}%
\begin{note}
A conversion function in a derived class hides only
conversion functions in base classes that convert to the same type.
A conversion function template with a dependent return type hides only
templates in base classes that correspond to it\iref{class.member.lookup};
otherwise, it hides and is hidden as a non-template function.
Function overload resolution\iref{over.match.best} selects
the best conversion function to perform the conversion.
\begin{example}
\begin{codeblock}
struct X {
  operator int();
};

struct Y : X {
    operator char();
};

void f(Y& a) {
  if (a) {          // error: ambiguous between \tcode{X::operator int()} and \tcode{Y::operator char()}
  }
}
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{conversion!virtual user-defined}%
Conversion functions can be virtual.

\pnum
\indextext{conversion!deduced return type of user-defined}%
A conversion function template shall not have a
deduced return type\iref{dcl.spec.auto}.
\begin{example}
\begin{codeblock}
struct S {
  operator auto() const { return 10; }      // OK
  template<class T>
  operator auto() const { return 1.2; }     // error: conversion function template
};
\end{codeblock}
\end{example}

\rSec2[class.static]{Static members}%

\rSec3[class.static.general]{General}%
\indextext{member!static}%

\pnum
A static member \tcode{s} of class \tcode{X} may be referred to
using the \grammarterm{qualified-id} expression \tcode{X::s}; it is not
necessary to use the class member access syntax\iref{expr.ref} to
refer to a static member. A static member may be
referred to using the class member access syntax, in which case the
object expression is evaluated.
\begin{example}
\begin{codeblock}
struct process {
  static void reschedule();
};
process& g();

void f() {
  process::reschedule();        // OK, no object necessary
  g().reschedule();             // \tcode{g()} is called
}
\end{codeblock}
\end{example}

\pnum
Static members obey the usual class member access rules\iref{class.access}.
When used in the declaration of a class
member, the \keyword{static} specifier shall only be used in the member
declarations that appear within the \grammarterm{member-specification} of
the class definition.
\begin{note}
It cannot be specified in member declarations that appear in namespace scope.
\end{note}

\rSec3[class.static.mfct]{Static member functions}
\indextext{member function!static}%

\pnum
\begin{note}
The rules described in~\ref{class.mfct} apply to static member
functions.
\end{note}

\pnum
\begin{note}
A static member function does not have a \keyword{this}
pointer\iref{expr.prim.this}.
A static member function cannot be qualified with \keyword{const},
\tcode{volatile}, or \keyword{virtual}\iref{dcl.fct}.
\end{note}

\rSec3[class.static.data]{Static data members}
\indextext{member data!static}%

\pnum
A static data member is not part of the subobjects of a class. If a
static data member is declared \keyword{thread_local} there is one copy of
the member per thread. If a static data member is not declared
\keyword{thread_local} there is one copy of the data member that is shared by all
the objects of the class.

\pnum
A static data member shall not be \keyword{mutable}\iref{dcl.stc}.
A static data member shall not be a direct member\iref{class.mem}
of an unnamed\iref{class.pre} or local\iref{class.local} class or
of a (possibly indirectly) nested class\iref{class.nest} thereof.

\pnum
\indextext{initialization!static member}%
\indextext{definition!static member}%
The declaration of a non-inline
static data member in its class definition
is not a definition and may be of an incomplete type other than
\cv{}~\keyword{void}.
\indextext{operator use!scope resolution}%
\begin{note}
The \grammarterm{initializer} in the definition of a
static data member is in the scope of its
class\iref{basic.scope.class}.
\end{note}
\begin{example}
\begin{codeblock}
class process {
  static process* run_chain;
  static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
\end{codeblock}

The definition of the static data member \tcode{run_chain} of class
\tcode{process} inhabits the global scope; the notation
\tcode{process::run_chain} indicates that the member \tcode{run_chain}
is a member of class \tcode{process} and in the scope of class
\tcode{process}. In the static data member definition, the
\grammarterm{initializer} expression refers to the static data
member \tcode{running} of class \tcode{process}.
\end{example}

\begin{note}
Once the static data member has been defined, it exists even if
no objects of its class have been created.
\begin{example}
In the example above, \tcode{run_chain} and \tcode{running} exist even
if no objects of class \tcode{process} are created by the program.
\end{example}
The initialization and destruction of static data members is described in
\ref{basic.start.static}, \ref{basic.start.dynamic}, and \ref{basic.start.term}.
\end{note}

\pnum
If a non-volatile non-inline \keyword{const} static data member is
of integral or enumeration type,
its declaration in the class definition can specify a
\grammarterm{brace-or-equal-initializer} in which every
\grammarterm{initializer-clause} that is an \grammarterm{assignment-expression}
is a constant expression\iref{expr.const}.
The member shall still be defined in a namespace scope if
it is odr-used\iref{term.odr.use} in the program and the
namespace scope definition shall not contain an \grammarterm{initializer}.
The declaration of an inline static data member (which is a definition)
may specify a \grammarterm{brace-or-equal-initializer}. If the
member is declared with the \keyword{constexpr} specifier, it may be
redeclared in namespace scope with no initializer (this usage is
deprecated; see \ref{depr.static.constexpr}). Declarations of other
static data members shall not specify a \grammarterm{brace-or-equal-initializer}.

\pnum
\begin{note}
There is exactly one definition of a static data member
that is odr-used\iref{term.odr.use} in a valid program.
\end{note}

\pnum
\begin{note}
Static data members of a class in namespace scope have the linkage of the name of the class\iref{basic.link}.
\end{note}

\rSec2[class.bit]{Bit-fields}%
\indextext{bit-field}

\pnum
A \grammarterm{member-declarator} of the form
\begin{ncsimplebnf}
\opt{identifier} \opt{attribute-specifier-seq} \terminal{:} constant-expression \opt{brace-or-equal-initializer}
\end{ncsimplebnf}
\indextext{\idxcode{:}!bit-field declaration}%
\indextext{declaration!bit-field}%
specifies a bit-field.
The optional \grammarterm{attribute-specifier-seq} appertains
to the entity being declared.
A bit-field shall not be a static member.
\indextext{bit-field!type of}%
A bit-field shall have integral or (possibly cv-qualified) enumeration type;
the bit-field semantic property is not part of the type of the class member.
The \grammarterm{constant-expression} shall be an integral constant expression
with a value greater than or equal to zero and
is called the \defn{width} of the bit-field.
If the width of a bit-field is larger than
the width of the bit-field's type
(or, in case of an enumeration type, of its underlying type),
the extra bits are padding bits\iref{term.padding.bits}.
\indextext{allocation!implementation-defined bit-field}%
Allocation of bit-fields within a class object is
\impldef{allocation of bit-fields within a class object}.
\indextext{bit-field!implementation-defined alignment of}%
Alignment of bit-fields is \impldef{alignment of bit-fields within a class object}.
\indextext{layout!bit-field}%
Bit-fields are packed into some addressable allocation unit.
\begin{note}
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
\end{note}

\pnum
A declaration for a bit-field that omits the \grammarterm{identifier}
declares an \defnadj{unnamed}{bit-field}. Unnamed bit-fields are not
members and cannot be initialized.
An unnamed bit-field shall not be declared with a cv-qualified type.
\begin{note}
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
\end{note}
\indextext{bit-field!zero width of}%
\indextext{bit-field!alignment of}%
As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the width be zero.

\pnum
\indextext{bit-field!address of}%
The address-of operator \tcode{\&} shall not be applied to a bit-field,
so there are no pointers to bit-fields.
\indextext{restriction!bit-field}%
\indextext{restriction!address of bit-field}%
\indextext{restriction!pointer to bit-field}%
A non-const reference shall not bind to a bit-field\iref{dcl.init.ref}.
\begin{note}
If the initializer for a reference of type \keyword{const} \tcode{T\&} is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See~\ref{dcl.init.ref}.
\end{note}

\pnum
If a value of integral type (other than \tcode{bool}) is stored
into a bit-field of width $N$ and the value would be representable
in a hypothetical signed or unsigned integer type
with width $N$ and the same signedness as the bit-field's type,
the original value and the value of the bit-field compare equal.
If the value \tcode{true} or \tcode{false} is stored into a bit-field of
type \tcode{bool} of any size (including a one bit bit-field), the
original \tcode{bool} value and the value of the bit-field compare
equal. If a value of an enumeration type is stored into a bit-field of the
same type and the width is large
enough to hold all the values of that enumeration type\iref{dcl.enum},
the original value and the value of the bit-field compare equal.
\begin{example}
\begin{codeblock}
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              // yields \tcode{true}
    { @\commentellip@ }
}
\end{codeblock}
\end{example}

\rSec2[class.free]{Allocation and deallocation functions}%
\indextext{free store}%

\pnum
\indextext{\idxcode{new}!type of}%
\indextext{allocation function!class-specific}%
Any allocation function for a class
\tcode{T}
is a static member (even if not explicitly declared
\keyword{static}).

\pnum
\begin{example}
\begin{codeblock}
class Arena;
struct B {
  void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};

Arena*  ap;
void foo(int i) {
  new (ap) D1;      // calls \tcode{B::operator new(std::size_t, Arena*)}
  new D1[i];        // calls \tcode{::operator new[](std::size_t)}
  new D1;           // error: \tcode{::operator new(std::size_t)} hidden
}
\end{codeblock}
\end{example}

\pnum
\indextext{\idxcode{delete}!type of}%
\indextext{deallocation function!class-specific}%
Any deallocation function for a class
\tcode{X}
is a static member (even if not explicitly declared
\keyword{static}).
\begin{example}
\begin{codeblock}
class X {
  void operator delete(void*);
  void operator delete[](void*, std::size_t);
};

class Y {
  void operator delete(void*, std::size_t);
  void operator delete[](void*);
};
\end{codeblock}
\end{example}

\pnum
Since member allocation and deallocation functions are
\keyword{static}
they cannot be virtual.
\begin{note}
However, when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an object of class type with a virtual destructor,
because the deallocation function is chosen by the destructor
of the dynamic type of the object, the effect is the same in that case.
\begin{example}
\begin{codeblock}
struct B {
  virtual ~B();
  void operator delete(void*, std::size_t);
};

struct D : B {
  void operator delete(void*);
};

struct E : B {
  void log_deletion();
  void operator delete(E *p, std::destroying_delete_t) {
    p->log_deletion();
    p->~E();
    ::operator delete(p);
  }
};

void f() {
  B* bp = new D;
  delete bp;        // 1: uses \tcode{D::operator delete(void*)}
  bp = new E;
  delete bp;        // 2: uses \tcode{E::operator delete(E*, std::destroying_delete_t)}
}
\end{codeblock}
Here, storage for the object of class
\tcode{D}
is deallocated by
\tcode{D::operator delete()},
and
the object of class \tcode{E} is destroyed
and its storage is deallocated
by \tcode{E::operator delete()},
due to the virtual destructor.
\end{example}
\end{note}
\begin{note}
Virtual destructors have no effect on the deallocation function actually
called when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an array of objects of class type.
\begin{example}
\begin{codeblock}
struct B {
  virtual ~B();
  void operator delete[](void*, std::size_t);
};

struct D : B {
  void operator delete[](void*, std::size_t);
};

void f(int i) {
  D* dp = new D[i];
  delete [] dp;     // uses \tcode{D::operator delete[](void*, std::size_t)}
  B* bp = new D[i];
  delete[] bp;      // undefined behavior
}
\end{codeblock}
\end{example}
\end{note}

\pnum
Access to the deallocation function is checked statically,
even if a different one is actually executed.
\begin{example}
For the call on line ``// 1'' above,
if
\tcode{B::operator delete()}
had been private, the delete expression would have been ill-formed.
\end{example}

\pnum
\begin{note}
If a deallocation function has no explicit \grammarterm{noexcept-specifier}, it
has a non-throwing exception specification\iref{except.spec}.
\end{note}

\rSec2[class.nest]{Nested class declarations}%
\indextext{definition!nested class}%

\pnum
A class can be declared within another class. A class declared within
another is called a \defnadj{nested}{class}.
\begin{note}
See~\ref{expr.prim.id} for restrictions on the use of non-static data
members and non-static member functions.
\end{note}

\begin{example}
\begin{codeblock}
int x;
int y;

struct enclose {
  int x;
  static int s;

  struct inner {
    void f(int i) {
      int a = sizeof(x);        // OK, operand of sizeof is an unevaluated operand
      x = i;                    // error: assign to \tcode{enclose::x}
      s = i;                    // OK, assign to \tcode{enclose::s}
      ::x = i;                  // OK, assign to global \tcode{x}
      y = i;                    // OK, assign to global \tcode{y}
    }
    void g(enclose* p, int i) {
      p->x = i;                 // OK, assign to \tcode{enclose::x}
    }
  };
};

inner* p = 0;                   // error: \tcode{inner} not found
\end{codeblock}
\end{example}

\pnum
\begin{note}
Nested classes can be defined
either in the enclosing class or in an enclosing namespace;
member functions and static data members of a nested class can be
defined either in the nested class or in an enclosing namespace scope.
\begin{example}
\begin{codeblock}
struct enclose {
  struct inner {
    static int x;
    void f(int i);
  };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { @\commentellip@ }

class E {
  class I1;                     // forward declaration of nested class
  class I2;
  class I1 { };                 // definition of nested class
};
class E::I2 { };                // definition of nested class
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{friend function!nested class}%
A friend function\iref{class.friend} defined
within a nested class has no special access rights to
members of an enclosing class.

\rSec1[class.union]{Unions}%

\rSec2[class.union.general]{General}%
\indextext{\idxcode{union}}

\pnum
A \defn{union} is a class defined with the \grammarterm{class-key}
\keyword{union}.

\pnum
In a union,
a non-static data member is \defnx{active}{active!union member}
if its name refers to an object
whose lifetime has begun and has not ended\iref{basic.life}.
At most one of the non-static data members of an object of union type
can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time.
\begin{note}
One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence\iref{class.mem}, and
if a non-static data member of an object of this standard-layout union type
is active and is one of the standard-layout structs,
the common initial sequence of any of the standard-layout struct members can be inspected;
see~\ref{class.mem}.
\end{note}

\pnum
The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a non-union class.
\begin{note}
A union object and its non-static data members are
pointer-interconvertible\iref{basic.compound,expr.static.cast}.
As a consequence, all non-static data members of a
union object have the same address.
\end{note}

\pnum
\indextext{member function!\idxcode{union}}%
\indextext{constructor!\idxcode{union}}%
\indextext{destructor!\idxcode{union}}%
A union can have member functions (including constructors and destructors),
\indextext{restriction!\idxcode{union}}%
but it shall not have virtual\iref{class.virtual} functions. A union shall not have
base classes. A union shall not be used as a base class.
\indextext{restriction!\idxcode{union}}%
If a union contains a non-static data member of
reference type, the program is ill-formed.
\begin{note}
If any non-static data member of a union has a non-trivial
copy constructor,
move constructor\iref{class.copy.ctor},
copy assignment operator, or
move assignment operator\iref{class.copy.assign},
the corresponding member function
of the union must be user-provided or it will
be implicitly deleted\iref{dcl.fct.def.delete} for the union.
\begin{example}
Consider the following union:
\begin{codeblock}
union U {
  int i;
  float f;
  std::string s;
};
\end{codeblock}
Since \tcode{std::string}\iref{string.classes} declares non-trivial versions of all of the special
member functions, \tcode{U} will have an implicitly deleted
copy/move constructor and copy/move assignment operator.
The default constructor and destructor of \tcode{U} are both trivial
even though \tcode{std::string} has
a non-trivial default constructor and a non-trivial destructor.
\end{example}
\end{note}

\pnum
When the left operand of an assignment operator
involves a member access expression\iref{expr.ref}
that nominates a union member,
it may begin the lifetime of that union member,
as described below.
For an expression \tcode{E},
define the set $S(\mathtt{E})$
of subexpressions of \tcode{E}
as follows:
\begin{itemize}
\item
If \tcode{E} is of the form \tcode{A.B},
$S(\mathtt{E})$ contains the elements of $S(\mathtt{A})$,
and also contains \tcode{A.B}
if \tcode{B} names a union member of a non-class, non-array type,
or of a class type with a trivial default constructor that is not deleted,
or an array of such types.
\item
If \tcode{E} is of the form \tcode{A[B]}
and is interpreted as a built-in array subscripting operator,
$S(\mathtt{E})$ is $S(\mathtt{A})$ if \tcode{A} is of array type,
$S(\mathtt{B})$ if \tcode{B} is of array type,
and empty otherwise.
\item
Otherwise, $S(\mathtt{E})$ is empty.
\end{itemize}
In an assignment expression of the form \tcode{E1 = E2}
that uses either the built-in assignment operator\iref{expr.assign}
or a trivial assignment operator\iref{class.copy.assign},
for each element \tcode{X} of $S($\tcode{E1}$)$ and
each anonymous union member \tcode{X}\iref{class.union.anon} that
is a member of a union and
has such an element as an immediate subobject (recursively),
if modification of \tcode{X} would have undefined behavior under~\ref{basic.life},
an object of the type of \tcode{X} is implicitly created
in the nominated storage;
no initialization is performed and
the beginning of its lifetime is sequenced after
the value computation of the left and right operands
and before the assignment.
\begin{note}
This ends the lifetime of the previously-active
member of the union, if any\iref{basic.life}.
\end{note}
\begin{example}
\begin{codeblock}
union A { int x; int y[4]; };
struct B { A a; };
union C { B b; int k; };
int f() {
  C c;                  // does not start lifetime of any union member
  c.b.a.y[3] = 4;       // OK, $S($\tcode{c.b.a.y[3]}$)$ contains \tcode{c.b} and \tcode{c.b.a.y};
                        // creates objects to hold union members \tcode{c.b} and \tcode{c.b.a.y}
  return c.b.a.y[3];    // OK, \tcode{c.b.a.y} refers to newly created object (see \ref{basic.life})
}

struct X { const int a; int b; };
union Y { X x; int k; };
void g() {
  Y y = { { 1, 2 } };   // OK, \tcode{y.x} is active union member\iref{class.mem}
  int n = y.x.a;
  y.k = 4;              // OK, ends lifetime of \tcode{y.x}, \tcode{y.k} is active member of union
  y.x.b = n;            // undefined behavior: \tcode{y.x.b} modified outside its lifetime,
                        // $S($\tcode{y.x.b}$)$ is empty because \tcode{X}'s default constructor is deleted,
                        // so union member \tcode{y.x}'s lifetime does not implicitly start
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
In cases where the above rule does not apply,
the active member of a union can only be changed by
the use of a placement \grammarterm{new-expression}.
\end{note}
\begin{example}
Consider an object \tcode{u} of a \keyword{union} type \tcode{U} having non-static data members
\tcode{m} of type \tcode{M} and \tcode{n} of type \tcode{N}. If \tcode{M} has a non-trivial
destructor and \tcode{N} has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of \tcode{u} can be safely switched from \tcode{m} to
\tcode{n} using the destructor and placement \grammarterm{new-expression} as follows:

\begin{codeblock}
u.m.~M();
new (&u.n) N;
\end{codeblock}
\end{example}

\rSec2[class.union.anon]{Anonymous unions}
\indextext{\idxcode{union}!anonymous}%

\pnum
\indextext{anonymous union!member|see{member, anonymous union}}%
\indextext{anonymous union!variable|see{variable, anonymous union}}%
A union of the form
\begin{ncsimplebnf}
\keyword{union} \terminal{\{} member-specification \terminal{\}} \terminal{;}
\end{ncsimplebnf}
is called an \defn{anonymous union}; it defines an unnamed type and
an unnamed object of that type called
an \defnx{anonymous union member}{member!anonymous union}
if it is a non-static data member or
an \defnx{anonymous union variable}{variable!anonymous union} otherwise.
\indextext{access control!anonymous \tcode{union}}%
\indextext{restriction!anonymous \tcode{union}}%
Each \grammarterm{member-declaration} in the \grammarterm{member-specification}
of an anonymous union shall either define one or more public non-static data members or
be a \grammarterm{static_assert-declaration}.
Nested types, anonymous unions, and functions
shall not be declared within an anonymous union.
The names of the members of an anonymous union
are bound in the scope inhabited by the union declaration.
\begin{example}
\begin{codeblock}
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
\end{codeblock}

Here \tcode{a} and \tcode{p} are used like ordinary (non-member)
variables, but since they are union members they have the same address.
\end{example}

\pnum
\indextext{\idxcode{union}!global anonymous}%
\indextext{scope!anonymous \tcode{union} at namespace}%
An anonymous union declared in the scope of a namespace with external linkage
shall use the \grammarterm{storage-class-specifier} \keyword{static}.
Anonymous unions declared at block scope shall not use a \grammarterm{storage-class-specifier}
that is not permitted in the declaration of a block variable.
An anonymous union declaration at class scope shall not have
a \grammarterm{storage-class-specifier}.

\pnum
\begin{note}
A union for which objects, pointers, or references are declared is not an anonymous union.
\begin{example}
\begin{codeblock}
void f() {
  union { int aa; char* p; } obj, *ptr = &obj;
  aa = 1;           // error
  ptr->aa = 1;      // OK
}
\end{codeblock}

The assignment to plain \tcode{aa} is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
\end{example}
\end{note}
\begin{note}
Initialization of unions with no user-declared constructors is described
in~\ref{dcl.init.aggr}.
\end{note}

\pnum
\indextext{class!variant member of}%
A \defnadj{union-like}{class} is a union or a class that has an anonymous union as a direct
member. A union-like class \tcode{X} has a set of \defnx{variant members}{variant member}.
If \tcode{X} is a union, a non-static data member of \tcode{X} that is not an anonymous
union is a variant member of \tcode{X}. In addition, a non-static data member of an
anonymous union that is a member of \tcode{X} is also a variant member of \tcode{X}.
At most one variant member of a union may have a default member initializer.
\begin{example}
\begin{codeblock}
union U {
  int x = 0;
  union {
    int k;
  };
  union {
    int z;
    int y = 1;      // error: initialization for second variant member of \tcode{U}
  };
};
\end{codeblock}
\end{example}

\rSec1[class.local]{Local class declarations}
\indextext{declaration!local class}%
\indextext{definition!local class}%
\indextext{class!local|see{local class}}%

\pnum
A class can be declared within a function definition; such a class is
called a \defnadj{local}{class}.
\begin{note}
A declaration in a local class
cannot odr-use\iref{term.odr.use}
a local entity
from an
enclosing scope.
\end{note}
\begin{example}
\begin{codeblock}
int x;
void f() {
  static int s;
  int x;
  const int N = 5;
  extern int q();
  int arr[2];
  auto [y, z] = arr;

  struct local {
    int g() { return x; }       // error: odr-use of non-odr-usable variable \tcode{x}
    int h() { return s; }       // OK
    int k() { return ::x; }     // OK
    int l() { return q(); }     // OK
    int m() { return N; }       // OK, not an odr-use
    int* n() { return &N; }     // error: odr-use of non-odr-usable variable \tcode{N}
    int p() { return y; }       // error: odr-use of non-odr-usable structured binding \tcode{y}
  };
}

local* p = 0;                   // error: \tcode{local} not found
\end{codeblock}
\end{example}

\pnum
An enclosing function has no special access to members of the local
class; it obeys the usual access rules\iref{class.access}.
\indextext{member function!local class}%
Member functions of a local class shall be defined within their class
definition, if they are defined at all.

\pnum
\indextext{nested class!local class}%
\indextext{restriction!local class}%
A class nested within
a local class is a local class.
A member of a local class \tcode{X} shall be
declared only in the definition of \tcode{X} or,
if the member is a nested class,
in the nearest enclosing block scope of \tcode{X}.

\pnum
\indextext{restriction!static member local class}%
\begin{note}
A local class cannot have static data members\iref{class.static.data}.
\end{note}

\rSec1[class.derived]{Derived classes}%

\rSec2[class.derived.general]{General}%
\indextext{derived class|(}

\indextext{virtual base class|see{base class, virtual}}
\indextext{virtual function|see{function, virtual}}
\indextext{dynamic binding|see{function, virtual}}

\pnum
\indextext{base class}%
\indextext{inheritance}%
\indextext{multiple inheritance}%
A list of base classes can be specified in a class definition using
the notation:

\begin{bnf}
\nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
\nontermdef{base-specifier-list}\br
    base-specifier \opt{\terminal{...}}\br
    base-specifier-list \terminal{,} base-specifier \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
\nontermdef{base-specifier}\br
    \opt{attribute-specifier-seq} class-or-decltype\br
    \opt{attribute-specifier-seq} \keyword{virtual} \opt{access-specifier} class-or-decltype\br
    \opt{attribute-specifier-seq} access-specifier \opt{\keyword{virtual}} class-or-decltype
\end{bnf}

\begin{bnf}
\nontermdef{class-or-decltype}\br
    \opt{nested-name-specifier} type-name\br
    nested-name-specifier \keyword{template} simple-template-id\br
    computed-type-specifier
\end{bnf}

\indextext{specifier access|see{access specifier}}%
%
\begin{bnf}
\nontermdef{access-specifier}\br
    \keyword{private}\br
    \keyword{protected}\br
    \keyword{public}
\end{bnf}

The optional \grammarterm{attribute-specifier-seq} appertains to the \grammarterm{base-specifier}.

\pnum
\indextext{component name}%
The component names of a \grammarterm{class-or-decltype} are those of its
\grammarterm{nested-name-specifier},
\grammarterm{type-name}, and/or
\grammarterm{simple-template-id}.
\indextext{type!incomplete}%
A \grammarterm{class-or-decltype} shall denote
a (possibly cv-qualified) class type that is not
an incompletely defined class\iref{class.mem};
any cv-qualifiers are ignored.
The class denoted by the \grammarterm{class-or-decltype} of
a \grammarterm{base-specifier} is called a
\defnadj{direct}{base class}
for the class being defined.
\indextext{base class}%
\indextext{derivation|see{inheritance}}%
The lookup for the component name of
the \grammarterm{type-name} or \grammarterm{simple-template-id}
is type-only\iref{basic.lookup}.
A class \tcode{B} is a
base class of a class \tcode{D} if it is a direct base class of
\tcode{D} or a direct base class of one of \tcode{D}'s base classes.
A class is an \defnadj{indirect}{base class} of another if it is a base
class but not a direct base class. A class is said to be (directly or
indirectly) \term{derived} from its (direct or indirect) base
classes.
\begin{note}
See \ref{class.access} for the meaning of
\grammarterm{access-specifier}.
\end{note}
\indextext{access control!base class member}%
Members of a base class are also members of the derived class.
\begin{note}
Constructors of a base class can be explicitly inherited\iref{namespace.udecl}.
Base class members can be referred to in
expressions in the same manner as other members of the derived class,
unless their names are hidden or ambiguous\iref{class.member.lookup}.
\indextext{operator!scope resolution}%
The scope resolution operator \tcode{::}\iref{expr.prim.id.qual} can be used
to refer to a direct or indirect base member explicitly,
even if it is hidden in the derived class.
A derived class can itself serve as a base class subject to access
control; see~\ref{class.access.base}. A pointer to a derived class can be
implicitly converted to a pointer to an accessible unambiguous base
class\iref{conv.ptr}. An lvalue of a derived class type can be bound
to a reference to an accessible unambiguous base
class\iref{dcl.init.ref}.
\end{note}

\pnum
The \grammarterm{base-specifier-list} specifies the type of the
\term{base class subobjects} contained in an
object of the derived class type.
\begin{example}
\begin{codeblock}
struct Base {
  int a, b, c;
};
\end{codeblock}

\begin{codeblock}
struct Derived : Base {
  int b;
};
\end{codeblock}

\begin{codeblock}
struct Derived2 : Derived {
  int c;
};
\end{codeblock}

Here, an object of class \tcode{Derived2} will have a subobject of class
\tcode{Derived} which in turn will have a subobject of class
\tcode{Base}.
\end{example}

\pnum
A \grammarterm{base-specifier} followed by an ellipsis is a pack
expansion\iref{temp.variadic}.

\pnum
The order in which the base class subobjects are allocated in the most
derived object\iref{intro.object} is unspecified.
\begin{note}
\indextext{directed acyclic graph|see{DAG}}%
\indextext{lattice|see{DAG}}%
\indextext{lattice|see{subobject}}%
A derived class and its base class subobjects can be represented by a
directed acyclic graph (DAG) where an arrow means ``directly derived
from'' (see \fref{class.dag}).
An arrow need not have a physical representation in memory.
A DAG of subobjects is often referred to as a ``subobject lattice''.
\end{note}

\begin{importgraphic}
{Directed acyclic graph}
{class.dag}
{figdag.pdf}
\end{importgraphic}

\pnum
\begin{note}
Initialization of objects representing base classes can be specified in
constructors; see~\ref{class.base.init}.
\end{note}

\pnum
\begin{note}
A base class subobject can have a layout different
from the layout of a most derived object of the same type. A base class
subobject can have a polymorphic behavior\iref{class.cdtor}
different from the polymorphic behavior of a most derived object of the
same type. A base class subobject can be of zero size;
however, two subobjects that have the same class type and that belong to
the same most derived object cannot be allocated at the same
address\iref{intro.object}.
\end{note}

\rSec2[class.mi]{Multiple base classes}
\indextext{multiple inheritance}%
\indextext{base class}%

\pnum
A class can be derived from any number of base classes.
\begin{note}
The use of more than one direct base class is often called multiple inheritance.
\end{note}
\begin{example}
\begin{codeblock}
class A { @\commentellip@ };
class B { @\commentellip@ };
class C { @\commentellip@ };
class D : public A, public B, public C { @\commentellip@ };
\end{codeblock}
\end{example}

\pnum
\indextext{layout!class object}%
\indextext{initialization!order of}%
\begin{note}
The order of derivation is not significant except as specified by the
semantics of initialization by constructor\iref{class.base.init},
cleanup\iref{class.dtor}, and storage
layout\iref{class.mem,class.access.spec}.
\end{note}

\pnum
A class shall not be specified as a direct base class of a derived class
more than once.
\begin{note}
A class can be an indirect base class more than once and can be a direct
and an indirect base class. There are limited things that can be done
with such a class;
lookup that finds its non-static data members and member functions
in the scope of the derived class will be ambiguous.
However, the static members, enumerations and types can be
unambiguously referred to.
\end{note}
\begin{example}
\begin{codeblock}
class X { @\commentellip@ };
class Y : public X, public X { @\commentellip@ };             // error

\end{codeblock}
\begin{codeblock}
class L { public: int next;  @\commentellip@ };
class A : public L { @\commentellip@ };
class B : public L { @\commentellip@ };
class C : public A, public B { void f(); @\commentellip@ };   // well-formed
class D : public A, public L { void f(); @\commentellip@ };   // well-formed
\end{codeblock}
\end{example}

\pnum
\indextext{base class!virtual}%
A base class specifier that does not contain the keyword
\keyword{virtual} specifies a \defnadj{non-virtual}{base class}. A base
class specifier that contains the keyword \keyword{virtual} specifies a
\defnadj{virtual}{base class}. For each distinct occurrence of a
non-virtual base class in the class lattice of the most derived class,
the most derived object\iref{intro.object} shall contain a
corresponding distinct base class subobject of that type. For each
distinct base class that is specified virtual, the most derived object
shall contain a single base class subobject of that type.

\pnum
\begin{note}
For an object of class type \tcode{C}, each distinct occurrence of a
(non-virtual) base class \tcode{L} in the class lattice of \tcode{C}
corresponds one-to-one with a distinct \tcode{L} subobject within the
object of type \tcode{C}. Given the class \tcode{C} defined above, an
object of class \tcode{C} will have two subobjects of class \tcode{L} as
shown in \fref{class.nonvirt}.

\begin{importgraphic}
{Non-virtual base}
{class.nonvirt}
{fignonvirt.pdf}
\end{importgraphic}

In such lattices, explicit qualification can be used to specify which
subobject is meant. The body of function \tcode{C::f} can refer to the
member \tcode{next} of each \tcode{L} subobject:
\begin{codeblock}
void C::f() { A::next = B::next; }      // well-formed
\end{codeblock}
Without the \tcode{A::} or \tcode{B::} qualifiers, the definition of
\tcode{C::f} above would be ill-formed because of
ambiguity\iref{class.member.lookup}.
\end{note}

\pnum
\begin{note}
In contrast, consider the case with a virtual base class:
\begin{codeblock}
class V { @\commentellip@ };
class A : virtual public V { @\commentellip@ };
class B : virtual public V { @\commentellip@ };
class C : public A, public B { @\commentellip@ };
\end{codeblock}
\begin{importgraphic}
{Virtual base}
{class.virt}
{figvirt.pdf}
\end{importgraphic}
For an object \tcode{c} of class type \tcode{C}, a single subobject of
type \tcode{V} is shared by every base class subobject of \tcode{c} that has a
\keyword{virtual} base class of type \tcode{V}. Given the class \tcode{C}
defined above, an object of class \tcode{C} will have one subobject of
class \tcode{V}, as shown in \fref{class.virt}.
\indextext{DAG!multiple inheritance}%
\indextext{DAG!virtual base class}%
\end{note}

\pnum
\begin{note}
A class can have both virtual and non-virtual base classes of a given
type.
\begin{codeblock}
class B { @\commentellip@ };
class X : virtual public B { @\commentellip@ };
class Y : virtual public B { @\commentellip@ };
class Z : public B { @\commentellip@ };
class AA : public X, public Y, public Z { @\commentellip@ };
\end{codeblock}
For an object of class \tcode{AA}, all \keyword{virtual} occurrences of
base class \tcode{B} in the class lattice of \tcode{AA} correspond to a
single \tcode{B} subobject within the object of type \tcode{AA}, and
every other occurrence of a (non-virtual) base class \tcode{B} in the
class lattice of \tcode{AA} corresponds one-to-one with a distinct
\tcode{B} subobject within the object of type \tcode{AA}. Given the
class \tcode{AA} defined above, class \tcode{AA} has two subobjects of
class \tcode{B}: \tcode{Z}'s \tcode{B} and the virtual \tcode{B} shared
by \tcode{X} and \tcode{Y}, as shown in \fref{class.virtnonvirt}.

\indextext{DAG!virtual base class}%
\indextext{DAG!non-virtual base class}%
\indextext{DAG!multiple inheritance}%
\begin{importgraphic}
{Virtual and non-virtual base}
{class.virtnonvirt}
{figvirtnonvirt.pdf}
\end{importgraphic}
\end{note}

\rSec2[class.virtual]{Virtual functions}%
\indextext{function!virtual|(}%
\indextext{type!polymorphic}%

\pnum
A non-static member function is a \defnadj{virtual}{function}
if it is first declared with the keyword \keyword{virtual} or
if it overrides a virtual member function declared in a base class
(see below).
\begin{footnote}
The use of the \keyword{virtual} specifier in the
declaration of an overriding function is valid but redundant (has empty
semantics).
\end{footnote}
\begin{note}
Virtual functions support dynamic binding and object-oriented
programming.
\end{note}
A class with a virtual member function is called a \defnadj{polymorphic}{class}.
\begin{footnote}
If
all virtual functions are immediate functions,
the class is still polymorphic even if
its internal representation does not otherwise require
any additions for that polymorphic behavior.
\end{footnote}

\pnum
If a virtual member function $F$ is declared in a class $B$, and,
in a class $D$ derived (directly or indirectly) from $B$,
a declaration of a member function $G$
corresponds\iref{basic.scope.scope} to a declaration of $F$,
ignoring trailing \grammarterm{requires-clause}s,
\indextext{override|see{function, virtual, override}}%
then $G$ \defnx{overrides}{function!virtual!override}
\begin{footnote}
A function
with the same name but a different parameter list\iref{over}
as a virtual function is not necessarily virtual and
does not override. Access control\iref{class.access} is not considered in
determining overriding.
\end{footnote}
$F$.
For convenience, we say that any virtual function overrides itself.
\indextext{overrider!final}%
A virtual member function $V$ of a class object $S$ is a \defn{final
overrider} unless the most derived class\iref{intro.object} of which $S$ is a
base class subobject (if any) has another member function that overrides $V$.
In a derived class, if a virtual member function of a base class subobject
has more than one final overrider, the program is ill-formed.
\begin{example}
\begin{codeblock}
struct A {
  virtual void f();
};
struct B : virtual A {
  virtual void f();
};
struct C : B , virtual A {
  using A::f;
};

void foo() {
  C c;
  c.f();            // calls \tcode{B::f}, the final overrider
  c.C::f();         // calls \tcode{A::f} because of the using-declaration
}
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { };            // OK, \tcode{A::f} and \tcode{C::f} are the final overriders
                                // for the \tcode{B} and \tcode{C} subobjects, respectively
\end{codeblock}
\end{example}

\pnum
\begin{note}
A virtual member function does not have to be visible to be overridden,
for example,
\begin{codeblock}
struct B {
  virtual void f();
};
struct D : B {
  void f(int);
};
struct D2 : D {
  void f();
};
\end{codeblock}
the function \tcode{f(int)} in class \tcode{D} hides the virtual
function \tcode{f()} in its base class \tcode{B}; \tcode{D::f(int)} is
not a virtual function. However, \tcode{f()} declared in class
\tcode{D2} has the same name and the same parameter list as
\tcode{B::f()}, and therefore is a virtual function that overrides the
function \tcode{B::f()} even though \tcode{B::f()} is not visible in
class \tcode{D2}.
\end{note}

\pnum
If a virtual function \tcode{f} in some class \tcode{B} is marked with the
\grammarterm{virt-specifier} \keyword{final} and in a class \tcode{D} derived from \tcode{B}
a function \tcode{D::f} overrides \tcode{B::f}, the program is ill-formed.
\begin{example}
\begin{codeblock}
struct B {
  virtual void f() const final;
};

struct D : B {
  void f() const;   // error: \tcode{D::f} attempts to override \tcode{final} \tcode{B::f}
};
\end{codeblock}
\end{example}

\pnum
If a virtual function is marked with the \grammarterm{virt-specifier} \keyword{override} and
does not override a member function of a base class, the program is ill-formed.
\begin{example}
\begin{codeblock}
struct B {
  virtual void f(int);
};

struct D : B {
  virtual void f(long) override;        // error: wrong signature overriding \tcode{B::f}
  virtual void f(int) override;         // OK
};
\end{codeblock}
\end{example}

\pnum
A virtual function shall not have a trailing \grammarterm{requires-clause}\iref{dcl.decl}.
\begin{example}
\begin{codeblock}
template<typename T>
struct A {
  virtual void f() requires true;       // error: virtual function cannot be constrained\iref{temp.constr.decl}
};
\end{codeblock}
\end{example}

\pnum
The \grammarterm{ref-qualifier}, or lack thereof, of an overriding function
shall be the same as that of the overridden function.

\pnum
The return type of an overriding function shall be either identical to
the return type of the overridden function or \defnx{covariant}{return type!covariant} with
the classes of the functions. If a function \tcode{D::f} overrides a
function \tcode{B::f}, the return types of the functions are covariant
if they satisfy the following criteria:
\begin{itemize}
\item both are pointers to classes, both are lvalue references to
classes, or both are rvalue references to classes
\begin{footnote}
Multi-level pointers to classes or references to multi-level pointers to
classes are not allowed.%
\end{footnote}

\item the class in the return type of \tcode{B::f} is the same class as
the class in the return type of \tcode{D::f}, or is an unambiguous and
accessible direct or indirect base class of the class in the return type
of \tcode{D::f}

\item both pointers or references have the same cv-qualification and the
class type in the return type of \tcode{D::f} has the same
cv-qualification as or less cv-qualification than the class type in the
return type of \tcode{B::f}.
\end{itemize}

\pnum
If the class type in the covariant return type of \tcode{D::f} differs from that of
\tcode{B::f}, the class type in the return type of \tcode{D::f} shall be
complete at the locus\iref{basic.scope.pdecl} of the overriding declaration or shall be the
class type \tcode{D}. When the overriding function is called as the
final overrider of the overridden function, its result is converted to
the type returned by the (statically chosen) overridden
function\iref{expr.call}.
\begin{example}
\begin{codeblock}
class B { };
class D : private B { friend class Derived; };
struct Base {
  virtual void vf1();
  virtual void vf2();
  virtual void vf3();
  virtual B*   vf4();
  virtual B*   vf5();
  void f();
};

struct No_good : public Base {
  D*  vf4();        // error: \tcode{B} (base class of \tcode{D}) inaccessible
};

class A;
struct Derived : public Base {
    void vf1();     // virtual and overrides \tcode{Base::vf1()}
    void vf2(int);  // not virtual, hides \tcode{Base::vf2()}
    char vf3();     // error: invalid difference in return type only
    D*   vf4();     // OK, returns pointer to derived class
    A*   vf5();     // error: returns pointer to incomplete class
    void f();
};

void g() {
  Derived d;
  Base* bp = &d;                // standard conversion:
                                // \tcode{Derived*} to \tcode{Base*}
  bp->vf1();                    // calls \tcode{Derived::vf1()}
  bp->vf2();                    // calls \tcode{Base::vf2()}
  bp->f();                      // calls \tcode{Base::f()} (not virtual)
  B*  p = bp->vf4();            // calls \tcode{Derived::vf4()} and converts the
                                // result to \tcode{B*}
  Derived*  dp = &d;
  D*  q = dp->vf4();            // calls \tcode{Derived::vf4()} and does not
                                // convert the result to \tcode{B*}
  dp->vf2();                    // error: argument mismatch
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
The interpretation of the call of a virtual function depends on the type
of the object for which it is called (the dynamic type), whereas the
interpretation of a call of a non-virtual member function depends only
on the type of the pointer or reference denoting that object (the static
type)\iref{expr.call}.
\end{note}

\pnum
\begin{note}
The \keyword{virtual} specifier implies membership, so a virtual function
cannot be a non-member\iref{dcl.fct.spec} function. Nor can a virtual
function be a static member, since a virtual function call relies on a
specific object for determining which function to invoke. A virtual
function declared in one class can be declared a friend\iref{class.friend} in
another class.
\end{note}

\pnum
\indextext{definition!virtual function}%
A virtual function declared in a class shall be defined, or declared
pure\iref{class.abstract} in that class, or both; no diagnostic is
required\iref{basic.def.odr}.
\indextext{friend!\tcode{virtual} and}%

\pnum
\indextext{multiple inheritance!\tcode{virtual} and}%
\begin{example}
Here are some uses of virtual functions with multiple base classes:
\begin{codeblock}
struct A {
  virtual void f();
};

struct B1 : A {                 // note non-virtual derivation
  void f();
};

struct B2 : A {
  void f();
};

struct D : B1, B2 {             // \tcode{D} has two separate \tcode{A} subobjects
};

void foo() {
  D   d;
//\tcode{   A*  ap = \&d;}                  // would be ill-formed: ambiguous
  B1*  b1p = &d;
  A*   ap = b1p;
  D*   dp = &d;
  ap->f();                      // calls \tcode{D::B1::f}
  dp->f();                      // error: ambiguous
}
\end{codeblock}
In class \tcode{D} above there are two occurrences of class \tcode{A}
and hence two occurrences of the virtual member function \tcode{A::f}.
The final overrider of \tcode{B1::A::f} is \tcode{B1::f} and the final
overrider of \tcode{B2::A::f} is \tcode{B2::f}.
\end{example}

\pnum
\begin{example}
The following example shows a function that does not have a unique final
overrider:
\begin{codeblock}
struct A {
  virtual void f();
};

struct VB1 : virtual A {        // note virtual derivation
  void f();
};

struct VB2 : virtual A {
  void f();
};

struct Error : VB1, VB2 {       // error
};

struct Okay : VB1, VB2 {
  void f();
};
\end{codeblock}
Both \tcode{VB1::f} and \tcode{VB2::f} override \tcode{A::f} but there
is no overrider of both of them in class \tcode{Error}. This example is
therefore ill-formed. Class \tcode{Okay} is well-formed, however,
because \tcode{Okay::f} is a final overrider.
\end{example}

\pnum
\begin{example}
The following example uses the well-formed classes from above.
\begin{codeblock}
struct VB1a : virtual A {       // does not declare \tcode{f}
};

struct Da : VB1a, VB2 {
};

void foe() {
  VB1a*  vb1ap = new Da;
  vb1ap->f();                   // calls \tcode{VB2::f}
}
\end{codeblock}
\end{example}

\pnum
\indextext{operator!scope resolution}%
\indextext{virtual function call}%
Explicit qualification with the scope operator\iref{expr.prim.id.qual}
suppresses the virtual call mechanism.
\begin{example}
\begin{codeblock}
class B { public: virtual void f(); };
class D : public B { public: void f(); };

void D::f() { @\commentellip@ B::f(); }
\end{codeblock}

Here, the function call in
\tcode{D::f}
really does call
\tcode{B::f}
and not
\tcode{D::f}.
\end{example}

\pnum
A deleted function\iref{dcl.fct.def} shall
not override a function that is not deleted. Likewise,
a function that is not deleted shall not override a
deleted function.%
\indextext{function!virtual|)}

\pnum
A \keyword{consteval} virtual function shall not override
a virtual function that is not \keyword{consteval}.
A \keyword{consteval} virtual function shall not be overridden by
a virtual function that is not \keyword{consteval}.

\rSec2[class.abstract]{Abstract classes}%

\pnum
\begin{note}
The abstract class mechanism supports the notion of a general concept,
such as a \tcode{shape}, of which only more concrete variants, such as
\tcode{circle} and \tcode{square}, can actually be used. An abstract
class can also be used to define an interface for which derived classes
provide a variety of implementations.
\end{note}

\pnum
A virtual function is specified as
a \defnx{pure virtual function}{function!virtual!pure} by using a
\grammarterm{pure-specifier}\iref{class.mem} in the function declaration
in the class definition.
\begin{note}
Such a function might be inherited: see below.
\end{note}
A class is an \defnadj{abstract}{class}
if it has at least one pure virtual function.
\begin{note}
An abstract class can be used only as a base class of some other class;
no objects of an abstract class can be created
except as subobjects of a class
derived from it\iref{basic.def,class.mem}.
\end{note}
\indextext{definition!pure virtual function}%
A pure virtual function need be defined only if called with, or as if
with\iref{class.dtor}, the \grammarterm{qualified-id}
syntax\iref{expr.prim.id.qual}.
\begin{example}
\begin{codeblock}
class point { @\commentellip@ };
class shape {                   // abstract class
  point center;
public:
  point where() { return center; }
  void move(point p) { center=p; draw(); }
  virtual void rotate(int) = 0; // pure virtual
  virtual void draw() = 0;      // pure virtual
};
\end{codeblock}
\end{example}
\begin{note}
A function declaration cannot provide both a \grammarterm{pure-specifier}
and a definition.
\end{note}
\begin{example}
\begin{codeblock}
struct C {
  virtual void f() = 0 { };     // error
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
An abstract class type cannot be used
as a parameter or return type of
a function being defined\iref{dcl.fct} or called\iref{expr.call},
except as specified in \ref{dcl.type.simple}.
Further, an abstract class type cannot be used as
the type of an explicit type conversion\iref{expr.static.cast,
expr.reinterpret.cast,expr.const.cast},
because the resulting prvalue would be of abstract class type\iref{basic.lval}.
However, pointers and references to abstract class types
can appear in such contexts.
\end{note}

\pnum
\indextext{function!virtual!pure}%
A class is abstract if it has at least one pure virtual
function for which the final overrider is pure virtual.
\begin{example}
\begin{codeblock}
class ab_circle : public shape {
  int radius;
public:
  void rotate(int) { }
  // \tcode{ab_circle::draw()} is a pure virtual
};
\end{codeblock}

Since \tcode{shape::draw()} is a pure virtual function
\tcode{ab_circle::draw()} is a pure virtual by default. The alternative
declaration,
\begin{codeblock}
class circle : public shape {
  int radius;
public:
  void rotate(int) { }
  void draw();                  // a definition is required somewhere
};
\end{codeblock}
would make class \tcode{circle} non-abstract and a definition of
\tcode{circle::draw()} must be provided.
\end{example}

\pnum
\begin{note}
An abstract class can be derived from a class that is not abstract, and
a pure virtual function can override a virtual function which is not
pure.
\end{note}

\pnum
\indextext{class!constructor and abstract}%
Member functions can be called from a constructor (or destructor) of an
abstract class;
\indextext{virtual function call!undefined pure}%
the effect of making a virtual call\iref{class.virtual} to a pure
virtual function directly or indirectly for the object being created (or
destroyed) from such a constructor (or destructor) is undefined.%
\indextext{derived class|)}

\rSec1[class.access]{Member access control}%

\rSec2[class.access.general]{General}%
\indextext{access control|(}

\indextext{protection|see{access control}}
\indextext{\idxcode{private}|see{access control, \tcode{private}}}
\indextext{\idxcode{protected}|see{access control, \tcode{protected}}}
\indextext{\idxcode{public}|see{access control, \tcode{public}}}

\pnum
A member of a class can be
\begin{itemize}
\item
\indextext{access control!\idxcode{private}}%
private,
that is, it can be named only by members and friends
of the class in which it is declared;
\item
\indextext{access control!\idxcode{protected}}%
protected,
that is, it can be named only by members and friends
of the class in which it is declared, by classes derived from that class, and by their
friends (see~\ref{class.protected}); or
\item
\indextext{access control!\idxcode{public}}%
public,
that is, it can be named anywhere without access restriction.
\end{itemize}
\begin{note}
A constructor or destructor can be named by an expression\iref{basic.def.odr}
even though it has no name.
\end{note}

\pnum
A member of a class can also access all the members to which the class has access.
A local class of a member function may access
the same members that the member function itself may access.
\begin{footnote}
Access
permissions are thus transitive and cumulative to nested
and local classes.
\end{footnote}

\pnum
\indextext{access control!member name}%
\indextext{default access control|see{access control, default}}%
\indextext{access control!default}%
Members of a class defined with the keyword
\keyword{class}
are private by default.
Members of a class defined with the keywords
\keyword{struct} or \keyword{union}
are public by default.
\begin{example}
\begin{codeblock}
class X {
  int a;            // \tcode{X::a} is private by default
};

struct S {
  int a;            // \tcode{S::a} is public by default
};
\end{codeblock}
\end{example}

\pnum
Access control is applied uniformly to declarations and expressions.
\begin{note}
Access control applies to members nominated by
friend declarations\iref{class.friend} and
\grammarterm{using-declaration}{s}\iref{namespace.udecl}.
\end{note}
When a \grammarterm{using-declarator} is named,
access control is applied to it, not to the declarations that replace it.
For an overload set, access control is applied only to
the function selected by overload resolution.
\begin{example}
\begin{codeblock}
struct S {
  void f(int);
private:
  void f(double);
};

void g(S* sp) {
  sp->f(2);         // OK, access control applied after overload resolution
}
\end{codeblock}
\end{example}
\begin{note}
Because access control applies to the declarations named, if access control is applied to a
\grammarterm{typedef-name}, only the accessibility of the typedef or alias declaration itself is considered.
The accessibility of the entity referred to by the \grammarterm{typedef-name} is not considered.
\begin{example}
\begin{codeblock}
class A {
  class B { };
public:
  typedef B BB;
};

void f() {
  A::BB x;          // OK, typedef \tcode{A::BB} is public
  A::B y;           // access error, \tcode{A::B} is private
}
\end{codeblock}
\end{example}
\end{note}

\pnum
\begin{note}
Access control does not prevent members from being found by name lookup or
implicit conversions to base classes from being considered.
\end{note}
The interpretation of a given construct is
established without regard to access control.
If the interpretation
established makes use of inaccessible members or base classes,
the construct is ill-formed.

\pnum
All access controls in \ref{class.access} affect the ability to name a class member
from the declaration of a particular
entity, including parts of the declaration preceding the name of the entity
being declared and, if the entity is a class, the definitions of members of
the class appearing outside the class's \grammarterm{member-specification}{.}
\begin{note}
This access also applies to implicit references to constructors,
conversion functions, and destructors.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
class A {
  typedef int I;    // private member
  I f() pre(A::x > 0);
  friend I g(I) post(A::x <= 0);
  static I x;
  template<int> struct Q;
  template<int> friend struct R;
protected:
    struct B { };
};

A::I A::f() pre(A::x > 0) { return 0; }
A::I g(A::I p = A::x) post(A::x <= 0);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
template<A::I> struct A::Q { };
template<A::I> struct R { };

struct D: A::B, A { };
\end{codeblock}

Here, all the uses of
\tcode{A::I}
are well-formed because
\tcode{A::f},
\tcode{A::x}, and \tcode{A::Q}
are members of class
\tcode{A}
and
\tcode{g}
and \tcode{R} are friends of class
\tcode{A}.
This implies, for example, that access checking on the first use of
\tcode{A::I}
must be deferred until it is determined that this use of
\tcode{A::I}
is as the return type of a member of class
\tcode{A}.
Similarly, the use of \tcode{A::B} as a
\grammarterm{base-specifier} is well-formed because \tcode{D}
is derived from \tcode{A}, so checking of \grammarterm{base-specifier}{s}
must be deferred until the entire \grammarterm{base-specifier-list} has been seen.
\end{example}

\pnum
\indextext{argument!access checking and default}%
\indextext{access control!default argument}%
Access is checked for a default argument\iref{dcl.fct.default}
at the point of declaration,
rather than at any points of use of the default argument.
Access checking for default arguments in function templates and in
member functions of class templates is performed as described in~\ref{temp.inst}.

\pnum
Access for a default \grammarterm{template-argument}\iref{temp.param}
is checked in the context in which it appears rather than at any
points of use of it.
\begin{example}
\begin{codeblock}
class B { };
template <class T> class C {
protected:
  typedef T TT;
};

template <class U, class V = typename U::TT>
class D : public U { };

D <C<B> >* d;       // access error, \tcode{C::TT} is protected
\end{codeblock}
\end{example}

\rSec2[class.access.spec]{Access specifiers}%
\indextext{access specifier}

\pnum
Member declarations can be labeled by an
\grammarterm{access-specifier}\iref{class.derived}:

\begin{ncsimplebnf}
access-specifier \terminal{:} \opt{member-specification}
\end{ncsimplebnf}

An
\grammarterm{access-specifier}
specifies the access rules for members following it
until the end of the class or until another
\grammarterm{access-specifier}
is encountered.
\begin{example}
\begin{codeblock}
class X {
  int a;            // \tcode{X::a} is private by default: \keyword{class} used
public:
  int b;            // \tcode{X::b} is public
  int c;            // \tcode{X::c} is public
};
\end{codeblock}
\end{example}

\pnum
Any number of access specifiers is allowed and no particular order is required.
\begin{example}
\begin{codeblock}
struct S {
  int a;            // \tcode{S::a} is public by default: \keyword{struct} used
protected:
  int b;            // \tcode{S::b} is protected
private:
  int c;            // \tcode{S::c} is private
public:
  int d;            // \tcode{S::d} is public
};
\end{codeblock}
\end{example}

\pnum
When a member is redeclared within its class definition,
the access specified at its redeclaration shall
be the same as at its initial declaration.
\begin{example}
\begin{codeblock}
struct S {
  class A;
  enum E : int;
private:
  class A { };                  // error: cannot change access
  enum E: int { e0 };           // error: cannot change access
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
In a derived class, the lookup of a base class name will find the
injected-class-name instead of the name of the base class in the scope
in which it was declared. The injected-class-name might be less accessible
than the name of the base class in the scope in which it was declared.
\end{note}

\begin{example}
\begin{codeblock}
class A { };
class B : private A { };
class C : public B {
  A* p;             // error: injected-class-name \tcode{A} is inaccessible
  ::A* q;           // OK
};
\end{codeblock}
\end{example}

\rSec2[class.access.base]{Accessibility of base classes and base class members}%
\indextext{access control!base class}%
\indextext{access specifier}%
\indextext{base class!\idxcode{private}}%
\indextext{base class!\idxcode{protected}}%
\indextext{base class!\idxcode{public}}

\pnum
If a class is declared to be a base class\iref{class.derived} for another class using the
\keyword{public}
access specifier, the
public members of the base class are accessible as
public members of the derived class and
protected members of the base class are accessible as
protected members of the derived class.
If a class is declared to be a base class for another class using the
\keyword{protected}
access specifier, the
public and protected members of the base class are accessible as
protected members of the derived class.
If a class is declared to be a base class for another class using the
\keyword{private}
access specifier, the
public and protected
members of the base class are accessible as private
members of the derived class.
\begin{footnote}
As specified previously in \ref{class.access},
private members of a base class remain inaccessible even to derived classes
unless friend
declarations within the base class definition are used to grant access explicitly.
\end{footnote}

\pnum
In the absence of an
\grammarterm{access-specifier}
for a base class,
\keyword{public}
is assumed when the derived class is
defined with the \grammarterm{class-key}
\keyword{struct}
and
\keyword{private}
is assumed when the class is
defined with the \grammarterm{class-key}
\keyword{class}.
\begin{example}
\begin{codeblock}
class B { @\commentellip@ };
class D1 : private B { @\commentellip@ };
class D2 : public B { @\commentellip@ };
class D3 : B { @\commentellip@ };             // \tcode{B} private by default
struct D4 : public B { @\commentellip@ };
struct D5 : private B { @\commentellip@ };
struct D6 : B { @\commentellip@ };            // \tcode{B} public by default
class D7 : protected B { @\commentellip@ };
struct D8 : protected B { @\commentellip@ };
\end{codeblock}

Here
\tcode{B}
is a public base of
\tcode{D2},
\tcode{D4},
and
\tcode{D6},
a private base of
\tcode{D1},
\tcode{D3},
and
\tcode{D5},
and a protected base of
\tcode{D7}
and
\tcode{D8}.
\end{example}

\pnum
\begin{note}
A member of a private base class can be inaccessible as inherited,
but accessible directly.
Because of the rules on pointer conversions\iref{conv.ptr} and
explicit casts\iref{expr.type.conv,expr.static.cast,expr.cast},
a conversion from a pointer to a derived class to a pointer
to an inaccessible base class can be ill-formed if an implicit conversion
is used, but well-formed if an explicit cast is used.
\begin{example}
\begin{codeblock}
class B {
public:
  int mi;                       // non-static member
  static int si;                // static member
};
class D : private B {
};
class DD : public D {
  void f();
};

void DD::f() {
  mi = 3;                       // error: \tcode{mi} is private in \tcode{D}
  si = 3;                       // error: \tcode{si} is private in \tcode{D}
  ::B  b;
  b.mi = 3;                     // OK (\tcode{b.mi} is different from \tcode{this->mi})
  b.si = 3;                     // OK (\tcode{b.si} is different from \tcode{this->si})
  ::B::si = 3;                  // OK
  ::B* bp1 = this;              // error: \tcode{B} is a private base class
  ::B* bp2 = (::B*)this;        // OK with cast
  bp2->mi = 3;                  // OK, access through a pointer to \tcode{B}.
}
\end{codeblock}
\end{example}
\end{note}

\pnum
A base class
\tcode{B}
of
\tcode{N}
is
\defn{accessible}
at
\placeholder{R},
if
\begin{itemize}
\item
an invented public member of
\tcode{B}
would be a public member of
\tcode{N}, or
\item
\placeholder{R}
occurs in a direct member or friend of class
\tcode{N},
and an invented public member of
\tcode{B}
would be a private or protected member of
\tcode{N}, or
\item
\placeholder{R}
occurs in a direct member or friend of a class
\tcode{P}
derived from
\tcode{N},
and an invented public member of
\tcode{B}
would be a private or protected member of
\tcode{P}, or
\item
there exists a class
\tcode{S}
such that
\tcode{B}
is a base class of
\tcode{S}
accessible at
\placeholder{R}
and
\tcode{S}
is a base class of
\tcode{N}
accessible at
\placeholder{R}.
\end{itemize}

\begin{example}
\begin{codeblock}
class B {
public:
  int m;
};

class S: private B {
  friend class N;
};

class N: private S {
  void f() {
    B* p = this;    // OK because class \tcode{S} satisfies the fourth condition above: \tcode{B} is a base class of \tcode{N}
                    // accessible in \tcode{f()} because \tcode{B} is an accessible base class of \tcode{S} and \tcode{S} is an accessible
                    // base class of \tcode{N}.
  }
};
\end{codeblock}
\end{example}

\pnum
If a base class is accessible, one can implicitly convert a pointer to
a derived class to a pointer to that base class\iref{conv.ptr,conv.mem}.
\begin{note}
It follows that
members and friends of a class
\tcode{X}
can implicitly convert an
\tcode{X*}
to a pointer to a private or protected immediate base class of
\tcode{X}.
\end{note}
The access to a member is affected by the class in which the member is
named.
This naming class is
the class in whose scope name lookup performed a search that found the member.
\begin{note}
This class can be explicit, e.g., when a
\grammarterm{qualified-id}
is used, or implicit, e.g., when a class member access operator\iref{expr.ref} is used (including cases where an implicit
``\tcode{this->}''
is
added).
If both a class member access operator and a
\grammarterm{qualified-id}
are used to name the member (as in
\tcode{p->T::m}),
the class naming the member is the class denoted by the
\grammarterm{nested-name-specifier}
of the
\grammarterm{qualified-id}
(that is,
\tcode{T}).
\end{note}
A member
\tcode{m}
is accessible at the point
\placeholder{R}
when named in class
\tcode{N}
if
\begin{itemize}
\item
\tcode{m}
as a member of
\tcode{N}
is public, or
\item
\tcode{m}
as a member of
\tcode{N}
is private, and
\placeholder{R}
occurs in a direct member or friend of class
\tcode{N},
or
\item
\tcode{m}
as a member of
\tcode{N}
is protected, and
\placeholder{R}
occurs in a direct member or friend of class
\tcode{N},
or in a member of a class
\tcode{P}
derived from
\tcode{N},
where
\tcode{m}
as a member of
\tcode{P}
is public, private, or protected, or
\item
there exists a base class
\tcode{B}
of
\tcode{N}
that is accessible at
\placeholder{R},
and
\tcode{m}
is accessible at
\placeholder{R}
when named in class
\tcode{B}.
\begin{example}
\begin{codeblock}
class B;
class A {
private:
  int i;
  friend void f(B*);
};
class B : public A { };
void f(B* p) {
  p->i = 1;         // OK, \tcode{B*} can be implicitly converted to \tcode{A*}, and \tcode{f} has access to \tcode{i} in \tcode{A}
}
\end{codeblock}
\end{example}
\end{itemize}

\pnum
If a class member access operator, including an implicit
``\tcode{this->}'',
is used to access a non-static data member or non-static
member function, the reference is ill-formed if the
left operand (considered as a pointer in the
``\tcode{.}''
operator case) cannot be implicitly converted to a
pointer to the naming class of the right operand.
\begin{note}
This requirement is in addition to the requirement that
the member be accessible as named.
\end{note}

\rSec2[class.friend]{Friends}%
\indextext{friend function!access and}%
\indextext{access control!friend function}

\pnum
A friend of a class is a function or class that is
given permission to name the private and protected members of the class.
A class specifies its friends, if any, by way of friend declarations.
Such declarations give special access rights to the friends, but they
do not make the nominated friends members of the befriending class.
\begin{example}
The following example illustrates the differences between
members and friends:
\indextext{friend function!member function and}%

\begin{codeblock}
class X {
  int a;
  friend void friend_set(X*, int);
public:
  void member_set(int);
};

void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }

void f() {
  X obj;
  friend_set(&obj,10);
  obj.member_set(10);
}
\end{codeblock}
\end{example}

\pnum
\indextext{friend!class access and}%
Declaring a class to be a friend implies that private and
protected members of the class granting friendship can be named in the
\grammarterm{base-specifier}{s} and member declarations of the befriended
class.
\begin{example}
\begin{codeblock}
class A {
  class B { };
  friend class X;
};

struct X : A::B {               // OK, \tcode{A::B} accessible to friend
  A::B mx;                      // OK, \tcode{A::B} accessible to member of friend
  class Y {
    A::B my;                    // OK, \tcode{A::B} accessible to nested member of friend
  };
};
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
class X {
  enum { a=100 };
  friend class Y;
};

class Y {
  int v[X::a];                  // OK, \tcode{Y} is a friend of \tcode{X}
};

class Z {
  int v[X::a];                  // error: \tcode{X::a} is private
};
\end{codeblock}
\end{example}

\pnum
A friend declaration that does not declare a function
shall be a \grammarterm{friend-type-declaration}.

\begin{note}
A friend declaration can be the
\grammarterm{declaration} in
a \grammarterm{template-declaration}\iref{temp.pre,temp.friend}.
\end{note}
If a \grammarterm{friend-type-specifier} in a friend declaration
designates a (possibly
cv-qualified) class type, that class is declared as a friend; otherwise, the
\grammarterm{friend-type-specifier} is ignored.
\begin{example}
\begin{codeblock}
class C;
typedef C Ct;
class E;

class X1 {
  friend C;                     // OK, \tcode{class C} is a friend
};

class X2 {
  friend Ct;                    // OK, \tcode{class C} is a friend
  friend D;                     // error: \tcode{D} not found
  friend class D;               // OK, elaborated-type-specifier declares new class
};

template <typename ... Ts> class R {
  friend Ts...;
};

template <class... Ts, class... Us>
class R<R<Ts...>, R<Us...>> {
  friend Ts::Nested..., Us...;
};

R<C> rc;                        // \tcode{class C} is a friend of \tcode{R<C>}
R<C, E> rce;                    // classes \tcode{C} and \tcode{E} are friends of \tcode{R<C, E>}
R<int> Ri;                      // OK, ``\tcode{friend int;}'' is ignored

struct E { struct Nested; };

R<R<E>, R<C, int>> rr;          // \tcode{E::Nested} and \tcode{C} are friends of \tcode{R<R<E>, R<C, int>>}
\end{codeblock}
\end{example}

\pnum
\indextext{declaration!overloaded name and \tcode{friend}}%
\begin{note}
A friend declaration refers to an entity, not (all overloads of) a name.
A member function of a class
\tcode{X}
can be a friend of
a class
\tcode{Y}.
\indextext{member function!friend}%
\begin{example}
\begin{codeblock}
class Y {
  friend char* X::foo(int);
  friend X::X(char);            // constructors can be friends
  friend X::~X();               // destructors can be friends
};
\end{codeblock}
\end{example}
\end{note}

\pnum
\indextext{friend function!inline}%
A function may be defined in a friend declaration of a class if and only if the
class is a non-local class\iref{class.local} and the function name is unqualified.
\begin{example}
\begin{codeblock}
class M {
  friend void f() { }           // definition of global \tcode{f}, a friend of \tcode{M},
                                // not the definition of a member function
};
\end{codeblock}
\end{example}

\pnum
Such a function is implicitly an inline\iref{dcl.inline} function
if it is attached to the global module.
\begin{note}
If a friend function is defined outside a class,
it is not in the scope of the class.
\end{note}

\pnum
No
\grammarterm{storage-class-specifier}
shall appear in the
\grammarterm{decl-specifier-seq}
of a friend declaration.

\pnum
\indextext{friend!access specifier and}%
A member nominated by a friend declaration shall be accessible in the
class containing the friend declaration.
The meaning of the friend declaration is the same whether the friend declaration
appears in the private, protected, or public\iref{class.mem}
portion of the class
\grammarterm{member-specification}.

\pnum
\indextext{friend!inheritance and}%
Friendship is neither inherited nor transitive.
\begin{example}
\begin{codeblock}
class A {
  friend class B;
  int a;
};

class B {
  friend class C;
};

class C  {
  void f(A* p) {
    p->a++;         // error: \tcode{C} is not a friend of \tcode{A} despite being a friend of a friend
  }
};

class D : public B  {
  void f(A* p) {
    p->a++;         // error: \tcode{D} is not a friend of \tcode{A} despite being derived from a friend
  }
};
\end{codeblock}
\end{example}

\pnum
\indextext{local class!friend}%
\indextext{friend!local class and}%
\begin{note}
A friend declaration never binds any names\iref{dcl.meaning,dcl.type.elab}.
\end{note}
\begin{example}
\begin{codeblock}
// Assume \tcode{f} and \tcode{g} have not yet been declared.
void h(int);
template <class T> void f2(T);
namespace A {
  class X {
    friend void f(X);           // \tcode{A::f(X)} is a friend
    class Y {
      friend void g();          // \tcode{A::g} is a friend
      friend void h(int);       // \tcode{A::h} is a friend
                                // \tcode{::h} not considered
      friend void f2<>(int);    // \tcode{::f2<>(int)} is a friend
    };
  };

  // \tcode{A::f}, \tcode{A::g} and \tcode{A::h} are not visible here
  X x;
  void g() { f(x); }            // definition of \tcode{A::g}
  void f(X) { @\commentellip@ }       // definition of \tcode{A::f}
  void h(int) { @\commentellip@ }     // definition of \tcode{A::h}
  // \tcode{A::f}, \tcode{A::g} and \tcode{A::h} are visible here and known to be friends
}

using A::x;

void h() {
  A::f(x);
  A::X::f(x);                   // error: \tcode{f} is not a member of \tcode{A::X}
  A::X::Y::g();                 // error: \tcode{g} is not a member of \tcode{A::X::Y}
}
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
class X;
void a();
void f() {
  class Y;
  extern void b();
  class A {
  friend class X;   // OK, but \tcode{X} is a local class, not \tcode{::X}
  friend class Y;   // OK
  friend class Z;   // OK, introduces local class \tcode{Z}
  friend void a();  // error, \tcode{::a} is not considered
  friend void b();  // OK
  friend void c();  // error
  };
  X* px;            // OK, but \tcode{::X} is found
  Z* pz;            // error: no \tcode{Z} is found
}
\end{codeblock}
\end{example}

\rSec2[class.protected]{Protected member access}
\indextext{access control!\idxcode{protected}}%

\pnum
An additional access check beyond those described earlier in \ref{class.access}
is applied when a non-static data member or non-static member function is a
protected member of its naming class\iref{class.access.base}.
\begin{footnote}
This
additional check does not apply to other members,
e.g., static data members or enumerator member constants.
\end{footnote}
As described earlier, access to a protected member is granted because the
reference occurs in a friend or direct member of some class \tcode{C}. If the access is
to form a pointer to member\iref{expr.unary.op}, the
\grammarterm{nested-name-specifier} shall denote \tcode{C} or a class derived from
\tcode{C}. All other accesses involve a (possibly implicit) object
expression\iref{expr.ref}. In this case, the class of the object expression shall be
\tcode{C} or a class derived from \tcode{C}.
\begin{example}
\begin{codeblock}
class B {
protected:
  int i;
  static int j;
};

class D1 : public B {
};

class D2 : public B {
  friend void fr(B*,D1*,D2*);
  void mem(B*,D1*);
};

void fr(B* pb, D1* p1, D2* p2) {
  pb->i = 1;                    // error
  p1->i = 2;                    // error
  p2->i = 3;                    // OK (access through a \tcode{D2})
  p2->B::i = 4;                 // OK (access through a \tcode{D2}, even though naming class is \tcode{B})
  int B::* pmi_B = &B::i;       // error
  int B::* pmi_B2 = &D2::i;     // OK (type of \tcode{\&D2::i} is \tcode{int B::*})
  B::j = 5;                     // error: not a friend of naming class \tcode{B}
  D2::j = 6;                    // OK (because refers to static member)
}

void D2::mem(B* pb, D1* p1) {
  pb->i = 1;                    // error
  p1->i = 2;                    // error
  i = 3;                        // OK (access through \keyword{this})
  B::i = 4;                     // OK (access through \keyword{this}, qualification ignored)
  int B::* pmi_B = &B::i;       // error
  int B::* pmi_B2 = &D2::i;     // OK
  j = 5;                        // OK (because \tcode{j} refers to static member)
  B::j = 6;                     // OK (because \tcode{B::j} refers to static member)
}

void g(B* pb, D1* p1, D2* p2) {
  pb->i = 1;                    // error
  p1->i = 2;                    // error
  p2->i = 3;                    // error
}
\end{codeblock}
\end{example}

\rSec2[class.access.virt]{Access to virtual functions}%
\indextext{access control!virtual function}

\pnum
The access rules\iref{class.access} for a virtual function are determined by its declaration
and are not affected by the rules for a function that later overrides it.
\begin{example}
\begin{codeblock}
class B {
public:
  virtual int f();
};

class D : public B {
private:
  int f();
};

void f() {
  D d;
  B* pb = &d;
  D* pd = &d;

  pb->f();                      // OK, \tcode{B::f()} is public, \tcode{D::f()} is invoked
  pd->f();                      // error: \tcode{D::f()} is private
}
\end{codeblock}
\end{example}

\pnum
Access is checked at the call point using the type of the expression used
to denote the object for which the member function is called
(\tcode{B*}
in the example above).
The access of the member function in the class in which it was defined
(\tcode{D}
in the example above) is in general not known.

\rSec2[class.paths]{Multiple access}%
\indextext{access control!multiple access}

\pnum
If a declaration can be reached by several paths through a multiple inheritance
graph, the access is that of the path that gives most access.
\begin{example}
\begin{codeblock}
class W { public: void f(); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A, public B {
  void f() { W::f(); }          // OK
};
\end{codeblock}

Since
\tcode{W::f()}
is available to
\tcode{C::f()}
along the public path through
\tcode{B},
access is allowed.
\end{example}

\rSec2[class.access.nest]{Nested classes}%
\indextext{access control!nested class}%
\indextext{member function!nested class}

\pnum
A nested class is a member and as such has the same access rights as any other member.
The members of an enclosing class have no special access to members of a nested
class; the usual access rules\iref{class.access} shall be obeyed.
\begin{example}
\begin{codeblock}
class E {
  int x;
  class B { };

  class I {
    B b;                        // OK, \tcode{E::I} can access \tcode{E::B}
    int y;
    void f(E* p, int i) {
      p->x = i;                 // OK, \tcode{E::I} can access \tcode{E::x}
    }
  };

  int g(I* p) {
    return p->y;                // error: \tcode{I::y} is private
  }
};
\end{codeblock}
\end{example}
\indextext{access control|)}

\rSec1[class.init]{Initialization}%

\rSec2[class.init.general]{General}%
\indextext{initialization!class object|(}%
\indextext{initialization!default constructor and}%
\indextext{initialization!constructor and}

\pnum
When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
\tcode{()},
the object is initialized as specified in~\ref{dcl.init}.

\pnum
An object of class type (or array thereof) can be explicitly initialized;
see~\ref{class.expl.init} and~\ref{class.base.init}.

\pnum
\indextext{order of execution!constructor and array}%
When an array of class objects is initialized
(either explicitly or implicitly) and the elements are initialized by constructor,
the constructor shall be called for each element of the array,
following the subscript order; see~\ref{dcl.array}.
\begin{note}
Destructors for the array elements are called in reverse order of their
construction.
\end{note}

\rSec2[class.expl.init]{Explicit initialization}%
\indextext{initialization!explicit}%
\indextext{initialization!constructor and}%

\pnum
An object of class type can be initialized with a parenthesized
\grammarterm{expression-list},
where the
\grammarterm{expression-list}
is construed as an argument list for a constructor
that is called to initialize the object.
Alternatively, a single
\grammarterm{assignment-expression}
can be specified as an
\grammarterm{initializer}
using the
\tcode{=}
form of initialization.
Either direct-initialization semantics or copy-initialization semantics apply;
see~\ref{dcl.init}.
\begin{example}
\begin{codeblock}
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   // initialized by calling \tcode{complex(double)} with argument \tcode{1}
complex b = a;                  // initialized as a copy of \tcode{a}
complex c = complex(1,2);       // initialized by calling \tcode{complex(double,double)} with arguments \tcode{1} and \tcode{2}
complex d = sqrt(b,c);          // initialized by calling \tcode{sqrt(complex,complex)} with \tcode{d} as its result object
complex e;                      // initialized by calling \tcode{complex()}
complex f = 3;                  // initialized by calling \tcode{complex(double)} with argument \tcode{3}
complex g = { 1, 2 };           // initialized by calling \tcode{complex(double, double)} with arguments \tcode{1} and \tcode{2}
\end{codeblock}
\end{example}
\begin{note}
\indextext{initialization!overloaded assignment and}%
Overloading of the assignment operator\iref{over.assign}
has no effect on initialization.
\end{note}

\pnum
\indextext{initialization!array of class objects}%
\indextext{constructor!array of class objects and}%
An object of class type can also be initialized by a
\grammarterm{braced-init-list}. List-initialization semantics apply;
see~\ref{dcl.init} and~\ref{dcl.init.list}.
\begin{example}
\begin{codeblock}
complex v[6] = { 1, complex(1,2), complex(), 2 };
\end{codeblock}

Here,
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{v[0]}
and
\tcode{v[3]},
\tcode{complex::complex(\brk{}double, double)}
is called for the initialization of
\tcode{v[1]},
\tcode{complex::complex()}
is called for the initialization of
\tcode{v[2]},
\tcode{v[4]},
and
\tcode{v[5]}.
For another example,

\begin{codeblock}
struct X {
  int i;
  float f;
  complex c;
} x = { 99, 88.8, 77.7 };
\end{codeblock}

Here,
\tcode{x.i}
is initialized with 99,
\tcode{x.f}
is initialized with 88.8, and
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{x.c}.
\end{example}
\begin{note}
Braces can be elided in the
\grammarterm{initializer-list}
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see~\ref{dcl.init.aggr}.
\end{note}

\pnum
\begin{note}
If
\tcode{T}
is a class type with no default constructor,
any initializing declaration of an object of type
\tcode{T}
(or array thereof) is ill-formed if no
\grammarterm{initializer}
is explicitly specified (see~\ref{class.init} and~\ref{dcl.init}).
\end{note}

\pnum
\begin{note}
\indextext{order of execution!constructor and static data members}%
The order in which objects with static or thread storage duration
are initialized is described in~\ref{basic.start.dynamic} and~\ref{stmt.dcl}.
\end{note}

\rSec2[class.base.init]{Initializing bases and members}%
\indextext{initialization!base class}%
\indextext{initialization!member}

\pnum
In the definition of a constructor for a class,
initializers for direct and virtual base class subobjects and
non-static data members can be specified by a
\grammarterm{ctor-initializer},
which has the form

\begin{bnf}
\nontermdef{ctor-initializer}\br
    \terminal{:} mem-initializer-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-list}\br
    mem-initializer \opt{\terminal{...}}\br
    mem-initializer-list \terminal{,} mem-initializer \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer}\br
    mem-initializer-id \terminal{(} \opt{expression-list} \terminal{)}\br
    mem-initializer-id braced-init-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-id}\br
    class-or-decltype\br
    identifier
\end{bnf}

\pnum
Lookup for an unqualified name in a \grammarterm{mem-initializer-id}
ignores the constructor's function parameter scope.
\begin{note}
If the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
\grammarterm{mem-initializer-id}
naming the member or base class and composed of a single identifier
refers to the class member.
A
\grammarterm{mem-initializer-id}
for the hidden base class can be specified using a qualified name.
\end{note}
Unless the
\grammarterm{mem-initializer-id}
names the constructor's class,
a non-static data member of the constructor's class, or
a direct or virtual base of that class,
the
\grammarterm{mem-initializer}
is ill-formed.

\pnum
A
\grammarterm{mem-initializer-list}
can initialize a base class using any \grammarterm{class-or-decltype} that denotes that base class type.
\begin{example}
\begin{codeblock}
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }          // mem-initializer for base \tcode{A}
\end{codeblock}
\end{example}

\pnum
If a
\grammarterm{mem-initializer-id}
is ambiguous because it designates both a direct non-virtual base class and
an indirect virtual base class, the
\grammarterm{mem-initializer}
is ill-formed.
\begin{example}
\begin{codeblock}
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 // error: which \tcode{A}?
\end{codeblock}
\end{example}

\pnum
A
\grammarterm{ctor-initializer}
may initialize a variant member of the
constructor's class.
If a
\grammarterm{ctor-initializer}
specifies more than one
\grammarterm{mem-initializer}
for the same member or for the same base class,
the
\grammarterm{ctor-initializer}
is ill-formed.

\pnum
A \grammarterm{mem-initializer-list} can delegate to another
constructor of the constructor's class using any
\grammarterm{class-or-decltype} that denotes the constructor's class itself. If a
\grammarterm{mem-initializer-id} designates the constructor's class,
it shall be the only \grammarterm{mem-initializer}; the constructor
is a \defnadj{delegating}{constructor}, and the constructor selected by the
\grammarterm{mem-initializer} is the \defnadj{target}{constructor}.
The target constructor is selected by overload resolution.
Once the target constructor returns, the body of the delegating constructor
is executed. If a constructor delegates to itself directly or indirectly,
the program is ill-formed, no diagnostic required.
\begin{example}
\begin{codeblock}
struct C {
  C( int ) { }                  // \#1: non-delegating constructor
  C(): C(42) { }                // \#2: delegates to \#1
  C( char c ) : C(42.0) { }     // \#3: ill-formed due to recursion with \#4
  C( double d ) : C('a') { }    // \#4: ill-formed due to recursion with \#3
};
\end{codeblock}
\end{example}

\pnum
\indextext{initialization!base class}%
\indextext{initialization!member object}%
The
\grammarterm{expression-list}
or \grammarterm{braced-init-list}
in a
\grammarterm{mem-initializer}
is used to initialize the
designated subobject (or, in the case of a delegating constructor, the complete class object)
according to the initialization rules of~\ref{dcl.init} for direct-initialization.
\begin{example}
\begin{codeblock}
struct B1 { B1(int); @\commentellip@ };
struct B2 { B2(int); @\commentellip@ };
struct D : B1, B2 {
  D(int);
  B1 b;
  const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { @\commentellip@ }
D d(10);
\end{codeblock}
\end{example}
\begin{note}
The initialization
performed by each \grammarterm{mem-initializer}
constitutes a full-expres\-sion\iref{intro.execution}.
Any expression in
a
\grammarterm{mem-initializer}
is evaluated as part of the full-expression that performs the initialization.
\end{note}
A \grammarterm{mem-initializer} where the \grammarterm{mem-initializer-id} denotes
a virtual base class is ignored during execution of a constructor of any class that is
not the most derived class.

\pnum
A temporary expression bound to a reference member in a \grammarterm{mem-initializer}
is ill-formed.
\begin{example}
\begin{codeblock}
struct A {
  A() : v(42) { }   // error
  const int& v;
};
\end{codeblock}
\end{example}

\pnum
In a non-delegating constructor
other than an implicitly-defined copy/move constructor\iref{class.copy.ctor},
if a given potentially constructed subobject is not designated by a
\grammarterm{mem-initializer-id}
(including the case where there is no
\grammarterm{mem-initializer-list}
because the constructor has no
\grammarterm{ctor-initializer}),
then
\begin{itemize}
\item if the entity is a non-static data member that has
a default member initializer\iref{class.mem} and either
\begin{itemize}
\item the constructor's class is a union\iref{class.union}, and no other variant
member of that union is designated by a \grammarterm{mem-initializer-id} or

\item the constructor's class is not a union, and, if the entity is a member of an
anonymous union, no other member of that union is designated by a
\grammarterm{mem-initializer-id},
\end{itemize}
the entity is initialized from its default member initializer
as specified in~\ref{dcl.init};

\item otherwise, if the entity is an anonymous union or a variant member\iref{class.union.anon}, no initialization is performed;

\item otherwise, the entity is default-initialized\iref{dcl.init}.
\end{itemize}

\begin{note}
An abstract class\iref{class.abstract} is never a most derived
class, thus its constructors never initialize virtual base classes, therefore the
corresponding \grammarterm{mem-initializer}{s} can be omitted.
\end{note}
An attempt to initialize more than one non-static data member of a union renders the
program ill-formed.
\indextext{initialization!const member}%
\indextext{initialization!reference member}%
\begin{note}
After the call to a constructor for class
\tcode{X}
for an object with automatic or dynamic storage duration
has completed, if
the constructor was not invoked as part of value-initialization and
a member of
\tcode{X}
is neither initialized nor
given a value
during execution of the \grammarterm{compound-statement} of the body of the constructor,
the member has an indeterminate or erroneous value\iref{basic.indet}.
\end{note}
\begin{example}
\begin{codeblock}
struct A {
  A();
};

struct B {
  B(int);
};

struct C {
  C() { }               // initializes members as follows:
  A a;                  // OK, calls \tcode{A::A()}
  const B b;            // error: \tcode{B} has no default constructor
  int i;                // OK, \tcode{i} has indeterminate or erroneous value
  int j = 5;            // OK, \tcode{j} has the value \tcode{5}
};
\end{codeblock}
\end{example}

\pnum
If a given non-static data member has both a default member initializer
and a \grammarterm{mem-initializer}, the initialization specified by the
\grammarterm{mem-initializer} is performed, and the non-static data member's
default member initializer is ignored.
\begin{example}
Given
% The comment below is misrendered with an overly large space before 'effects'
% if left to listings (see NB US-26 (C++17 CD)) (possibly due to the ff
% ligature), so we fix it up manually.
\begin{codeblock}
struct A {
  int i = /* some integer expression with side effects */ ;
  A(int arg) : i(arg) { }
  // ...
};
\end{codeblock}
the \tcode{A(int)} constructor will simply initialize \tcode{i} to the value of
\tcode{arg}, and the
\indextext{side effects}%
side effects in \tcode{i}'s default member initializer
will not take place.
\end{example}

\pnum
A temporary expression bound to a reference member from a
default member initializer is ill-formed.
\begin{example}
\begin{codeblock}
struct A {
  A() = default;        // OK
  A(int v) : v(v) { }   // OK
  const int& v = 42;    // OK
};
A a1;                   // error: ill-formed binding of temporary to reference
A a2(1);                // OK, unfortunately
\end{codeblock}
\end{example}

\pnum
In a non-delegating constructor, the destructor for each potentially constructed
subobject of class type is potentially invoked\iref{class.dtor}.
\begin{note}
This provision ensures that destructors can be called for fully-constructed
subobjects in case an exception is thrown\iref{except.ctor}.
\end{note}

\pnum
In a non-delegating constructor, initialization
proceeds in the following order:
\begin{itemize}
\item
\indextext{initialization!order of virtual base class}%
First, and only for the constructor of the most derived class\iref{intro.object},
virtual base classes are initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where ``left-to-right'' is the order of appearance of the base classes
in the derived class
\grammarterm{base-specifier-list}.
\item
\indextext{initialization!order of base class}%
Then, direct base classes are initialized in declaration order
as they appear in the
\grammarterm{base-specifier-list}
(regardless of the order of the
\grammarterm{mem-initializer}{s}).
\item
\indextext{initialization!order of member}%
Then, non-static data members are initialized in the order
they were declared in the class definition
(again regardless of the order of the
\grammarterm{mem-initializer}{s}).
\item
Finally, the \grammarterm{compound-statement} of the constructor
body  is executed.
\end{itemize}

\begin{note}
The declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
struct V {
  V();
  V(int);
};

struct A : virtual V {
  A();
  A(int);
};

struct B : virtual V {
  B();
  B(int);
};

struct C : A, B, virtual V {
  C();
  C(int);
};

A::A(int i) : V(i) { @\commentellip@ }
B::B(int i) { @\commentellip@ }
C::C(int i) { @\commentellip@ }

V v(1);             // use \tcode{V(int)}
A a(2);             // use \tcode{V(int)}
B b(3);             // use \tcode{V()}
C c(4);             // use \tcode{V()}
\end{codeblock}
\end{example}

\pnum
\indextext{initializer!scope of member}%
\begin{note}
The \grammarterm{expression-list} or \grammarterm{braced-init-list}
of a \grammarterm{mem-initializer}
is in the function parameter scope of the constructor
and can use \keyword{this} to refer to the object being initialized.
\end{note}
\begin{example}
\begin{codeblock}
class X {
  int a;
  int b;
  int i;
  int j;
public:
  const int& r;
  X(int i): r(a), b(i), i(i), j(this->i) { }
};
\end{codeblock}

initializes
\tcode{X::r}
to refer to
\tcode{X::a},
initializes
\tcode{X::b}
with the value of the constructor parameter
\tcode{i},
initializes
\tcode{X::i}
with the value of the constructor parameter
\tcode{i},
and initializes
\tcode{X::j}
with the value of
\tcode{X::i};
this takes place each time an object of class
\tcode{X}
is created.
\end{example}

\pnum
\indextext{initialization!member function call during}%
Member functions (including virtual member functions, \ref{class.virtual}) can be
called for an object under construction or destruction.
Similarly, an object under construction or destruction can be the operand of the
\tcode{typeid}
operator\iref{expr.typeid} or of a
\keyword{dynamic_cast}\iref{expr.dynamic.cast}.
However, if these operations are performed
during evaluation of
\begin{itemize}
\item
a \grammarterm{ctor-initializer}
(or in a function called directly or indirectly from a
\grammarterm{ctor-initializer})
before all the
\grammarterm{mem-initializer}{s}
for base classes have completed,
\item
a precondition assertion of a constructor, or
\item
a postcondition assertion of a destructor\iref{dcl.contract.func},
\end{itemize}
the program has undefined behavior.
\begin{example}
\begin{codeblock}
class A {
public:
  A(int);
};

class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     // undefined behavior: calls member function but base \tcode{A} not yet initialized
  j(f()) { }        // well-defined: bases are all initialized
};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;
public:
  D() : C(f()),     // undefined behavior: calls member function but base \tcode{C} not yet initialized
  i(f()) { }        // well-defined: bases are all initialized
};
\end{codeblock}
\end{example}

\pnum
\begin{note}
\ref{class.cdtor} describes the results of virtual function calls,
\tcode{typeid}
and
\keyword{dynamic_cast}s
during construction for the well-defined cases;
that is, describes the polymorphic behavior
of an object under construction.
\end{note}

\pnum
\indextext{initializer!pack expansion}%
A \grammarterm{mem-initializer} followed by an ellipsis is
a pack expansion\iref{temp.variadic} that initializes the base
classes specified by a pack expansion in the \grammarterm{base-specifier-list}
for the class.
\begin{example}
\begin{codeblock}
template<class... Mixins>
class X : public Mixins... {
public:
  X(const Mixins&... mixins) : Mixins(mixins)... { }
};
\end{codeblock}

\end{example}

\rSec2[class.inhctor.init]{Initialization by inherited constructor}%
\indextext{initialization!by inherited constructor}

\pnum
When a constructor for type \tcode{B} is invoked
to initialize an object of a different type \tcode{D}
(that is, when the constructor was inherited\iref{namespace.udecl}),
initialization proceeds as if a defaulted default constructor
were used to initialize the \tcode{D} object and
each base class subobject from which the constructor was inherited,
except that the \tcode{B} subobject is initialized
by the inherited constructor
if the base class subobject were to be initialized
as part of the \tcode{D} object\iref{class.base.init}.
The invocation of the inherited constructor,
including the evaluation of any arguments,
is omitted if the \tcode{B} subobject is not to be initialized
as part of the \tcode{D} object.
The complete initialization is considered to be a single function call;
in particular, unless omitted,
the initialization of the inherited constructor's parameters
is sequenced before the initialization of any part of the \tcode{D} object.
\begin{example}
\begin{codeblock}
struct B1 {
  B1(int, ...) { }
};

struct B2 {
  B2(double) { }
};

int get();

struct D1 : B1 {
  using B1::B1;     // inherits \tcode{B1(int, ...)}
  int x;
  int y = get();
};

void test() {
  D1 d(2, 3, 4);    // OK, \tcode{B1} is initialized by calling \tcode{B1(2, 3, 4)},
                    // then \tcode{d.x} is default-initialized (no initialization is performed),
                    // then \tcode{d.y} is initialized by calling \tcode{get()}
  D1 e;             // error: \tcode{D1} has no default constructor
}

struct D2 : B2 {
  using B2::B2;
  B1 b;
};

D2 f(1.0);          // error: \tcode{B1} has no default constructor

struct W { W(int); };
struct X : virtual W { using W::W; X() = delete; };
struct Y : X { using X::X; };
struct Z : Y, virtual W { using Y::Y; };
Z z(0);             // OK, initialization of \tcode{Y} does not invoke default constructor of \tcode{X}

template<class T> struct Log : T {
  using T::T;       // inherits all constructors from class \tcode{T}
  ~Log() { std::clog << "Destroying wrapper" << std::endl; }
};
\end{codeblock}
Class template \tcode{Log} wraps any class and forwards all of its constructors,
while writing a message to the standard log
whenever an object of class \tcode{Log} is destroyed.
\end{example}

\begin{example}
\begin{codeblock}
struct V { V() = default; V(int); };
struct Q { Q(); };
struct A : virtual V, Q {
  using V::V;
  A() = delete;
};
int bar() { return 42; }
struct B : A {
  B() : A(bar()) {} // OK
};
struct C : B {};
void foo() { C c; } // \tcode{bar} is not invoked, because the \tcode{V} subobject is not initialized as part of \tcode{B}
\end{codeblock}
\end{example}

\pnum
If the constructor was inherited from multiple base class subobjects
of type \tcode{B}, the program is ill-formed.
\begin{example}
\begin{codeblock}
struct A { A(int); };
struct B : A { using A::A; };

struct C1 : B { using B::B; };
struct C2 : B { using B::B; };

struct D1 : C1, C2 {
  using C1::C1;
  using C2::C2;
};

struct V1 : virtual B { using B::B; };
struct V2 : virtual B { using B::B; };

struct D2 : V1, V2 {
  using V1::V1;
  using V2::V2;
};

D1 d1(0);           // error: ambiguous
D2 d2(0);           // OK, initializes virtual \tcode{B} base class, which initializes the \tcode{A} base class
                    // then initializes the \tcode{V1} and \tcode{V2} base classes as if by a defaulted default constructor

struct M { M(); M(int); };
struct N : M { using M::M; };
struct O : M {};
struct P : N, O { using N::N; using O::O; };
P p(0);             // OK, use \tcode{M(0)} to initialize \tcode{N}{'s} base class,
                    // use \tcode{M()} to initialize \tcode{O}{'s} base class
\end{codeblock}
\end{example}

\pnum
When an object is initialized by an inherited constructor,
initialization of the object is complete
when the initialization of all subobjects is complete.%
\indextext{initialization!class object|)}

\rSec2[class.cdtor]{Construction and destruction}%
\indextext{construction|(}%
\indextext{destruction|(}%

\pnum
\indextext{construction!member access}%
\indextext{destruction!member access}%
For an object with a non-trivial constructor, referring to any non-static member
or base class of the object before the constructor begins execution results in
undefined behavior. For an object with a non-trivial destructor, referring to
any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior.
\begin{example}
\begin{codeblock}
struct X { int i; };
struct Y : X { Y(); };                  // non-trivial
struct A { int a; };
struct B : public A { int j; Y y; };    // non-trivial

extern B bobj;
B* pb = &bobj;                          // OK
int* p1 = &bobj.a;                      // undefined behavior: refers to base class member
int* p2 = &bobj.y.i;                    // undefined behavior: refers to member's member

A* pa = &bobj;                          // undefined behavior: upcast to a base class type
B bobj;                                 // definition of \tcode{bobj}

extern X xobj;
int* p3 = &xobj.i;                      // OK, all constructors of \tcode{X} are trivial
X xobj;
\end{codeblock}
For another example,
\begin{codeblock}
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() : p(&x.j) {   // undefined, \tcode{x} is not yet constructed
    }
};
\end{codeblock}
\end{example}

\pnum
During the construction of an object,
if the value of any of its subobjects
or any element of its object representation
is accessed through a glvalue that is not obtained, directly or indirectly, from
the constructor's
\keyword{this}
pointer, the value thus obtained is unspecified.
\begin{example}
\begin{codeblock}
struct C;
void no_opt(C*);

struct C {
  int c;
  C() : c(0) { no_opt(this); }
};

const C cobj;

void no_opt(C* cptr) {
  int i = cobj.c * 100;         // value of \tcode{cobj.c} is unspecified
  cptr->c = 1;
  cout << cobj.c * 100          // value of \tcode{cobj.c} is unspecified
       << '\n';
}

extern struct D d;
struct D {
  D(int a) : a(a), b(d.a) {}
  int a, b;
};
D d = D(1);                     // value of \tcode{d.b} is unspecified
\end{codeblock}
\end{example}

\pnum
\indextext{construction!pointer to member or base}%
\indextext{destruction!pointer to member or base}%
To explicitly or implicitly convert a pointer (a glvalue) referring to
an object of class
\tcode{X}
to a pointer (reference) to a direct or indirect base class
\tcode{B}
of
\tcode{X},
the construction of
\tcode{X}
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
\tcode{B}
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior.
To form a pointer to (or access the value of) a direct non-static member of
an object
\tcode{obj},
the construction of
\tcode{obj}
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior.
\begin{example}
\begin{codeblock}
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    // undefined behavior: upcast from \tcode{E*} to \tcode{A*} might use path \tcode{E*} $\rightarrow$ \tcode{D*} $\rightarrow$ \tcode{A*}
                    // but \tcode{D} is not constructed

                    // ``\tcode{D((C*)this)}\!'' would be defined: \tcode{E*} $\rightarrow$ \tcode{C*} is defined because \tcode{E()} has started,
                    // and \tcode{C*} $\rightarrow$ \tcode{A*} is defined because \tcode{C} is fully constructed

  X(this) {}        // defined: upon construction of \tcode{X}, \tcode{C/B/D/A} sublattice is fully constructed
};
\end{codeblock}
\end{example}

\pnum
\indextext{virtual function call!constructor and}%
\indextext{virtual function call!destructor and}%
\indextext{construction!virtual function call}%
\indextext{destruction!virtual function call}%
Member functions, including virtual functions\iref{class.virtual}, can be called
during construction or destruction\iref{class.base.init}.
When a virtual function is called directly or indirectly from a constructor
or from a destructor,
including during the construction or destruction of the class's non-static data
members,
or during the evaluation of
a postcondition assertion of a constructor or
a precondition assertion of a destructor\iref{dcl.contract.func},
and the object to which the call applies is the object (call it \tcode{x}) under construction or
destruction,
the function called is the
final overrider in the constructor's or destructor's class and not one
overriding it in a more-derived class.
If the virtual function call uses an explicit class member access\iref{expr.ref}
and the object expression refers to
the complete object of \tcode{x} or one of that object's base class subobjects
but not \tcode{x} or one of its base class subobjects, the behavior
is undefined.
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V*, A*);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  f();              // calls \tcode{V::f}, not \tcode{A::f}
  g();              // calls \tcode{B::g}, not \tcode{D::g}
  v->g();           // \tcode{v} is base of \tcode{B}, the call is well-defined, calls \tcode{B::g}
  a->f();           // undefined behavior: \tcode{a}'s type not a base of \tcode{B}
}
\end{codeblock}
\end{example}

\pnum
\indextext{construction!\idxcode{typeid} operator}%
\indextext{destruction!\idxcode{typeid} operator}%
\indextext{\idxcode{typeid}!construction and}%
\indextext{\idxcode{typeid}!destruction and}%
The
\tcode{typeid}
operator\iref{expr.typeid} can be used during construction or destruction\iref{class.base.init}.
When
\tcode{typeid}
is used in a constructor (including the
\grammarterm{mem-initializer} or default member initializer\iref{class.mem}
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
\tcode{typeid}
refers to the object under construction or destruction,
\tcode{typeid}
yields the
\tcode{std::type_info}
object representing the constructor or destructor's class.
If the operand of
\tcode{typeid}
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the behavior is undefined.

\pnum
\indextext{construction!dynamic cast and}%
\indextext{destruction!dynamic cast and}%
\indextext{cast!dynamic!construction and}%
\indextext{cast!dynamic!destruction and}%
\keyword{dynamic_cast}s\iref{expr.dynamic.cast} can be used during construction
or destruction\iref{class.base.init}. When a
\keyword{dynamic_cast}
is used in a constructor (including the
\grammarterm{mem-initializer} or default member initializer
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
\keyword{dynamic_cast}
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class.
If the operand of the
\keyword{dynamic_cast}
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
\keyword{dynamic_cast}
results in undefined behavior.
\begin{example}
\begin{codeblock}
struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);                // \tcode{type_info} for \tcode{B}
  typeid(*v);                   // well-defined: \tcode{*v} has type \tcode{V}, a base of \tcode{B} yields \tcode{type_info} for \tcode{B}
  typeid(*a);                   // undefined behavior: type \tcode{A} not a base of \tcode{B}
  dynamic_cast<B*>(v);          // well-defined: \tcode{v} of type \tcode{V*}, \tcode{V} base of \tcode{B} results in \tcode{B*}
  dynamic_cast<B*>(a);          // undefined behavior: \tcode{a} has type \tcode{A*}, \tcode{A} not a base of \tcode{B}
}
\end{codeblock}
\end{example}
\indextext{destruction|)}%
\indextext{construction|)}%

\rSec2[class.copy.elision]{Copy/move elision}%

\pnum
\indextext{temporary!elimination of}%
\indextext{elision!copy constructor|see{constructor, copy, elision}}%
\indextext{elision!move constructor|see{constructor, move, elision}}%
\indextext{constructor!copy!elision}%
\indextext{constructor!move!elision}%
When certain criteria are met, an implementation is
allowed to omit the creation of a class object from
a source object of the same type (ignoring cv-qualification),
even if the selected constructor and/or the
destructor for the object have
\indextext{side effects}%
side effects.  In such cases, the
implementation treats the source and target of the
omitted initialization as simply two different ways of
referring to the same object. If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization.
\begin{note}
Because only one object is destroyed instead of two,
and the creation of one object is omitted,
there is still one object destroyed for each one constructed.
\end{note}
This elision of object creation, called
\indexdefn{copy elision|see{constructor, copy, elision}}%
\indexdefn{elision!copy|see{constructor, copy, elision}}%
\indexdefn{constructor!copy!elision}\indexdefn{constructor!move!elision}\term{copy elision},
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):
\begin{itemize}
\item in a \tcode{return} statement\iref{stmt.return} in
a function with a class return type,
when the \grammarterm{expression} is the name of a non-volatile
object $o$ with automatic storage duration (other than a function parameter or a variable
introduced by the \grammarterm{exception-declaration} of a
\grammarterm{handler}\iref{except.handle}),
the copy-initialization of the result object can be
omitted by constructing $o$ directly
into the function call's result object;

\item in a \grammarterm{throw-expression}\iref{expr.throw}, when the operand
is the name of a non-volatile object $o$ with automatic storage duration
(other than a function parameter or
a variable introduced by
the \grammarterm{exception-declaration} of a \grammarterm{handler})
that belongs to a scope that does not contain
the innermost enclosing \grammarterm{compound-statement}
associated with a \grammarterm{try-block} (if there is one),
the copy-initialization of the exception object can be omitted by
constructing $o$ directly into the exception object;

\item in a coroutine\iref{dcl.fct.def.coroutine}, a copy of a coroutine parameter
can be omitted and references to that copy replaced with references to the
corresponding parameter if the meaning of the program will be unchanged except for
the execution of a constructor and destructor for the parameter copy object;

\item when the \grammarterm{exception-declaration} of a
\grammarterm{handler}\iref{except.handle} declares an object $o$,
the copy-initialization of $o$ can be omitted by treating
the \grammarterm{exception-declaration} as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
\grammarterm{exception-declaration}.
\begin{note}
There cannot be a move from the exception object because it is
always an lvalue.
\end{note}
\end{itemize}
Copy elision is not permitted
where an expression is evaluated in a context
requiring a constant expression\iref{expr.const}
and in constant initialization\iref{basic.start.static}.
\begin{note}
It is possible that copy elision is performed
if the same expression
is evaluated in another context.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A loc;
  return loc;
}

constexpr A a;          // well-formed, \tcode{a.p} points to \tcode{a}
constexpr A b = g();    // error: \tcode{b.p} would be dangling\iref{expr.const}

void h() {
  A c = g();            // well-formed, \tcode{c.p} can point to \tcode{c} or be dangling
}
\end{codeblock}
Here the criteria for elision can eliminate
the copying of the object \tcode{t} with automatic storage duration
into the result object for the function call \tcode{f()},
which is the non-local object \tcode{t2}.
Effectively, the construction of \tcode{t}
can be viewed as directly initializing \tcode{t2},
and that object's destruction will occur at program exit.
Adding a move constructor to \tcode{Thing} has the same effect, but it is the
move construction from the object with automatic storage duration to \tcode{t2} that is elided.
\end{example}

\pnum
\begin{example}
\begin{codeblock}
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&&);
private:
  Thing(const Thing&);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            // OK, \tcode{Thing(Thing\&\&)} used (or elided) to throw \tcode{t}
  return t;             // OK, \tcode{Thing(Thing\&\&)} used (or elided) to return \tcode{t}
}

Thing t2 = f(false);    // OK, no extra copy/move performed, \tcode{t2} constructed by call to \tcode{f}

struct Weird {
  Weird();
  Weird(Weird&);
};

Weird g(bool b) {
  static Weird w1;
  Weird w2;
  if (b)
    return w1;  // OK, uses \tcode{Weird(Weird\&)}
  else
    return w2;  // error: \tcode{w2} in this context is an xvalue
}

int& h(bool b, int i) {
  static int s;
  if (b)
    return s;   // OK
  else
    return i;   // error: \tcode{i} is an xvalue
}

decltype(auto) h2(Thing t) {
  return t;     // OK, \tcode{t} is an xvalue and \tcode{h2}'s return type is \tcode{Thing}
}

decltype(auto) h3(Thing t) {
  return (t);   // OK, \tcode{(t)} is an xvalue and \tcode{h3}'s return type is \tcode{Thing\&\&}
}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
template<class T> void g(const T&);

template<class T> void f() {
  T x;
  try {
    T y;
    try { g(x); }
    catch (...) {
      if (/*...*/)
        throw x;        // does not move
      throw y;          // moves
    }
    g(y);
  } catch(...) {
    g(x);
    g(y);               // error: \tcode{y} is not in scope
  }
}
\end{codeblock}
\end{example}

\rSec1[class.compare]{Comparisons}%

\rSec2[class.compare.default]{Defaulted comparison operator functions}%

\pnum
A defaulted comparison operator function\iref{over.binary}
shall be a non-template function
that
\begin{itemize}
\item
is a non-static member or friend of some class \tcode{C},

\item
is defined as defaulted in \tcode{C} or in
a context where \tcode{C} is complete, and

\item
either has
two parameters of type \tcode{const C\&} or
two parameters of type \tcode{C},
where the implicit object parameter (if any) is considered to be
the first parameter.
\end{itemize}
Such a comparison operator function is termed
\indextext{operator!defaulted comparison operator function}%
a defaulted comparison operator function for class \tcode{C}.
Name lookups and access checks in
the implicit definition\iref{dcl.fct.def.default}
of a comparison operator function
are performed from a context equivalent to
its \grammarterm{function-body}.
A definition of a comparison operator as
defaulted that appears in a class shall be the first declaration
of that function.
\begin{example}
\begin{codeblock}
struct S;
bool operator==(S, S) = default;                    // error: \tcode{S} is not complete
struct S {
  friend bool operator==(S, const S&) = default;    // error: parameters of different types
};
enum E { };
bool operator==(E, E) = default;                    // error: not a member or friend of a class
\end{codeblock}
\end{example}

\pnum
A defaulted \tcode{<=>} or \tcode{==} operator function for class \tcode{C}
\indextext{operator!three-way comparison!deleted}%
\indextext{operator!equality!deleted}%
is defined as deleted if
any non-static data member of \tcode{C} is of reference type or
\tcode{C} has variant members\iref{class.union.anon}.

\pnum
A binary operator expression \tcode{a @ b} is
\defnx{usable}{usable!binary operator expression}
if either

\begin{itemize}
\item
\tcode{a} or \tcode{b} is of class or enumeration type and
overload resolution\iref{over.match} as applied to \tcode{a @ b}
results in a usable candidate, or

\item
neither \tcode{a} nor \tcode{b} is of class or enumeration type and
\tcode{a @ b} is a valid expression.
\end{itemize}

\pnum
If the \grammarterm{member-specification}
does not explicitly declare
any member or friend named \tcode{operator==},
an \tcode{==} operator function is declared implicitly
for each three-way comparison operator function
defined as defaulted in the \grammarterm{member-specification},
with the same access and \grammarterm{function-definition} and
in the same class scope as
the respective three-way comparison operator function,
except that the return type is replaced with \tcode{bool} and
the \grammarterm{declarator-id} is replaced with \tcode{operator==}.
\begin{note}
Such an implicitly-declared \tcode{==} operator for a class \tcode{X}
is defined as defaulted
in the definition of \tcode{X} and
has the same \grammarterm{parameter-declaration-clause} and
trailing \grammarterm{requires-clause} as
the respective three-way comparison operator.
It is declared with \keyword{friend}, \keyword{virtual}, \keyword{constexpr},
or \keyword{consteval} if
the three-way comparison operator function is so declared.
If the three-way comparison operator function
has no \grammarterm{noexcept-specifier},
the implicitly-declared \tcode{==} operator function
has an implicit exception specification\iref{except.spec} that
can differ from the implicit exception specification of
the three-way comparison operator function.
\end{note}
\begin{example}
\begin{codeblock}
template<typename T> struct X {
  friend constexpr std::partial_ordering operator<=>(X, X) requires (sizeof(T) != 1) = default;
  // implicitly declares: \tcode{friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;}

  [[nodiscard]] virtual std::strong_ordering operator<=>(const X&) const = default;
  // implicitly declares: \tcode{[[nodiscard]] virtual bool operator==(const X\&) const = default;}
};
\end{codeblock}
\end{example}
\begin{note}
The \tcode{==} operator function is declared implicitly even if
the defaulted three-way comparison operator function
is defined as deleted.
\end{note}

\pnum
The direct base class subobjects of \tcode{C},
in the order of their declaration in the \grammarterm{base-specifier-list} of \tcode{C},
followed by the non-static data members of \tcode{C},
in the order of their declaration in the \grammarterm{member-specification} of \tcode{C},
form a list of subobjects.
In that list, any subobject of array type is recursively expanded
to the sequence of its elements, in the order of increasing subscript.
Let $\tcode{x}_i$ be an lvalue denoting the $i^\text{th}$ element
in the expanded list of subobjects for an object \tcode{x}
(of length $n$),
where $\tcode{x}_i$ is
formed by a sequence of
derived-to-base conversions\iref{over.best.ics},
class member access expressions\iref{expr.ref}, and
array subscript expressions\iref{expr.sub} applied to \tcode{x}.

\rSec2[class.eq]{Equality operator}
\indextext{operator!equality!defaulted}%

\pnum
A defaulted equality operator function\iref{over.binary}
shall have a declared return type \tcode{bool}.

\pnum
A defaulted \tcode{==} operator function for a class \tcode{C}
is defined as deleted
unless, for each $\tcode{x}_i$ in the expanded list of subobjects
for an object \tcode{x} of type \tcode{C},
$\tcode{x}_i\tcode{ == }\tcode{x}_i$
is usable\iref{class.compare.default}.

\pnum
The return value of a defaulted \tcode{==} operator function
with parameters \tcode{x} and \tcode{y} is determined
by comparing corresponding elements $\tcode{x}_i$ and $\tcode{y}_i$
in the expanded lists of subobjects for \tcode{x} and \tcode{y}
(in increasing index order)
until the first index $i$
where $\tcode{x}_i\tcode{ == }\tcode{y}_i$ yields a result value which,
when contextually converted to \tcode{bool}, yields \tcode{false}.
The return value is \tcode{false} if such an index exists
and \tcode{true} otherwise.

\pnum
\begin{example}
\begin{codeblock}
struct D {
  int i;
  friend bool operator==(const D& x, const D& y) = default;
                                                // OK, returns \tcode{x.i == y.i}
};
\end{codeblock}
\end{example}

\rSec2[class.spaceship]{Three-way comparison}
\indextext{operator!three-way comparison!defaulted}%

\pnum
The \defnadj{synthesized}{three-way comparison}
of type \tcode{R}\iref{cmp.categories}
of glvalues \tcode{a} and \tcode{b} of the same type
is defined as follows:

\begin{itemize}
\item
If \tcode{a <=> b} is usable\iref{class.compare.default} and
can be explicitly converted to \tcode{R} using \keyword{static_cast},
\tcode{static_cast<R>(a <=> b)}.

\item
Otherwise, if \tcode{a <=> b} is usable or
overload resolution for \tcode{a <=> b} is performed and
finds at least one viable candidate,
the synthesized three-way comparison is not defined.

\item
Otherwise, if \tcode{R} is not a comparison category type, or either
the expression \tcode{a == b} or the expression \tcode{a < b}
is not usable,
the synthesized three-way comparison is not defined.

\item
Otherwise, if \tcode{R} is \tcode{strong_ordering}, then
\begin{codeblock}
a == b ? strong_ordering::equal :
a < b  ? strong_ordering::less :
         strong_ordering::greater
\end{codeblock}

\item
Otherwise, if \tcode{R} is \tcode{weak_ordering}, then
\begin{codeblock}
a == b ? weak_ordering::equivalent :
a < b  ? weak_ordering::less :
         weak_ordering::greater
\end{codeblock}

\item
Otherwise (when \tcode{R} is \tcode{partial_ordering}),
\begin{codeblock}
a == b ? partial_ordering::equivalent :
a < b  ? partial_ordering::less :
b < a  ? partial_ordering::greater :
         partial_ordering::unordered
\end{codeblock}
\end{itemize}

\begin{note}
A synthesized three-way comparison is ill-formed
if overload resolution finds usable candidates
that do not otherwise meet the requirements implied by the defined expression.
\end{note}

\pnum
Let \tcode{R} be the declared return type of
a defaulted three-way comparison operator function, and
let $\tcode{x}_i$ be the elements of
the expanded list of subobjects for
an object \tcode{x} of type \tcode{C}.

\begin{itemize}
\item
If \tcode{R} is \keyword{auto}, then
let $\cv{}_i~\tcode{R}_i$ be
the type of the expression $\tcode{x}_i\tcode{ <=> }\tcode{x}_i$.
The operator function is defined as deleted
if that expression is not usable or
if $\tcode{R}_i$ is not
a comparison category type\iref{cmp.categories.pre} for any $i$.
The return type is deduced as
the common comparison type (see below) of
$\tcode{R}_0$, $\tcode{R}_1$, $\dotsc$, $\tcode{R}_{n-1}$.
\item
Otherwise, \tcode{R} shall not contain a placeholder type.
If the synthesized three-way comparison of type \tcode{R}
between any objects $\tcode{x}_i$ and $\tcode{x}_i$
is not defined,
the operator function is defined as deleted.
\end{itemize}

\pnum
The return value of type \tcode{R}
of the defaulted three-way comparison operator function
with parameters \tcode{x} and \tcode{y} of the same type
is determined by comparing corresponding elements
$\tcode{x}_i$ and $\tcode{y}_i$
in the expanded lists of subobjects for \tcode{x} and \tcode{y}
(in increasing index order)
until the first index $i$ where
the synthesized three-way comparison of type \tcode{R}
between $\tcode{x}_i$ and $\tcode{y}_i$
yields a result value $\tcode{v}_i$ where $\tcode{v}_i \mathrel{\tcode{!=}} 0$,
contextually converted to \tcode{bool}, yields \tcode{true}.
The return value is a copy of $\tcode{v}_i$
if such an index exists and
\tcode{static_cast<R>(std::strong_ordering::equal)} otherwise.

\pnum
The \defn{common comparison type} \tcode{U}
of a possibly-empty list of $n$ comparison category types
$\tcode{T}_0$, $\tcode{T}_1$, $\dotsc$, $\tcode{T}_{n-1}$
is defined as follows:

\begin{itemize}
\item
If at least one $\tcode{T}_i$ is \tcode{std::partial_ordering},
\tcode{U} is \tcode{std::partial_ordering}\iref{cmp.partialord}.

\item
Otherwise, if at least one $\tcode{T}_i$ is \tcode{std::weak_ordering},
\tcode{U} is \tcode{std::weak_ordering}\iref{cmp.weakord}.

\item
Otherwise, \tcode{U} is \tcode{std::strong_ordering}\iref{cmp.strongord}.
\begin{note}
In particular, this is the result when $n$ is 0.
\end{note}
\end{itemize}

\rSec2[class.compare.secondary]{Secondary comparison operators}
\indextext{operator!inequality!defaulted}%
\indextext{operator!relational!defaulted}%

\pnum
\indextext{operator!comparison!secondary}%
A \defn{secondary comparison operator} is
a relational operator\iref{expr.rel} or the \tcode{!=} operator.
A defaulted operator function\iref{over.binary}
for a secondary comparison operator \tcode{@}
shall have a declared return type \tcode{bool}.

\pnum
The operator function with parameters \tcode{x} and \tcode{y}
is defined as deleted if
\begin{itemize}
\item
a first overload resolution\iref{over.match},
as applied to \tcode{x @ y},
\begin{itemize}
\item
does not result in a usable candidate, or
\item
the selected candidate is not a rewritten candidate, or
\end{itemize}

\item
a second overload resolution for
the expression resulting from the interpretation of \tcode{x @ y}
using the selected rewritten candidate\iref{over.match.oper}
does not result in a usable candidate
(for example, that expression might be \tcode{(x <=> y) @ 0}), or

\item
\tcode{x @ y} cannot be implicitly converted to \tcode{bool}.
\end{itemize}
In any of the two overload resolutions above,
the defaulted operator function is not considered as
a candidate for the \tcode{@} operator.
Otherwise, the operator function yields \tcode{x @ y}.

\pnum
\begin{example}
\begin{codeblock}
struct HasNoLessThan { };

struct C {
  friend HasNoLessThan operator<=>(const C&, const C&);
  bool operator<(const C&) const = default;             // OK, function is deleted
};
\end{codeblock}
\end{example}

\indextext{class|)}
