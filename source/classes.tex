%!TEX root = std.tex
\rSec0[class]{Classes}%
\indextext{class|(}

\gramSec[gram.class]{Classes}

\indextext{class!member function|see{member function, class}}

\pnum
\indextext{\idxcode{\{\}}!class declaration}%
\indextext{\idxcode{\{\}}!class definition}%
\indextext{type!class and}%
\indextext{object class|seealso{class object}}%
A class is a type.
\indextext{name class|see{class name}}%
Its name becomes a \grammarterm{class-name}\iref{class.name} within its
scope.

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    simple-template-id
\end{bnf}

\grammarterm{Class-specifier}{s} and
\grammarterm{elaborated-type-specifier}{s}\iref{dcl.type.elab} are used to
make \grammarterm{class-name}{s}. An object of a class consists of a
(possibly empty) sequence of members and base class objects.

\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} \opt{member-specification} \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{class-head}\br
    class-key \opt{attribute-specifier-seq} class-head-name \opt{class-virt-specifier} \opt{base-clause}\br
    class-key \opt{attribute-specifier-seq} \opt{base-clause}
\end{bnf}

\begin{bnf}
\nontermdef{class-head-name}\br
    \opt{nested-name-specifier} class-name
\end{bnf}

\begin{bnf}
\nontermdef{class-virt-specifier}\br
    \terminal{final}
\end{bnf}

\begin{bnf}
\nontermdef{class-key}\br
    \terminal{class}\br
    \terminal{struct}\br
    \terminal{union}
\end{bnf}

A \grammarterm{class-specifier} whose
\grammarterm{class-head} omits the
\grammarterm{class-head-name} defines an unnamed class. \begin{note} An unnamed class thus can't
be \tcode{final}. \end{note}

\pnum
A \grammarterm{class-name} is inserted into the scope in which it is
declared immediately after the \grammarterm{class-name} is seen. The
\grammarterm{class-name} is also inserted into the scope of the class
itself; this is known as the \defn{injected-class-name}.
For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
\indextext{definition!class}%
A \grammarterm{class-specifier} is commonly referred to as a class
definition.
\indextext{definition!class}%
A class is considered defined after the closing brace of its
\grammarterm{class-specifier} has been seen even though its member
functions are in general not yet defined.
The optional \grammarterm{attribute-specifier-seq} appertains to the class; the attributes in
the \grammarterm{attribute-specifier-seq} are thereafter considered attributes of the class
whenever it is named.

\pnum
If a class is marked with the \grammarterm{class-virt-specifier} \tcode{final} and it appears
as a \grammarterm{class-or-decltype} in a \grammarterm{base-clause}\iref{class.derived},
the program is ill-formed. Whenever a
\grammarterm{class-key} is followed by a \grammarterm{class-head-name}, the
\grammarterm{identifier} \tcode{final}, and a colon or left brace, \tcode{final} is
interpreted as a \grammarterm{class-virt-specifier}. \begin{example}
\begin{codeblock}
struct A;
struct A final {};      // OK: definition of \tcode{struct A},
                        // not value-initialization of variable \tcode{final}

struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B final : C{};  // OK: definition of nested class \tcode{B},
                        // not declaration of a bit-field member \tcode{final}
};
\end{codeblock}
\end{example}

\pnum
Complete objects and member subobjects of class type shall have nonzero
size.\footnote{Base class subobjects are not so constrained.}
\begin{note}
Class objects can be assigned, passed as arguments to functions, and
returned by functions (except objects of classes for which copying or moving has
been restricted; see~\ref{class.copy}). Other plausible operators, such
as equality comparison, can be defined by the user; see~\ref{over.oper}.
\end{note}

\pnum
\indextext{\idxcode{struct}!\tcode{class} versus}%
\indextext{structure}%
\indextext{\idxcode{union}!\tcode{class} versus}%
A \term{union} is a class defined with the \grammarterm{class-key}
\tcode{union};
\indextext{access control!\idxcode{union} default member}%
it holds at most one data member at a time\iref{class.union}.
\begin{note}
Aggregates of class type are described in~\ref{dcl.init.aggr}.
\end{note}

\indextext{class!trivial}%
\indextext{trivial class}%
\indextext{class!trivially copyable}%
\pnum
A \defn{trivially copyable class} is a class:

\begin{itemize}
\item where each copy constructor, move constructor, copy assignment operator,
and move assignment operator~(\ref{class.copy}, \ref{over.ass})
is either deleted or trivial,
\item that has at least one non-deleted copy constructor, move constructor,
copy assignment operator, or move assignment operator, and
\item that has a trivial, non-deleted destructor\iref{class.dtor}.
\end{itemize}

A \term{trivial class} is a class that is trivially copyable and
has one or more default constructors\iref{class.ctor},
all of which are either trivial or deleted and
at least one of which is not deleted.
\begin{note} In particular, a trivially copyable or trivial class does not have
virtual functions or virtual base classes.\end{note}

\indextext{class!standard-layout}%
\pnum
A class \tcode{S} is a \defn{standard-layout class} if it:
\begin{itemize}
\item has no non-static data members of type non-standard-layout class
(or array of such types) or reference,

\item has no virtual functions\iref{class.virtual} and no
virtual base classes\iref{class.mi},

\item has the same access control\iref{class.access}
for all non-static data members,

\item has no non-standard-layout base classes,

\item has at most one base class subobject of any given type,

\item has all non-static data members and bit-fields in the class and
its base classes first declared in the same class, and

\item has no element of the set $M(\mathtt{S})$ of types (defined below)
as a base class.\footnote{This ensures that two subobjects that have the
same class type and that
belong to the same most derived object are not allocated at the same
address\iref{expr.eq}.}
\end{itemize}

$M(\mathtt{X})$ is defined as follows:
\begin{itemize}
\item If \tcode{X} is a non-union class type with no (possibly
inherited\iref{class.derived}) non-static data members, the set
$M(\mathtt{X})$ is empty.

\item If \tcode{X} is a non-union class type whose first non-static data
member has type $\mathtt{X}_0$ (where said member may be an anonymous union),
the set $M(\mathtt{X})$ consists of $\mathtt{X}_0$ and the elements of
$M(\mathtt{X}_0)$.

\item If \tcode{X} is a union type, the set $M(\mathtt{X})$ is
the union of all $M(\mathtt{U}_i)$ and the set containing all $\mathtt{U}_i$,
where each $\mathtt{U}_i$ is the type of the $i$th non-static data member
of \tcode{X}.

\item If \tcode{X} is an array type with element type $\mathtt{X}_e$,
the set $M(\mathtt{X})$ consists of $\mathtt{X}_e$
and the elements of $M(\mathtt{X}_e)$.

\item If \tcode{X} is a non-class, non-array type, the set $M(\mathtt{X})$ is empty.
\end{itemize}

\begin{note} $M(\mathtt{X})$ is the set of the types of all non-base-class subobjects
that are guaranteed in a standard-layout class to be at a zero offset
in \tcode{X}. \end{note}

\begin{example}
\begin{codeblock}
   struct B { int i; };         // standard-layout class
   struct C : B { };            // standard-layout class
   struct D : C { };            // standard-layout class
   struct E : D { char : 4; };  // not a standard-layout class

   struct Q {};
   struct S : Q { };
   struct T : Q { };
   struct U : S, T { };         // not a standard-layout class
\end{codeblock}
\end{example}

\indextext{struct!standard-layout}%
\indextext{union!standard-layout}%
\pnum
A \defn{standard-layout struct} is a standard-layout class
defined with the \grammarterm{class-key} \tcode{struct} or the
\grammarterm{class-key} \tcode{class}.
A \defn{standard-layout union} is a standard-layout class
defined with the
\grammarterm{class-key} \tcode{union}.

\pnum
\begin{note} Standard-layout classes are useful for communicating with
code written in other programming languages. Their layout is specified
in~\ref{class.mem}.\end{note}

\pnum
\begin{example}
\begin{codeblock}
struct N {          // neither trivial nor standard-layout
  int i;
  int j;
  virtual ~N();
};

struct T {          // trivial but not standard-layout
  int i;
private:
  int j;
};

struct SL {         // standard-layout but not trivial
  int i;
  int j;
  ~SL();
};

struct POD {        // both trivial and standard-layout
  int i;
  int j;
};
\end{codeblock}
\end{example}

\pnum
If a \grammarterm{class-head-name} contains a \grammarterm{nested-name-specifier},
the \grammarterm{class-specifier} shall refer to a class that was
previously declared directly in the class or namespace to which the
\grammarterm{nested-name-specifier} refers,
or in an element of the inline namespace set\iref{namespace.def} of that namespace
(i.e., not merely inherited or
introduced by a \grammarterm{using-declaration}), and the
\grammarterm{class-specifier} shall appear in a namespace enclosing the
previous declaration.
In such cases, the \grammarterm{nested-name-specifier} of the
\grammarterm{class-head-name} of the
definition shall not begin with a \grammarterm{decltype-specifier}.

\rSec1[class.name]{Class names}
\indextext{definition!class name as type}%
\indextext{structure tag|see{class name}}%
\indextext{equivalence!type}%

\pnum
A class definition introduces a new type.
\begin{example}

\begin{codeblock}
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
\end{codeblock}

declares three variables of three different types. This implies that

\begin{codeblock}
a1 = a2;                        // error: \tcode{Y} assigned to \tcode{X}
a1 = a3;                        // error: \tcode{int} assigned to \tcode{X}
\end{codeblock}

are type mismatches, and that

\begin{codeblock}
int f(X);
int f(Y);
\end{codeblock}

\indextext{overloading}%
declare an overloaded\iref{over} function \tcode{f()} and not
simply a single function \tcode{f()} twice. For the same reason,

\begin{codeblock}
struct S { int a; };
struct S { int a; };            // error, double definition
\end{codeblock}

is ill-formed because it defines \tcode{S} twice.
\end{example}

\pnum
\indextext{definition!scope of class}%
\indextext{class name!scope of}%
A class declaration introduces the class name into the scope where
\indextext{name hiding!class definition}%
it is declared and hides any
class, variable, function, or other declaration of that name in an
enclosing scope\iref{basic.scope}. If a class name is declared in a
scope where a variable, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
\grammarterm{elaborated-type-specifier}\iref{basic.lookup.elab}.
\begin{example}
\begin{codeblock}
struct stat {
  // ...
};

stat gstat;                     // use plain \tcode{stat} to define variable

int stat(struct stat*);         // redeclare \tcode{stat} as function

void f() {
  struct stat* ps;              // \tcode{struct} prefix needed to name \tcode{struct stat}
  stat(ps);                     // call \tcode{stat()}
}
\end{codeblock}
\end{example}
\indextext{class name!elaborated}%
\indextext{declaration!forward class}%
A \grammarterm{declaration} consisting solely of \grammarterm{class-key}
\grammarterm{identifier}\tcode{;} is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
\begin{example}
\begin{codeblock}
struct s { int a; };

void g() {
  struct s;                     // hide global \tcode{struct s} with a block-scope declaration
  s* p;                         // refer to local \tcode{struct s}
  struct s { char* p; };        // define local \tcode{struct s}
  struct s;                     // redeclaration, has no effect
}
\end{codeblock}
\end{example}
\begin{note}
Such declarations allow definition of classes that refer to each other.
\indextext{example!friend}%
\begin{example}
\begin{codeblock}
class Vector;

class Matrix {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};

class Vector {
  // ...
  friend Vector operator*(const Matrix&, const Vector&);
};
\end{codeblock}
Declaration of friends is described in~\ref{class.friend},
operator functions in~\ref{over.oper}.
\end{example}
\end{note}

\pnum
\indextext{class name!elaborated}%
\indextext{elaborated type specifier|see{class name, elaborated}}%
\begin{note}
An \grammarterm{elaborated-type-specifier}\iref{dcl.type.elab} can also
be used as a \grammarterm{type-specifier} as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
\end{note}
\begin{example}

\begin{codeblock}
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   // global \tcode{s}
  p->a = s;                     // parameter \tcode{s}
}
\end{codeblock}
\end{example}

\pnum
\indextext{class name!point of declaration}%
\begin{note}
The declaration of a class name takes effect immediately after the
\grammarterm{identifier} is seen in the class definition or
\grammarterm{elaborated-type-specifier}. For example,

\begin{codeblock}
class A * A;
\end{codeblock}

first specifies \tcode{A} to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form \tcode{class} \tcode{A} must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
\end{note}

\pnum
\indextext{class name!\idxcode{typedef}}%
A \grammarterm{typedef-name}\iref{dcl.typedef} that names a class type,
or a cv-qualified version thereof, is also a \grammarterm{class-name}. If a
\grammarterm{typedef-name} that names a cv-qualified class type is used
where a \grammarterm{class-name} is required, the cv-qualifiers are
ignored. A \grammarterm{typedef-name} shall not be used as the
\grammarterm{identifier} in a \grammarterm{class-head}.

\rSec1[class.mem]{Class members}%
\indextext{declaration!member}%
\indextext{data member|see{member}}

\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration \opt{member-specification}\br
    access-specifier \terminal{:} \opt{member-specification}
\end{bnf}

\begin{bnf}
\nontermdef{member-declaration}\br
    \opt{attribute-specifier-seq} \opt{decl-specifier-seq} \opt{member-declarator-list} \terminal{;}\br
    function-definition\br
    using-declaration\br
    static_assert-declaration\br
    template-declaration\br
    deduction-guide\br
    alias-declaration\br
    empty-declaration
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator}\br
    declarator \opt{virt-specifier-seq} \opt{pure-specifier}\br
    declarator requires-clause\br
    declarator \opt{brace-or-equal-initializer}\br
    \opt{identifier} \opt{attribute-specifier-seq} \terminal{:} constant-expression \opt{brace-or-equal-initializer}
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier-seq}\br
    virt-specifier\br
    virt-specifier-seq virt-specifier
\end{bnf}

\begin{bnf}
\nontermdef{virt-specifier}\br
    \terminal{override}\br
    \terminal{final}
\end{bnf}

\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{= 0}
\end{bnf}

\pnum
\indextext{definition!class}%
The \grammarterm{member-specification} in a class definition declares the
full set of members of the class; no member can be added elsewhere.
A \defn{direct member} of a class \tcode{X} is a member of \tcode{X}
that was first declared within the \grammarterm{member-specification} of \tcode{X},
including anonymous union objects\iref{class.union.anon} and direct members thereof.
Members of a class are data members, member
functions\iref{class.mfct}, nested types, enumerators,
and member templates\iref{temp.mem} and specializations thereof.
\begin{note}
A specialization of a static data member template is a static data member.
A specialization of a member function template is a member function.
A specialization of a member class template is a nested class.
\end{note}

\pnum
A \grammarterm{member-declaration} does not declare new members of the class
if it is
\begin{itemize}
\item a friend declaration\iref{class.friend},
\item a \grammarterm{static_assert-declaration},
\item a \grammarterm{using-declaration}\iref{namespace.udecl}, or
\item an \grammarterm{empty-declaration}.
\end{itemize}
For any other \grammarterm{member-declaration},
each declared entity
that is not an unnamed bit-field\iref{class.bit}
is a member of the class,
and each such \grammarterm{member-declaration}
shall either
declare at least one member name of the class
or declare at least one unnamed bit-field.

\pnum
A \defn{data member} is a non-function member introduced by a
\grammarterm{member-declarator}.
A \defn{member function} is a member that is a function.
Nested types are classes~(\ref{class.name}, \ref{class.nest}) and
enumerations\iref{dcl.enum} declared in the class and arbitrary types
declared as members by use of a typedef declaration\iref{dcl.typedef}
or \grammarterm{alias-declaration}.
The enumerators of an unscoped enumeration\iref{dcl.enum} defined in the class
are members of the class.

\indextext{member!static}%
\indextext{member function!static}%
\indextext{data member!static}%
\pnum
A data member or member function
may be declared \tcode{static} in its \grammarterm{member-declaration},
in which case it is a \defn{static member} (see~\ref{class.static})
(a \defn{static data member}\iref{class.static.data} or
\defn{static member function}\iref{class.static.mfct}, respectively)
of the class.
Any other data member or member function is a \defn{non-static member}
(a \defn{non-static data member} or
\defn{non-static member function}~(\ref{class.mfct.non-static}), respectively).
\begin{note} A non-static data member of non-reference
type is a member subobject of a class object\iref{intro.object}.\end{note}

\pnum
A member shall not be declared twice in the
\grammarterm{member-specification}, except that
\begin{itemize}
\item a nested class or member
class template can be declared and then later defined, and
\item an
enumeration can be introduced with an \grammarterm{opaque-enum-declaration} and later
redeclared with an \grammarterm{enum-specifier}{}.
\end{itemize}
\begin{note}
A single name can denote several member functions provided their types
are sufficiently different\iref{over}.
\end{note}

\pnum
\indextext{completely defined}%
A class is considered a completely-defined object
type\iref{basic.types} (or complete type) at the closing \tcode{\}} of
the \grammarterm{class-specifier}.
Within the class
\grammarterm{member-specification}, the class is regarded as complete
within function bodies, default arguments,
\grammarterm{noexcept-specifier}{s}, and
default member initializers
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
\grammarterm{member-specification}.

\pnum
In a \grammarterm{member-declarator},
an \tcode{=} immediately following the \grammarterm{declarator}
is interpreted as introducing a \grammarterm{pure-specifier}
if the \grammarterm{declarator-id} has function type,
otherwise it is interpreted as introducing
a \grammarterm{brace-or-equal-initializer}.
\begin{example}
\begin{codeblock}
struct S {
  using T = void();
  T * p = 0;        // OK: \grammarterm{brace-or-equal-initializer}
  virtual T f = 0;  // OK: \grammarterm{pure-specifier}
};
\end{codeblock}
\end{example}

\pnum
In a \grammarterm{member-declarator} for a bit-field,
the \grammarterm{constant-expression} is parsed as
the longest sequence of tokens
that could syntactically form a \grammarterm{constant-expression}.
\begin{example}
\begin{codeblock}
int a;
const int b = 0;
struct S {
  int x1 : 8 = 42;               // OK, \tcode{"= 42"} is \grammarterm{brace-or-equal-initializer}
  int x2 : 8 { 42 };             // OK, \tcode{"\{ 42 \}"} is \grammarterm{brace-or-equal-initializer}
  int y1 : true ? 8 : a = 42;    // OK, \grammarterm{brace-or-equal-initializer} is absent
  int y2 : true ? 8 : b = 42;    // error: cannot assign to \tcode{const int}
  int y3 : (true ? 8 : b) = 42;  // OK, \tcode{"= 42"} is \grammarterm{brace-or-equal-initializer}
  int z : 1 || new int { 0 };    // OK, \grammarterm{brace-or-equal-initializer} is absent
};
\end{codeblock}
\end{example}

\pnum
A \grammarterm{brace-or-equal-initializer} shall appear only in the
declaration of a data member. (For static data members,
see~\ref{class.static.data}; for non-static data members,
see~\ref{class.base.init} and~\ref{dcl.init.aggr}).
A \grammarterm{brace-or-equal-initializer} for a non-static data member
\indextext{member!default initializer}%
specifies a \defn{default member initializer} for the member, and
shall not directly or indirectly cause the implicit definition of a
defaulted default constructor for the enclosing class or the
exception specification of that constructor.

\pnum
A member shall not be declared with the \tcode{extern}
\grammarterm{storage-class-specifier}. Within a class definition, a member shall not be declared with the \tcode{thread_local} \grammarterm{storage-class-specifier} unless also declared \tcode{static}.

\pnum
The \grammarterm{decl-specifier-seq} may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the \grammarterm{decl-specifier-seq}
shall contain a \grammarterm{type-specifier} that is not a \grammarterm{cv-qualifier}.
The
\grammarterm{member-declarator-list} can be omitted only after a
\grammarterm{class-specifier} or an \grammarterm{enum-specifier} or in a
friend declaration\iref{class.friend}. A
\grammarterm{pure-specifier} shall be used only in the declaration of a
virtual function\iref{class.virtual}
that is not a friend declaration.

\pnum
The optional \grammarterm{attribute-specifier-seq} in a \grammarterm{member-declaration}
appertains to each of the entities declared by the \grammarterm{member-declarator}{s};
it shall not appear if the optional \grammarterm{member-declarator-list} is omitted.

\pnum
A \grammarterm{virt-specifier-seq} shall contain at most one of each
\grammarterm{virt-specifier}.
A \grammarterm{virt-specifier-seq}
shall appear only in the declaration of a virtual member
function\iref{class.virtual}.

\pnum
\indextext{class object!member}%
Non-static data members shall not have
incomplete types. In particular, a class \tcode{C} shall not contain a
non-static member of class \tcode{C}, but it can contain a pointer or
reference to an object of class \tcode{C}.

\pnum
\begin{note}
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\end{note}

\pnum
\begin{note}
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
\end{note}

\pnum
\indextext{example!class definition}%
\begin{example}
A simple example of a class definition is

\begin{codeblock}
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
\end{codeblock}

which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration

\begin{codeblock}
tnode s, *sp;
\end{codeblock}

declares \tcode{s} to be a \tcode{tnode} and \tcode{sp} to be a pointer
to a \tcode{tnode}. With these declarations, \tcode{sp->count} refers to
the \tcode{count} member of the object to which \tcode{sp} points;
\tcode{s.left} refers to the \tcode{left} subtree pointer of the object
\tcode{s}; and \tcode{s.right->tword[0]} refers to the initial character
of the \tcode{tword} member of the \tcode{right} subtree of \tcode{s}.
\end{example}

\pnum
\indextext{layout!class object}%
Non-static data members of a (non-union) class
with the same access control\iref{class.access}
are allocated so that later
members have higher addresses within a class object.
\indextext{allocation!unspecified}%
The order of allocation of non-static data members
with different access control
is unspecified\iref{class.access}.
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions\iref{class.virtual} and
virtual base classes\iref{class.mi}.

\pnum
If \tcode{T} is the name of a class, then each of the following shall
have a name different from \tcode{T}:

\begin{itemize}
\item every static data member of class \tcode{T};

\item every member function of class \tcode{T}
\begin{note}
This restriction does not apply to constructors, which do not have
names\iref{class.ctor}
\end{note};

\item every member of class \tcode{T} that is itself a type;

\item every member template of class \tcode{T};

\item every enumerator of every member of class \tcode{T} that is an
unscoped enumerated type; and

\item every member of every anonymous union that is a member of class
\tcode{T}.
\end{itemize}

\pnum
In addition, if class \tcode{T} has a user-declared
constructor\iref{class.ctor}, every non-static data member of class
\tcode{T} shall have a name different from \tcode{T}.

\pnum
The \defn{common initial sequence} of two standard-layout struct\iref{class}
types is the longest sequence of non-static data
members and bit-fields in declaration order, starting with the first
such entity in each of the structs, such that corresponding entities
have layout-compatible types and either neither entity is a bit-field or
both are bit-fields with the same width.
\begin{example}
\begin{codeblock}
  struct A { int a; char b; };
  struct B { const int b1; volatile char b2; };
  struct C { int c; unsigned : 0; char b; };
  struct D { int d; char b : 4; };
  struct E { unsigned int e; char b; };
\end{codeblock}
The common initial sequence of \tcode{A} and \tcode{B} comprises all members
of either class. The common initial sequence of \tcode{A} and \tcode{C} and
of \tcode{A} and \tcode{D} comprises the first member in each case.
The common initial sequence of \tcode{A} and \tcode{E} is empty.
\end{example}

\pnum
Two standard-layout struct\iref{class} types are
\defnx{layout-compatible classes}{layout-compatible!class} if
their common initial sequence comprises all members and bit-fields of
both classes\iref{basic.types}.

\pnum
Two standard-layout unions are layout-compatible if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types\iref{basic.types}.

\pnum
In a standard-layout union with an active member\iref{class.union}
of struct type \tcode{T1}, it is permitted to read a non-static
data member \tcode{m} of another union member of struct type \tcode{T2}
provided \tcode{m} is part of the common initial sequence of \tcode{T1} and \tcode{T2};
the behavior is as if the corresponding member of \tcode{T1} were nominated.
\begin{example}
\begin{codeblock}
struct T1 { int a, b; };
struct T2 { int c; double d; };
union U { T1 t1; T2 t2; };
int f() {
  U u = { { 1, 2 } };   // active member is \tcode{t1}
  return u.t2.c;        // OK, as if \tcode{u.t1.a} were nominated
}
\end{codeblock}
\end{example}
\begin{note}
Reading a volatile object through a non-volatile glvalue has
undefined behavior\iref{dcl.type.cv}.
\end{note}

\pnum
If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member. Otherwise, its
address is the same as the address of its first base class subobject (if any).
\begin{note}
There might therefore be unnamed padding within a standard-layout struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
\end{note}
\begin{note}
The object and its first subobject are
pointer-interconvertible~(\ref{basic.compound}, \ref{expr.static.cast}).
\end{note}

\rSec2[class.mfct]{Member functions}%
\indextext{member function!class}

\pnum
\indextext{member function!inline}%
\indextext{definition!member function}%
A member function may be defined\iref{dcl.fct.def} in its class
definition, in which case it is an \term{inline} member
function\iref{dcl.inline}, or it may be defined outside of its class
definition if it has already been declared but not defined in its class
definition. A member function definition that appears outside of the
class definition shall appear in a namespace scope enclosing the class
definition. Except for member function definitions that appear outside
of a class definition, and except for explicit specializations of member
functions of class templates and member function
templates\iref{temp.spec} appearing outside of the class definition, a
member function shall not be redeclared.

\pnum
An inline member function (whether static or non-static) may
also be defined outside of its class definition provided either its
declaration in the class definition or its definition outside of the
class definition declares the function as \tcode{inline} or \tcode{constexpr}.
\begin{note}
Member functions of a class in namespace scope have the linkage of that class.
Member functions of a local class\iref{class.local} have no linkage.
See~\ref{basic.link}.
\end{note}

\pnum
\begin{note}
There can be at most one definition of a non-inline member function in
a program. There may be more than one
inline member function definition in a program.
See~\ref{basic.def.odr} and~\ref{dcl.inline}.
\end{note}

\pnum
\indextext{operator!scope resolution}%
If the definition of a member function is lexically outside its class
definition, the member function name shall be qualified by its class
name using the \tcode{::} operator.
\begin{note}
A name used in a member function definition (that is, in the
\grammarterm{parameter-declaration-clause} including the default
arguments\iref{dcl.fct.default} or in the member function body) is looked up
as described in~\ref{basic.lookup}.
\end{note}
\begin{example}

\begin{codeblock}
struct X {
  typedef int T;
  static T count;
  void f(T);
};
void X::f(T t = count) { }
\end{codeblock}

The member function \tcode{f} of class \tcode{X} is defined in global
scope; the notation \tcode{X::f} specifies that the function \tcode{f}
is a member of class \tcode{X} and in the scope of class \tcode{X}. In
the function definition, the parameter type \tcode{T} refers to the
typedef member \tcode{T} declared in class \tcode{X} and the default
argument \tcode{count} refers to the static data member \tcode{count}
declared in class \tcode{X}.
\end{example}

\pnum
\begin{note}
A \tcode{static} local variable or local type in a member function always refers to
the same entity, whether or not the member function is inline.
\end{note}

\pnum
Previously declared member functions may be mentioned in friend declarations.

\pnum
\indextext{local class!member function in}%
Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.

\pnum
\begin{note}
A member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see~\ref{dcl.fct}. For example,

\begin{codeblock}
typedef void fv();
typedef void fvc() const;
struct S {
  fv memfunc1;      // equivalent to: \tcode{void memfunc1();}
  void memfunc2();
  fvc memfunc3;     // equivalent to: \tcode{void memfunc3() const;}
};
fv  S::* pmfv1 = &S::memfunc1;
fv  S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
\end{codeblock}

Also see~\ref{temp.arg}.
\end{note}

\rSec2[class.mfct.non-static]{Non-static member functions}%
\indextext{member function!non-static}

\pnum
A non-static member function may be called for an object of
its class type, or for an object of a class derived\iref{class.derived}
from its class type, using the class member
access syntax~(\ref{expr.ref}, \ref{over.match.call}). A non-static
member function may also be called directly using the function call
syntax~(\ref{expr.call}, \ref{over.match.call}) from within
the body of a member function of its class or of a class derived from
its class.

\pnum
\indextext{member function!call undefined}%
If a non-static member function of a class \tcode{X} is called for an
object that is not of type \tcode{X}, or of a type derived from
\tcode{X}, the behavior is undefined.

\pnum
When an \grammarterm{id-expression}\iref{expr.prim} that is not part of a
class member access syntax\iref{expr.ref} and not used to form a
pointer to member\iref{expr.unary.op} is used in
a member of class \tcode{X} in a context where \tcode{this} can be
used\iref{expr.prim.this},
if name
lookup\iref{basic.lookup} resolves the name in the
\grammarterm{id-expression} to a non-static non-type member of some class
\tcode{C},
and if either the \grammarterm{id-expression} is potentially evaluated or
\tcode{C} is \tcode{X} or a base class of \tcode{X},
the \grammarterm{id-expression} is transformed into a class
member access expression\iref{expr.ref} using
\tcode{(*this)}\iref{class.this} as the \grammarterm{postfix-expression}
to the left of the \tcode{.} operator.
\begin{note}
If \tcode{C} is not \tcode{X} or a base class of \tcode{X}, the class
member access expression is ill-formed.
\end{note}
Similarly during name lookup, when an
\grammarterm{unqualified-id}\iref{expr.prim} used in the definition of a
member function for class \tcode{X} resolves to a static member,
an enumerator or a nested type of class \tcode{X} or of a base class of
\tcode{X}, the \grammarterm{unqualified-id} is transformed into a
\grammarterm{qualified-id}\iref{expr.prim} in which the
\grammarterm{nested-name-specifier} names the class of the member function.
These transformations do not apply in the
template definition context\iref{temp.dep.type}.
\indextext{example!member function}%
\begin{example}

\begin{codeblock}
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
  void set(const char*, tnode* l, tnode* r);
};

void tnode::set(const char* w, tnode* l, tnode* r) {
  count = strlen(w)+1;
  if (sizeof(tword)<=count)
      perror("tnode string too long");
  strcpy(tword,w);
  left = l;
  right = r;
}

void f(tnode n1, tnode n2) {
  n1.set("abc",&n2,0);
  n2.set("def",0,0);
}
\end{codeblock}

In the body of the member function \tcode{tnode::set}, the member names
\tcode{tword}, \tcode{count}, \tcode{left}, and \tcode{right} refer to
members of the object for which the function is called. Thus, in the
call \tcode{n1.set("abc",\&n2,0)}, \tcode{tword} refers to
\tcode{n1.tword}, and in the call \tcode{n2.set("def",0,0)}, it refers
to \tcode{n2.tword}. The functions \tcode{strlen}, \tcode{perror}, and
\tcode{strcpy} are not members of the class \tcode{tnode} and should be
declared elsewhere.\footnote{See, for example, \tcode{<cstring>}\iref{c.strings}.}
\end{example}

\pnum
\indextext{member function!const}%
\indextext{member function!volatile}%
\indextext{member function!const volatile}%
A non-static member function may be declared \tcode{const},
\tcode{volatile}, or \tcode{const} \tcode{volatile}. These
\grammarterm{cv-qualifier}{s} affect the type of the \tcode{this}
pointer\iref{class.this}. They also affect the function
type\iref{dcl.fct} of the member function; a member function declared
\tcode{const} is a \defn{const member function}, a member function
declared \tcode{volatile} is a \defn{volatile member function} and a
member function declared \tcode{const} \tcode{volatile} is a
\defn{const volatile member function}.
\begin{example}

\begin{codeblock}
struct X {
  void g() const;
  void h() const volatile;
};
\end{codeblock}

\tcode{X::g} is a const member function and \tcode{X::h} is a
const volatile member function.
\end{example}

\pnum
A non-static member function may be declared with a \grammarterm{ref-qualifier}\iref{dcl.fct}; see~\ref{over.match.funcs}.

\pnum
A non-static member function may be declared
\term{virtual}\iref{class.virtual} or \term{pure virtual}\iref{class.abstract}.

\rSec3[class.this]{The \tcode{this} pointer}%
\indextext{\idxcode{this}}
\indextext{member function!\idxcode{this}}

\pnum
\indextext{this pointer@\tcode{this} pointer|see{\tcode{this}}}%
In the body of a non-static\iref{class.mfct} member function, the
keyword \tcode{this} is a prvalue expression whose value is the
address of the object for which the function is called.
\indextext{\idxcode{this}!type of}%
The type of \tcode{this} in a member function of a class \tcode{X} is
\tcode{X*}.
If the member function is declared \tcode{const}, the type of
\tcode{this} is \tcode{const} \tcode{X*},
if the member function is declared \tcode{volatile}, the type of
\tcode{this} is \tcode{volatile} \tcode{X*}, and if the member function
is declared \tcode{const} \tcode{volatile}, the type of \tcode{this} is
\tcode{const} \tcode{volatile} \tcode{X*}.
\begin{note} Thus in a const member function, the object for which the function is
called is accessed through a const access path. \end{note}
\begin{example}

\begin{codeblock}
struct s {
  int a;
  int f() const;
  int g() { return a++; }
  int h() const { return a++; } // error
};

int s::f() const { return a; }
\end{codeblock}

The \tcode{a++} in the body of \tcode{s::h} is ill-formed because it
tries to modify (a part of) the object for which \tcode{s::h()} is
called. This is not allowed in a const member function because
\tcode{this} is a pointer to \tcode{const}; that is, \tcode{*this} has
\tcode{const} type.
\end{example}

\pnum
Similarly, \tcode{volatile} semantics\iref{dcl.type.cv} apply in
volatile member functions when accessing the object and its
non-static data members.

\pnum
A cv-qualified member function can be called on an
object-expression\iref{expr.ref} only if the object-expression is as
cv-qualified or less-cv-qualified than the member function.
\begin{example}

\begin{codeblock}
void k(s& x, const s& y) {
  x.f();
  x.g();
  y.f();
  y.g();                        // error
}
\end{codeblock}

The call \tcode{y.g()} is ill-formed because \tcode{y} is \tcode{const}
and \tcode{s::g()} is a non-const member function, that is,
\tcode{s::g()} is less-qualified than the object-expression \tcode{y}.
\end{example}

\pnum
\indextext{\idxcode{const}!constructor and}%
\indextext{\idxcode{const}!destructor and}%
\indextext{\idxcode{volatile}!constructor and}%
\indextext{\idxcode{volatile}!destructor and}%
Constructors\iref{class.ctor} and destructors\iref{class.dtor} shall
not be declared \tcode{const}, \tcode{volatile} or \tcode{const}
\tcode{volatile}. \begin{note} However, these functions can be invoked to
create and destroy objects with cv-qualified types,
see~\ref{class.ctor} and~\ref{class.dtor}.
\end{note}

\rSec2[class.static]{Static members}%
\indextext{member!static}%

\pnum
A static member \tcode{s} of class \tcode{X} may be referred to
using the \grammarterm{qualified-id} expression \tcode{X::s}; it is not
necessary to use the class member access syntax\iref{expr.ref} to
refer to a static member. A static member may be
referred to using the class member access syntax, in which case the
object expression is evaluated.
\begin{example}

\begin{codeblock}
struct process {
  static void reschedule();
};
process& g();

void f() {
  process::reschedule();        // OK: no object necessary
  g().reschedule();             // \tcode{g()} is called
}
\end{codeblock}
\end{example}

\pnum
A static member may be referred to directly in the scope of its
class or in the scope of a class derived\iref{class.derived}
from its class; in this case, the static member is referred to
as if a \grammarterm{qualified-id} expression was used, with the
\grammarterm{nested-name-specifier} of the \grammarterm{qualified-id} naming
the class scope from which the static member is referenced.
\begin{example}

\begin{codeblock}
int g();
struct X {
  static int g();
};
struct Y : X {
  static int i;
};
int Y::i = g();                 // equivalent to \tcode{Y::g();}
\end{codeblock}
\end{example}

\pnum
If an \grammarterm{unqualified-id}\iref{expr.prim} is used in the
definition of a static member following the member's
\grammarterm{declarator-id}, and name lookup\iref{basic.lookup.unqual}
finds that the \grammarterm{unqualified-id} refers to a static
member, enumerator, or nested type of the member's class (or of a base
class of the member's class), the \grammarterm{unqualified-id} is
transformed into a \grammarterm{qualified-id} expression in which the
\grammarterm{nested-name-specifier} names the class scope from which the
member is referenced.
\begin{note}
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\end{note}


\pnum
Static members obey the usual class member access rules\iref{class.access}.
When used in the declaration of a class
member, the \tcode{static} specifier shall only be used in the member
declarations that appear within the \grammarterm{member-specification} of
the class definition.
\begin{note}
It cannot be specified in member declarations that appear in namespace scope.
\end{note}

\rSec3[class.static.mfct]{Static member functions}
\indextext{member function!static}%

\pnum
\begin{note}
The rules described in~\ref{class.mfct} apply to static member
functions.
\end{note}

\pnum
\begin{note}
A static member function does not have a \tcode{this}
pointer\iref{class.this}.
\end{note}
A static member function shall not be \tcode{virtual}. There
shall not be a static and a non-static member function with the
same name and the same parameter types\iref{over.load}. A
static member function shall not be declared \tcode{const},
\tcode{volatile}, or \tcode{const volatile}.

\rSec3[class.static.data]{Static data members}
\indextext{member data!static}%

\pnum
A static data member is not part of the subobjects of a class. If a
static data member is declared \tcode{thread_local} there is one copy of
the member per thread. If a static data member is not declared
\tcode{thread_local} there is one copy of the data member that is shared by all
the objects of the class.

\pnum
\indextext{initialization!static member}%
\indextext{definition!static member}%
The declaration of a non-inline
static data member in its class definition
is not a definition and may be of an incomplete type other than
\cv{}~\tcode{void}. The definition for a static data
member that is not defined inline in the class definition
shall appear in a namespace scope enclosing the member's class
definition.
\indextext{operator use!scope resolution}%
In the definition at namespace scope, the name of the static
data member shall be qualified by its class name using the \tcode{::}
operator. The \grammarterm{initializer} expression in the definition of a
static data member is in the scope of its
class\iref{basic.scope.class}.
\indextext{example!static member}%
\begin{example}

\begin{codeblock}
class process {
  static process* run_chain;
  static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
\end{codeblock}

The static data member \tcode{run_chain} of class
\tcode{process} is defined in global scope; the notation
\tcode{process::run_chain} specifies that the member \tcode{run_chain}
is a member of class \tcode{process} and in the scope of class
\tcode{process}. In the static data member definition, the
\grammarterm{initializer} expression refers to the static data
member \tcode{running} of class \tcode{process}.
\end{example}

\begin{note}
Once the static data member has been defined, it exists even if
no objects of its class have been created.
\begin{example}
In the example above, \tcode{run_chain} and \tcode{running} exist even
if no objects of class \tcode{process} are created by the program.
\end{example}
\end{note}

\pnum
If a non-volatile non-inline \tcode{const} static data member is
of integral or enumeration type,
its declaration in the class definition can specify a
\grammarterm{brace-or-equal-initializer} in which every
\grammarterm{initializer-clause} that is an \grammarterm{assignment-expression}
is a constant expression\iref{expr.const}.
The member shall still be defined in a namespace scope if
it is odr-used\iref{basic.def.odr} in the program and the
namespace scope definition shall not contain an \grammarterm{initializer}.
An inline static data member may be defined in the class definition
and may specify a \grammarterm{brace-or-equal-initializer}. If the
member is declared with the \tcode{constexpr} specifier, it may be
redeclared in namespace scope with no initializer (this usage is
deprecated; see \ref{depr.static_constexpr}). Declarations of other
static data members shall not specify a \grammarterm{brace-or-equal-initializer}.

\pnum
\begin{note}
There shall be exactly one definition of a static data member
that is odr-used\iref{basic.def.odr} in a program; no diagnostic is required.
\end{note}
Unnamed classes and classes contained directly
or indirectly within unnamed classes shall not contain static
data members.

\pnum
\begin{note}
Static data members of a class in namespace scope have the linkage of that class\iref{basic.link}. A local class cannot have static data members\iref{class.local}.
\end{note}

\pnum
Static data members are initialized and destroyed exactly like
non-local variables~(\ref{basic.start.static}, \ref{basic.start.dynamic},
\ref{basic.start.term}).

\pnum
A static data member shall not be
\tcode{mutable}\iref{dcl.stc}.

\rSec2[class.bit]{Bit-fields}%
\indextext{bit-field}

\pnum
A \grammarterm{member-declarator} of the form

\begin{ncbnftab}
\opt{identifier} \opt{attribute-specifier-seq} \terminal{:} constant-expression \opt{brace-or-equal-initializer}
\end{ncbnftab}

\indextext{\idxcode{:}!bit-field declaration}%
\indextext{declaration!bit-field}%
specifies a bit-field;
its length is set off from the bit-field name by a colon. The optional \grammarterm{attribute-specifier-seq} appertains to the entity being declared. The bit-field
attribute is not part of the type of the class member. The
\grammarterm{constant-expression} shall be an integral constant expression
with a value greater than or equal to zero. The
value of the integral constant expression may
be larger than the number of bits in the object
representation\iref{basic.types} of the bit-field's type; in such
cases the extra bits are padding bits\iref{basic.types}.
\indextext{allocation!implementation-defined bit-field}%
Allocation of bit-fields within a class object is
\impldef{allocation of bit-fields within a class object}.
\indextext{bit-field!implementation-defined alignment of}%
Alignment of bit-fields is \impldef{alignment of bit-fields within a class object}.
\indextext{layout!bit-field}%
Bit-fields are packed into some addressable allocation unit.
\begin{note}
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
\end{note}

\pnum
\indextext{bit-field!unnamed}%
A declaration for a bit-field that omits the \grammarterm{identifier}
declares an \defn{unnamed bit-field}. Unnamed bit-fields are not
members and cannot be initialized.
\begin{note}
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
\end{note}
\indextext{bit-field!zero width of}%
\indextext{bit-field!alignment of}%
As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the value of the
\grammarterm{constant-expression} be equal to zero.

\pnum
\indextext{bit-field!type of}%
A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type\iref{basic.fundamental}.
\indextext{Boolean}%
A \tcode{bool} value can successfully be stored in a bit-field of any
nonzero size.
\indextext{bit-field!address of}%
The address-of operator \tcode{\&} shall not be applied to a bit-field,
so there are no pointers to bit-fields.
\indextext{restriction!bit-field}%
\indextext{restriction!address of bit-field}%
\indextext{restriction!pointer to bit-field}%
A non-const reference shall not be bound to a
bit-field\iref{dcl.init.ref}.
\begin{note}
If the initializer for a reference of type \tcode{const} \tcode{T\&} is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See~\ref{dcl.init.ref}.
\end{note}

\pnum
If the value \tcode{true} or \tcode{false} is stored into a bit-field of
type \tcode{bool} of any size (including a one bit bit-field), the
original \tcode{bool} value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type\iref{dcl.enum},
the original enumerator value and the value of the bit-field shall
compare equal.
\begin{example}

\begin{codeblock}
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              // yields \tcode{true}
    { @\commentellip@ }
}
\end{codeblock}
\end{example}

\rSec2[class.nest]{Nested class declarations}%
\indextext{definition!nested class}%
\indextext{class!nested|see{nested class}}

\pnum
A class can be declared within another class. A class declared within
another is called a \defnx{nested}{nested class} class. The name of a nested class
is local to its enclosing class.
\indextext{nested class!scope of}%
The nested class is in the scope of its enclosing class.
\begin{note}
See~\ref{expr.prim} for restrictions on the use of non-static data
members and non-static member functions.
\end{note}

\indextext{example!nested class}%
\begin{example}

\begin{codeblock}
int x;
int y;

struct enclose {
  int x;
  static int s;

  struct inner {
    void f(int i) {
      int a = sizeof(x);        // OK: operand of sizeof is an unevaluated operand
      x = i;                    // error: assign to \tcode{enclose::x}
      s = i;                    // OK: assign to \tcode{enclose::s}
      ::x = i;                  // OK: assign to global \tcode{x}
      y = i;                    // OK: assign to global \tcode{y}
    }
    void g(enclose* p, int i) {
      p->x = i;                 // OK: assign to \tcode{enclose::x}
    }
  };
};

inner* p = 0;                   // error: \tcode{inner} not in scope
\end{codeblock}
\end{example}

\pnum
Member functions and static data members of a nested class can be
defined in a namespace scope enclosing the definition of their class.
\indextext{example!nested class definition}%
\begin{example}

\begin{codeblock}
struct enclose {
  struct inner {
    static int x;
    void f(int i);
  };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { @\commentellip@ }
\end{codeblock}
\end{example}

\pnum
If class \tcode{X} is defined in a namespace scope, a nested class
\tcode{Y} may be declared in class \tcode{X} and later defined in the
definition of class \tcode{X} or be later defined in a namespace scope
enclosing the definition of class \tcode{X}.
\indextext{example!nested class forward declaration}%
\begin{example}

\begin{codeblock}
class E {
  class I1;                     // forward declaration of nested class
  class I2;
  class I1 { };                 // definition of nested class
};
class E::I2 { };                // definition of nested class
\end{codeblock}
\end{example}

\pnum
\indextext{friend function!nested class}%
Like a member function, a friend function\iref{class.friend} defined
within a nested class is in the lexical scope of that class; it obeys
the same rules for name binding as a static member function of that
class\iref{class.static}, but it has no special access rights to
members of an enclosing class.

\rSec2[class.nested.type]{Nested type names}
\indextext{type name!nested}%
\indextext{type name!nested!scope of}%

\pnum
Type names obey exactly the same scope rules as other names. In
particular, type names defined within a class definition cannot be used
outside their class without qualification.
\begin{example}

\indextext{example!nested type name}%
\begin{codeblock}
struct X {
  typedef int I;
  class Y { @\commentellip@ };
  I a;
};

I b;                            // error
Y c;                            // error
X::Y d;                         // OK
X::I e;                         // OK
\end{codeblock}
\end{example}%
\indextext{class|)}

\rSec1[class.union]{Unions}%
\indextext{\idxcode{union}}

\pnum
In a union,
a non-static data member is \defnx{active}{active!union member}
if its name refers to an object
whose lifetime has begun and has not ended\iref{basic.life}.
At most one of the non-static data members of an object of union type
can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. \begin{note} One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence\iref{class.mem}, and
if a non-static data member of an object of this standard-layout union type
is active and is one of the standard-layout structs,
it is permitted to inspect the common initial sequence
of any of the standard-layout struct members;
see~\ref{class.mem}.
\end{note}

\pnum
The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct.
\begin{note}
A union object and its non-static data members are
pointer-interconvertible~(\ref{basic.compound}, \ref{expr.static.cast}).
As a consequence, all non-static data members of a
union object have the same address.
\end{note}

\pnum
\indextext{member function!\idxcode{union}}%
\indextext{constructor!\idxcode{union}}%
\indextext{destructor!\idxcode{union}}%
A union can have member functions (including constructors and destructors),
\indextext{restriction!\idxcode{union}}%
but it shall not have virtual\iref{class.virtual} functions. A union shall not have
base classes. A union shall not be used as a base class.
\indextext{restriction!\idxcode{union}}%
If a union contains a non-static data member of
reference type the program is ill-formed.
\begin{note} Absent default member initializers\iref{class.mem},
if any non-static data member of a union has a non-trivial
default constructor\iref{class.ctor},
copy constructor\iref{class.copy},
move constructor\iref{class.copy},
copy assignment operator\iref{class.copy},
move assignment operator\iref{class.copy},
or destructor\iref{class.dtor}, the corresponding member function
of the union must be user-provided or it will
be implicitly deleted\iref{dcl.fct.def.delete} for the union. \end{note}

\pnum
\begin{example} Consider the following union:

\begin{codeblock}
union U {
  int i;
  float f;
  std::string s;
};
\end{codeblock}

Since \tcode{std::string}\iref{string.classes} declares non-trivial versions of all of the special
member functions, \tcode{U} will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use \tcode{U}, some or all of these member functions
must be user-provided.\end{example}

\pnum
When the left operand of an assignment operator
involves a member access expression\iref{expr.ref}
that nominates a union member,
it may begin the lifetime of that union member,
as described below.
For an expression \tcode{E},
define the set $S(\mathtt{E})$
of subexpressions of \tcode{E}
as follows:
\begin{itemize}
\item
If \tcode{E} is of the form \tcode{A.B},
$S(\mathtt{E})$ contains the elements of $S(\mathtt{A})$,
and also contains \tcode{A.B}
if \tcode{B} names a union member of a non-class, non-array type,
or of a class type with a trivial default constructor that is not deleted,
or an array of such types.
\item
If \tcode{E} is of the form \tcode{A[B]}
and is interpreted as a built-in array subscripting operator,
$S(\mathtt{E})$ is $S(\mathtt{A})$ if \tcode{A} is of array type,
$S(\mathtt{B})$ if \tcode{B} is of array type,
and empty otherwise.
\item
Otherwise, $S(\mathtt{E})$ is empty.
\end{itemize}
In an assignment expression of the form \tcode{E1 = E2}
that uses either the built-in assignment operator\iref{expr.ass}
or a trivial assignment operator\iref{class.copy},
for each element \tcode{X} of $S($\tcode{E1}$)$,
if modification of \tcode{X} would have undefined behavior under~\ref{basic.life},
an object of the type of \tcode{X} is implicitly created
in the nominated storage;
no initialization is performed and
the beginning of its lifetime is sequenced after
the value computation of the left and right operands
and before the assignment.
\begin{note}
This ends the lifetime of the previously-active
member of the union, if any\iref{basic.life}.
\end{note}
\begin{example}
\begin{codeblock}
union A { int x; int y[4]; };
struct B { A a; };
union C { B b; int k; };
int f() {
  C c;                  // does not start lifetime of any union member
  c.b.a.y[3] = 4;       // OK: $S($\tcode{c.b.a.y[3]}$)$ contains \tcode{c.b} and \tcode{c.b.a.y};
                        // creates objects to hold union members \tcode{c.b} and \tcode{c.b.a.y}
  return c.b.a.y[3];    // OK: \tcode{c.b.a.y} refers to newly created object (see \ref{basic.life})
}

struct X { const int a; int b; };
union Y { X x; int k; };
void g() {
  Y y = { { 1, 2 } };   // OK, \tcode{y.x} is active union member\iref{class.mem}
  int n = y.x.a;
  y.k = 4;              // OK: ends lifetime of \tcode{y.x}, \tcode{y.k} is active member of union
  y.x.b = n;            // undefined behavior: \tcode{y.x.b} modified outside its lifetime,
                        // $S($\tcode{y.x.b}$)$ is empty because \tcode{X}'s default constructor is deleted,
                        // so union member \tcode{y.x}'s lifetime does not implicitly start
}
\end{codeblock}
\end{example}

\pnum
\begin{note} In general, one must use explicit destructor calls and placement
\grammarterm{new-expression} to change the active member of a union. \end{note}
\begin{example}
Consider an object \tcode{u} of a \tcode{union} type \tcode{U} having non-static data members
\tcode{m} of type \tcode{M} and \tcode{n} of type \tcode{N}. If \tcode{M} has a non-trivial
destructor and \tcode{N} has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of \tcode{u} can be safely switched from \tcode{m} to
\tcode{n} using the destructor and placement \grammarterm{new-expression} as follows:

\begin{codeblock}
u.m.~M();
new (&u.n) N;
\end{codeblock}
\end{example}

\rSec2[class.union.anon]{Anonymous unions}
\indextext{\idxcode{union}!anonymous}%

\pnum
A union of the form

\begin{ncbnftab}
\terminal{union} \terminal{\{} member-specification \terminal{\}} \terminal{;}
\end{ncbnftab}

is called an \defn{anonymous union}; it defines an unnamed type and
an unnamed object of that type called an \defn{anonymous union object}.
Each \grammarterm{member-declaration} in the \grammarterm{member-specification}
of an anonymous union shall either define a non-static data member or be a
\grammarterm{static_assert-declaration}.
\begin{note}
Nested types, anonymous unions, and functions cannot be declared within an anonymous
union.
\end{note}
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
\indextext{initialization!\idxcode{union}}%
\begin{example}

\begin{codeblock}
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
\end{codeblock}

Here \tcode{a} and \tcode{p} are used like ordinary (non-member)
variables, but since they are union members they have the same address.
\end{example}

\pnum
\indextext{\idxcode{union}!global anonymous}%
\indextext{scope!anonymous \tcode{union} at namespace}%
Anonymous unions declared in a named namespace or in the global
namespace shall be declared \tcode{static}. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
\indextext{access control!anonymous \tcode{union}}%
\indextext{restriction!anonymous \tcode{union}}%
An anonymous union shall not have private or protected
members\iref{class.access}. An anonymous union shall not have
member functions.

\pnum
A union for which objects, pointers, or references are declared is not an anonymous union.
\begin{example}

\begin{codeblock}
void f() {
  union { int aa; char* p; } obj, *ptr = &obj;
  aa = 1;           // error
  ptr->aa = 1;      // OK
}
\end{codeblock}

The assignment to plain \tcode{aa} is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
\end{example}
\begin{note}
Initialization of unions with no user-declared constructors is described
in~\ref{dcl.init.aggr}.
\end{note}

\pnum
\indextext{class!union-like}%
\indextext{class!variant member of}%
A \defn{union-like class} is a union or a class that has an anonymous union as a direct
member. A union-like class \tcode{X} has a set of \defnx{variant members}{variant member}.
If \tcode{X} is a union, a non-static data member of \tcode{X} that is not an anonymous
union is a variant member of \tcode{X}. In addition, a non-static data member of an
anonymous union that is a member of \tcode{X} is also a variant member of \tcode{X}.
At most one variant member of a union may have a default member initializer.
\begin{example}
\begin{codeblock}
union U {
  int x = 0;
  union {
    int k;
  };
  union {
    int z;
    int y = 1;      // error: initialization for second variant member of \tcode{U}
  };
};
\end{codeblock}
\end{example}

\rSec1[class.local]{Local class declarations}
\indextext{declaration!local class}%
\indextext{definition!local class}%
\indextext{class!local|see{local class}}%

\pnum
A class can be declared within a function definition; such a class is
called a \defnx{local}{local class} class. The name of a local class is local to
its enclosing scope.
\indextext{local class!scope of}%
The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function.
\begin{note}
A declaration in a local class
cannot odr-use\iref{basic.def.odr}
a local entity
from an
enclosing scope.
\end{note}
\begin{example}
\indextext{example!local class}%
\begin{codeblock}
int x;
void f() {
  static int s;
  int x;
  const int N = 5;
  extern int q();
  int arr[2];
  auto [y, z] = arr;

  struct local {
    int g() { return x; }       // error: odr-use of non-odr-usable variable \tcode{x}
    int h() { return s; }       // OK
    int k() { return ::x; }     // OK
    int l() { return q(); }     // OK
    int m() { return N; }       // OK: not an odr-use
    int* n() { return &N; }     // error: odr-use of non-odr-usable variable \tcode{N}
    int p() { return y; }       // error: odr-use of non-odr-usable structured binding \tcode{y}
  };
}

local* p = 0;                   // error: \tcode{local} not in scope
\end{codeblock}
\end{example}

\pnum
An enclosing function has no special access to members of the local
class; it obeys the usual access rules\iref{class.access}.
\indextext{member function!local class}%
Member functions of a local class shall be defined within their class
definition, if they are defined at all.

\pnum
\indextext{nested class!local class}%
If class \tcode{X} is a local class a nested class \tcode{Y} may be
declared in class \tcode{X} and later defined in the definition of class
\tcode{X} or be later defined in the same scope as the definition of
class \tcode{X}.
\indextext{restriction!local class}%
A class nested within
a local class is a local class.

\pnum
\indextext{restriction!static member local class}%
A local class shall not have static data members.
