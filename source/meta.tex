%!TEX root = std.tex
\rSec0[meta]{Metaprogramming library}

\rSec1[meta.general]{General}

\pnum
This Clause describes metaprogramming facilities.
These facilities are summarized in \tref{meta.summary}.

\begin{libsumtab}{Metaprogramming library summary}{meta.summary}
\ref{intseq}                & Integer sequences    & \tcode{<utility>} \\ \rowsep
\ref{type.traits}           & Type traits   & \tcode{<type_traits>} \\ \rowsep
\ref{ratio}                 & Rational arithmetic  & \tcode{<ratio>}       \\
\end{libsumtab}

\rSec1[intseq]{Compile-time integer sequences}

\rSec2[intseq.general]{General}

\pnum
The library provides a class template that can represent an integer sequence.
When used as an argument to a function template the template parameter pack defining the
sequence can be deduced and used in a pack expansion.
\begin{note}
The \tcode{index_sequence} alias template is provided for the common case of
an integer sequence of type \tcode{size_t}; see also \ref{tuple.apply}.
\end{note}

\rSec2[intseq.intseq]{Class template \tcode{integer_sequence}}

\indexlibraryglobal{integer_sequence}%
\indexlibrarymember{value_type}{integer_sequence}%
\begin{codeblock}
namespace std {
  template<class T, T... I> struct integer_sequence {
    using value_type = T;
    static constexpr size_t size() noexcept { return sizeof...(I); }
  };
}
\end{codeblock}

\pnum
\mandates
\tcode{T} is an integer type.

\rSec2[intseq.make]{Alias template \tcode{make_integer_sequence}}

\indexlibraryglobal{make_integer_sequence}%
\begin{itemdecl}
template<class T, T N>
  using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
$\tcode{N} \geq 0$.

\pnum
The alias template
\tcode{make_integer_sequence} denotes a specialization of
\tcode{integer_sequence} with \tcode{N} constant template arguments.
The type \tcode{make_integer_sequence<T, N>} is an alias for the type
\tcode{integer_sequence<T, 0, 1, ..., N - 1>}.
\begin{note}
\tcode{make_integer_sequence<int, 0>} is an alias for the type
\tcode{integer_sequence<int>}.
\end{note}
\end{itemdescr}

\rSec1[type.traits]{Metaprogramming and type traits}

\rSec2[type.traits.general]{General}

\pnum
Subclause \ref{type.traits} describes components used by \Cpp{} programs, particularly in
templates, to support the widest possible range of types, optimize
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible \Cpp{} types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.

\pnum
\indextext{signal-safe!type traits}%
All functions specified in \ref{type.traits} are signal-safe\iref{support.signal}.

\rSec2[meta.rqmts]{Requirements}

\pnum
A \defnoldconcept{UnaryTypeTrait} describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be \oldconcept{DefaultConstructible},
\oldconcept{CopyConstructible},
and publicly and unambiguously derived, directly or indirectly, from
its \defn{base characteristic}, which is
a specialization of the template
\tcode{integral_constant}\iref{meta.help}, with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular property being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the \oldconcept{UnaryTypeTrait}.

\pnum
A \defnoldconcept{BinaryTypeTrait} describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be \oldconcept{DefaultConstructible}, \oldconcept{CopyConstructible},
and publicly and unambiguously derived, directly or
indirectly, from
its \term{base characteristic}, which is a specialization
of the template
\tcode{integral_constant}\iref{meta.help}, with
the arguments to the template \tcode{integral_constant} determined by the
requirements for the particular relationship being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the \oldconcept{BinaryTypeTrait}.

\pnum
A \defnoldconcept{TransformationTrait}
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named \tcode{type}, which shall be a synonym for the modified type.

\pnum
Unless otherwise specified,
the behavior of a program that adds specializations
for any of the templates specified in \ref{type.traits}
is undefined.

\pnum
Unless otherwise specified, an incomplete type may be used
to instantiate a template specified in \ref{type.traits}.
The behavior of a program is undefined if
\begin{itemize}
\item
  an instantiation of a template specified in \ref{type.traits}
  directly or indirectly depends on
  an incompletely-defined object type \tcode{T}, and
\item
  that instantiation could yield a different result
  were \tcode{T} hypothetically completed.
\end{itemize}

\rSec2[meta.type.synop]{Header \tcode{<type_traits>} synopsis}

\indexheader{type_traits}%
% FIXME: Many index entries missing.
\begin{codeblock}
// all freestanding
namespace std {
  // \ref{meta.help}, helper class
  template<class T, T v> struct integral_constant;

  template<bool B>
    using @\libglobal{bool_constant}@ = integral_constant<bool, B>;
  using @\libglobal{true_type}@  = bool_constant<true>;
  using @\libglobal{false_type}@ = bool_constant<false>;

  // \ref{meta.unary.cat}, primary type categories
  template<class T> struct is_void;
  template<class T> struct is_null_pointer;
  template<class T> struct is_integral;
  template<class T> struct is_floating_point;
  template<class T> struct is_array;
  template<class T> struct is_pointer;
  template<class T> struct is_lvalue_reference;
  template<class T> struct is_rvalue_reference;
  template<class T> struct is_member_object_pointer;
  template<class T> struct is_member_function_pointer;
  template<class T> struct is_enum;
  template<class T> struct is_union;
  template<class T> struct is_class;
  template<class T> struct is_function;

  // \ref{meta.unary.comp}, composite type categories
  template<class T> struct is_reference;
  template<class T> struct is_arithmetic;
  template<class T> struct is_fundamental;
  template<class T> struct is_object;
  template<class T> struct is_scalar;
  template<class T> struct is_compound;
  template<class T> struct is_member_pointer;

  // \ref{meta.unary.prop}, type properties
  template<class T> struct is_const;
  template<class T> struct is_volatile;
  template<class T> struct is_trivially_copyable;
  template<class T> struct is_trivially_relocatable;
  template<class T> struct is_replaceable;
  template<class T> struct is_standard_layout;
  template<class T> struct is_empty;
  template<class T> struct is_polymorphic;
  template<class T> struct is_abstract;
  template<class T> struct is_final;
  template<class T> struct is_aggregate;

  template<class T> struct is_signed;
  template<class T> struct is_unsigned;
  template<class T> struct is_bounded_array;
  template<class T> struct is_unbounded_array;
  template<class T> struct is_scoped_enum;

  template<class T, class... Args> struct is_constructible;
  template<class T> struct is_default_constructible;
  template<class T> struct is_copy_constructible;
  template<class T> struct is_move_constructible;

  template<class T, class U> struct is_assignable;
  template<class T> struct is_copy_assignable;
  template<class T> struct is_move_assignable;

  template<class T, class U> struct is_swappable_with;
  template<class T> struct is_swappable;

  template<class T> struct is_destructible;

  template<class T, class... Args> struct is_trivially_constructible;
  template<class T> struct is_trivially_default_constructible;
  template<class T> struct is_trivially_copy_constructible;
  template<class T> struct is_trivially_move_constructible;

  template<class T, class U> struct is_trivially_assignable;
  template<class T> struct is_trivially_copy_assignable;
  template<class T> struct is_trivially_move_assignable;
  template<class T> struct is_trivially_destructible;

  template<class T, class... Args> struct is_nothrow_constructible;
  template<class T> struct is_nothrow_default_constructible;
  template<class T> struct is_nothrow_copy_constructible;
  template<class T> struct is_nothrow_move_constructible;

  template<class T, class U> struct is_nothrow_assignable;
  template<class T> struct is_nothrow_copy_assignable;
  template<class T> struct is_nothrow_move_assignable;

  template<class T, class U> struct is_nothrow_swappable_with;
  template<class T> struct is_nothrow_swappable;

  template<class T> struct is_nothrow_destructible;
  template<class T> struct is_nothrow_relocatable;

  template<class T> struct is_implicit_lifetime;

  template<class T> struct has_virtual_destructor;

  template<class T> struct has_unique_object_representations;

  template<class T, class U> struct reference_constructs_from_temporary;
  template<class T, class U> struct reference_converts_from_temporary;

  // \ref{meta.unary.prop.query}, type property queries
  template<class T> struct alignment_of;
  template<class T> struct rank;
  template<class T, unsigned I = 0> struct extent;

  // \ref{meta.rel}, type relations
  template<class T, class U> struct is_same;
  template<class Base, class Derived> struct is_base_of;
  template<class Base, class Derived> struct is_virtual_base_of;
  template<class From, class To> struct is_convertible;
  template<class From, class To> struct is_nothrow_convertible;
  template<class T, class U> struct is_layout_compatible;
  template<class Base, class Derived> struct is_pointer_interconvertible_base_of;

  template<class Fn, class... ArgTypes> struct is_invocable;
  template<class R, class Fn, class... ArgTypes> struct is_invocable_r;

  template<class Fn, class... ArgTypes> struct is_nothrow_invocable;
  template<class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;

  // \ref{meta.trans.cv}, const-volatile modifications
  template<class T> struct remove_const;
  template<class T> struct remove_volatile;
  template<class T> struct remove_cv;
  template<class T> struct add_const;
  template<class T> struct add_volatile;
  template<class T> struct add_cv;

  template<class T>
    using @\libglobal{remove_const_t}@    = typename remove_const<T>::type;
  template<class T>
    using @\libglobal{remove_volatile_t}@ = typename remove_volatile<T>::type;
  template<class T>
    using @\libglobal{remove_cv_t}@       = typename remove_cv<T>::type;
  template<class T>
    using @\libglobal{add_const_t}@       = typename add_const<T>::type;
  template<class T>
    using @\libglobal{add_volatile_t}@    = typename add_volatile<T>::type;
  template<class T>
    using @\libglobal{add_cv_t}@          = typename add_cv<T>::type;

  // \ref{meta.trans.ref}, reference modifications
  template<class T> struct remove_reference;
  template<class T> struct add_lvalue_reference;
  template<class T> struct add_rvalue_reference;

  template<class T>
    using @\libglobal{remove_reference_t}@     = typename remove_reference<T>::type;
  template<class T>
    using @\libglobal{add_lvalue_reference_t}@ = typename add_lvalue_reference<T>::type;
  template<class T>
    using @\libglobal{add_rvalue_reference_t}@ = typename add_rvalue_reference<T>::type;

  // \ref{meta.trans.sign}, sign modifications
  template<class T> struct make_signed;
  template<class T> struct make_unsigned;

  template<class T>
    using @\libglobal{make_signed_t}@   = typename make_signed<T>::type;
  template<class T>
    using @\libglobal{make_unsigned_t}@ = typename make_unsigned<T>::type;

  // \ref{meta.trans.arr}, array modifications
  template<class T> struct remove_extent;
  template<class T> struct remove_all_extents;

  template<class T>
    using @\libglobal{remove_extent_t}@      = typename remove_extent<T>::type;
  template<class T>
    using @\libglobal{remove_all_extents_t}@ = typename remove_all_extents<T>::type;

  // \ref{meta.trans.ptr}, pointer modifications
  template<class T> struct remove_pointer;
  template<class T> struct add_pointer;

  template<class T>
    using @\libglobal{remove_pointer_t}@ = typename remove_pointer<T>::type;
  template<class T>
    using @\libglobal{add_pointer_t}@    = typename add_pointer<T>::type;

  // \ref{meta.trans.other}, other transformations
  template<class T> struct type_identity;
  template<class T> struct remove_cvref;
  template<class T> struct decay;
  template<bool, class T = void> struct enable_if;
  template<bool, class T, class F> struct conditional;
  template<class... T> struct common_type;
  template<class T, class U, template<class> class TQual, template<class> class UQual>
    struct basic_common_reference { };
  template<class... T> struct common_reference;
  template<class T> struct underlying_type;
  template<class Fn, class... ArgTypes> struct invoke_result;
  template<class T> struct unwrap_reference;
  template<class T> struct unwrap_ref_decay;

  template<class T>
    using @\libglobal{type_identity_t}@    = typename type_identity<T>::type;
  template<class T>
    using @\libglobal{remove_cvref_t}@     = typename remove_cvref<T>::type;
  template<class T>
    using @\libglobal{decay_t}@            = typename decay<T>::type;
  template<bool B, class T = void>
    using @\libglobal{enable_if_t}@        = typename enable_if<B, T>::type;
  template<bool B, class T, class F>
    using @\libglobal{conditional_t}@      = typename conditional<B, T, F>::type;
  template<class... T>
    using @\libglobal{common_type_t}@      = typename common_type<T...>::type;
  template<class... T>
    using @\libglobal{common_reference_t}@ = typename common_reference<T...>::type;
  template<class T>
    using @\libglobal{underlying_type_t}@  = typename underlying_type<T>::type;
  template<class Fn, class... ArgTypes>
    using @\libglobal{invoke_result_t}@    = typename invoke_result<Fn, ArgTypes...>::type;
  template<class T>
    using unwrap_reference_t = typename unwrap_reference<T>::type;
  template<class T>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type;
  template<class...>
    using @\libglobal{void_t}@             = void;

  // \ref{meta.logical}, logical operator traits
  template<class... B> struct conjunction;
  template<class... B> struct disjunction;
  template<class B> struct negation;

  // \ref{meta.unary.cat}, primary type categories
  template<class T>
    constexpr bool @\libglobal{is_void_v}@ = is_void<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_null_pointer_v}@ = is_null_pointer<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_integral_v}@ = is_integral<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_floating_point_v}@ = is_floating_point<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_array_v}@ = is_array<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_pointer_v}@ = is_pointer<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_lvalue_reference_v}@ = is_lvalue_reference<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_rvalue_reference_v}@ = is_rvalue_reference<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_member_object_pointer_v}@ = is_member_object_pointer<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_member_function_pointer_v}@ = is_member_function_pointer<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_enum_v}@ = is_enum<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_union_v}@ = is_union<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_class_v}@ = is_class<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_function_v}@ = is_function<T>::value;

  // \ref{meta.unary.comp}, composite type categories
  template<class T>
    constexpr bool @\libglobal{is_reference_v}@ = is_reference<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_arithmetic_v}@ = is_arithmetic<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_fundamental_v}@ = is_fundamental<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_object_v}@ = is_object<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_scalar_v}@ = is_scalar<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_compound_v}@ = is_compound<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_member_pointer_v}@ = is_member_pointer<T>::value;

  // \ref{meta.unary.prop}, type properties
  template<class T>
    constexpr bool @\libglobal{is_const_v}@ = is_const<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_volatile_v}@ = is_volatile<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_trivially_copyable_v}@ = is_trivially_copyable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_trivially_relocatable_v}@ = is_trivially_relocatable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_standard_layout_v}@ = is_standard_layout<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_empty_v}@ = is_empty<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_polymorphic_v}@ = is_polymorphic<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_abstract_v}@ = is_abstract<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_final_v}@ = is_final<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_aggregate_v}@ = is_aggregate<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_signed_v}@ = is_signed<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_unsigned_v}@ = is_unsigned<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_bounded_array_v}@ = is_bounded_array<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_unbounded_array_v}@ = is_unbounded_array<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_scoped_enum_v}@ = is_scoped_enum<T>::value;
  template<class T, class... Args>
    constexpr bool @\libglobal{is_constructible_v}@ = is_constructible<T, Args...>::value;
  template<class T>
    constexpr bool @\libglobal{is_default_constructible_v}@ = is_default_constructible<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_copy_constructible_v}@ = is_copy_constructible<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_move_constructible_v}@ = is_move_constructible<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_assignable_v}@ = is_assignable<T, U>::value;
  template<class T>
    constexpr bool @\libglobal{is_copy_assignable_v}@ = is_copy_assignable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_move_assignable_v}@ = is_move_assignable<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_swappable_with_v}@ = is_swappable_with<T, U>::value;
  template<class T>
    constexpr bool @\libglobal{is_swappable_v}@ = is_swappable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_destructible_v}@ = is_destructible<T>::value;
  template<class T, class... Args>
    constexpr bool is_trivially_constructible_v
      = is_trivially_constructible<T, Args...>::value;
  template<class T>
    constexpr bool is_trivially_default_constructible_v
      = is_trivially_default_constructible<T>::value;
  template<class T>
    constexpr bool is_trivially_copy_constructible_v
      = is_trivially_copy_constructible<T>::value;
  template<class T>
    constexpr bool is_trivially_move_constructible_v
      = is_trivially_move_constructible<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_trivially_assignable_v}@ = is_trivially_assignable<T, U>::value;
  template<class T>
    constexpr bool is_trivially_copy_assignable_v
      = is_trivially_copy_assignable<T>::value;
  template<class T>
    constexpr bool is_trivially_move_assignable_v
      = is_trivially_move_assignable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_trivially_destructible_v}@ = is_trivially_destructible<T>::value;
  template<class T, class... Args>
    constexpr bool is_nothrow_constructible_v
      = is_nothrow_constructible<T, Args...>::value;
  template<class T>
    constexpr bool is_nothrow_default_constructible_v
      = is_nothrow_default_constructible<T>::value;
  template<class T>
    constexpr bool is_nothrow_copy_constructible_v
      = is_nothrow_copy_constructible<T>::value;
  template<class T>
    constexpr bool is_nothrow_move_constructible_v
      = is_nothrow_move_constructible<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_nothrow_assignable_v}@ = is_nothrow_assignable<T, U>::value;
  template<class T>
    constexpr bool @\libglobal{is_nothrow_copy_assignable_v}@ = is_nothrow_copy_assignable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_nothrow_move_assignable_v}@ = is_nothrow_move_assignable<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_nothrow_swappable_with_v}@ = is_nothrow_swappable_with<T, U>::value;
  template<class T>
    constexpr bool @\libglobal{is_nothrow_swappable_v}@ = is_nothrow_swappable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_nothrow_destructible_v}@ = is_nothrow_destructible<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_nothrow_relocatable_v}@ = is_nothrow_relocatable<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_implicit_lifetime_v}@ = is_implicit_lifetime<T>::value;
  template<class T>
    constexpr bool @\libglobal{is_replaceable_v}@ = is_replaceable<T>::value;
  template<class T>
    constexpr bool @\libglobal{has_virtual_destructor_v}@ = has_virtual_destructor<T>::value;
  template<class T>
    constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<T>::value;
  template<class T, class U>
    constexpr bool @\libglobal{reference_constructs_from_temporary_v}@
      = reference_constructs_from_temporary<T, U>::value;
  template<class T, class U>
    constexpr bool @\libglobal{reference_converts_from_temporary_v}@
      = reference_converts_from_temporary<T, U>::value;

  // \ref{meta.unary.prop.query}, type property queries
  template<class T>
    constexpr size_t @\libglobal{alignment_of_v}@ = alignment_of<T>::value;
  template<class T>
    constexpr size_t @\libglobal{rank_v}@ = rank<T>::value;
  template<class T, unsigned I = 0>
    constexpr size_t @\libglobal{extent_v}@ = extent<T, I>::value;

  // \ref{meta.rel}, type relations
  template<class T, class U>
    constexpr bool @\libglobal{is_same_v}@ = is_same<T, U>::value;
  template<class Base, class Derived>
    constexpr bool @\libglobal{is_base_of_v}@ = is_base_of<Base, Derived>::value;
  template<class Base, class Derived>
    constexpr bool @\libglobal{is_virtual_base_of_v}@ = is_virtual_base_of<Base, Derived>::value;
  template<class From, class To>
    constexpr bool @\libglobal{is_convertible_v}@ = is_convertible<From, To>::value;
  template<class From, class To>
    constexpr bool @\libglobal{is_nothrow_convertible_v}@ = is_nothrow_convertible<From, To>::value;
  template<class T, class U>
    constexpr bool @\libglobal{is_layout_compatible_v}@ = is_layout_compatible<T, U>::value;
  template<class Base, class Derived>
    constexpr bool is_pointer_interconvertible_base_of_v
      = is_pointer_interconvertible_base_of<Base, Derived>::value;
  template<class Fn, class... ArgTypes>
    constexpr bool @\libglobal{is_invocable_v}@ = is_invocable<Fn, ArgTypes...>::value;
  template<class R, class Fn, class... ArgTypes>
    constexpr bool @\libglobal{is_invocable_r_v}@ = is_invocable_r<R, Fn, ArgTypes...>::value;
  template<class Fn, class... ArgTypes>
    constexpr bool @\libglobal{is_nothrow_invocable_v}@ = is_nothrow_invocable<Fn, ArgTypes...>::value;
  template<class R, class Fn, class... ArgTypes>
    constexpr bool is_nothrow_invocable_r_v
      = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;

  // \ref{meta.logical}, logical operator traits
  template<class... B>
    constexpr bool @\libglobal{conjunction_v}@ = conjunction<B...>::value;
  template<class... B>
    constexpr bool @\libglobal{disjunction_v}@ = disjunction<B...>::value;
  template<class B>
    constexpr bool @\libglobal{negation_v}@ = negation<B>::value;

  // \ref{meta.member}, member relationships
  template<class S, class M>
    constexpr bool is_pointer_interconvertible_with_class(M S::*m) noexcept;
  template<class S1, class S2, class M1, class M2>
    constexpr bool is_corresponding_member(M1 S1::*m1, M2 S2::*m2) noexcept;

  // \ref{meta.const.eval}, constant evaluation context
  constexpr bool is_constant_evaluated() noexcept;
  consteval bool is_within_lifetime(const auto*) noexcept;
}
\end{codeblock}

\rSec2[meta.help]{Helper classes}

\indexlibrarymember{value_type}{integral_constant}%
\begin{codeblock}
namespace std {
  template<class T, T v> struct @\libglobal{integral_constant}@ {
    static constexpr T value = v;

    using value_type = T;
    using type = integral_constant<T, v>;

    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
}
\end{codeblock}

\indexlibraryglobal{bool_constant}%
\indexlibraryglobal{true_type}%
\indexlibraryglobal{false_type}%
\pnum
The class template \tcode{integral_constant},
alias template \tcode{bool_constant}, and
its associated \grammarterm{typedef-name}{s}
\tcode{true_type} and \tcode{false_type}
are used as base classes to define
the interface for various type traits.

\rSec2[meta.unary]{Unary type traits}

\rSec3[meta.unary.general]{General}

\pnum
Subclause \ref{meta.unary} contains templates that may be used to query the
properties of a type at compile time.

\pnum
Each of these templates shall be a
\oldconcept{UnaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of
\tcode{true_type} if the corresponding condition is \tcode{true}, otherwise
\tcode{false_type}.

\rSec3[meta.unary.cat]{Primary type categories}

\pnum
The primary type categories specified in \tref{meta.unary.cat}
correspond to the descriptions given in
subclause~\ref{basic.types} of the \Cpp{} standard.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T} and to \cv{}~\tcode{T} shall yield the same result.

\pnum
\begin{note}
For any given type \tcode{T}, exactly one of the primary type categories
has a \tcode{value} member that evaluates to \tcode{true}.
\end{note}

\begin{libreqtab3e}{Primary type category predicates}{meta.unary.cat}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\\capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\indexlibraryglobal{is_void}%
\tcode{template<class T>}\br
 \tcode{struct is_void;}                &
\tcode{T} is \keyword{void}       &   \\ \rowsep
\indexlibraryglobal{is_null_pointer}%
\tcode{template<class T>}\br
 \tcode{struct is_null_pointer;}                &
\tcode{T} is \tcode{nullptr_t}\iref{basic.fundamental}       &   \\ \rowsep
\indexlibraryglobal{is_integral}%
\tcode{template<class T>}\br
 \tcode{struct is_integral;}        &
\tcode{T} is an integral type\iref{basic.fundamental}                 &   \\ \rowsep
\indexlibraryglobal{is_floating_point}%
\tcode{template<class T>}\br
 \tcode{struct is_floating_point;}  &
\tcode{T} is a floating-point type\iref{basic.fundamental}            &   \\ \rowsep
\indexlibraryglobal{is_array}%
\tcode{template<class T>}\br
 \tcode{struct is_array;}           &
\tcode{T} is an array type\iref{basic.compound} of known or unknown extent    &
Class template \tcode{array}\iref{array}
is not an array type.                   \\ \rowsep
\indexlibraryglobal{is_pointer}%
\tcode{template<class T>}\br
 \tcode{struct is_pointer;}         &
\tcode{T} is a pointer type\iref{basic.compound}                      &
Includes pointers to functions
but not pointers to non-static members.                        \\ \rowsep
\indexlibraryglobal{is_lvalue_reference}%
\tcode{template<class T>}\br
 \tcode{struct is_lvalue_reference;}    &
 \tcode{T} is an lvalue reference type\iref{dcl.ref}   &   \\ \rowsep
\indexlibraryglobal{is_rvalue_reference}%
\tcode{template<class T>}\br
 \tcode{struct is_rvalue_reference;}    &
 \tcode{T} is an rvalue reference type\iref{dcl.ref}   &   \\ \rowsep
\indexlibraryglobal{is_member_object_pointer}%
\tcode{template<class T>}\br
 \tcode{struct is_member_object_pointer;}&
 \tcode{T} is a pointer to data member                              &   \\ \rowsep
\indexlibraryglobal{is_member_function_pointer}%
\tcode{template<class T>}\br
 \tcode{struct is_member_function_pointer;}&
\tcode{T} is a pointer to member function                           &   \\ \rowsep
\indexlibraryglobal{is_enum}%
\tcode{template<class T>}\br
 \tcode{struct is_enum;}            &
\tcode{T} is an enumeration type\iref{basic.compound}                 &   \\ \rowsep
\indexlibraryglobal{is_union}%
\tcode{template<class T>}\br
 \tcode{struct is_union;}           &
\tcode{T} is a union type\iref{basic.compound}                        &   \\ \rowsep
\indexlibraryglobal{is_class}%
\tcode{template<class T>}\br
 \tcode{struct is_class;}           &
\tcode{T} is a non-union class type\iref{basic.compound} & \\ \rowsep
\indexlibraryglobal{is_function}%
\tcode{template<class T>}\br
 \tcode{struct is_function;}        &
\tcode{T} is a function type\iref{basic.compound}                     &   \\
\end{libreqtab3e}

\rSec3[meta.unary.comp]{Composite type traits}

\pnum
The templates specified in \tref{meta.unary.comp}
provide convenient compositions of the primary type categories,
corresponding to the descriptions given in subclause~\ref{basic.types}.

\pnum
For any given type \tcode{T}, the result of applying one of these templates to
\tcode{T} and to \cv{}~\tcode{T} shall yield the same result.

\begin{libreqtab3b}{Composite type category predicates}{meta.unary.comp}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\indexlibraryglobal{is_reference}%
\tcode{template<class T>}\br
 \tcode{struct is_reference;}   &
 \tcode{T} is an lvalue reference or an rvalue reference &  \\ \rowsep
\indexlibraryglobal{is_arithmetic}%
\tcode{template<class T>}\br
 \tcode{struct is_arithmetic;}          &
 \tcode{T} is an arithmetic type\iref{basic.fundamental}              &   \\ \rowsep
\indexlibraryglobal{is_fundamental}%
\tcode{template<class T>}\br
 \tcode{struct is_fundamental;}         &
 \tcode{T} is a fundamental type\iref{basic.fundamental}              &   \\ \rowsep
\indexlibraryglobal{is_object}%
\tcode{template<class T>}\br
 \tcode{struct is_object;}              &
 \tcode{T} is an object type\iref{term.object.type}                    &   \\ \rowsep
\indexlibraryglobal{is_scalar}%
\tcode{template<class T>}\br
 \tcode{struct is_scalar;}              &
 \tcode{T} is a scalar type\iref{term.scalar.type}                       &   \\ \rowsep
\indexlibraryglobal{is_compound}%
\tcode{template<class T>}\br
 \tcode{struct is_compound;}            &
 \tcode{T} is a compound type\iref{basic.compound}                        &   \\ \rowsep
\indexlibraryglobal{is_member_pointer}%
\tcode{template<class T>}\br
 \tcode{struct is_member_pointer;}      &
 \tcode{T} is a pointer-to-member type\iref{basic.compound}               &   \\
\end{libreqtab3b}

\rSec3[meta.unary.prop]{Type properties}

\pnum
The templates specified in \tref{meta.unary.prop}
provide access to some of the more important properties of types.

\pnum
It is unspecified whether the library defines any full or partial
specializations of any of these templates.

\pnum
For all of the class templates \tcode{X} declared in this subclause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of \tcode{X} require that
the argument is a complete type.

\pnum
For the purpose of defining the templates in this subclause,
a function call expression \tcode{declval<T>()} for any type \tcode{T}
is considered to be a trivial\iref{term.trivial.type,special} function call
that is not an odr-use\iref{term.odr.use} of \tcode{declval}
in the context of the corresponding definition
notwithstanding the restrictions of~\ref{declval}.

\pnum
For the purpose of defining the templates in this subclause,
let \tcode{\placeholdernc{VAL}<T>} for some type \tcode{T} be
an expression defined as follows:
\begin{itemize}
\item
If \tcode{T} is a reference or function type,
\tcode{\placeholdernc{VAL}<T>} is an expression
with the same type and value category as \tcode{declval<T>()}.
\item
Otherwise, \tcode{\placeholdernc{VAL}<T>} is a prvalue
that initially has type \tcode{T}.
\begin{note}
If \tcode{T} is cv-qualified,
the cv-qualification is subject to adjustment\iref{expr.type}.
\end{note}
\end{itemize}

\begin{libreqtab3b}{Type property predicates}{meta.unary.prop}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Preconditions}    \\ \capsep
\endhead

\indexlibraryglobal{is_const}%
\tcode{template<class T>}\br
 \tcode{struct is_const;}               &
 \tcode{T} is const-qualified\iref{basic.type.qualifier}                  &   \\ \rowsep

\indexlibraryglobal{is_volatile}%
\tcode{template<class T>}\br
 \tcode{struct is_volatile;}            &
 \tcode{T} is volatile-qualified\iref{basic.type.qualifier}                   &   \\ \rowsep


\indexlibraryglobal{is_trivially_copyable}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copyable;}      &
 \tcode{T} is a trivially copyable type\iref{term.trivially.copyable.type} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 \cv{}~\keyword{void}.                               \\ \rowsep

\indexlibraryglobal{is_trivially_relocatable}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_relocatable;} &
 \tcode{T} is a trivially relocatable type\iref{basic.types.general} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 \cv{}~\keyword{void}, \\ \rowsep

\indexlibraryglobal{is_replaceable}%
\tcode{template<class T>}\br
 \tcode{struct is_replaceable;} &
 \tcode{T} is a replaceable type\iref{basic.types.general} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 \cv{}~\keyword{void}, \\ \rowsep

\indexlibraryglobal{is_standard_layout}%
\tcode{template<class T>}\br
 \tcode{struct is_standard_layout;}                 &
 \tcode{T} is a standard-layout type\iref{term.standard.layout.type}   &
 \tcode{remove_all_extents_t<T>} shall be a complete
 type or \cv{}~\keyword{void}.                \\ \rowsep

\indexlibrary{\idxcode{is_empty}!class}%
\tcode{template<class T>}\br
 \tcode{struct is_empty;}               &
 \tcode{T} is a class type, but not a union type, with no non-static data
 members other than subobjects of zero size, no virtual member functions,
 no virtual base classes, and no base class \tcode{B} for
 which \tcode{is_empty_v<B>} is \tcode{false}. &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                               \\ \rowsep

\indexlibraryglobal{is_polymorphic}%
\tcode{template<class T>}\br
 \tcode{struct is_polymorphic;}         &
 \tcode{T} is a polymorphic class\iref{class.virtual}                             &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibraryglobal{is_abstract}%
\tcode{template<class T>}\br
 \tcode{struct is_abstract;}            &
 \tcode{T} is an abstract class\iref{class.abstract}                              &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibraryglobal{is_final}%
\tcode{template<class T>}\br
 \tcode{struct is_final;}               &
 \tcode{T} is a class type marked with the \grammarterm{class-property-specifier}
 \tcode{final}\iref{class.pre}.
\begin{tailnote}
A union is a class type that
 can be marked with \tcode{final}.
\end{tailnote}
&
 If \tcode{T} is a class type, \tcode{T} shall be a complete type.                          \\ \rowsep

\indexlibraryglobal{is_aggregate}%
\tcode{template<class T>}\br
  \tcode{struct is_aggregate;}           &
 \tcode{T} is an aggregate type\iref{dcl.init.aggr} &
 \tcode{T} shall be an array type, a complete type, or \cv~\keyword{void}.              \\ \rowsep

\indexlibrary{\idxcode{is_signed}!class}%
\tcode{template<class T>}\br
  \tcode{struct is_signed;}              &
  If \tcode{is_arithmetic_v<T>} is \tcode{true}, the same result as
  \tcode{T(-1) < T(0)};
  otherwise, \tcode{false}   &   \\  \rowsep

\indexlibraryglobal{is_unsigned}%
\tcode{template<class T>}\br
  \tcode{struct is_unsigned;}            &
  If \tcode{is_arithmetic_v<T>} is \tcode{true}, the same result as
  \tcode{T(0) < T(-1)};
  otherwise, \tcode{false}   &   \\  \rowsep

\indexlibraryglobal{is_bounded_array}%
\tcode{template<class T>}\br
  \tcode{struct is_bounded_array;}       &
  \tcode{T} is an array type of known bound\iref{dcl.array}
                             &   \\  \rowsep

\indexlibraryglobal{is_unbounded_array}%
\tcode{template<class T>}\br
  \tcode{struct is_unbounded_array;}     &
  \tcode{T} is an array type of unknown bound\iref{dcl.array}
                             &   \\  \rowsep

\indexlibraryglobal{is_scoped_enum}%
\tcode{template<class T>}\br
  \tcode{struct is_scoped_enum;}     &
  \tcode{T} is a scoped enumeration\iref{dcl.enum}
                             &   \\  \rowsep

\indexlibraryglobal{is_constructible}%
\tcode{template<class T, class... Args>}\br
 \tcode{struct is_constructible;}   &
 For a function type \tcode{T} or
 for a \cv{}~\keyword{void} type \tcode{T},
 \tcode{is_constructible_v<T, Args...>} is \tcode{false},
 otherwise \seebelow                &
 \tcode{T} and all types in the template parameter pack \tcode{Args}
 shall be complete types, \cv{}~\keyword{void},
 or arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{is_default_constructible}%
\tcode{template<class T>}\br
  \tcode{struct is_default_constructible;} &
  \tcode{is_constructible_v<T>} is \tcode{true}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_copy_constructible}%
\tcode{template<class T>}\br
  \tcode{struct is_copy_constructible;} &
  For a referenceable type \tcode{T}\iref{defns.referenceable}, the same result as
  \tcode{is_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_move_constructible}%
\tcode{template<class T>}\br
  \tcode{struct is_move_constructible;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_assignable}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_assignable;} &
  The expression \tcode{declval<T>() =} \tcode{declval<U>()} is well-formed
  when treated as an unevaluated
  operand\iref{term.unevaluated.operand}. Access checking is performed as if in a context
  unrelated to \tcode{T} and \tcode{U}. Only the validity of the immediate context
  of the assignment expression is considered.
\begin{tailnote}
The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the ``immediate
  context'' and can result in the program being ill-formed.
\end{tailnote}
&
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\keyword{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibraryglobal{is_copy_assignable}%
\tcode{template<class T>}\br
  \tcode{struct is_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_move_assignable}%
\tcode{template<class T>}\br
  \tcode{struct is_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_swappable_with}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_swappable_with;} &
  The expressions \tcode{swap(declval<T>(), declval<U>())} and
  \tcode{swap(declval<U>(), declval<T>())} are each well-formed
  when treated as an unevaluated operand\iref{term.unevaluated.operand}
  in an overload-resolution context
  for swappable values\iref{swappable.requirements}.
  Access checking is performed as if in a context
  unrelated to \tcode{T} and \tcode{U}.
  Only the validity of the immediate context
  of the \tcode{swap} expressions is considered.
  \begin{tailnote}
  The compilation of the expressions can result in side effects
  such as the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such side effects are not in the ``immediate context'' and
  can result in the program being ill-formed.
  \end{tailnote}
&
  \tcode{T} and \tcode{U} shall be complete types,
  \cv{}~\keyword{void}, or
  arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{is_swappable}%
\tcode{template<class T>}\br
  \tcode{struct is_swappable;} &
  For a referenceable type \tcode{T},
  the same result as \tcode{is_swappable_with_v<T\&, T\&>},
  otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
  \cv{}~\keyword{void}, or
  an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_destructible}%
\tcode{template<class T>}\br
  \tcode{struct is_destructible;} &
  Either \tcode{T} is a reference type,
  or \tcode{T} is a complete object type
  for which the expression
  \tcode{declval<U\&>().\~U()}
  is well-formed
  when treated as an unevaluated operand\iref{term.unevaluated.operand},
  where \tcode{U} is
  \tcode{remove_all_extents_t<T>}. &
  \tcode{T} shall be a complete type, \cv{}~\keyword{void},
  or an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_trivially_constructible}%
\tcode{template<class T, class... Args>}\br
  \keyword{struct}\br
  \tcode{is_trivially_constructible;} &
  \tcode{is_constructible_v<T,}\br
  \tcode{Args...>} is \tcode{true} and the variable
  definition for \tcode{is_constructible}, as defined below, is known to call
  no operation that is not trivial\iref{term.trivial.type,special}. &
  \tcode{T} and all types in the template parameter pack \tcode{Args} shall be complete types,
  \cv{}~\keyword{void}, or arrays of unknown bound. \\ \rowsep

\indexlibraryglobal{is_trivially_default_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_default_constructible;} &
 \tcode{is_trivially_constructible_v<T>} is \tcode{true}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_trivially_copy_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_trivially_move_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_trivially_assignable}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_trivially_assignable;} &
  \tcode{is_assignable_v<T, U>} is \tcode{true} and the assignment, as defined by
  \tcode{is_assignable}, is known to call no operation that is not
  trivial\iref{term.trivial.type,special}. &
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\keyword{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibraryglobal{is_trivially_copy_assignable}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_trivially_move_assignable}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_trivially_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown bound.                \\ \rowsep

\indexlibraryglobal{is_trivially_destructible}%
\tcode{template<class T>}\br
 \tcode{struct is_trivially_destructible;} &
 \tcode{is_destructible_v<T>} is \tcode{true} and
 \tcode{remove_all_extents_t<T>} is either a non-class type or
 a class type with a trivial destructor. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_constructible}%
\tcode{template<class T, class... Args>}\br
 \tcode{struct is_nothrow_constructible;}   &
 \tcode{is_constructible_v<T,} \tcode{ Args...>} is \tcode{true}
 and the
 variable definition for \tcode{is_constructible}, as defined below, is known not to
 throw any exceptions\iref{expr.unary.noexcept}.
 &
 \tcode{T} and all types in the template parameter pack \tcode{Args}
 shall be complete types, \cv{}~\keyword{void},
 or arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{is_nothrow_default_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_default_constructible;} &
 \tcode{is_nothrow_constructible_v<T>} is \tcode{true}.  &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_copy_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_copy_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible_v<T, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_move_constructible}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_move_constructible;}      &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_constructible_v<T, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_assignable}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_nothrow_assignable;} &
  \tcode{is_assignable_v<T, U>} is \tcode{true} and the assignment is known not to
  throw any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} and \tcode{U} shall be complete types, \cv{}~\keyword{void},
  or arrays of unknown bound. \\ \rowsep

\indexlibraryglobal{is_nothrow_copy_assignable}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_copy_assignable;} &
  For a referenceable type \tcode{T}, the same result as
 \tcode{is_nothrow_assignable_v<T\&, const T\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_move_assignable}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_move_assignable;} &
  For a referenceable type \tcode{T}, the same result as
  \tcode{is_nothrow_assignable_v<T\&, T\&\&>}, otherwise \tcode{false}. &
 \tcode{T} shall be a complete type,
 \cv{}~\keyword{void}, or an array of unknown
 bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_swappable_with}%
\tcode{template<class T, class U>}\br
  \tcode{struct is_nothrow_swappable_with;} &
  \tcode{is_swappable_with_v<T, U>} is \tcode{true} and
  each \tcode{swap} expression of the definition of
  \tcode{is_swappable_with<T, U>} is known not to throw
  any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} and \tcode{U} shall be complete types,
  \cv{}~\keyword{void}, or
  arrays of unknown bound. \\ \rowsep

\indexlibraryglobal{is_nothrow_swappable}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_swappable;} &
  For a referenceable type \tcode{T},
  the same result as \tcode{is_nothrow_swappable_with_v<T\&, T\&>},
  otherwise \tcode{false}. &
  \tcode{T} shall be a complete type,
  \cv{}~\keyword{void}, or
  an array of unknown bound. \\ \rowsep

\indexlibraryglobal{is_nothrow_destructible}%
\tcode{template<class T>}\br
  \tcode{struct is_nothrow_destructible;} &
  \tcode{is_destructible_v<T>} is \tcode{true} and the indicated destructor is known
  not to throw any exceptions\iref{expr.unary.noexcept}. &
  \tcode{T} shall be a complete type,
  \cv{}~\keyword{void}, or an array of unknown
  bound.                \\ \rowsep

\indexlibraryglobal{is_nothrow_relocatable}%
\tcode{template<class T>}\br
 \tcode{struct is_nothrow_relocatable;} &
 \tcode{is_trivially_relocatable_v<T> ||}
 \tcode{(is_nothrow_move_constructible_v<}
 \tcode{remove_all_extents_t<T>> \&\& is_nothrow_destructible_v<}
 \tcode{remove_all_extents_t<T>>)} &
 \tcode{remove_all_extents_t<T>} shall be a complete type or
 \cv{}~\keyword{void}, \\ \rowsep

\indexlibraryglobal{is_implicit_lifetime}%
\tcode{template<class T>}\br
  \tcode{struct is_implicit_lifetime;} &
  \tcode{T} is an implicit-lifetime type\iref{term.implicit.lifetime.type}. &
  \tcode{T} shall be an array type,
  a complete type, or \cv{}~\keyword{void}.  \\ \rowsep

\indexlibraryglobal{has_virtual_destructor}%
\tcode{template<class T>}\br
 \tcode{struct has_virtual_destructor;} &
 \tcode{T} has a virtual destructor\iref{class.dtor} &
 If \tcode{T} is a non-union class type, \tcode{T} shall be a complete type.                \\ \rowsep

\indexlibraryglobal{has_unique_object_representations}%
\tcode{template<class T>}\br
  \tcode{struct has_unique_object_representations;} &
  For an array type \tcode{T}, the same result as
  \tcode{has_unique_object_representations_v<remove_all_extents_t<T>>},
  otherwise \seebelow. &
  \tcode{remove_all_extents_t<T>} shall be a complete type or
  \cv{}~\keyword{void}.  \\ \rowsep

\indexlibraryglobal{reference_constructs_from_temporary}%
\tcode{template<class T, class U>}\br
  \tcode{struct reference_constructs_from_temporary;} &
  \tcode{T} is a reference type, and
  the initialization \tcode{T t(\exposidnc{VAL}<U>);} is
  well-formed and binds \tcode{t} to
  a temporary object whose lifetime is extended\iref{class.temporary}.
  Access checking is performed as if in
  a context unrelated to \tcode{T} and \tcode{U}.
  Only the validity of the immediate context of
  the variable initialization is considered.
  \begin{tailnote}
  The initialization can result in effects such as
  the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such effects are not in the ``immediate context'' and
  can result in the program being ill-formed.
  \end{tailnote}
&
  \tcode{T} and \tcode{U} shall be
  complete types, \cv{}~\keyword{void}, or arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{reference_converts_from_temporary}%
\tcode{template<class T, class U>}\br
  \tcode{struct reference_converts_from_temporary;} &
  \tcode{T} is a reference type, and
  the initialization \tcode{T t = \exposidnc{VAL}<U>;}
  is well-formed and binds \tcode{t} to
  a temporary object whose lifetime is extended\iref{class.temporary}.
  Access checking is performed as if in
  a context unrelated to \tcode{T} and \tcode{U}.
  Only the validity of the immediate context of
  the variable initialization is considered.
  \begin{tailnote}
  The initialization can result in effects such as
  the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such effects are not in the ``immediate context'' and
  can result in the program being ill-formed.
  \end{tailnote}
&
  \tcode{T} and \tcode{U} shall be
  complete types, \cv{}~\keyword{void}, or arrays of unknown bound.  \\ \rowsep

\end{libreqtab3b}

\pnum
\begin{example}
\begin{codeblock}
is_const_v<const volatile int>      // \tcode{true}
is_const_v<const int*>              // \tcode{false}
is_const_v<const int&>              // \tcode{false}
is_const_v<int[3]>                  // \tcode{false}
is_const_v<const int[3]>            // \tcode{true}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
remove_const_t<const volatile int>  // \tcode{volatile int}
remove_const_t<const int* const>    // \tcode{const int*}
remove_const_t<const int&>          // \tcode{const int\&}
remove_const_t<const int[3]>        // \tcode{int[3]}
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// Given:
struct P final { };
union U1 { };
union U2 final { };

// the following assertions hold:
static_assert(!is_final_v<int>);
static_assert(is_final_v<P>);
static_assert(!is_final_v<U1>);
static_assert(is_final_v<U2>);
\end{codeblock}
\end{example}

\indexlibraryglobal{is_constructible}%
\pnum
The predicate condition for a template specialization
\tcode{is_constructible<T, Args...>} shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable \tcode{t}:

\begin{codeblock}
T t(declval<Args>()...);
\end{codeblock}

\begin{note}
These tokens are never interpreted as a function declaration.
\end{note}
Access checking is performed as if in a context unrelated to \tcode{T}
and any of the \tcode{Args}. Only the validity of the immediate context of the
variable initialization is considered.
\begin{note}
The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
``immediate context'' and can result in the program being ill-formed.
\end{note}

\indexlibraryglobal{has_unique_object_representations}%
\pnum
The predicate condition for a template specialization
\tcode{has_unique_object_representations<T>}
shall be satisfied if and only if
\begin{itemize}
\item \tcode{T} is trivially copyable, and
\item any two objects of type \tcode{T} with the same value
have the same object representation, where
\begin{itemize}
\item two objects of array or non-union class type are considered to have the same value
if their respective sequences of direct subobjects have the same values, and
\item two objects of union type are considered to have the same value
if they have the same active member and the corresponding members have the same value.
\end{itemize}
\end{itemize}
The set of scalar types for which this condition holds is
\impldef{which scalar types have unique object representations}.
\begin{note}
If a type has padding bits, the condition does not hold;
otherwise, the condition holds true for integral types.
\end{note}

\rSec2[meta.unary.prop.query]{Type property queries}

\pnum
The templates specified in \tref{meta.unary.prop.query}
may be used to query properties of types at compile time.

\begin{libreqtab2a}{Type property queries}{meta.unary.prop.query}
\\ \topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Value}    \\ \capsep
\endhead

\indexlibraryglobal{alignment_of}%
\tcode{template<class T>\br
 struct alignment_of;}      &
 \tcode{alignof(T)}.\br
 \mandates
 \tcode{alignof(T)} is a valid expression\iref{expr.alignof}  \\  \rowsep

\indexlibraryglobal{rank}%
\tcode{template<class T>\br
 struct rank;}      &
 If \tcode{T} is an array type, an integer value representing
 the number of dimensions of \tcode{T}; otherwise, 0. \\    \rowsep

\indexlibraryglobal{extent}%
\tcode{template<class T,\br
 unsigned I = 0>\br
 struct extent;}        &
 If \tcode{T} is not an array type, or if it has rank less
 than or equal to \tcode{I}, or if \tcode{I} is 0 and \tcode{T}
 has type ``array of unknown bound of \tcode{U}'', then
 0; otherwise, the bound\iref{dcl.array} of the $\tcode{I}^\text{th}$ dimension of
\tcode{T}, where indexing of \tcode{I} is zero-based \\
\end{libreqtab2a}

\pnum
Each of these templates shall be a \oldconcept{UnaryTypeTrait}\iref{meta.rqmts} with a
base characteristic of \tcode{integral_constant<size_t, Value>}.

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
static_assert(rank_v<int> == 0);
static_assert(rank_v<int[2]> == 1);
static_assert(rank_v<int[][4]> == 2);
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
static_assert(extent_v<int> == 0);
static_assert(extent_v<int[2]> == 2);
static_assert(extent_v<int[2][4]> == 2);
static_assert(extent_v<int[][4]> == 0);
static_assert(extent_v<int, 1> == 0);
static_assert(extent_v<int[2], 1> == 0);
static_assert(extent_v<int[2][4], 1> == 4);
static_assert(extent_v<int[][4], 1> == 4);
\end{codeblock}
\end{example}

\rSec2[meta.rel]{Relationships between types}

\pnum
The templates specified in \tref{meta.rel}
may be used to query relationships between types at compile time.

\pnum
Each of these templates shall be a
\oldconcept{BinaryTypeTrait}\iref{meta.rqmts}
with a base characteristic of
\tcode{true_type} if the corresponding condition is true, otherwise
\tcode{false_type}.

\begin{libreqtab3f}{Type relationship predicates}{meta.rel}
\\ \topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \chdr{Condition}    &   \rhdr{Comments} \\ \capsep
\endhead
\tcode{template<class T, class U>}\br
 \tcode{struct is_same;}                    &
 \tcode{T} and \tcode{U} name the same type with the same cv-qualifications                            &   \\ \rowsep

\indexlibraryglobal{is_base_of}%
\tcode{template<class Base, class Derived>}\br
 \tcode{struct is_base_of;}                 &
 \tcode{Base} is a base class of \tcode{Derived}\iref{class.derived}
 without regard to cv-qualifiers
 or \tcode{Base} and \tcode{Derived} are not unions and
 name the same class type
 without regard to cv-qualifiers            &
 If \tcode{Base} and
 \tcode{Derived} are non-union class types and are
 not (possibly cv-qualified versions of) the same type,
 \tcode{Derived} shall be a complete
 type.
 \begin{tailnote}
 Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes.
\end{tailnote}
\\ \rowsep

\indexlibraryglobal{is_virtual_base_of}%
\tcode{template<class Base, class Derived>}\br
 \tcode{struct is_virtual_base_of;}                 &
 \tcode{Base} is a virtual base class of \tcode{Derived}\iref{class.mi}
 without regard to cv-qualifiers.            &
 If \tcode{Base} and
 \tcode{Derived} are non-union class types,
 \tcode{Derived} shall be a complete type.
 \begin{note}
 Virtual base classes that are private, protected, or ambiguous
 are, nonetheless, virtual base classes.
 \end{note}
 \begin{tailnote}
 A class is never a virtual base class of itself.
 \end{tailnote}                                     \\ \rowsep

\indexlibraryglobal{is_convertible}%
\tcode{template<class From, class To>}\br
 \tcode{struct is_convertible;}             &
 \seebelow                                  &
 \tcode{From} and \tcode{To} shall be complete types,
 \cv{}~\keyword{void}, or arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{is_nothrow_convertible}%
\tcode{template<class From, class To>}\br
 \tcode{struct is_nothrow_convertible;}     &
 \tcode{is_convertible_v<From, To>} is \tcode{true} and
 the conversion, as defined by \tcode{is_convertible},
 is known not to throw any exceptions\iref{expr.unary.noexcept} &
 \tcode{From} and \tcode{To} shall be complete types,
 \cv{}~\keyword{void}, or arrays of unknown bound.  \\ \rowsep

\indexlibraryglobal{is_layout_compatible}%
\tcode{template<class T, class U>}\br
 \tcode{struct is_layout_compatible;}                 &
 \tcode{T} and \tcode{U} are layout-compatible\iref{term.layout.compatible.type}    &
 \tcode{T} and \tcode{U} shall be complete types,
 \cv{}~\keyword{void},
 or arrays of unknown bound.                \\ \rowsep

\indexlibraryglobal{is_pointer_interconvertible_base_of}%
\tcode{template<class Base, class Derived>}\br
 \tcode{struct is_pointer_interconvertible_base_of;}                 &
 \tcode{Derived} is unambiguously derived from \tcode{Base}
 without regard to cv-qualifiers,
 and each object of type \tcode{Derived}
 is pointer-interconvertible\iref{basic.compound} with
 its \tcode{Base} subobject,
 or \tcode{Base} and \tcode{Derived} are not unions
 and name the same class type
 without regard to cv-qualifiers.   &
 If \tcode{Base} and \tcode{Derived} are non-union class types
 and are not (possibly cv-qualified versions of) the same type,
 \tcode{Derived} shall be a complete type.  \\ \rowsep

\indexlibraryglobal{is_invocable}%
\tcode{template<class Fn, class... ArgTypes>}\br
 \tcode{struct is_invocable;}                      &
 The expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}\iref{func.require}
 is well-formed when treated as an unevaluated operand\iref{term.unevaluated.operand} &
 \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\keyword{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibraryglobal{is_invocable_r}%
\tcode{template<class R, class Fn, class... ArgTypes>}\br
 \tcode{struct is_invocable_r;}                      &
 The expression \tcode{\placeholdernc{INVOKE}<R>(declval<Fn>(), declval<ArgTypes>()...)}
 is well-formed when treated as an unevaluated operand                &
 \tcode{Fn}, \tcode{R}, and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\keyword{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibraryglobal{is_nothrow_invocable}%
\tcode{template<class Fn, class... ArgTypes>}\br
 \tcode{struct is_nothrow_invocable;}              &
 \tcode{is_invocable_v<}\br\tcode{Fn, ArgTypes...>} is \tcode{true} and
 the expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}
 is known not to throw any exceptions\iref{expr.unary.noexcept}       &
 \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\keyword{void}, or
 arrays of unknown bound.                                             \\ \rowsep

\indexlibraryglobal{is_nothrow_invocable_r}%
\tcode{template<class R, class Fn, class... ArgTypes>}\br
 \tcode{struct is_nothrow_invocable_r;}              &
 \tcode{is_invocable_r_v<}\br\tcode{R, Fn, ArgTypes...>} is \tcode{true} and
 the expression \tcode{\placeholdernc{INVOKE}<R>(declval<Fn>(), declval<ArgTypes>()...)}
 is known not to throw any exceptions\iref{expr.unary.noexcept}       &
 \tcode{Fn}, \tcode{R}, and all types in the template parameter pack \tcode{ArgTypes}
 shall be complete types, \cv{}~\keyword{void}, or
 arrays of unknown bound.                                             \\
\end{libreqtab3f}

\pnum
For the purpose of defining the templates in this subclause,
a function call expression \tcode{declval<T>()} for any type \tcode{T}
is considered to be a trivial\iref{term.trivial.type,special} function call
that is not an odr-use\iref{term.odr.use} of \tcode{declval}
in the context of the corresponding definition
notwithstanding the restrictions of~\ref{declval}.

\pnum
\begin{example}
\begin{codeblock}
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of_v<B, D>              // \tcode{true}
is_base_of_v<const B, D>        // \tcode{true}
is_base_of_v<B, const D>        // \tcode{true}
is_base_of_v<B, const B>        // \tcode{true}
is_base_of_v<D, B>              // \tcode{false}
is_base_of_v<B&, D&>            // \tcode{false}
is_base_of_v<B[3], D[3]>        // \tcode{false}
is_base_of_v<int, int>          // \tcode{false}
\end{codeblock}
\end{example}

\indexlibraryglobal{is_convertible}%
\pnum
The predicate condition for a template specialization \tcode{is_convertible<From, To>}
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:

\begin{codeblock}
To test() {
  return declval<From>();
}
\end{codeblock}

\begin{note}
This requirement gives well-defined results for reference types,
array types, function types, and \cv{}~\keyword{void}.
\end{note}
Access checking is performed
in a context unrelated to \tcode{To} and \tcode{From}. Only the validity of
the immediate context of the \grammarterm{expression} of the \tcode{return} statement\iref{stmt.return}
(including initialization of the returned object or reference) is considered.
\begin{note}
The
initialization can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the ``immediate context'' and can result in the program
being ill-formed.
\end{note}

\rSec2[meta.trans]{Transformations between types}

\rSec3[meta.trans.general]{General}
\pnum
Subclause \ref{meta.trans} contains templates that may be used to transform one
type to another following some predefined rule.

\pnum
Each of the templates in \ref{meta.trans} shall be a
\oldconcept{TransformationTrait}\iref{meta.rqmts}.

\rSec3[meta.trans.cv]{Const-volatile modifications}

\pnum
The templates specified in \tref{meta.trans.cv}
add or remove cv-qualifications\iref{basic.type.qualifier}.

\begin{libreqtab2a}{Const-volatile modifications}{meta.trans.cv}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibraryglobal{remove_const}%
\tcode{template<class T>\br
 struct remove_const;}                  &
 The member typedef \tcode{type} denotes the type formed
 by removing any top-level const-qualifier from \tcode{T}.
 \begin{tailexample}
\tcode{remove_const_t<const volatile int>} evaluates
 to \tcode{volatile int}, whereas \tcode{remove_const_t<const int*>} evaluates to
 \tcode{const int*}.
\end{tailexample}
\\  \rowsep

\indexlibraryglobal{remove_volatile}%
\tcode{template<class T>\br
 struct remove_volatile;}               &
 The member typedef \tcode{type} denotes the type formed
 by removing any top-level volatile-qualifier from \tcode{T}.
 \begin{tailexample}
\tcode{remove_volatile_t<const volatile int>}
 evaluates to \tcode{const int},
 whereas \tcode{remove_volatile_t<volatile int*>} evaluates to \tcode{volatile int*}.
 \end{tailexample}
\\  \rowsep

\indexlibraryglobal{remove_cv}%
\tcode{template<class T>\br
 struct remove_cv;}                 &
 The member typedef \tcode{type} denotes the type formed
 by removing any top-level cv-qualifiers from \tcode{T}.
 \begin{tailexample}
\tcode{remove_cv_t<const volatile int>}
 evaluates to \tcode{int}, whereas \tcode{remove_cv_t<const volatile int*>}
 evaluates to \tcode{const volatile int*}.
\end{tailexample}
\\  \rowsep

\indexlibraryglobal{add_const}%
\tcode{template<class T>\br
 struct add_const;}                 &
 If \tcode{T} is a reference, function, or top-level const-qualified
 type, then \tcode{type} denotes \tcode{T}, otherwise
 \tcode{T const}.                                                           \\  \rowsep

\indexlibraryglobal{add_volatile}%
\tcode{template<class T>\br
 struct add_volatile;}                  &
 If \tcode{T} is a reference, function, or top-level volatile-qualified
 type, then \tcode{type} denotes \tcode{T}, otherwise
 \tcode{T volatile}.                                                            \\  \rowsep

\indexlibraryglobal{add_cv}%
\tcode{template<class T>\br
 struct add_cv;}                    &
 The member typedef \tcode{type} denotes
 \tcode{add_const_t<add_volatile_t<T>>}.                               \\
\end{libreqtab2a}

\rSec3[meta.trans.ref]{Reference modifications}

\pnum
The templates specified in \tref{meta.trans.ref}
add or remove references.

\begin{libreqtab2a}{Reference modifications}{meta.trans.ref}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibraryglobal{remove_reference}%
\tcode{template<class T>\br
 struct remove_reference;}                  &
 If \tcode{T} has type ``reference to \tcode{T1}'' then the
 member typedef \tcode{type} denotes \tcode{T1};
 otherwise, \tcode{type} denotes \tcode{T}.\\ \rowsep

\indexlibraryglobal{add_lvalue_reference}%
\tcode{template<class T>\br
 struct add_lvalue_reference;}                     &
 If \tcode{T} is a referenceable type\iref{defns.referenceable} then
 the member typedef \tcode{type} denotes \tcode{T\&};
 otherwise, \tcode{type} denotes \tcode{T}.
 \begin{tailnote}
 This rule reflects the semantics of reference collapsing\iref{dcl.ref}.
 \end{tailnote}
\\ \rowsep

\indexlibraryglobal{add_rvalue_reference}%
\tcode{template<class T>}\br
 \tcode{struct add_rvalue_reference;}    &
 If \tcode{T} is a referenceable type then
 the member typedef \tcode{type} denotes \tcode{T\&\&};
 otherwise, \tcode{type} denotes \tcode{T}.
 \begin{tailnote}
This rule reflects the semantics of reference collapsing\iref{dcl.ref}.
 For example, when a type \tcode{T} is a reference type \tcode{T1\&},
 the type \tcode{add_rvalue_reference_t<T>} is not an rvalue reference.
 \end{tailnote}
\\
\end{libreqtab2a}

\rSec3[meta.trans.sign]{Sign modifications}

\pnum
The templates specified in \tref{meta.trans.sign}
convert an integer type to its corresponding signed or unsigned type.

\begin{libreqtab2a}{Sign modifications}{meta.trans.sign}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibraryglobal{make_signed}%
\tcode{template<class T>}\br
 \tcode{struct make_signed;} &
 If \tcode{T} is a (possibly cv-qualified) signed integer
 type\iref{basic.fundamental} then the member typedef
 \tcode{type} denotes \tcode{T}; otherwise,
 if \tcode{T} is a (possibly cv-qualified) unsigned integer
 type then \tcode{type} denotes the corresponding
 signed integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} denotes the signed integer type with smallest
 rank\iref{conv.rank} for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \mandates \tcode{T} is an integral or enumeration type
 other than \cv~\tcode{bool}.\\ \rowsep

\indexlibraryglobal{make_unsigned}%
\tcode{template<class T>}\br
 \tcode{struct make_unsigned;} &
 If \tcode{T} is a (possibly cv-qualified) unsigned integer
 type\iref{basic.fundamental} then the member typedef
 \tcode{type} denotes \tcode{T}; otherwise,
 if \tcode{T} is a (possibly cv-qualified) signed integer
 type then \tcode{type} denotes the corresponding
 unsigned integer type, with the same cv-qualifiers as \tcode{T};
 otherwise, \tcode{type} denotes the unsigned integer type with smallest
 rank\iref{conv.rank} for which
 \tcode{sizeof(T) == sizeof(type)}, with the same
 cv-qualifiers as \tcode{T}.\br
 \mandates \tcode{T} is an integral or enumeration type
 other than \cv~\tcode{bool}.\\
\end{libreqtab2a}

\rSec3[meta.trans.arr]{Array modifications}

\pnum
The templates specified in \tref{meta.trans.arr}
modify array types.

\begin{libreqtab2a}{Array modifications}{meta.trans.arr}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibraryglobal{remove_extent}%
\tcode{template<class T>\br
 struct remove_extent;}                 &
 If \tcode{T} is a type ``array of \tcode{U}'',
 the member typedef \tcode{type} denotes \tcode{U},
 otherwise \tcode{T}.
 \begin{tailnote}
For multidimensional arrays, only the first array dimension is
 removed. For a type ``array of \tcode{const U}'', the resulting type is
 \tcode{const U}.
\end{tailnote}
\\  \rowsep

\indexlibraryglobal{remove_all_extents}%
\tcode{template<class T>\br
 struct remove_all_extents;}                &
 If \tcode{T} is ``multidimensional array of \tcode{U}'', the resulting member
 typedef \tcode{type} denotes \tcode{U}, otherwise \tcode{T}.                                       \\
\end{libreqtab2a}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
static_assert(is_same_v<remove_extent_t<int>, int>);
static_assert(is_same_v<remove_extent_t<int[2]>, int>);
static_assert(is_same_v<remove_extent_t<int[2][3]>, int[3]>);
static_assert(is_same_v<remove_extent_t<int[][3]>, int[3]>);
\end{codeblock}
\end{example}

\pnum
\begin{example}
\begin{codeblock}
// the following assertions hold:
static_assert(is_same_v<remove_all_extents_t<int>, int>);
static_assert(is_same_v<remove_all_extents_t<int[2]>, int>);
static_assert(is_same_v<remove_all_extents_t<int[2][3]>, int>);
static_assert(is_same_v<remove_all_extents_t<int[][3]>, int>);
\end{codeblock}
\end{example}

\rSec3[meta.trans.ptr]{Pointer modifications}

\pnum
The templates specified in \tref{meta.trans.ptr}
add or remove pointers.

\begin{libreqtab2a}{Pointer modifications}{meta.trans.ptr}
\\ \topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template} &   \rhdr{Comments} \\ \capsep
\endhead

\indexlibraryglobal{remove_pointer}%
\tcode{template<class T>\br
 struct remove_pointer;}                    &
 If \tcode{T} has type ``(possibly cv-qualified) pointer
 to \tcode{T1}'' then the member typedef \tcode{type}
 denotes \tcode{T1}; otherwise, it denotes \tcode{T}.\\ \rowsep

\indexlibraryglobal{add_pointer}%
\tcode{template<class T>\br
 struct add_pointer;}                       &
 If \tcode{T} is a referenceable type\iref{defns.referenceable} or a
 \cv{}~\keyword{void} type then
 the member typedef \tcode{type} denotes
 \tcode{remove_reference_t<T>*};
 otherwise, \tcode{type} denotes \tcode{T}.             \\
\end{libreqtab2a}

\rSec3[meta.trans.other]{Other transformations}

\pnum
The templates specified in \tref{meta.trans.other}
perform other modifications of a type.

\begin{libreqtab2a}{Other transformations}{meta.trans.other}
\\ \topline
\lhdr{Template}   &   \rhdr{Comments} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Template}   &   \rhdr{Comments} \\ \capsep
\endhead

\tcode{template<class T>\br
 struct \libglobal{type_identity};}
 &
 The member typedef \tcode{type} denotes \tcode{T}. \\ \rowsep

\tcode{template<class T>\br struct \libglobal{remove_cvref};}
 &
 The member typedef \tcode{type} denotes
 \tcode{remove_cv_t<remove_reference_t<T>>}.
 \\ \rowsep

\tcode{template<class T>\br struct \libglobal{decay};}
 &
 Let \tcode{U} be \tcode{remove_reference_t<T>}. If \tcode{is_array_v<U>} is
 \tcode{true}, the member typedef \tcode{type} denotes
 \tcode{remove_extent_t<U>*}. If \tcode{is_function_v<U>} is \tcode{true},
 the member typedef \tcode{type} denotes \tcode{add_pointer_t<U>}. Otherwise
 the member typedef \tcode{type} denotes \tcode{remove_cv_t<U>}.
\begin{tailnote}
This behavior is similar to the lvalue-to-rvalue\iref{conv.lval},
array-to-pointer\iref{conv.array}, and function-to-pointer\iref{conv.func}
conversions applied when an lvalue is used as an rvalue, but also
strips cv-qualifiers from class types in order to more closely model by-value
argument passing.
\end{tailnote}
 \\ \rowsep

\tcode{template<bool B, class T = void>} \tcode{struct \libglobal{enable_if};}
 &
 If \tcode{B} is \tcode{true}, the member typedef \tcode{type}
 denotes \tcode{T}; otherwise, there shall be no member
 \tcode{type}. \\ \rowsep

\tcode{template<bool B, class T,}
 \tcode{class F>}\br
 \tcode{struct \libglobal{conditional};}
 &
 If \tcode{B} is \tcode{true},  the member typedef \tcode{type} denotes \tcode{T}.
 If \tcode{B} is \tcode{false}, the member typedef \tcode{type} denotes \tcode{F}. \\ \rowsep

 \tcode{template<class... T>} \tcode{struct common_type;}
 &
 Unless this trait is specialized,
 the member \tcode{type} is defined or omitted as specified below.
 If it is omitted, there shall be no member \tcode{type}.
 Each type in the template parameter pack \tcode{T} shall be
 complete, \cv{}~\keyword{void}, or an array of unknown bound. \\ \rowsep

\tcode{template<class, class,}
 \hspace*{2ex}\tcode{template<class> class,}
 \hspace*{2ex}\tcode{template<class> class>}
 \keyword{struct}
 \hspace*{2ex}\tcode{\libglobal{basic_common_reference};}
 &
 Unless this trait is specialized,
 there shall be no member \tcode{type}. \\ \rowsep

\tcode{template<class... T>} \tcode{struct \libglobal{common_reference};}
 &
 The member \grammarterm{typedef-name} \tcode{type} is defined or omitted
 as specified below. Each type in the parameter pack \tcode{T} shall
 be complete or \cv{} \keyword{void}. \\ \rowsep

\tcode{template<class T>}\br
 \tcode{struct \libglobal{underlying_type};}
 &
 If \tcode{T} is an enumeration type, the member typedef \tcode{type} denotes
 the underlying type of \tcode{T}\iref{dcl.enum};
 otherwise, there is no member \tcode{type}.\br
 \mandates \tcode{T} is not an incomplete enumeration type. \\ \rowsep

\tcode{template<class Fn,}\br
 \tcode{class... ArgTypes>}\br
 \tcode{struct \libglobal{invoke_result};}
 &
 If the expression \tcode{\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...)}\iref{func.require}
 is well-formed when treated as an unevaluated operand\iref{term.unevaluated.operand},
 the member typedef \tcode{type} denotes the type
 \tcode{decltype(\placeholdernc{INVOKE}(declval<Fn>(), declval<ArgTypes>()...))};
 otherwise, there shall be no member \tcode{type}. Access checking is
 performed as if in a context unrelated to \tcode{Fn} and
 \tcode{ArgTypes}. Only the validity of the immediate context of the
 expression is considered.
 \begin{note}
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the ``immediate
 context'' and can result in the program being ill-formed.
 \end{note}
 \expects \tcode{Fn} and all types in the template parameter pack \tcode{ArgTypes}
 are complete types, \cv{}~\keyword{void}, or arrays of
 unknown bound.\\ \rowsep

\tcode{template<class T>} \tcode{struct \libglobal{unwrap_reference};}
 &
 If \tcode{T} is
 a specialization \tcode{reference_wrapper<X>} for some type \tcode{X},
 the member typedef \tcode{type} of \tcode{unwrap_reference<T>}
 denotes \tcode{X\&},
 otherwise \tcode{type} denotes \tcode{T}. \\ \rowsep

\tcode{template<class T>} \tcode{\libglobal{unwrap_ref_decay};}
 &
 The member typedef \tcode{type} of \tcode{unwrap_ref_decay<T>}
 denotes the type \tcode{unwrap_reference_t<decay_t<T>>}.\\
\end{libreqtab2a}

\pnum
In addition to being available via inclusion
of the \tcode{<type_traits>} header, the templates
\tcode{unwrap_reference},
\tcode{unwrap_ref_decay},
\tcode{unwrap_reference_t}, and
\tcode{unwrap_ref_decay_t}
are available
when the header \tcode{<func\-tional>}\iref{functional.syn} is included.

\indexlibraryglobal{common_type}%
\pnum
Let:
\begin{itemize}
\item \tcode{\placeholdernc{CREF}(A)} be
  \tcode{add_lvalue_reference_t<const remove_reference_t<A>{}>},
\item \tcode{\placeholdernc{XREF}(A)} denote a unary alias template \tcode{T}
  such that \tcode{T<U>} denotes the same type as \tcode{U} with the addition
  of \tcode{A}'s cv and reference qualifiers, for a non-reference cv-unqualified
  type \tcode{U},
\item \tcode{\placeholdernc{COPYCV}(FROM, TO)} be an alias for type \tcode{TO}
  with the addition of \tcode{FROM}'s top-level cv-qualifiers,
  \begin{example}
    \tcode{\placeholdernc{COPYCV}(const int, volatile short)} is an alias for
    \tcode{const volatile short}.
  \end{example}
\item \tcode{\placeholdernc{COND-RES}(X, Y)} be
  \tcode{decltype(false ?\ declval<X(\&)()>()() :\ declval<Y(\&)()>()())}.
\end{itemize}
Given types \tcode{A} and \tcode{B},
let \tcode{X} be \tcode{remove_reference_t<A>},
let \tcode{Y} be \tcode{remove_reference_t<B>}, and
let \tcode{\placeholdernc{COMMON-\brk{}REF}(A, B)} be:
\begin{itemize}
\item If \tcode{A} and \tcode{B} are both lvalue reference types,
  \tcode{\placeholdernc{COMMON-REF}(A, B)} is
  \tcode{\placeholdernc{COND-RES}(\placeholdernc{COPYCV}(X, Y) \&,
    \placeholdernc{COPYCV}(\brk{}Y, X) \&)} if that type exists
  and is a reference type.
\item Otherwise, let \tcode{C} be
  \tcode{remove_reference_t<\placeholdernc{COMMON-REF}(X\&, Y\&)>\&\&}.
  If \tcode{A} and \tcode{B} are both rvalue reference types,
  \tcode{C} is well-formed, and
  \tcode{is_convertible_v<A, C> \&\& is_convertible_v<B, C>} is \tcode{true},
  then \tcode{\placeholdernc{COMMON-REF}(A, B)} is \tcode{C}.
\item Otherwise, let \tcode{D} be
  \tcode{\placeholdernc{COMMON-REF}(const X\&, Y\&)}. If \tcode{A} is an rvalue
  reference and \tcode{B} is an lvalue reference and \tcode{D} is
  well-formed and \tcode{is_convertible_v<A, D>} is
  \tcode{true}, then \tcode{\placeholdernc{COMMON-REF}(A, B)} is \tcode{D}.
\item Otherwise, if \tcode{A} is an lvalue reference and \tcode{B}
  is an rvalue reference, then \tcode{\placeholdernc{COMMON-REF}(A, B)} is
  \tcode{\placeholdernc{COMMON-REF}(B, A)}.
\item Otherwise, \tcode{\placeholdernc{COMMON-REF}(A, B)} is ill-formed.
\end{itemize}

If any of the types computed above is ill-formed, then
\tcode{\placeholdernc{COMMON-REF}(A, B)} is ill-formed.

\pnum
For the \tcode{common_type} trait applied to a template parameter pack \tcode{T} of types,
the member \tcode{type} shall be either defined or not present as follows:

\begin{itemize}
\item If \tcode{sizeof...(T)} is zero, there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is one, let \tcode{T0} denote the sole type
constituting the pack \tcode{T}.
The member \grammarterm{typedef-name} \tcode{type} shall denote the same
type, if any, as \tcode{common_type_t<T0, T0>};
otherwise there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is two,
let the first and second types constituting \tcode{T} be denoted
by \tcode{T1} and \tcode{T2}, respectively, and
let \tcode{D1} and \tcode{D2} denote
the same types as \tcode{decay_t<T1>} and \tcode{decay_t<T2>}, respectively.
  \begin{itemize}
  \item If \tcode{is_same_v<T1, D1>} is \tcode{false} or
     \tcode{is_same_v<T2, D2>} is \tcode{false},
     let \tcode{C} denote the same type, if any,
     as \tcode{common_type_t<D1, D2>}.
  \item
    \begin{note}
      None of the following will apply if there is a specialization
      \tcode{common_type<D1, D2>}.
    \end{note}
  \item Otherwise, if
\begin{codeblock}
decay_t<decltype(false ? declval<D1>() : declval<D2>())>
\end{codeblock}
    denotes a valid type, let \tcode{C} denote that type.
  \item Otherwise, if
    \tcode{\placeholdernc{COND-RES}(\placeholdernc{CREF}(D1),
      \placeholdernc{CREF}(D2))}
    denotes a type, let \tcode{C} denote the type
    \tcode{decay_t<\placeholdernc{COND-RES}(\placeholdernc{CREF}(D1),
      \placeholdernc{CREF}(D2))>}.
  \end{itemize}
In either case, the member \grammarterm{typedef-name} \tcode{type} shall denote
the same type, if any, as \tcode{C}.
Otherwise, there shall be no member \tcode{type}.

\item If \tcode{sizeof...(T)} is greater than two,
let \tcode{T1}, \tcode{T2}, and \tcode{R}, respectively,
denote the first, second, and (pack of) remaining types constituting \tcode{T}.
Let \tcode{C} denote the same type, if any, as \tcode{common_type_t<T1, T2>}.
If there is such a type \tcode{C}, the member \grammarterm{typedef-name} \tcode{type}
shall denote the same type, if any, as \tcode{common_type_t<C, R...>}.
Otherwise, there shall be no member \tcode{type}.
\end{itemize}

\pnum
Notwithstanding the provisions of \ref{meta.type.synop}, and
pursuant to \ref{namespace.std},
a program may specialize \tcode{common_type<T1, T2>}
for types \tcode{T1} and \tcode{T2} such that
\tcode{is_same_v<T1, decay_t<T1>>} and
\tcode{is_same_v<T2, decay_t<T2>>} are each \tcode{true}.
\begin{note}
Such specializations are needed when only explicit conversions
are desired between the template arguments.
\end{note}
Such a specialization need not have a member named \tcode{type},
but if it does,
the \grammarterm{qualified-id} \tcode{common_type<T1, T2>::type} shall denote
a cv-unqualified non-reference type
to which each of the types \tcode{T1} and \tcode{T2} is explicitly convertible.
Moreover, \tcode{common_type_t<T1, T2>} shall denote
the same type, if any, as does \tcode{common_type_t<T2, T1>}.
No diagnostic is required for a violation of this Note's rules.

\pnum
For the \tcode{common_reference} trait applied to a parameter pack
\tcode{T} of types, the member \tcode{type} shall be either defined or not
present as follows:
\begin{itemize}
\item If \tcode{sizeof...(T)} is zero, there shall be no member \tcode{type}.

\item Otherwise, if \tcode{sizeof...(T)} is one, let \tcode{T0} denote the sole
  type in the pack \tcode{T}. The member typedef \tcode{type} shall denote the
  same type as \tcode{T0}.

\item Otherwise, if \tcode{sizeof...(T)} is two, let \tcode{T1} and \tcode{T2}
  denote the two types in the pack \tcode{T}. Then
  \begin{itemize}
  \item Let \tcode{R} be \tcode{\placeholdernc{COMMON-REF}(T1, T2)}.
    If \tcode{T1} and \tcode{T2} are reference types,
    \tcode{R} is well-formed, and
    \tcode{is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> \&\& is_convertible_v<add_poin\linebreak{}ter_t<T2>, add_pointer_t<R>>} is \tcode{true},
    then the member typedef \tcode{type} denotes \tcode{R}.

  \item Otherwise, if
    \tcode{basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>,
      \brk{}\placeholdernc{XREF}(\brk{}T1), \placeholdernc{XREF}(T2)>::type}
    is well-formed, then the member typedef \tcode{type} denotes that type.

  \item Otherwise, if \tcode{\placeholdernc{COND-RES}(T1, T2)} is well-formed,
    then the member typedef \tcode{type} denotes that type.

  \item Otherwise, if \tcode{common_type_t<T1, T2>} is well-formed, then the
    member typedef \tcode{type} denotes that type.

  \item Otherwise, there shall be no member \tcode{type}.
  \end{itemize}

\item Otherwise, if \tcode{sizeof...(T)} is greater than two, let \tcode{T1},
  \tcode{T2}, and \tcode{Rest}, respectively, denote the first, second, and
  (pack of) remaining types comprising \tcode{T}. Let \tcode{C} be the type
  \tcode{common_reference_t<T1, T2>}. Then:
  \begin{itemize}
  \item If there is such a type \tcode{C}, the member typedef \tcode{type} shall
    denote the same type, if any, as \tcode{common_reference_t<C, Rest...>}.

  \item Otherwise, there shall be no member \tcode{type}.
  \end{itemize}
\end{itemize}

\pnum
Notwithstanding the provisions of \ref{meta.type.synop}, and
pursuant to \ref{namespace.std}, a program may partially specialize
\tcode{basic_common_reference<T, U, TQual, UQual>}
for types \tcode{T} and \tcode{U} such that
\tcode{is_same_v<T, decay_t<T>>} and
\tcode{is_same_v<U, decay_t<U>>} are each \tcode{true}.
\begin{note}
Such specializations
can be used to influence the result of \tcode{common_reference}, and
are needed when only explicit conversions are desired
between the template arguments.
\end{note}
Such a specialization need not have a member named \tcode{type}, but if it does,
the \grammarterm{qualified-id}
\tcode{basic_common_reference<T, U, TQual, UQual>::type}
shall denote a type
to which each of the types \tcode{TQual<T>} and
\tcode{UQual<U>} is convertible.
Moreover, \tcode{basic_common_reference<T, U, TQual, UQual>::type} shall denote
the same type, if any, as does
\tcode{basic_common_reference<U, T, UQual, TQual>::type}.
No diagnostic is required for a violation of these rules.

\pnum
\begin{example}
Given these definitions:
\begin{codeblock}
using PF1 = bool  (&)();
using PF2 = short (*)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&);
  void fn(long) const;
  char data;
};

using PMF = void (S::*)(long) const;
using PMD = char  S::*;
\end{codeblock}
the following assertions will hold:
\begin{codeblock}
static_assert(is_same_v<invoke_result_t<S, int>, short>);
static_assert(is_same_v<invoke_result_t<S&, unsigned char, int&>, double>);
static_assert(is_same_v<invoke_result_t<PF1>, bool>);
static_assert(is_same_v<invoke_result_t<PMF, unique_ptr<S>, int>, void>);
static_assert(is_same_v<invoke_result_t<PMD, S>, char&&>);
static_assert(is_same_v<invoke_result_t<PMD, const S*>, const char&>);
\end{codeblock}
\end{example}

\rSec2[meta.logical]{Logical operator traits}

\pnum
This subclause describes type traits for applying logical operators
to other type traits.

\indexlibraryglobal{conjunction}%
\begin{itemdecl}
template<class... B> struct conjunction : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{conjunction}
forms the logical conjunction of its template type arguments.

\pnum
For a specialization \tcode{conjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>},
if there is a template type argument $\tcode{B}_{i}$
for which \tcode{bool($\tcode{B}_{i}$::value)} is \tcode{false},
then instantiating \tcode{conjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>::value}
does not require the instantiation of \tcode{$\tcode{B}_{j}$::value} for $j > i$.
\begin{note}
This is analogous to the short-circuiting behavior of
the built-in operator \tcode{\&\&}.
\end{note}

\pnum
Every template type argument
for which \tcode{$\tcode{B}_{i}$::value} is instantiated
shall be usable as a base class and
shall have a member \tcode{value} which
is convertible to \tcode{bool},
is not hidden, and
is unambiguously available in the type.

\pnum
The specialization \tcode{conjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>}
has a public and unambiguous base that is either
\begin{itemize}
\item
the first type $\tcode{B}_{i}$ in the list \tcode{true_type, $\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$}
for which \tcode{bool($\tcode{B}_{i}$::value)} is \tcode{false}, or
\item
if there is no such $\tcode{B}_{i}$, the last type in the list.
\end{itemize}
\begin{note}
This means a specialization of \tcode{conjunction}
does not necessarily inherit from
either \tcode{true_type} or \tcode{false_type}.
\end{note}

\pnum
The member names of the base class, other than \tcode{conjunction} and
\tcode{operator=}, shall not be hidden and shall be unambiguously available
in \tcode{conjunction}.
\end{itemdescr}

\indexlibraryglobal{disjunction}%
\begin{itemdecl}
template<class... B> struct disjunction : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{disjunction}
forms the logical disjunction of its template type arguments.

\pnum
For a specialization \tcode{disjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>},
if there is a template type argument $\tcode{B}_{i}$
for which \tcode{bool($\tcode{B}_{i}$::value)} is \tcode{true},
then instantiating \tcode{disjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>::value}
does not require the instantiation of \tcode{$\tcode{B}_{j}$::value} for $j > i$.
\begin{note}
This is analogous to the short-circuiting behavior of
the built-in operator \tcode{||}.
\end{note}

\pnum
Every template type argument
for which \tcode{$\tcode{B}_{i}$::value} is instantiated
shall be usable as a base class and
shall have a member \tcode{value} which
is convertible to \tcode{bool},
is not hidden, and
is unambiguously available in the type.

\pnum
The specialization \tcode{disjunction<$\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$>}
has a public and unambiguous base that is either
\begin{itemize}
\item the first type $\tcode{B}_{i}$ in the list \tcode{false_type, $\tcode{B}_{1}$, $\dotsc$, $\tcode{B}_{N}$}
for which \tcode{bool($\tcode{B}_{i}$::value)} is \tcode{true}, or
\item if there is no such $\tcode{B}_{i}$, the last type in the list.
\end{itemize}
\begin{note}
This means a specialization of \tcode{disjunction}
does not necessarily inherit from
either \tcode{true_type} or \tcode{false_type}.
\end{note}

\pnum
The member names of the base class,
other than \tcode{disjunction} and \tcode{operator=},
shall not be hidden and shall be unambiguously available in \tcode{disjunction}.
\end{itemdescr}

\indexlibraryglobal{negation}%
\begin{itemdecl}
template<class B> struct negation : @\seebelow@ { };
\end{itemdecl}

\begin{itemdescr}
\pnum
The class template \tcode{negation}
forms the logical negation of its template type argument.
The type \tcode{negation<B>}
is a \oldconcept{UnaryTypeTrait} with a base characteristic of \tcode{bool_constant<!bool(B::\brk{}value)>}.
\end{itemdescr}

\rSec2[meta.member]{Member relationships}

\indexlibraryglobal{is_pointer_interconvertible_with_class}
\begin{itemdecl}
template<class S, class M>
  constexpr bool is_pointer_interconvertible_with_class(M S::*m) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{S} is a complete type.

\pnum
\returns
\tcode{true} if and only if
 \tcode{S} is a standard-layout type,
 \tcode{M} is an object type,
 \tcode{m} is not null,
 and each object \tcode{s} of type \tcode{S}
 is pointer-interconvertible\iref{basic.compound}
 with its subobject \tcode{s.*m}.
\end{itemdescr}

\indexlibraryglobal{is_corresponding_member}
\begin{itemdecl}
template<class S1, class S2, class M1, class M2>
  constexpr bool is_corresponding_member(M1 S1::*m1, M2 S2::*m2) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{S1} and \tcode{S2} are complete types.

\pnum
\returns
\tcode{true} if and only if
 \tcode{S1} and \tcode{S2} are standard-layout struct\iref{class.prop} types,
 \tcode{M1} and \tcode{M2} are object types,
 \tcode{m1} and \tcode{m2} are not null,
 and \tcode{m1} and \tcode{m2} point to corresponding members of
 the common initial sequence\iref{class.mem} of \tcode{S1} and \tcode{S2}.
\end{itemdescr}

\pnum
\begin{note}
The type of a pointer-to-member expression \tcode{\&C::b}
is not always a pointer to member of \tcode{C},
leading to potentially surprising results
when using these functions in conjunction with inheritance.
\begin{example}
\begin{codeblock}
struct A { int a; };                    // a standard-layout class
struct B { int b; };                    // a standard-layout class
struct C: public A, public B { };       // not a standard-layout class

static_assert( is_pointer_interconvertible_with_class( &C::b ) );
  // Succeeds because, despite its appearance, \tcode{\&C::b} has type
  // ``pointer to member of \tcode{B} of type \tcode{int}''.
static_assert( is_pointer_interconvertible_with_class<C>( &C::b ) );
  // Forces the use of class \tcode{C}, and fails.

static_assert( is_corresponding_member( &C::a, &C::b ) );
  // Succeeds because, despite its appearance, \tcode{\&C::a} and \tcode{\&C::b} have types
  // ``pointer to member of \tcode{A} of type \tcode{int}'' and
  // ``pointer to member of \tcode{B} of type \tcode{int}'', respectively.
static_assert( is_corresponding_member<C, C>( &C::a, &C::b ) );
  // Forces the use of class \tcode{C}, and fails.
\end{codeblock}
\end{example}
\end{note}

\rSec2[meta.const.eval]{Constant evaluation context}

\indexlibraryglobal{is_constant_evaluated}%
\begin{itemdecl}
constexpr bool is_constant_evaluated() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if consteval {
  return true;
} else {
  return false;
}
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
constexpr void f(unsigned char *p, int n) {
  if (std::is_constant_evaluated()) {           // should not be a constexpr if statement
    for (int k = 0; k<n; ++k) p[k] = 0;
  } else {
    memset(p, 0, n);                            // not a core constant expression
  }
}
\end{codeblock}
\end{example}
\end{itemdescr}

\indexlibraryglobal{is_within_lifetime}%
\begin{itemdecl}
consteval bool is_within_lifetime(const auto* p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true} if \tcode{p} is a pointer to an object that is
within its lifetime\iref{basic.life}; otherwise, \tcode{false}.

\pnum
\remarks
During the evaluation of an expression \tcode{E} as a core constant expression,
a call to this function is ill-formed
unless \tcode{p} points to an object that is usable
in constant expressions or
whose complete object's lifetime began within \tcode{E}.

\pnum
\begin{example}
\begin{codeblock}
struct OptBool {
  union { bool b; char c; };

  // note: this assumes common implementation properties for \tcode{bool} and \tcode{char}:
  // * \tcode{sizeof(bool) == sizeof(char)}, and
  // * the value representations for \tcode{true} and \tcode{false} are distinct
  //   from the value representation for \tcode{2}
  constexpr OptBool() : c(2) { }
  constexpr OptBool(bool b) : b(b) { }

  constexpr auto has_value() const -> bool {
    if consteval {
      return std::is_within_lifetime(&b);       // during constant evaluation, cannot read from \tcode{c}
    } else {
      return c != 2;                            // during runtime, must read from \tcode{c}
    }
  }

  constexpr auto operator*() const -> const bool& {
    return b;
  }
};

constexpr OptBool disengaged;
constexpr OptBool engaged(true);
static_assert(!disengaged.has_value());
static_assert(engaged.has_value());
static_assert(*engaged);
\end{codeblock}
\end{example}
\end{itemdescr}

\rSec1[ratio]{Compile-time rational arithmetic}

\rSec2[ratio.general]{General}

\pnum
\indexlibraryglobal{ratio}%
Subclause~\ref{ratio} describes the ratio library. It provides a class template
\tcode{ratio} which exactly represents any finite rational number with a
numerator and denominator representable by compile-time constants of type
\tcode{intmax_t}.

\pnum
Throughout subclause~\ref{ratio}, the names of template parameters are used to express
type requirements. If a template parameter is named \tcode{R1} or \tcode{R2},
and the template argument is not a specialization of the \tcode{ratio} template,
the program is ill-formed.

\rSec2[ratio.syn]{Header \tcode{<ratio>} synopsis}

\indexheader{ratio}%
\begin{codeblockdigitsep}
// all freestanding
namespace std {
  // \ref{ratio.ratio}, class template \tcode{ratio}
  template<intmax_t N, intmax_t D = 1> class ratio;

  // \ref{ratio.arithmetic}, ratio arithmetic
  template<class R1, class R2> using ratio_add = @\seebelow@;
  template<class R1, class R2> using ratio_subtract = @\seebelow@;
  template<class R1, class R2> using ratio_multiply = @\seebelow@;
  template<class R1, class R2> using ratio_divide = @\seebelow@;

  // \ref{ratio.comparison}, ratio comparison
  template<class R1, class R2> struct ratio_equal;
  template<class R1, class R2> struct ratio_not_equal;
  template<class R1, class R2> struct ratio_less;
  template<class R1, class R2> struct ratio_less_equal;
  template<class R1, class R2> struct ratio_greater;
  template<class R1, class R2> struct ratio_greater_equal;

  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_equal_v}@ = ratio_equal<R1, R2>::value;
  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_not_equal_v}@ = ratio_not_equal<R1, R2>::value;
  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_less_v}@ = ratio_less<R1, R2>::value;
  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_less_equal_v}@ = ratio_less_equal<R1, R2>::value;
  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_greater_v}@ = ratio_greater<R1, R2>::value;
  template<class R1, class R2>
    constexpr bool @\libglobal{ratio_greater_equal_v}@ = ratio_greater_equal<R1, R2>::value;

  // \ref{ratio.si}, convenience SI typedefs
  using @\libglobal{quecto}@ = ratio<1, 1'000'000'000'000'000'000'000'000'000'000>;     // \seebelow
  using @\libglobal{ronto}@  = ratio<1,     1'000'000'000'000'000'000'000'000'000>;     // \seebelow
  using @\libglobal{yocto}@  = ratio<1,         1'000'000'000'000'000'000'000'000>;     // \seebelow
  using @\libglobal{zepto}@  = ratio<1,             1'000'000'000'000'000'000'000>;     // \seebelow
  using @\libglobal{atto}@   = ratio<1,                 1'000'000'000'000'000'000>;
  using @\libglobal{femto}@  = ratio<1,                     1'000'000'000'000'000>;
  using @\libglobal{pico}@   = ratio<1,                         1'000'000'000'000>;
  using @\libglobal{nano}@   = ratio<1,                             1'000'000'000>;
  using @\libglobal{micro}@  = ratio<1,                                 1'000'000>;
  using @\libglobal{milli}@  = ratio<1,                                     1'000>;
  using @\libglobal{centi}@  = ratio<1,                                       100>;
  using @\libglobal{deci}@   = ratio<1,                                        10>;
  using @\libglobal{deca}@   = ratio<                                       10, 1>;
  using @\libglobal{hecto}@  = ratio<                                      100, 1>;
  using @\libglobal{kilo}@   = ratio<                                    1'000, 1>;
  using @\libglobal{mega}@   = ratio<                                1'000'000, 1>;
  using @\libglobal{giga}@   = ratio<                            1'000'000'000, 1>;
  using @\libglobal{tera}@   = ratio<                        1'000'000'000'000, 1>;
  using @\libglobal{peta}@   = ratio<                    1'000'000'000'000'000, 1>;
  using @\libglobal{exa}@    = ratio<                1'000'000'000'000'000'000, 1>;
  using @\libglobal{zetta}@  = ratio<            1'000'000'000'000'000'000'000, 1>;     // \seebelow
  using @\libglobal{yotta}@  = ratio<        1'000'000'000'000'000'000'000'000, 1>;     // \seebelow
  using @\libglobal{ronna}@  = ratio<    1'000'000'000'000'000'000'000'000'000, 1>;     // \seebelow
  using @\libglobal{quetta}@ = ratio<1'000'000'000'000'000'000'000'000'000'000, 1>;     // \seebelow
}
\end{codeblockdigitsep}

\rSec2[ratio.ratio]{Class template \tcode{ratio}}

\indexlibraryglobal{ratio}%
\begin{codeblock}
namespace std {
  template<intmax_t N, intmax_t D = 1> class ratio {
  public:
    static constexpr intmax_t num;
    static constexpr intmax_t den;
    using type = ratio<num, den>;
  };
}
\end{codeblock}

\pnum
\indextext{signed integer representation!two's complement}%
If the template argument \tcode{D} is zero or the absolute values of either of the
template arguments \tcode{N} and \tcode{D} is not representable by type
\tcode{intmax_t}, the program is ill-formed.
\begin{note}
These rules ensure that infinite
ratios are avoided and that for any negative input, there exists a representable value
of its absolute value which is positive.
This excludes the most negative value.
\end{note}

\pnum
The static data members \tcode{num} and \tcode{den} shall have the following values,
where \tcode{gcd} represents the greatest common divisor of the absolute values of
\tcode{N} and \tcode{D}:

\begin{itemize}
\item \tcode{num} shall have the value \tcode{$\operatorname{sgn}(\tcode{N})$ * $\operatorname{sgn}(\tcode{D})$ * abs(N) / gcd}.
\item \tcode{den} shall have the value \tcode{abs(D) / gcd}.
\end{itemize}

\rSec2[ratio.arithmetic]{Arithmetic on \tcode{ratio}{s}}

\pnum
\indexlibraryglobal{ratio_add}%
\indexlibraryglobal{ratio_subtract}%
\indexlibraryglobal{ratio_multiply}%
\indexlibraryglobal{ratio_divide}%
Each of the alias templates \tcode{ratio_add}, \tcode{ratio_subtract}, \tcode{ratio_multiply},
and \tcode{ratio_divide} denotes the result of an arithmetic computation on two
\tcode{ratio}{s} \tcode{R1} and \tcode{R2}. With \tcode{X} and \tcode{Y} computed (in the
absence of arithmetic overflow) as specified by \tref{ratio.arithmetic}, each alias
denotes a \tcode{ratio<U, V>} such that \tcode{U} is the same as \tcode{ratio<X, Y>::num} and
\tcode{V} is the same as \tcode{ratio<X, Y>::den}.

\pnum
If it is not possible to represent \tcode{U} or \tcode{V} with \tcode{intmax_t}, the program is
ill-formed. Otherwise, an implementation should yield correct values of \tcode{U} and
\tcode{V}. If it is not possible to represent \tcode{X} or \tcode{Y} with \tcode{intmax_t}, the
program is ill-formed unless the implementation yields correct values of \tcode{U} and
\tcode{V}.

\begin{floattable}{Expressions used to perform ratio arithmetic}{ratio.arithmetic}
{lll}
\topline
\lhdr{Type}                     &
  \chdr{Value of \tcode{X}}     &
  \rhdr{Value of \tcode{Y}}     \\ \rowsep

\tcode{ratio_add<R1, R2>}       &
  \tcode{R1::num * R2::den +}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_subtract<R1, R2>}  &
  \tcode{R1::num * R2::den -}   &
  \tcode{R1::den * R2::den}     \\
                                &
  \tcode{R2::num * R1::den}     &
                                \\ \rowsep

\tcode{ratio_multiply<R1, R2>}  &
  \tcode{R1::num * R2::num}     &
  \tcode{R1::den * R2::den}     \\ \rowsep

\tcode{ratio_divide<R1, R2>}    &
  \tcode{R1::num * R2::den}     &
  \tcode{R1::den * R2::num}     \\
\end{floattable}

\pnum
\begin{example}
\begin{codeblock}
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::den == 2, "1/3*3/2 == 1/2");

// The following cases may cause the program to be ill-formed under some implementations
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::num == 2,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::den == INT_MAX,
  "1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::num == 1,
  "1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::den == 2,
  "1/MAX * MAX/2 == 1/2");
\end{codeblock}

\end{example}

\rSec2[ratio.comparison]{Comparison of \tcode{ratio}{s}}

\indexlibraryglobal{ratio_equal}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_equal : bool_constant<R1::num == R2::num && R1::den == R2::den> { };
\end{itemdecl}

\indexlibraryglobal{ratio_not_equal}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_not_equal : bool_constant<!ratio_equal_v<R1, R2>> { };
\end{itemdecl}

\indexlibraryglobal{ratio_less}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_less : bool_constant<@\seebelow@> { };
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{R1::num} $\times$ \tcode{R2::den} is less than \tcode{R2::num} $\times$ \tcode{R1::den},
\tcode{ratio_less<R1, R2>} shall be
derived from \tcode{bool_constant<true>}; otherwise it shall be derived from
\tcode{bool_constant<false>}. Implementations may use other algorithms to
compute this relationship to avoid overflow. If overflow occurs, the program is ill-formed.
\end{itemdescr}

\indexlibraryglobal{ratio_less_equal}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_less_equal : bool_constant<!ratio_less_v<R2, R1>> { };
\end{itemdecl}

\indexlibraryglobal{ratio_greater}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_greater : bool_constant<ratio_less_v<R2, R1>> { };
\end{itemdecl}

\indexlibraryglobal{ratio_greater_equal}%
\begin{itemdecl}
template<class R1, class R2>
  struct ratio_greater_equal : bool_constant<!ratio_less_v<R1, R2>> { };
\end{itemdecl}

\rSec2[ratio.si]{SI types for \tcode{ratio}}

\pnum
\indexlibraryglobal{quecto}%
\indexlibraryglobal{ronto}%
\indexlibraryglobal{yocto}%
\indexlibraryglobal{zepto}%
\indexlibraryglobal{zetta}%
\indexlibraryglobal{yotta}%
\indexlibraryglobal{ronna}%
\indexlibraryglobal{quetta}%
For each of the \grammarterm{typedef-name}{s}
\tcode{quecto}, \tcode{ronto},
\tcode{yocto}, \tcode{zepto},
\tcode{zetta}, \tcode{yotta},
\tcode{ronna}, and \tcode{quetta},
if both of the constants used in its
specification are representable by \tcode{intmax_t}, the typedef is
defined; if either of the constants is not representable by \tcode{intmax_t},
the typedef is not defined.
